{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13426719",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719",
    "key": "ARROW-15582",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351947",
                "id": "12351947",
                "description": "",
                "name": "10.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-10-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available",
            "substrait"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 46200,
            "total": 46200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 46200,
            "total": 46200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15582/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 77,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/776934",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg opened a new pull request, #13285:\nURL: https://github.com/apache/arrow/pull/13285\n\n   **[WIP]**\r\n   This PR adds function mappings for compute functions from substrait to arrow and vice-versa. This introduces a `FunctionMapping` class to register and store the mappings and supply when required. Registering a function includes encoding the various options and arguments in the respective mapping function's definition.\n\n\n",
                    "created": "2022-06-01T15:07:58.777+0000",
                    "updated": "2022-06-01T15:07:58.777+0000",
                    "started": "2022-06-01T15:07:58.777+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "776934",
                    "issueId": "13426719"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/776951",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13285:\nURL: https://github.com/apache/arrow/pull/13285#issuecomment-1143753348\n\n   https://issues.apache.org/jira/browse/ARROW-15582\n\n\n",
                    "created": "2022-06-01T15:25:09.188+0000",
                    "updated": "2022-06-01T15:25:09.188+0000",
                    "started": "2022-06-01T15:25:09.188+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "776951",
                    "issueId": "13426719"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/776952",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13285:\nURL: https://github.com/apache/arrow/pull/13285#issuecomment-1143753378\n\n   :warning: Ticket **has not been started in JIRA**, please click 'Start Progress'.\n\n\n",
                    "created": "2022-06-01T15:25:11.414+0000",
                    "updated": "2022-06-01T15:25:11.414+0000",
                    "started": "2022-06-01T15:25:11.414+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "776952",
                    "issueId": "13426719"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/777269",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg commented on code in PR #13285:\nURL: https://github.com/apache/arrow/pull/13285#discussion_r887532254\n\n\n##########\ncpp/src/arrow/engine/substrait/expression_internal.cc:\n##########\n@@ -159,21 +159,11 @@ Result<compute::Expression> FromProto(const substrait::Expression& expr,\n \n       ARROW_ASSIGN_OR_RAISE(auto decoded_function,\n                             ext_set.DecodeFunction(scalar_fn.function_reference()));\n+      \n+      auto arrow_function = ext_set.functions_map.GetArrowFromSubstrait(static_cast<std::string>(decoded_function.name));\n\nReview Comment:\n   Can use `to_string()` here\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.h:\n##########\n@@ -228,6 +250,8 @@ class ARROW_ENGINE_EXPORT ExtensionSet {\n   /// future; see ARROW-15583.\n   std::size_t num_functions() const { return functions_.size(); }\n \n+  arrow::engine::FunctionMapping functions_map;\n\nReview Comment:\n   Will keep this in Extension Registry\n\n\n\n",
                    "created": "2022-06-02T03:43:20.281+0000",
                    "updated": "2022-06-02T03:43:20.281+0000",
                    "started": "2022-06-02T03:43:20.281+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "777269",
                    "issueId": "13426719"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/777279",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg commented on code in PR #13285:\nURL: https://github.com/apache/arrow/pull/13285#discussion_r887556309\n\n\n##########\ncpp/src/arrow/engine/substrait/expression_internal.cc:\n##########\n@@ -159,21 +159,11 @@ Result<compute::Expression> FromProto(const substrait::Expression& expr,\n \n       ARROW_ASSIGN_OR_RAISE(auto decoded_function,\n                             ext_set.DecodeFunction(scalar_fn.function_reference()));\n+      \n+      auto arrow_function = ext_set.functions_map.GetArrowFromSubstrait(static_cast<std::string>(decoded_function.name));\n\nReview Comment:\n   Made the change.\n\n\n\n",
                    "created": "2022-06-02T04:53:16.938+0000",
                    "updated": "2022-06-02T04:53:16.938+0000",
                    "started": "2022-06-02T04:53:16.937+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "777279",
                    "issueId": "13426719"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/777280",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg commented on code in PR #13285:\nURL: https://github.com/apache/arrow/pull/13285#discussion_r887556447\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.h:\n##########\n@@ -228,6 +250,8 @@ class ARROW_ENGINE_EXPORT ExtensionSet {\n   /// future; see ARROW-15583.\n   std::size_t num_functions() const { return functions_.size(); }\n \n+  arrow::engine::FunctionMapping functions_map;\n\nReview Comment:\n   Moved to ExtensionRegistry\n\n\n\n",
                    "created": "2022-06-02T04:53:37.021+0000",
                    "updated": "2022-06-02T04:53:37.021+0000",
                    "started": "2022-06-02T04:53:37.021+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "777280",
                    "issueId": "13426719"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/777286",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13285:\nURL: https://github.com/apache/arrow/pull/13285#discussion_r887579756\n\n\n##########\ncpp/src/arrow/engine/substrait/expression_internal.cc:\n##########\n@@ -159,21 +159,11 @@ Result<compute::Expression> FromProto(const substrait::Expression& expr,\n \n       ARROW_ASSIGN_OR_RAISE(auto decoded_function,\n                             ext_set.DecodeFunction(scalar_fn.function_reference()));\n+      \n+      auto arrow_function = ext_set.GetFunctionMap().GetArrowFromSubstrait(decoded_function.name.to_string());\n \n-      std::vector<compute::Expression> arguments(scalar_fn.args_size());\n-      for (int i = 0; i < scalar_fn.args_size(); ++i) {\n-        ARROW_ASSIGN_OR_RAISE(arguments[i], FromProto(scalar_fn.args(i), ext_set));\n-      }\n+      return arrow_function(scalar_fn);                      \n\nReview Comment:\n   What happens if `arrow_function` is not found?\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -351,5 +355,278 @@ ExtensionIdRegistry* default_extension_id_registry() {\n   return &impl_;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+  }\n+  return Status::OK();\n+}\n+\n+Status FunctionMapping::AddSubstraitToArrow(std::string substrait_function_name, SubstraitToArrow conversion_func){\n+  if (substrait_to_arrow.find(substrait_function_name) != substrait_to_arrow.end()){\n+    substrait_to_arrow[substrait_function_name] =  conversion_func;\n+  }\n+  return Status::OK();\n+}\n+\n+SubstraitToArrow substrait_add_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto value_1 = call.args(1);\n+  auto value_2 = call.args(2);\n+  ExtensionSet ext_set_;\n+  ARROW_ASSIGN_OR_RAISE(auto expression_1, FromProto(value_1, ext_set_));\n+  ARROW_ASSIGN_OR_RAISE(auto expression_2, FromProto(value_2, ext_set_));\n+  auto options = call.args(0);\n+  if (options.has_enum_()) {\n+    auto overflow_handling = options.enum_();\n+    if(overflow_handling.has_specified()){\n+    std::string overflow_type = overflow_handling.specified();\n+    if(overflow_type == \"SILENT\"){\n+      return arrow::compute::call(\"add\", {expression_1,expression_2}, compute::ArithmeticOptions());\n+    } else if (overflow_type == \"SATURATE\") {\n+      return Status::Invalid(\"Arrow does not support a saturating add\");\n+    } else {\n+      return arrow::compute::call(\"add_checked\", {expression_1,expression_2}, compute::ArithmeticOptions(true));\n+    }\n+  } else {\n+    return arrow::compute::call(\"add\", {expression_1,expression_2}, compute::ArithmeticOptions());\n+  }\n+  } else {\n+      return Status::Invalid(\"Substrait Function Options should be an enum\");\n+  }\n+};\n+\n+ArrowToSubstrait arrow_add_to_substrait = [] (const arrow::compute::Expression::Call& call, arrow::engine::ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  \n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"add\"));\n+  substrait_call.set_function_reference(function_reference);\n+\n+  substrait::Expression::Enum options;\n+  std::string overflow_handling = \"ERROR\";\n+  options.set_specified(overflow_handling);\n+  substrait_call.add_args()->set_allocated_enum_(&options);\n+  \n+  auto expression_1 = call.arguments[0];\n+  auto expression_2 = call.arguments[1];\n+  \n+  ARROW_ASSIGN_OR_RAISE(auto value_1, ToProto(expression_1, ext_set_));\n+  ARROW_ASSIGN_OR_RAISE(auto value_2, ToProto(expression_2, ext_set_));\n+\n+  substrait_call.add_args()->CopyFrom(*value_1);\n+  substrait_call.add_args()->CopyFrom(*value_2);\n+  return std::move(substrait_call);\n+};\n+\n+ArrowToSubstrait arrow_unchecked_add_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  \n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"add\"));\n+  substrait_call.set_function_reference(function_reference);\n+\n+  substrait::Expression::Enum options;\n+  std::string overflow_handling = \"SILENT\";\n+  options.set_specified(overflow_handling);\n+  substrait_call.add_args()->set_allocated_enum_(&options);\n+  \n+  auto expression_1 = call.arguments[0];\n+  auto expression_2 = call.arguments[1];\n+  \n+  ARROW_ASSIGN_OR_RAISE(auto value_1, ToProto(expression_1, ext_set_));\n+  ARROW_ASSIGN_OR_RAISE(auto value_2, ToProto(expression_2, ext_set_));\n+\n+  substrait_call.add_args()->CopyFrom(*value_1);\n+  substrait_call.add_args()->CopyFrom(*value_2);\n+  return std::move(substrait_call);\n+};\n+\n+\n+// Boolean Functions mapping\n+SubstraitToArrow substrait_not_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto value_1 = call.args(1);\n+  ExtensionSet ext_set_;\n+  ARROW_ASSIGN_OR_RAISE(auto expression_1, FromProto(value_1, ext_set_));\n+  return arrow::compute::call(\"invert\", {expression_1});\n+};\n+\n+SubstraitToArrow substrait_or_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  int num_args = call.args_size();  // OR function has variadic arguments\n+  substrait::Expression value;\n+  ExtensionSet ext_set_;\n+  arrow::compute::Expression expression;\n+  std::vector<arrow::compute::Expression> func_args;\n+  for(int i=0; i<num_args; ++i){\n+    value = call.args(i);\n+    ARROW_ASSIGN_OR_RAISE(expression, FromProto(value, ext_set_));\n+    func_args.push_back(expression);\n+  }\n+  return arrow::compute::call(\"or_kleene\", func_args);\n+};\n+\n+SubstraitToArrow substrait_and_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  int num_args = call.args_size();  // AND function has variadic arguments\n+  substrait::Expression value;\n+  ExtensionSet ext_set_;\n+  arrow::compute::Expression expression;\n+  std::vector<arrow::compute::Expression> func_args;\n+  for(int i=0; i<num_args; ++i){\n+    value = call.args(i);\n+    ARROW_ASSIGN_OR_RAISE(expression, FromProto(value, ext_set_));\n+    func_args.push_back(expression);\n+  }\n+  return arrow::compute::call(\"and_kleene\", func_args);\n+};\n+\n+SubstraitToArrow substrait_xor_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto value_1 = call.args(0);\n+  auto value_2 = call.args(1);\n+  ExtensionSet ext_set_;\n+  ARROW_ASSIGN_OR_RAISE(auto expression_1, FromProto(value_1, ext_set_));\n+  ARROW_ASSIGN_OR_RAISE(auto expression_2, FromProto(value_2, ext_set_));\n+  return arrow::compute::call(\"xor\", {expression_1, expression_2});\n+};\n+\n+ArrowToSubstrait arrow_invert_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  \n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"not\"));\n+  substrait_call.set_function_reference(function_reference);\n+  \n+  auto expression_1 = call.arguments[0];\n+  auto expression_2 = call.arguments[1];\n+  \n+  ARROW_ASSIGN_OR_RAISE(auto value_1, ToProto(expression_1, ext_set_));\n+  ARROW_ASSIGN_OR_RAISE(auto value_2, ToProto(expression_2, ext_set_));\n+\n+  substrait_call.add_args()->CopyFrom(*value_1);\n+  substrait_call.add_args()->CopyFrom(*value_2);\n+  return std::move(substrait_call);\n+\n+};\n\nReview Comment:\n   Several functions map exactly and fit this simple pattern.  Can we create a helper method for:\r\n   \r\n    * Grab all arguments from Arrow call\r\n    * Convert all arguments to Substrait expressions\r\n    * Create Substrait call\r\n    \r\n   Then all we should need to specify is the substrait function name.\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -351,5 +355,278 @@ ExtensionIdRegistry* default_extension_id_registry() {\n   return &impl_;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+  }\n\nReview Comment:\n   Should we return an invalid status as an else clause here?\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -351,5 +355,278 @@ ExtensionIdRegistry* default_extension_id_registry() {\n   return &impl_;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+  }\n+  return Status::OK();\n+}\n+\n+Status FunctionMapping::AddSubstraitToArrow(std::string substrait_function_name, SubstraitToArrow conversion_func){\n+  if (substrait_to_arrow.find(substrait_function_name) != substrait_to_arrow.end()){\n+    substrait_to_arrow[substrait_function_name] =  conversion_func;\n+  }\n\nReview Comment:\n   Same, perhaps the else should be an invalid status.\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.h:\n##########\n@@ -22,16 +22,55 @@\n #include <unordered_map>\n #include <vector>\n \n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/exec/expression.h\"\n #include \"arrow/engine/substrait/visibility.h\"\n #include \"arrow/type_fwd.h\"\n #include \"arrow/util/optional.h\"\n #include \"arrow/util/string_view.h\"\n \n #include \"arrow/util/hash_util.h\"\n+#include \"substrait/expression.pb.h\"  // IWYU pragma: export\n \n namespace arrow {\n namespace engine {\n \n+class ExtensionSet;\n+using ArrowToSubstrait = std::function<Result<substrait::Expression::ScalarFunction>(const arrow::compute::Expression::Call&, arrow::engine::ExtensionSet*)>;\n+using SubstraitToArrow = std::function<Result<arrow::compute::Expression>(const substrait::Expression::ScalarFunction&)>;\n+\n+class FunctionMapping {\n+  \n+  enum defined_functions {\n\nReview Comment:\n   Is this used anywhere?\n\n\n\n",
                    "created": "2022-06-02T05:55:14.361+0000",
                    "updated": "2022-06-02T05:55:14.361+0000",
                    "started": "2022-06-02T05:55:14.360+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "777286",
                    "issueId": "13426719"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/778866",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg commented on code in PR #13285:\nURL: https://github.com/apache/arrow/pull/13285#discussion_r890821982\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -351,5 +355,278 @@ ExtensionIdRegistry* default_extension_id_registry() {\n   return &impl_;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+  }\n\nReview Comment:\n   Made the change.\n\n\n\n",
                    "created": "2022-06-07T06:43:45.426+0000",
                    "updated": "2022-06-07T06:43:45.426+0000",
                    "started": "2022-06-07T06:43:45.425+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "778866",
                    "issueId": "13426719"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/778867",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg commented on code in PR #13285:\nURL: https://github.com/apache/arrow/pull/13285#discussion_r890822805\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -351,5 +355,278 @@ ExtensionIdRegistry* default_extension_id_registry() {\n   return &impl_;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+  }\n+  return Status::OK();\n+}\n+\n+Status FunctionMapping::AddSubstraitToArrow(std::string substrait_function_name, SubstraitToArrow conversion_func){\n+  if (substrait_to_arrow.find(substrait_function_name) != substrait_to_arrow.end()){\n+    substrait_to_arrow[substrait_function_name] =  conversion_func;\n+  }\n\nReview Comment:\n   Returning a AlreadyExist status here, will that be better?\n\n\n\n",
                    "created": "2022-06-07T06:45:00.189+0000",
                    "updated": "2022-06-07T06:45:00.189+0000",
                    "started": "2022-06-07T06:45:00.188+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "778867",
                    "issueId": "13426719"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/778868",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg commented on code in PR #13285:\nURL: https://github.com/apache/arrow/pull/13285#discussion_r890822986\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -351,5 +355,278 @@ ExtensionIdRegistry* default_extension_id_registry() {\n   return &impl_;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+  }\n+  return Status::OK();\n+}\n+\n+Status FunctionMapping::AddSubstraitToArrow(std::string substrait_function_name, SubstraitToArrow conversion_func){\n+  if (substrait_to_arrow.find(substrait_function_name) != substrait_to_arrow.end()){\n+    substrait_to_arrow[substrait_function_name] =  conversion_func;\n+  }\n+  return Status::OK();\n+}\n+\n+SubstraitToArrow substrait_add_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto value_1 = call.args(1);\n+  auto value_2 = call.args(2);\n+  ExtensionSet ext_set_;\n+  ARROW_ASSIGN_OR_RAISE(auto expression_1, FromProto(value_1, ext_set_));\n+  ARROW_ASSIGN_OR_RAISE(auto expression_2, FromProto(value_2, ext_set_));\n+  auto options = call.args(0);\n+  if (options.has_enum_()) {\n+    auto overflow_handling = options.enum_();\n+    if(overflow_handling.has_specified()){\n+    std::string overflow_type = overflow_handling.specified();\n+    if(overflow_type == \"SILENT\"){\n+      return arrow::compute::call(\"add\", {expression_1,expression_2}, compute::ArithmeticOptions());\n+    } else if (overflow_type == \"SATURATE\") {\n+      return Status::Invalid(\"Arrow does not support a saturating add\");\n+    } else {\n+      return arrow::compute::call(\"add_checked\", {expression_1,expression_2}, compute::ArithmeticOptions(true));\n+    }\n+  } else {\n+    return arrow::compute::call(\"add\", {expression_1,expression_2}, compute::ArithmeticOptions());\n+  }\n+  } else {\n+      return Status::Invalid(\"Substrait Function Options should be an enum\");\n+  }\n+};\n+\n+ArrowToSubstrait arrow_add_to_substrait = [] (const arrow::compute::Expression::Call& call, arrow::engine::ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  \n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"add\"));\n+  substrait_call.set_function_reference(function_reference);\n+\n+  substrait::Expression::Enum options;\n+  std::string overflow_handling = \"ERROR\";\n+  options.set_specified(overflow_handling);\n+  substrait_call.add_args()->set_allocated_enum_(&options);\n+  \n+  auto expression_1 = call.arguments[0];\n+  auto expression_2 = call.arguments[1];\n+  \n+  ARROW_ASSIGN_OR_RAISE(auto value_1, ToProto(expression_1, ext_set_));\n+  ARROW_ASSIGN_OR_RAISE(auto value_2, ToProto(expression_2, ext_set_));\n+\n+  substrait_call.add_args()->CopyFrom(*value_1);\n+  substrait_call.add_args()->CopyFrom(*value_2);\n+  return std::move(substrait_call);\n+};\n+\n+ArrowToSubstrait arrow_unchecked_add_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  \n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"add\"));\n+  substrait_call.set_function_reference(function_reference);\n+\n+  substrait::Expression::Enum options;\n+  std::string overflow_handling = \"SILENT\";\n+  options.set_specified(overflow_handling);\n+  substrait_call.add_args()->set_allocated_enum_(&options);\n+  \n+  auto expression_1 = call.arguments[0];\n+  auto expression_2 = call.arguments[1];\n+  \n+  ARROW_ASSIGN_OR_RAISE(auto value_1, ToProto(expression_1, ext_set_));\n+  ARROW_ASSIGN_OR_RAISE(auto value_2, ToProto(expression_2, ext_set_));\n+\n+  substrait_call.add_args()->CopyFrom(*value_1);\n+  substrait_call.add_args()->CopyFrom(*value_2);\n+  return std::move(substrait_call);\n+};\n+\n+\n+// Boolean Functions mapping\n+SubstraitToArrow substrait_not_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto value_1 = call.args(1);\n+  ExtensionSet ext_set_;\n+  ARROW_ASSIGN_OR_RAISE(auto expression_1, FromProto(value_1, ext_set_));\n+  return arrow::compute::call(\"invert\", {expression_1});\n+};\n+\n+SubstraitToArrow substrait_or_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  int num_args = call.args_size();  // OR function has variadic arguments\n+  substrait::Expression value;\n+  ExtensionSet ext_set_;\n+  arrow::compute::Expression expression;\n+  std::vector<arrow::compute::Expression> func_args;\n+  for(int i=0; i<num_args; ++i){\n+    value = call.args(i);\n+    ARROW_ASSIGN_OR_RAISE(expression, FromProto(value, ext_set_));\n+    func_args.push_back(expression);\n+  }\n+  return arrow::compute::call(\"or_kleene\", func_args);\n+};\n+\n+SubstraitToArrow substrait_and_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  int num_args = call.args_size();  // AND function has variadic arguments\n+  substrait::Expression value;\n+  ExtensionSet ext_set_;\n+  arrow::compute::Expression expression;\n+  std::vector<arrow::compute::Expression> func_args;\n+  for(int i=0; i<num_args; ++i){\n+    value = call.args(i);\n+    ARROW_ASSIGN_OR_RAISE(expression, FromProto(value, ext_set_));\n+    func_args.push_back(expression);\n+  }\n+  return arrow::compute::call(\"and_kleene\", func_args);\n+};\n+\n+SubstraitToArrow substrait_xor_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto value_1 = call.args(0);\n+  auto value_2 = call.args(1);\n+  ExtensionSet ext_set_;\n+  ARROW_ASSIGN_OR_RAISE(auto expression_1, FromProto(value_1, ext_set_));\n+  ARROW_ASSIGN_OR_RAISE(auto expression_2, FromProto(value_2, ext_set_));\n+  return arrow::compute::call(\"xor\", {expression_1, expression_2});\n+};\n+\n+ArrowToSubstrait arrow_invert_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  \n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"not\"));\n+  substrait_call.set_function_reference(function_reference);\n+  \n+  auto expression_1 = call.arguments[0];\n+  auto expression_2 = call.arguments[1];\n+  \n+  ARROW_ASSIGN_OR_RAISE(auto value_1, ToProto(expression_1, ext_set_));\n+  ARROW_ASSIGN_OR_RAISE(auto value_2, ToProto(expression_2, ext_set_));\n+\n+  substrait_call.add_args()->CopyFrom(*value_1);\n+  substrait_call.add_args()->CopyFrom(*value_2);\n+  return std::move(substrait_call);\n+\n+};\n\nReview Comment:\n   Made the change, add the helpers, thanks!\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -351,5 +355,278 @@ ExtensionIdRegistry* default_extension_id_registry() {\n   return &impl_;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+  }\n+  return Status::OK();\n+}\n+\n+Status FunctionMapping::AddSubstraitToArrow(std::string substrait_function_name, SubstraitToArrow conversion_func){\n+  if (substrait_to_arrow.find(substrait_function_name) != substrait_to_arrow.end()){\n+    substrait_to_arrow[substrait_function_name] =  conversion_func;\n+  }\n+  return Status::OK();\n+}\n+\n+SubstraitToArrow substrait_add_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto value_1 = call.args(1);\n+  auto value_2 = call.args(2);\n+  ExtensionSet ext_set_;\n+  ARROW_ASSIGN_OR_RAISE(auto expression_1, FromProto(value_1, ext_set_));\n+  ARROW_ASSIGN_OR_RAISE(auto expression_2, FromProto(value_2, ext_set_));\n+  auto options = call.args(0);\n+  if (options.has_enum_()) {\n+    auto overflow_handling = options.enum_();\n+    if(overflow_handling.has_specified()){\n+    std::string overflow_type = overflow_handling.specified();\n+    if(overflow_type == \"SILENT\"){\n+      return arrow::compute::call(\"add\", {expression_1,expression_2}, compute::ArithmeticOptions());\n+    } else if (overflow_type == \"SATURATE\") {\n+      return Status::Invalid(\"Arrow does not support a saturating add\");\n+    } else {\n+      return arrow::compute::call(\"add_checked\", {expression_1,expression_2}, compute::ArithmeticOptions(true));\n+    }\n+  } else {\n+    return arrow::compute::call(\"add\", {expression_1,expression_2}, compute::ArithmeticOptions());\n+  }\n+  } else {\n+      return Status::Invalid(\"Substrait Function Options should be an enum\");\n+  }\n+};\n+\n+ArrowToSubstrait arrow_add_to_substrait = [] (const arrow::compute::Expression::Call& call, arrow::engine::ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  \n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"add\"));\n+  substrait_call.set_function_reference(function_reference);\n+\n+  substrait::Expression::Enum options;\n+  std::string overflow_handling = \"ERROR\";\n+  options.set_specified(overflow_handling);\n+  substrait_call.add_args()->set_allocated_enum_(&options);\n+  \n+  auto expression_1 = call.arguments[0];\n+  auto expression_2 = call.arguments[1];\n+  \n+  ARROW_ASSIGN_OR_RAISE(auto value_1, ToProto(expression_1, ext_set_));\n+  ARROW_ASSIGN_OR_RAISE(auto value_2, ToProto(expression_2, ext_set_));\n+\n+  substrait_call.add_args()->CopyFrom(*value_1);\n+  substrait_call.add_args()->CopyFrom(*value_2);\n+  return std::move(substrait_call);\n+};\n+\n+ArrowToSubstrait arrow_unchecked_add_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  \n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"add\"));\n+  substrait_call.set_function_reference(function_reference);\n+\n+  substrait::Expression::Enum options;\n+  std::string overflow_handling = \"SILENT\";\n+  options.set_specified(overflow_handling);\n+  substrait_call.add_args()->set_allocated_enum_(&options);\n+  \n+  auto expression_1 = call.arguments[0];\n+  auto expression_2 = call.arguments[1];\n+  \n+  ARROW_ASSIGN_OR_RAISE(auto value_1, ToProto(expression_1, ext_set_));\n+  ARROW_ASSIGN_OR_RAISE(auto value_2, ToProto(expression_2, ext_set_));\n+\n+  substrait_call.add_args()->CopyFrom(*value_1);\n+  substrait_call.add_args()->CopyFrom(*value_2);\n+  return std::move(substrait_call);\n+};\n+\n+\n+// Boolean Functions mapping\n+SubstraitToArrow substrait_not_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto value_1 = call.args(1);\n+  ExtensionSet ext_set_;\n+  ARROW_ASSIGN_OR_RAISE(auto expression_1, FromProto(value_1, ext_set_));\n+  return arrow::compute::call(\"invert\", {expression_1});\n+};\n+\n+SubstraitToArrow substrait_or_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  int num_args = call.args_size();  // OR function has variadic arguments\n+  substrait::Expression value;\n+  ExtensionSet ext_set_;\n+  arrow::compute::Expression expression;\n+  std::vector<arrow::compute::Expression> func_args;\n+  for(int i=0; i<num_args; ++i){\n+    value = call.args(i);\n+    ARROW_ASSIGN_OR_RAISE(expression, FromProto(value, ext_set_));\n+    func_args.push_back(expression);\n+  }\n+  return arrow::compute::call(\"or_kleene\", func_args);\n+};\n+\n+SubstraitToArrow substrait_and_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  int num_args = call.args_size();  // AND function has variadic arguments\n+  substrait::Expression value;\n+  ExtensionSet ext_set_;\n+  arrow::compute::Expression expression;\n+  std::vector<arrow::compute::Expression> func_args;\n+  for(int i=0; i<num_args; ++i){\n+    value = call.args(i);\n+    ARROW_ASSIGN_OR_RAISE(expression, FromProto(value, ext_set_));\n+    func_args.push_back(expression);\n+  }\n+  return arrow::compute::call(\"and_kleene\", func_args);\n+};\n+\n+SubstraitToArrow substrait_xor_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto value_1 = call.args(0);\n+  auto value_2 = call.args(1);\n+  ExtensionSet ext_set_;\n+  ARROW_ASSIGN_OR_RAISE(auto expression_1, FromProto(value_1, ext_set_));\n+  ARROW_ASSIGN_OR_RAISE(auto expression_2, FromProto(value_2, ext_set_));\n+  return arrow::compute::call(\"xor\", {expression_1, expression_2});\n+};\n+\n+ArrowToSubstrait arrow_invert_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  \n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"not\"));\n+  substrait_call.set_function_reference(function_reference);\n+  \n+  auto expression_1 = call.arguments[0];\n+  auto expression_2 = call.arguments[1];\n+  \n+  ARROW_ASSIGN_OR_RAISE(auto value_1, ToProto(expression_1, ext_set_));\n+  ARROW_ASSIGN_OR_RAISE(auto value_2, ToProto(expression_2, ext_set_));\n+\n+  substrait_call.add_args()->CopyFrom(*value_1);\n+  substrait_call.add_args()->CopyFrom(*value_2);\n+  return std::move(substrait_call);\n+\n+};\n\nReview Comment:\n   Made the change, added the helpers, thanks!\n\n\n\n",
                    "created": "2022-06-07T06:45:15.289+0000",
                    "updated": "2022-06-07T06:45:15.289+0000",
                    "started": "2022-06-07T06:45:15.289+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "778868",
                    "issueId": "13426719"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/778869",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg commented on code in PR #13285:\nURL: https://github.com/apache/arrow/pull/13285#discussion_r890823220\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.h:\n##########\n@@ -22,16 +22,55 @@\n #include <unordered_map>\n #include <vector>\n \n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/exec/expression.h\"\n #include \"arrow/engine/substrait/visibility.h\"\n #include \"arrow/type_fwd.h\"\n #include \"arrow/util/optional.h\"\n #include \"arrow/util/string_view.h\"\n \n #include \"arrow/util/hash_util.h\"\n+#include \"substrait/expression.pb.h\"  // IWYU pragma: export\n \n namespace arrow {\n namespace engine {\n \n+class ExtensionSet;\n+using ArrowToSubstrait = std::function<Result<substrait::Expression::ScalarFunction>(const arrow::compute::Expression::Call&, arrow::engine::ExtensionSet*)>;\n+using SubstraitToArrow = std::function<Result<arrow::compute::Expression>(const substrait::Expression::ScalarFunction&)>;\n+\n+class FunctionMapping {\n+  \n+  enum defined_functions {\n\nReview Comment:\n   Removed it.\n\n\n\n",
                    "created": "2022-06-07T06:45:35.275+0000",
                    "updated": "2022-06-07T06:45:35.275+0000",
                    "started": "2022-06-07T06:45:35.274+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "778869",
                    "issueId": "13426719"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/778871",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg commented on code in PR #13285:\nURL: https://github.com/apache/arrow/pull/13285#discussion_r890823472\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -351,5 +355,278 @@ ExtensionIdRegistry* default_extension_id_registry() {\n   return &impl_;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+  }\n\nReview Comment:\n   Returning an AlreadyExist status.\n\n\n\n",
                    "created": "2022-06-07T06:46:00.337+0000",
                    "updated": "2022-06-07T06:46:00.337+0000",
                    "started": "2022-06-07T06:46:00.336+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "778871",
                    "issueId": "13426719"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/778872",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg commented on code in PR #13285:\nURL: https://github.com/apache/arrow/pull/13285#discussion_r890823834\n\n\n##########\ncpp/src/arrow/engine/substrait/expression_internal.cc:\n##########\n@@ -159,21 +159,11 @@ Result<compute::Expression> FromProto(const substrait::Expression& expr,\n \n       ARROW_ASSIGN_OR_RAISE(auto decoded_function,\n                             ext_set.DecodeFunction(scalar_fn.function_reference()));\n+      \n+      auto arrow_function = ext_set.GetFunctionMap().GetArrowFromSubstrait(decoded_function.name.to_string());\n \n-      std::vector<compute::Expression> arguments(scalar_fn.args_size());\n-      for (int i = 0; i < scalar_fn.args_size(); ++i) {\n-        ARROW_ASSIGN_OR_RAISE(arguments[i], FromProto(scalar_fn.args(i), ext_set));\n-      }\n+      return arrow_function(scalar_fn);                      \n\nReview Comment:\n   Returning a KeyError status if not found.\n\n\n\n",
                    "created": "2022-06-07T06:46:30.404+0000",
                    "updated": "2022-06-07T06:46:30.404+0000",
                    "started": "2022-06-07T06:46:30.404+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "778872",
                    "issueId": "13426719"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/782200",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13285:\nURL: https://github.com/apache/arrow/pull/13285#discussion_r899666451\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -204,6 +209,521 @@ const int* GetIndex(const KeyToIndex& key_to_index, const Key& key) {\n   return &it->second;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Arrow function already exist in the conversion map\");\n+}\n+\n+Status FunctionMapping::AddSubstraitToArrow(std::string substrait_function_name, SubstraitToArrow conversion_func){\n+  if (substrait_to_arrow.find(substrait_function_name) != substrait_to_arrow.end()){\n\nReview Comment:\n   Same as above.  This seems backwards (but maybe I'm just not thinking right)\n\n\n\n##########\ncpp/src/arrow/engine/substrait/expression_internal.cc:\n##########\n@@ -159,21 +160,17 @@ Result<compute::Expression> FromProto(const substrait::Expression& expr,\n \n       ARROW_ASSIGN_OR_RAISE(auto decoded_function,\n                             ext_set.DecodeFunction(scalar_fn.function_reference()));\n+      ARROW_ASSIGN_OR_RAISE(auto arrow_function, ext_set.GetFunctionMap().GetArrowFromSubstrait(decoded_function.name.to_string()));\n+      return arrow_function(scalar_fn);                      \n+    }\n \n-      std::vector<compute::Expression> arguments(scalar_fn.args_size());\n-      for (int i = 0; i < scalar_fn.args_size(); ++i) {\n-        ARROW_ASSIGN_OR_RAISE(arguments[i], FromProto(scalar_fn.args(i), ext_set));\n-      }\n-\n-      auto func_name = decoded_function.name.to_string();\n-      if (func_name != \"cast\") {\n-        return compute::call(func_name, std::move(arguments));\n-      } else {\n-        ARROW_ASSIGN_OR_RAISE(auto output_type_desc,\n-                              FromProto(scalar_fn.output_type(), ext_set));\n-        auto cast_options = compute::CastOptions::Safe(std::move(output_type_desc.first));\n-        return compute::call(func_name, std::move(arguments), std::move(cast_options));\n-      }\n+    case substrait::Expression::kEnum: {\n+      auto enum_expr = expr.enum_();\n\nReview Comment:\n   Does this convert to the string value of the enum?  Can you add a small comment here explaining that.\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -204,6 +209,521 @@ const int* GetIndex(const KeyToIndex& key_to_index, const Key& key) {\n   return &it->second;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Arrow function already exist in the conversion map\");\n+}\n+\n+Status FunctionMapping::AddSubstraitToArrow(std::string substrait_function_name, SubstraitToArrow conversion_func){\n+  if (substrait_to_arrow.find(substrait_function_name) != substrait_to_arrow.end()){\n+    substrait_to_arrow[substrait_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Substrait function already exist in the conversion map\");\n+}\n+\n+Result<SubstraitToArrow> FunctionMapping::GetArrowFromSubstrait(std::string name) const {\n+   if (FunctionMapping::substrait_to_arrow.find(name)!=FunctionMapping::substrait_to_arrow.end()){\n+     return FunctionMapping::substrait_to_arrow.at(name);\n+   } else {\n+    return Status::KeyError(\"Substrait function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+Result<ArrowToSubstrait> FunctionMapping::GetSubstraitFromArrow(std::string name) const {\n+   if (FunctionMapping::arrow_to_substrait.find(name)!=FunctionMapping::arrow_to_substrait.end()){\n+     return FunctionMapping::arrow_to_substrait.at(name);\n+   } else {\n+    return Status::KeyError(\"Arrow function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+std::vector<arrow::compute::Expression> substrait_convert_arguments(const substrait::Expression::ScalarFunction& call){\n+  substrait::Expression value;\n+  ExtensionSet ext_set_;\n\nReview Comment:\n   ```suggestion\r\n     ExtensionSet ext_set;\r\n   ```\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -204,6 +209,521 @@ const int* GetIndex(const KeyToIndex& key_to_index, const Key& key) {\n   return &it->second;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Arrow function already exist in the conversion map\");\n+}\n+\n+Status FunctionMapping::AddSubstraitToArrow(std::string substrait_function_name, SubstraitToArrow conversion_func){\n+  if (substrait_to_arrow.find(substrait_function_name) != substrait_to_arrow.end()){\n+    substrait_to_arrow[substrait_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Substrait function already exist in the conversion map\");\n+}\n+\n+Result<SubstraitToArrow> FunctionMapping::GetArrowFromSubstrait(std::string name) const {\n+   if (FunctionMapping::substrait_to_arrow.find(name)!=FunctionMapping::substrait_to_arrow.end()){\n+     return FunctionMapping::substrait_to_arrow.at(name);\n+   } else {\n+    return Status::KeyError(\"Substrait function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+Result<ArrowToSubstrait> FunctionMapping::GetSubstraitFromArrow(std::string name) const {\n+   if (FunctionMapping::arrow_to_substrait.find(name)!=FunctionMapping::arrow_to_substrait.end()){\n+     return FunctionMapping::arrow_to_substrait.at(name);\n+   } else {\n+    return Status::KeyError(\"Arrow function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+std::vector<arrow::compute::Expression> substrait_convert_arguments(const substrait::Expression::ScalarFunction& call){\n+  substrait::Expression value;\n+  ExtensionSet ext_set_;\n\nReview Comment:\n   This seems strange.  Wouldn't this function take in an extension set as an argument?\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -204,6 +209,521 @@ const int* GetIndex(const KeyToIndex& key_to_index, const Key& key) {\n   return &it->second;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Arrow function already exist in the conversion map\");\n+}\n+\n+Status FunctionMapping::AddSubstraitToArrow(std::string substrait_function_name, SubstraitToArrow conversion_func){\n+  if (substrait_to_arrow.find(substrait_function_name) != substrait_to_arrow.end()){\n+    substrait_to_arrow[substrait_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Substrait function already exist in the conversion map\");\n+}\n+\n+Result<SubstraitToArrow> FunctionMapping::GetArrowFromSubstrait(std::string name) const {\n+   if (FunctionMapping::substrait_to_arrow.find(name)!=FunctionMapping::substrait_to_arrow.end()){\n+     return FunctionMapping::substrait_to_arrow.at(name);\n+   } else {\n+    return Status::KeyError(\"Substrait function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+Result<ArrowToSubstrait> FunctionMapping::GetSubstraitFromArrow(std::string name) const {\n+   if (FunctionMapping::arrow_to_substrait.find(name)!=FunctionMapping::arrow_to_substrait.end()){\n+     return FunctionMapping::arrow_to_substrait.at(name);\n+   } else {\n+    return Status::KeyError(\"Arrow function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+std::vector<arrow::compute::Expression> substrait_convert_arguments(const substrait::Expression::ScalarFunction& call){\n+  substrait::Expression value;\n+  ExtensionSet ext_set_;\n+  arrow::compute::Expression expression;\n+  std::vector<compute::Expression> func_args;\n+  for(int i=0; i<call.args_size(); ++i){\n+    value = call.args(i);\n+    expression = FromProto(value, ext_set_).ValueOrDie();\n+    func_args.push_back(expression);\n+   }\n+  return func_args;\n+}\n+\n+substrait::Expression::ScalarFunction arrow_convert_arguments(const arrow::compute::Expression::Call& call, substrait::Expression::ScalarFunction& substrait_call, ExtensionSet* ext_set_){\n+  arrow::compute::Expression expression;\n+  std::unique_ptr<substrait::Expression> value;\n+  for(size_t i = 0; i<call.arguments.size(); ++i){\n+      expression = call.arguments[i];\n+      value = ToProto(expression, ext_set_).ValueOrDie();\n+      substrait_call.add_args()->CopyFrom(*value);\n+  }\n+  return std::move(substrait_call);\n+}\n+\n+substrait::Expression::ScalarFunction arrow_convert_enum_arguments(const arrow::compute::Expression::Call& call, substrait::Expression::ScalarFunction& substrait_call, ExtensionSet* ext_set_, std::string overflow_handling){\n+  substrait::Expression::Enum options;\n+  options.set_specified(overflow_handling);\n+  substrait_call.add_args()->set_allocated_enum_(&options);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+}\n+\n+\n+SubstraitToArrow substrait_add_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  if(func_args[0].ToString() == \"SILENT\"){\n+    return arrow::compute::call(\"add\", {func_args[1], func_args[2]}, compute::ArithmeticOptions());\n+  } else if (func_args[0].ToString() == \"SATURATE\") {\n+    return Status::Invalid(\"Arrow does not support a saturating add\");\n+   } else {\n+    return arrow::compute::call(\"add_checked\", {func_args[1], func_args[2]}, compute::ArithmeticOptions(true));\n+   }\n+ };\n+\n+SubstraitToArrow substrait_subtract_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  if(func_args[0].ToString() == \"SILENT\"){\n+    return arrow::compute::call(\"subtract\", {func_args[1], func_args[2]}, compute::ArithmeticOptions());\n+  } else if (func_args[0].ToString() == \"SATURATE\") {\n+    return Status::Invalid(\"Arrow does not support a saturating subtract\");\n+  } else {\n+    return arrow::compute::call(\"subtract_checked\", {func_args[1], func_args[2]}, compute::ArithmeticOptions(true));\n+  }\n+};\n+\n+SubstraitToArrow substrait_multiply_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  if(func_args[0].ToString() == \"SILENT\"){\n+    return arrow::compute::call(\"multiply\", {func_args[1], func_args[2]}, compute::ArithmeticOptions());\n+  } else if (func_args[0].ToString() == \"SATURATE\") {\n+    return Status::Invalid(\"Arrow does not support a saturating multiply\");\n+  } else {\n+    return arrow::compute::call(\"mutiply_checked\", {func_args[1], func_args[2]}, compute::ArithmeticOptions(true));\n+  }\n+};\n+\n+SubstraitToArrow substrait_divide_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  if(func_args[0].ToString() == \"SILENT\"){\n+    return arrow::compute::call(\"divide\", {func_args[1], func_args[2]}, compute::ArithmeticOptions());\n+  } else if (func_args[0].ToString() == \"SATURATE\") {\n+    return Status::Invalid(\"Arrow does not support a saturating divide\");\n+  } else {\n+    return arrow::compute::call(\"divide_checked\", {func_args[1], func_args[2]}, compute::ArithmeticOptions(true));\n+  }\n+};\n+\n+SubstraitToArrow substrait_modulus_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"abs\", substrait_convert_arguments(call));\n+};\n+\n+ArrowToSubstrait arrow_add_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"add\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_enum_arguments(call, substrait_call, ext_set_, \"ERROR\");\n+ };\n+\n+ArrowToSubstrait arrow_unchecked_add_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"add\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_enum_arguments(call, substrait_call, ext_set_, \"SILENT\");\n+};\n+\n+ArrowToSubstrait arrow_subtract_to_substrait = [] (const arrow::compute::Expression::Call& call, arrow::engine::ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"subtract\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_enum_arguments(call, substrait_call, ext_set_, \"ERROR\");\n+};\n+\n+ArrowToSubstrait arrow_unchecked_subtract_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"subtract\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_enum_arguments(call, substrait_call, ext_set_, \"SILENT\") ;\n+};\n+\n+ArrowToSubstrait arrow_multiply_to_substrait = [] (const arrow::compute::Expression::Call& call, arrow::engine::ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"multiply\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_enum_arguments(call, substrait_call, ext_set_, \"ERROR\");\n+};\n+\n+ArrowToSubstrait arrow_unchecked_multiply_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"multiply\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_enum_arguments(call, substrait_call, ext_set_, \"SILENT\");\n+};\n+\n+\n+ArrowToSubstrait arrow_divide_to_substrait = [] (const arrow::compute::Expression::Call& call, arrow::engine::ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"divide\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_enum_arguments(call, substrait_call, ext_set_, \"ERROR\");\n+};\n+\n+ArrowToSubstrait arrow_unchecked_divide_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"divide\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_enum_arguments(call, substrait_call, ext_set_, \"SILENT\");\n+};\n+\n+ArrowToSubstrait arrow_abs_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"modulus\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+// Boolean Functions mappings\n+SubstraitToArrow substrait_not_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"invert\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_or_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"or_kleene\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_and_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"and_kleene\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_xor_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"xor\", substrait_convert_arguments(call));\n+};\n+\n+ArrowToSubstrait arrow_invert_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"not\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_or_kleene_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"or\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_and_kleene_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"and\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_xor_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"xor\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+// Comparison Functions mapping\n+SubstraitToArrow substrait_lt_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"less\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_gt_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"greater\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_lte_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"less_equal\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_gte_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"greater_equal\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_not_equal_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"not_equal\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_equal_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"equal\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_is_null_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"is_null\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_is_not_null_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"is_valid\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_is_not_distinct_from_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  std::vector<compute::Expression> func_args = substrait_convert_arguments(call);\n+  auto null_check_1 = arrow::compute::call(\"is_null\", {func_args[0]});\n+  auto null_check_2 = arrow::compute::call(\"is_null\", {func_args[1]});\n+  if(null_check_1.IsNullLiteral() && null_check_1.IsNullLiteral()){\n+    return arrow::compute::call(\"not_equal\", {null_check_1, null_check_2});\n+  }\n+  return arrow::compute::call(\"not_equal\", func_args);\n+};\n+\n+ArrowToSubstrait arrow_less_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"lt\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_greater_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"gt\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_less_equal_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"lte\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_greater_equal_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"gte\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_equal_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"equal\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_not_equal_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"not_equal\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_is_null_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"is_null\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_is_valid_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"is_not_null\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+// Strings function mapping\n+SubstraitToArrow substrait_like_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  return arrow::compute::call(\"match_like\", {func_args[0]}, compute::MatchSubstringOptions(func_args[1].ToString()));\n+};\n+\n+SubstraitToArrow substrait_substring_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  auto start = func_args[1].literal()->scalar_as<Int64Scalar>();\n+  auto stop = func_args[2].literal()->scalar_as<Int64Scalar>();\n+  return arrow::compute::call(\"utf8_slice_codeunits\", {func_args[0]}, compute::SliceOptions(static_cast<int64_t>(start.value), static_cast<int64_t>(stop.value)));\n+};\n+\n+SubstraitToArrow substrait_concat_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  arrow::StringBuilder builder;\n+  builder.Append(func_args[0].ToString());\n+  builder.Append(func_args[1].ToString());\n+  auto strings_datum = arrow::Datum(*builder.Finish());\n+  auto separator_datum = arrow::Datum(\"\");\n+  return arrow::compute::call(\"binary_join\", {arrow::compute::Expression(strings_datum), arrow::compute::Expression(separator_datum)});\n+};\n+\n+ArrowToSubstrait arrow_match_like_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"like\"));\n+  substrait_call.set_function_reference(function_reference);\n+\n+  arrow::compute::Expression expression_1, expression_2;\n+  std::unique_ptr<substrait::Expression> string_1, string_2;\n+  expression_1 = call.arguments[0];\n+  string_1 = ToProto(expression_1, ext_set_).ValueOrDie();\n+  substrait_call.add_args()->CopyFrom(*string_1);\n+\n+  auto pattern_string = std::dynamic_pointer_cast<compute::MatchSubstringOptions>(call.options)->pattern;\n+  expression_2 = arrow::compute::Expression(arrow::Datum(pattern_string));\n+  string_2 = ToProto(expression_2, ext_set_).ValueOrDie();\n+  substrait_call.add_args()->CopyFrom(*string_2);\n+\n+  return std::move(substrait_call);\n+};\n+\n+ArrowToSubstrait arrow_utf8_slice_codeunits_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"substring\"));\n+  substrait_call.set_function_reference(function_reference);\n+  arrow::compute::Expression expression_1, expression_2, expression_3;\n+  std::unique_ptr<substrait::Expression> string, start, stop;\n+  expression_1 = call.arguments[0];\n+  string = ToProto(expression_1, ext_set_).ValueOrDie();\n+  substrait_call.add_args()->CopyFrom(*string);\n+\n+  auto start_index = std::dynamic_pointer_cast<compute::SliceOptions>(call.options)->start;\n+  auto stop_index = std::dynamic_pointer_cast<compute::SliceOptions>(call.options)->stop;\n+  expression_2 = arrow::compute::Expression(arrow::Datum(start_index));\n+  expression_3 = arrow::compute::Expression(arrow::Datum(stop_index));\n+  start =  ToProto(expression_2, ext_set_).ValueOrDie();\n+  stop  =  ToProto(expression_3, ext_set_).ValueOrDie();\n+  substrait_call.add_args()->CopyFrom(*start);\n+  substrait_call.add_args()->CopyFrom(*stop);\n+\n+  return std::move(substrait_call);\n+};\n+\n+ArrowToSubstrait arrow_binary_join_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"concat\"));\n+  substrait_call.set_function_reference(function_reference);\n+  arrow::compute::Expression expression_1, expression_2;\n+  std::unique_ptr<substrait::Expression> string_1, string_2;\n+\n+  auto strings_list = call.arguments[0].literal()->make_array();\n+  expression_1 = arrow::compute::Expression(*(strings_list->GetScalar(0)));\n+  expression_2 = arrow::compute::Expression(*(strings_list->GetScalar(1)));\n+\n+  string_1 = ToProto(expression_1, ext_set_).ValueOrDie();\n+  string_2 = ToProto(expression_2, ext_set_).ValueOrDie();\n+  substrait_call.add_args()->CopyFrom(*string_1);\n+  substrait_call.add_args()->CopyFrom(*string_2);\n+  return std::move(substrait_call);\n+};\n+\n+// Cast function mapping\n+SubstraitToArrow substrait_cast_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  ExtensionSet ext_set_;\n+  ARROW_ASSIGN_OR_RAISE(auto output_type_desc,\n+                              FromProto(call.output_type(), ext_set_));\n+  auto cast_options = compute::CastOptions::Safe(std::move(output_type_desc.first));\n+  return compute::call(\"cast\", {substrait_convert_arguments(call)[0]}, std::move(cast_options));\n+};\n+\n+ArrowToSubstrait arrow_cast_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"cast\"));\n+  substrait_call.set_function_reference(function_reference);\n+  \n+  auto arrow_to_type = std::dynamic_pointer_cast<compute::CastOptions>(call.options)->to_type;\n+  ARROW_ASSIGN_OR_RAISE(auto substrait_to_type, ToProto(*arrow_to_type, false, ext_set_));\n+  substrait_call.set_allocated_output_type(substrait_to_type.get());\n+\n+  auto expression = call.arguments[0];\n+  ARROW_ASSIGN_OR_RAISE(auto value, ToProto(expression, ext_set_));\n+  substrait_call.add_args()->CopyFrom(*value);\n+  \n+  return substrait_call;\n+};\n+\n+// Datetime functions mapping\n+SubstraitToArrow substrait_extract_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  if(func_args[0].ToString() == \"YEAR\"){\n+    return arrow::compute::call(\"year\", {func_args[1]});\n+  } else if (func_args[0].ToString() == \"MONTH\") {\n+    return arrow::compute::call(\"month\", {func_args[1]});\n+  } else if (func_args[0].ToString() == \"DAY\") {\n+    return arrow::compute::call(\"day\", {func_args[1]});\n+  } else {\n+    return arrow::compute::call(\"second\", {func_args[1]});\n+  }\n+};\n+\n+ArrowToSubstrait arrow_year_to_arrow = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"extract\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_enum_arguments(call, substrait_call, ext_set_, \"YEAR\");\n+};\n+\n+ArrowToSubstrait arrow_month_to_arrow = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"extract\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_enum_arguments(call, substrait_call, ext_set_, \"MONTH\");\n+};\n+\n+ArrowToSubstrait arrow_day_to_arrow = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"extract\"));\n+  substrait_call.set_function_reference(function_reference);\n\nReview Comment:\n   All of these calls to `EncodeFunction` seem pretty repetitive.  Is there any way we can move this into the part that calls `GetArrowToSubstrait`?  Also, I don't see anything today that calls `GetArrowToSubstrait`\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -204,6 +209,521 @@ const int* GetIndex(const KeyToIndex& key_to_index, const Key& key) {\n   return &it->second;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Arrow function already exist in the conversion map\");\n+}\n+\n+Status FunctionMapping::AddSubstraitToArrow(std::string substrait_function_name, SubstraitToArrow conversion_func){\n+  if (substrait_to_arrow.find(substrait_function_name) != substrait_to_arrow.end()){\n+    substrait_to_arrow[substrait_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Substrait function already exist in the conversion map\");\n+}\n+\n+Result<SubstraitToArrow> FunctionMapping::GetArrowFromSubstrait(std::string name) const {\n+   if (FunctionMapping::substrait_to_arrow.find(name)!=FunctionMapping::substrait_to_arrow.end()){\n+     return FunctionMapping::substrait_to_arrow.at(name);\n+   } else {\n+    return Status::KeyError(\"Substrait function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+Result<ArrowToSubstrait> FunctionMapping::GetSubstraitFromArrow(std::string name) const {\n+   if (FunctionMapping::arrow_to_substrait.find(name)!=FunctionMapping::arrow_to_substrait.end()){\n+     return FunctionMapping::arrow_to_substrait.at(name);\n+   } else {\n+    return Status::KeyError(\"Arrow function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+std::vector<arrow::compute::Expression> substrait_convert_arguments(const substrait::Expression::ScalarFunction& call){\n+  substrait::Expression value;\n+  ExtensionSet ext_set_;\n+  arrow::compute::Expression expression;\n+  std::vector<compute::Expression> func_args;\n+  for(int i=0; i<call.args_size(); ++i){\n+    value = call.args(i);\n+    expression = FromProto(value, ext_set_).ValueOrDie();\n+    func_args.push_back(expression);\n+   }\n+  return func_args;\n+}\n+\n+substrait::Expression::ScalarFunction arrow_convert_arguments(const arrow::compute::Expression::Call& call, substrait::Expression::ScalarFunction& substrait_call, ExtensionSet* ext_set_){\n\nReview Comment:\n   Style guide prefers passing mutable objects by pointer instead of mutable references.\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -204,6 +209,521 @@ const int* GetIndex(const KeyToIndex& key_to_index, const Key& key) {\n   return &it->second;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Arrow function already exist in the conversion map\");\n+}\n+\n+Status FunctionMapping::AddSubstraitToArrow(std::string substrait_function_name, SubstraitToArrow conversion_func){\n+  if (substrait_to_arrow.find(substrait_function_name) != substrait_to_arrow.end()){\n+    substrait_to_arrow[substrait_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Substrait function already exist in the conversion map\");\n+}\n+\n+Result<SubstraitToArrow> FunctionMapping::GetArrowFromSubstrait(std::string name) const {\n+   if (FunctionMapping::substrait_to_arrow.find(name)!=FunctionMapping::substrait_to_arrow.end()){\n+     return FunctionMapping::substrait_to_arrow.at(name);\n+   } else {\n+    return Status::KeyError(\"Substrait function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+Result<ArrowToSubstrait> FunctionMapping::GetSubstraitFromArrow(std::string name) const {\n+   if (FunctionMapping::arrow_to_substrait.find(name)!=FunctionMapping::arrow_to_substrait.end()){\n+     return FunctionMapping::arrow_to_substrait.at(name);\n+   } else {\n+    return Status::KeyError(\"Arrow function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+std::vector<arrow::compute::Expression> substrait_convert_arguments(const substrait::Expression::ScalarFunction& call){\n+  substrait::Expression value;\n+  ExtensionSet ext_set_;\n+  arrow::compute::Expression expression;\n+  std::vector<compute::Expression> func_args;\n+  for(int i=0; i<call.args_size(); ++i){\n+    value = call.args(i);\n+    expression = FromProto(value, ext_set_).ValueOrDie();\n\nReview Comment:\n   Don't use `ValueOrDie` if it could possibly fail.  Return a `Result` instead and use `ARROW_ASSIGN_OR_RAISE`\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -204,6 +209,521 @@ const int* GetIndex(const KeyToIndex& key_to_index, const Key& key) {\n   return &it->second;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n\nReview Comment:\n   This logic seems backwards to me...wouldn't `umap.find(...) != umap.end()` mean the item already existed?\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -204,6 +209,521 @@ const int* GetIndex(const KeyToIndex& key_to_index, const Key& key) {\n   return &it->second;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Arrow function already exist in the conversion map\");\n+}\n+\n+Status FunctionMapping::AddSubstraitToArrow(std::string substrait_function_name, SubstraitToArrow conversion_func){\n+  if (substrait_to_arrow.find(substrait_function_name) != substrait_to_arrow.end()){\n+    substrait_to_arrow[substrait_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Substrait function already exist in the conversion map\");\n+}\n+\n+Result<SubstraitToArrow> FunctionMapping::GetArrowFromSubstrait(std::string name) const {\n+   if (FunctionMapping::substrait_to_arrow.find(name)!=FunctionMapping::substrait_to_arrow.end()){\n+     return FunctionMapping::substrait_to_arrow.at(name);\n+   } else {\n+    return Status::KeyError(\"Substrait function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+Result<ArrowToSubstrait> FunctionMapping::GetSubstraitFromArrow(std::string name) const {\n+   if (FunctionMapping::arrow_to_substrait.find(name)!=FunctionMapping::arrow_to_substrait.end()){\n+     return FunctionMapping::arrow_to_substrait.at(name);\n+   } else {\n+    return Status::KeyError(\"Arrow function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+std::vector<arrow::compute::Expression> substrait_convert_arguments(const substrait::Expression::ScalarFunction& call){\n+  substrait::Expression value;\n+  ExtensionSet ext_set_;\n+  arrow::compute::Expression expression;\n+  std::vector<compute::Expression> func_args;\n+  for(int i=0; i<call.args_size(); ++i){\n+    value = call.args(i);\n+    expression = FromProto(value, ext_set_).ValueOrDie();\n+    func_args.push_back(expression);\n+   }\n+  return func_args;\n+}\n+\n+substrait::Expression::ScalarFunction arrow_convert_arguments(const arrow::compute::Expression::Call& call, substrait::Expression::ScalarFunction& substrait_call, ExtensionSet* ext_set_){\n\nReview Comment:\n   ```suggestion\r\n   substrait::Expression::ScalarFunction ConvertArrowArguments(const arrow::compute::Expression::Call& call, substrait::Expression::ScalarFunction* substrait_call, ExtensionSet* ext_set){\r\n   ```\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -204,6 +209,521 @@ const int* GetIndex(const KeyToIndex& key_to_index, const Key& key) {\n   return &it->second;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Arrow function already exist in the conversion map\");\n+}\n+\n+Status FunctionMapping::AddSubstraitToArrow(std::string substrait_function_name, SubstraitToArrow conversion_func){\n+  if (substrait_to_arrow.find(substrait_function_name) != substrait_to_arrow.end()){\n+    substrait_to_arrow[substrait_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Substrait function already exist in the conversion map\");\n+}\n+\n+Result<SubstraitToArrow> FunctionMapping::GetArrowFromSubstrait(std::string name) const {\n+   if (FunctionMapping::substrait_to_arrow.find(name)!=FunctionMapping::substrait_to_arrow.end()){\n+     return FunctionMapping::substrait_to_arrow.at(name);\n+   } else {\n+    return Status::KeyError(\"Substrait function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+Result<ArrowToSubstrait> FunctionMapping::GetSubstraitFromArrow(std::string name) const {\n+   if (FunctionMapping::arrow_to_substrait.find(name)!=FunctionMapping::arrow_to_substrait.end()){\n+     return FunctionMapping::arrow_to_substrait.at(name);\n+   } else {\n+    return Status::KeyError(\"Arrow function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+std::vector<arrow::compute::Expression> substrait_convert_arguments(const substrait::Expression::ScalarFunction& call){\n\nReview Comment:\n   ```suggestion\r\n   std::vector<arrow::compute::Expression> ConvertSubstraitArguments(const substrait::Expression::ScalarFunction& call){\r\n   ```\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -204,6 +209,521 @@ const int* GetIndex(const KeyToIndex& key_to_index, const Key& key) {\n   return &it->second;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Arrow function already exist in the conversion map\");\n+}\n+\n+Status FunctionMapping::AddSubstraitToArrow(std::string substrait_function_name, SubstraitToArrow conversion_func){\n+  if (substrait_to_arrow.find(substrait_function_name) != substrait_to_arrow.end()){\n+    substrait_to_arrow[substrait_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Substrait function already exist in the conversion map\");\n+}\n+\n+Result<SubstraitToArrow> FunctionMapping::GetArrowFromSubstrait(std::string name) const {\n+   if (FunctionMapping::substrait_to_arrow.find(name)!=FunctionMapping::substrait_to_arrow.end()){\n+     return FunctionMapping::substrait_to_arrow.at(name);\n+   } else {\n+    return Status::KeyError(\"Substrait function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+Result<ArrowToSubstrait> FunctionMapping::GetSubstraitFromArrow(std::string name) const {\n+   if (FunctionMapping::arrow_to_substrait.find(name)!=FunctionMapping::arrow_to_substrait.end()){\n+     return FunctionMapping::arrow_to_substrait.at(name);\n+   } else {\n+    return Status::KeyError(\"Arrow function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+std::vector<arrow::compute::Expression> substrait_convert_arguments(const substrait::Expression::ScalarFunction& call){\n+  substrait::Expression value;\n+  ExtensionSet ext_set_;\n+  arrow::compute::Expression expression;\n+  std::vector<compute::Expression> func_args;\n+  for(int i=0; i<call.args_size(); ++i){\n+    value = call.args(i);\n+    expression = FromProto(value, ext_set_).ValueOrDie();\n+    func_args.push_back(expression);\n+   }\n+  return func_args;\n+}\n+\n+substrait::Expression::ScalarFunction arrow_convert_arguments(const arrow::compute::Expression::Call& call, substrait::Expression::ScalarFunction& substrait_call, ExtensionSet* ext_set_){\n+  arrow::compute::Expression expression;\n+  std::unique_ptr<substrait::Expression> value;\n+  for(size_t i = 0; i<call.arguments.size(); ++i){\n+      expression = call.arguments[i];\n+      value = ToProto(expression, ext_set_).ValueOrDie();\n+      substrait_call.add_args()->CopyFrom(*value);\n+  }\n+  return std::move(substrait_call);\n+}\n+\n+substrait::Expression::ScalarFunction arrow_convert_enum_arguments(const arrow::compute::Expression::Call& call, substrait::Expression::ScalarFunction& substrait_call, ExtensionSet* ext_set_, std::string overflow_handling){\n\nReview Comment:\n   ```suggestion\r\n   substrait::Expression::ScalarFunction ConvertArrowEnumArguments(const arrow::compute::Expression::Call& call, substrait::Expression::ScalarFunction& substrait_call, ExtensionSet* ext_set, std::string overflow_handling){\r\n   ```\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -204,6 +209,521 @@ const int* GetIndex(const KeyToIndex& key_to_index, const Key& key) {\n   return &it->second;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Arrow function already exist in the conversion map\");\n+}\n+\n+Status FunctionMapping::AddSubstraitToArrow(std::string substrait_function_name, SubstraitToArrow conversion_func){\n+  if (substrait_to_arrow.find(substrait_function_name) != substrait_to_arrow.end()){\n+    substrait_to_arrow[substrait_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Substrait function already exist in the conversion map\");\n+}\n+\n+Result<SubstraitToArrow> FunctionMapping::GetArrowFromSubstrait(std::string name) const {\n+   if (FunctionMapping::substrait_to_arrow.find(name)!=FunctionMapping::substrait_to_arrow.end()){\n+     return FunctionMapping::substrait_to_arrow.at(name);\n+   } else {\n+    return Status::KeyError(\"Substrait function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+Result<ArrowToSubstrait> FunctionMapping::GetSubstraitFromArrow(std::string name) const {\n+   if (FunctionMapping::arrow_to_substrait.find(name)!=FunctionMapping::arrow_to_substrait.end()){\n+     return FunctionMapping::arrow_to_substrait.at(name);\n+   } else {\n+    return Status::KeyError(\"Arrow function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+std::vector<arrow::compute::Expression> substrait_convert_arguments(const substrait::Expression::ScalarFunction& call){\n+  substrait::Expression value;\n+  ExtensionSet ext_set_;\n+  arrow::compute::Expression expression;\n+  std::vector<compute::Expression> func_args;\n+  for(int i=0; i<call.args_size(); ++i){\n+    value = call.args(i);\n+    expression = FromProto(value, ext_set_).ValueOrDie();\n+    func_args.push_back(expression);\n+   }\n+  return func_args;\n+}\n+\n+substrait::Expression::ScalarFunction arrow_convert_arguments(const arrow::compute::Expression::Call& call, substrait::Expression::ScalarFunction& substrait_call, ExtensionSet* ext_set_){\n+  arrow::compute::Expression expression;\n+  std::unique_ptr<substrait::Expression> value;\n+  for(size_t i = 0; i<call.arguments.size(); ++i){\n+      expression = call.arguments[i];\n+      value = ToProto(expression, ext_set_).ValueOrDie();\n+      substrait_call.add_args()->CopyFrom(*value);\n+  }\n+  return std::move(substrait_call);\n+}\n+\n+substrait::Expression::ScalarFunction arrow_convert_enum_arguments(const arrow::compute::Expression::Call& call, substrait::Expression::ScalarFunction& substrait_call, ExtensionSet* ext_set_, std::string overflow_handling){\n+  substrait::Expression::Enum options;\n+  options.set_specified(overflow_handling);\n\nReview Comment:\n   overflow_handling seems like an odd name given this is a generic function\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -204,6 +209,521 @@ const int* GetIndex(const KeyToIndex& key_to_index, const Key& key) {\n   return &it->second;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Arrow function already exist in the conversion map\");\n+}\n+\n+Status FunctionMapping::AddSubstraitToArrow(std::string substrait_function_name, SubstraitToArrow conversion_func){\n+  if (substrait_to_arrow.find(substrait_function_name) != substrait_to_arrow.end()){\n+    substrait_to_arrow[substrait_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Substrait function already exist in the conversion map\");\n+}\n+\n+Result<SubstraitToArrow> FunctionMapping::GetArrowFromSubstrait(std::string name) const {\n+   if (FunctionMapping::substrait_to_arrow.find(name)!=FunctionMapping::substrait_to_arrow.end()){\n+     return FunctionMapping::substrait_to_arrow.at(name);\n+   } else {\n+    return Status::KeyError(\"Substrait function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+Result<ArrowToSubstrait> FunctionMapping::GetSubstraitFromArrow(std::string name) const {\n+   if (FunctionMapping::arrow_to_substrait.find(name)!=FunctionMapping::arrow_to_substrait.end()){\n+     return FunctionMapping::arrow_to_substrait.at(name);\n+   } else {\n+    return Status::KeyError(\"Arrow function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+std::vector<arrow::compute::Expression> substrait_convert_arguments(const substrait::Expression::ScalarFunction& call){\n+  substrait::Expression value;\n+  ExtensionSet ext_set_;\n+  arrow::compute::Expression expression;\n+  std::vector<compute::Expression> func_args;\n+  for(int i=0; i<call.args_size(); ++i){\n+    value = call.args(i);\n+    expression = FromProto(value, ext_set_).ValueOrDie();\n+    func_args.push_back(expression);\n+   }\n+  return func_args;\n+}\n+\n+substrait::Expression::ScalarFunction arrow_convert_arguments(const arrow::compute::Expression::Call& call, substrait::Expression::ScalarFunction& substrait_call, ExtensionSet* ext_set_){\n+  arrow::compute::Expression expression;\n+  std::unique_ptr<substrait::Expression> value;\n+  for(size_t i = 0; i<call.arguments.size(); ++i){\n+      expression = call.arguments[i];\n+      value = ToProto(expression, ext_set_).ValueOrDie();\n\nReview Comment:\n   Again, don't use `ValueOrDie`.\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -204,6 +209,521 @@ const int* GetIndex(const KeyToIndex& key_to_index, const Key& key) {\n   return &it->second;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Arrow function already exist in the conversion map\");\n+}\n+\n+Status FunctionMapping::AddSubstraitToArrow(std::string substrait_function_name, SubstraitToArrow conversion_func){\n+  if (substrait_to_arrow.find(substrait_function_name) != substrait_to_arrow.end()){\n+    substrait_to_arrow[substrait_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Substrait function already exist in the conversion map\");\n+}\n+\n+Result<SubstraitToArrow> FunctionMapping::GetArrowFromSubstrait(std::string name) const {\n+   if (FunctionMapping::substrait_to_arrow.find(name)!=FunctionMapping::substrait_to_arrow.end()){\n+     return FunctionMapping::substrait_to_arrow.at(name);\n+   } else {\n+    return Status::KeyError(\"Substrait function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+Result<ArrowToSubstrait> FunctionMapping::GetSubstraitFromArrow(std::string name) const {\n+   if (FunctionMapping::arrow_to_substrait.find(name)!=FunctionMapping::arrow_to_substrait.end()){\n+     return FunctionMapping::arrow_to_substrait.at(name);\n+   } else {\n+    return Status::KeyError(\"Arrow function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+std::vector<arrow::compute::Expression> substrait_convert_arguments(const substrait::Expression::ScalarFunction& call){\n+  substrait::Expression value;\n+  ExtensionSet ext_set_;\n+  arrow::compute::Expression expression;\n+  std::vector<compute::Expression> func_args;\n+  for(int i=0; i<call.args_size(); ++i){\n+    value = call.args(i);\n+    expression = FromProto(value, ext_set_).ValueOrDie();\n+    func_args.push_back(expression);\n+   }\n+  return func_args;\n+}\n+\n+substrait::Expression::ScalarFunction arrow_convert_arguments(const arrow::compute::Expression::Call& call, substrait::Expression::ScalarFunction& substrait_call, ExtensionSet* ext_set_){\n+  arrow::compute::Expression expression;\n+  std::unique_ptr<substrait::Expression> value;\n+  for(size_t i = 0; i<call.arguments.size(); ++i){\n+      expression = call.arguments[i];\n+      value = ToProto(expression, ext_set_).ValueOrDie();\n+      substrait_call.add_args()->CopyFrom(*value);\n+  }\n+  return std::move(substrait_call);\n+}\n+\n+substrait::Expression::ScalarFunction arrow_convert_enum_arguments(const arrow::compute::Expression::Call& call, substrait::Expression::ScalarFunction& substrait_call, ExtensionSet* ext_set_, std::string overflow_handling){\n+  substrait::Expression::Enum options;\n+  options.set_specified(overflow_handling);\n+  substrait_call.add_args()->set_allocated_enum_(&options);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+}\n+\n+\n+SubstraitToArrow substrait_add_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  if(func_args[0].ToString() == \"SILENT\"){\n+    return arrow::compute::call(\"add\", {func_args[1], func_args[2]}, compute::ArithmeticOptions());\n+  } else if (func_args[0].ToString() == \"SATURATE\") {\n+    return Status::Invalid(\"Arrow does not support a saturating add\");\n+   } else {\n+    return arrow::compute::call(\"add_checked\", {func_args[1], func_args[2]}, compute::ArithmeticOptions(true));\n+   }\n+ };\n+\n+SubstraitToArrow substrait_subtract_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  if(func_args[0].ToString() == \"SILENT\"){\n+    return arrow::compute::call(\"subtract\", {func_args[1], func_args[2]}, compute::ArithmeticOptions());\n+  } else if (func_args[0].ToString() == \"SATURATE\") {\n+    return Status::Invalid(\"Arrow does not support a saturating subtract\");\n+  } else {\n+    return arrow::compute::call(\"subtract_checked\", {func_args[1], func_args[2]}, compute::ArithmeticOptions(true));\n+  }\n+};\n+\n+SubstraitToArrow substrait_multiply_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  if(func_args[0].ToString() == \"SILENT\"){\n+    return arrow::compute::call(\"multiply\", {func_args[1], func_args[2]}, compute::ArithmeticOptions());\n+  } else if (func_args[0].ToString() == \"SATURATE\") {\n+    return Status::Invalid(\"Arrow does not support a saturating multiply\");\n+  } else {\n+    return arrow::compute::call(\"mutiply_checked\", {func_args[1], func_args[2]}, compute::ArithmeticOptions(true));\n+  }\n+};\n+\n+SubstraitToArrow substrait_divide_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  if(func_args[0].ToString() == \"SILENT\"){\n+    return arrow::compute::call(\"divide\", {func_args[1], func_args[2]}, compute::ArithmeticOptions());\n+  } else if (func_args[0].ToString() == \"SATURATE\") {\n+    return Status::Invalid(\"Arrow does not support a saturating divide\");\n+  } else {\n+    return arrow::compute::call(\"divide_checked\", {func_args[1], func_args[2]}, compute::ArithmeticOptions(true));\n+  }\n+};\n+\n+SubstraitToArrow substrait_modulus_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"abs\", substrait_convert_arguments(call));\n+};\n+\n+ArrowToSubstrait arrow_add_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n\nReview Comment:\n   There's a lot of places where you have `ext_set_` and it should probably be `ext_set`.  For the sake of brevity I'm not going to mark them all.\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -288,6 +808,11 @@ struct ExtensionIdRegistryImpl : ExtensionIdRegistry {\n     return Status::OK();\n   }\n \n+  Status RegisterFunctionMapping(Id id, SubstraitToArrow conversion_func) override {\n+    DCHECK_OK(functions_map.AddSubstraitToArrow(id.name.to_string(), conversion_func));  \n+    return RegisterFunction(id, id.name.to_string());\n\nReview Comment:\n   It seems a little odd that we need two maps.  What happens if two functions exist with the same name but different URIs?  Thinking on this longer, maybe `substrait_to_arrow` should replace the map in the extension id registry (that gets updated by the call to `RegisterFunction`?)\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -204,6 +209,521 @@ const int* GetIndex(const KeyToIndex& key_to_index, const Key& key) {\n   return &it->second;\n }\n \n+Status FunctionMapping::AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func){\n+  if (arrow_to_substrait.find(arrow_function_name) != arrow_to_substrait.end()){\n+    arrow_to_substrait[arrow_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Arrow function already exist in the conversion map\");\n+}\n+\n+Status FunctionMapping::AddSubstraitToArrow(std::string substrait_function_name, SubstraitToArrow conversion_func){\n+  if (substrait_to_arrow.find(substrait_function_name) != substrait_to_arrow.end()){\n+    substrait_to_arrow[substrait_function_name] =  conversion_func;\n+    return Status::OK();\n+  }\n+  return Status::AlreadyExists(\"Substrait function already exist in the conversion map\");\n+}\n+\n+Result<SubstraitToArrow> FunctionMapping::GetArrowFromSubstrait(std::string name) const {\n+   if (FunctionMapping::substrait_to_arrow.find(name)!=FunctionMapping::substrait_to_arrow.end()){\n+     return FunctionMapping::substrait_to_arrow.at(name);\n+   } else {\n+    return Status::KeyError(\"Substrait function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+Result<ArrowToSubstrait> FunctionMapping::GetSubstraitFromArrow(std::string name) const {\n+   if (FunctionMapping::arrow_to_substrait.find(name)!=FunctionMapping::arrow_to_substrait.end()){\n+     return FunctionMapping::arrow_to_substrait.at(name);\n+   } else {\n+    return Status::KeyError(\"Arrow function doesn't exist in the mapping registry\");\n+   }\n+ }\n+ \n+std::vector<arrow::compute::Expression> substrait_convert_arguments(const substrait::Expression::ScalarFunction& call){\n+  substrait::Expression value;\n+  ExtensionSet ext_set_;\n+  arrow::compute::Expression expression;\n+  std::vector<compute::Expression> func_args;\n+  for(int i=0; i<call.args_size(); ++i){\n+    value = call.args(i);\n+    expression = FromProto(value, ext_set_).ValueOrDie();\n+    func_args.push_back(expression);\n+   }\n+  return func_args;\n+}\n+\n+substrait::Expression::ScalarFunction arrow_convert_arguments(const arrow::compute::Expression::Call& call, substrait::Expression::ScalarFunction& substrait_call, ExtensionSet* ext_set_){\n+  arrow::compute::Expression expression;\n+  std::unique_ptr<substrait::Expression> value;\n+  for(size_t i = 0; i<call.arguments.size(); ++i){\n+      expression = call.arguments[i];\n+      value = ToProto(expression, ext_set_).ValueOrDie();\n+      substrait_call.add_args()->CopyFrom(*value);\n+  }\n+  return std::move(substrait_call);\n+}\n+\n+substrait::Expression::ScalarFunction arrow_convert_enum_arguments(const arrow::compute::Expression::Call& call, substrait::Expression::ScalarFunction& substrait_call, ExtensionSet* ext_set_, std::string overflow_handling){\n+  substrait::Expression::Enum options;\n+  options.set_specified(overflow_handling);\n+  substrait_call.add_args()->set_allocated_enum_(&options);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+}\n+\n+\n+SubstraitToArrow substrait_add_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  if(func_args[0].ToString() == \"SILENT\"){\n+    return arrow::compute::call(\"add\", {func_args[1], func_args[2]}, compute::ArithmeticOptions());\n+  } else if (func_args[0].ToString() == \"SATURATE\") {\n+    return Status::Invalid(\"Arrow does not support a saturating add\");\n+   } else {\n+    return arrow::compute::call(\"add_checked\", {func_args[1], func_args[2]}, compute::ArithmeticOptions(true));\n+   }\n+ };\n+\n+SubstraitToArrow substrait_subtract_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  if(func_args[0].ToString() == \"SILENT\"){\n+    return arrow::compute::call(\"subtract\", {func_args[1], func_args[2]}, compute::ArithmeticOptions());\n+  } else if (func_args[0].ToString() == \"SATURATE\") {\n+    return Status::Invalid(\"Arrow does not support a saturating subtract\");\n+  } else {\n+    return arrow::compute::call(\"subtract_checked\", {func_args[1], func_args[2]}, compute::ArithmeticOptions(true));\n+  }\n+};\n+\n+SubstraitToArrow substrait_multiply_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  if(func_args[0].ToString() == \"SILENT\"){\n+    return arrow::compute::call(\"multiply\", {func_args[1], func_args[2]}, compute::ArithmeticOptions());\n+  } else if (func_args[0].ToString() == \"SATURATE\") {\n+    return Status::Invalid(\"Arrow does not support a saturating multiply\");\n+  } else {\n+    return arrow::compute::call(\"mutiply_checked\", {func_args[1], func_args[2]}, compute::ArithmeticOptions(true));\n+  }\n+};\n+\n+SubstraitToArrow substrait_divide_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  if(func_args[0].ToString() == \"SILENT\"){\n+    return arrow::compute::call(\"divide\", {func_args[1], func_args[2]}, compute::ArithmeticOptions());\n+  } else if (func_args[0].ToString() == \"SATURATE\") {\n+    return Status::Invalid(\"Arrow does not support a saturating divide\");\n+  } else {\n+    return arrow::compute::call(\"divide_checked\", {func_args[1], func_args[2]}, compute::ArithmeticOptions(true));\n+  }\n+};\n+\n+SubstraitToArrow substrait_modulus_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"abs\", substrait_convert_arguments(call));\n+};\n+\n+ArrowToSubstrait arrow_add_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"add\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_enum_arguments(call, substrait_call, ext_set_, \"ERROR\");\n+ };\n+\n+ArrowToSubstrait arrow_unchecked_add_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"add\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_enum_arguments(call, substrait_call, ext_set_, \"SILENT\");\n+};\n+\n+ArrowToSubstrait arrow_subtract_to_substrait = [] (const arrow::compute::Expression::Call& call, arrow::engine::ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"subtract\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_enum_arguments(call, substrait_call, ext_set_, \"ERROR\");\n+};\n+\n+ArrowToSubstrait arrow_unchecked_subtract_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"subtract\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_enum_arguments(call, substrait_call, ext_set_, \"SILENT\") ;\n+};\n+\n+ArrowToSubstrait arrow_multiply_to_substrait = [] (const arrow::compute::Expression::Call& call, arrow::engine::ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"multiply\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_enum_arguments(call, substrait_call, ext_set_, \"ERROR\");\n+};\n+\n+ArrowToSubstrait arrow_unchecked_multiply_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"multiply\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_enum_arguments(call, substrait_call, ext_set_, \"SILENT\");\n+};\n+\n+\n+ArrowToSubstrait arrow_divide_to_substrait = [] (const arrow::compute::Expression::Call& call, arrow::engine::ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"divide\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_enum_arguments(call, substrait_call, ext_set_, \"ERROR\");\n+};\n+\n+ArrowToSubstrait arrow_unchecked_divide_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"divide\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_enum_arguments(call, substrait_call, ext_set_, \"SILENT\");\n+};\n+\n+ArrowToSubstrait arrow_abs_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"modulus\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+// Boolean Functions mappings\n+SubstraitToArrow substrait_not_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"invert\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_or_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"or_kleene\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_and_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"and_kleene\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_xor_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"xor\", substrait_convert_arguments(call));\n+};\n+\n+ArrowToSubstrait arrow_invert_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"not\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_or_kleene_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"or\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_and_kleene_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"and\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_xor_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"xor\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+// Comparison Functions mapping\n+SubstraitToArrow substrait_lt_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"less\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_gt_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"greater\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_lte_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"less_equal\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_gte_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"greater_equal\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_not_equal_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"not_equal\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_equal_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"equal\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_is_null_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"is_null\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_is_not_null_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  return arrow::compute::call(\"is_valid\", substrait_convert_arguments(call));\n+};\n+\n+SubstraitToArrow substrait_is_not_distinct_from_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  std::vector<compute::Expression> func_args = substrait_convert_arguments(call);\n+  auto null_check_1 = arrow::compute::call(\"is_null\", {func_args[0]});\n+  auto null_check_2 = arrow::compute::call(\"is_null\", {func_args[1]});\n+  if(null_check_1.IsNullLiteral() && null_check_1.IsNullLiteral()){\n+    return arrow::compute::call(\"not_equal\", {null_check_1, null_check_2});\n+  }\n+  return arrow::compute::call(\"not_equal\", func_args);\n+};\n+\n+ArrowToSubstrait arrow_less_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"lt\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_greater_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"gt\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_less_equal_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"lte\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_greater_equal_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"gte\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_equal_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"equal\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_not_equal_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"not_equal\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_is_null_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"is_null\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+ArrowToSubstrait arrow_is_valid_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"is_not_null\"));\n+  substrait_call.set_function_reference(function_reference);\n+  return arrow_convert_arguments(call, substrait_call, ext_set_);\n+};\n+\n+// Strings function mapping\n+SubstraitToArrow substrait_like_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  return arrow::compute::call(\"match_like\", {func_args[0]}, compute::MatchSubstringOptions(func_args[1].ToString()));\n+};\n+\n+SubstraitToArrow substrait_substring_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  auto start = func_args[1].literal()->scalar_as<Int64Scalar>();\n+  auto stop = func_args[2].literal()->scalar_as<Int64Scalar>();\n+  return arrow::compute::call(\"utf8_slice_codeunits\", {func_args[0]}, compute::SliceOptions(static_cast<int64_t>(start.value), static_cast<int64_t>(stop.value)));\n+};\n+\n+SubstraitToArrow substrait_concat_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  arrow::StringBuilder builder;\n+  builder.Append(func_args[0].ToString());\n+  builder.Append(func_args[1].ToString());\n+  auto strings_datum = arrow::Datum(*builder.Finish());\n+  auto separator_datum = arrow::Datum(\"\");\n+  return arrow::compute::call(\"binary_join\", {arrow::compute::Expression(strings_datum), arrow::compute::Expression(separator_datum)});\n+};\n+\n+ArrowToSubstrait arrow_match_like_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"like\"));\n+  substrait_call.set_function_reference(function_reference);\n+\n+  arrow::compute::Expression expression_1, expression_2;\n+  std::unique_ptr<substrait::Expression> string_1, string_2;\n+  expression_1 = call.arguments[0];\n+  string_1 = ToProto(expression_1, ext_set_).ValueOrDie();\n+  substrait_call.add_args()->CopyFrom(*string_1);\n+\n+  auto pattern_string = std::dynamic_pointer_cast<compute::MatchSubstringOptions>(call.options)->pattern;\n+  expression_2 = arrow::compute::Expression(arrow::Datum(pattern_string));\n+  string_2 = ToProto(expression_2, ext_set_).ValueOrDie();\n+  substrait_call.add_args()->CopyFrom(*string_2);\n+\n+  return std::move(substrait_call);\n+};\n+\n+ArrowToSubstrait arrow_utf8_slice_codeunits_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"substring\"));\n+  substrait_call.set_function_reference(function_reference);\n+  arrow::compute::Expression expression_1, expression_2, expression_3;\n+  std::unique_ptr<substrait::Expression> string, start, stop;\n+  expression_1 = call.arguments[0];\n+  string = ToProto(expression_1, ext_set_).ValueOrDie();\n+  substrait_call.add_args()->CopyFrom(*string);\n+\n+  auto start_index = std::dynamic_pointer_cast<compute::SliceOptions>(call.options)->start;\n+  auto stop_index = std::dynamic_pointer_cast<compute::SliceOptions>(call.options)->stop;\n+  expression_2 = arrow::compute::Expression(arrow::Datum(start_index));\n+  expression_3 = arrow::compute::Expression(arrow::Datum(stop_index));\n+  start =  ToProto(expression_2, ext_set_).ValueOrDie();\n+  stop  =  ToProto(expression_3, ext_set_).ValueOrDie();\n+  substrait_call.add_args()->CopyFrom(*start);\n+  substrait_call.add_args()->CopyFrom(*stop);\n+\n+  return std::move(substrait_call);\n+};\n+\n+ArrowToSubstrait arrow_binary_join_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"concat\"));\n+  substrait_call.set_function_reference(function_reference);\n+  arrow::compute::Expression expression_1, expression_2;\n+  std::unique_ptr<substrait::Expression> string_1, string_2;\n+\n+  auto strings_list = call.arguments[0].literal()->make_array();\n+  expression_1 = arrow::compute::Expression(*(strings_list->GetScalar(0)));\n+  expression_2 = arrow::compute::Expression(*(strings_list->GetScalar(1)));\n+\n+  string_1 = ToProto(expression_1, ext_set_).ValueOrDie();\n+  string_2 = ToProto(expression_2, ext_set_).ValueOrDie();\n+  substrait_call.add_args()->CopyFrom(*string_1);\n+  substrait_call.add_args()->CopyFrom(*string_2);\n+  return std::move(substrait_call);\n+};\n+\n+// Cast function mapping\n+SubstraitToArrow substrait_cast_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  ExtensionSet ext_set_;\n+  ARROW_ASSIGN_OR_RAISE(auto output_type_desc,\n+                              FromProto(call.output_type(), ext_set_));\n+  auto cast_options = compute::CastOptions::Safe(std::move(output_type_desc.first));\n+  return compute::call(\"cast\", {substrait_convert_arguments(call)[0]}, std::move(cast_options));\n+};\n+\n+ArrowToSubstrait arrow_cast_to_substrait = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n+  substrait::Expression::ScalarFunction substrait_call;\n+  ARROW_ASSIGN_OR_RAISE(auto function_reference, ext_set_->EncodeFunction(\"cast\"));\n+  substrait_call.set_function_reference(function_reference);\n+  \n+  auto arrow_to_type = std::dynamic_pointer_cast<compute::CastOptions>(call.options)->to_type;\n+  ARROW_ASSIGN_OR_RAISE(auto substrait_to_type, ToProto(*arrow_to_type, false, ext_set_));\n+  substrait_call.set_allocated_output_type(substrait_to_type.get());\n+\n+  auto expression = call.arguments[0];\n+  ARROW_ASSIGN_OR_RAISE(auto value, ToProto(expression, ext_set_));\n+  substrait_call.add_args()->CopyFrom(*value);\n+  \n+  return substrait_call;\n+};\n+\n+// Datetime functions mapping\n+SubstraitToArrow substrait_extract_to_arrow = [] (const substrait::Expression::ScalarFunction& call) -> Result<arrow::compute::Expression>  {\n+  auto func_args = substrait_convert_arguments(call);\n+  if(func_args[0].ToString() == \"YEAR\"){\n+    return arrow::compute::call(\"year\", {func_args[1]});\n+  } else if (func_args[0].ToString() == \"MONTH\") {\n+    return arrow::compute::call(\"month\", {func_args[1]});\n+  } else if (func_args[0].ToString() == \"DAY\") {\n+    return arrow::compute::call(\"day\", {func_args[1]});\n+  } else {\n+    return arrow::compute::call(\"second\", {func_args[1]});\n+  }\n+};\n+\n+ArrowToSubstrait arrow_year_to_arrow = [] (const arrow::compute::Expression::Call& call, ExtensionSet* ext_set_) -> Result<substrait::Expression::ScalarFunction> {\n\nReview Comment:\n   `arrow_...to_arrow`?\n\n\n\n",
                    "created": "2022-06-17T01:10:40.571+0000",
                    "updated": "2022-06-17T01:10:40.571+0000",
                    "started": "2022-06-17T01:10:40.570+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "782200",
                    "issueId": "13426719"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/791178",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace opened a new pull request, #13613:\nURL: https://github.com/apache/arrow/pull/13613\n\n   This picks up where #13285 has left off.  It only focuses on the Substrait->Arrow direction at the moment.  In addition, basic support is added for named tables.  This makes it easy to create unit tests that read from in-memory tables instead of requiring unit tests to do a scan.\r\n   \r\n   Right now this PR is pretty rough and still needs some cleanup:\r\n   \r\n    * I've stuck the function converter registry and named table provider in the extension set for now just so I have a place to put it. Once #13537 merges I'd prefer these to be part of converter options.\r\n    * The extension set no longer needs function records in the same way and should be trimmed up.\r\n    * Various FIXME / hacks put in place to get things working should be smoothed out.\r\n    * Only add/add_checked are implemented at the moment.  I need to copy over the rest of the standard functions, but this should be fairly straightforward now.\r\n   \n\n\n",
                    "created": "2022-07-14T23:01:41.817+0000",
                    "updated": "2022-07-14T23:01:41.817+0000",
                    "started": "2022-07-14T23:01:41.816+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "791178",
                    "issueId": "13426719"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/791179",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13613:\nURL: https://github.com/apache/arrow/pull/13613#issuecomment-1184972185\n\n   https://issues.apache.org/jira/browse/ARROW-15582\n\n\n",
                    "created": "2022-07-14T23:02:06.944+0000",
                    "updated": "2022-07-14T23:02:06.944+0000",
                    "started": "2022-07-14T23:02:06.943+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "791179",
                    "issueId": "13426719"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/791243",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on code in PR #13613:\nURL: https://github.com/apache/arrow/pull/13613#discussion_r921780460\n\n\n##########\ncpp/src/arrow/compute/exec/util.cc:\n##########\n@@ -383,5 +383,25 @@ size_t ThreadIndexer::Check(size_t thread_index) {\n   return thread_index;\n }\n \n+Status TableSinkNodeConsumer::Init(const std::shared_ptr<Schema>& schema,\n+                                   BackpressureControl* backpressure_control) {\n+  // If the user is collecting into a table then backpressure is meaningless\n+  ARROW_UNUSED(backpressure_control);\n+  schema_ = schema;\n+  return Status::OK();\n+}\n+\n+Status TableSinkNodeConsumer::Consume(ExecBatch batch) {\n+  auto guard = consume_mutex_.Lock();\n+  ARROW_ASSIGN_OR_RAISE(auto rb, batch.ToRecordBatch(schema_, pool_));\n+  batches_.push_back(rb);\n\nReview Comment:\n   should we move this? \n\n\n\n",
                    "created": "2022-07-15T03:28:27.058+0000",
                    "updated": "2022-07-15T03:28:27.058+0000",
                    "started": "2022-07-15T03:28:27.057+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "791243",
                    "issueId": "13426719"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/791244",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on code in PR #13613:\nURL: https://github.com/apache/arrow/pull/13613#discussion_r921780857\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -129,18 +136,19 @@ Result<ExtensionSet> ExtensionSet::Make(\n     return Status::Invalid(\"Type \", type_ids[i].uri, \"#\", type_ids[i].name, \" not found\");\n   }\n \n-  set.functions_.reserve(function_ids.size());\n+  // set.functions_.reserve(function_ids.size());\n \n   for (unsigned int i = 0; i < static_cast<unsigned int>(function_ids.size()); ++i) {\n     if (function_ids[i].empty()) continue;\n     RETURN_NOT_OK(set.CheckHasUri(function_ids[i].uri));\n-\n-    if (auto rec = registry->GetFunction(function_ids[i])) {\n-      set.functions_[i] = {rec->id, rec->function_name};\n-      continue;\n-    }\n-    return Status::Invalid(\"Function \", function_ids[i].uri, \"#\", function_ids[i].name,\n-                           \" not found\");\n+    set.functions_[i] = {{function_ids[i].uri, function_ids[i].name}, \"dummy\"};\n+\n+    // if (auto rec = registry->GetFunction(function_ids[i])) {\n+    //   set.functions_[i] = {rec->id, rec->function_name};\n+    //   continue;\n+    // }\n+    // return Status::Invalid(\"Function \", function_ids[i].uri, \"#\", function_ids[i].name,\n+    //                        \" not found\");\n\nReview Comment:\n   should we remove this or intended to use?\n\n\n\n",
                    "created": "2022-07-15T03:29:52.134+0000",
                    "updated": "2022-07-15T03:29:52.134+0000",
                    "started": "2022-07-15T03:29:52.134+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "791244",
                    "issueId": "13426719"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/791246",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on code in PR #13613:\nURL: https://github.com/apache/arrow/pull/13613#discussion_r921781258\n\n\n##########\ncpp/src/arrow/engine/substrait/function_test.cc:\n##########\n@@ -0,0 +1,156 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include <google/protobuf/util/json_util.h>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/array/builder_binary.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/engine/substrait/function_internal.h\"\n+#include \"arrow/engine/substrait/plan_internal.h\"\n+#include \"arrow/engine/substrait/serde.h\"\n+#include \"arrow/engine/substrait/test_plan_builder.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/future_util.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/type.h\"\n+\n+namespace arrow {\n+\n+namespace engine {\n+\n+struct FunctionTestCase {\n+  ExtensionSet::Id function_id;\n+  std::vector<std::string> arguments;\n+  std::vector<std::shared_ptr<DataType>> data_types;\n+};\n+\n+struct ValidFunctionTestCase {\n+  ExtensionSet::Id function_id;\n+  std::vector<std::string> arguments;\n+  std::vector<std::shared_ptr<DataType>> data_types;\n+  std::string expected_output;\n+  std::shared_ptr<DataType> expected_output_type;\n+};\n+\n+std::shared_ptr<Array> GetArray(const std::string& value,\n+                                const std::shared_ptr<DataType>& data_type) {\n+  StringBuilder str_builder;\n+  ARROW_EXPECT_OK(str_builder.Append(value));\n+  EXPECT_OK_AND_ASSIGN(std::shared_ptr<Array> value_str, str_builder.Finish());\n+  EXPECT_OK_AND_ASSIGN(Datum value_datum, compute::Cast(value_str, data_type));\n+  return value_datum.make_array();\n+}\n+\n+std::shared_ptr<Table> GetInputTable(\n+    const std::vector<std::string>& arguments,\n+    const std::vector<std::shared_ptr<DataType>>& data_types) {\n+  std::vector<std::shared_ptr<Array>> columns;\n+  std::vector<std::shared_ptr<Field>> fields;\n+  EXPECT_EQ(arguments.size(), data_types.size());\n+  for (std::size_t i = 0; i < arguments.size(); i++) {\n+    if (data_types[i]) {\n+      columns.push_back(GetArray(arguments[i], data_types[i]));\n+      fields.push_back(field(\"arg_\" + std::to_string(i), data_types[i]));\n+    }\n+  }\n+  std::shared_ptr<RecordBatch> batch =\n+      RecordBatch::Make(schema(std::move(fields)), 1, columns);\n+  EXPECT_OK_AND_ASSIGN(std::shared_ptr<Table> table, Table::FromRecordBatches({batch}));\n+  return table;\n+}\n+\n+std::shared_ptr<Table> GetOutputTable(const std::string& output_value,\n+                                      const std::shared_ptr<DataType>& output_type) {\n+  std::vector<std::shared_ptr<Array>> columns(1);\n+  std::vector<std::shared_ptr<Field>> fields(1);\n+  columns[0] = GetArray(output_value, output_type);\n+  fields[0] = field(\"output\", output_type);\n+  std::shared_ptr<RecordBatch> batch =\n+      RecordBatch::Make(schema(std::move(fields)), 1, columns);\n+  EXPECT_OK_AND_ASSIGN(std::shared_ptr<Table> table, Table::FromRecordBatches({batch}));\n+  return table;\n+}\n+\n+void CheckValidTestCases(const std::vector<ValidFunctionTestCase>& valid_cases) {\n+  for (const ValidFunctionTestCase& test_case : valid_cases) {\n+    std::shared_ptr<Table> input_table =\n+        GetInputTable(test_case.arguments, test_case.data_types);\n+    std::cout << \"Input Table: \" << input_table->ToString() << std::endl;\n+    ASSERT_OK_AND_ASSIGN(std::shared_ptr<Buffer> substrait,\n+                         internal::CreateScanProjectSubstrait(\n+                             test_case.function_id, input_table, test_case.arguments,\n+                             test_case.data_types, *test_case.expected_output_type));\n+    ASSERT_OK_AND_ASSIGN(auto plan_json, internal::SubstraitToJSON(\"Plan\", *substrait));\n+    std::cout << plan_json << std::endl;\n+    std::shared_ptr<Table> output_table;\n+    std::shared_ptr<compute::SinkNodeConsumer> consumer =\n+        std::make_shared<compute::TableSinkNodeConsumer>(&output_table,\n+                                                         default_memory_pool());\n+\n+    // Mock table provider that ignores the table name and returns input_table\n+    NamedTableProvider table_provider = [input_table](const std::vector<std::string>&) {\n+      std::shared_ptr<compute::ExecNodeOptions> options =\n+          std::make_shared<compute::TableSourceNodeOptions>(input_table);\n+      return compute::Declaration(\"table_source\", {}, options, \"mock_source\");\n+    };\n+\n+    ASSERT_OK_AND_ASSIGN(\n+        std::shared_ptr<compute::ExecPlan> plan,\n+        DeserializePlan(*substrait, std::move(consumer), default_extension_id_registry(),\n+                        /*ext_set_out=*/nullptr, std::move(table_provider)));\n+    std::cout << \"Plan: \" << plan->ToString() << std::endl;\n+    ASSERT_OK(plan->StartProducing());\n+    ASSERT_FINISHES_OK(plan->finished());\n+    std::cout << \"Output Table: \" << output_table->ToString() << std::endl;\n+\n+    // Could also modify the Substrait plan with an emit to drop the leading columns\n+    ASSERT_OK_AND_ASSIGN(output_table,\n+                         output_table->SelectColumns({output_table->num_columns() - 1}));\n+\n+    std::shared_ptr<Table> expected_output =\n+        GetOutputTable(test_case.expected_output, test_case.expected_output_type);\n+    AssertTablesEqual(*expected_output, *output_table, /*same_chunk_layout=*/false);\n+  }\n+}\n+\n+TEST(FunctionMapping, ValidCases) {\n+  const std::vector<ValidFunctionTestCase> valid_test_cases = {\n+      {{kSubstraitArithmeticFunctionsUri, \"add\"},\n+       {\"SILENT\", \"127\", \"10\"},\n+       {nullptr, int8(), int8()},\n+       \"-119\",\n+       int8()}};\n+  CheckValidTestCases(valid_test_cases);\n+  // const std::vector<FunctionTestCase> error_test_cases = {\n+  //     {{kSubstraitArithmeticFunctionsUri, \"add\"},\n+  //      {\"ERROR\", \"127\", \"10\"},\n+  //      {nullptr, int8(), int8()}}};\n\nReview Comment:\n   should we remove this?\n\n\n\n",
                    "created": "2022-07-15T03:31:12.493+0000",
                    "updated": "2022-07-15T03:31:12.493+0000",
                    "started": "2022-07-15T03:31:12.492+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "791246",
                    "issueId": "13426719"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/worklog/791864",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13613:\nURL: https://github.com/apache/arrow/pull/13613#discussion_r923016345\n\n\n##########\ncpp/src/arrow/engine/substrait/function_test.cc:\n##########\n@@ -0,0 +1,156 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include <google/protobuf/util/json_util.h>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/array/builder_binary.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/engine/substrait/function_internal.h\"\n+#include \"arrow/engine/substrait/plan_internal.h\"\n+#include \"arrow/engine/substrait/serde.h\"\n+#include \"arrow/engine/substrait/test_plan_builder.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/future_util.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/type.h\"\n+\n+namespace arrow {\n+\n+namespace engine {\n+\n+struct FunctionTestCase {\n+  ExtensionSet::Id function_id;\n+  std::vector<std::string> arguments;\n+  std::vector<std::shared_ptr<DataType>> data_types;\n+};\n+\n+struct ValidFunctionTestCase {\n+  ExtensionSet::Id function_id;\n+  std::vector<std::string> arguments;\n+  std::vector<std::shared_ptr<DataType>> data_types;\n+  std::string expected_output;\n+  std::shared_ptr<DataType> expected_output_type;\n+};\n+\n+std::shared_ptr<Array> GetArray(const std::string& value,\n+                                const std::shared_ptr<DataType>& data_type) {\n+  StringBuilder str_builder;\n+  ARROW_EXPECT_OK(str_builder.Append(value));\n+  EXPECT_OK_AND_ASSIGN(std::shared_ptr<Array> value_str, str_builder.Finish());\n+  EXPECT_OK_AND_ASSIGN(Datum value_datum, compute::Cast(value_str, data_type));\n+  return value_datum.make_array();\n+}\n+\n+std::shared_ptr<Table> GetInputTable(\n+    const std::vector<std::string>& arguments,\n+    const std::vector<std::shared_ptr<DataType>>& data_types) {\n+  std::vector<std::shared_ptr<Array>> columns;\n+  std::vector<std::shared_ptr<Field>> fields;\n+  EXPECT_EQ(arguments.size(), data_types.size());\n+  for (std::size_t i = 0; i < arguments.size(); i++) {\n+    if (data_types[i]) {\n+      columns.push_back(GetArray(arguments[i], data_types[i]));\n+      fields.push_back(field(\"arg_\" + std::to_string(i), data_types[i]));\n+    }\n+  }\n+  std::shared_ptr<RecordBatch> batch =\n+      RecordBatch::Make(schema(std::move(fields)), 1, columns);\n+  EXPECT_OK_AND_ASSIGN(std::shared_ptr<Table> table, Table::FromRecordBatches({batch}));\n+  return table;\n+}\n+\n+std::shared_ptr<Table> GetOutputTable(const std::string& output_value,\n+                                      const std::shared_ptr<DataType>& output_type) {\n+  std::vector<std::shared_ptr<Array>> columns(1);\n+  std::vector<std::shared_ptr<Field>> fields(1);\n+  columns[0] = GetArray(output_value, output_type);\n+  fields[0] = field(\"output\", output_type);\n+  std::shared_ptr<RecordBatch> batch =\n+      RecordBatch::Make(schema(std::move(fields)), 1, columns);\n+  EXPECT_OK_AND_ASSIGN(std::shared_ptr<Table> table, Table::FromRecordBatches({batch}));\n+  return table;\n+}\n+\n+void CheckValidTestCases(const std::vector<ValidFunctionTestCase>& valid_cases) {\n+  for (const ValidFunctionTestCase& test_case : valid_cases) {\n+    std::shared_ptr<Table> input_table =\n+        GetInputTable(test_case.arguments, test_case.data_types);\n+    std::cout << \"Input Table: \" << input_table->ToString() << std::endl;\n+    ASSERT_OK_AND_ASSIGN(std::shared_ptr<Buffer> substrait,\n+                         internal::CreateScanProjectSubstrait(\n+                             test_case.function_id, input_table, test_case.arguments,\n+                             test_case.data_types, *test_case.expected_output_type));\n+    ASSERT_OK_AND_ASSIGN(auto plan_json, internal::SubstraitToJSON(\"Plan\", *substrait));\n+    std::cout << plan_json << std::endl;\n+    std::shared_ptr<Table> output_table;\n+    std::shared_ptr<compute::SinkNodeConsumer> consumer =\n+        std::make_shared<compute::TableSinkNodeConsumer>(&output_table,\n+                                                         default_memory_pool());\n+\n+    // Mock table provider that ignores the table name and returns input_table\n+    NamedTableProvider table_provider = [input_table](const std::vector<std::string>&) {\n+      std::shared_ptr<compute::ExecNodeOptions> options =\n+          std::make_shared<compute::TableSourceNodeOptions>(input_table);\n+      return compute::Declaration(\"table_source\", {}, options, \"mock_source\");\n+    };\n+\n+    ASSERT_OK_AND_ASSIGN(\n+        std::shared_ptr<compute::ExecPlan> plan,\n+        DeserializePlan(*substrait, std::move(consumer), default_extension_id_registry(),\n+                        /*ext_set_out=*/nullptr, std::move(table_provider)));\n+    std::cout << \"Plan: \" << plan->ToString() << std::endl;\n+    ASSERT_OK(plan->StartProducing());\n+    ASSERT_FINISHES_OK(plan->finished());\n+    std::cout << \"Output Table: \" << output_table->ToString() << std::endl;\n+\n+    // Could also modify the Substrait plan with an emit to drop the leading columns\n+    ASSERT_OK_AND_ASSIGN(output_table,\n+                         output_table->SelectColumns({output_table->num_columns() - 1}));\n+\n+    std::shared_ptr<Table> expected_output =\n+        GetOutputTable(test_case.expected_output, test_case.expected_output_type);\n+    AssertTablesEqual(*expected_output, *output_table, /*same_chunk_layout=*/false);\n+  }\n+}\n+\n+TEST(FunctionMapping, ValidCases) {\n+  const std::vector<ValidFunctionTestCase> valid_test_cases = {\n+      {{kSubstraitArithmeticFunctionsUri, \"add\"},\n+       {\"SILENT\", \"127\", \"10\"},\n+       {nullptr, int8(), int8()},\n+       \"-119\",\n+       int8()}};\n+  CheckValidTestCases(valid_test_cases);\n+  // const std::vector<FunctionTestCase> error_test_cases = {\n+  //     {{kSubstraitArithmeticFunctionsUri, \"add\"},\n+  //      {\"ERROR\", \"127\", \"10\"},\n+  //      {nullptr, int8(), int8()}}};\n\nReview Comment:\n   I uncommented this and implemented these cases.\n\n\n\n",
                    "created": "2022-07-18T06:51:45.395+0000",
                    "updated": "2022-07-18T06:51:45.395+0000",
                    "started": "2022-07-18T06:51:45.395+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "791864",
                    "issueId": "13426719"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 46200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@3f1d6665[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@320d2bad[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1fb02125[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@44bb213d[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6845bd85[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@71d5591a[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6f72f70c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@72dd9116[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3731b35d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@6c773128[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@14c5713d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@a8e1792[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 46200,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Aug 10 19:27:09 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-08-10T19:27:09.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15582/watchers",
            "watchCount": 5,
            "isWatching": false
        },
        "created": "2022-02-05T01:08:56.000+0000",
        "updated": "2022-08-10T21:42:02.000+0000",
        "timeoriginalestimate": null,
        "description": "Sometimes one Substrait function will map to multiple Arrow functions.  For example, the Substrait {{add}} function might be referring to Arrow's {{add}} or {{add_checked}}.  We need to figure out how to register this correctly (e.g. one possible approach would be a {{substrait_add}} meta function).\r\n\r\nOther times a substrait function will encode something Arrow considers an \"option\" as a function argument.  For example, the is_in Arrow function is unary with an option for the lookup set.  The substrait function is binary but the second argument must be constant and be the lookup set.  Neither of which is to be confused with a truly binary is_in function which takes in a different set at every row.\r\n\r\nIt's possible there is no work to do here other than adding a bunch of substrait_ meta functions in Arrow.  In that case all the work will be done in other JIRAs.  Or, it is possible that there is some kind of extension we can make to the function registry that bypasses the need for the meta functions.  I'm leaving this JIRA open so future contributors can consider this second option.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "12h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 46200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Add support for registering tricky functions with the Substrait consumer (or add a bunch of substrait meta functions)",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/comment/17527868",
                    "id": "17527868",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "There are <100 \"standard\" Substrait functions right now but this list will probably grow.  In general I do not think it is safe to assume that Substrait functions & Arrow functions will share the same name.  Even if two functions do exist with the same name I don't think it's safe to assume they will have the same behavior.  I think some kind of \"mapping\" object is going to have to be maintained.\r\n\r\nAt a minimum one would think this mapping object would be a simple bidirectional string:string map which goes from Arrow function name to Substrait function name and back.  Unfortunately, as the ticket describes, I do not think this is possible today.\r\n\r\nThe worst case scenario is that we require two functions for every entry in the mapping.  One that goes from a Substrait \"call\" to an Arrow \"call\" and the reverse.  I think, as a first attempt, we should tackle this with a very manual mapping, probably with some kind of convenience option for the functions that are simple aliases and then we can look at how we improve from there.\r\n\r\nA substrait \"call\" is a name (string), a vector of arguments (expressions), and a vector of options (literal expressions).  An arrow \"call\" is a name (string), a vector of arguments (expressions), and an options object (POCO).\r\n\r\nSo my suggestion for the mapping would be something like...\r\n\r\n{noformat}\r\nusing ArrowToSubstrait = std::function<substrait::Expression::ScalarFunction(const arrow::compute::Expression::Call&, std::vector<substrait::Expression>)>;\r\nusing SubstraitToArrow = std::function<arrow::compute::Expression::Call(const substrait::Expression::ScalarFunction&)>;\r\nclass FunctionMapping {\r\n\r\n  // Registration API\r\n  AddArrowToSubstrait(std::string arrow_function_name, ArrowToSubstrait conversion_func);\r\n  AddSubstraitToArrow(std::string substrait_function_name, SubstraitToArrow conversion_func);\r\n\r\n  // Usage API\r\n  substrait::Expression::ScalarFunction ToProto(const arrow::compute::Expression::Call& call);\r\n  arrow::compute::Expression::Call FromProto(const substrait::Expression::ScalarFunction& call);\r\n};\r\n{noformat}\r\n\r\nThe add function is an interesting example (some pseudo-code / imaginary helper functions for brevity):\r\n\r\n{noformat}\r\nSubstraitToArrow substrait_add_to_arrow = [] (const substrait::Expression::ScalarFunction& call)  {\r\n  // Note, Substrait scalar functions don't distinguish between options and arguments so the\r\n  // index of this option is 2 because it comes after the operands (at index 0 and 1).\r\n  // This is why we have to specify how many args there are in the GetArgs invocation.\r\n  auto args = GetArgs(call, 2);\r\n  EnumLiteral overflow_handling = GetOption<EnumLiteral>(call, 2);\r\n  if (IsSpecified(overflow_handling)) {\r\n    switch (GetEnumValue(overflow_handling)) {\r\n      case \"SILENT\":\r\n        return call(\"add\", args);\r\n      case \"SATURATE\":\r\n        return Status::Invalid(\"Arrow does not have a saturating add\");\r\n      case \"ERROR\":\r\n        return call(\"add_checked\", args);\r\n    }\r\n  } else {\r\n    // Default to unchecked add because SILENT => unchecked and SILENT\r\n    // is the first option in the enum (and thus the highest priority when\r\n    // not specified)\r\n    return call(\"add\", args);\r\n  }\r\n};\r\n// Note, we can automatically do the conversion from arrow args to Substrait args because\r\n// we distinguish between args and options in Arrow.\r\nArrowToSubstrait arrow_add_to_substrait = [] (const arrow::compute::Expression::Call& call, std::vector<substrait::Expression> args) {\r\n  var overflow_behavior = MakeEnum(\"ERROR\");\r\n  var all_args = Concat(std::move(args), {overflow_behavior});\r\n  return MakeSubstraitCall(\"add\", std::move(all_args));\r\n};\r\nArrowToSubstrait arrow_unchecked_add_to_substrait = [] (const arrow::compute::Expression::Call& call, std::vector<substrait::Expression> args) {\r\n  var overflow_behavior = MakeEnum(\"SILENT\");\r\n  var all_args = Concat(std::move(args), {overflow_behavior});\r\n  return MakeSubstraitCall(\"add\", std::move(all_args));\r\n};\r\nfunction_mapping.AddSubstraitToArrow(\"add\", substrait_add_to_arrow);\r\nfunction_mapping.AddArrowToSubstrait(\"add\", arrow_add_to_substrait);\r\nfunction_mapping.AddArrowToSubstrait(\"add_unchecked\", arrow_add_unchecked_to_substrait);\r\n{noformat}",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-04-26T03:39:56.643+0000",
                    "updated": "2022-04-26T03:39:56.643+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/comment/17527869",
                    "id": "17527869",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "It's unclear how much testing should be done here.  Conformance testing for Substrait is a large question and could/should be shared by multiple implementations.  If there were a sophisticated conformance tester then testing of the mapping code could be fairly minimal.\r\n\r\nAlso, if there were conformance testing then I think one could prioritize / only implement the Substrait -> Arrow path as the Arrow -> Substrait path is currently only used for testing (although one can imagine non-testing applications).",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-04-26T03:45:13.511+0000",
                    "updated": "2022-04-26T03:45:13.511+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/comment/17527871",
                    "id": "17527871",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Also, the above example of {{add}}/{{add_unchecked}} is a worst case scenario.  Some functions should be much simpler:\r\n\r\n{noformat}\r\n// The \"less than\" function has no options in both arrow and Substrait\r\nAddSimpleMapping(function_mapping, \"less\", \"lt\");\r\n{noformat}",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-04-26T03:50:34.896+0000",
                    "updated": "2022-04-26T03:50:34.896+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/comment/17527872",
                    "id": "17527872",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "[~lidavidm] [~jvanstraten] [~vibhatha] [~sanjibansg] [~ArianaVillegas]\r\n\r\nTagging for discussion.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-04-26T03:51:25.010+0000",
                    "updated": "2022-04-26T03:52:39.981+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/comment/17528177",
                    "id": "17528177",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "I agree we're going to need some sort of mapping. I think someone will just have to sit down and look through all the functions to determine how best to structure/maintain this, though; maybe most are fairly trivial, some patterns exist like for arithmetic, and a few are just special cases (if_else etc. perhaps).",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2022-04-26T13:41:53.426+0000",
                    "updated": "2022-04-26T13:41:53.426+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/comment/17530271",
                    "id": "17530271",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=sanjibansg",
                        "name": "sanjibansg",
                        "key": "JIRAUSER282926",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
                        },
                        "displayName": "Sanjiban Sengupta",
                        "active": true,
                        "timeZone": "Asia/Kolkata"
                    },
                    "body": "The following spreadsheet provides a table of functions in Substrait and their equivalent in Arrow along with the required options for both of them.\r\n\r\nhttps://docs.google.com/spreadsheets/d/1Jm7vt-sTxsmB7HlLsdWPk6LFINcOGzZjU9SL4ZtiYoY/edit?usp=sharing",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=sanjibansg",
                        "name": "sanjibansg",
                        "key": "JIRAUSER282926",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
                        },
                        "displayName": "Sanjiban Sengupta",
                        "active": true,
                        "timeZone": "Asia/Kolkata"
                    },
                    "created": "2022-04-29T23:20:03.939+0000",
                    "updated": "2022-04-29T23:20:03.939+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/comment/17530378",
                    "id": "17530378",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=rtpsw",
                        "name": "rtpsw",
                        "key": "JIRAUSER284707",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=JIRAUSER284707&avatarId=49322",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=JIRAUSER284707&avatarId=49322",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=JIRAUSER284707&avatarId=49322",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=JIRAUSER284707&avatarId=49322"
                        },
                        "displayName": "Yaron Gvili",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "This is an interesting discussion for me as I ran into this issue myself. In my specific use case, which only required a specific set of functions, I was able to manage by hard-coding a couple of simple Substrait-to-Arrow function-name mappings and by adding a [special case for cast|https://github.com/apache/arrow/pull/13032], which I'm not sure fits the above API - the return-type, which affects the cast operation, might be missing from the Arrow-to-Substrait API. At least for me, it would be useful to get a short-term solution that provides (perhaps configurable) simple mappings.\r\n\r\nIn the context of the general discussion, Substrait also has a ternary-function \"clip\" that does not currently appear in the list. Some possible solutions for it are:\r\n # Map \"clip(x, a, b)\" to an Arrow expression like \"min_element_wise(max_element_wise(x, a), b)\". This solution would work with the above Substrait-to-Arrow API but would require some kind of expression-matching in the reverse direction.\r\n # Add An Arrow \"clip\" function. AFAIK, Arrow has good support for unary and binary scalar kernels but not for ternary ones, so this solution might involve adding this support first.\r\n # Translate \"clip(x, a, b)\" to \"clip_upper(clip_lower(x, a), b)\" in Substrait and then add simple mappings from \"clip_upper\" and \"clip_lower\" in Substrait to \"min_element_wise\" and \"max_element_wise\" in Arrow, respectively. This solution has an impact on the Substrait DSL specification.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=rtpsw",
                        "name": "rtpsw",
                        "key": "JIRAUSER284707",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=JIRAUSER284707&avatarId=49322",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=JIRAUSER284707&avatarId=49322",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=JIRAUSER284707&avatarId=49322",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=JIRAUSER284707&avatarId=49322"
                        },
                        "displayName": "Yaron Gvili",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-04-30T11:13:11.001+0000",
                    "updated": "2022-05-01T10:28:05.062+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/comment/17530945",
                    "id": "17530945",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "I'd have a slight preference for #2 (Arrow has two ternary functions at the moment, if_else, and replace_with_mask, and it shouldn't be too bad to add more).\r\n\r\nI think #1 is something that will happen a lot at some point but I feel like it lives in the realm of the query planner/optimizer.  So I'd almost want to say \"Arrow doesn't support that function\" before we get into the realm of \"equivalent but not identical plans\".\r\n\r\nHaving something like #3 in Substrait would possible enable something like #1 to happen in a query planner.  One could then imagine the following conversation between planner and consumer:\r\n * Planner: Do you support clip?\r\n * Consumer: No\r\n * Planner: Do you support clip_lower and clip_upper?\r\n * Consumer: Yes\r\n * Planner produces plan with clip_lower and clip_upper.\r\n\r\nI'm happy for any compromise / alternatives for the short term.  There is also a related JIRA ( ARROW-15535 ) which covers automatic generation of YAML.\r\n\r\nThe way I think about it is that the \"standard Substrait namespace\" will require a high degree of manual mapping.  However, the \"Arrow namespace\" should be automatically generated.  Having the Arrow namespace will likely be good enough for initial development tasks and quickly expose the entirety of Arrow's compute functionality while we wait for the longer standards-approved methodologies to roll in.\r\n\r\nFor example, the automatic generation should be able to easily map {{min_element_wise}} and {{max_element_wise}} so that we can use those while testing other features and prototyping.  Then any prototypes can switch over to using \"clip\" as they need to start supporting multi-consumer support, etc.\r\n\r\nI think we could also have a short term solution for the standard Substrait namespace too if someone wants to put together a PR.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-05-02T21:15:28.201+0000",
                    "updated": "2022-05-02T21:15:28.201+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426719/comment/17578132",
                    "id": "17578132",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 13613\n[https://github.com/apache/arrow/pull/13613]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-08-10T19:27:09.229+0000",
                    "updated": "2022-08-10T19:27:09.229+0000"
                }
            ],
            "maxResults": 9,
            "total": 9,
            "startAt": 0
        },
        "customfield_12311820": "0|z0z9zk:",
        "customfield_12314139": null
    }
}