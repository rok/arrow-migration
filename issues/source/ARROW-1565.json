{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13103422",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422",
    "key": "ARROW-1565",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350323",
                "id": "12350323",
                "description": "",
                "name": "6.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-10-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "Analytics",
            "pull-request-available",
            "query-engine"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12622849",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12622849",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "outwardIssue": {
                    "id": "13400495",
                    "key": "ARROW-13974",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400495",
                    "fields": {
                        "summary": "[C++] Resolve follow-up reviews for TopK/BottomK",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
                            "name": "Minor",
                            "id": "4"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12620520",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12620520",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13376404",
                    "key": "ARROW-12633",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376404",
                    "fields": {
                        "summary": "[C++] Query engine umbrella issue",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12623934",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12623934",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13404295",
                    "key": "ARROW-14183",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404295",
                    "fields": {
                        "summary": "[C++] Improve select_k_unstable performance",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12621934",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12621934",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "inwardIssue": {
                    "id": "13397593",
                    "key": "ARROW-13766",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13397593",
                    "fields": {
                        "summary": "[R] Add Arrow methods slice_min(), slice_max()",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                            "id": "7",
                            "description": "The sub-task of the issue",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                            "name": "Sub-task",
                            "subtask": true,
                            "avatarId": 21146
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=aocsa",
            "name": "aocsa",
            "key": "aocsa",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=aocsa&avatarId=47387",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=aocsa&avatarId=47387",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=aocsa&avatarId=47387",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=aocsa&avatarId=47387"
            },
            "displayName": "Alexander Ocsa",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 54000,
            "total": 54000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 54000,
            "total": 54000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1565/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 90,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/642920",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa opened a new pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019\n\n\n   Heap-based topk can compute these indices in O(n log k) time\r\n   \r\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-27T17:04:43.540+0000",
                    "updated": "2021-08-27T17:04:43.540+0000",
                    "started": "2021-08-27T17:04:43.540+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "642920",
                    "issueId": "13103422"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/642921",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019#issuecomment-907345731\n\n\n   https://issues.apache.org/jira/browse/ARROW-1565\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-27T17:05:08.008+0000",
                    "updated": "2021-08-27T17:05:08.008+0000",
                    "started": "2021-08-27T17:05:08.007+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "642921",
                    "issueId": "13103422"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/645272",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019#discussion_r700206299\n\n\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.h\n##########\n@@ -120,6 +120,25 @@ class ARROW_EXPORT SortOptions : public FunctionOptions {\n   std::vector<SortKey> sort_keys;\n };\n \n+/// \\brief Partitioning options for NthToIndices\n+class ARROW_EXPORT SelectKOptions : public FunctionOptions {\n+ public:\n+  explicit SelectKOptions(int64_t pivot = 0, std::vector<std::string> keys = {},\n+                          std::string keep = \"first\",\n\nReview comment:\n       We should use an enum instead of a string for modes like this.\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.h\n##########\n@@ -120,6 +120,25 @@ class ARROW_EXPORT SortOptions : public FunctionOptions {\n   std::vector<SortKey> sort_keys;\n };\n \n+/// \\brief Partitioning options for NthToIndices\n+class ARROW_EXPORT SelectKOptions : public FunctionOptions {\n+ public:\n+  explicit SelectKOptions(int64_t pivot = 0, std::vector<std::string> keys = {},\n\nReview comment:\n       Here it's called pivot instead of k - is that intentional?\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.cc\n##########\n@@ -111,6 +111,10 @@ static auto kSortOptionsType =\n     GetFunctionOptionsType<SortOptions>(DataMember(\"sort_keys\", &SortOptions::sort_keys));\n static auto kPartitionNthOptionsType = GetFunctionOptionsType<PartitionNthOptions>(\n     DataMember(\"pivot\", &PartitionNthOptions::pivot));\n+static auto kSelectKOptionsType = GetFunctionOptionsType<SelectKOptions>(\n+    DataMember(\"k\", &SelectKOptions::k), DataMember(\"keys\", &SelectKOptions::keys),\n+    DataMember(\"order\", &SelectKOptions::order),\n+    DataMember(\"keep\", &SelectKOptions::keep));\n\nReview comment:\n       nit: it'd be good to add a couple instances of the options to the test in function_test.cc: https://github.com/apache/arrow/blob/3da09e51e3f94ca427915c98ac59d72701f728bc/cpp/src/arrow/compute/function_test.cc#L112\n\n##########\nFile path: cpp/src/arrow/util/heap.h\n##########\n@@ -0,0 +1,76 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+// A Heap class, is a simple wrapper to make heap operation simpler.\n+// This class is immutable by design\n\nReview comment:\n       The heap is immutable?\n\n##########\nFile path: cpp/src/arrow/util/heap.h\n##########\n@@ -0,0 +1,76 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+// A Heap class, is a simple wrapper to make heap operation simpler.\n+// This class is immutable by design\n+template <typename T, typename Compare = std::less<T>>\n+class ARROW_EXPORT Heap {\n+ public:\n+  explicit Heap() : values_(), comp_() {}\n\nReview comment:\n       note there are some lints for this file: https://github.com/apache/arrow/pull/11019/checks?check_run_id=3468575773\r\n   \r\n   ```\r\n    /arrow/cpp/src/arrow/util/heap.h:33:  Zero-parameter constructors should not be marked explicit.  [runtime/explicit] [5]\r\n   /arrow/cpp/src/arrow/util/heap.h:76:  Could not find a newline character at the end of the file.  [whitespace/ending_newline] [5]\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/select_k_test.cc\n##########\n@@ -0,0 +1,714 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <functional>\n+#include <iostream>\n+#include <limits>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/array_decimal.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/testing/util.h\"\n+#include \"arrow/type_traits.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// Convert arrow::Type to arrow::DataType. If arrow::Type isn't\n+// parameter free, this returns an arrow::DataType with the default\n+// parameter.\n+template <typename ArrowType>\n+enable_if_t<TypeTraits<ArrowType>::is_parameter_free, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return TypeTraits<ArrowType>::type_singleton();\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, TimestampType>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return timestamp(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time32Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time32(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time64Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time64(TimeUnit::NANO);\n+}\n+\n+// ----------------------------------------------------------------------\n+// Tests for SelectK\n+\n+template <typename ArrayType>\n+auto GetLogicalValue(const ArrayType& array, uint64_t index)\n+    -> decltype(array.GetView(index)) {\n+  return array.GetView(index);\n+}\n+\n+Decimal128 GetLogicalValue(const Decimal128Array& array, uint64_t index) {\n+  return Decimal128(array.Value(index));\n+}\n+\n+Decimal256 GetLogicalValue(const Decimal256Array& array, uint64_t index) {\n+  return Decimal256(array.Value(index));\n+}\n+\n+}  // namespace\n+\n+template <typename ArrayType, SortOrder order>\n+class SelectKComparator {\n+ public:\n+  template <typename Type>\n+  bool operator()(const Type& lval, const Type& rval) {\n+    if (is_floating_type<typename ArrayType::TypeClass>::value) {\n+      // NaNs ordered after non-NaNs\n+      if (rval != rval) return true;\n\nReview comment:\n       use std::isnan?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/select_k_test.cc\n##########\n@@ -0,0 +1,714 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <functional>\n+#include <iostream>\n+#include <limits>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/array_decimal.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/testing/util.h\"\n+#include \"arrow/type_traits.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// Convert arrow::Type to arrow::DataType. If arrow::Type isn't\n+// parameter free, this returns an arrow::DataType with the default\n+// parameter.\n+template <typename ArrowType>\n+enable_if_t<TypeTraits<ArrowType>::is_parameter_free, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return TypeTraits<ArrowType>::type_singleton();\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, TimestampType>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return timestamp(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time32Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time32(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time64Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time64(TimeUnit::NANO);\n+}\n+\n+// ----------------------------------------------------------------------\n+// Tests for SelectK\n+\n+template <typename ArrayType>\n+auto GetLogicalValue(const ArrayType& array, uint64_t index)\n+    -> decltype(array.GetView(index)) {\n+  return array.GetView(index);\n+}\n+\n+Decimal128 GetLogicalValue(const Decimal128Array& array, uint64_t index) {\n+  return Decimal128(array.Value(index));\n+}\n+\n+Decimal256 GetLogicalValue(const Decimal256Array& array, uint64_t index) {\n+  return Decimal256(array.Value(index));\n+}\n+\n+}  // namespace\n+\n+template <typename ArrayType, SortOrder order>\n+class SelectKComparator {\n+ public:\n+  template <typename Type>\n+  bool operator()(const Type& lval, const Type& rval) {\n+    if (is_floating_type<typename ArrayType::TypeClass>::value) {\n+      // NaNs ordered after non-NaNs\n+      if (rval != rval) return true;\n+      if (lval != lval) return false;\n+    }\n+    if (order == SortOrder::Ascending) {\n+      return lval <= rval;\n+    } else {\n+      return rval <= lval;\n+    }\n+  }\n+};\n+\n+template <SortOrder order>\n+Result<std::shared_ptr<Array>> SelectK(const ChunkedArray& values, int64_t k) {\n+  if (order == SortOrder::Descending) {\n+    return TopK(values, k);\n+  } else {\n+    return BottomK(values, k);\n+  }\n+}\n+\n+template <SortOrder order>\n+Result<std::shared_ptr<Array>> SelectK(const Array& values, int64_t k) {\n+  if (order == SortOrder::Descending) {\n+    return TopK(values, k);\n+  } else {\n+    return BottomK(values, k);\n+  }\n+}\n+template <typename ArrowType>\n+class TestSelectKBase : public TestBase {\n+  using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n+\n+ protected:\n+  void Validate(const ArrayType& array, int k, ArrayType& select_k, SortOrder order) {\n+    ASSERT_OK_AND_ASSIGN(auto sorted_indices, SortIndices(array, order));\n+    ASSERT_OK_AND_ASSIGN(Datum sorted_datum,\n+                         Take(array, sorted_indices, TakeOptions::NoBoundsCheck()));\n+    std::shared_ptr<Array> sorted_array_out = sorted_datum.make_array();\n+\n+    const ArrayType& sorted_array = *checked_pointer_cast<ArrayType>(sorted_array_out);\n+\n+    if (k < array.length()) {\n+      for (uint64_t i = 0; i < (uint64_t)select_k.length(); ++i) {\n+        const auto lval = GetLogicalValue(select_k, i);\n+        const auto rval = GetLogicalValue(sorted_array, i);\n+        ASSERT_TRUE(lval == rval);\n+      }\n+    }\n+  }\n+  template <SortOrder order>\n+  void AssertSelectKArray(const std::shared_ptr<Array> values, int n) {\n+    std::shared_ptr<Array> select_k;\n+    ASSERT_OK_AND_ASSIGN(select_k, SelectK<order>(*values, n));\n+    ASSERT_EQ(select_k->data()->null_count, 0);\n+    ValidateOutput(*select_k);\n+    Validate(*checked_pointer_cast<ArrayType>(values), n,\n+             *checked_pointer_cast<ArrayType>(select_k), order);\n+  }\n+\n+  void AssertTopKArray(const std::shared_ptr<Array> values, int n) {\n+    AssertSelectKArray<SortOrder::Descending>(values, n);\n+  }\n+  void AssertBottomKArray(const std::shared_ptr<Array> values, int n) {\n+    AssertSelectKArray<SortOrder::Descending>(values, n);\n+  }\n+\n+  void AssertSelectKJson(const std::string& values, int n) {\n+    AssertTopKArray(ArrayFromJSON(GetType(), values), n);\n+    AssertBottomKArray(ArrayFromJSON(GetType(), values), n);\n+  }\n+\n+  virtual std::shared_ptr<DataType> GetType() = 0;\n+};\n+\n+template <typename ArrowType>\n+class TestSelectK : public TestSelectKBase<ArrowType> {\n+ protected:\n+  std::shared_ptr<DataType> GetType() override { return TypeToDataType<ArrowType>(); }\n+};\n+\n+template <typename ArrowType>\n+class TestSelectKForReal : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForReal, RealArrowTypes);\n+\n+template <typename ArrowType>\n+class TestSelectKForIntegral : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForIntegral, IntegralArrowTypes);\n+\n+template <typename ArrowType>\n+class TestSelectKForBool : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForBool, ::testing::Types<BooleanType>);\n+\n+template <typename ArrowType>\n+class TestSelectKForTemporal : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForTemporal, TemporalArrowTypes);\n+\n+template <typename ArrowType>\n+class TestSelectKForDecimal : public TestSelectKBase<ArrowType> {\n+  std::shared_ptr<DataType> GetType() override {\n+    return std::make_shared<ArrowType>(5, 2);\n+  }\n+};\n+TYPED_TEST_SUITE(TestSelectKForDecimal, DecimalArrowTypes);\n+\n+template <typename ArrowType>\n+class TestSelectKForStrings : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForStrings, testing::Types<StringType>);\n+\n+TYPED_TEST(TestSelectKForReal, SelectKDoesNotProvideDefaultOptions) {\n+  auto input = ArrayFromJSON(this->GetType(), \"[null, 1, 3.3, null, 2, 5.3]\");\n+  ASSERT_RAISES(Invalid, CallFunction(\"top_k\", {input}));\n+}\n+\n+TYPED_TEST(TestSelectKForReal, Real) {\n+  this->AssertSelectKJson(\"[null, 1, 3.3, null, 2, 5.3]\", 0);\n+  this->AssertSelectKJson(\"[null, 1, 3.3, null, 2, 5.3]\", 2);\n+  this->AssertSelectKJson(\"[null, 1, 3.3, null, 2, 5.3]\", 5);\n+  this->AssertSelectKJson(\"[null, 1, 3.3, null, 2, 5.3]\", 6);\n+\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 0);\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 1);\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 2);\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 3);\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 4);\n+  this->AssertSelectKJson(\"[NaN, 2, null, 3, 1]\", 3);\n+  this->AssertSelectKJson(\"[NaN, 2, null, 3, 1]\", 4);\n+}\n+\n+TYPED_TEST(TestSelectKForIntegral, Integral) {\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 0);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 2);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 5);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 6);\n+\n+  this->AssertSelectKJson(\"[2, 4, 5, 7, 8, 0, 9, 1, 3]\", 5);\n+}\n+\n+TYPED_TEST(TestSelectKForBool, Bool) {\n+  this->AssertSelectKJson(\"[null, false, true, null, false, true]\", 0);\n+  this->AssertSelectKJson(\"[null, false, true, null, false, true]\", 2);\n+  this->AssertSelectKJson(\"[null, false, true, null, false, true]\", 5);\n+  this->AssertSelectKJson(\"[null, false, true, null, false, true]\", 6);\n+}\n+\n+TYPED_TEST(TestSelectKForTemporal, Temporal) {\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 0);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 2);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 5);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 6);\n+}\n+\n+TYPED_TEST(TestSelectKForDecimal, Decimal) {\n+  const std::string values = R\"([\"123.45\", null, \"-123.45\", \"456.78\", \"-456.78\"])\";\n+  this->AssertSelectKJson(values, 0);\n+  this->AssertSelectKJson(values, 2);\n+  this->AssertSelectKJson(values, 4);\n+  this->AssertSelectKJson(values, 5);\n+}\n+\n+TYPED_TEST(TestSelectKForStrings, Strings) {\n+  this->AssertSelectKJson(R\"([\"testing\", null, \"nth\", \"for\", null, \"strings\"])\", 0);\n+  this->AssertSelectKJson(R\"([\"testing\", null, \"nth\", \"for\", null, \"strings\"])\", 2);\n+  this->AssertSelectKJson(R\"([\"testing\", null, \"nth\", \"for\", null, \"strings\"])\", 5);\n+  this->AssertSelectKJson(R\"([\"testing\", null, \"nth\", \"for\", null, \"strings\"])\", 6);\n+}\n+\n+/*struct TestSelectKWithKeepParam : public ::testing::Test {\n+  void Check(const std::shared_ptr<DataType>& type, const std::string& values, int64_t k,\n+             const std::string& expected) {\n+    std::shared_ptr<Array> actual;\n+    ASSERT_OK(this->DoSelectK(type, values, k, &actual));\n+    ValidateOutput(actual);\n+\n+    ASSERT_ARRAYS_EQUAL(*ArrayFromJSON(type, expected), *actual);\n+  }\n+\n+  void Check(const std::shared_ptr<DataType>& type, const std::shared_ptr<Array>& values,\n+             int64_t k, const std::string& expected) {\n+    ASSERT_OK_AND_ASSIGN(auto actual, TopK(*values, k));\n+    ValidateOutput(actual);\n+    ASSERT_ARRAYS_EQUAL(*ArrayFromJSON(type, expected), *actual);\n+  }\n+\n+  Status DoSelectK(const std::shared_ptr<DataType>& type, const std::string& values,\n+                   int64_t k, std::shared_ptr<Array>* out) {\n+    ARROW_ASSIGN_OR_RAISE(*out, TopK(*ArrayFromJSON(type, values), k));\n+    PrettyPrint(**out, {}, &std::cerr);\n+    return Status::OK();\n+  }\n+};\n+\n+TEST_F(TestSelectKWithKeepParam, Integral) {\n+  this->Check(int32(), \"[null, 1, 3, null, 2, 5]\", 0, \"[]\");\n+  this->Check(int32(), \"[null, 1, 3, null, 2, 5]\", 2, \"[5, 3]\");\n+  this->Check(int32(), \"[null, 1, 3, null, 2, 5]\", 5, \"[5, 3, 2, 1]\");\n+  this->Check(int32(), \"[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\", 5, \"[4, 4, 4, 4, 3]\");\n+}*/\n+\n+template <typename ArrowType>\n+class TestSelectKRandom : public TestSelectKBase<ArrowType> {\n+ public:\n+  std::shared_ptr<DataType> GetType() override {\n+    EXPECT_TRUE(0) << \"shouldn't be used\";\n+    return nullptr;\n+  }\n+};\n+\n+using SelectKableTypes =\n+    ::testing::Types<UInt8Type, UInt16Type, UInt32Type, UInt64Type, Int8Type, Int16Type,\n+                     Int32Type, Int64Type, FloatType, DoubleType, Decimal128Type,\n+                     StringType>;\n+\n+class RandomImpl {\n+ protected:\n+  random::RandomArrayGenerator generator_;\n+  std::shared_ptr<DataType> type_;\n+\n+  explicit RandomImpl(random::SeedType seed, std::shared_ptr<DataType> type)\n+      : generator_(seed), type_(std::move(type)) {}\n+\n+ public:\n+  std::shared_ptr<Array> Generate(uint64_t count, double null_prob) {\n+    return generator_.ArrayOf(type_, count, null_prob);\n+  }\n+};\n+\n+template <typename ArrowType>\n+class Random : public RandomImpl {\n+ public:\n+  explicit Random(random::SeedType seed)\n+      : RandomImpl(seed, TypeTraits<ArrowType>::type_singleton()) {}\n+};\n+\n+template <>\n+class Random<FloatType> : public RandomImpl {\n+  using CType = float;\n+\n+ public:\n+  explicit Random(random::SeedType seed) : RandomImpl(seed, float32()) {}\n+\n+  std::shared_ptr<Array> Generate(uint64_t count, double null_prob, double nan_prob = 0) {\n+    return generator_.Float32(count, std::numeric_limits<CType>::min(),\n+                              std::numeric_limits<CType>::max(), null_prob, nan_prob);\n+  }\n+};\n+\n+template <>\n+class Random<DoubleType> : public RandomImpl {\n+  using CType = double;\n+\n+ public:\n+  explicit Random(random::SeedType seed) : RandomImpl(seed, float64()) {}\n+\n+  std::shared_ptr<Array> Generate(uint64_t count, double null_prob, double nan_prob = 0) {\n+    return generator_.Float64(count, std::numeric_limits<CType>::min(),\n+                              std::numeric_limits<CType>::max(), null_prob, nan_prob);\n+  }\n+};\n+\n+template <>\n+class Random<Decimal128Type> : public RandomImpl {\n+ public:\n+  explicit Random(random::SeedType seed,\n+                  std::shared_ptr<DataType> type = decimal128(18, 5))\n+      : RandomImpl(seed, std::move(type)) {}\n+};\n+\n+template <typename ArrowType>\n+class RandomRange : public RandomImpl {\n+  using CType = typename TypeTraits<ArrowType>::CType;\n+\n+ public:\n+  explicit RandomRange(random::SeedType seed)\n+      : RandomImpl(seed, TypeTraits<ArrowType>::type_singleton()) {}\n+\n+  std::shared_ptr<Array> Generate(uint64_t count, int range, double null_prob) {\n+    CType min = std::numeric_limits<CType>::min();\n+    CType max = min + range;\n+    if (sizeof(CType) < 4 && (range + min) > std::numeric_limits<CType>::max()) {\n+      max = std::numeric_limits<CType>::max();\n+    }\n+    return generator_.Numeric<ArrowType>(count, min, max, null_prob);\n+  }\n+};\n+\n+TYPED_TEST_SUITE(TestSelectKRandom, SelectKableTypes);\n+\n+TYPED_TEST(TestSelectKRandom, RandomValues) {\n+  Random<TypeParam> rand(0x61549225);\n+  int length = 100;\n+  for (auto null_probability : {0.0, 0.1, 0.5, 1.0}) {\n+    // Try n from 0 to out of bound\n+    for (int n = 0; n <= length; ++n) {\n+      auto array = rand.Generate(length, null_probability);\n+      this->AssertTopKArray(array, n);\n+      this->AssertBottomKArray(array, n);\n+    }\n+  }\n+}\n+\n+template <SortOrder order>\n+struct TestSelectKWithChunkedArray : public ::testing::Test {\n+  TestSelectKWithChunkedArray()\n+      : sizes_({0, 1, 2, 4, 16, 31, 1234}),\n+        null_probabilities_({0.0, 0.1, 0.5, 0.9, 1.0}) {}\n+\n+  void Check(const std::shared_ptr<DataType>& type,\n+             const std::vector<std::string>& values, int64_t k,\n+             const std::string& expected) {\n+    std::shared_ptr<Array> actual;\n+    ASSERT_OK(this->DoSelectK(type, values, k, &actual));\n+    ValidateOutput(actual);\n+\n+    ASSERT_ARRAYS_EQUAL(*ArrayFromJSON(type, expected), *actual);\n+  }\n+\n+  void Check(const std::shared_ptr<DataType>& type,\n+             const std::shared_ptr<ChunkedArray>& values, int64_t k,\n+             const std::string& expected) {\n+    ASSERT_OK_AND_ASSIGN(auto actual, SelectK<order>(*values, k));\n+    ValidateOutput(actual);\n+    ASSERT_ARRAYS_EQUAL(*ArrayFromJSON(type, expected), *actual);\n+  }\n+\n+  Status DoSelectK(const std::shared_ptr<DataType>& type,\n+                   const std::vector<std::string>& values, int64_t k,\n+                   std::shared_ptr<Array>* out) {\n+    ARROW_ASSIGN_OR_RAISE(*out, SelectK<order>(*(ChunkedArrayFromJSON(type, values)), k));\n+    PrettyPrint(**out, {}, &std::cerr);\n+    return Status::OK();\n+  }\n+  std::vector<int32_t> sizes_;\n+  std::vector<double> null_probabilities_;\n+};\n+\n+struct TestTopKWithChunkedArray\n\nReview comment:\n       Why not make these checks above in the typed tests?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/select_k_test.cc\n##########\n@@ -0,0 +1,714 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <functional>\n+#include <iostream>\n+#include <limits>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/array_decimal.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/testing/util.h\"\n+#include \"arrow/type_traits.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// Convert arrow::Type to arrow::DataType. If arrow::Type isn't\n+// parameter free, this returns an arrow::DataType with the default\n+// parameter.\n+template <typename ArrowType>\n+enable_if_t<TypeTraits<ArrowType>::is_parameter_free, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return TypeTraits<ArrowType>::type_singleton();\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, TimestampType>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return timestamp(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time32Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time32(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time64Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time64(TimeUnit::NANO);\n+}\n+\n+// ----------------------------------------------------------------------\n+// Tests for SelectK\n+\n+template <typename ArrayType>\n+auto GetLogicalValue(const ArrayType& array, uint64_t index)\n+    -> decltype(array.GetView(index)) {\n+  return array.GetView(index);\n+}\n+\n+Decimal128 GetLogicalValue(const Decimal128Array& array, uint64_t index) {\n+  return Decimal128(array.Value(index));\n+}\n+\n+Decimal256 GetLogicalValue(const Decimal256Array& array, uint64_t index) {\n+  return Decimal256(array.Value(index));\n+}\n+\n+}  // namespace\n+\n+template <typename ArrayType, SortOrder order>\n+class SelectKComparator {\n+ public:\n+  template <typename Type>\n+  bool operator()(const Type& lval, const Type& rval) {\n+    if (is_floating_type<typename ArrayType::TypeClass>::value) {\n+      // NaNs ordered after non-NaNs\n+      if (rval != rval) return true;\n+      if (lval != lval) return false;\n+    }\n+    if (order == SortOrder::Ascending) {\n+      return lval <= rval;\n+    } else {\n+      return rval <= lval;\n+    }\n+  }\n+};\n+\n+template <SortOrder order>\n+Result<std::shared_ptr<Array>> SelectK(const ChunkedArray& values, int64_t k) {\n+  if (order == SortOrder::Descending) {\n+    return TopK(values, k);\n+  } else {\n+    return BottomK(values, k);\n+  }\n+}\n+\n+template <SortOrder order>\n+Result<std::shared_ptr<Array>> SelectK(const Array& values, int64_t k) {\n+  if (order == SortOrder::Descending) {\n+    return TopK(values, k);\n+  } else {\n+    return BottomK(values, k);\n+  }\n+}\n+template <typename ArrowType>\n+class TestSelectKBase : public TestBase {\n+  using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n+\n+ protected:\n+  void Validate(const ArrayType& array, int k, ArrayType& select_k, SortOrder order) {\n+    ASSERT_OK_AND_ASSIGN(auto sorted_indices, SortIndices(array, order));\n+    ASSERT_OK_AND_ASSIGN(Datum sorted_datum,\n+                         Take(array, sorted_indices, TakeOptions::NoBoundsCheck()));\n+    std::shared_ptr<Array> sorted_array_out = sorted_datum.make_array();\n+\n+    const ArrayType& sorted_array = *checked_pointer_cast<ArrayType>(sorted_array_out);\n+\n+    if (k < array.length()) {\n+      for (uint64_t i = 0; i < (uint64_t)select_k.length(); ++i) {\n+        const auto lval = GetLogicalValue(select_k, i);\n+        const auto rval = GetLogicalValue(sorted_array, i);\n+        ASSERT_TRUE(lval == rval);\n+      }\n+    }\n+  }\n+  template <SortOrder order>\n+  void AssertSelectKArray(const std::shared_ptr<Array> values, int n) {\n+    std::shared_ptr<Array> select_k;\n+    ASSERT_OK_AND_ASSIGN(select_k, SelectK<order>(*values, n));\n+    ASSERT_EQ(select_k->data()->null_count, 0);\n+    ValidateOutput(*select_k);\n+    Validate(*checked_pointer_cast<ArrayType>(values), n,\n+             *checked_pointer_cast<ArrayType>(select_k), order);\n+  }\n+\n+  void AssertTopKArray(const std::shared_ptr<Array> values, int n) {\n+    AssertSelectKArray<SortOrder::Descending>(values, n);\n+  }\n+  void AssertBottomKArray(const std::shared_ptr<Array> values, int n) {\n+    AssertSelectKArray<SortOrder::Descending>(values, n);\n+  }\n+\n+  void AssertSelectKJson(const std::string& values, int n) {\n+    AssertTopKArray(ArrayFromJSON(GetType(), values), n);\n+    AssertBottomKArray(ArrayFromJSON(GetType(), values), n);\n+  }\n+\n+  virtual std::shared_ptr<DataType> GetType() = 0;\n+};\n+\n+template <typename ArrowType>\n+class TestSelectK : public TestSelectKBase<ArrowType> {\n+ protected:\n+  std::shared_ptr<DataType> GetType() override { return TypeToDataType<ArrowType>(); }\n+};\n+\n+template <typename ArrowType>\n+class TestSelectKForReal : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForReal, RealArrowTypes);\n+\n+template <typename ArrowType>\n+class TestSelectKForIntegral : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForIntegral, IntegralArrowTypes);\n+\n+template <typename ArrowType>\n+class TestSelectKForBool : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForBool, ::testing::Types<BooleanType>);\n+\n+template <typename ArrowType>\n+class TestSelectKForTemporal : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForTemporal, TemporalArrowTypes);\n+\n+template <typename ArrowType>\n+class TestSelectKForDecimal : public TestSelectKBase<ArrowType> {\n+  std::shared_ptr<DataType> GetType() override {\n+    return std::make_shared<ArrowType>(5, 2);\n+  }\n+};\n+TYPED_TEST_SUITE(TestSelectKForDecimal, DecimalArrowTypes);\n+\n+template <typename ArrowType>\n+class TestSelectKForStrings : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForStrings, testing::Types<StringType>);\n+\n+TYPED_TEST(TestSelectKForReal, SelectKDoesNotProvideDefaultOptions) {\n+  auto input = ArrayFromJSON(this->GetType(), \"[null, 1, 3.3, null, 2, 5.3]\");\n+  ASSERT_RAISES(Invalid, CallFunction(\"top_k\", {input}));\n+}\n+\n+TYPED_TEST(TestSelectKForReal, Real) {\n+  this->AssertSelectKJson(\"[null, 1, 3.3, null, 2, 5.3]\", 0);\n+  this->AssertSelectKJson(\"[null, 1, 3.3, null, 2, 5.3]\", 2);\n+  this->AssertSelectKJson(\"[null, 1, 3.3, null, 2, 5.3]\", 5);\n+  this->AssertSelectKJson(\"[null, 1, 3.3, null, 2, 5.3]\", 6);\n+\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 0);\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 1);\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 2);\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 3);\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 4);\n+  this->AssertSelectKJson(\"[NaN, 2, null, 3, 1]\", 3);\n+  this->AssertSelectKJson(\"[NaN, 2, null, 3, 1]\", 4);\n+}\n+\n+TYPED_TEST(TestSelectKForIntegral, Integral) {\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 0);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 2);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 5);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 6);\n+\n+  this->AssertSelectKJson(\"[2, 4, 5, 7, 8, 0, 9, 1, 3]\", 5);\n+}\n+\n+TYPED_TEST(TestSelectKForBool, Bool) {\n+  this->AssertSelectKJson(\"[null, false, true, null, false, true]\", 0);\n+  this->AssertSelectKJson(\"[null, false, true, null, false, true]\", 2);\n+  this->AssertSelectKJson(\"[null, false, true, null, false, true]\", 5);\n+  this->AssertSelectKJson(\"[null, false, true, null, false, true]\", 6);\n+}\n+\n+TYPED_TEST(TestSelectKForTemporal, Temporal) {\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 0);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 2);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 5);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 6);\n+}\n+\n+TYPED_TEST(TestSelectKForDecimal, Decimal) {\n+  const std::string values = R\"([\"123.45\", null, \"-123.45\", \"456.78\", \"-456.78\"])\";\n+  this->AssertSelectKJson(values, 0);\n+  this->AssertSelectKJson(values, 2);\n+  this->AssertSelectKJson(values, 4);\n+  this->AssertSelectKJson(values, 5);\n+}\n+\n+TYPED_TEST(TestSelectKForStrings, Strings) {\n+  this->AssertSelectKJson(R\"([\"testing\", null, \"nth\", \"for\", null, \"strings\"])\", 0);\n+  this->AssertSelectKJson(R\"([\"testing\", null, \"nth\", \"for\", null, \"strings\"])\", 2);\n+  this->AssertSelectKJson(R\"([\"testing\", null, \"nth\", \"for\", null, \"strings\"])\", 5);\n+  this->AssertSelectKJson(R\"([\"testing\", null, \"nth\", \"for\", null, \"strings\"])\", 6);\n+}\n+\n+/*struct TestSelectKWithKeepParam : public ::testing::Test {\n+  void Check(const std::shared_ptr<DataType>& type, const std::string& values, int64_t k,\n+             const std::string& expected) {\n+    std::shared_ptr<Array> actual;\n+    ASSERT_OK(this->DoSelectK(type, values, k, &actual));\n+    ValidateOutput(actual);\n+\n+    ASSERT_ARRAYS_EQUAL(*ArrayFromJSON(type, expected), *actual);\n+  }\n+\n+  void Check(const std::shared_ptr<DataType>& type, const std::shared_ptr<Array>& values,\n+             int64_t k, const std::string& expected) {\n+    ASSERT_OK_AND_ASSIGN(auto actual, TopK(*values, k));\n+    ValidateOutput(actual);\n+    ASSERT_ARRAYS_EQUAL(*ArrayFromJSON(type, expected), *actual);\n+  }\n+\n+  Status DoSelectK(const std::shared_ptr<DataType>& type, const std::string& values,\n+                   int64_t k, std::shared_ptr<Array>* out) {\n+    ARROW_ASSIGN_OR_RAISE(*out, TopK(*ArrayFromJSON(type, values), k));\n+    PrettyPrint(**out, {}, &std::cerr);\n+    return Status::OK();\n+  }\n+};\n+\n+TEST_F(TestSelectKWithKeepParam, Integral) {\n+  this->Check(int32(), \"[null, 1, 3, null, 2, 5]\", 0, \"[]\");\n+  this->Check(int32(), \"[null, 1, 3, null, 2, 5]\", 2, \"[5, 3]\");\n+  this->Check(int32(), \"[null, 1, 3, null, 2, 5]\", 5, \"[5, 3, 2, 1]\");\n+  this->Check(int32(), \"[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\", 5, \"[4, 4, 4, 4, 3]\");\n+}*/\n+\n+template <typename ArrowType>\n+class TestSelectKRandom : public TestSelectKBase<ArrowType> {\n+ public:\n+  std::shared_ptr<DataType> GetType() override {\n+    EXPECT_TRUE(0) << \"shouldn't be used\";\n+    return nullptr;\n+  }\n+};\n+\n+using SelectKableTypes =\n+    ::testing::Types<UInt8Type, UInt16Type, UInt32Type, UInt64Type, Int8Type, Int16Type,\n+                     Int32Type, Int64Type, FloatType, DoubleType, Decimal128Type,\n+                     StringType>;\n+\n+class RandomImpl {\n+ protected:\n+  random::RandomArrayGenerator generator_;\n+  std::shared_ptr<DataType> type_;\n+\n+  explicit RandomImpl(random::SeedType seed, std::shared_ptr<DataType> type)\n+      : generator_(seed), type_(std::move(type)) {}\n+\n+ public:\n+  std::shared_ptr<Array> Generate(uint64_t count, double null_prob) {\n+    return generator_.ArrayOf(type_, count, null_prob);\n+  }\n+};\n+\n+template <typename ArrowType>\n+class Random : public RandomImpl {\n+ public:\n+  explicit Random(random::SeedType seed)\n+      : RandomImpl(seed, TypeTraits<ArrowType>::type_singleton()) {}\n+};\n+\n+template <>\n+class Random<FloatType> : public RandomImpl {\n+  using CType = float;\n+\n+ public:\n+  explicit Random(random::SeedType seed) : RandomImpl(seed, float32()) {}\n+\n+  std::shared_ptr<Array> Generate(uint64_t count, double null_prob, double nan_prob = 0) {\n+    return generator_.Float32(count, std::numeric_limits<CType>::min(),\n+                              std::numeric_limits<CType>::max(), null_prob, nan_prob);\n+  }\n+};\n+\n+template <>\n+class Random<DoubleType> : public RandomImpl {\n+  using CType = double;\n+\n+ public:\n+  explicit Random(random::SeedType seed) : RandomImpl(seed, float64()) {}\n+\n+  std::shared_ptr<Array> Generate(uint64_t count, double null_prob, double nan_prob = 0) {\n+    return generator_.Float64(count, std::numeric_limits<CType>::min(),\n+                              std::numeric_limits<CType>::max(), null_prob, nan_prob);\n+  }\n+};\n+\n+template <>\n+class Random<Decimal128Type> : public RandomImpl {\n+ public:\n+  explicit Random(random::SeedType seed,\n+                  std::shared_ptr<DataType> type = decimal128(18, 5))\n+      : RandomImpl(seed, std::move(type)) {}\n+};\n+\n+template <typename ArrowType>\n+class RandomRange : public RandomImpl {\n+  using CType = typename TypeTraits<ArrowType>::CType;\n+\n+ public:\n+  explicit RandomRange(random::SeedType seed)\n+      : RandomImpl(seed, TypeTraits<ArrowType>::type_singleton()) {}\n+\n+  std::shared_ptr<Array> Generate(uint64_t count, int range, double null_prob) {\n+    CType min = std::numeric_limits<CType>::min();\n+    CType max = min + range;\n+    if (sizeof(CType) < 4 && (range + min) > std::numeric_limits<CType>::max()) {\n+      max = std::numeric_limits<CType>::max();\n+    }\n+    return generator_.Numeric<ArrowType>(count, min, max, null_prob);\n+  }\n+};\n+\n+TYPED_TEST_SUITE(TestSelectKRandom, SelectKableTypes);\n+\n+TYPED_TEST(TestSelectKRandom, RandomValues) {\n+  Random<TypeParam> rand(0x61549225);\n+  int length = 100;\n+  for (auto null_probability : {0.0, 0.1, 0.5, 1.0}) {\n+    // Try n from 0 to out of bound\n+    for (int n = 0; n <= length; ++n) {\n+      auto array = rand.Generate(length, null_probability);\n+      this->AssertTopKArray(array, n);\n+      this->AssertBottomKArray(array, n);\n+    }\n+  }\n+}\n+\n+template <SortOrder order>\n+struct TestSelectKWithChunkedArray : public ::testing::Test {\n+  TestSelectKWithChunkedArray()\n+      : sizes_({0, 1, 2, 4, 16, 31, 1234}),\n+        null_probabilities_({0.0, 0.1, 0.5, 0.9, 1.0}) {}\n+\n+  void Check(const std::shared_ptr<DataType>& type,\n+             const std::vector<std::string>& values, int64_t k,\n+             const std::string& expected) {\n+    std::shared_ptr<Array> actual;\n+    ASSERT_OK(this->DoSelectK(type, values, k, &actual));\n+    ValidateOutput(actual);\n+\n+    ASSERT_ARRAYS_EQUAL(*ArrayFromJSON(type, expected), *actual);\n+  }\n+\n+  void Check(const std::shared_ptr<DataType>& type,\n+             const std::shared_ptr<ChunkedArray>& values, int64_t k,\n+             const std::string& expected) {\n+    ASSERT_OK_AND_ASSIGN(auto actual, SelectK<order>(*values, k));\n+    ValidateOutput(actual);\n+    ASSERT_ARRAYS_EQUAL(*ArrayFromJSON(type, expected), *actual);\n+  }\n+\n+  Status DoSelectK(const std::shared_ptr<DataType>& type,\n+                   const std::vector<std::string>& values, int64_t k,\n+                   std::shared_ptr<Array>* out) {\n+    ARROW_ASSIGN_OR_RAISE(*out, SelectK<order>(*(ChunkedArrayFromJSON(type, values)), k));\n+    PrettyPrint(**out, {}, &std::cerr);\n+    return Status::OK();\n+  }\n+  std::vector<int32_t> sizes_;\n+  std::vector<double> null_probabilities_;\n+};\n+\n+struct TestTopKWithChunkedArray\n\nReview comment:\n       Also, you can probably make one typed test suite that covers all the numeric and most of the temporal types in one go, since the temporal types generally are numeric underneath.\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.h\n##########\n@@ -252,6 +271,40 @@ ARROW_EXPORT\n Result<std::shared_ptr<Array>> NthToIndices(const Array& values, int64_t n,\n                                             ExecContext* ctx = NULLPTR);\n \n+/// @TODO\n+ARROW_EXPORT\n+Result<std::shared_ptr<Array>> TopK(const Array& values, int64_t k,\n+                                    const std::string& keep = \"first\",\n+                                    ExecContext* ctx = NULLPTR);\n+\n+/// @TODO\n+ARROW_EXPORT\n+Result<std::shared_ptr<Array>> TopK(const ChunkedArray& values, int64_t k,\n+                                    const std::string& keep = \"first\",\n+                                    ExecContext* ctx = NULLPTR);\n+\n+/// @TODO\n+ARROW_EXPORT\n+Result<Datum> TopK(const Datum& datum, int64_t k, SelectKOptions options,\n+                   ExecContext* ctx = NULLPTR);\n+\n+/// @TODO\n+ARROW_EXPORT\n+Result<std::shared_ptr<Array>> BottomK(const Array& values, int64_t k,\n+                                       const std::string& keep = \"first\",\n+                                       ExecContext* ctx = NULLPTR);\n+\n+/// @TODO\n+ARROW_EXPORT\n+Result<std::shared_ptr<Array>> BottomK(const ChunkedArray& values, int64_t k,\n+                                       const std::string& keep = \"first\",\n+                                       ExecContext* ctx = NULLPTR);\n+\n+/// @TODO\n+ARROW_EXPORT\n+Result<Datum> BottomK(const Datum& datum, int64_t k, SelectKOptions options,\n\nReview comment:\n       I'm not sure we need all these overloads in C++. They may instead be better suited as static factory methods on the options (SelectKOptions::BottomK and such).\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.h\n##########\n@@ -120,6 +120,25 @@ class ARROW_EXPORT SortOptions : public FunctionOptions {\n   std::vector<SortKey> sort_keys;\n };\n \n+/// \\brief Partitioning options for NthToIndices\n+class ARROW_EXPORT SelectKOptions : public FunctionOptions {\n+ public:\n+  explicit SelectKOptions(int64_t pivot = 0, std::vector<std::string> keys = {},\n+                          std::string keep = \"first\",\n+                          SortOrder order = SortOrder::Ascending);\n+  constexpr static char const kTypeName[] = \"SelectKOptions\";\n+  static SelectKOptions TopKDefault() {\n+    return SelectKOptions{0, {}, \"first\", SortOrder::Descending};\n+  }\n+  static SelectKOptions BottomKDefault() {\n+    return SelectKOptions{0, {}, \"first\", SortOrder::Ascending};\n+  }\n+  int64_t k;\n+  std::vector<std::string> keys;\n+  std::string keep;\n+  SortOrder order;\n\nReview comment:\n       nit: we should have docstrings for these fields.\n\n##########\nFile path: cpp/src/arrow/testing/gtest_util.h\n##########\n@@ -157,8 +157,7 @@ using NumericArrowTypes =\n \n using RealArrowTypes = ::testing::Types<FloatType, DoubleType>;\n \n-using IntegralArrowTypes = ::testing::Types<UInt8Type, UInt16Type, UInt32Type, UInt64Type,\n-                                            Int8Type, Int16Type, Int32Type, Int64Type>;\n\nReview comment:\n       It seems this is WIP but please don't forget to revert this.\n\n##########\nFile path: cpp/src/arrow/util/heap.h\n##########\n@@ -0,0 +1,76 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n\nReview comment:\n       Can we make this heap_internal.h to make it clear it's not part of our public API?\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.h\n##########\n@@ -120,6 +120,25 @@ class ARROW_EXPORT SortOptions : public FunctionOptions {\n   std::vector<SortKey> sort_keys;\n };\n \n+/// \\brief Partitioning options for NthToIndices\n\nReview comment:\n       nit: this comment should be updated.\n\n##########\nFile path: cpp/src/arrow/util/heap.h\n##########\n@@ -0,0 +1,76 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+// A Heap class, is a simple wrapper to make heap operation simpler.\n+// This class is immutable by design\n+template <typename T, typename Compare = std::less<T>>\n+class ARROW_EXPORT Heap {\n\nReview comment:\n       We should have direct tests of the heap itself.\n\n##########\nFile path: cpp/src/arrow/util/heap.h\n##########\n@@ -0,0 +1,76 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+// A Heap class, is a simple wrapper to make heap operation simpler.\n+// This class is immutable by design\n+template <typename T, typename Compare = std::less<T>>\n+class ARROW_EXPORT Heap {\n+ public:\n+  explicit Heap() : values_(), comp_() {}\n+  explicit Heap(const Compare& compare) : values_(), comp_(compare) {}\n+\n+  Heap(Heap&&) = default;\n+  Heap& operator=(Heap&&) = default;\n+\n+  T* Data() { return values_.data(); }\n+\n+  // const T& Top() const { return values_.front(); }\n+\n+  T Top() const { return values_.front(); }\n+\n+  bool Empty() const { return values_.empty(); }\n+\n+  size_t Size() const { return values_.size(); }\n+\n+  void Push(const T& value) {\n+    values_.push_back(value);\n+    std::push_heap(values_.begin(), values_.end(), comp_);\n+  }\n+\n+  void Pop() {\n+    std::pop_heap(values_.begin(), values_.end(), comp_);\n+    values_.pop_back();\n+  }\n+\n+  void ReplaceTop(const T& value) {\n+    std::pop_heap(values_.begin(), values_.end(), comp_);\n+    values_.back() = value;\n+    std::push_heap(values_.begin(), values_.end(), comp_);\n+  }\n+\n+  void SetComparator(const Compare& comp) { comp_ = comp; }\n\nReview comment:\n       Is this used?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/select_k_test.cc\n##########\n@@ -0,0 +1,714 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <functional>\n+#include <iostream>\n+#include <limits>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/array_decimal.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/testing/util.h\"\n+#include \"arrow/type_traits.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// Convert arrow::Type to arrow::DataType. If arrow::Type isn't\n+// parameter free, this returns an arrow::DataType with the default\n+// parameter.\n+template <typename ArrowType>\n+enable_if_t<TypeTraits<ArrowType>::is_parameter_free, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return TypeTraits<ArrowType>::type_singleton();\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, TimestampType>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return timestamp(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time32Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time32(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time64Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time64(TimeUnit::NANO);\n+}\n+\n+// ----------------------------------------------------------------------\n+// Tests for SelectK\n+\n+template <typename ArrayType>\n+auto GetLogicalValue(const ArrayType& array, uint64_t index)\n+    -> decltype(array.GetView(index)) {\n+  return array.GetView(index);\n+}\n+\n+Decimal128 GetLogicalValue(const Decimal128Array& array, uint64_t index) {\n+  return Decimal128(array.Value(index));\n+}\n+\n+Decimal256 GetLogicalValue(const Decimal256Array& array, uint64_t index) {\n+  return Decimal256(array.Value(index));\n+}\n+\n+}  // namespace\n+\n+template <typename ArrayType, SortOrder order>\n+class SelectKComparator {\n+ public:\n+  template <typename Type>\n+  bool operator()(const Type& lval, const Type& rval) {\n+    if (is_floating_type<typename ArrayType::TypeClass>::value) {\n+      // NaNs ordered after non-NaNs\n+      if (rval != rval) return true;\n+      if (lval != lval) return false;\n+    }\n+    if (order == SortOrder::Ascending) {\n+      return lval <= rval;\n+    } else {\n+      return rval <= lval;\n+    }\n+  }\n+};\n+\n+template <SortOrder order>\n+Result<std::shared_ptr<Array>> SelectK(const ChunkedArray& values, int64_t k) {\n+  if (order == SortOrder::Descending) {\n+    return TopK(values, k);\n+  } else {\n+    return BottomK(values, k);\n+  }\n+}\n+\n+template <SortOrder order>\n+Result<std::shared_ptr<Array>> SelectK(const Array& values, int64_t k) {\n+  if (order == SortOrder::Descending) {\n+    return TopK(values, k);\n+  } else {\n+    return BottomK(values, k);\n+  }\n+}\n+template <typename ArrowType>\n+class TestSelectKBase : public TestBase {\n+  using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n+\n+ protected:\n+  void Validate(const ArrayType& array, int k, ArrayType& select_k, SortOrder order) {\n+    ASSERT_OK_AND_ASSIGN(auto sorted_indices, SortIndices(array, order));\n+    ASSERT_OK_AND_ASSIGN(Datum sorted_datum,\n+                         Take(array, sorted_indices, TakeOptions::NoBoundsCheck()));\n+    std::shared_ptr<Array> sorted_array_out = sorted_datum.make_array();\n+\n+    const ArrayType& sorted_array = *checked_pointer_cast<ArrayType>(sorted_array_out);\n+\n+    if (k < array.length()) {\n+      for (uint64_t i = 0; i < (uint64_t)select_k.length(); ++i) {\n+        const auto lval = GetLogicalValue(select_k, i);\n+        const auto rval = GetLogicalValue(sorted_array, i);\n\nReview comment:\n       Instead of GetLogicalValue and such, you could slice the arrays and use AssertArraysEqual/AssertArraysApproxEqual. With the `verbose == true` parameter this will also print out the mismatched values on failure.\n\n##########\nFile path: cpp/src/arrow/util/heap.h\n##########\n@@ -0,0 +1,76 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+// A Heap class, is a simple wrapper to make heap operation simpler.\n+// This class is immutable by design\n+template <typename T, typename Compare = std::less<T>>\n+class ARROW_EXPORT Heap {\n+ public:\n+  explicit Heap() : values_(), comp_() {}\n+  explicit Heap(const Compare& compare) : values_(), comp_(compare) {}\n+\n+  Heap(Heap&&) = default;\n+  Heap& operator=(Heap&&) = default;\n\nReview comment:\n       You might enjoy ARROW_DEFAULT_MOVE_AND_ASSIGN. https://github.com/apache/arrow/blob/3da09e51e3f94ca427915c98ac59d72701f728bc/cpp/src/arrow/util/macros.h#L34-L36\n\n##########\nFile path: cpp/src/arrow/util/heap.h\n##########\n@@ -0,0 +1,76 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+// A Heap class, is a simple wrapper to make heap operation simpler.\n+// This class is immutable by design\n+template <typename T, typename Compare = std::less<T>>\n+class ARROW_EXPORT Heap {\n+ public:\n+  explicit Heap() : values_(), comp_() {}\n+  explicit Heap(const Compare& compare) : values_(), comp_(compare) {}\n+\n+  Heap(Heap&&) = default;\n+  Heap& operator=(Heap&&) = default;\n+\n+  T* Data() { return values_.data(); }\n+\n+  // const T& Top() const { return values_.front(); }\n+\n+  T Top() const { return values_.front(); }\n+\n+  bool Empty() const { return values_.empty(); }\n+\n+  size_t Size() const { return values_.size(); }\n\nReview comment:\n       nit: for const getter methods like this, they can be named lowercase still. size() is often left as size() and not Size() in our codebase, and top()/empty()/data() could also follow that.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/select_k_test.cc\n##########\n@@ -0,0 +1,714 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <functional>\n+#include <iostream>\n+#include <limits>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/array_decimal.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/testing/util.h\"\n+#include \"arrow/type_traits.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// Convert arrow::Type to arrow::DataType. If arrow::Type isn't\n+// parameter free, this returns an arrow::DataType with the default\n+// parameter.\n+template <typename ArrowType>\n+enable_if_t<TypeTraits<ArrowType>::is_parameter_free, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return TypeTraits<ArrowType>::type_singleton();\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, TimestampType>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return timestamp(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time32Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time32(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time64Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time64(TimeUnit::NANO);\n+}\n\nReview comment:\n       You might want to use default_type_instance: https://github.com/apache/arrow/blob/3da09e51e3f94ca427915c98ac59d72701f728bc/cpp/src/arrow/compute/kernels/test_util.h#L123-L144\n\n##########\nFile path: cpp/src/arrow/compute/kernels/select_k_test.cc\n##########\n@@ -0,0 +1,714 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <functional>\n+#include <iostream>\n+#include <limits>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/array_decimal.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/testing/util.h\"\n+#include \"arrow/type_traits.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// Convert arrow::Type to arrow::DataType. If arrow::Type isn't\n+// parameter free, this returns an arrow::DataType with the default\n+// parameter.\n+template <typename ArrowType>\n+enable_if_t<TypeTraits<ArrowType>::is_parameter_free, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return TypeTraits<ArrowType>::type_singleton();\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, TimestampType>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return timestamp(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time32Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time32(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time64Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time64(TimeUnit::NANO);\n+}\n+\n+// ----------------------------------------------------------------------\n+// Tests for SelectK\n+\n+template <typename ArrayType>\n+auto GetLogicalValue(const ArrayType& array, uint64_t index)\n+    -> decltype(array.GetView(index)) {\n+  return array.GetView(index);\n+}\n+\n+Decimal128 GetLogicalValue(const Decimal128Array& array, uint64_t index) {\n+  return Decimal128(array.Value(index));\n+}\n+\n+Decimal256 GetLogicalValue(const Decimal256Array& array, uint64_t index) {\n+  return Decimal256(array.Value(index));\n+}\n+\n+}  // namespace\n+\n+template <typename ArrayType, SortOrder order>\n+class SelectKComparator {\n+ public:\n+  template <typename Type>\n+  bool operator()(const Type& lval, const Type& rval) {\n+    if (is_floating_type<typename ArrayType::TypeClass>::value) {\n+      // NaNs ordered after non-NaNs\n+      if (rval != rval) return true;\n+      if (lval != lval) return false;\n+    }\n+    if (order == SortOrder::Ascending) {\n+      return lval <= rval;\n+    } else {\n+      return rval <= lval;\n+    }\n+  }\n+};\n+\n+template <SortOrder order>\n+Result<std::shared_ptr<Array>> SelectK(const ChunkedArray& values, int64_t k) {\n+  if (order == SortOrder::Descending) {\n+    return TopK(values, k);\n+  } else {\n+    return BottomK(values, k);\n+  }\n+}\n+\n+template <SortOrder order>\n+Result<std::shared_ptr<Array>> SelectK(const Array& values, int64_t k) {\n+  if (order == SortOrder::Descending) {\n+    return TopK(values, k);\n+  } else {\n+    return BottomK(values, k);\n+  }\n+}\n+template <typename ArrowType>\n+class TestSelectKBase : public TestBase {\n+  using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n+\n+ protected:\n+  void Validate(const ArrayType& array, int k, ArrayType& select_k, SortOrder order) {\n+    ASSERT_OK_AND_ASSIGN(auto sorted_indices, SortIndices(array, order));\n+    ASSERT_OK_AND_ASSIGN(Datum sorted_datum,\n+                         Take(array, sorted_indices, TakeOptions::NoBoundsCheck()));\n+    std::shared_ptr<Array> sorted_array_out = sorted_datum.make_array();\n+\n+    const ArrayType& sorted_array = *checked_pointer_cast<ArrayType>(sorted_array_out);\n+\n+    if (k < array.length()) {\n+      for (uint64_t i = 0; i < (uint64_t)select_k.length(); ++i) {\n+        const auto lval = GetLogicalValue(select_k, i);\n+        const auto rval = GetLogicalValue(sorted_array, i);\n+        ASSERT_TRUE(lval == rval);\n+      }\n+    }\n+  }\n+  template <SortOrder order>\n+  void AssertSelectKArray(const std::shared_ptr<Array> values, int n) {\n+    std::shared_ptr<Array> select_k;\n+    ASSERT_OK_AND_ASSIGN(select_k, SelectK<order>(*values, n));\n+    ASSERT_EQ(select_k->data()->null_count, 0);\n+    ValidateOutput(*select_k);\n+    Validate(*checked_pointer_cast<ArrayType>(values), n,\n+             *checked_pointer_cast<ArrayType>(select_k), order);\n+  }\n+\n+  void AssertTopKArray(const std::shared_ptr<Array> values, int n) {\n+    AssertSelectKArray<SortOrder::Descending>(values, n);\n+  }\n+  void AssertBottomKArray(const std::shared_ptr<Array> values, int n) {\n+    AssertSelectKArray<SortOrder::Descending>(values, n);\n+  }\n+\n+  void AssertSelectKJson(const std::string& values, int n) {\n+    AssertTopKArray(ArrayFromJSON(GetType(), values), n);\n+    AssertBottomKArray(ArrayFromJSON(GetType(), values), n);\n+  }\n+\n+  virtual std::shared_ptr<DataType> GetType() = 0;\n\nReview comment:\n       nit: most other such tests in our codebase call this type_singleton\n\n##########\nFile path: cpp/src/arrow/compute/kernels/select_k_test.cc\n##########\n@@ -0,0 +1,714 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <functional>\n+#include <iostream>\n+#include <limits>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/array_decimal.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/testing/util.h\"\n+#include \"arrow/type_traits.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// Convert arrow::Type to arrow::DataType. If arrow::Type isn't\n+// parameter free, this returns an arrow::DataType with the default\n+// parameter.\n+template <typename ArrowType>\n+enable_if_t<TypeTraits<ArrowType>::is_parameter_free, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return TypeTraits<ArrowType>::type_singleton();\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, TimestampType>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return timestamp(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time32Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time32(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time64Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time64(TimeUnit::NANO);\n+}\n+\n+// ----------------------------------------------------------------------\n+// Tests for SelectK\n+\n+template <typename ArrayType>\n+auto GetLogicalValue(const ArrayType& array, uint64_t index)\n+    -> decltype(array.GetView(index)) {\n+  return array.GetView(index);\n+}\n+\n+Decimal128 GetLogicalValue(const Decimal128Array& array, uint64_t index) {\n+  return Decimal128(array.Value(index));\n+}\n+\n+Decimal256 GetLogicalValue(const Decimal256Array& array, uint64_t index) {\n+  return Decimal256(array.Value(index));\n+}\n+\n+}  // namespace\n+\n+template <typename ArrayType, SortOrder order>\n+class SelectKComparator {\n+ public:\n+  template <typename Type>\n+  bool operator()(const Type& lval, const Type& rval) {\n+    if (is_floating_type<typename ArrayType::TypeClass>::value) {\n+      // NaNs ordered after non-NaNs\n+      if (rval != rval) return true;\n+      if (lval != lval) return false;\n+    }\n+    if (order == SortOrder::Ascending) {\n+      return lval <= rval;\n+    } else {\n+      return rval <= lval;\n+    }\n+  }\n+};\n+\n+template <SortOrder order>\n+Result<std::shared_ptr<Array>> SelectK(const ChunkedArray& values, int64_t k) {\n+  if (order == SortOrder::Descending) {\n+    return TopK(values, k);\n+  } else {\n+    return BottomK(values, k);\n+  }\n+}\n+\n+template <SortOrder order>\n+Result<std::shared_ptr<Array>> SelectK(const Array& values, int64_t k) {\n+  if (order == SortOrder::Descending) {\n+    return TopK(values, k);\n+  } else {\n+    return BottomK(values, k);\n+  }\n+}\n+template <typename ArrowType>\n+class TestSelectKBase : public TestBase {\n+  using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n+\n+ protected:\n+  void Validate(const ArrayType& array, int k, ArrayType& select_k, SortOrder order) {\n+    ASSERT_OK_AND_ASSIGN(auto sorted_indices, SortIndices(array, order));\n+    ASSERT_OK_AND_ASSIGN(Datum sorted_datum,\n+                         Take(array, sorted_indices, TakeOptions::NoBoundsCheck()));\n+    std::shared_ptr<Array> sorted_array_out = sorted_datum.make_array();\n+\n+    const ArrayType& sorted_array = *checked_pointer_cast<ArrayType>(sorted_array_out);\n+\n+    if (k < array.length()) {\n+      for (uint64_t i = 0; i < (uint64_t)select_k.length(); ++i) {\n+        const auto lval = GetLogicalValue(select_k, i);\n+        const auto rval = GetLogicalValue(sorted_array, i);\n+        ASSERT_TRUE(lval == rval);\n+      }\n+    }\n+  }\n+  template <SortOrder order>\n+  void AssertSelectKArray(const std::shared_ptr<Array> values, int n) {\n+    std::shared_ptr<Array> select_k;\n+    ASSERT_OK_AND_ASSIGN(select_k, SelectK<order>(*values, n));\n\nReview comment:\n       Why is everything templated instead of passing it as a parameter?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/select_k_test.cc\n##########\n@@ -0,0 +1,714 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <functional>\n+#include <iostream>\n+#include <limits>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/array_decimal.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/testing/util.h\"\n+#include \"arrow/type_traits.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// Convert arrow::Type to arrow::DataType. If arrow::Type isn't\n+// parameter free, this returns an arrow::DataType with the default\n+// parameter.\n+template <typename ArrowType>\n+enable_if_t<TypeTraits<ArrowType>::is_parameter_free, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return TypeTraits<ArrowType>::type_singleton();\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, TimestampType>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return timestamp(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time32Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time32(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time64Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time64(TimeUnit::NANO);\n+}\n+\n+// ----------------------------------------------------------------------\n+// Tests for SelectK\n+\n+template <typename ArrayType>\n+auto GetLogicalValue(const ArrayType& array, uint64_t index)\n+    -> decltype(array.GetView(index)) {\n+  return array.GetView(index);\n+}\n+\n+Decimal128 GetLogicalValue(const Decimal128Array& array, uint64_t index) {\n+  return Decimal128(array.Value(index));\n+}\n+\n+Decimal256 GetLogicalValue(const Decimal256Array& array, uint64_t index) {\n+  return Decimal256(array.Value(index));\n+}\n+\n+}  // namespace\n+\n+template <typename ArrayType, SortOrder order>\n+class SelectKComparator {\n+ public:\n+  template <typename Type>\n+  bool operator()(const Type& lval, const Type& rval) {\n+    if (is_floating_type<typename ArrayType::TypeClass>::value) {\n+      // NaNs ordered after non-NaNs\n+      if (rval != rval) return true;\n+      if (lval != lval) return false;\n+    }\n+    if (order == SortOrder::Ascending) {\n+      return lval <= rval;\n+    } else {\n+      return rval <= lval;\n+    }\n+  }\n+};\n+\n+template <SortOrder order>\n+Result<std::shared_ptr<Array>> SelectK(const ChunkedArray& values, int64_t k) {\n+  if (order == SortOrder::Descending) {\n+    return TopK(values, k);\n+  } else {\n+    return BottomK(values, k);\n+  }\n+}\n+\n+template <SortOrder order>\n+Result<std::shared_ptr<Array>> SelectK(const Array& values, int64_t k) {\n+  if (order == SortOrder::Descending) {\n+    return TopK(values, k);\n+  } else {\n+    return BottomK(values, k);\n+  }\n+}\n+template <typename ArrowType>\n+class TestSelectKBase : public TestBase {\n+  using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n+\n+ protected:\n+  void Validate(const ArrayType& array, int k, ArrayType& select_k, SortOrder order) {\n+    ASSERT_OK_AND_ASSIGN(auto sorted_indices, SortIndices(array, order));\n+    ASSERT_OK_AND_ASSIGN(Datum sorted_datum,\n+                         Take(array, sorted_indices, TakeOptions::NoBoundsCheck()));\n+    std::shared_ptr<Array> sorted_array_out = sorted_datum.make_array();\n+\n+    const ArrayType& sorted_array = *checked_pointer_cast<ArrayType>(sorted_array_out);\n+\n+    if (k < array.length()) {\n+      for (uint64_t i = 0; i < (uint64_t)select_k.length(); ++i) {\n+        const auto lval = GetLogicalValue(select_k, i);\n+        const auto rval = GetLogicalValue(sorted_array, i);\n\nReview comment:\n       That would also let you get rid of various casts and such.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -156,7 +161,7 @@ struct ChunkedArrayResolver {\n   }\n \n   int64_t num_chunks_;\n-  const Array* const* chunks_;\n+  const std::vector<const Array*> chunks_;\n\nReview comment:\n       Was there an issue with the original (chunks_ getting invalidated, presumably?)?\n\n##########\nFile path: cpp/src/arrow/util/heap.h\n##########\n@@ -0,0 +1,76 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n\nReview comment:\n       That way it won't get installed with the rest of the headers, so it'll be usable only within Arrow itself.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -1778,6 +1784,711 @@ class SortIndicesMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// TopK/BottomK implementations\n+\n+using SelectKOptionsState = internal::OptionsWrapper<SelectKOptions>;\n+const auto kDefaultTopKOptions = SelectKOptions::TopKDefault();\n+const auto kDefaultBottomKOptions = SelectKOptions::BottomKDefault();\n+\n+const FunctionDoc top_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n\nReview comment:\n       I realize these are TODOs but don't forget to update these :)\n\n##########\nFile path: cpp/src/arrow/util/heap.h\n##########\n@@ -0,0 +1,76 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+// A Heap class, is a simple wrapper to make heap operation simpler.\n+// This class is immutable by design\n+template <typename T, typename Compare = std::less<T>>\n+class ARROW_EXPORT Heap {\n+ public:\n+  explicit Heap() : values_(), comp_() {}\n\nReview comment:\n       You can use docker to run linting locally: https://arrow.apache.org/docs/developers/cpp/development.html#code-style-linting-and-ci\n\n##########\nFile path: cpp/src/arrow/compute/kernels/select_k_test.cc\n##########\n@@ -0,0 +1,714 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <functional>\n+#include <iostream>\n+#include <limits>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/array_decimal.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/testing/util.h\"\n+#include \"arrow/type_traits.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// Convert arrow::Type to arrow::DataType. If arrow::Type isn't\n+// parameter free, this returns an arrow::DataType with the default\n+// parameter.\n+template <typename ArrowType>\n+enable_if_t<TypeTraits<ArrowType>::is_parameter_free, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return TypeTraits<ArrowType>::type_singleton();\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, TimestampType>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return timestamp(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time32Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time32(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time64Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time64(TimeUnit::NANO);\n+}\n+\n+// ----------------------------------------------------------------------\n+// Tests for SelectK\n+\n+template <typename ArrayType>\n+auto GetLogicalValue(const ArrayType& array, uint64_t index)\n+    -> decltype(array.GetView(index)) {\n+  return array.GetView(index);\n+}\n+\n+Decimal128 GetLogicalValue(const Decimal128Array& array, uint64_t index) {\n+  return Decimal128(array.Value(index));\n+}\n+\n+Decimal256 GetLogicalValue(const Decimal256Array& array, uint64_t index) {\n+  return Decimal256(array.Value(index));\n+}\n+\n+}  // namespace\n+\n+template <typename ArrayType, SortOrder order>\n+class SelectKComparator {\n+ public:\n+  template <typename Type>\n+  bool operator()(const Type& lval, const Type& rval) {\n+    if (is_floating_type<typename ArrayType::TypeClass>::value) {\n+      // NaNs ordered after non-NaNs\n+      if (rval != rval) return true;\n+      if (lval != lval) return false;\n+    }\n+    if (order == SortOrder::Ascending) {\n+      return lval <= rval;\n+    } else {\n+      return rval <= lval;\n+    }\n+  }\n+};\n+\n+template <SortOrder order>\n+Result<std::shared_ptr<Array>> SelectK(const ChunkedArray& values, int64_t k) {\n+  if (order == SortOrder::Descending) {\n+    return TopK(values, k);\n+  } else {\n+    return BottomK(values, k);\n+  }\n+}\n+\n+template <SortOrder order>\n+Result<std::shared_ptr<Array>> SelectK(const Array& values, int64_t k) {\n+  if (order == SortOrder::Descending) {\n+    return TopK(values, k);\n+  } else {\n+    return BottomK(values, k);\n+  }\n+}\n+template <typename ArrowType>\n+class TestSelectKBase : public TestBase {\n+  using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n+\n+ protected:\n+  void Validate(const ArrayType& array, int k, ArrayType& select_k, SortOrder order) {\n+    ASSERT_OK_AND_ASSIGN(auto sorted_indices, SortIndices(array, order));\n+    ASSERT_OK_AND_ASSIGN(Datum sorted_datum,\n+                         Take(array, sorted_indices, TakeOptions::NoBoundsCheck()));\n+    std::shared_ptr<Array> sorted_array_out = sorted_datum.make_array();\n+\n+    const ArrayType& sorted_array = *checked_pointer_cast<ArrayType>(sorted_array_out);\n+\n+    if (k < array.length()) {\n+      for (uint64_t i = 0; i < (uint64_t)select_k.length(); ++i) {\n+        const auto lval = GetLogicalValue(select_k, i);\n+        const auto rval = GetLogicalValue(sorted_array, i);\n+        ASSERT_TRUE(lval == rval);\n+      }\n+    }\n+  }\n+  template <SortOrder order>\n+  void AssertSelectKArray(const std::shared_ptr<Array> values, int n) {\n+    std::shared_ptr<Array> select_k;\n+    ASSERT_OK_AND_ASSIGN(select_k, SelectK<order>(*values, n));\n+    ASSERT_EQ(select_k->data()->null_count, 0);\n+    ValidateOutput(*select_k);\n+    Validate(*checked_pointer_cast<ArrayType>(values), n,\n+             *checked_pointer_cast<ArrayType>(select_k), order);\n+  }\n+\n+  void AssertTopKArray(const std::shared_ptr<Array> values, int n) {\n+    AssertSelectKArray<SortOrder::Descending>(values, n);\n+  }\n+  void AssertBottomKArray(const std::shared_ptr<Array> values, int n) {\n+    AssertSelectKArray<SortOrder::Descending>(values, n);\n+  }\n+\n+  void AssertSelectKJson(const std::string& values, int n) {\n+    AssertTopKArray(ArrayFromJSON(GetType(), values), n);\n+    AssertBottomKArray(ArrayFromJSON(GetType(), values), n);\n+  }\n+\n+  virtual std::shared_ptr<DataType> GetType() = 0;\n+};\n+\n+template <typename ArrowType>\n+class TestSelectK : public TestSelectKBase<ArrowType> {\n+ protected:\n+  std::shared_ptr<DataType> GetType() override { return TypeToDataType<ArrowType>(); }\n+};\n+\n+template <typename ArrowType>\n+class TestSelectKForReal : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForReal, RealArrowTypes);\n+\n+template <typename ArrowType>\n+class TestSelectKForIntegral : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForIntegral, IntegralArrowTypes);\n+\n+template <typename ArrowType>\n+class TestSelectKForBool : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForBool, ::testing::Types<BooleanType>);\n+\n+template <typename ArrowType>\n+class TestSelectKForTemporal : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForTemporal, TemporalArrowTypes);\n+\n+template <typename ArrowType>\n+class TestSelectKForDecimal : public TestSelectKBase<ArrowType> {\n+  std::shared_ptr<DataType> GetType() override {\n+    return std::make_shared<ArrowType>(5, 2);\n+  }\n+};\n+TYPED_TEST_SUITE(TestSelectKForDecimal, DecimalArrowTypes);\n+\n+template <typename ArrowType>\n+class TestSelectKForStrings : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForStrings, testing::Types<StringType>);\n+\n+TYPED_TEST(TestSelectKForReal, SelectKDoesNotProvideDefaultOptions) {\n+  auto input = ArrayFromJSON(this->GetType(), \"[null, 1, 3.3, null, 2, 5.3]\");\n+  ASSERT_RAISES(Invalid, CallFunction(\"top_k\", {input}));\n+}\n+\n+TYPED_TEST(TestSelectKForReal, Real) {\n+  this->AssertSelectKJson(\"[null, 1, 3.3, null, 2, 5.3]\", 0);\n+  this->AssertSelectKJson(\"[null, 1, 3.3, null, 2, 5.3]\", 2);\n+  this->AssertSelectKJson(\"[null, 1, 3.3, null, 2, 5.3]\", 5);\n+  this->AssertSelectKJson(\"[null, 1, 3.3, null, 2, 5.3]\", 6);\n+\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 0);\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 1);\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 2);\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 3);\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 4);\n+  this->AssertSelectKJson(\"[NaN, 2, null, 3, 1]\", 3);\n+  this->AssertSelectKJson(\"[NaN, 2, null, 3, 1]\", 4);\n+}\n+\n+TYPED_TEST(TestSelectKForIntegral, Integral) {\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 0);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 2);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 5);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 6);\n+\n+  this->AssertSelectKJson(\"[2, 4, 5, 7, 8, 0, 9, 1, 3]\", 5);\n+}\n+\n+TYPED_TEST(TestSelectKForBool, Bool) {\n+  this->AssertSelectKJson(\"[null, false, true, null, false, true]\", 0);\n+  this->AssertSelectKJson(\"[null, false, true, null, false, true]\", 2);\n+  this->AssertSelectKJson(\"[null, false, true, null, false, true]\", 5);\n+  this->AssertSelectKJson(\"[null, false, true, null, false, true]\", 6);\n+}\n+\n+TYPED_TEST(TestSelectKForTemporal, Temporal) {\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 0);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 2);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 5);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 6);\n+}\n+\n+TYPED_TEST(TestSelectKForDecimal, Decimal) {\n+  const std::string values = R\"([\"123.45\", null, \"-123.45\", \"456.78\", \"-456.78\"])\";\n+  this->AssertSelectKJson(values, 0);\n+  this->AssertSelectKJson(values, 2);\n+  this->AssertSelectKJson(values, 4);\n+  this->AssertSelectKJson(values, 5);\n+}\n+\n+TYPED_TEST(TestSelectKForStrings, Strings) {\n+  this->AssertSelectKJson(R\"([\"testing\", null, \"nth\", \"for\", null, \"strings\"])\", 0);\n+  this->AssertSelectKJson(R\"([\"testing\", null, \"nth\", \"for\", null, \"strings\"])\", 2);\n+  this->AssertSelectKJson(R\"([\"testing\", null, \"nth\", \"for\", null, \"strings\"])\", 5);\n+  this->AssertSelectKJson(R\"([\"testing\", null, \"nth\", \"for\", null, \"strings\"])\", 6);\n+}\n+\n+/*struct TestSelectKWithKeepParam : public ::testing::Test {\n+  void Check(const std::shared_ptr<DataType>& type, const std::string& values, int64_t k,\n+             const std::string& expected) {\n+    std::shared_ptr<Array> actual;\n+    ASSERT_OK(this->DoSelectK(type, values, k, &actual));\n+    ValidateOutput(actual);\n+\n+    ASSERT_ARRAYS_EQUAL(*ArrayFromJSON(type, expected), *actual);\n+  }\n+\n+  void Check(const std::shared_ptr<DataType>& type, const std::shared_ptr<Array>& values,\n+             int64_t k, const std::string& expected) {\n+    ASSERT_OK_AND_ASSIGN(auto actual, TopK(*values, k));\n+    ValidateOutput(actual);\n+    ASSERT_ARRAYS_EQUAL(*ArrayFromJSON(type, expected), *actual);\n+  }\n+\n+  Status DoSelectK(const std::shared_ptr<DataType>& type, const std::string& values,\n+                   int64_t k, std::shared_ptr<Array>* out) {\n+    ARROW_ASSIGN_OR_RAISE(*out, TopK(*ArrayFromJSON(type, values), k));\n+    PrettyPrint(**out, {}, &std::cerr);\n+    return Status::OK();\n+  }\n+};\n+\n+TEST_F(TestSelectKWithKeepParam, Integral) {\n+  this->Check(int32(), \"[null, 1, 3, null, 2, 5]\", 0, \"[]\");\n+  this->Check(int32(), \"[null, 1, 3, null, 2, 5]\", 2, \"[5, 3]\");\n+  this->Check(int32(), \"[null, 1, 3, null, 2, 5]\", 5, \"[5, 3, 2, 1]\");\n+  this->Check(int32(), \"[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\", 5, \"[4, 4, 4, 4, 3]\");\n+}*/\n+\n+template <typename ArrowType>\n+class TestSelectKRandom : public TestSelectKBase<ArrowType> {\n+ public:\n+  std::shared_ptr<DataType> GetType() override {\n+    EXPECT_TRUE(0) << \"shouldn't be used\";\n+    return nullptr;\n+  }\n+};\n+\n+using SelectKableTypes =\n+    ::testing::Types<UInt8Type, UInt16Type, UInt32Type, UInt64Type, Int8Type, Int16Type,\n+                     Int32Type, Int64Type, FloatType, DoubleType, Decimal128Type,\n+                     StringType>;\n+\n+class RandomImpl {\n+ protected:\n+  random::RandomArrayGenerator generator_;\n+  std::shared_ptr<DataType> type_;\n+\n+  explicit RandomImpl(random::SeedType seed, std::shared_ptr<DataType> type)\n+      : generator_(seed), type_(std::move(type)) {}\n+\n+ public:\n+  std::shared_ptr<Array> Generate(uint64_t count, double null_prob) {\n+    return generator_.ArrayOf(type_, count, null_prob);\n+  }\n+};\n+\n+template <typename ArrowType>\n+class Random : public RandomImpl {\n+ public:\n+  explicit Random(random::SeedType seed)\n+      : RandomImpl(seed, TypeTraits<ArrowType>::type_singleton()) {}\n+};\n+\n+template <>\n+class Random<FloatType> : public RandomImpl {\n+  using CType = float;\n+\n+ public:\n+  explicit Random(random::SeedType seed) : RandomImpl(seed, float32()) {}\n+\n+  std::shared_ptr<Array> Generate(uint64_t count, double null_prob, double nan_prob = 0) {\n+    return generator_.Float32(count, std::numeric_limits<CType>::min(),\n+                              std::numeric_limits<CType>::max(), null_prob, nan_prob);\n+  }\n+};\n+\n+template <>\n+class Random<DoubleType> : public RandomImpl {\n+  using CType = double;\n+\n+ public:\n+  explicit Random(random::SeedType seed) : RandomImpl(seed, float64()) {}\n+\n+  std::shared_ptr<Array> Generate(uint64_t count, double null_prob, double nan_prob = 0) {\n+    return generator_.Float64(count, std::numeric_limits<CType>::min(),\n+                              std::numeric_limits<CType>::max(), null_prob, nan_prob);\n+  }\n+};\n+\n+template <>\n+class Random<Decimal128Type> : public RandomImpl {\n+ public:\n+  explicit Random(random::SeedType seed,\n+                  std::shared_ptr<DataType> type = decimal128(18, 5))\n+      : RandomImpl(seed, std::move(type)) {}\n+};\n+\n+template <typename ArrowType>\n+class RandomRange : public RandomImpl {\n+  using CType = typename TypeTraits<ArrowType>::CType;\n+\n+ public:\n+  explicit RandomRange(random::SeedType seed)\n+      : RandomImpl(seed, TypeTraits<ArrowType>::type_singleton()) {}\n+\n+  std::shared_ptr<Array> Generate(uint64_t count, int range, double null_prob) {\n+    CType min = std::numeric_limits<CType>::min();\n+    CType max = min + range;\n+    if (sizeof(CType) < 4 && (range + min) > std::numeric_limits<CType>::max()) {\n+      max = std::numeric_limits<CType>::max();\n+    }\n+    return generator_.Numeric<ArrowType>(count, min, max, null_prob);\n+  }\n+};\n+\n+TYPED_TEST_SUITE(TestSelectKRandom, SelectKableTypes);\n+\n+TYPED_TEST(TestSelectKRandom, RandomValues) {\n+  Random<TypeParam> rand(0x61549225);\n+  int length = 100;\n+  for (auto null_probability : {0.0, 0.1, 0.5, 1.0}) {\n+    // Try n from 0 to out of bound\n+    for (int n = 0; n <= length; ++n) {\n+      auto array = rand.Generate(length, null_probability);\n+      this->AssertTopKArray(array, n);\n+      this->AssertBottomKArray(array, n);\n+    }\n+  }\n+}\n+\n+template <SortOrder order>\n+struct TestSelectKWithChunkedArray : public ::testing::Test {\n+  TestSelectKWithChunkedArray()\n+      : sizes_({0, 1, 2, 4, 16, 31, 1234}),\n+        null_probabilities_({0.0, 0.1, 0.5, 0.9, 1.0}) {}\n+\n+  void Check(const std::shared_ptr<DataType>& type,\n+             const std::vector<std::string>& values, int64_t k,\n+             const std::string& expected) {\n+    std::shared_ptr<Array> actual;\n+    ASSERT_OK(this->DoSelectK(type, values, k, &actual));\n+    ValidateOutput(actual);\n+\n+    ASSERT_ARRAYS_EQUAL(*ArrayFromJSON(type, expected), *actual);\n+  }\n+\n+  void Check(const std::shared_ptr<DataType>& type,\n+             const std::shared_ptr<ChunkedArray>& values, int64_t k,\n+             const std::string& expected) {\n+    ASSERT_OK_AND_ASSIGN(auto actual, SelectK<order>(*values, k));\n+    ValidateOutput(actual);\n+    ASSERT_ARRAYS_EQUAL(*ArrayFromJSON(type, expected), *actual);\n+  }\n+\n+  Status DoSelectK(const std::shared_ptr<DataType>& type,\n+                   const std::vector<std::string>& values, int64_t k,\n+                   std::shared_ptr<Array>* out) {\n+    ARROW_ASSIGN_OR_RAISE(*out, SelectK<order>(*(ChunkedArrayFromJSON(type, values)), k));\n+    PrettyPrint(**out, {}, &std::cerr);\n\nReview comment:\n       Maybe move the ValidateOutput call here so you can't forget it?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/select_k_test.cc\n##########\n@@ -0,0 +1,714 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <functional>\n+#include <iostream>\n+#include <limits>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/array_decimal.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/testing/util.h\"\n+#include \"arrow/type_traits.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// Convert arrow::Type to arrow::DataType. If arrow::Type isn't\n+// parameter free, this returns an arrow::DataType with the default\n+// parameter.\n+template <typename ArrowType>\n+enable_if_t<TypeTraits<ArrowType>::is_parameter_free, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return TypeTraits<ArrowType>::type_singleton();\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, TimestampType>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return timestamp(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time32Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time32(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time64Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time64(TimeUnit::NANO);\n+}\n+\n+// ----------------------------------------------------------------------\n+// Tests for SelectK\n+\n+template <typename ArrayType>\n+auto GetLogicalValue(const ArrayType& array, uint64_t index)\n+    -> decltype(array.GetView(index)) {\n+  return array.GetView(index);\n+}\n+\n+Decimal128 GetLogicalValue(const Decimal128Array& array, uint64_t index) {\n+  return Decimal128(array.Value(index));\n+}\n+\n+Decimal256 GetLogicalValue(const Decimal256Array& array, uint64_t index) {\n+  return Decimal256(array.Value(index));\n+}\n+\n+}  // namespace\n+\n+template <typename ArrayType, SortOrder order>\n+class SelectKComparator {\n+ public:\n+  template <typename Type>\n+  bool operator()(const Type& lval, const Type& rval) {\n+    if (is_floating_type<typename ArrayType::TypeClass>::value) {\n+      // NaNs ordered after non-NaNs\n+      if (rval != rval) return true;\n+      if (lval != lval) return false;\n+    }\n+    if (order == SortOrder::Ascending) {\n+      return lval <= rval;\n+    } else {\n+      return rval <= lval;\n+    }\n+  }\n+};\n+\n+template <SortOrder order>\n+Result<std::shared_ptr<Array>> SelectK(const ChunkedArray& values, int64_t k) {\n+  if (order == SortOrder::Descending) {\n+    return TopK(values, k);\n+  } else {\n+    return BottomK(values, k);\n+  }\n+}\n+\n+template <SortOrder order>\n+Result<std::shared_ptr<Array>> SelectK(const Array& values, int64_t k) {\n+  if (order == SortOrder::Descending) {\n+    return TopK(values, k);\n+  } else {\n+    return BottomK(values, k);\n+  }\n+}\n+template <typename ArrowType>\n+class TestSelectKBase : public TestBase {\n+  using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n+\n+ protected:\n+  void Validate(const ArrayType& array, int k, ArrayType& select_k, SortOrder order) {\n+    ASSERT_OK_AND_ASSIGN(auto sorted_indices, SortIndices(array, order));\n+    ASSERT_OK_AND_ASSIGN(Datum sorted_datum,\n+                         Take(array, sorted_indices, TakeOptions::NoBoundsCheck()));\n+    std::shared_ptr<Array> sorted_array_out = sorted_datum.make_array();\n+\n+    const ArrayType& sorted_array = *checked_pointer_cast<ArrayType>(sorted_array_out);\n+\n+    if (k < array.length()) {\n+      for (uint64_t i = 0; i < (uint64_t)select_k.length(); ++i) {\n+        const auto lval = GetLogicalValue(select_k, i);\n+        const auto rval = GetLogicalValue(sorted_array, i);\n+        ASSERT_TRUE(lval == rval);\n+      }\n+    }\n+  }\n+  template <SortOrder order>\n+  void AssertSelectKArray(const std::shared_ptr<Array> values, int n) {\n+    std::shared_ptr<Array> select_k;\n+    ASSERT_OK_AND_ASSIGN(select_k, SelectK<order>(*values, n));\n+    ASSERT_EQ(select_k->data()->null_count, 0);\n+    ValidateOutput(*select_k);\n+    Validate(*checked_pointer_cast<ArrayType>(values), n,\n+             *checked_pointer_cast<ArrayType>(select_k), order);\n+  }\n+\n+  void AssertTopKArray(const std::shared_ptr<Array> values, int n) {\n+    AssertSelectKArray<SortOrder::Descending>(values, n);\n+  }\n+  void AssertBottomKArray(const std::shared_ptr<Array> values, int n) {\n+    AssertSelectKArray<SortOrder::Descending>(values, n);\n+  }\n+\n+  void AssertSelectKJson(const std::string& values, int n) {\n+    AssertTopKArray(ArrayFromJSON(GetType(), values), n);\n+    AssertBottomKArray(ArrayFromJSON(GetType(), values), n);\n+  }\n+\n+  virtual std::shared_ptr<DataType> GetType() = 0;\n+};\n+\n+template <typename ArrowType>\n+class TestSelectK : public TestSelectKBase<ArrowType> {\n+ protected:\n+  std::shared_ptr<DataType> GetType() override { return TypeToDataType<ArrowType>(); }\n+};\n+\n+template <typename ArrowType>\n+class TestSelectKForReal : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForReal, RealArrowTypes);\n+\n+template <typename ArrowType>\n+class TestSelectKForIntegral : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForIntegral, IntegralArrowTypes);\n+\n+template <typename ArrowType>\n+class TestSelectKForBool : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForBool, ::testing::Types<BooleanType>);\n+\n+template <typename ArrowType>\n+class TestSelectKForTemporal : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForTemporal, TemporalArrowTypes);\n+\n+template <typename ArrowType>\n+class TestSelectKForDecimal : public TestSelectKBase<ArrowType> {\n+  std::shared_ptr<DataType> GetType() override {\n+    return std::make_shared<ArrowType>(5, 2);\n+  }\n+};\n+TYPED_TEST_SUITE(TestSelectKForDecimal, DecimalArrowTypes);\n+\n+template <typename ArrowType>\n+class TestSelectKForStrings : public TestSelectK<ArrowType> {};\n+TYPED_TEST_SUITE(TestSelectKForStrings, testing::Types<StringType>);\n+\n+TYPED_TEST(TestSelectKForReal, SelectKDoesNotProvideDefaultOptions) {\n+  auto input = ArrayFromJSON(this->GetType(), \"[null, 1, 3.3, null, 2, 5.3]\");\n+  ASSERT_RAISES(Invalid, CallFunction(\"top_k\", {input}));\n+}\n+\n+TYPED_TEST(TestSelectKForReal, Real) {\n+  this->AssertSelectKJson(\"[null, 1, 3.3, null, 2, 5.3]\", 0);\n+  this->AssertSelectKJson(\"[null, 1, 3.3, null, 2, 5.3]\", 2);\n+  this->AssertSelectKJson(\"[null, 1, 3.3, null, 2, 5.3]\", 5);\n+  this->AssertSelectKJson(\"[null, 1, 3.3, null, 2, 5.3]\", 6);\n+\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 0);\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 1);\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 2);\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 3);\n+  this->AssertSelectKJson(\"[null, 2, NaN, 3, 1]\", 4);\n+  this->AssertSelectKJson(\"[NaN, 2, null, 3, 1]\", 3);\n+  this->AssertSelectKJson(\"[NaN, 2, null, 3, 1]\", 4);\n+}\n+\n+TYPED_TEST(TestSelectKForIntegral, Integral) {\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 0);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 2);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 5);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 6);\n+\n+  this->AssertSelectKJson(\"[2, 4, 5, 7, 8, 0, 9, 1, 3]\", 5);\n+}\n+\n+TYPED_TEST(TestSelectKForBool, Bool) {\n+  this->AssertSelectKJson(\"[null, false, true, null, false, true]\", 0);\n+  this->AssertSelectKJson(\"[null, false, true, null, false, true]\", 2);\n+  this->AssertSelectKJson(\"[null, false, true, null, false, true]\", 5);\n+  this->AssertSelectKJson(\"[null, false, true, null, false, true]\", 6);\n+}\n+\n+TYPED_TEST(TestSelectKForTemporal, Temporal) {\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 0);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 2);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 5);\n+  this->AssertSelectKJson(\"[null, 1, 3, null, 2, 5]\", 6);\n+}\n+\n+TYPED_TEST(TestSelectKForDecimal, Decimal) {\n+  const std::string values = R\"([\"123.45\", null, \"-123.45\", \"456.78\", \"-456.78\"])\";\n+  this->AssertSelectKJson(values, 0);\n+  this->AssertSelectKJson(values, 2);\n+  this->AssertSelectKJson(values, 4);\n+  this->AssertSelectKJson(values, 5);\n+}\n+\n+TYPED_TEST(TestSelectKForStrings, Strings) {\n+  this->AssertSelectKJson(R\"([\"testing\", null, \"nth\", \"for\", null, \"strings\"])\", 0);\n+  this->AssertSelectKJson(R\"([\"testing\", null, \"nth\", \"for\", null, \"strings\"])\", 2);\n+  this->AssertSelectKJson(R\"([\"testing\", null, \"nth\", \"for\", null, \"strings\"])\", 5);\n+  this->AssertSelectKJson(R\"([\"testing\", null, \"nth\", \"for\", null, \"strings\"])\", 6);\n+}\n+\n+/*struct TestSelectKWithKeepParam : public ::testing::Test {\n+  void Check(const std::shared_ptr<DataType>& type, const std::string& values, int64_t k,\n+             const std::string& expected) {\n+    std::shared_ptr<Array> actual;\n+    ASSERT_OK(this->DoSelectK(type, values, k, &actual));\n+    ValidateOutput(actual);\n+\n+    ASSERT_ARRAYS_EQUAL(*ArrayFromJSON(type, expected), *actual);\n+  }\n+\n+  void Check(const std::shared_ptr<DataType>& type, const std::shared_ptr<Array>& values,\n+             int64_t k, const std::string& expected) {\n+    ASSERT_OK_AND_ASSIGN(auto actual, TopK(*values, k));\n+    ValidateOutput(actual);\n+    ASSERT_ARRAYS_EQUAL(*ArrayFromJSON(type, expected), *actual);\n+  }\n+\n+  Status DoSelectK(const std::shared_ptr<DataType>& type, const std::string& values,\n+                   int64_t k, std::shared_ptr<Array>* out) {\n+    ARROW_ASSIGN_OR_RAISE(*out, TopK(*ArrayFromJSON(type, values), k));\n+    PrettyPrint(**out, {}, &std::cerr);\n+    return Status::OK();\n+  }\n+};\n+\n+TEST_F(TestSelectKWithKeepParam, Integral) {\n+  this->Check(int32(), \"[null, 1, 3, null, 2, 5]\", 0, \"[]\");\n+  this->Check(int32(), \"[null, 1, 3, null, 2, 5]\", 2, \"[5, 3]\");\n+  this->Check(int32(), \"[null, 1, 3, null, 2, 5]\", 5, \"[5, 3, 2, 1]\");\n+  this->Check(int32(), \"[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\", 5, \"[4, 4, 4, 4, 3]\");\n+}*/\n+\n+template <typename ArrowType>\n+class TestSelectKRandom : public TestSelectKBase<ArrowType> {\n+ public:\n+  std::shared_ptr<DataType> GetType() override {\n+    EXPECT_TRUE(0) << \"shouldn't be used\";\n+    return nullptr;\n+  }\n+};\n+\n+using SelectKableTypes =\n+    ::testing::Types<UInt8Type, UInt16Type, UInt32Type, UInt64Type, Int8Type, Int16Type,\n+                     Int32Type, Int64Type, FloatType, DoubleType, Decimal128Type,\n+                     StringType>;\n+\n+class RandomImpl {\n+ protected:\n+  random::RandomArrayGenerator generator_;\n+  std::shared_ptr<DataType> type_;\n+\n+  explicit RandomImpl(random::SeedType seed, std::shared_ptr<DataType> type)\n+      : generator_(seed), type_(std::move(type)) {}\n+\n+ public:\n+  std::shared_ptr<Array> Generate(uint64_t count, double null_prob) {\n+    return generator_.ArrayOf(type_, count, null_prob);\n+  }\n+};\n+\n+template <typename ArrowType>\n+class Random : public RandomImpl {\n+ public:\n+  explicit Random(random::SeedType seed)\n+      : RandomImpl(seed, TypeTraits<ArrowType>::type_singleton()) {}\n+};\n+\n+template <>\n+class Random<FloatType> : public RandomImpl {\n+  using CType = float;\n+\n+ public:\n+  explicit Random(random::SeedType seed) : RandomImpl(seed, float32()) {}\n+\n+  std::shared_ptr<Array> Generate(uint64_t count, double null_prob, double nan_prob = 0) {\n+    return generator_.Float32(count, std::numeric_limits<CType>::min(),\n+                              std::numeric_limits<CType>::max(), null_prob, nan_prob);\n+  }\n+};\n+\n+template <>\n+class Random<DoubleType> : public RandomImpl {\n+  using CType = double;\n+\n+ public:\n+  explicit Random(random::SeedType seed) : RandomImpl(seed, float64()) {}\n+\n+  std::shared_ptr<Array> Generate(uint64_t count, double null_prob, double nan_prob = 0) {\n+    return generator_.Float64(count, std::numeric_limits<CType>::min(),\n+                              std::numeric_limits<CType>::max(), null_prob, nan_prob);\n+  }\n+};\n+\n+template <>\n+class Random<Decimal128Type> : public RandomImpl {\n+ public:\n+  explicit Random(random::SeedType seed,\n+                  std::shared_ptr<DataType> type = decimal128(18, 5))\n+      : RandomImpl(seed, std::move(type)) {}\n+};\n+\n+template <typename ArrowType>\n+class RandomRange : public RandomImpl {\n+  using CType = typename TypeTraits<ArrowType>::CType;\n+\n+ public:\n+  explicit RandomRange(random::SeedType seed)\n+      : RandomImpl(seed, TypeTraits<ArrowType>::type_singleton()) {}\n+\n+  std::shared_ptr<Array> Generate(uint64_t count, int range, double null_prob) {\n+    CType min = std::numeric_limits<CType>::min();\n+    CType max = min + range;\n+    if (sizeof(CType) < 4 && (range + min) > std::numeric_limits<CType>::max()) {\n+      max = std::numeric_limits<CType>::max();\n+    }\n+    return generator_.Numeric<ArrowType>(count, min, max, null_prob);\n+  }\n+};\n+\n+TYPED_TEST_SUITE(TestSelectKRandom, SelectKableTypes);\n+\n+TYPED_TEST(TestSelectKRandom, RandomValues) {\n+  Random<TypeParam> rand(0x61549225);\n+  int length = 100;\n+  for (auto null_probability : {0.0, 0.1, 0.5, 1.0}) {\n+    // Try n from 0 to out of bound\n+    for (int n = 0; n <= length; ++n) {\n+      auto array = rand.Generate(length, null_probability);\n+      this->AssertTopKArray(array, n);\n+      this->AssertBottomKArray(array, n);\n+    }\n+  }\n+}\n+\n+template <SortOrder order>\n+struct TestSelectKWithChunkedArray : public ::testing::Test {\n+  TestSelectKWithChunkedArray()\n+      : sizes_({0, 1, 2, 4, 16, 31, 1234}),\n+        null_probabilities_({0.0, 0.1, 0.5, 0.9, 1.0}) {}\n+\n+  void Check(const std::shared_ptr<DataType>& type,\n+             const std::vector<std::string>& values, int64_t k,\n+             const std::string& expected) {\n+    std::shared_ptr<Array> actual;\n+    ASSERT_OK(this->DoSelectK(type, values, k, &actual));\n+    ValidateOutput(actual);\n+\n+    ASSERT_ARRAYS_EQUAL(*ArrayFromJSON(type, expected), *actual);\n+  }\n+\n+  void Check(const std::shared_ptr<DataType>& type,\n+             const std::shared_ptr<ChunkedArray>& values, int64_t k,\n+             const std::string& expected) {\n+    ASSERT_OK_AND_ASSIGN(auto actual, SelectK<order>(*values, k));\n+    ValidateOutput(actual);\n+    ASSERT_ARRAYS_EQUAL(*ArrayFromJSON(type, expected), *actual);\n+  }\n+\n+  Status DoSelectK(const std::shared_ptr<DataType>& type,\n+                   const std::vector<std::string>& values, int64_t k,\n+                   std::shared_ptr<Array>* out) {\n+    ARROW_ASSIGN_OR_RAISE(*out, SelectK<order>(*(ChunkedArrayFromJSON(type, values)), k));\n+    PrettyPrint(**out, {}, &std::cerr);\n+    return Status::OK();\n+  }\n+  std::vector<int32_t> sizes_;\n+  std::vector<double> null_probabilities_;\n+};\n+\n+struct TestTopKWithChunkedArray\n\nReview comment:\n       You can make the 'base' overload of the test helpers take Datum and then use ChunkedArrayFromJSON in the tests themselves, so that you don't have to write too many overloads.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -1778,6 +1784,711 @@ class SortIndicesMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// TopK/BottomK implementations\n+\n+using SelectKOptionsState = internal::OptionsWrapper<SelectKOptions>;\n+const auto kDefaultTopKOptions = SelectKOptions::TopKDefault();\n+const auto kDefaultBottomKOptions = SelectKOptions::BottomKDefault();\n+\n+const FunctionDoc top_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n\nReview comment:\n       Is `k` really a parameter? Shouldn't these be unary functions?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-01T13:47:57.407+0000",
                    "updated": "2021-09-01T13:47:57.407+0000",
                    "started": "2021-09-01T13:47:57.407+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645272",
                    "issueId": "13103422"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/645322",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019#discussion_r700236238\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -1778,6 +1784,711 @@ class SortIndicesMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// TopK/BottomK implementations\n+\n+using SelectKOptionsState = internal::OptionsWrapper<SelectKOptions>;\n+const auto kDefaultTopKOptions = SelectKOptions::TopKDefault();\n+const auto kDefaultBottomKOptions = SelectKOptions::BottomKDefault();\n+\n+const FunctionDoc top_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+const FunctionDoc bottom_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+Result<std::shared_ptr<ArrayData>> MakeMutableArrayForFixedSizedType(\n+    std::shared_ptr<DataType> out_type, int64_t length, MemoryPool* memory_pool) {\n+  auto buffer_size = BitUtil::BytesForBits(\n+      length * std::static_pointer_cast<UInt64Type>(out_type)->bit_width());\n+  std::vector<std::shared_ptr<Buffer>> buffers(2);\n+  ARROW_ASSIGN_OR_RAISE(buffers[1], AllocateResizableBuffer(buffer_size, memory_pool));\n+  auto out = std::make_shared<ArrayData>(out_type, length, buffers, 0);\n+  return out;\n+}\n+\n+class ArraySelecter : public TypeVisitor {\n+ public:\n+  ArraySelecter(ExecContext* ctx, const Array& array, int64_t k, const SortOrder order,\n+                Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        array_(array),\n+        k_(k),\n+        physical_type_(GetPhysicalType(array.type())),\n+        order_(order),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n\nReview comment:\n       nit: you might prefer VisitTypeInline instead which would let you define cases via templates instead of macros/overloads.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -1778,6 +1784,711 @@ class SortIndicesMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// TopK/BottomK implementations\n+\n+using SelectKOptionsState = internal::OptionsWrapper<SelectKOptions>;\n+const auto kDefaultTopKOptions = SelectKOptions::TopKDefault();\n+const auto kDefaultBottomKOptions = SelectKOptions::BottomKDefault();\n+\n+const FunctionDoc top_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+const FunctionDoc bottom_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+Result<std::shared_ptr<ArrayData>> MakeMutableArrayForFixedSizedType(\n+    std::shared_ptr<DataType> out_type, int64_t length, MemoryPool* memory_pool) {\n+  auto buffer_size = BitUtil::BytesForBits(\n+      length * std::static_pointer_cast<UInt64Type>(out_type)->bit_width());\n+  std::vector<std::shared_ptr<Buffer>> buffers(2);\n+  ARROW_ASSIGN_OR_RAISE(buffers[1], AllocateResizableBuffer(buffer_size, memory_pool));\n+  auto out = std::make_shared<ArrayData>(out_type, length, buffers, 0);\n+  return out;\n+}\n+\n+class ArraySelecter : public TypeVisitor {\n+ public:\n+  ArraySelecter(ExecContext* ctx, const Array& array, int64_t k, const SortOrder order,\n+                Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        array_(array),\n+        k_(k),\n+        physical_type_(GetPhysicalType(array.type())),\n+        order_(order),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return SelectKthInternal<TYPE>(); }\n+\n+  VISIT_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status SelectKthInternal() {\n+    using GetView = GetViewType<InType>;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    ArrayType arr(array_.data());\n+    std::vector<uint64_t> indices(arr.length());\n+\n+    uint64_t* indices_begin = indices.data();\n+    uint64_t* indices_end = indices_begin + indices.size();\n+    std::iota(indices_begin, indices_end, 0);\n+    if (k_ > arr.length()) {\n+      k_ = arr.length();\n+    }\n+    auto end_iter = PartitionNulls<ArrayType, NonStablePartitioner>(indices_begin,\n+                                                                    indices_end, arr, 0);\n+    auto kth_begin = indices_begin + k_;\n+    if (kth_begin > end_iter) {\n+      kth_begin = end_iter;\n+    }\n+    std::function<bool(uint64_t, uint64_t)> cmp;\n+    if (order_ == SortOrder::Ascending) {\n\nReview comment:\n       It seems odd to me to have sort order be templated in so many places only for it to ultimately result in a runtime choice. Either it should be templated all the way through, or it should be a runtime parameter all the way through.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -1778,6 +1784,711 @@ class SortIndicesMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// TopK/BottomK implementations\n+\n+using SelectKOptionsState = internal::OptionsWrapper<SelectKOptions>;\n+const auto kDefaultTopKOptions = SelectKOptions::TopKDefault();\n+const auto kDefaultBottomKOptions = SelectKOptions::BottomKDefault();\n+\n+const FunctionDoc top_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+const FunctionDoc bottom_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+Result<std::shared_ptr<ArrayData>> MakeMutableArrayForFixedSizedType(\n+    std::shared_ptr<DataType> out_type, int64_t length, MemoryPool* memory_pool) {\n+  auto buffer_size = BitUtil::BytesForBits(\n+      length * std::static_pointer_cast<UInt64Type>(out_type)->bit_width());\n+  std::vector<std::shared_ptr<Buffer>> buffers(2);\n+  ARROW_ASSIGN_OR_RAISE(buffers[1], AllocateResizableBuffer(buffer_size, memory_pool));\n+  auto out = std::make_shared<ArrayData>(out_type, length, buffers, 0);\n+  return out;\n+}\n+\n+class ArraySelecter : public TypeVisitor {\n+ public:\n+  ArraySelecter(ExecContext* ctx, const Array& array, int64_t k, const SortOrder order,\n+                Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        array_(array),\n+        k_(k),\n+        physical_type_(GetPhysicalType(array.type())),\n+        order_(order),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return SelectKthInternal<TYPE>(); }\n+\n+  VISIT_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n\nReview comment:\n       I wonder if the templating here could be done in a way to generate less code. For instance, TimestampType, Int64Type, and Date64Type all have the same underlying semantics and should use the same generated code.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -1778,6 +1784,711 @@ class SortIndicesMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// TopK/BottomK implementations\n+\n+using SelectKOptionsState = internal::OptionsWrapper<SelectKOptions>;\n+const auto kDefaultTopKOptions = SelectKOptions::TopKDefault();\n+const auto kDefaultBottomKOptions = SelectKOptions::BottomKDefault();\n+\n+const FunctionDoc top_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+const FunctionDoc bottom_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+Result<std::shared_ptr<ArrayData>> MakeMutableArrayForFixedSizedType(\n+    std::shared_ptr<DataType> out_type, int64_t length, MemoryPool* memory_pool) {\n+  auto buffer_size = BitUtil::BytesForBits(\n+      length * std::static_pointer_cast<UInt64Type>(out_type)->bit_width());\n+  std::vector<std::shared_ptr<Buffer>> buffers(2);\n+  ARROW_ASSIGN_OR_RAISE(buffers[1], AllocateResizableBuffer(buffer_size, memory_pool));\n+  auto out = std::make_shared<ArrayData>(out_type, length, buffers, 0);\n+  return out;\n+}\n+\n+class ArraySelecter : public TypeVisitor {\n+ public:\n+  ArraySelecter(ExecContext* ctx, const Array& array, int64_t k, const SortOrder order,\n+                Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        array_(array),\n+        k_(k),\n+        physical_type_(GetPhysicalType(array.type())),\n+        order_(order),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return SelectKthInternal<TYPE>(); }\n+\n+  VISIT_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status SelectKthInternal() {\n+    using GetView = GetViewType<InType>;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    ArrayType arr(array_.data());\n+    std::vector<uint64_t> indices(arr.length());\n+\n+    uint64_t* indices_begin = indices.data();\n+    uint64_t* indices_end = indices_begin + indices.size();\n+    std::iota(indices_begin, indices_end, 0);\n+    if (k_ > arr.length()) {\n+      k_ = arr.length();\n+    }\n+    auto end_iter = PartitionNulls<ArrayType, NonStablePartitioner>(indices_begin,\n+                                                                    indices_end, arr, 0);\n+    auto kth_begin = indices_begin + k_;\n+    if (kth_begin > end_iter) {\n+      kth_begin = end_iter;\n+    }\n+    std::function<bool(uint64_t, uint64_t)> cmp;\n+    if (order_ == SortOrder::Ascending) {\n+      cmp = [&arr](uint64_t left, uint64_t right) -> bool {\n+        const auto lval = GetView::LogicalValue(arr.GetView(left));\n+        const auto rval = GetView::LogicalValue(arr.GetView(right));\n+        return lval < rval;\n+      };\n+    } else {\n+      cmp = [&arr](uint64_t left, uint64_t right) -> bool {\n+        const auto lval = GetView::LogicalValue(arr.GetView(left));\n+        const auto rval = GetView::LogicalValue(arr.GetView(right));\n+        return rval < lval;\n+      };\n+    }\n+    arrow::internal::Heap<uint64_t, decltype(cmp)> heap(cmp);\n+    uint64_t* iter = indices_begin;\n+    for (; iter != kth_begin && heap.Size() < static_cast<size_t>(k_); ++iter) {\n+      heap.Push(*iter);\n+    }\n+    for (; iter != end_iter && heap.Size() > 0; ++iter) {\n+      uint64_t x_index = *iter;\n+      const auto lval = GetView::LogicalValue(arr.GetView(x_index));\n+      const auto rval = GetView::LogicalValue(arr.GetView(heap.Top()));\n+      if (order_ == SortOrder::Ascending) {\n+        if (lval < rval) {\n+          heap.ReplaceTop(x_index);\n+        }\n+      } else {\n+        if (rval < lval) {\n+          heap.ReplaceTop(x_index);\n+        }\n+      }\n+    }\n+\n+    int64_t out_size = static_cast<int64_t>(heap.Size());\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto take_indices,\n+        MakeMutableArrayForFixedSizedType(uint64(), out_size, ctx_->memory_pool()));\n\nReview comment:\n       I wonder if we shouldn't just return the indices, just like the sort kernel.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -1778,6 +1784,711 @@ class SortIndicesMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// TopK/BottomK implementations\n+\n+using SelectKOptionsState = internal::OptionsWrapper<SelectKOptions>;\n+const auto kDefaultTopKOptions = SelectKOptions::TopKDefault();\n+const auto kDefaultBottomKOptions = SelectKOptions::BottomKDefault();\n+\n+const FunctionDoc top_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+const FunctionDoc bottom_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+Result<std::shared_ptr<ArrayData>> MakeMutableArrayForFixedSizedType(\n+    std::shared_ptr<DataType> out_type, int64_t length, MemoryPool* memory_pool) {\n+  auto buffer_size = BitUtil::BytesForBits(\n+      length * std::static_pointer_cast<UInt64Type>(out_type)->bit_width());\n+  std::vector<std::shared_ptr<Buffer>> buffers(2);\n+  ARROW_ASSIGN_OR_RAISE(buffers[1], AllocateResizableBuffer(buffer_size, memory_pool));\n+  auto out = std::make_shared<ArrayData>(out_type, length, buffers, 0);\n+  return out;\n+}\n+\n+class ArraySelecter : public TypeVisitor {\n+ public:\n+  ArraySelecter(ExecContext* ctx, const Array& array, int64_t k, const SortOrder order,\n+                Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        array_(array),\n+        k_(k),\n+        physical_type_(GetPhysicalType(array.type())),\n+        order_(order),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return SelectKthInternal<TYPE>(); }\n+\n+  VISIT_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status SelectKthInternal() {\n+    using GetView = GetViewType<InType>;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    ArrayType arr(array_.data());\n+    std::vector<uint64_t> indices(arr.length());\n+\n+    uint64_t* indices_begin = indices.data();\n+    uint64_t* indices_end = indices_begin + indices.size();\n+    std::iota(indices_begin, indices_end, 0);\n+    if (k_ > arr.length()) {\n+      k_ = arr.length();\n+    }\n+    auto end_iter = PartitionNulls<ArrayType, NonStablePartitioner>(indices_begin,\n+                                                                    indices_end, arr, 0);\n+    auto kth_begin = indices_begin + k_;\n+    if (kth_begin > end_iter) {\n+      kth_begin = end_iter;\n+    }\n+    std::function<bool(uint64_t, uint64_t)> cmp;\n+    if (order_ == SortOrder::Ascending) {\n\nReview comment:\n       (Otherwise, why generate separate code for both cases in so many places?)\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -1778,6 +1784,711 @@ class SortIndicesMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// TopK/BottomK implementations\n+\n+using SelectKOptionsState = internal::OptionsWrapper<SelectKOptions>;\n+const auto kDefaultTopKOptions = SelectKOptions::TopKDefault();\n+const auto kDefaultBottomKOptions = SelectKOptions::BottomKDefault();\n+\n+const FunctionDoc top_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+const FunctionDoc bottom_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+Result<std::shared_ptr<ArrayData>> MakeMutableArrayForFixedSizedType(\n+    std::shared_ptr<DataType> out_type, int64_t length, MemoryPool* memory_pool) {\n+  auto buffer_size = BitUtil::BytesForBits(\n+      length * std::static_pointer_cast<UInt64Type>(out_type)->bit_width());\n+  std::vector<std::shared_ptr<Buffer>> buffers(2);\n+  ARROW_ASSIGN_OR_RAISE(buffers[1], AllocateResizableBuffer(buffer_size, memory_pool));\n+  auto out = std::make_shared<ArrayData>(out_type, length, buffers, 0);\n+  return out;\n+}\n+\n+class ArraySelecter : public TypeVisitor {\n+ public:\n+  ArraySelecter(ExecContext* ctx, const Array& array, int64_t k, const SortOrder order,\n+                Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        array_(array),\n+        k_(k),\n+        physical_type_(GetPhysicalType(array.type())),\n+        order_(order),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return SelectKthInternal<TYPE>(); }\n+\n+  VISIT_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status SelectKthInternal() {\n+    using GetView = GetViewType<InType>;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    ArrayType arr(array_.data());\n+    std::vector<uint64_t> indices(arr.length());\n+\n+    uint64_t* indices_begin = indices.data();\n+    uint64_t* indices_end = indices_begin + indices.size();\n+    std::iota(indices_begin, indices_end, 0);\n+    if (k_ > arr.length()) {\n+      k_ = arr.length();\n+    }\n+    auto end_iter = PartitionNulls<ArrayType, NonStablePartitioner>(indices_begin,\n+                                                                    indices_end, arr, 0);\n+    auto kth_begin = indices_begin + k_;\n+    if (kth_begin > end_iter) {\n+      kth_begin = end_iter;\n+    }\n+    std::function<bool(uint64_t, uint64_t)> cmp;\n+    if (order_ == SortOrder::Ascending) {\n+      cmp = [&arr](uint64_t left, uint64_t right) -> bool {\n+        const auto lval = GetView::LogicalValue(arr.GetView(left));\n+        const auto rval = GetView::LogicalValue(arr.GetView(right));\n+        return lval < rval;\n+      };\n+    } else {\n+      cmp = [&arr](uint64_t left, uint64_t right) -> bool {\n+        const auto lval = GetView::LogicalValue(arr.GetView(left));\n+        const auto rval = GetView::LogicalValue(arr.GetView(right));\n+        return rval < lval;\n+      };\n+    }\n+    arrow::internal::Heap<uint64_t, decltype(cmp)> heap(cmp);\n+    uint64_t* iter = indices_begin;\n+    for (; iter != kth_begin && heap.Size() < static_cast<size_t>(k_); ++iter) {\n\nReview comment:\n       Isn't the second condition redundant because of how kth_begin is defined above?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-01T14:55:54.936+0000",
                    "updated": "2021-09-01T14:55:54.936+0000",
                    "started": "2021-09-01T14:55:54.936+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645322",
                    "issueId": "13103422"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/645600",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019#discussion_r700603134\n\n\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.cc\n##########\n@@ -140,6 +144,15 @@ PartitionNthOptions::PartitionNthOptions(int64_t pivot)\n     : FunctionOptions(internal::kPartitionNthOptionsType), pivot(pivot) {}\n constexpr char PartitionNthOptions::kTypeName[];\n \n+SelectKOptions::SelectKOptions(int64_t k, std::vector<std::string> keys, std::string keep,\n+                               SortOrder order)\n+    : FunctionOptions(internal::kSelectKOptionsType),\n+      k(k),\n+      keys(std::move(keys)),\n+      keep(keep),\n+      order(order) {}\n+constexpr char SelectKOptions::kTypeName[];\n+\n\nReview comment:\n       The select K algorithm is a general approach to get the topK, bottomK, or median statistic. It seems that SortOrder option is always `Descending` for topK and `Ascending` for bottomK, so I recommend to use an enum for the type of statistic desired instead of specifying ordering. As a user, if I specify `Ascending` it is not intuitive that it corresponds to topK because it depends from which side the sorted data is searched.\r\n   ```\r\n   enum class SelectionOperator {\r\n     TOPK,\r\n     BOTTOMK,\r\n     MEDIAN,  // possibly for another PR\r\n   };\r\n   ```\r\n   Also, I am not sure that the`keys` and `keep` options are part of common SelectK algorithms.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-01T22:00:33.954+0000",
                    "updated": "2021-09-01T22:00:33.954+0000",
                    "started": "2021-09-01T22:00:33.954+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645600",
                    "issueId": "13103422"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/645601",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019#discussion_r700603134\n\n\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.cc\n##########\n@@ -140,6 +144,15 @@ PartitionNthOptions::PartitionNthOptions(int64_t pivot)\n     : FunctionOptions(internal::kPartitionNthOptionsType), pivot(pivot) {}\n constexpr char PartitionNthOptions::kTypeName[];\n \n+SelectKOptions::SelectKOptions(int64_t k, std::vector<std::string> keys, std::string keep,\n+                               SortOrder order)\n+    : FunctionOptions(internal::kSelectKOptionsType),\n+      k(k),\n+      keys(std::move(keys)),\n+      keep(keep),\n+      order(order) {}\n+constexpr char SelectKOptions::kTypeName[];\n+\n\nReview comment:\n       The select K algorithm is a general approach to get the topK, bottomK, or median statistic. It seems that SortOrder option is always `Descending` for topK and `Ascending` for bottomK, so I recommend to use an enum for the type of statistic desired instead of specifying ordering. As a user, if I specify `Ascending` it is not intuitive that it corresponds to topK because it depends from which side the sorted data is searched.\r\n   ```\r\n   enum class SelectionOperator {\r\n     TOPK,\r\n     BOTTOMK,\r\n     MEDIAN,  // possibly for another PR\r\n   };\r\n   ```\r\n   Also, I am not sure that the`keys` and `keep` options are part of common selectK APIs.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-01T22:05:30.155+0000",
                    "updated": "2021-09-01T22:05:30.155+0000",
                    "started": "2021-09-01T22:05:30.155+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645601",
                    "issueId": "13103422"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/645607",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019#discussion_r700615057\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -1778,6 +1784,711 @@ class SortIndicesMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// TopK/BottomK implementations\n+\n+using SelectKOptionsState = internal::OptionsWrapper<SelectKOptions>;\n+const auto kDefaultTopKOptions = SelectKOptions::TopKDefault();\n+const auto kDefaultBottomKOptions = SelectKOptions::BottomKDefault();\n+\n+const FunctionDoc top_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+const FunctionDoc bottom_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+Result<std::shared_ptr<ArrayData>> MakeMutableArrayForFixedSizedType(\n+    std::shared_ptr<DataType> out_type, int64_t length, MemoryPool* memory_pool) {\n+  auto buffer_size = BitUtil::BytesForBits(\n+      length * std::static_pointer_cast<UInt64Type>(out_type)->bit_width());\n+  std::vector<std::shared_ptr<Buffer>> buffers(2);\n+  ARROW_ASSIGN_OR_RAISE(buffers[1], AllocateResizableBuffer(buffer_size, memory_pool));\n+  auto out = std::make_shared<ArrayData>(out_type, length, buffers, 0);\n+  return out;\n+}\n+\n+class ArraySelecter : public TypeVisitor {\n+ public:\n+  ArraySelecter(ExecContext* ctx, const Array& array, int64_t k, const SortOrder order,\n+                Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        array_(array),\n+        k_(k),\n+        physical_type_(GetPhysicalType(array.type())),\n+        order_(order),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return SelectKthInternal<TYPE>(); }\n+\n+  VISIT_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status SelectKthInternal() {\n+    using GetView = GetViewType<InType>;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    ArrayType arr(array_.data());\n+    std::vector<uint64_t> indices(arr.length());\n+\n+    uint64_t* indices_begin = indices.data();\n+    uint64_t* indices_end = indices_begin + indices.size();\n+    std::iota(indices_begin, indices_end, 0);\n+    if (k_ > arr.length()) {\n+      k_ = arr.length();\n+    }\n+    auto end_iter = PartitionNulls<ArrayType, NonStablePartitioner>(indices_begin,\n+                                                                    indices_end, arr, 0);\n+    auto kth_begin = indices_begin + k_;\n+    if (kth_begin > end_iter) {\n+      kth_begin = end_iter;\n+    }\n+    std::function<bool(uint64_t, uint64_t)> cmp;\n+    if (order_ == SortOrder::Ascending) {\n+      cmp = [&arr](uint64_t left, uint64_t right) -> bool {\n+        const auto lval = GetView::LogicalValue(arr.GetView(left));\n+        const auto rval = GetView::LogicalValue(arr.GetView(right));\n+        return lval < rval;\n+      };\n+    } else {\n+      cmp = [&arr](uint64_t left, uint64_t right) -> bool {\n+        const auto lval = GetView::LogicalValue(arr.GetView(left));\n+        const auto rval = GetView::LogicalValue(arr.GetView(right));\n+        return rval < lval;\n+      };\n+    }\n+    arrow::internal::Heap<uint64_t, decltype(cmp)> heap(cmp);\n+    uint64_t* iter = indices_begin;\n+    for (; iter != kth_begin && heap.Size() < static_cast<size_t>(k_); ++iter) {\n+      heap.Push(*iter);\n+    }\n+    for (; iter != end_iter && heap.Size() > 0; ++iter) {\n+      uint64_t x_index = *iter;\n+      const auto lval = GetView::LogicalValue(arr.GetView(x_index));\n+      const auto rval = GetView::LogicalValue(arr.GetView(heap.Top()));\n+      if (order_ == SortOrder::Ascending) {\n+        if (lval < rval) {\n+          heap.ReplaceTop(x_index);\n+        }\n+      } else {\n+        if (rval < lval) {\n+          heap.ReplaceTop(x_index);\n+        }\n+      }\n+    }\n+\n+    int64_t out_size = static_cast<int64_t>(heap.Size());\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto take_indices,\n+        MakeMutableArrayForFixedSizedType(uint64(), out_size, ctx_->memory_pool()));\n+\n+    auto* out_cbegin = take_indices->GetMutableValues<uint64_t>(1) + out_size - 1;\n+    while (heap.Size() > 0) {\n+      *out_cbegin = heap.Top();\n+      heap.Pop();\n+      --out_cbegin;\n+    }\n+    ARROW_ASSIGN_OR_RAISE(*output_, Take(array_, Datum(std::move(take_indices)),\n+                                         TakeOptions::NoBoundsCheck(), ctx_));\n+    return Status::OK();\n+  }\n+\n+  ExecContext* ctx_;\n+  const Array& array_;\n+  int64_t k_;\n+  const std::shared_ptr<DataType> physical_type_;\n+  SortOrder order_;\n+  Datum* output_;\n+};\n+\n+template <typename ArrayType>\n+struct TypedHeapItem {\n+  uint64_t index;\n+  uint64_t offset;\n+  ArrayType* array;\n+};\n+\n+class ChunkedArraySelecter : public TypeVisitor {\n+ public:\n+  ChunkedArraySelecter(ExecContext* ctx, int64_t k, const ChunkedArray& chunked_array,\n+                       const SortOrder order, Datum* output)\n+      : TypeVisitor(),\n+        k_(k),\n+        chunked_array_(chunked_array),\n+        physical_type_(GetPhysicalType(chunked_array.type())),\n+        physical_chunks_(GetPhysicalChunks(chunked_array_, physical_type_)),\n+        order_(order),\n+        ctx_(ctx),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return SelectKthInternal<TYPE>(); }\n+\n+  VISIT_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status SelectKthInternal() {\n+    using GetView = GetViewType<InType>;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+    using HeapItem = TypedHeapItem<ArrayType>;\n+\n+    const auto num_chunks = chunked_array_.num_chunks();\n+    if (num_chunks == 0) {\n+      return Status::OK();\n+    }\n+    if (k_ > chunked_array_.length()) {\n+      k_ = chunked_array_.length();\n+    }\n+    std::function<bool(const HeapItem&, const HeapItem&)> cmp;\n+    if (order_ == SortOrder::Ascending) {\n+      cmp = [](const HeapItem& left, const HeapItem& right) -> bool {\n\nReview comment:\n       These ordering checks and compare lambdas can be resolved via templates based on the SelectionOperator (topK vs bottomK).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-01T22:25:50.991+0000",
                    "updated": "2021-09-01T22:25:50.991+0000",
                    "started": "2021-09-01T22:25:50.991+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645607",
                    "issueId": "13103422"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/645616",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019#discussion_r700603134\n\n\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.cc\n##########\n@@ -140,6 +144,15 @@ PartitionNthOptions::PartitionNthOptions(int64_t pivot)\n     : FunctionOptions(internal::kPartitionNthOptionsType), pivot(pivot) {}\n constexpr char PartitionNthOptions::kTypeName[];\n \n+SelectKOptions::SelectKOptions(int64_t k, std::vector<std::string> keys, std::string keep,\n+                               SortOrder order)\n+    : FunctionOptions(internal::kSelectKOptionsType),\n+      k(k),\n+      keys(std::move(keys)),\n+      keep(keep),\n+      order(order) {}\n+constexpr char SelectKOptions::kTypeName[];\n+\n\nReview comment:\n       The select K algorithm is a general approach to get the topK, bottomK, or median statistic. It seems that SortOrder option is always `Descending` for topK and `Ascending` for bottomK, so I recommend to use an enum for the type of statistic desired instead of specifying ordering. As a user, if I specify `Ascending` it is not intuitive that it corresponds to topK because it depends from which side the sorted data is searched.\r\n   ```\r\n   enum class SelectionOperator {\r\n     TOPK,\r\n     BOTTOMK,\r\n     MEDIAN,  // possibly for another PR\r\n   };\r\n   ```\r\n   Also, I am not sure that the`keys` and `keep` options are part of common selectK APIs. I think that having a sorter data member which represents the options for a sorting algorithm would be better structured.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-01T22:38:08.429+0000",
                    "updated": "2021-09-01T22:38:08.429+0000",
                    "started": "2021-09-01T22:38:08.428+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645616",
                    "issueId": "13103422"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/645630",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019#discussion_r700633416\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -1778,6 +1784,711 @@ class SortIndicesMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// TopK/BottomK implementations\n+\n+using SelectKOptionsState = internal::OptionsWrapper<SelectKOptions>;\n+const auto kDefaultTopKOptions = SelectKOptions::TopKDefault();\n+const auto kDefaultBottomKOptions = SelectKOptions::BottomKDefault();\n+\n+const FunctionDoc top_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+const FunctionDoc bottom_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+Result<std::shared_ptr<ArrayData>> MakeMutableArrayForFixedSizedType(\n+    std::shared_ptr<DataType> out_type, int64_t length, MemoryPool* memory_pool) {\n+  auto buffer_size = BitUtil::BytesForBits(\n+      length * std::static_pointer_cast<UInt64Type>(out_type)->bit_width());\n+  std::vector<std::shared_ptr<Buffer>> buffers(2);\n+  ARROW_ASSIGN_OR_RAISE(buffers[1], AllocateResizableBuffer(buffer_size, memory_pool));\n+  auto out = std::make_shared<ArrayData>(out_type, length, buffers, 0);\n+  return out;\n+}\n+\n+class ArraySelecter : public TypeVisitor {\n+ public:\n+  ArraySelecter(ExecContext* ctx, const Array& array, int64_t k, const SortOrder order,\n+                Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        array_(array),\n+        k_(k),\n+        physical_type_(GetPhysicalType(array.type())),\n+        order_(order),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return SelectKthInternal<TYPE>(); }\n+\n+  VISIT_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status SelectKthInternal() {\n+    using GetView = GetViewType<InType>;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    ArrayType arr(array_.data());\n+    std::vector<uint64_t> indices(arr.length());\n+\n+    uint64_t* indices_begin = indices.data();\n+    uint64_t* indices_end = indices_begin + indices.size();\n+    std::iota(indices_begin, indices_end, 0);\n+    if (k_ > arr.length()) {\n+      k_ = arr.length();\n+    }\n+    auto end_iter = PartitionNulls<ArrayType, NonStablePartitioner>(indices_begin,\n+                                                                    indices_end, arr, 0);\n+    auto kth_begin = indices_begin + k_;\n+    if (kth_begin > end_iter) {\n+      kth_begin = end_iter;\n+    }\n+    std::function<bool(uint64_t, uint64_t)> cmp;\n+    if (order_ == SortOrder::Ascending) {\n+      cmp = [&arr](uint64_t left, uint64_t right) -> bool {\n+        const auto lval = GetView::LogicalValue(arr.GetView(left));\n+        const auto rval = GetView::LogicalValue(arr.GetView(right));\n+        return lval < rval;\n+      };\n+    } else {\n+      cmp = [&arr](uint64_t left, uint64_t right) -> bool {\n+        const auto lval = GetView::LogicalValue(arr.GetView(left));\n+        const auto rval = GetView::LogicalValue(arr.GetView(right));\n+        return rval < lval;\n+      };\n+    }\n+    arrow::internal::Heap<uint64_t, decltype(cmp)> heap(cmp);\n+    uint64_t* iter = indices_begin;\n+    for (; iter != kth_begin && heap.Size() < static_cast<size_t>(k_); ++iter) {\n+      heap.Push(*iter);\n+    }\n+    for (; iter != end_iter && heap.Size() > 0; ++iter) {\n+      uint64_t x_index = *iter;\n+      const auto lval = GetView::LogicalValue(arr.GetView(x_index));\n+      const auto rval = GetView::LogicalValue(arr.GetView(heap.Top()));\n+      if (order_ == SortOrder::Ascending) {\n+        if (lval < rval) {\n+          heap.ReplaceTop(x_index);\n+        }\n+      } else {\n+        if (rval < lval) {\n+          heap.ReplaceTop(x_index);\n+        }\n+      }\n+    }\n+\n+    int64_t out_size = static_cast<int64_t>(heap.Size());\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto take_indices,\n+        MakeMutableArrayForFixedSizedType(uint64(), out_size, ctx_->memory_pool()));\n+\n+    auto* out_cbegin = take_indices->GetMutableValues<uint64_t>(1) + out_size - 1;\n+    while (heap.Size() > 0) {\n+      *out_cbegin = heap.Top();\n+      heap.Pop();\n+      --out_cbegin;\n+    }\n\nReview comment:\n       The code for extracting top from heap until empty is used in the same manner across the different `SelectKthInternal` methods. Could this be generalized into a common method for `Heap`? Similarly, other duplicated code across methods could be extracted into a single common method.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-01T23:12:27.133+0000",
                    "updated": "2021-09-01T23:12:27.133+0000",
                    "started": "2021-09-01T23:12:27.132+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645630",
                    "issueId": "13103422"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/645656",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019#discussion_r700680043\n\n\n\n##########\nFile path: cpp/src/arrow/util/heap.h\n##########\n@@ -0,0 +1,76 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+// A Heap class, is a simple wrapper to make heap operation simpler.\n+// This class is immutable by design\n\nReview comment:\n       oh my bad\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-02T01:31:40.564+0000",
                    "updated": "2021-09-02T01:31:40.564+0000",
                    "started": "2021-09-02T01:31:40.564+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645656",
                    "issueId": "13103422"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/645657",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019#discussion_r700680132\n\n\n\n##########\nFile path: cpp/src/arrow/util/heap.h\n##########\n@@ -0,0 +1,76 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+// A Heap class, is a simple wrapper to make heap operation simpler.\n+// This class is immutable by design\n+template <typename T, typename Compare = std::less<T>>\n+class ARROW_EXPORT Heap {\n+ public:\n+  explicit Heap() : values_(), comp_() {}\n+  explicit Heap(const Compare& compare) : values_(), comp_(compare) {}\n+\n+  Heap(Heap&&) = default;\n+  Heap& operator=(Heap&&) = default;\n+\n+  T* Data() { return values_.data(); }\n+\n+  // const T& Top() const { return values_.front(); }\n+\n+  T Top() const { return values_.front(); }\n+\n+  bool Empty() const { return values_.empty(); }\n+\n+  size_t Size() const { return values_.size(); }\n+\n+  void Push(const T& value) {\n+    values_.push_back(value);\n+    std::push_heap(values_.begin(), values_.end(), comp_);\n+  }\n+\n+  void Pop() {\n+    std::pop_heap(values_.begin(), values_.end(), comp_);\n+    values_.pop_back();\n+  }\n+\n+  void ReplaceTop(const T& value) {\n+    std::pop_heap(values_.begin(), values_.end(), comp_);\n+    values_.back() = value;\n+    std::push_heap(values_.begin(), values_.end(), comp_);\n+  }\n+\n+  void SetComparator(const Compare& comp) { comp_ = comp; }\n\nReview comment:\n       it was removed \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-02T01:31:53.926+0000",
                    "updated": "2021-09-02T01:31:53.926+0000",
                    "started": "2021-09-02T01:31:53.926+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645657",
                    "issueId": "13103422"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/645660",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019#discussion_r700685992\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/select_k_test.cc\n##########\n@@ -0,0 +1,714 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <functional>\n+#include <iostream>\n+#include <limits>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/array_decimal.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/testing/util.h\"\n+#include \"arrow/type_traits.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// Convert arrow::Type to arrow::DataType. If arrow::Type isn't\n+// parameter free, this returns an arrow::DataType with the default\n+// parameter.\n+template <typename ArrowType>\n+enable_if_t<TypeTraits<ArrowType>::is_parameter_free, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return TypeTraits<ArrowType>::type_singleton();\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, TimestampType>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return timestamp(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time32Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time32(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time64Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time64(TimeUnit::NANO);\n+}\n\nReview comment:\n       I will wait a little, once `default_type_instance` is part of master I will replace this part of the code. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-02T01:51:22.803+0000",
                    "updated": "2021-09-02T01:51:22.803+0000",
                    "started": "2021-09-02T01:51:22.802+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645660",
                    "issueId": "13103422"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/645665",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019#discussion_r700688954\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/select_k_test.cc\n##########\n@@ -0,0 +1,714 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <functional>\n+#include <iostream>\n+#include <limits>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/array_decimal.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/testing/util.h\"\n+#include \"arrow/type_traits.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// Convert arrow::Type to arrow::DataType. If arrow::Type isn't\n+// parameter free, this returns an arrow::DataType with the default\n+// parameter.\n+template <typename ArrowType>\n+enable_if_t<TypeTraits<ArrowType>::is_parameter_free, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return TypeTraits<ArrowType>::type_singleton();\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, TimestampType>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return timestamp(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time32Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time32(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time64Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time64(TimeUnit::NANO);\n+}\n+\n+// ----------------------------------------------------------------------\n+// Tests for SelectK\n+\n+template <typename ArrayType>\n+auto GetLogicalValue(const ArrayType& array, uint64_t index)\n+    -> decltype(array.GetView(index)) {\n+  return array.GetView(index);\n+}\n+\n+Decimal128 GetLogicalValue(const Decimal128Array& array, uint64_t index) {\n+  return Decimal128(array.Value(index));\n+}\n+\n+Decimal256 GetLogicalValue(const Decimal256Array& array, uint64_t index) {\n+  return Decimal256(array.Value(index));\n+}\n+\n+}  // namespace\n+\n+template <typename ArrayType, SortOrder order>\n+class SelectKComparator {\n+ public:\n+  template <typename Type>\n+  bool operator()(const Type& lval, const Type& rval) {\n+    if (is_floating_type<typename ArrayType::TypeClass>::value) {\n+      // NaNs ordered after non-NaNs\n+      if (rval != rval) return true;\n\nReview comment:\n       Not for this case, this functor is used only to test output not to process data. So it is expected that NaN are not part of the output as null-like values were filtered before in TopK/BottomK. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-02T02:00:08.468+0000",
                    "updated": "2021-09-02T02:00:08.468+0000",
                    "started": "2021-09-02T02:00:08.467+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645665",
                    "issueId": "13103422"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/645682",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019#discussion_r700701250\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/select_k_test.cc\n##########\n@@ -0,0 +1,714 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <functional>\n+#include <iostream>\n+#include <limits>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/array_decimal.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/testing/util.h\"\n+#include \"arrow/type_traits.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// Convert arrow::Type to arrow::DataType. If arrow::Type isn't\n+// parameter free, this returns an arrow::DataType with the default\n+// parameter.\n+template <typename ArrowType>\n+enable_if_t<TypeTraits<ArrowType>::is_parameter_free, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return TypeTraits<ArrowType>::type_singleton();\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, TimestampType>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return timestamp(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time32Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time32(TimeUnit::MILLI);\n+}\n+\n+template <typename ArrowType>\n+enable_if_t<std::is_same<ArrowType, Time64Type>::value, std::shared_ptr<DataType>>\n+TypeToDataType() {\n+  return time64(TimeUnit::NANO);\n+}\n+\n+// ----------------------------------------------------------------------\n+// Tests for SelectK\n+\n+template <typename ArrayType>\n+auto GetLogicalValue(const ArrayType& array, uint64_t index)\n+    -> decltype(array.GetView(index)) {\n+  return array.GetView(index);\n+}\n+\n+Decimal128 GetLogicalValue(const Decimal128Array& array, uint64_t index) {\n+  return Decimal128(array.Value(index));\n+}\n+\n+Decimal256 GetLogicalValue(const Decimal256Array& array, uint64_t index) {\n+  return Decimal256(array.Value(index));\n+}\n+\n+}  // namespace\n+\n+template <typename ArrayType, SortOrder order>\n+class SelectKComparator {\n+ public:\n+  template <typename Type>\n+  bool operator()(const Type& lval, const Type& rval) {\n+    if (is_floating_type<typename ArrayType::TypeClass>::value) {\n+      // NaNs ordered after non-NaNs\n+      if (rval != rval) return true;\n+      if (lval != lval) return false;\n+    }\n+    if (order == SortOrder::Ascending) {\n+      return lval <= rval;\n+    } else {\n+      return rval <= lval;\n+    }\n+  }\n+};\n+\n+template <SortOrder order>\n+Result<std::shared_ptr<Array>> SelectK(const ChunkedArray& values, int64_t k) {\n+  if (order == SortOrder::Descending) {\n+    return TopK(values, k);\n+  } else {\n+    return BottomK(values, k);\n+  }\n+}\n+\n+template <SortOrder order>\n+Result<std::shared_ptr<Array>> SelectK(const Array& values, int64_t k) {\n+  if (order == SortOrder::Descending) {\n+    return TopK(values, k);\n+  } else {\n+    return BottomK(values, k);\n+  }\n+}\n+template <typename ArrowType>\n+class TestSelectKBase : public TestBase {\n+  using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n+\n+ protected:\n+  void Validate(const ArrayType& array, int k, ArrayType& select_k, SortOrder order) {\n+    ASSERT_OK_AND_ASSIGN(auto sorted_indices, SortIndices(array, order));\n+    ASSERT_OK_AND_ASSIGN(Datum sorted_datum,\n+                         Take(array, sorted_indices, TakeOptions::NoBoundsCheck()));\n+    std::shared_ptr<Array> sorted_array_out = sorted_datum.make_array();\n+\n+    const ArrayType& sorted_array = *checked_pointer_cast<ArrayType>(sorted_array_out);\n+\n+    if (k < array.length()) {\n+      for (uint64_t i = 0; i < (uint64_t)select_k.length(); ++i) {\n+        const auto lval = GetLogicalValue(select_k, i);\n+        const auto rval = GetLogicalValue(sorted_array, i);\n+        ASSERT_TRUE(lval == rval);\n+      }\n+    }\n+  }\n+  template <SortOrder order>\n+  void AssertSelectKArray(const std::shared_ptr<Array> values, int n) {\n+    std::shared_ptr<Array> select_k;\n+    ASSERT_OK_AND_ASSIGN(select_k, SelectK<order>(*values, n));\n\nReview comment:\n       for constant parameters I prefer to use templates, hopefully sometime we will be able to use const_if \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-02T02:41:13.029+0000",
                    "updated": "2021-09-02T02:41:13.029+0000",
                    "started": "2021-09-02T02:41:13.028+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645682",
                    "issueId": "13103422"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/645686",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019#discussion_r700715908\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -156,7 +161,7 @@ struct ChunkedArrayResolver {\n   }\n \n   int64_t num_chunks_;\n-  const Array* const* chunks_;\n+  const std::vector<const Array*> chunks_;\n\nReview comment:\n       Yes there was an issue, a holder for this pointer  was needed\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-02T03:25:47.547+0000",
                    "updated": "2021-09-02T03:25:47.547+0000",
                    "started": "2021-09-02T03:25:47.547+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645686",
                    "issueId": "13103422"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/645697",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019#discussion_r700731263\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -1778,6 +1784,711 @@ class SortIndicesMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// TopK/BottomK implementations\n+\n+using SelectKOptionsState = internal::OptionsWrapper<SelectKOptions>;\n+const auto kDefaultTopKOptions = SelectKOptions::TopKDefault();\n+const auto kDefaultBottomKOptions = SelectKOptions::BottomKDefault();\n+\n+const FunctionDoc top_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n\nReview comment:\n       I though that kernel arity contains the number of required arguments for the function. This function requires at least it is required the input and k.  So arity should be binary.  \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-02T04:16:02.512+0000",
                    "updated": "2021-09-02T04:16:02.512+0000",
                    "started": "2021-09-02T04:16:02.512+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645697",
                    "issueId": "13103422"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/645731",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019#discussion_r700758909\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -1778,6 +1784,711 @@ class SortIndicesMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// TopK/BottomK implementations\n+\n+using SelectKOptionsState = internal::OptionsWrapper<SelectKOptions>;\n+const auto kDefaultTopKOptions = SelectKOptions::TopKDefault();\n+const auto kDefaultBottomKOptions = SelectKOptions::BottomKDefault();\n+\n+const FunctionDoc top_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+const FunctionDoc bottom_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+Result<std::shared_ptr<ArrayData>> MakeMutableArrayForFixedSizedType(\n+    std::shared_ptr<DataType> out_type, int64_t length, MemoryPool* memory_pool) {\n+  auto buffer_size = BitUtil::BytesForBits(\n+      length * std::static_pointer_cast<UInt64Type>(out_type)->bit_width());\n+  std::vector<std::shared_ptr<Buffer>> buffers(2);\n+  ARROW_ASSIGN_OR_RAISE(buffers[1], AllocateResizableBuffer(buffer_size, memory_pool));\n+  auto out = std::make_shared<ArrayData>(out_type, length, buffers, 0);\n+  return out;\n+}\n+\n+class ArraySelecter : public TypeVisitor {\n+ public:\n+  ArraySelecter(ExecContext* ctx, const Array& array, int64_t k, const SortOrder order,\n+                Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        array_(array),\n+        k_(k),\n+        physical_type_(GetPhysicalType(array.type())),\n+        order_(order),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return SelectKthInternal<TYPE>(); }\n+\n+  VISIT_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status SelectKthInternal() {\n+    using GetView = GetViewType<InType>;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    ArrayType arr(array_.data());\n+    std::vector<uint64_t> indices(arr.length());\n+\n+    uint64_t* indices_begin = indices.data();\n+    uint64_t* indices_end = indices_begin + indices.size();\n+    std::iota(indices_begin, indices_end, 0);\n+    if (k_ > arr.length()) {\n+      k_ = arr.length();\n+    }\n+    auto end_iter = PartitionNulls<ArrayType, NonStablePartitioner>(indices_begin,\n+                                                                    indices_end, arr, 0);\n+    auto kth_begin = indices_begin + k_;\n+    if (kth_begin > end_iter) {\n+      kth_begin = end_iter;\n+    }\n+    std::function<bool(uint64_t, uint64_t)> cmp;\n+    if (order_ == SortOrder::Ascending) {\n\nReview comment:\n       I see, I will remove these ordering checks by templates based on the SelectionOperator (topK vs bottomK).\r\n   \r\n   \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-02T05:36:08.396+0000",
                    "updated": "2021-09-02T05:36:08.396+0000",
                    "started": "2021-09-02T05:36:08.395+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645731",
                    "issueId": "13103422"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/645737",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019#discussion_r700773589\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -1778,6 +1784,711 @@ class SortIndicesMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// TopK/BottomK implementations\n+\n+using SelectKOptionsState = internal::OptionsWrapper<SelectKOptions>;\n+const auto kDefaultTopKOptions = SelectKOptions::TopKDefault();\n+const auto kDefaultBottomKOptions = SelectKOptions::BottomKDefault();\n+\n+const FunctionDoc top_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+const FunctionDoc bottom_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+Result<std::shared_ptr<ArrayData>> MakeMutableArrayForFixedSizedType(\n+    std::shared_ptr<DataType> out_type, int64_t length, MemoryPool* memory_pool) {\n+  auto buffer_size = BitUtil::BytesForBits(\n+      length * std::static_pointer_cast<UInt64Type>(out_type)->bit_width());\n+  std::vector<std::shared_ptr<Buffer>> buffers(2);\n+  ARROW_ASSIGN_OR_RAISE(buffers[1], AllocateResizableBuffer(buffer_size, memory_pool));\n+  auto out = std::make_shared<ArrayData>(out_type, length, buffers, 0);\n+  return out;\n+}\n+\n+class ArraySelecter : public TypeVisitor {\n+ public:\n+  ArraySelecter(ExecContext* ctx, const Array& array, int64_t k, const SortOrder order,\n+                Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        array_(array),\n+        k_(k),\n+        physical_type_(GetPhysicalType(array.type())),\n+        order_(order),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return SelectKthInternal<TYPE>(); }\n+\n+  VISIT_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status SelectKthInternal() {\n+    using GetView = GetViewType<InType>;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    ArrayType arr(array_.data());\n+    std::vector<uint64_t> indices(arr.length());\n+\n+    uint64_t* indices_begin = indices.data();\n+    uint64_t* indices_end = indices_begin + indices.size();\n+    std::iota(indices_begin, indices_end, 0);\n+    if (k_ > arr.length()) {\n+      k_ = arr.length();\n+    }\n+    auto end_iter = PartitionNulls<ArrayType, NonStablePartitioner>(indices_begin,\n+                                                                    indices_end, arr, 0);\n+    auto kth_begin = indices_begin + k_;\n+    if (kth_begin > end_iter) {\n+      kth_begin = end_iter;\n+    }\n+    std::function<bool(uint64_t, uint64_t)> cmp;\n+    if (order_ == SortOrder::Ascending) {\n+      cmp = [&arr](uint64_t left, uint64_t right) -> bool {\n+        const auto lval = GetView::LogicalValue(arr.GetView(left));\n+        const auto rval = GetView::LogicalValue(arr.GetView(right));\n+        return lval < rval;\n+      };\n+    } else {\n+      cmp = [&arr](uint64_t left, uint64_t right) -> bool {\n+        const auto lval = GetView::LogicalValue(arr.GetView(left));\n+        const auto rval = GetView::LogicalValue(arr.GetView(right));\n+        return rval < lval;\n+      };\n+    }\n+    arrow::internal::Heap<uint64_t, decltype(cmp)> heap(cmp);\n+    uint64_t* iter = indices_begin;\n+    for (; iter != kth_begin && heap.Size() < static_cast<size_t>(k_); ++iter) {\n\nReview comment:\n       it's not redundant for chunked_array as the  heap size will reach at somepoint the capacity k.  \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-02T06:10:26.950+0000",
                    "updated": "2021-09-02T06:10:26.950+0000",
                    "started": "2021-09-02T06:10:26.950+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645737",
                    "issueId": "13103422"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/645738",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019#discussion_r700773589\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -1778,6 +1784,711 @@ class SortIndicesMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// TopK/BottomK implementations\n+\n+using SelectKOptionsState = internal::OptionsWrapper<SelectKOptions>;\n+const auto kDefaultTopKOptions = SelectKOptions::TopKDefault();\n+const auto kDefaultBottomKOptions = SelectKOptions::BottomKDefault();\n+\n+const FunctionDoc top_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+const FunctionDoc bottom_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+Result<std::shared_ptr<ArrayData>> MakeMutableArrayForFixedSizedType(\n+    std::shared_ptr<DataType> out_type, int64_t length, MemoryPool* memory_pool) {\n+  auto buffer_size = BitUtil::BytesForBits(\n+      length * std::static_pointer_cast<UInt64Type>(out_type)->bit_width());\n+  std::vector<std::shared_ptr<Buffer>> buffers(2);\n+  ARROW_ASSIGN_OR_RAISE(buffers[1], AllocateResizableBuffer(buffer_size, memory_pool));\n+  auto out = std::make_shared<ArrayData>(out_type, length, buffers, 0);\n+  return out;\n+}\n+\n+class ArraySelecter : public TypeVisitor {\n+ public:\n+  ArraySelecter(ExecContext* ctx, const Array& array, int64_t k, const SortOrder order,\n+                Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        array_(array),\n+        k_(k),\n+        physical_type_(GetPhysicalType(array.type())),\n+        order_(order),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return SelectKthInternal<TYPE>(); }\n+\n+  VISIT_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status SelectKthInternal() {\n+    using GetView = GetViewType<InType>;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    ArrayType arr(array_.data());\n+    std::vector<uint64_t> indices(arr.length());\n+\n+    uint64_t* indices_begin = indices.data();\n+    uint64_t* indices_end = indices_begin + indices.size();\n+    std::iota(indices_begin, indices_end, 0);\n+    if (k_ > arr.length()) {\n+      k_ = arr.length();\n+    }\n+    auto end_iter = PartitionNulls<ArrayType, NonStablePartitioner>(indices_begin,\n+                                                                    indices_end, arr, 0);\n+    auto kth_begin = indices_begin + k_;\n+    if (kth_begin > end_iter) {\n+      kth_begin = end_iter;\n+    }\n+    std::function<bool(uint64_t, uint64_t)> cmp;\n+    if (order_ == SortOrder::Ascending) {\n+      cmp = [&arr](uint64_t left, uint64_t right) -> bool {\n+        const auto lval = GetView::LogicalValue(arr.GetView(left));\n+        const auto rval = GetView::LogicalValue(arr.GetView(right));\n+        return lval < rval;\n+      };\n+    } else {\n+      cmp = [&arr](uint64_t left, uint64_t right) -> bool {\n+        const auto lval = GetView::LogicalValue(arr.GetView(left));\n+        const auto rval = GetView::LogicalValue(arr.GetView(right));\n+        return rval < lval;\n+      };\n+    }\n+    arrow::internal::Heap<uint64_t, decltype(cmp)> heap(cmp);\n+    uint64_t* iter = indices_begin;\n+    for (; iter != kth_begin && heap.Size() < static_cast<size_t>(k_); ++iter) {\n\nReview comment:\n       it's not redundant for chunked_array as the  heap size will reach at somepoint the capacity k.  For other cases is redundant.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-02T06:10:40.324+0000",
                    "updated": "2021-09-02T06:10:40.324+0000",
                    "started": "2021-09-02T06:10:40.324+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645738",
                    "issueId": "13103422"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/worklog/645739",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #11019:\nURL: https://github.com/apache/arrow/pull/11019#discussion_r700775265\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -1778,6 +1784,711 @@ class SortIndicesMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// TopK/BottomK implementations\n+\n+using SelectKOptionsState = internal::OptionsWrapper<SelectKOptions>;\n+const auto kDefaultTopKOptions = SelectKOptions::TopKDefault();\n+const auto kDefaultBottomKOptions = SelectKOptions::BottomKDefault();\n+\n+const FunctionDoc top_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+const FunctionDoc bottom_k_doc(\n+    \"Return the indices that would partition an array array, record batch or table\\n\"\n+    \"around a pivot\",\n+    (\"@TODO\"), {\"input\", \"k\"}, \"PartitionNthOptions\");\n+\n+Result<std::shared_ptr<ArrayData>> MakeMutableArrayForFixedSizedType(\n+    std::shared_ptr<DataType> out_type, int64_t length, MemoryPool* memory_pool) {\n+  auto buffer_size = BitUtil::BytesForBits(\n+      length * std::static_pointer_cast<UInt64Type>(out_type)->bit_width());\n+  std::vector<std::shared_ptr<Buffer>> buffers(2);\n+  ARROW_ASSIGN_OR_RAISE(buffers[1], AllocateResizableBuffer(buffer_size, memory_pool));\n+  auto out = std::make_shared<ArrayData>(out_type, length, buffers, 0);\n+  return out;\n+}\n+\n+class ArraySelecter : public TypeVisitor {\n+ public:\n+  ArraySelecter(ExecContext* ctx, const Array& array, int64_t k, const SortOrder order,\n+                Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        array_(array),\n+        k_(k),\n+        physical_type_(GetPhysicalType(array.type())),\n+        order_(order),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return SelectKthInternal<TYPE>(); }\n+\n+  VISIT_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status SelectKthInternal() {\n+    using GetView = GetViewType<InType>;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    ArrayType arr(array_.data());\n+    std::vector<uint64_t> indices(arr.length());\n+\n+    uint64_t* indices_begin = indices.data();\n+    uint64_t* indices_end = indices_begin + indices.size();\n+    std::iota(indices_begin, indices_end, 0);\n+    if (k_ > arr.length()) {\n+      k_ = arr.length();\n+    }\n+    auto end_iter = PartitionNulls<ArrayType, NonStablePartitioner>(indices_begin,\n+                                                                    indices_end, arr, 0);\n+    auto kth_begin = indices_begin + k_;\n+    if (kth_begin > end_iter) {\n+      kth_begin = end_iter;\n+    }\n+    std::function<bool(uint64_t, uint64_t)> cmp;\n+    if (order_ == SortOrder::Ascending) {\n+      cmp = [&arr](uint64_t left, uint64_t right) -> bool {\n+        const auto lval = GetView::LogicalValue(arr.GetView(left));\n+        const auto rval = GetView::LogicalValue(arr.GetView(right));\n+        return lval < rval;\n+      };\n+    } else {\n+      cmp = [&arr](uint64_t left, uint64_t right) -> bool {\n+        const auto lval = GetView::LogicalValue(arr.GetView(left));\n+        const auto rval = GetView::LogicalValue(arr.GetView(right));\n+        return rval < lval;\n+      };\n+    }\n+    arrow::internal::Heap<uint64_t, decltype(cmp)> heap(cmp);\n+    uint64_t* iter = indices_begin;\n+    for (; iter != kth_begin && heap.Size() < static_cast<size_t>(k_); ++iter) {\n+      heap.Push(*iter);\n+    }\n+    for (; iter != end_iter && heap.Size() > 0; ++iter) {\n+      uint64_t x_index = *iter;\n+      const auto lval = GetView::LogicalValue(arr.GetView(x_index));\n+      const auto rval = GetView::LogicalValue(arr.GetView(heap.Top()));\n+      if (order_ == SortOrder::Ascending) {\n+        if (lval < rval) {\n+          heap.ReplaceTop(x_index);\n+        }\n+      } else {\n+        if (rval < lval) {\n+          heap.ReplaceTop(x_index);\n+        }\n+      }\n+    }\n+\n+    int64_t out_size = static_cast<int64_t>(heap.Size());\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto take_indices,\n+        MakeMutableArrayForFixedSizedType(uint64(), out_size, ctx_->memory_pool()));\n\nReview comment:\n       IMO it should return values to match pandas API.  \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-02T06:13:43.659+0000",
                    "updated": "2021-09-02T06:13:43.659+0000",
                    "started": "2021-09-02T06:13:43.658+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645739",
                    "issueId": "13103422"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 54000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@76ac0c7d[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3a1a38bc[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@43e23905[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@2856261d[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5c7c2386[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@518b0262[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3733347[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@1a0c8bfa[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2751eb2e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@2ec075b4[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@34338220[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4a9e9c07[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 54000,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Sep 10 14:42:41 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-09-10T14:42:41.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1565/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2017-09-19T22:29:54.000+0000",
        "updated": "2021-09-30T12:14:23.000+0000",
        "timeoriginalestimate": null,
        "description": "Heap-based topk can compute these indices in O(n log k) time",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "15h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 54000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Compute] Implement TopK/BottomK",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/comment/17039309",
                    "id": "17039309",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Another possibility is to use quickselect.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2020-02-18T18:13:16.331+0000",
                    "updated": "2020-02-18T18:13:16.331+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/comment/17116048",
                    "id": "17116048",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "I reframed this issue as a query processing task. We need to be able to compute TopK/BottomK with chunked data",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-05-25T14:06:37.649+0000",
                    "updated": "2020-05-25T14:06:37.649+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/comment/17392867",
                    "id": "17392867",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "cc [~bkietz]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-08-04T08:40:20.794+0000",
                    "updated": "2021-08-04T08:40:20.794+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/comment/17396072",
                    "id": "17396072",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Daniel Lemire compared various approaches (modifications of the heap approach or modifications of quickselect) and found that the heap wins in his tests: https://lemire.me/blog/2017/06/21/top-speed-for-top-k-queries/ \r\n\r\nIf we want this to perfectly emulate Pandas's nlargest/nsmallest then there are some additional complications (inputs must have a defined order to resolve ties, and/or we must be able to track and output duplicate values).",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-08-09T14:25:57.061+0000",
                    "updated": "2021-08-09T14:25:57.061+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103422/comment/17413223",
                    "id": "17413223",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 11019\n[https://github.com/apache/arrow/pull/11019]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-09-10T14:42:41.602+0000",
                    "updated": "2021-09-10T14:42:41.602+0000"
                }
            ],
            "maxResults": 5,
            "total": 5,
            "startAt": 0
        },
        "customfield_12311820": "0|i3k9m7:",
        "customfield_12314139": null
    }
}