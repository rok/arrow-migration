{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13100602",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100602",
    "key": "ARROW-1484",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12341352",
                "id": "12341352",
                "name": "0.8.0",
                "archived": false,
                "released": true,
                "releaseDate": "2017-12-18"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": null,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12514166",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12514166",
                "type": {
                    "id": "12310060",
                    "name": "Container",
                    "inward": "Is contained by",
                    "outward": "contains",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310060"
                },
                "inwardIssue": {
                    "id": "13100663",
                    "key": "ARROW-1492",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100663",
                    "fields": {
                        "summary": "[C++] Type casting function kernel suite",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": null,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1484/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 0,
            "worklogs": []
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": null,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@6d0d4aa4[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4f7546d2[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7d57bc7b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@187136d5[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@638a68d6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@5d3342e2[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1dc7995b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@c11c3a8[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3cedd624[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@7b0ea709[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5a22f472[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@58ac601d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": null,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Oct 26 02:07:12 UTC 2017",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2017-10-26T02:07:12.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1484/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2017-09-07T22:01:39.000+0000",
        "updated": "2017-10-26T02:07:12.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {},
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Implement (safe and unsafe) casts between timestamps and times of different units",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100602/comment/16218062",
                    "id": "16218062",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm opened a new pull request #1245: ARROW-1484: [C++/Python] Implement casts between date, time, timestamp units\nURL: https://github.com/apache/arrow/pull/1245\n \n \n   Several JIRAs here that made sense to tackle together:\r\n   \r\n   * ARROW-1680\r\n   * ARROW-1482\r\n   * ARROW-1484\r\n   * ARROW-1524\r\n   \r\n   This also fixes bugs relating to ignoring the offset in sliced arrays in some of the cast kernel implementations.\r\n   \r\n   cc @BryanCutler @xhochy @cpcloud \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-25T03:57:49.084+0000",
                    "updated": "2017-10-25T03:57:49.084+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100602/comment/16219116",
                    "id": "16219116",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1245: ARROW-1484: [C++/Python] Implement casts between date, time, timestamp units\nURL: https://github.com/apache/arrow/pull/1245#discussion_r146926826\n \n \n\n ##########\n File path: cpp/src/arrow/compute/compute-test.cc\n ##########\n @@ -270,6 +275,205 @@ TEST_F(TestCast, ToIntDowncastUnsafe) {\n                                                     options);\n }\n \n+TEST_F(TestCast, TimestampToTimestamp) {\n+  CastOptions options;\n+\n+  auto CheckTimestampCast = [this](\n+      const CastOptions& options, TimeUnit::type from_unit, TimeUnit::type to_unit,\n+      const std::vector<int64_t>& from_values, const std::vector<int64_t>& to_values,\n+      const std::vector<bool>& is_valid) {\n+    CheckCase<TimestampType, int64_t, TimestampType, int64_t>(\n+        timestamp(from_unit), from_values, is_valid, timestamp(to_unit), to_values,\n+        options);\n+  };\n+\n+  vector<bool> is_valid = {true, false, true, true, true};\n+\n+  // Multiply promotions\n+  vector<int64_t> v1 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e1 = {0, 100000, 200000, 1000, 2000};\n+  CheckTimestampCast(options, TimeUnit::SECOND, TimeUnit::MILLI, v1, e1, is_valid);\n+\n+  vector<int64_t> v2 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e2 = {0, 100000000L, 200000000L, 1000000, 2000000};\n+  CheckTimestampCast(options, TimeUnit::SECOND, TimeUnit::MICRO, v2, e2, is_valid);\n+\n+  vector<int64_t> v3 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e3 = {0, 100000000000L, 200000000000L, 1000000000L, 2000000000L};\n+  CheckTimestampCast(options, TimeUnit::SECOND, TimeUnit::NANO, v3, e3, is_valid);\n+\n+  vector<int64_t> v4 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e4 = {0, 100000, 200000, 1000, 2000};\n+  CheckTimestampCast(options, TimeUnit::MILLI, TimeUnit::MICRO, v4, e4, is_valid);\n+\n+  vector<int64_t> v5 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e5 = {0, 100000000L, 200000000L, 1000000, 2000000};\n+  CheckTimestampCast(options, TimeUnit::MILLI, TimeUnit::NANO, v5, e5, is_valid);\n+\n+  vector<int64_t> v6 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e6 = {0, 100000, 200000, 1000, 2000};\n+  CheckTimestampCast(options, TimeUnit::MICRO, TimeUnit::NANO, v6, e6, is_valid);\n+\n+  // Zero copy\n+  std::shared_ptr<Array> arr;\n+  vector<int64_t> v7 = {0, 70000, 2000, 1000, 0};\n+  ArrayFromVector<TimestampType, int64_t>(timestamp(TimeUnit::SECOND), is_valid, v7,\n+                                          &arr);\n+  CheckZeroCopy(*arr, timestamp(TimeUnit::SECOND));\n+\n+  // Divide, truncate\n+  vector<int64_t> v8 = {0, 100123, 200456, 1123, 2456};\n+  vector<int64_t> e8 = {0, 100, 200, 1, 2};\n+\n+  options.allow_time_truncate = true;\n \n Review comment:\n   Does this option need to be set in pyarrow to prevent an error when truncating?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-25T17:19:53.025+0000",
                    "updated": "2017-10-25T17:19:53.025+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100602/comment/16219123",
                    "id": "16219123",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on a change in pull request #1245: ARROW-1484: [C++/Python] Implement casts between date, time, timestamp units\nURL: https://github.com/apache/arrow/pull/1245#discussion_r146927485\n \n \n\n ##########\n File path: cpp/src/arrow/compute/compute-test.cc\n ##########\n @@ -270,6 +275,205 @@ TEST_F(TestCast, ToIntDowncastUnsafe) {\n                                                     options);\n }\n \n+TEST_F(TestCast, TimestampToTimestamp) {\n+  CastOptions options;\n+\n+  auto CheckTimestampCast = [this](\n+      const CastOptions& options, TimeUnit::type from_unit, TimeUnit::type to_unit,\n+      const std::vector<int64_t>& from_values, const std::vector<int64_t>& to_values,\n+      const std::vector<bool>& is_valid) {\n+    CheckCase<TimestampType, int64_t, TimestampType, int64_t>(\n+        timestamp(from_unit), from_values, is_valid, timestamp(to_unit), to_values,\n+        options);\n+  };\n+\n+  vector<bool> is_valid = {true, false, true, true, true};\n+\n+  // Multiply promotions\n+  vector<int64_t> v1 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e1 = {0, 100000, 200000, 1000, 2000};\n+  CheckTimestampCast(options, TimeUnit::SECOND, TimeUnit::MILLI, v1, e1, is_valid);\n+\n+  vector<int64_t> v2 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e2 = {0, 100000000L, 200000000L, 1000000, 2000000};\n+  CheckTimestampCast(options, TimeUnit::SECOND, TimeUnit::MICRO, v2, e2, is_valid);\n+\n+  vector<int64_t> v3 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e3 = {0, 100000000000L, 200000000000L, 1000000000L, 2000000000L};\n+  CheckTimestampCast(options, TimeUnit::SECOND, TimeUnit::NANO, v3, e3, is_valid);\n+\n+  vector<int64_t> v4 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e4 = {0, 100000, 200000, 1000, 2000};\n+  CheckTimestampCast(options, TimeUnit::MILLI, TimeUnit::MICRO, v4, e4, is_valid);\n+\n+  vector<int64_t> v5 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e5 = {0, 100000000L, 200000000L, 1000000, 2000000};\n+  CheckTimestampCast(options, TimeUnit::MILLI, TimeUnit::NANO, v5, e5, is_valid);\n+\n+  vector<int64_t> v6 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e6 = {0, 100000, 200000, 1000, 2000};\n+  CheckTimestampCast(options, TimeUnit::MICRO, TimeUnit::NANO, v6, e6, is_valid);\n+\n+  // Zero copy\n+  std::shared_ptr<Array> arr;\n+  vector<int64_t> v7 = {0, 70000, 2000, 1000, 0};\n+  ArrayFromVector<TimestampType, int64_t>(timestamp(TimeUnit::SECOND), is_valid, v7,\n+                                          &arr);\n+  CheckZeroCopy(*arr, timestamp(TimeUnit::SECOND));\n+\n+  // Divide, truncate\n+  vector<int64_t> v8 = {0, 100123, 200456, 1123, 2456};\n+  vector<int64_t> e8 = {0, 100, 200, 1, 2};\n+\n+  options.allow_time_truncate = true;\n \n Review comment:\n   Thanks for catching. I'll make `safe=True` set this option http://arrow.apache.org/docs/python/generated/pyarrow.lib.Array.html#pyarrow.lib.Array.cast\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-25T17:22:32.906+0000",
                    "updated": "2017-10-25T17:22:32.906+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100602/comment/16219848",
                    "id": "16219848",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm closed pull request #1245: ARROW-1484: [C++/Python] Implement casts between date, time, timestamp units\nURL: https://github.com/apache/arrow/pull/1245\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/cpp/src/arrow/compute/cast.cc b/cpp/src/arrow/compute/cast.cc\nindex e8bbfd347..68a2b1237 100644\n--- a/cpp/src/arrow/compute/cast.cc\n+++ b/cpp/src/arrow/compute/cast.cc\n@@ -25,6 +25,7 @@\n #include <sstream>\n #include <string>\n #include <type_traits>\n+#include <utility>\n \n #include \"arrow/array.h\"\n #include \"arrow/buffer.h\"\n@@ -68,6 +69,24 @@\n namespace arrow {\n namespace compute {\n \n+template <typename T>\n+inline const T* GetValuesAs(const ArrayData& data, int i) {\n+  return reinterpret_cast<const T*>(data.buffers[i]->data()) + data.offset;\n+}\n+\n+namespace {\n+\n+void CopyData(const Array& input, ArrayData* output) {\n+  auto in_data = input.data();\n+  output->length = in_data->length;\n+  output->null_count = input.null_count();\n+  output->buffers = in_data->buffers;\n+  output->offset = in_data->offset;\n+  output->child_data = in_data->child_data;\n+}\n+\n+}  // namespace\n+\n // ----------------------------------------------------------------------\n // Zero copy casts\n \n@@ -77,7 +96,9 @@ struct is_zero_copy_cast {\n };\n \n template <typename O, typename I>\n-struct is_zero_copy_cast<O, I, typename std::enable_if<std::is_same<I, O>::value>::type> {\n+struct is_zero_copy_cast<\n+    O, I, typename std::enable_if<std::is_same<I, O>::value &&\n+                                  !std::is_base_of<ParametricType, O>::value>::type> {\n   static constexpr bool value = true;\n };\n \n@@ -102,10 +123,7 @@ template <typename O, typename I>\n struct CastFunctor<O, I, typename std::enable_if<is_zero_copy_cast<O, I>::value>::type> {\n   void operator()(FunctionContext* ctx, const CastOptions& options, const Array& input,\n                   ArrayData* output) {\n-    auto in_data = input.data();\n-    output->null_count = input.null_count();\n-    output->buffers = in_data->buffers;\n-    output->child_data = in_data->child_data;\n+    CopyData(input, output);\n   }\n };\n \n@@ -119,6 +137,7 @@ struct CastFunctor<T, NullType, typename std::enable_if<\n                   ArrayData* output) {\n     // Simply initialize data to 0\n     auto buf = output->buffers[1];\n+    DCHECK_EQ(output->offset, 0);\n     memset(buf->mutable_data(), 0, buf->size());\n   }\n };\n@@ -139,12 +158,16 @@ struct CastFunctor<T, BooleanType,\n   void operator()(FunctionContext* ctx, const CastOptions& options, const Array& input,\n                   ArrayData* output) {\n     using c_type = typename T::c_type;\n-    const uint8_t* data = input.data()->buffers[1]->data();\n-    auto out = reinterpret_cast<c_type*>(output->buffers[1]->mutable_data());\n     constexpr auto kOne = static_cast<c_type>(1);\n     constexpr auto kZero = static_cast<c_type>(0);\n+\n+    auto in_data = input.data();\n+    internal::BitmapReader bit_reader(in_data->buffers[1]->data(), in_data->offset,\n+                                      in_data->length);\n+    auto out = reinterpret_cast<c_type*>(output->buffers[1]->mutable_data());\n     for (int64_t i = 0; i < input.length(); ++i) {\n-      *out++ = BitUtil::GetBit(data, i) ? kOne : kZero;\n+      *out++ = bit_reader.IsSet() ? kOne : kZero;\n+      bit_reader.Next();\n     }\n   }\n };\n@@ -189,7 +212,9 @@ struct CastFunctor<O, I, typename std::enable_if<std::is_same<BooleanType, O>::v\n   void operator()(FunctionContext* ctx, const CastOptions& options, const Array& input,\n                   ArrayData* output) {\n     using in_type = typename I::c_type;\n-    auto in_data = reinterpret_cast<const in_type*>(input.data()->buffers[1]->data());\n+    DCHECK_EQ(output->offset, 0);\n+\n+    const in_type* in_data = GetValuesAs<in_type>(*input.data(), 1);\n     uint8_t* out_data = reinterpret_cast<uint8_t*>(output->buffers[1]->mutable_data());\n     for (int64_t i = 0; i < input.length(); ++i) {\n       BitUtil::SetBitTo(out_data, i, (*in_data++) != 0);\n@@ -204,12 +229,11 @@ struct CastFunctor<O, I,\n                   ArrayData* output) {\n     using in_type = typename I::c_type;\n     using out_type = typename O::c_type;\n+    DCHECK_EQ(output->offset, 0);\n \n     auto in_offset = input.offset();\n \n-    const auto& input_buffers = input.data()->buffers;\n-\n-    auto in_data = reinterpret_cast<const in_type*>(input_buffers[1]->data()) + in_offset;\n+    const in_type* in_data = GetValuesAs<in_type>(*input.data(), 1);\n     auto out_data = reinterpret_cast<out_type*>(output->buffers[1]->mutable_data());\n \n     if (!options.allow_int_overflow) {\n@@ -217,14 +241,15 @@ struct CastFunctor<O, I,\n       constexpr in_type kMin = static_cast<in_type>(std::numeric_limits<out_type>::min());\n \n       if (input.null_count() > 0) {\n-        const uint8_t* is_valid = input_buffers[0]->data();\n-        int64_t is_valid_offset = in_offset;\n+        internal::BitmapReader is_valid_reader(input.data()->buffers[0]->data(),\n+                                               in_offset, input.length());\n         for (int64_t i = 0; i < input.length(); ++i) {\n-          if (ARROW_PREDICT_FALSE(BitUtil::GetBit(is_valid, is_valid_offset++) &&\n+          if (ARROW_PREDICT_FALSE(is_valid_reader.IsSet() &&\n                                   (*in_data > kMax || *in_data < kMin))) {\n             ctx->SetStatus(Status::Invalid(\"Integer value out of bounds\"));\n           }\n           *out_data++ = static_cast<out_type>(*in_data++);\n+          is_valid_reader.Next();\n         }\n       } else {\n         for (int64_t i = 0; i < input.length(); ++i) {\n@@ -251,7 +276,7 @@ struct CastFunctor<O, I,\n     using in_type = typename I::c_type;\n     using out_type = typename O::c_type;\n \n-    auto in_data = reinterpret_cast<const in_type*>(input.data()->buffers[1]->data());\n+    const in_type* in_data = GetValuesAs<in_type>(*input.data(), 1);\n     auto out_data = reinterpret_cast<out_type*>(output->buffers[1]->mutable_data());\n     for (int64_t i = 0; i < input.length(); ++i) {\n       *out_data++ = static_cast<out_type>(*in_data++);\n@@ -260,6 +285,125 @@ struct CastFunctor<O, I,\n };\n \n // ----------------------------------------------------------------------\n+// From one timestamp to another\n+\n+template <typename in_type, typename out_type>\n+inline void ShiftTime(FunctionContext* ctx, const CastOptions& options,\n+                      const bool is_multiply, const int64_t factor, const Array& input,\n+                      ArrayData* output) {\n+  const in_type* in_data = GetValuesAs<in_type>(*input.data(), 1);\n+  auto out_data = reinterpret_cast<out_type*>(output->buffers[1]->mutable_data());\n+\n+  if (is_multiply) {\n+    for (int64_t i = 0; i < input.length(); i++) {\n+      out_data[i] = static_cast<out_type>(in_data[i] * factor);\n+    }\n+  } else {\n+    if (options.allow_time_truncate) {\n+      for (int64_t i = 0; i < input.length(); i++) {\n+        out_data[i] = static_cast<out_type>(in_data[i] / factor);\n+      }\n+    } else {\n+      for (int64_t i = 0; i < input.length(); i++) {\n+        out_data[i] = static_cast<out_type>(in_data[i] / factor);\n+        if (input.IsValid(i) && (out_data[i] * factor != in_data[i])) {\n+          std::stringstream ss;\n+          ss << \"Casting from \" << input.type()->ToString() << \" to \"\n+             << output->type->ToString() << \" would lose data: \" << in_data[i];\n+          ctx->SetStatus(Status::Invalid(ss.str()));\n+          break;\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+namespace {\n+\n+// {is_multiply, factor}\n+const std::pair<bool, int64_t> kTimeConversionTable[4][4] = {\n+    {{true, 1}, {true, 1000}, {true, 1000000}, {true, 1000000000L}},     // SECOND\n+    {{false, 1000}, {true, 1}, {true, 1000}, {true, 1000000}},           // MILLI\n+    {{false, 1000000}, {false, 1000}, {true, 1}, {true, 1000}},          // MICRO\n+    {{false, 1000000000L}, {false, 1000000}, {false, 1000}, {true, 1}},  // NANO\n+};\n+\n+}  // namespace\n+\n+template <>\n+struct CastFunctor<TimestampType, TimestampType> {\n+  void operator()(FunctionContext* ctx, const CastOptions& options, const Array& input,\n+                  ArrayData* output) {\n+    // If units are the same, zero copy, otherwise convert\n+    const auto& in_type = static_cast<const TimestampType&>(*input.type());\n+    const auto& out_type = static_cast<const TimestampType&>(*output->type);\n+\n+    if (in_type.unit() == out_type.unit()) {\n+      CopyData(input, output);\n+      return;\n+    }\n+\n+    std::pair<bool, int64_t> conversion =\n+        kTimeConversionTable[static_cast<int>(in_type.unit())]\n+                            [static_cast<int>(out_type.unit())];\n+\n+    ShiftTime<int64_t, int64_t>(ctx, options, conversion.first, conversion.second, input,\n+                                output);\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// From one time32 or time64 to another\n+\n+template <typename O, typename I>\n+struct CastFunctor<O, I,\n+                   typename std::enable_if<std::is_base_of<TimeType, I>::value &&\n+                                           std::is_base_of<TimeType, O>::value>::type> {\n+  void operator()(FunctionContext* ctx, const CastOptions& options, const Array& input,\n+                  ArrayData* output) {\n+    using in_t = typename I::c_type;\n+    using out_t = typename O::c_type;\n+\n+    // If units are the same, zero copy, otherwise convert\n+    const auto& in_type = static_cast<const I&>(*input.type());\n+    const auto& out_type = static_cast<const O&>(*output->type);\n+\n+    if (in_type.unit() == out_type.unit()) {\n+      CopyData(input, output);\n+      return;\n+    }\n+\n+    std::pair<bool, int64_t> conversion =\n+        kTimeConversionTable[static_cast<int>(in_type.unit())]\n+                            [static_cast<int>(out_type.unit())];\n+\n+    ShiftTime<in_t, out_t>(ctx, options, conversion.first, conversion.second, input,\n+                           output);\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Between date32 and date64\n+\n+constexpr int64_t kMillisecondsInDay = 86400000;\n+\n+template <>\n+struct CastFunctor<Date64Type, Date32Type> {\n+  void operator()(FunctionContext* ctx, const CastOptions& options, const Array& input,\n+                  ArrayData* output) {\n+    ShiftTime<int32_t, int64_t>(ctx, options, true, kMillisecondsInDay, input, output);\n+  }\n+};\n+\n+template <>\n+struct CastFunctor<Date32Type, Date64Type> {\n+  void operator()(FunctionContext* ctx, const CastOptions& options, const Array& input,\n+                  ArrayData* output) {\n+    ShiftTime<int64_t, int32_t>(ctx, options, false, kMillisecondsInDay, input, output);\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n // Dictionary to other things\n \n template <typename IndexType>\n@@ -271,9 +415,8 @@ void UnpackFixedSizeBinaryDictionary(FunctionContext* ctx, const Array& indices,\n   internal::BitmapReader valid_bits_reader(indices.null_bitmap_data(), indices.offset(),\n                                            indices.length());\n \n-  const index_c_type* in =\n-      reinterpret_cast<const index_c_type*>(indices.data()->buffers[1]->data()) +\n-      indices.offset();\n+  const index_c_type* in = GetValuesAs<index_c_type>(*indices.data(), 1);\n+\n   uint8_t* out = output->buffers[1]->mutable_data();\n   int32_t byte_width =\n       static_cast<const FixedSizeBinaryType&>(*output->type).byte_width();\n@@ -336,9 +479,7 @@ Status UnpackBinaryDictionary(FunctionContext* ctx, const Array& indices,\n   internal::BitmapReader valid_bits_reader(indices.null_bitmap_data(), indices.offset(),\n                                            indices.length());\n \n-  const index_c_type* in =\n-      reinterpret_cast<const index_c_type*>(indices.data()->buffers[1]->data()) +\n-      indices.offset();\n+  const index_c_type* in = GetValuesAs<index_c_type>(*indices.data(), 1);\n   for (int64_t i = 0; i < indices.length(); ++i) {\n     if (valid_bits_reader.IsSet()) {\n       int32_t length;\n@@ -409,9 +550,7 @@ void UnpackPrimitiveDictionary(const Array& indices, const c_type* dictionary,\n   internal::BitmapReader valid_bits_reader(indices.null_bitmap_data(), indices.offset(),\n                                            indices.length());\n \n-  const index_c_type* in =\n-      reinterpret_cast<const index_c_type*>(indices.data()->buffers[1]->data()) +\n-      indices.offset();\n+  const index_c_type* in = GetValuesAs<index_c_type>(*indices.data(), 1);\n   for (int64_t i = 0; i < indices.length(); ++i) {\n     if (valid_bits_reader.IsSet()) {\n       out[i] = dictionary[in[i]];\n@@ -436,9 +575,8 @@ struct CastFunctor<T, DictionaryType,\n     DCHECK(values_type.Equals(*output->type))\n         << \"Dictionary type: \" << values_type << \" target type: \" << (*output->type);\n \n-    auto dictionary =\n-        reinterpret_cast<const c_type*>(type.dictionary()->data()->buffers[1]->data()) +\n-        type.dictionary()->offset();\n+    const c_type* dictionary = GetValuesAs<c_type>(*type.dictionary()->data(), 1);\n+\n     auto out = reinterpret_cast<c_type*>(output->buffers[1]->mutable_data());\n     const Array& indices = *dict_array.indices();\n     switch (indices.type()->id()) {\n@@ -481,6 +619,9 @@ static Status AllocateIfNotPreallocated(FunctionContext* ctx, const Array& input\n     int64_t bitmap_size = BitUtil::BytesForBits(length);\n     RETURN_NOT_OK(ctx->Allocate(bitmap_size, &validity_bitmap));\n     memset(validity_bitmap->mutable_data(), 0, bitmap_size);\n+  } else if (input.offset() != 0) {\n+    RETURN_NOT_OK(CopyBitmap(ctx->memory_pool(), validity_bitmap->data(), input.offset(),\n+                             length, &validity_bitmap));\n   }\n \n   if (out->buffers.size() == 2) {\n@@ -598,13 +739,21 @@ class CastKernel : public UnaryKernel {\n   FN(Int64Type, Time64Type);     \\\n   FN(Int64Type, Date64Type);\n \n-#define DATE32_CASES(FN, IN_TYPE) FN(Date32Type, Date32Type);\n+#define DATE32_CASES(FN, IN_TYPE) \\\n+  FN(Date32Type, Date32Type);     \\\n+  FN(Date32Type, Date64Type);\n \n-#define DATE64_CASES(FN, IN_TYPE) FN(Date64Type, Date64Type);\n+#define DATE64_CASES(FN, IN_TYPE) \\\n+  FN(Date64Type, Date64Type);     \\\n+  FN(Date64Type, Date32Type);\n \n-#define TIME32_CASES(FN, IN_TYPE) FN(Time32Type, Time32Type);\n+#define TIME32_CASES(FN, IN_TYPE) \\\n+  FN(Time32Type, Time32Type);     \\\n+  FN(Time32Type, Time64Type);\n \n-#define TIME64_CASES(FN, IN_TYPE) FN(Time64Type, Time64Type);\n+#define TIME64_CASES(FN, IN_TYPE) \\\n+  FN(Time64Type, Time32Type);     \\\n+  FN(Time64Type, Time64Type);\n \n #define TIMESTAMP_CASES(FN, IN_TYPE) FN(TimestampType, TimestampType);\n \ndiff --git a/cpp/src/arrow/compute/cast.h b/cpp/src/arrow/compute/cast.h\nindex 7a07512b2..d7bde20d6 100644\n--- a/cpp/src/arrow/compute/cast.h\n+++ b/cpp/src/arrow/compute/cast.h\n@@ -34,9 +34,10 @@ class FunctionContext;\n class UnaryKernel;\n \n struct CastOptions {\n-  CastOptions() : allow_int_overflow(false) {}\n+  CastOptions() : allow_int_overflow(false), allow_time_truncate(false) {}\n \n   bool allow_int_overflow;\n+  bool allow_time_truncate;\n };\n \n /// \\since 0.7.0\ndiff --git a/cpp/src/arrow/compute/compute-test.cc b/cpp/src/arrow/compute/compute-test.cc\nindex 8a595178d..8a7ef923b 100644\n--- a/cpp/src/arrow/compute/compute-test.cc\n+++ b/cpp/src/arrow/compute/compute-test.cc\n@@ -68,7 +68,7 @@ class TestCast : public ComputeFixture, public TestBase {\n                  const std::shared_ptr<DataType>& out_type, const CastOptions& options) {\n     std::shared_ptr<Array> result;\n     ASSERT_OK(Cast(&ctx_, input, out_type, options, &result));\n-    AssertArraysEqual(expected, *result);\n+    ASSERT_ARRAYS_EQUAL(expected, *result);\n   }\n \n   template <typename InType, typename I_TYPE>\n@@ -105,6 +105,11 @@ class TestCast : public ComputeFixture, public TestBase {\n       ArrayFromVector<OutType, O_TYPE>(out_type, out_values, &expected);\n     }\n     CheckPass(*input, *expected, out_type, options);\n+\n+    // Check a sliced variant\n+    if (input->length() > 1) {\n+      CheckPass(*input->Slice(1), *expected->Slice(1), out_type, options);\n+    }\n   }\n };\n \n@@ -270,6 +275,205 @@ TEST_F(TestCast, ToIntDowncastUnsafe) {\n                                                     options);\n }\n \n+TEST_F(TestCast, TimestampToTimestamp) {\n+  CastOptions options;\n+\n+  auto CheckTimestampCast = [this](\n+      const CastOptions& options, TimeUnit::type from_unit, TimeUnit::type to_unit,\n+      const std::vector<int64_t>& from_values, const std::vector<int64_t>& to_values,\n+      const std::vector<bool>& is_valid) {\n+    CheckCase<TimestampType, int64_t, TimestampType, int64_t>(\n+        timestamp(from_unit), from_values, is_valid, timestamp(to_unit), to_values,\n+        options);\n+  };\n+\n+  vector<bool> is_valid = {true, false, true, true, true};\n+\n+  // Multiply promotions\n+  vector<int64_t> v1 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e1 = {0, 100000, 200000, 1000, 2000};\n+  CheckTimestampCast(options, TimeUnit::SECOND, TimeUnit::MILLI, v1, e1, is_valid);\n+\n+  vector<int64_t> v2 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e2 = {0, 100000000L, 200000000L, 1000000, 2000000};\n+  CheckTimestampCast(options, TimeUnit::SECOND, TimeUnit::MICRO, v2, e2, is_valid);\n+\n+  vector<int64_t> v3 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e3 = {0, 100000000000L, 200000000000L, 1000000000L, 2000000000L};\n+  CheckTimestampCast(options, TimeUnit::SECOND, TimeUnit::NANO, v3, e3, is_valid);\n+\n+  vector<int64_t> v4 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e4 = {0, 100000, 200000, 1000, 2000};\n+  CheckTimestampCast(options, TimeUnit::MILLI, TimeUnit::MICRO, v4, e4, is_valid);\n+\n+  vector<int64_t> v5 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e5 = {0, 100000000L, 200000000L, 1000000, 2000000};\n+  CheckTimestampCast(options, TimeUnit::MILLI, TimeUnit::NANO, v5, e5, is_valid);\n+\n+  vector<int64_t> v6 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e6 = {0, 100000, 200000, 1000, 2000};\n+  CheckTimestampCast(options, TimeUnit::MICRO, TimeUnit::NANO, v6, e6, is_valid);\n+\n+  // Zero copy\n+  std::shared_ptr<Array> arr;\n+  vector<int64_t> v7 = {0, 70000, 2000, 1000, 0};\n+  ArrayFromVector<TimestampType, int64_t>(timestamp(TimeUnit::SECOND), is_valid, v7,\n+                                          &arr);\n+  CheckZeroCopy(*arr, timestamp(TimeUnit::SECOND));\n+\n+  // Divide, truncate\n+  vector<int64_t> v8 = {0, 100123, 200456, 1123, 2456};\n+  vector<int64_t> e8 = {0, 100, 200, 1, 2};\n+\n+  options.allow_time_truncate = true;\n+  CheckTimestampCast(options, TimeUnit::MILLI, TimeUnit::SECOND, v8, e8, is_valid);\n+  CheckTimestampCast(options, TimeUnit::MICRO, TimeUnit::MILLI, v8, e8, is_valid);\n+  CheckTimestampCast(options, TimeUnit::NANO, TimeUnit::MICRO, v8, e8, is_valid);\n+\n+  vector<int64_t> v9 = {0, 100123000, 200456000, 1123000, 2456000};\n+  vector<int64_t> e9 = {0, 100, 200, 1, 2};\n+  CheckTimestampCast(options, TimeUnit::MICRO, TimeUnit::SECOND, v9, e9, is_valid);\n+  CheckTimestampCast(options, TimeUnit::NANO, TimeUnit::MILLI, v9, e9, is_valid);\n+\n+  vector<int64_t> v10 = {0, 100123000000L, 200456000000L, 1123000000L, 2456000000};\n+  vector<int64_t> e10 = {0, 100, 200, 1, 2};\n+  CheckTimestampCast(options, TimeUnit::NANO, TimeUnit::SECOND, v10, e10, is_valid);\n+\n+  // Disallow truncate, failures\n+  options.allow_time_truncate = false;\n+  CheckFails<TimestampType>(timestamp(TimeUnit::MILLI), v8, is_valid,\n+                            timestamp(TimeUnit::SECOND), options);\n+  CheckFails<TimestampType>(timestamp(TimeUnit::MICRO), v8, is_valid,\n+                            timestamp(TimeUnit::MILLI), options);\n+  CheckFails<TimestampType>(timestamp(TimeUnit::NANO), v8, is_valid,\n+                            timestamp(TimeUnit::MICRO), options);\n+  CheckFails<TimestampType>(timestamp(TimeUnit::MICRO), v9, is_valid,\n+                            timestamp(TimeUnit::SECOND), options);\n+  CheckFails<TimestampType>(timestamp(TimeUnit::NANO), v9, is_valid,\n+                            timestamp(TimeUnit::MILLI), options);\n+  CheckFails<TimestampType>(timestamp(TimeUnit::NANO), v10, is_valid,\n+                            timestamp(TimeUnit::SECOND), options);\n+}\n+\n+TEST_F(TestCast, TimeToTime) {\n+  CastOptions options;\n+\n+  vector<bool> is_valid = {true, false, true, true, true};\n+\n+  // Multiply promotions\n+  vector<int32_t> v1 = {0, 100, 200, 1, 2};\n+  vector<int32_t> e1 = {0, 100000, 200000, 1000, 2000};\n+  CheckCase<Time32Type, int32_t, Time32Type, int32_t>(\n+      time32(TimeUnit::SECOND), v1, is_valid, time32(TimeUnit::MILLI), e1, options);\n+\n+  vector<int32_t> v2 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e2 = {0, 100000000L, 200000000L, 1000000, 2000000};\n+  CheckCase<Time32Type, int32_t, Time64Type, int64_t>(\n+      time32(TimeUnit::SECOND), v2, is_valid, time64(TimeUnit::MICRO), e2, options);\n+\n+  vector<int32_t> v3 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e3 = {0, 100000000000L, 200000000000L, 1000000000L, 2000000000L};\n+  CheckCase<Time32Type, int32_t, Time64Type, int64_t>(\n+      time32(TimeUnit::SECOND), v3, is_valid, time64(TimeUnit::NANO), e3, options);\n+\n+  vector<int32_t> v4 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e4 = {0, 100000, 200000, 1000, 2000};\n+  CheckCase<Time32Type, int32_t, Time64Type, int64_t>(\n+      time32(TimeUnit::MILLI), v4, is_valid, time64(TimeUnit::MICRO), e4, options);\n+\n+  vector<int32_t> v5 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e5 = {0, 100000000L, 200000000L, 1000000, 2000000};\n+  CheckCase<Time32Type, int32_t, Time64Type, int64_t>(\n+      time32(TimeUnit::MILLI), v5, is_valid, time64(TimeUnit::NANO), e5, options);\n+\n+  vector<int64_t> v6 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e6 = {0, 100000, 200000, 1000, 2000};\n+  CheckCase<Time64Type, int64_t, Time64Type, int64_t>(\n+      time64(TimeUnit::MICRO), v6, is_valid, time64(TimeUnit::NANO), e6, options);\n+\n+  // Zero copy\n+  std::shared_ptr<Array> arr;\n+  vector<int64_t> v7 = {0, 70000, 2000, 1000, 0};\n+  ArrayFromVector<Time64Type, int64_t>(time64(TimeUnit::MICRO), is_valid, v7, &arr);\n+  CheckZeroCopy(*arr, time64(TimeUnit::MICRO));\n+\n+  // Divide, truncate\n+  vector<int32_t> v8 = {0, 100123, 200456, 1123, 2456};\n+  vector<int32_t> e8 = {0, 100, 200, 1, 2};\n+\n+  options.allow_time_truncate = true;\n+  CheckCase<Time32Type, int32_t, Time32Type, int32_t>(\n+      time32(TimeUnit::MILLI), v8, is_valid, time32(TimeUnit::SECOND), e8, options);\n+  CheckCase<Time64Type, int32_t, Time32Type, int32_t>(\n+      time64(TimeUnit::MICRO), v8, is_valid, time32(TimeUnit::MILLI), e8, options);\n+  CheckCase<Time64Type, int32_t, Time64Type, int32_t>(\n+      time64(TimeUnit::NANO), v8, is_valid, time64(TimeUnit::MICRO), e8, options);\n+\n+  vector<int64_t> v9 = {0, 100123000, 200456000, 1123000, 2456000};\n+  vector<int32_t> e9 = {0, 100, 200, 1, 2};\n+  CheckCase<Time64Type, int64_t, Time32Type, int32_t>(\n+      time64(TimeUnit::MICRO), v9, is_valid, time32(TimeUnit::SECOND), e9, options);\n+  CheckCase<Time64Type, int64_t, Time32Type, int32_t>(\n+      time64(TimeUnit::NANO), v9, is_valid, time32(TimeUnit::MILLI), e9, options);\n+\n+  vector<int64_t> v10 = {0, 100123000000L, 200456000000L, 1123000000L, 2456000000};\n+  vector<int32_t> e10 = {0, 100, 200, 1, 2};\n+  CheckCase<Time64Type, int64_t, Time32Type, int32_t>(\n+      time64(TimeUnit::NANO), v10, is_valid, time32(TimeUnit::SECOND), e10, options);\n+\n+  // Disallow truncate, failures\n+\n+  options.allow_time_truncate = false;\n+  CheckFails<Time32Type>(time32(TimeUnit::MILLI), v8, is_valid, time32(TimeUnit::SECOND),\n+                         options);\n+  CheckFails<Time64Type>(time64(TimeUnit::MICRO), v8, is_valid, time32(TimeUnit::MILLI),\n+                         options);\n+  CheckFails<Time64Type>(time64(TimeUnit::NANO), v8, is_valid, time64(TimeUnit::MICRO),\n+                         options);\n+  CheckFails<Time64Type>(time64(TimeUnit::MICRO), v9, is_valid, time32(TimeUnit::SECOND),\n+                         options);\n+  CheckFails<Time64Type>(time64(TimeUnit::NANO), v9, is_valid, time32(TimeUnit::MILLI),\n+                         options);\n+  CheckFails<Time64Type>(time64(TimeUnit::NANO), v10, is_valid, time32(TimeUnit::SECOND),\n+                         options);\n+}\n+\n+TEST_F(TestCast, DateToDate) {\n+  CastOptions options;\n+\n+  vector<bool> is_valid = {true, false, true, true, true};\n+\n+  constexpr int64_t F = 86400000;\n+\n+  // Multiply promotion\n+  vector<int32_t> v1 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e1 = {0, 100 * F, 200 * F, F, 2 * F};\n+  CheckCase<Date32Type, int32_t, Date64Type, int64_t>(date32(), v1, is_valid, date64(),\n+                                                      e1, options);\n+\n+  // Zero copy\n+  std::shared_ptr<Array> arr;\n+  vector<int32_t> v2 = {0, 70000, 2000, 1000, 0};\n+  vector<int64_t> v3 = {0, 70000, 2000, 1000, 0};\n+  ArrayFromVector<Date32Type, int32_t>(date32(), is_valid, v2, &arr);\n+  CheckZeroCopy(*arr, date32());\n+\n+  ArrayFromVector<Date64Type, int64_t>(date64(), is_valid, v3, &arr);\n+  CheckZeroCopy(*arr, date64());\n+\n+  // Divide, truncate\n+  vector<int64_t> v8 = {0, 100 * F + 123, 200 * F + 456, F + 123, 2 * F + 456};\n+  vector<int32_t> e8 = {0, 100, 200, 1, 2};\n+\n+  options.allow_time_truncate = true;\n+  CheckCase<Date64Type, int64_t, Date32Type, int32_t>(date64(), v8, is_valid, date32(),\n+                                                      e8, options);\n+\n+  // Disallow truncate, failures\n+  options.allow_time_truncate = false;\n+  CheckFails<Date64Type>(date64(), v8, is_valid, date32(), options);\n+}\n+\n TEST_F(TestCast, ToDouble) {\n   CastOptions options;\n   vector<bool> is_valid = {true, false, true, true, true};\n@@ -335,7 +539,7 @@ TEST_F(TestCast, FromNull) {\n   ASSERT_EQ(length, result->null_count());\n \n   // OK to look at bitmaps\n-  AssertArraysEqual(*result, *result);\n+  ASSERT_ARRAYS_EQUAL(*result, *result);\n }\n \n TEST_F(TestCast, PreallocatedMemory) {\n@@ -373,7 +577,7 @@ TEST_F(TestCast, PreallocatedMemory) {\n   std::shared_ptr<Array> expected;\n   ArrayFromVector<Int64Type, int64_t>(int64(), is_valid, e1, &expected);\n \n-  AssertArraysEqual(*expected, *result);\n+  ASSERT_ARRAYS_EQUAL(*expected, *result);\n }\n \n template <typename TestType>\ndiff --git a/cpp/src/arrow/test-util.h b/cpp/src/arrow/test-util.h\nindex 83ebdea4a..044fb9476 100644\n--- a/cpp/src/arrow/test-util.h\n+++ b/cpp/src/arrow/test-util.h\n@@ -281,15 +281,20 @@ Status MakeArray(const std::vector<uint8_t>& valid_bytes, const std::vector<T>&\n   return builder->Finish(out);\n }\n \n-void AssertArraysEqual(const Array& expected, const Array& actual) {\n-  if (!actual.Equals(expected)) {\n-    std::stringstream pp_result;\n-    std::stringstream pp_expected;\n+#define ASSERT_ARRAYS_EQUAL(LEFT, RIGHT)                                               \\\n+  do {                                                                                 \\\n+    if (!(LEFT).Equals((RIGHT))) {                                                     \\\n+      std::stringstream pp_result;                                                     \\\n+      std::stringstream pp_expected;                                                   \\\n+                                                                                       \\\n+      EXPECT_OK(PrettyPrint(RIGHT, 0, &pp_result));                                    \\\n+      EXPECT_OK(PrettyPrint(LEFT, 0, &pp_expected));                                   \\\n+      FAIL() << \"Got: \\n\" << pp_result.str() << \"\\nExpected: \\n\" << pp_expected.str(); \\\n+    }                                                                                  \\\n+  } while (false)\n \n-    EXPECT_OK(PrettyPrint(actual, 0, &pp_result));\n-    EXPECT_OK(PrettyPrint(expected, 0, &pp_expected));\n-    FAIL() << \"Got: \\n\" << pp_result.str() << \"\\nExpected: \\n\" << pp_expected.str();\n-  }\n+void AssertArraysEqual(const Array& expected, const Array& actual) {\n+  ASSERT_ARRAYS_EQUAL(expected, actual);\n }\n \n #define ASSERT_BATCHES_EQUAL(LEFT, RIGHT)    \\\ndiff --git a/cpp/src/arrow/type.h b/cpp/src/arrow/type.h\nindex 443828423..878fdf29e 100644\n--- a/cpp/src/arrow/type.h\n+++ b/cpp/src/arrow/type.h\n@@ -228,7 +228,11 @@ class ARROW_EXPORT FloatingPoint : public Number {\n   virtual Precision precision() const = 0;\n };\n \n-class ARROW_EXPORT NestedType : public DataType {\n+/// \\class ParametricType\n+/// \\brief A superclass for types having additional metadata\n+class ParametricType {};\n+\n+class ARROW_EXPORT NestedType : public DataType, public ParametricType {\n  public:\n   using DataType::DataType;\n };\n@@ -444,7 +448,7 @@ class ARROW_EXPORT BinaryType : public DataType, public NoExtraMeta {\n };\n \n // BinaryType type is represents lists of 1-byte values.\n-class ARROW_EXPORT FixedSizeBinaryType : public FixedWidthType {\n+class ARROW_EXPORT FixedSizeBinaryType : public FixedWidthType, public ParametricType {\n  public:\n   static constexpr Type::type type_id = Type::FIXED_SIZE_BINARY;\n \n@@ -611,7 +615,7 @@ static inline std::ostream& operator<<(std::ostream& os, TimeUnit::type unit) {\n   return os;\n }\n \n-class ARROW_EXPORT TimeType : public FixedWidthType {\n+class ARROW_EXPORT TimeType : public FixedWidthType, public ParametricType {\n  public:\n   TimeUnit::type unit() const { return unit_; }\n \n@@ -650,7 +654,7 @@ class ARROW_EXPORT Time64Type : public TimeType {\n   std::string name() const override { return \"time64\"; }\n };\n \n-class ARROW_EXPORT TimestampType : public FixedWidthType {\n+class ARROW_EXPORT TimestampType : public FixedWidthType, public ParametricType {\n  public:\n   using Unit = TimeUnit;\n \ndiff --git a/python/pyarrow/array.pxi b/python/pyarrow/array.pxi\nindex c596d2ad8..72262f0c9 100644\n--- a/python/pyarrow/array.pxi\n+++ b/python/pyarrow/array.pxi\n@@ -260,8 +260,8 @@ cdef class Array:\n \n         type = _ensure_type(target_type)\n \n-        if not safe:\n-            options.allow_int_overflow = 1\n+        options.allow_int_overflow = not safe\n+        options.allow_time_truncate = not safe\n \n         with nogil:\n             check_status(Cast(_context(), self.ap[0], type.sp_type,\ndiff --git a/python/pyarrow/includes/libarrow.pxd b/python/pyarrow/includes/libarrow.pxd\nindex 0e5d4a8ed..809bb96b7 100644\n--- a/python/pyarrow/includes/libarrow.pxd\n+++ b/python/pyarrow/includes/libarrow.pxd\n@@ -747,6 +747,7 @@ cdef extern from \"arrow/compute/api.h\" namespace \"arrow::compute\" nogil:\n \n     cdef cppclass CCastOptions\" arrow::compute::CastOptions\":\n         c_bool allow_int_overflow\n+        c_bool allow_time_truncate\n \n     CStatus Cast(CFunctionContext* context, const CArray& array,\n                  const shared_ptr[CDataType]& to_type,\ndiff --git a/python/pyarrow/tests/test_array.py b/python/pyarrow/tests/test_array.py\nindex 418076f81..e3a4c9756 100644\n--- a/python/pyarrow/tests/test_array.py\n+++ b/python/pyarrow/tests/test_array.py\n@@ -290,6 +290,32 @@ def test_cast_integers_unsafe():\n         _check_cast_case(case, safe=False)\n \n \n+def test_cast_timestamp_unit():\n+    # ARROW-1680\n+    val = datetime.datetime.now()\n+    s = pd.Series([val])\n+    s_nyc = s.dt.tz_localize('tzlocal()').dt.tz_convert('America/New_York')\n+\n+    us_with_tz = pa.timestamp('us', tz='America/New_York')\n+    arr = pa.Array.from_pandas(s_nyc, type=us_with_tz)\n+\n+    arr2 = pa.Array.from_pandas(s, type=pa.timestamp('us'))\n+\n+    assert arr[0].as_py() == s_nyc[0]\n+    assert arr2[0].as_py() == s[0]\n+\n+    # Disallow truncation\n+    arr = pa.array([123123], type='int64').cast(pa.timestamp('ms'))\n+    expected = pa.array([123], type='int64').cast(pa.timestamp('s'))\n+\n+    target = pa.timestamp('s')\n+    with pytest.raises(ValueError):\n+        arr.cast(target)\n+\n+    result = arr.cast(target, safe=False)\n+    assert result.equals(expected)\n+\n+\n def test_cast_signed_to_unsigned():\n     safe_cases = [\n         (np.array([0, 1, 2, 3], dtype='i1'), pa.uint8(),\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-26T02:05:16.149+0000",
                    "updated": "2017-10-26T02:05:16.149+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100602/comment/16219851",
                    "id": "16219851",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Resolved by PR https://github.com/apache/arrow/commit/54d5c81af0a9cbc6ea551922c795728cd43bd86c",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-10-26T02:07:12.057+0000",
                    "updated": "2017-10-26T02:07:12.057+0000"
                }
            ],
            "maxResults": 5,
            "total": 5,
            "startAt": 0
        },
        "customfield_12311820": "0|i3jscf:",
        "customfield_12314139": null
    }
}