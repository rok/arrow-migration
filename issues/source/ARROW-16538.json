{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13444489",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444489",
    "key": "ARROW-16538",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351550",
                "id": "12351550",
                "name": "9.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-08-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
            "name": "Minor",
            "id": "4"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351051",
                "id": "12351051",
                "description": "",
                "name": "8.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-05-06"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12639814",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12639814",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13442660",
                    "key": "ARROW-16427",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442660",
                    "fields": {
                        "summary": "[Java] jdbcToArrowVectors / sqlToArrowVectorIterator fails to handle variable decimal precision / scale",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
                            "id": "1",
                            "description": "A problem which impairs or prevents the functions of the product.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
                            "name": "Bug",
                            "subtask": false,
                            "avatarId": 21133
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=toddfarmer",
            "name": "toddfarmer",
            "key": "JIRAUSER288796",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=39935",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=39935",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=39935",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=39935"
            },
            "displayName": "Todd Farmer",
            "active": true,
            "timeZone": "America/Boise"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328933",
                "id": "12328933",
                "name": "Java"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=toddfarmer",
            "name": "toddfarmer",
            "key": "JIRAUSER288796",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=39935",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=39935",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=39935",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=39935"
            },
            "displayName": "Todd Farmer",
            "active": true,
            "timeZone": "America/Boise"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=toddfarmer",
            "name": "toddfarmer",
            "key": "JIRAUSER288796",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=39935",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=39935",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=39935",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=39935"
            },
            "displayName": "Todd Farmer",
            "active": true,
            "timeZone": "America/Boise"
        },
        "aggregateprogress": {
            "progress": 5400,
            "total": 5400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 5400,
            "total": 5400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16538/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 9,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444489/worklog/769284",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "toddfarmer opened a new pull request, #13123:\nURL: https://github.com/apache/arrow/pull/13123\n\n   The minimum required to support existing use cases of FakeResultSet has been implemented here - every other method throws a SQLException, and support can be added in the future as specific methods of MockResultSet are referenced.\n\n\n",
                    "created": "2022-05-11T20:23:30.234+0000",
                    "updated": "2022-05-11T20:23:30.234+0000",
                    "started": "2022-05-11T20:23:30.234+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "769284",
                    "issueId": "13444489"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444489/worklog/769285",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13123:\nURL: https://github.com/apache/arrow/pull/13123#issuecomment-1124253393\n\n   https://issues.apache.org/jira/browse/ARROW-16538\n\n\n",
                    "created": "2022-05-11T20:23:48.949+0000",
                    "updated": "2022-05-11T20:23:48.949+0000",
                    "started": "2022-05-11T20:23:48.949+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "769285",
                    "issueId": "13444489"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444489/worklog/769286",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13123:\nURL: https://github.com/apache/arrow/pull/13123#issuecomment-1124253413\n\n   :warning: Ticket **has not been started in JIRA**, please click 'Start Progress'.\n\n\n",
                    "created": "2022-05-11T20:23:50.923+0000",
                    "updated": "2022-05-11T20:23:50.923+0000",
                    "started": "2022-05-11T20:23:50.922+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "769286",
                    "issueId": "13444489"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444489/worklog/769857",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #13123:\nURL: https://github.com/apache/arrow/pull/13123#discussion_r871746085\n\n\n##########\njava/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/ResultSetUtility.java:\n##########\n@@ -0,0 +1,1617 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.net.URL;\n+import java.sql.Array;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Date;\n+import java.sql.NClob;\n+import java.sql.Ref;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.RowId;\n+import java.sql.SQLException;\n+import java.sql.SQLType;\n+import java.sql.SQLWarning;\n+import java.sql.SQLXML;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Map;\n+\n+public class ResultSetUtility {\n+\n+  public static ResultSet generateEmptyResultSet() throws SQLException {\n+    MockDataElement element = new MockDataElement(\"string_example\");\n+    MockResultSetMetaData.MockColumnMetaData columnMetaData =\n+            MockResultSetMetaData.MockColumnMetaData.fromDataElement(element, 1);\n+    ArrayList<MockResultSetMetaData.MockColumnMetaData> cols = new ArrayList<>();\n+    cols.add(columnMetaData);\n+    ResultSetMetaData metadata = new MockResultSetMetaData(cols);\n+    return MockResultSet.builder()\n+            .setMetaData(metadata)\n+            .build();\n+  }\n+\n+  public static ResultSet generateBasicResultSet(int rows) throws SQLException {\n+    MockResultSet.Builder builder = MockResultSet.builder();\n+    for (int i = 0; i < rows; i++) {\n+      builder.addDataElement(\"row number: \" + (i + 1)).addDataElement(\"data\").finishRow();\n+    }\n+    return builder.build();\n+  }\n+\n+  public static class MockResultSet extends ThrowingResultSet {\n+    private final ArrayList<MockRow> rows;\n+    private int index = 0;\n+    private boolean isClosed = false;\n+    private ResultSetMetaData metadata;\n+    private boolean wasNull;\n+\n+    public MockResultSet(ArrayList<MockRow> rows) throws SQLException {\n+      this(rows, MockResultSetMetaData.fromRows(rows));\n+    }\n+\n+    public MockResultSet(ArrayList<MockRow> rows, ResultSetMetaData metadata) {\n+      this.rows = rows;\n+      this.metadata = metadata;\n+      this.wasNull = false;\n+    }\n+\n+    public static Builder builder() {\n+      return new Builder();\n+    }\n+\n+    private void throwIfClosed() throws SQLException {\n+      if (isClosed) {\n+        throw new SQLException(\"ResultSet is already closed!\");\n+      }\n+    }\n+\n+    private void setWasNull(MockDataElement element) {\n+      wasNull = element.isNull();\n+    }\n+\n+    @Override\n+    public boolean next() throws SQLException {\n+      index++;\n+      return index <= rows.size();\n+    }\n+\n+    @Override\n+    public void close() throws SQLException {\n+      throwIfClosed();\n+      isClosed = true;\n+    }\n+\n+    @Override\n+    public boolean isBeforeFirst() throws SQLException {\n+      throwIfClosed();\n+      return index == 0;\n+    }\n+\n+    @Override\n+    public boolean isAfterLast() throws SQLException {\n+      return index == rows.size();\n\nReview Comment:\n   Given this is the definition of `isLast`, should this be `index > rows.size()`?\n\n\n\n##########\njava/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/ResultSetUtility.java:\n##########\n@@ -0,0 +1,1617 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.net.URL;\n+import java.sql.Array;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Date;\n+import java.sql.NClob;\n+import java.sql.Ref;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.RowId;\n+import java.sql.SQLException;\n+import java.sql.SQLType;\n+import java.sql.SQLWarning;\n+import java.sql.SQLXML;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Map;\n+\n+public class ResultSetUtility {\n+\n+  public static ResultSet generateEmptyResultSet() throws SQLException {\n+    MockDataElement element = new MockDataElement(\"string_example\");\n+    MockResultSetMetaData.MockColumnMetaData columnMetaData =\n+            MockResultSetMetaData.MockColumnMetaData.fromDataElement(element, 1);\n+    ArrayList<MockResultSetMetaData.MockColumnMetaData> cols = new ArrayList<>();\n+    cols.add(columnMetaData);\n+    ResultSetMetaData metadata = new MockResultSetMetaData(cols);\n+    return MockResultSet.builder()\n+            .setMetaData(metadata)\n+            .build();\n+  }\n+\n+  public static ResultSet generateBasicResultSet(int rows) throws SQLException {\n+    MockResultSet.Builder builder = MockResultSet.builder();\n+    for (int i = 0; i < rows; i++) {\n+      builder.addDataElement(\"row number: \" + (i + 1)).addDataElement(\"data\").finishRow();\n+    }\n+    return builder.build();\n+  }\n+\n+  public static class MockResultSet extends ThrowingResultSet {\n+    private final ArrayList<MockRow> rows;\n+    private int index = 0;\n+    private boolean isClosed = false;\n+    private ResultSetMetaData metadata;\n+    private boolean wasNull;\n+\n+    public MockResultSet(ArrayList<MockRow> rows) throws SQLException {\n+      this(rows, MockResultSetMetaData.fromRows(rows));\n+    }\n+\n+    public MockResultSet(ArrayList<MockRow> rows, ResultSetMetaData metadata) {\n+      this.rows = rows;\n+      this.metadata = metadata;\n+      this.wasNull = false;\n+    }\n+\n+    public static Builder builder() {\n+      return new Builder();\n+    }\n+\n+    private void throwIfClosed() throws SQLException {\n+      if (isClosed) {\n+        throw new SQLException(\"ResultSet is already closed!\");\n+      }\n+    }\n+\n+    private void setWasNull(MockDataElement element) {\n+      wasNull = element.isNull();\n+    }\n+\n+    @Override\n+    public boolean next() throws SQLException {\n+      index++;\n+      return index <= rows.size();\n+    }\n+\n+    @Override\n+    public void close() throws SQLException {\n+      throwIfClosed();\n+      isClosed = true;\n+    }\n+\n+    @Override\n+    public boolean isBeforeFirst() throws SQLException {\n+      throwIfClosed();\n+      return index == 0;\n+    }\n+\n+    @Override\n+    public boolean isAfterLast() throws SQLException {\n+      return index == rows.size();\n+    }\n+\n+    @Override\n+    public boolean isFirst() throws SQLException {\n+      return index == 1;\n+    }\n+\n+    @Override\n+    public boolean isLast() throws SQLException {\n+      return index == rows.size();\n+    }\n+\n+    @Override\n+    public void beforeFirst() throws SQLException {\n+      index = 0;\n+    }\n+\n+    @Override\n+    public void afterLast() throws SQLException {\n+      index = rows.size();\n+    }\n+\n+    private MockRow getCurrentRow() throws SQLException {\n+      throwIfClosed();\n+      if (index <= rows.size()) {\n+        return rows.get(index - 1);\n+      }\n+      throw new SQLException(\"Unable to fetch row at index: \" + index);\n+    }\n+\n+    private MockDataElement getDataElementAtCol(int idx) throws SQLException {\n+      MockRow row = getCurrentRow();\n+      MockDataElement element = row.getDataElementAtIndex(idx - 1);\n+      setWasNull(element);\n+      return element;\n+    }\n+\n+    @Override\n+    public String getString(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getString();\n+    }\n+\n+    @Override\n+    public boolean getBoolean(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getBoolean();\n+    }\n+\n+    @Override\n+    public short getShort(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getShort();\n+    }\n+\n+    @Override\n+    public int getInt(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getInt();\n+    }\n+\n+    @Override\n+    public long getLong(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getLong();\n+    }\n+\n+    @Override\n+    public float getFloat(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getFloat();\n+    }\n+\n+    @Override\n+    public double getDouble(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getDouble();\n+    }\n+\n+    @Override\n+    public BigDecimal getBigDecimal(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getBigDecimal();\n+    }\n+\n+    @Override\n+    public Date getDate(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getDate();\n+    }\n+\n+    @Override\n+    public Time getTime(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getTime();\n+    }\n+\n+    @Override\n+    public Timestamp getTimestamp(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getTimestamp();\n+    }\n+\n+    @Override\n+    public ResultSetMetaData getMetaData() throws SQLException {\n+      return metadata;\n+    }\n+\n+    @Override\n+    public boolean wasNull() throws SQLException {\n+      return wasNull;\n+    }\n+\n+    public static class Builder {\n+      private final ArrayList<MockRow> rows;\n+      private ArrayList<MockDataElement> bufferedElements;\n+      private ResultSetMetaData metadata;\n+\n+      Builder() {\n+        this.rows = new ArrayList<>();\n+        this.bufferedElements = new ArrayList<>();\n+      }\n+\n+      public Builder finishRow() {\n+        rows.add(new MockRow(this.bufferedElements));\n+        this.bufferedElements = new ArrayList<>();\n+        return this;\n+      }\n+\n+      public Builder addDataElement(MockDataElement element) {\n+        this.bufferedElements.add(element);\n+        return this;\n+      }\n+\n+      public Builder addDataElement(String str) {\n+        return this.addDataElement(new MockDataElement(str));\n+      }\n+\n+      public Builder addDataElement(Object val, int sqlType) {\n+        return this.addDataElement(new MockDataElement(val, sqlType));\n+      }\n+\n+      public Builder setMetaData(ResultSetMetaData metaData) {\n+        this.metadata = metaData;\n+        return this;\n+      }\n+\n+      public MockResultSet build() throws SQLException {\n+        if (this.metadata == null) {\n+          return new MockResultSet(this.rows);\n+        }\n+        return new MockResultSet(this.rows, this.metadata);\n+      }\n+    }\n+  }\n+\n+  public static class MockResultSetMetaData extends ThrowingResultSetMetaData {\n+    private ArrayList<MockColumnMetaData> columns;\n+\n+    public MockResultSetMetaData(ArrayList<MockColumnMetaData> columns) {\n+      this.columns = columns;\n+    }\n+\n+    @Override\n+    public int getColumnCount() throws SQLException {\n+      return columns.size();\n+    }\n+\n+    @Override\n+    public String getColumnLabel(int column) throws SQLException {\n+      return columns.get(column - 1).getLabel();\n+    }\n+\n+    @Override\n+    public String getColumnName(int column) throws SQLException {\n+      return columns.get(column - 1).getName();\n+    }\n+\n+    @Override\n+    public int getColumnType(int column) throws SQLException {\n+      return columns.get(column - 1).getType();\n+    }\n+\n+    @Override\n+    public int getPrecision(int column) throws SQLException {\n+      return columns.get(column - 1).getPrecision();\n+    }\n+\n+    @Override\n+    public int getScale(int column) throws SQLException {\n+      return columns.get(column - 1).getScale();\n+    }\n+\n+    @Override\n+    public int isNullable(int column) throws SQLException {\n+      return columns.get(column - 1).isNullable();\n+    }\n+\n+    public static MockResultSetMetaData fromRows(ArrayList<MockRow> rows) throws SQLException {\n+\n+      if (rows.size() == 0) {\n+        throw new SQLException(\"Unable to dynamically generate ResultSetMetaData because row count is zero!\");\n+      }\n+      MockRow firstRow = rows.get(0);\n+      if (firstRow.dataElements.size() == 0) {\n+        throw new SQLException(\"Unable to dynamically generate ResultSetMetaData because column count is zero!\");\n+      }\n+      ArrayList<MockColumnMetaData> columns = new ArrayList<>();\n+      for (int i = 0; i < firstRow.dataElements.size(); i++) {\n+        MockDataElement element = firstRow.getDataElementAtIndex(i);\n+        columns.add(MockColumnMetaData.fromDataElement(element, i));\n+      }\n+      return new MockResultSetMetaData(columns);\n+    }\n+\n+    public static class MockColumnMetaData {\n+      private int index;\n+      private int sqlType;\n+      private int precision;\n+      private int scale;\n+      private int nullable;\n+\n+      private MockColumnMetaData(int i, MockDataElement element) throws SQLException {\n+        this.index = i;\n+        this.sqlType = element.sqlType;\n+        this.precision = element.getPrecision();\n+        this.scale = element.getScale();\n+        this.nullable = element.isNullable();\n+      }\n+\n+      private String getLabel() {\n+        return \"col_\" + index;\n+      }\n+\n+      private String getName() {\n+        return getLabel();\n+      }\n+\n+      private int getType() {\n+        return sqlType;\n+      }\n+\n+      private int getPrecision() {\n+        return precision;\n+      }\n+\n+      private int getScale() {\n+        return scale;\n+      }\n+\n+      private int isNullable() {\n+        return nullable;\n+      }\n+\n+      static MockColumnMetaData fromDataElement(MockDataElement element, int i) throws SQLException {\n+        return new MockColumnMetaData(i, element);\n+      }\n+\n+    }\n+\n+  }\n+\n+  public static class MockRow {\n+    private final ArrayList<MockDataElement> dataElements;\n+\n+    public MockRow(ArrayList<MockDataElement> elements) {\n+      this.dataElements = elements;\n+    }\n+\n+    public MockDataElement getDataElementAtIndex(int idx) throws SQLException {\n+      if (idx > dataElements.size()) {\n+        throw new SQLException(\"Unable to find data element at position: \" + idx);\n+      }\n+      return dataElements.get(idx);\n+    }\n+  }\n+\n+  public static class MockDataElement {\n+    private final Object value;\n+    private final int sqlType;\n+\n+    public MockDataElement(String val) {\n+      this(val, Types.VARCHAR);\n+    }\n+\n+    public MockDataElement(Object val, int sqlType) {\n+      this.value = val;\n+      this.sqlType = sqlType;\n+    }\n+\n+    private boolean isNull() {\n+      return value == null;\n+    }\n+\n+    private String getValueAsString() {\n+      return value.toString();\n+    }\n+\n+    private int getPrecision() throws SQLException {\n+      if (this.sqlType == Types.VARCHAR) {\n+        return getValueAsString().length();\n+      }\n+      throw getExceptionToThrow(\"Unable to determine precision for data type!\");\n+    }\n+\n+    private int getScale() throws SQLException {\n+      if (this.sqlType == Types.VARCHAR) {\n+        return 0;\n+      }\n+      throw getExceptionToThrow(\"Unable to determine precision for data type!\");\n\nReview Comment:\n   ```suggestion\r\n         throw getExceptionToThrow(\"Unable to determine scale for data type!\");\r\n   ```\n\n\n\n##########\njava/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/ResultSetUtility.java:\n##########\n@@ -0,0 +1,1617 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.net.URL;\n+import java.sql.Array;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Date;\n+import java.sql.NClob;\n+import java.sql.Ref;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.RowId;\n+import java.sql.SQLException;\n+import java.sql.SQLType;\n+import java.sql.SQLWarning;\n+import java.sql.SQLXML;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Map;\n+\n+public class ResultSetUtility {\n+\n+  public static ResultSet generateEmptyResultSet() throws SQLException {\n+    MockDataElement element = new MockDataElement(\"string_example\");\n+    MockResultSetMetaData.MockColumnMetaData columnMetaData =\n+            MockResultSetMetaData.MockColumnMetaData.fromDataElement(element, 1);\n+    ArrayList<MockResultSetMetaData.MockColumnMetaData> cols = new ArrayList<>();\n+    cols.add(columnMetaData);\n+    ResultSetMetaData metadata = new MockResultSetMetaData(cols);\n+    return MockResultSet.builder()\n+            .setMetaData(metadata)\n+            .build();\n+  }\n+\n+  public static ResultSet generateBasicResultSet(int rows) throws SQLException {\n+    MockResultSet.Builder builder = MockResultSet.builder();\n+    for (int i = 0; i < rows; i++) {\n+      builder.addDataElement(\"row number: \" + (i + 1)).addDataElement(\"data\").finishRow();\n+    }\n+    return builder.build();\n+  }\n+\n+  public static class MockResultSet extends ThrowingResultSet {\n+    private final ArrayList<MockRow> rows;\n+    private int index = 0;\n+    private boolean isClosed = false;\n+    private ResultSetMetaData metadata;\n+    private boolean wasNull;\n+\n+    public MockResultSet(ArrayList<MockRow> rows) throws SQLException {\n+      this(rows, MockResultSetMetaData.fromRows(rows));\n+    }\n+\n+    public MockResultSet(ArrayList<MockRow> rows, ResultSetMetaData metadata) {\n+      this.rows = rows;\n+      this.metadata = metadata;\n+      this.wasNull = false;\n+    }\n+\n+    public static Builder builder() {\n+      return new Builder();\n+    }\n+\n+    private void throwIfClosed() throws SQLException {\n+      if (isClosed) {\n+        throw new SQLException(\"ResultSet is already closed!\");\n+      }\n+    }\n+\n+    private void setWasNull(MockDataElement element) {\n+      wasNull = element.isNull();\n+    }\n+\n+    @Override\n+    public boolean next() throws SQLException {\n+      index++;\n+      return index <= rows.size();\n+    }\n+\n+    @Override\n+    public void close() throws SQLException {\n+      throwIfClosed();\n+      isClosed = true;\n+    }\n+\n+    @Override\n+    public boolean isBeforeFirst() throws SQLException {\n+      throwIfClosed();\n+      return index == 0;\n+    }\n+\n+    @Override\n+    public boolean isAfterLast() throws SQLException {\n+      return index == rows.size();\n+    }\n+\n+    @Override\n+    public boolean isFirst() throws SQLException {\n+      return index == 1;\n+    }\n+\n+    @Override\n+    public boolean isLast() throws SQLException {\n+      return index == rows.size();\n+    }\n+\n+    @Override\n+    public void beforeFirst() throws SQLException {\n+      index = 0;\n+    }\n+\n+    @Override\n+    public void afterLast() throws SQLException {\n+      index = rows.size();\n+    }\n+\n+    private MockRow getCurrentRow() throws SQLException {\n+      throwIfClosed();\n+      if (index <= rows.size()) {\n+        return rows.get(index - 1);\n+      }\n+      throw new SQLException(\"Unable to fetch row at index: \" + index);\n+    }\n+\n+    private MockDataElement getDataElementAtCol(int idx) throws SQLException {\n+      MockRow row = getCurrentRow();\n+      MockDataElement element = row.getDataElementAtIndex(idx - 1);\n+      setWasNull(element);\n+      return element;\n+    }\n+\n+    @Override\n+    public String getString(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getString();\n+    }\n+\n+    @Override\n+    public boolean getBoolean(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getBoolean();\n+    }\n+\n+    @Override\n+    public short getShort(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getShort();\n+    }\n+\n+    @Override\n+    public int getInt(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getInt();\n+    }\n+\n+    @Override\n+    public long getLong(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getLong();\n+    }\n+\n+    @Override\n+    public float getFloat(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getFloat();\n+    }\n+\n+    @Override\n+    public double getDouble(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getDouble();\n+    }\n+\n+    @Override\n+    public BigDecimal getBigDecimal(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getBigDecimal();\n+    }\n+\n+    @Override\n+    public Date getDate(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getDate();\n+    }\n+\n+    @Override\n+    public Time getTime(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getTime();\n+    }\n+\n+    @Override\n+    public Timestamp getTimestamp(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getTimestamp();\n+    }\n+\n+    @Override\n+    public ResultSetMetaData getMetaData() throws SQLException {\n+      return metadata;\n+    }\n+\n+    @Override\n+    public boolean wasNull() throws SQLException {\n+      return wasNull;\n+    }\n+\n+    public static class Builder {\n+      private final ArrayList<MockRow> rows;\n+      private ArrayList<MockDataElement> bufferedElements;\n+      private ResultSetMetaData metadata;\n+\n+      Builder() {\n+        this.rows = new ArrayList<>();\n+        this.bufferedElements = new ArrayList<>();\n+      }\n+\n+      public Builder finishRow() {\n+        rows.add(new MockRow(this.bufferedElements));\n+        this.bufferedElements = new ArrayList<>();\n+        return this;\n+      }\n+\n+      public Builder addDataElement(MockDataElement element) {\n+        this.bufferedElements.add(element);\n+        return this;\n+      }\n+\n+      public Builder addDataElement(String str) {\n+        return this.addDataElement(new MockDataElement(str));\n+      }\n+\n+      public Builder addDataElement(Object val, int sqlType) {\n+        return this.addDataElement(new MockDataElement(val, sqlType));\n+      }\n+\n+      public Builder setMetaData(ResultSetMetaData metaData) {\n+        this.metadata = metaData;\n+        return this;\n+      }\n+\n+      public MockResultSet build() throws SQLException {\n+        if (this.metadata == null) {\n+          return new MockResultSet(this.rows);\n+        }\n+        return new MockResultSet(this.rows, this.metadata);\n+      }\n+    }\n+  }\n+\n+  public static class MockResultSetMetaData extends ThrowingResultSetMetaData {\n+    private ArrayList<MockColumnMetaData> columns;\n+\n+    public MockResultSetMetaData(ArrayList<MockColumnMetaData> columns) {\n+      this.columns = columns;\n+    }\n+\n+    @Override\n+    public int getColumnCount() throws SQLException {\n+      return columns.size();\n+    }\n+\n+    @Override\n+    public String getColumnLabel(int column) throws SQLException {\n+      return columns.get(column - 1).getLabel();\n+    }\n+\n+    @Override\n+    public String getColumnName(int column) throws SQLException {\n+      return columns.get(column - 1).getName();\n+    }\n+\n+    @Override\n+    public int getColumnType(int column) throws SQLException {\n+      return columns.get(column - 1).getType();\n+    }\n+\n+    @Override\n+    public int getPrecision(int column) throws SQLException {\n+      return columns.get(column - 1).getPrecision();\n+    }\n+\n+    @Override\n+    public int getScale(int column) throws SQLException {\n+      return columns.get(column - 1).getScale();\n+    }\n+\n+    @Override\n+    public int isNullable(int column) throws SQLException {\n+      return columns.get(column - 1).isNullable();\n+    }\n+\n+    public static MockResultSetMetaData fromRows(ArrayList<MockRow> rows) throws SQLException {\n+\n+      if (rows.size() == 0) {\n+        throw new SQLException(\"Unable to dynamically generate ResultSetMetaData because row count is zero!\");\n+      }\n+      MockRow firstRow = rows.get(0);\n+      if (firstRow.dataElements.size() == 0) {\n+        throw new SQLException(\"Unable to dynamically generate ResultSetMetaData because column count is zero!\");\n\nReview Comment:\n   Is it not valid to have a zero-column dataset?\n\n\n\n##########\njava/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/ResultSetUtility.java:\n##########\n@@ -0,0 +1,1617 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.net.URL;\n+import java.sql.Array;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Date;\n+import java.sql.NClob;\n+import java.sql.Ref;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.RowId;\n+import java.sql.SQLException;\n+import java.sql.SQLType;\n+import java.sql.SQLWarning;\n+import java.sql.SQLXML;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Map;\n+\n+public class ResultSetUtility {\n+\n+  public static ResultSet generateEmptyResultSet() throws SQLException {\n+    MockDataElement element = new MockDataElement(\"string_example\");\n+    MockResultSetMetaData.MockColumnMetaData columnMetaData =\n+            MockResultSetMetaData.MockColumnMetaData.fromDataElement(element, 1);\n+    ArrayList<MockResultSetMetaData.MockColumnMetaData> cols = new ArrayList<>();\n+    cols.add(columnMetaData);\n+    ResultSetMetaData metadata = new MockResultSetMetaData(cols);\n+    return MockResultSet.builder()\n+            .setMetaData(metadata)\n+            .build();\n+  }\n+\n+  public static ResultSet generateBasicResultSet(int rows) throws SQLException {\n+    MockResultSet.Builder builder = MockResultSet.builder();\n+    for (int i = 0; i < rows; i++) {\n+      builder.addDataElement(\"row number: \" + (i + 1)).addDataElement(\"data\").finishRow();\n+    }\n+    return builder.build();\n+  }\n+\n+  public static class MockResultSet extends ThrowingResultSet {\n+    private final ArrayList<MockRow> rows;\n+    private int index = 0;\n+    private boolean isClosed = false;\n+    private ResultSetMetaData metadata;\n+    private boolean wasNull;\n+\n+    public MockResultSet(ArrayList<MockRow> rows) throws SQLException {\n+      this(rows, MockResultSetMetaData.fromRows(rows));\n+    }\n+\n+    public MockResultSet(ArrayList<MockRow> rows, ResultSetMetaData metadata) {\n+      this.rows = rows;\n+      this.metadata = metadata;\n+      this.wasNull = false;\n+    }\n+\n+    public static Builder builder() {\n+      return new Builder();\n+    }\n+\n+    private void throwIfClosed() throws SQLException {\n+      if (isClosed) {\n+        throw new SQLException(\"ResultSet is already closed!\");\n+      }\n+    }\n+\n+    private void setWasNull(MockDataElement element) {\n+      wasNull = element.isNull();\n+    }\n+\n+    @Override\n+    public boolean next() throws SQLException {\n+      index++;\n+      return index <= rows.size();\n+    }\n+\n+    @Override\n+    public void close() throws SQLException {\n+      throwIfClosed();\n+      isClosed = true;\n+    }\n+\n+    @Override\n+    public boolean isBeforeFirst() throws SQLException {\n+      throwIfClosed();\n+      return index == 0;\n+    }\n+\n+    @Override\n+    public boolean isAfterLast() throws SQLException {\n+      return index == rows.size();\n+    }\n+\n+    @Override\n+    public boolean isFirst() throws SQLException {\n+      return index == 1;\n+    }\n+\n+    @Override\n+    public boolean isLast() throws SQLException {\n+      return index == rows.size();\n+    }\n+\n+    @Override\n+    public void beforeFirst() throws SQLException {\n+      index = 0;\n+    }\n+\n+    @Override\n+    public void afterLast() throws SQLException {\n+      index = rows.size();\n+    }\n+\n+    private MockRow getCurrentRow() throws SQLException {\n+      throwIfClosed();\n+      if (index <= rows.size()) {\n+        return rows.get(index - 1);\n+      }\n+      throw new SQLException(\"Unable to fetch row at index: \" + index);\n+    }\n+\n+    private MockDataElement getDataElementAtCol(int idx) throws SQLException {\n+      MockRow row = getCurrentRow();\n+      MockDataElement element = row.getDataElementAtIndex(idx - 1);\n+      setWasNull(element);\n+      return element;\n+    }\n+\n+    @Override\n+    public String getString(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getString();\n+    }\n+\n+    @Override\n+    public boolean getBoolean(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getBoolean();\n+    }\n+\n+    @Override\n+    public short getShort(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getShort();\n+    }\n+\n+    @Override\n+    public int getInt(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getInt();\n+    }\n+\n+    @Override\n+    public long getLong(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getLong();\n+    }\n+\n+    @Override\n+    public float getFloat(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getFloat();\n+    }\n+\n+    @Override\n+    public double getDouble(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getDouble();\n+    }\n+\n+    @Override\n+    public BigDecimal getBigDecimal(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getBigDecimal();\n+    }\n+\n+    @Override\n+    public Date getDate(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getDate();\n+    }\n+\n+    @Override\n+    public Time getTime(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getTime();\n+    }\n+\n+    @Override\n+    public Timestamp getTimestamp(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getTimestamp();\n+    }\n+\n+    @Override\n+    public ResultSetMetaData getMetaData() throws SQLException {\n+      return metadata;\n+    }\n+\n+    @Override\n+    public boolean wasNull() throws SQLException {\n+      return wasNull;\n+    }\n+\n+    public static class Builder {\n+      private final ArrayList<MockRow> rows;\n+      private ArrayList<MockDataElement> bufferedElements;\n+      private ResultSetMetaData metadata;\n+\n+      Builder() {\n+        this.rows = new ArrayList<>();\n+        this.bufferedElements = new ArrayList<>();\n+      }\n+\n+      public Builder finishRow() {\n+        rows.add(new MockRow(this.bufferedElements));\n+        this.bufferedElements = new ArrayList<>();\n+        return this;\n+      }\n+\n+      public Builder addDataElement(MockDataElement element) {\n+        this.bufferedElements.add(element);\n+        return this;\n+      }\n+\n+      public Builder addDataElement(String str) {\n+        return this.addDataElement(new MockDataElement(str));\n+      }\n+\n+      public Builder addDataElement(Object val, int sqlType) {\n+        return this.addDataElement(new MockDataElement(val, sqlType));\n+      }\n+\n+      public Builder setMetaData(ResultSetMetaData metaData) {\n+        this.metadata = metaData;\n+        return this;\n+      }\n+\n+      public MockResultSet build() throws SQLException {\n+        if (this.metadata == null) {\n+          return new MockResultSet(this.rows);\n+        }\n+        return new MockResultSet(this.rows, this.metadata);\n+      }\n+    }\n+  }\n+\n+  public static class MockResultSetMetaData extends ThrowingResultSetMetaData {\n+    private ArrayList<MockColumnMetaData> columns;\n+\n+    public MockResultSetMetaData(ArrayList<MockColumnMetaData> columns) {\n+      this.columns = columns;\n+    }\n+\n+    @Override\n+    public int getColumnCount() throws SQLException {\n+      return columns.size();\n+    }\n+\n+    @Override\n+    public String getColumnLabel(int column) throws SQLException {\n+      return columns.get(column - 1).getLabel();\n+    }\n+\n+    @Override\n+    public String getColumnName(int column) throws SQLException {\n+      return columns.get(column - 1).getName();\n+    }\n+\n+    @Override\n+    public int getColumnType(int column) throws SQLException {\n+      return columns.get(column - 1).getType();\n+    }\n+\n+    @Override\n+    public int getPrecision(int column) throws SQLException {\n+      return columns.get(column - 1).getPrecision();\n+    }\n+\n+    @Override\n+    public int getScale(int column) throws SQLException {\n+      return columns.get(column - 1).getScale();\n+    }\n+\n+    @Override\n+    public int isNullable(int column) throws SQLException {\n+      return columns.get(column - 1).isNullable();\n+    }\n+\n+    public static MockResultSetMetaData fromRows(ArrayList<MockRow> rows) throws SQLException {\n+\n+      if (rows.size() == 0) {\n+        throw new SQLException(\"Unable to dynamically generate ResultSetMetaData because row count is zero!\");\n+      }\n+      MockRow firstRow = rows.get(0);\n+      if (firstRow.dataElements.size() == 0) {\n+        throw new SQLException(\"Unable to dynamically generate ResultSetMetaData because column count is zero!\");\n+      }\n+      ArrayList<MockColumnMetaData> columns = new ArrayList<>();\n+      for (int i = 0; i < firstRow.dataElements.size(); i++) {\n+        MockDataElement element = firstRow.getDataElementAtIndex(i);\n+        columns.add(MockColumnMetaData.fromDataElement(element, i));\n+      }\n+      return new MockResultSetMetaData(columns);\n+    }\n+\n+    public static class MockColumnMetaData {\n+      private int index;\n+      private int sqlType;\n+      private int precision;\n+      private int scale;\n+      private int nullable;\n+\n+      private MockColumnMetaData(int i, MockDataElement element) throws SQLException {\n+        this.index = i;\n+        this.sqlType = element.sqlType;\n+        this.precision = element.getPrecision();\n+        this.scale = element.getScale();\n+        this.nullable = element.isNullable();\n+      }\n+\n+      private String getLabel() {\n+        return \"col_\" + index;\n+      }\n+\n+      private String getName() {\n+        return getLabel();\n+      }\n+\n+      private int getType() {\n+        return sqlType;\n+      }\n+\n+      private int getPrecision() {\n+        return precision;\n+      }\n+\n+      private int getScale() {\n+        return scale;\n+      }\n+\n+      private int isNullable() {\n+        return nullable;\n+      }\n+\n+      static MockColumnMetaData fromDataElement(MockDataElement element, int i) throws SQLException {\n+        return new MockColumnMetaData(i, element);\n+      }\n+\n+    }\n+\n+  }\n+\n+  public static class MockRow {\n+    private final ArrayList<MockDataElement> dataElements;\n+\n+    public MockRow(ArrayList<MockDataElement> elements) {\n+      this.dataElements = elements;\n+    }\n+\n+    public MockDataElement getDataElementAtIndex(int idx) throws SQLException {\n+      if (idx > dataElements.size()) {\n+        throw new SQLException(\"Unable to find data element at position: \" + idx);\n+      }\n+      return dataElements.get(idx);\n+    }\n+  }\n+\n+  public static class MockDataElement {\n+    private final Object value;\n+    private final int sqlType;\n+\n+    public MockDataElement(String val) {\n+      this(val, Types.VARCHAR);\n+    }\n+\n+    public MockDataElement(Object val, int sqlType) {\n+      this.value = val;\n+      this.sqlType = sqlType;\n+    }\n+\n+    private boolean isNull() {\n+      return value == null;\n+    }\n+\n+    private String getValueAsString() {\n+      return value.toString();\n+    }\n+\n+    private int getPrecision() throws SQLException {\n+      if (this.sqlType == Types.VARCHAR) {\n+        return getValueAsString().length();\n+      }\n+      throw getExceptionToThrow(\"Unable to determine precision for data type!\");\n+    }\n+\n+    private int getScale() throws SQLException {\n+      if (this.sqlType == Types.VARCHAR) {\n+        return 0;\n+      }\n+      throw getExceptionToThrow(\"Unable to determine precision for data type!\");\n+    }\n+\n+    private int isNullable() throws SQLException {\n+      if (this.sqlType == Types.VARCHAR) {\n+        return ResultSetMetaData.columnNullable;\n+      }\n+      throw getExceptionToThrow(\"Unable to determine precision for data type!\");\n\nReview Comment:\n   Should this be `columnNullableUnknown`?\n\n\n\n##########\njava/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/ResultSetUtility.java:\n##########\n@@ -0,0 +1,1617 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.net.URL;\n+import java.sql.Array;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Date;\n+import java.sql.NClob;\n+import java.sql.Ref;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.RowId;\n+import java.sql.SQLException;\n+import java.sql.SQLType;\n+import java.sql.SQLWarning;\n+import java.sql.SQLXML;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Map;\n+\n+public class ResultSetUtility {\n+\n+  public static ResultSet generateEmptyResultSet() throws SQLException {\n+    MockDataElement element = new MockDataElement(\"string_example\");\n+    MockResultSetMetaData.MockColumnMetaData columnMetaData =\n+            MockResultSetMetaData.MockColumnMetaData.fromDataElement(element, 1);\n+    ArrayList<MockResultSetMetaData.MockColumnMetaData> cols = new ArrayList<>();\n+    cols.add(columnMetaData);\n+    ResultSetMetaData metadata = new MockResultSetMetaData(cols);\n+    return MockResultSet.builder()\n+            .setMetaData(metadata)\n+            .build();\n+  }\n+\n+  public static ResultSet generateBasicResultSet(int rows) throws SQLException {\n+    MockResultSet.Builder builder = MockResultSet.builder();\n+    for (int i = 0; i < rows; i++) {\n+      builder.addDataElement(\"row number: \" + (i + 1)).addDataElement(\"data\").finishRow();\n+    }\n+    return builder.build();\n+  }\n+\n+  public static class MockResultSet extends ThrowingResultSet {\n+    private final ArrayList<MockRow> rows;\n+    private int index = 0;\n+    private boolean isClosed = false;\n+    private ResultSetMetaData metadata;\n+    private boolean wasNull;\n+\n+    public MockResultSet(ArrayList<MockRow> rows) throws SQLException {\n+      this(rows, MockResultSetMetaData.fromRows(rows));\n+    }\n+\n+    public MockResultSet(ArrayList<MockRow> rows, ResultSetMetaData metadata) {\n+      this.rows = rows;\n+      this.metadata = metadata;\n+      this.wasNull = false;\n+    }\n+\n+    public static Builder builder() {\n+      return new Builder();\n+    }\n+\n+    private void throwIfClosed() throws SQLException {\n+      if (isClosed) {\n+        throw new SQLException(\"ResultSet is already closed!\");\n+      }\n+    }\n+\n+    private void setWasNull(MockDataElement element) {\n+      wasNull = element.isNull();\n+    }\n+\n+    @Override\n+    public boolean next() throws SQLException {\n+      index++;\n+      return index <= rows.size();\n+    }\n+\n+    @Override\n+    public void close() throws SQLException {\n+      throwIfClosed();\n+      isClosed = true;\n+    }\n+\n+    @Override\n+    public boolean isBeforeFirst() throws SQLException {\n+      throwIfClosed();\n+      return index == 0;\n+    }\n+\n+    @Override\n+    public boolean isAfterLast() throws SQLException {\n+      return index == rows.size();\n+    }\n+\n+    @Override\n+    public boolean isFirst() throws SQLException {\n+      return index == 1;\n+    }\n+\n+    @Override\n+    public boolean isLast() throws SQLException {\n+      return index == rows.size();\n+    }\n+\n+    @Override\n+    public void beforeFirst() throws SQLException {\n+      index = 0;\n+    }\n+\n+    @Override\n+    public void afterLast() throws SQLException {\n+      index = rows.size();\n+    }\n+\n+    private MockRow getCurrentRow() throws SQLException {\n+      throwIfClosed();\n+      if (index <= rows.size()) {\n+        return rows.get(index - 1);\n+      }\n+      throw new SQLException(\"Unable to fetch row at index: \" + index);\n+    }\n+\n+    private MockDataElement getDataElementAtCol(int idx) throws SQLException {\n+      MockRow row = getCurrentRow();\n+      MockDataElement element = row.getDataElementAtIndex(idx - 1);\n+      setWasNull(element);\n+      return element;\n+    }\n+\n+    @Override\n+    public String getString(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getString();\n+    }\n+\n+    @Override\n+    public boolean getBoolean(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getBoolean();\n+    }\n+\n+    @Override\n+    public short getShort(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getShort();\n+    }\n+\n+    @Override\n+    public int getInt(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getInt();\n+    }\n+\n+    @Override\n+    public long getLong(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getLong();\n+    }\n+\n+    @Override\n+    public float getFloat(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getFloat();\n+    }\n+\n+    @Override\n+    public double getDouble(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getDouble();\n+    }\n+\n+    @Override\n+    public BigDecimal getBigDecimal(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getBigDecimal();\n+    }\n+\n+    @Override\n+    public Date getDate(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getDate();\n+    }\n+\n+    @Override\n+    public Time getTime(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getTime();\n+    }\n+\n+    @Override\n+    public Timestamp getTimestamp(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getTimestamp();\n+    }\n+\n+    @Override\n+    public ResultSetMetaData getMetaData() throws SQLException {\n+      return metadata;\n+    }\n+\n+    @Override\n+    public boolean wasNull() throws SQLException {\n+      return wasNull;\n+    }\n+\n+    public static class Builder {\n+      private final ArrayList<MockRow> rows;\n+      private ArrayList<MockDataElement> bufferedElements;\n+      private ResultSetMetaData metadata;\n+\n+      Builder() {\n+        this.rows = new ArrayList<>();\n+        this.bufferedElements = new ArrayList<>();\n+      }\n+\n+      public Builder finishRow() {\n+        rows.add(new MockRow(this.bufferedElements));\n+        this.bufferedElements = new ArrayList<>();\n+        return this;\n+      }\n+\n+      public Builder addDataElement(MockDataElement element) {\n+        this.bufferedElements.add(element);\n+        return this;\n+      }\n+\n+      public Builder addDataElement(String str) {\n+        return this.addDataElement(new MockDataElement(str));\n+      }\n+\n+      public Builder addDataElement(Object val, int sqlType) {\n+        return this.addDataElement(new MockDataElement(val, sqlType));\n+      }\n+\n+      public Builder setMetaData(ResultSetMetaData metaData) {\n+        this.metadata = metaData;\n+        return this;\n+      }\n+\n+      public MockResultSet build() throws SQLException {\n+        if (this.metadata == null) {\n+          return new MockResultSet(this.rows);\n+        }\n+        return new MockResultSet(this.rows, this.metadata);\n+      }\n+    }\n+  }\n+\n+  public static class MockResultSetMetaData extends ThrowingResultSetMetaData {\n+    private ArrayList<MockColumnMetaData> columns;\n+\n+    public MockResultSetMetaData(ArrayList<MockColumnMetaData> columns) {\n+      this.columns = columns;\n+    }\n+\n+    @Override\n+    public int getColumnCount() throws SQLException {\n+      return columns.size();\n+    }\n+\n+    @Override\n+    public String getColumnLabel(int column) throws SQLException {\n+      return columns.get(column - 1).getLabel();\n+    }\n+\n+    @Override\n+    public String getColumnName(int column) throws SQLException {\n+      return columns.get(column - 1).getName();\n+    }\n+\n+    @Override\n+    public int getColumnType(int column) throws SQLException {\n+      return columns.get(column - 1).getType();\n+    }\n+\n+    @Override\n+    public int getPrecision(int column) throws SQLException {\n+      return columns.get(column - 1).getPrecision();\n+    }\n+\n+    @Override\n+    public int getScale(int column) throws SQLException {\n+      return columns.get(column - 1).getScale();\n+    }\n+\n+    @Override\n+    public int isNullable(int column) throws SQLException {\n+      return columns.get(column - 1).isNullable();\n+    }\n+\n+    public static MockResultSetMetaData fromRows(ArrayList<MockRow> rows) throws SQLException {\n+\n+      if (rows.size() == 0) {\n+        throw new SQLException(\"Unable to dynamically generate ResultSetMetaData because row count is zero!\");\n+      }\n+      MockRow firstRow = rows.get(0);\n+      if (firstRow.dataElements.size() == 0) {\n+        throw new SQLException(\"Unable to dynamically generate ResultSetMetaData because column count is zero!\");\n+      }\n+      ArrayList<MockColumnMetaData> columns = new ArrayList<>();\n+      for (int i = 0; i < firstRow.dataElements.size(); i++) {\n+        MockDataElement element = firstRow.getDataElementAtIndex(i);\n+        columns.add(MockColumnMetaData.fromDataElement(element, i));\n+      }\n+      return new MockResultSetMetaData(columns);\n+    }\n+\n+    public static class MockColumnMetaData {\n+      private int index;\n+      private int sqlType;\n+      private int precision;\n+      private int scale;\n+      private int nullable;\n+\n+      private MockColumnMetaData(int i, MockDataElement element) throws SQLException {\n+        this.index = i;\n+        this.sqlType = element.sqlType;\n+        this.precision = element.getPrecision();\n+        this.scale = element.getScale();\n+        this.nullable = element.isNullable();\n+      }\n+\n+      private String getLabel() {\n+        return \"col_\" + index;\n+      }\n+\n+      private String getName() {\n+        return getLabel();\n+      }\n+\n+      private int getType() {\n+        return sqlType;\n+      }\n+\n+      private int getPrecision() {\n+        return precision;\n+      }\n+\n+      private int getScale() {\n+        return scale;\n+      }\n+\n+      private int isNullable() {\n+        return nullable;\n+      }\n+\n+      static MockColumnMetaData fromDataElement(MockDataElement element, int i) throws SQLException {\n+        return new MockColumnMetaData(i, element);\n+      }\n+\n+    }\n+\n+  }\n+\n+  public static class MockRow {\n+    private final ArrayList<MockDataElement> dataElements;\n+\n+    public MockRow(ArrayList<MockDataElement> elements) {\n+      this.dataElements = elements;\n+    }\n+\n+    public MockDataElement getDataElementAtIndex(int idx) throws SQLException {\n+      if (idx > dataElements.size()) {\n+        throw new SQLException(\"Unable to find data element at position: \" + idx);\n+      }\n+      return dataElements.get(idx);\n+    }\n+  }\n+\n+  public static class MockDataElement {\n+    private final Object value;\n+    private final int sqlType;\n+\n+    public MockDataElement(String val) {\n+      this(val, Types.VARCHAR);\n+    }\n+\n+    public MockDataElement(Object val, int sqlType) {\n+      this.value = val;\n+      this.sqlType = sqlType;\n+    }\n+\n+    private boolean isNull() {\n+      return value == null;\n+    }\n+\n+    private String getValueAsString() {\n+      return value.toString();\n+    }\n+\n+    private int getPrecision() throws SQLException {\n+      if (this.sqlType == Types.VARCHAR) {\n+        return getValueAsString().length();\n+      }\n+      throw getExceptionToThrow(\"Unable to determine precision for data type!\");\n+    }\n+\n+    private int getScale() throws SQLException {\n+      if (this.sqlType == Types.VARCHAR) {\n+        return 0;\n+      }\n+      throw getExceptionToThrow(\"Unable to determine precision for data type!\");\n+    }\n+\n+    private int isNullable() throws SQLException {\n+      if (this.sqlType == Types.VARCHAR) {\n+        return ResultSetMetaData.columnNullable;\n+      }\n+      throw getExceptionToThrow(\"Unable to determine precision for data type!\");\n+    }\n+\n+    public BigDecimal getBigDecimal() throws SQLException {\n+      try {\n+        return new BigDecimal(getValueAsString());\n+      } catch (Exception ex) {\n+        throw new SQLException(ex);\n+      }\n+    }\n+\n+    public String getString() throws SQLException {\n+      return getValueAsString();\n+    }\n+\n+    public boolean getBoolean() throws SQLException {\n+      try {\n+        return Boolean.parseBoolean(getValueAsString());\n+      } catch (Exception ex) {\n+        throw new SQLException(ex);\n+      }\n+    }\n+\n+    public int getInt() throws SQLException {\n+      try {\n+        return Integer.parseInt(getValueAsString());\n\nReview Comment:\n   Hmm, why don't we just cast the object we're holding?\n\n\n\n",
                    "created": "2022-05-12T19:45:16.519+0000",
                    "updated": "2022-05-12T19:45:16.519+0000",
                    "started": "2022-05-12T19:45:16.519+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "769857",
                    "issueId": "13444489"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444489/worklog/769950",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "toddfarmer commented on code in PR #13123:\nURL: https://github.com/apache/arrow/pull/13123#discussion_r871869381\n\n\n##########\njava/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/ResultSetUtility.java:\n##########\n@@ -0,0 +1,1617 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.net.URL;\n+import java.sql.Array;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Date;\n+import java.sql.NClob;\n+import java.sql.Ref;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.RowId;\n+import java.sql.SQLException;\n+import java.sql.SQLType;\n+import java.sql.SQLWarning;\n+import java.sql.SQLXML;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Map;\n+\n+public class ResultSetUtility {\n+\n+  public static ResultSet generateEmptyResultSet() throws SQLException {\n+    MockDataElement element = new MockDataElement(\"string_example\");\n+    MockResultSetMetaData.MockColumnMetaData columnMetaData =\n+            MockResultSetMetaData.MockColumnMetaData.fromDataElement(element, 1);\n+    ArrayList<MockResultSetMetaData.MockColumnMetaData> cols = new ArrayList<>();\n+    cols.add(columnMetaData);\n+    ResultSetMetaData metadata = new MockResultSetMetaData(cols);\n+    return MockResultSet.builder()\n+            .setMetaData(metadata)\n+            .build();\n+  }\n+\n+  public static ResultSet generateBasicResultSet(int rows) throws SQLException {\n+    MockResultSet.Builder builder = MockResultSet.builder();\n+    for (int i = 0; i < rows; i++) {\n+      builder.addDataElement(\"row number: \" + (i + 1)).addDataElement(\"data\").finishRow();\n+    }\n+    return builder.build();\n+  }\n+\n+  public static class MockResultSet extends ThrowingResultSet {\n+    private final ArrayList<MockRow> rows;\n+    private int index = 0;\n+    private boolean isClosed = false;\n+    private ResultSetMetaData metadata;\n+    private boolean wasNull;\n+\n+    public MockResultSet(ArrayList<MockRow> rows) throws SQLException {\n+      this(rows, MockResultSetMetaData.fromRows(rows));\n+    }\n+\n+    public MockResultSet(ArrayList<MockRow> rows, ResultSetMetaData metadata) {\n+      this.rows = rows;\n+      this.metadata = metadata;\n+      this.wasNull = false;\n+    }\n+\n+    public static Builder builder() {\n+      return new Builder();\n+    }\n+\n+    private void throwIfClosed() throws SQLException {\n+      if (isClosed) {\n+        throw new SQLException(\"ResultSet is already closed!\");\n+      }\n+    }\n+\n+    private void setWasNull(MockDataElement element) {\n+      wasNull = element.isNull();\n+    }\n+\n+    @Override\n+    public boolean next() throws SQLException {\n+      index++;\n+      return index <= rows.size();\n+    }\n+\n+    @Override\n+    public void close() throws SQLException {\n+      throwIfClosed();\n+      isClosed = true;\n+    }\n+\n+    @Override\n+    public boolean isBeforeFirst() throws SQLException {\n+      throwIfClosed();\n+      return index == 0;\n+    }\n+\n+    @Override\n+    public boolean isAfterLast() throws SQLException {\n+      return index == rows.size();\n+    }\n+\n+    @Override\n+    public boolean isFirst() throws SQLException {\n+      return index == 1;\n+    }\n+\n+    @Override\n+    public boolean isLast() throws SQLException {\n+      return index == rows.size();\n+    }\n+\n+    @Override\n+    public void beforeFirst() throws SQLException {\n+      index = 0;\n+    }\n+\n+    @Override\n+    public void afterLast() throws SQLException {\n+      index = rows.size();\n+    }\n+\n+    private MockRow getCurrentRow() throws SQLException {\n+      throwIfClosed();\n+      if (index <= rows.size()) {\n+        return rows.get(index - 1);\n+      }\n+      throw new SQLException(\"Unable to fetch row at index: \" + index);\n+    }\n+\n+    private MockDataElement getDataElementAtCol(int idx) throws SQLException {\n+      MockRow row = getCurrentRow();\n+      MockDataElement element = row.getDataElementAtIndex(idx - 1);\n+      setWasNull(element);\n+      return element;\n+    }\n+\n+    @Override\n+    public String getString(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getString();\n+    }\n+\n+    @Override\n+    public boolean getBoolean(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getBoolean();\n+    }\n+\n+    @Override\n+    public short getShort(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getShort();\n+    }\n+\n+    @Override\n+    public int getInt(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getInt();\n+    }\n+\n+    @Override\n+    public long getLong(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getLong();\n+    }\n+\n+    @Override\n+    public float getFloat(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getFloat();\n+    }\n+\n+    @Override\n+    public double getDouble(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getDouble();\n+    }\n+\n+    @Override\n+    public BigDecimal getBigDecimal(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getBigDecimal();\n+    }\n+\n+    @Override\n+    public Date getDate(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getDate();\n+    }\n+\n+    @Override\n+    public Time getTime(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getTime();\n+    }\n+\n+    @Override\n+    public Timestamp getTimestamp(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getTimestamp();\n+    }\n+\n+    @Override\n+    public ResultSetMetaData getMetaData() throws SQLException {\n+      return metadata;\n+    }\n+\n+    @Override\n+    public boolean wasNull() throws SQLException {\n+      return wasNull;\n+    }\n+\n+    public static class Builder {\n+      private final ArrayList<MockRow> rows;\n+      private ArrayList<MockDataElement> bufferedElements;\n+      private ResultSetMetaData metadata;\n+\n+      Builder() {\n+        this.rows = new ArrayList<>();\n+        this.bufferedElements = new ArrayList<>();\n+      }\n+\n+      public Builder finishRow() {\n+        rows.add(new MockRow(this.bufferedElements));\n+        this.bufferedElements = new ArrayList<>();\n+        return this;\n+      }\n+\n+      public Builder addDataElement(MockDataElement element) {\n+        this.bufferedElements.add(element);\n+        return this;\n+      }\n+\n+      public Builder addDataElement(String str) {\n+        return this.addDataElement(new MockDataElement(str));\n+      }\n+\n+      public Builder addDataElement(Object val, int sqlType) {\n+        return this.addDataElement(new MockDataElement(val, sqlType));\n+      }\n+\n+      public Builder setMetaData(ResultSetMetaData metaData) {\n+        this.metadata = metaData;\n+        return this;\n+      }\n+\n+      public MockResultSet build() throws SQLException {\n+        if (this.metadata == null) {\n+          return new MockResultSet(this.rows);\n+        }\n+        return new MockResultSet(this.rows, this.metadata);\n+      }\n+    }\n+  }\n+\n+  public static class MockResultSetMetaData extends ThrowingResultSetMetaData {\n+    private ArrayList<MockColumnMetaData> columns;\n+\n+    public MockResultSetMetaData(ArrayList<MockColumnMetaData> columns) {\n+      this.columns = columns;\n+    }\n+\n+    @Override\n+    public int getColumnCount() throws SQLException {\n+      return columns.size();\n+    }\n+\n+    @Override\n+    public String getColumnLabel(int column) throws SQLException {\n+      return columns.get(column - 1).getLabel();\n+    }\n+\n+    @Override\n+    public String getColumnName(int column) throws SQLException {\n+      return columns.get(column - 1).getName();\n+    }\n+\n+    @Override\n+    public int getColumnType(int column) throws SQLException {\n+      return columns.get(column - 1).getType();\n+    }\n+\n+    @Override\n+    public int getPrecision(int column) throws SQLException {\n+      return columns.get(column - 1).getPrecision();\n+    }\n+\n+    @Override\n+    public int getScale(int column) throws SQLException {\n+      return columns.get(column - 1).getScale();\n+    }\n+\n+    @Override\n+    public int isNullable(int column) throws SQLException {\n+      return columns.get(column - 1).isNullable();\n+    }\n+\n+    public static MockResultSetMetaData fromRows(ArrayList<MockRow> rows) throws SQLException {\n+\n+      if (rows.size() == 0) {\n+        throw new SQLException(\"Unable to dynamically generate ResultSetMetaData because row count is zero!\");\n+      }\n+      MockRow firstRow = rows.get(0);\n+      if (firstRow.dataElements.size() == 0) {\n+        throw new SQLException(\"Unable to dynamically generate ResultSetMetaData because column count is zero!\");\n\nReview Comment:\n   If it is, it's not possible to dynamically construct a MockResultSetMetaData from a zero-column data set.  I've added a comment to clarify.\n\n\n\n",
                    "created": "2022-05-12T23:00:10.483+0000",
                    "updated": "2022-05-12T23:00:10.483+0000",
                    "started": "2022-05-12T23:00:10.483+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "769950",
                    "issueId": "13444489"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444489/worklog/769955",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "toddfarmer commented on code in PR #13123:\nURL: https://github.com/apache/arrow/pull/13123#discussion_r871875410\n\n\n##########\njava/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/ResultSetUtility.java:\n##########\n@@ -0,0 +1,1617 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.net.URL;\n+import java.sql.Array;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Date;\n+import java.sql.NClob;\n+import java.sql.Ref;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.RowId;\n+import java.sql.SQLException;\n+import java.sql.SQLType;\n+import java.sql.SQLWarning;\n+import java.sql.SQLXML;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Map;\n+\n+public class ResultSetUtility {\n+\n+  public static ResultSet generateEmptyResultSet() throws SQLException {\n+    MockDataElement element = new MockDataElement(\"string_example\");\n+    MockResultSetMetaData.MockColumnMetaData columnMetaData =\n+            MockResultSetMetaData.MockColumnMetaData.fromDataElement(element, 1);\n+    ArrayList<MockResultSetMetaData.MockColumnMetaData> cols = new ArrayList<>();\n+    cols.add(columnMetaData);\n+    ResultSetMetaData metadata = new MockResultSetMetaData(cols);\n+    return MockResultSet.builder()\n+            .setMetaData(metadata)\n+            .build();\n+  }\n+\n+  public static ResultSet generateBasicResultSet(int rows) throws SQLException {\n+    MockResultSet.Builder builder = MockResultSet.builder();\n+    for (int i = 0; i < rows; i++) {\n+      builder.addDataElement(\"row number: \" + (i + 1)).addDataElement(\"data\").finishRow();\n+    }\n+    return builder.build();\n+  }\n+\n+  public static class MockResultSet extends ThrowingResultSet {\n+    private final ArrayList<MockRow> rows;\n+    private int index = 0;\n+    private boolean isClosed = false;\n+    private ResultSetMetaData metadata;\n+    private boolean wasNull;\n+\n+    public MockResultSet(ArrayList<MockRow> rows) throws SQLException {\n+      this(rows, MockResultSetMetaData.fromRows(rows));\n+    }\n+\n+    public MockResultSet(ArrayList<MockRow> rows, ResultSetMetaData metadata) {\n+      this.rows = rows;\n+      this.metadata = metadata;\n+      this.wasNull = false;\n+    }\n+\n+    public static Builder builder() {\n+      return new Builder();\n+    }\n+\n+    private void throwIfClosed() throws SQLException {\n+      if (isClosed) {\n+        throw new SQLException(\"ResultSet is already closed!\");\n+      }\n+    }\n+\n+    private void setWasNull(MockDataElement element) {\n+      wasNull = element.isNull();\n+    }\n+\n+    @Override\n+    public boolean next() throws SQLException {\n+      index++;\n+      return index <= rows.size();\n+    }\n+\n+    @Override\n+    public void close() throws SQLException {\n+      throwIfClosed();\n+      isClosed = true;\n+    }\n+\n+    @Override\n+    public boolean isBeforeFirst() throws SQLException {\n+      throwIfClosed();\n+      return index == 0;\n+    }\n+\n+    @Override\n+    public boolean isAfterLast() throws SQLException {\n+      return index == rows.size();\n+    }\n+\n+    @Override\n+    public boolean isFirst() throws SQLException {\n+      return index == 1;\n+    }\n+\n+    @Override\n+    public boolean isLast() throws SQLException {\n+      return index == rows.size();\n+    }\n+\n+    @Override\n+    public void beforeFirst() throws SQLException {\n+      index = 0;\n+    }\n+\n+    @Override\n+    public void afterLast() throws SQLException {\n+      index = rows.size();\n+    }\n+\n+    private MockRow getCurrentRow() throws SQLException {\n+      throwIfClosed();\n+      if (index <= rows.size()) {\n+        return rows.get(index - 1);\n+      }\n+      throw new SQLException(\"Unable to fetch row at index: \" + index);\n+    }\n+\n+    private MockDataElement getDataElementAtCol(int idx) throws SQLException {\n+      MockRow row = getCurrentRow();\n+      MockDataElement element = row.getDataElementAtIndex(idx - 1);\n+      setWasNull(element);\n+      return element;\n+    }\n+\n+    @Override\n+    public String getString(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getString();\n+    }\n+\n+    @Override\n+    public boolean getBoolean(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getBoolean();\n+    }\n+\n+    @Override\n+    public short getShort(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getShort();\n+    }\n+\n+    @Override\n+    public int getInt(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getInt();\n+    }\n+\n+    @Override\n+    public long getLong(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getLong();\n+    }\n+\n+    @Override\n+    public float getFloat(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getFloat();\n+    }\n+\n+    @Override\n+    public double getDouble(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getDouble();\n+    }\n+\n+    @Override\n+    public BigDecimal getBigDecimal(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getBigDecimal();\n+    }\n+\n+    @Override\n+    public Date getDate(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getDate();\n+    }\n+\n+    @Override\n+    public Time getTime(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getTime();\n+    }\n+\n+    @Override\n+    public Timestamp getTimestamp(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getTimestamp();\n+    }\n+\n+    @Override\n+    public ResultSetMetaData getMetaData() throws SQLException {\n+      return metadata;\n+    }\n+\n+    @Override\n+    public boolean wasNull() throws SQLException {\n+      return wasNull;\n+    }\n+\n+    public static class Builder {\n+      private final ArrayList<MockRow> rows;\n+      private ArrayList<MockDataElement> bufferedElements;\n+      private ResultSetMetaData metadata;\n+\n+      Builder() {\n+        this.rows = new ArrayList<>();\n+        this.bufferedElements = new ArrayList<>();\n+      }\n+\n+      public Builder finishRow() {\n+        rows.add(new MockRow(this.bufferedElements));\n+        this.bufferedElements = new ArrayList<>();\n+        return this;\n+      }\n+\n+      public Builder addDataElement(MockDataElement element) {\n+        this.bufferedElements.add(element);\n+        return this;\n+      }\n+\n+      public Builder addDataElement(String str) {\n+        return this.addDataElement(new MockDataElement(str));\n+      }\n+\n+      public Builder addDataElement(Object val, int sqlType) {\n+        return this.addDataElement(new MockDataElement(val, sqlType));\n+      }\n+\n+      public Builder setMetaData(ResultSetMetaData metaData) {\n+        this.metadata = metaData;\n+        return this;\n+      }\n+\n+      public MockResultSet build() throws SQLException {\n+        if (this.metadata == null) {\n+          return new MockResultSet(this.rows);\n+        }\n+        return new MockResultSet(this.rows, this.metadata);\n+      }\n+    }\n+  }\n+\n+  public static class MockResultSetMetaData extends ThrowingResultSetMetaData {\n+    private ArrayList<MockColumnMetaData> columns;\n+\n+    public MockResultSetMetaData(ArrayList<MockColumnMetaData> columns) {\n+      this.columns = columns;\n+    }\n+\n+    @Override\n+    public int getColumnCount() throws SQLException {\n+      return columns.size();\n+    }\n+\n+    @Override\n+    public String getColumnLabel(int column) throws SQLException {\n+      return columns.get(column - 1).getLabel();\n+    }\n+\n+    @Override\n+    public String getColumnName(int column) throws SQLException {\n+      return columns.get(column - 1).getName();\n+    }\n+\n+    @Override\n+    public int getColumnType(int column) throws SQLException {\n+      return columns.get(column - 1).getType();\n+    }\n+\n+    @Override\n+    public int getPrecision(int column) throws SQLException {\n+      return columns.get(column - 1).getPrecision();\n+    }\n+\n+    @Override\n+    public int getScale(int column) throws SQLException {\n+      return columns.get(column - 1).getScale();\n+    }\n+\n+    @Override\n+    public int isNullable(int column) throws SQLException {\n+      return columns.get(column - 1).isNullable();\n+    }\n+\n+    public static MockResultSetMetaData fromRows(ArrayList<MockRow> rows) throws SQLException {\n+\n+      if (rows.size() == 0) {\n+        throw new SQLException(\"Unable to dynamically generate ResultSetMetaData because row count is zero!\");\n+      }\n+      MockRow firstRow = rows.get(0);\n+      if (firstRow.dataElements.size() == 0) {\n+        throw new SQLException(\"Unable to dynamically generate ResultSetMetaData because column count is zero!\");\n+      }\n+      ArrayList<MockColumnMetaData> columns = new ArrayList<>();\n+      for (int i = 0; i < firstRow.dataElements.size(); i++) {\n+        MockDataElement element = firstRow.getDataElementAtIndex(i);\n+        columns.add(MockColumnMetaData.fromDataElement(element, i));\n+      }\n+      return new MockResultSetMetaData(columns);\n+    }\n+\n+    public static class MockColumnMetaData {\n+      private int index;\n+      private int sqlType;\n+      private int precision;\n+      private int scale;\n+      private int nullable;\n+\n+      private MockColumnMetaData(int i, MockDataElement element) throws SQLException {\n+        this.index = i;\n+        this.sqlType = element.sqlType;\n+        this.precision = element.getPrecision();\n+        this.scale = element.getScale();\n+        this.nullable = element.isNullable();\n+      }\n+\n+      private String getLabel() {\n+        return \"col_\" + index;\n+      }\n+\n+      private String getName() {\n+        return getLabel();\n+      }\n+\n+      private int getType() {\n+        return sqlType;\n+      }\n+\n+      private int getPrecision() {\n+        return precision;\n+      }\n+\n+      private int getScale() {\n+        return scale;\n+      }\n+\n+      private int isNullable() {\n+        return nullable;\n+      }\n+\n+      static MockColumnMetaData fromDataElement(MockDataElement element, int i) throws SQLException {\n+        return new MockColumnMetaData(i, element);\n+      }\n+\n+    }\n+\n+  }\n+\n+  public static class MockRow {\n+    private final ArrayList<MockDataElement> dataElements;\n+\n+    public MockRow(ArrayList<MockDataElement> elements) {\n+      this.dataElements = elements;\n+    }\n+\n+    public MockDataElement getDataElementAtIndex(int idx) throws SQLException {\n+      if (idx > dataElements.size()) {\n+        throw new SQLException(\"Unable to find data element at position: \" + idx);\n+      }\n+      return dataElements.get(idx);\n+    }\n+  }\n+\n+  public static class MockDataElement {\n+    private final Object value;\n+    private final int sqlType;\n+\n+    public MockDataElement(String val) {\n+      this(val, Types.VARCHAR);\n+    }\n+\n+    public MockDataElement(Object val, int sqlType) {\n+      this.value = val;\n+      this.sqlType = sqlType;\n+    }\n+\n+    private boolean isNull() {\n+      return value == null;\n+    }\n+\n+    private String getValueAsString() {\n+      return value.toString();\n+    }\n+\n+    private int getPrecision() throws SQLException {\n+      if (this.sqlType == Types.VARCHAR) {\n+        return getValueAsString().length();\n+      }\n+      throw getExceptionToThrow(\"Unable to determine precision for data type!\");\n+    }\n+\n+    private int getScale() throws SQLException {\n+      if (this.sqlType == Types.VARCHAR) {\n+        return 0;\n+      }\n+      throw getExceptionToThrow(\"Unable to determine precision for data type!\");\n+    }\n+\n+    private int isNullable() throws SQLException {\n+      if (this.sqlType == Types.VARCHAR) {\n+        return ResultSetMetaData.columnNullable;\n+      }\n+      throw getExceptionToThrow(\"Unable to determine precision for data type!\");\n+    }\n+\n+    public BigDecimal getBigDecimal() throws SQLException {\n+      try {\n+        return new BigDecimal(getValueAsString());\n+      } catch (Exception ex) {\n+        throw new SQLException(ex);\n+      }\n+    }\n+\n+    public String getString() throws SQLException {\n+      return getValueAsString();\n+    }\n+\n+    public boolean getBoolean() throws SQLException {\n+      try {\n+        return Boolean.parseBoolean(getValueAsString());\n+      } catch (Exception ex) {\n+        throw new SQLException(ex);\n+      }\n+    }\n+\n+    public int getInt() throws SQLException {\n+      try {\n+        return Integer.parseInt(getValueAsString());\n\nReview Comment:\n   That's an option, but the thinking behind my approach here was to enable easy type conversion.  By way of example, the following test succeeds with the current code, but will fail with object casting:\r\n   \r\n   ```java\r\n     @Test\r\n     public void testMockDataTypes() throws SQLException {\r\n       ResultSetUtility.MockDataElement element = new ResultSetUtility.MockDataElement(1L, Types.NUMERIC);\r\n       assertEquals(1L, element.getLong());\r\n       assertEquals(1, element.getInt());\r\n       assertEquals(\"1\", element.getString());\r\n     }\r\n   ```\n\n\n\n",
                    "created": "2022-05-12T23:15:07.743+0000",
                    "updated": "2022-05-12T23:15:07.743+0000",
                    "started": "2022-05-12T23:15:07.743+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "769955",
                    "issueId": "13444489"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444489/worklog/770155",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #13123:\nURL: https://github.com/apache/arrow/pull/13123#discussion_r872333579\n\n\n##########\njava/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/ResultSetUtility.java:\n##########\n@@ -0,0 +1,1617 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.net.URL;\n+import java.sql.Array;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Date;\n+import java.sql.NClob;\n+import java.sql.Ref;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.RowId;\n+import java.sql.SQLException;\n+import java.sql.SQLType;\n+import java.sql.SQLWarning;\n+import java.sql.SQLXML;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Map;\n+\n+public class ResultSetUtility {\n+\n+  public static ResultSet generateEmptyResultSet() throws SQLException {\n+    MockDataElement element = new MockDataElement(\"string_example\");\n+    MockResultSetMetaData.MockColumnMetaData columnMetaData =\n+            MockResultSetMetaData.MockColumnMetaData.fromDataElement(element, 1);\n+    ArrayList<MockResultSetMetaData.MockColumnMetaData> cols = new ArrayList<>();\n+    cols.add(columnMetaData);\n+    ResultSetMetaData metadata = new MockResultSetMetaData(cols);\n+    return MockResultSet.builder()\n+            .setMetaData(metadata)\n+            .build();\n+  }\n+\n+  public static ResultSet generateBasicResultSet(int rows) throws SQLException {\n+    MockResultSet.Builder builder = MockResultSet.builder();\n+    for (int i = 0; i < rows; i++) {\n+      builder.addDataElement(\"row number: \" + (i + 1)).addDataElement(\"data\").finishRow();\n+    }\n+    return builder.build();\n+  }\n+\n+  public static class MockResultSet extends ThrowingResultSet {\n+    private final ArrayList<MockRow> rows;\n+    private int index = 0;\n+    private boolean isClosed = false;\n+    private ResultSetMetaData metadata;\n+    private boolean wasNull;\n+\n+    public MockResultSet(ArrayList<MockRow> rows) throws SQLException {\n+      this(rows, MockResultSetMetaData.fromRows(rows));\n+    }\n+\n+    public MockResultSet(ArrayList<MockRow> rows, ResultSetMetaData metadata) {\n+      this.rows = rows;\n+      this.metadata = metadata;\n+      this.wasNull = false;\n+    }\n+\n+    public static Builder builder() {\n+      return new Builder();\n+    }\n+\n+    private void throwIfClosed() throws SQLException {\n+      if (isClosed) {\n+        throw new SQLException(\"ResultSet is already closed!\");\n+      }\n+    }\n+\n+    private void setWasNull(MockDataElement element) {\n+      wasNull = element.isNull();\n+    }\n+\n+    @Override\n+    public boolean next() throws SQLException {\n+      index++;\n+      return index <= rows.size();\n+    }\n+\n+    @Override\n+    public void close() throws SQLException {\n+      throwIfClosed();\n+      isClosed = true;\n+    }\n+\n+    @Override\n+    public boolean isBeforeFirst() throws SQLException {\n+      throwIfClosed();\n+      return index == 0;\n+    }\n+\n+    @Override\n+    public boolean isAfterLast() throws SQLException {\n+      return index == rows.size();\n+    }\n+\n+    @Override\n+    public boolean isFirst() throws SQLException {\n+      return index == 1;\n+    }\n+\n+    @Override\n+    public boolean isLast() throws SQLException {\n+      return index == rows.size();\n+    }\n+\n+    @Override\n+    public void beforeFirst() throws SQLException {\n+      index = 0;\n+    }\n+\n+    @Override\n+    public void afterLast() throws SQLException {\n+      index = rows.size();\n+    }\n+\n+    private MockRow getCurrentRow() throws SQLException {\n+      throwIfClosed();\n+      if (index <= rows.size()) {\n+        return rows.get(index - 1);\n+      }\n+      throw new SQLException(\"Unable to fetch row at index: \" + index);\n+    }\n+\n+    private MockDataElement getDataElementAtCol(int idx) throws SQLException {\n+      MockRow row = getCurrentRow();\n+      MockDataElement element = row.getDataElementAtIndex(idx - 1);\n+      setWasNull(element);\n+      return element;\n+    }\n+\n+    @Override\n+    public String getString(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getString();\n+    }\n+\n+    @Override\n+    public boolean getBoolean(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getBoolean();\n+    }\n+\n+    @Override\n+    public short getShort(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getShort();\n+    }\n+\n+    @Override\n+    public int getInt(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getInt();\n+    }\n+\n+    @Override\n+    public long getLong(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getLong();\n+    }\n+\n+    @Override\n+    public float getFloat(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getFloat();\n+    }\n+\n+    @Override\n+    public double getDouble(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getDouble();\n+    }\n+\n+    @Override\n+    public BigDecimal getBigDecimal(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getBigDecimal();\n+    }\n+\n+    @Override\n+    public Date getDate(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getDate();\n+    }\n+\n+    @Override\n+    public Time getTime(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getTime();\n+    }\n+\n+    @Override\n+    public Timestamp getTimestamp(int idx) throws SQLException {\n+      return getDataElementAtCol(idx).getTimestamp();\n+    }\n+\n+    @Override\n+    public ResultSetMetaData getMetaData() throws SQLException {\n+      return metadata;\n+    }\n+\n+    @Override\n+    public boolean wasNull() throws SQLException {\n+      return wasNull;\n+    }\n+\n+    public static class Builder {\n+      private final ArrayList<MockRow> rows;\n+      private ArrayList<MockDataElement> bufferedElements;\n+      private ResultSetMetaData metadata;\n+\n+      Builder() {\n+        this.rows = new ArrayList<>();\n+        this.bufferedElements = new ArrayList<>();\n+      }\n+\n+      public Builder finishRow() {\n+        rows.add(new MockRow(this.bufferedElements));\n+        this.bufferedElements = new ArrayList<>();\n+        return this;\n+      }\n+\n+      public Builder addDataElement(MockDataElement element) {\n+        this.bufferedElements.add(element);\n+        return this;\n+      }\n+\n+      public Builder addDataElement(String str) {\n+        return this.addDataElement(new MockDataElement(str));\n+      }\n+\n+      public Builder addDataElement(Object val, int sqlType) {\n+        return this.addDataElement(new MockDataElement(val, sqlType));\n+      }\n+\n+      public Builder setMetaData(ResultSetMetaData metaData) {\n+        this.metadata = metaData;\n+        return this;\n+      }\n+\n+      public MockResultSet build() throws SQLException {\n+        if (this.metadata == null) {\n+          return new MockResultSet(this.rows);\n+        }\n+        return new MockResultSet(this.rows, this.metadata);\n+      }\n+    }\n+  }\n+\n+  public static class MockResultSetMetaData extends ThrowingResultSetMetaData {\n+    private ArrayList<MockColumnMetaData> columns;\n+\n+    public MockResultSetMetaData(ArrayList<MockColumnMetaData> columns) {\n+      this.columns = columns;\n+    }\n+\n+    @Override\n+    public int getColumnCount() throws SQLException {\n+      return columns.size();\n+    }\n+\n+    @Override\n+    public String getColumnLabel(int column) throws SQLException {\n+      return columns.get(column - 1).getLabel();\n+    }\n+\n+    @Override\n+    public String getColumnName(int column) throws SQLException {\n+      return columns.get(column - 1).getName();\n+    }\n+\n+    @Override\n+    public int getColumnType(int column) throws SQLException {\n+      return columns.get(column - 1).getType();\n+    }\n+\n+    @Override\n+    public int getPrecision(int column) throws SQLException {\n+      return columns.get(column - 1).getPrecision();\n+    }\n+\n+    @Override\n+    public int getScale(int column) throws SQLException {\n+      return columns.get(column - 1).getScale();\n+    }\n+\n+    @Override\n+    public int isNullable(int column) throws SQLException {\n+      return columns.get(column - 1).isNullable();\n+    }\n+\n+    public static MockResultSetMetaData fromRows(ArrayList<MockRow> rows) throws SQLException {\n+\n+      if (rows.size() == 0) {\n+        throw new SQLException(\"Unable to dynamically generate ResultSetMetaData because row count is zero!\");\n+      }\n+      MockRow firstRow = rows.get(0);\n+      if (firstRow.dataElements.size() == 0) {\n+        throw new SQLException(\"Unable to dynamically generate ResultSetMetaData because column count is zero!\");\n+      }\n+      ArrayList<MockColumnMetaData> columns = new ArrayList<>();\n+      for (int i = 0; i < firstRow.dataElements.size(); i++) {\n+        MockDataElement element = firstRow.getDataElementAtIndex(i);\n+        columns.add(MockColumnMetaData.fromDataElement(element, i));\n+      }\n+      return new MockResultSetMetaData(columns);\n+    }\n+\n+    public static class MockColumnMetaData {\n+      private int index;\n+      private int sqlType;\n+      private int precision;\n+      private int scale;\n+      private int nullable;\n+\n+      private MockColumnMetaData(int i, MockDataElement element) throws SQLException {\n+        this.index = i;\n+        this.sqlType = element.sqlType;\n+        this.precision = element.getPrecision();\n+        this.scale = element.getScale();\n+        this.nullable = element.isNullable();\n+      }\n+\n+      private String getLabel() {\n+        return \"col_\" + index;\n+      }\n+\n+      private String getName() {\n+        return getLabel();\n+      }\n+\n+      private int getType() {\n+        return sqlType;\n+      }\n+\n+      private int getPrecision() {\n+        return precision;\n+      }\n+\n+      private int getScale() {\n+        return scale;\n+      }\n+\n+      private int isNullable() {\n+        return nullable;\n+      }\n+\n+      static MockColumnMetaData fromDataElement(MockDataElement element, int i) throws SQLException {\n+        return new MockColumnMetaData(i, element);\n+      }\n+\n+    }\n+\n+  }\n+\n+  public static class MockRow {\n+    private final ArrayList<MockDataElement> dataElements;\n+\n+    public MockRow(ArrayList<MockDataElement> elements) {\n+      this.dataElements = elements;\n+    }\n+\n+    public MockDataElement getDataElementAtIndex(int idx) throws SQLException {\n+      if (idx > dataElements.size()) {\n+        throw new SQLException(\"Unable to find data element at position: \" + idx);\n+      }\n+      return dataElements.get(idx);\n+    }\n+  }\n+\n+  public static class MockDataElement {\n+    private final Object value;\n+    private final int sqlType;\n+\n+    public MockDataElement(String val) {\n+      this(val, Types.VARCHAR);\n+    }\n+\n+    public MockDataElement(Object val, int sqlType) {\n+      this.value = val;\n+      this.sqlType = sqlType;\n+    }\n+\n+    private boolean isNull() {\n+      return value == null;\n+    }\n+\n+    private String getValueAsString() {\n+      return value.toString();\n+    }\n+\n+    private int getPrecision() throws SQLException {\n+      if (this.sqlType == Types.VARCHAR) {\n+        return getValueAsString().length();\n+      }\n+      throw getExceptionToThrow(\"Unable to determine precision for data type!\");\n+    }\n+\n+    private int getScale() throws SQLException {\n+      if (this.sqlType == Types.VARCHAR) {\n+        return 0;\n+      }\n+      throw getExceptionToThrow(\"Unable to determine precision for data type!\");\n+    }\n+\n+    private int isNullable() throws SQLException {\n+      if (this.sqlType == Types.VARCHAR) {\n+        return ResultSetMetaData.columnNullable;\n+      }\n+      throw getExceptionToThrow(\"Unable to determine precision for data type!\");\n+    }\n+\n+    public BigDecimal getBigDecimal() throws SQLException {\n+      try {\n+        return new BigDecimal(getValueAsString());\n+      } catch (Exception ex) {\n+        throw new SQLException(ex);\n+      }\n+    }\n+\n+    public String getString() throws SQLException {\n+      return getValueAsString();\n+    }\n+\n+    public boolean getBoolean() throws SQLException {\n+      try {\n+        return Boolean.parseBoolean(getValueAsString());\n+      } catch (Exception ex) {\n+        throw new SQLException(ex);\n+      }\n+    }\n+\n+    public int getInt() throws SQLException {\n+      try {\n+        return Integer.parseInt(getValueAsString());\n\nReview Comment:\n   Ah, ok, sounds good.\n\n\n\n",
                    "created": "2022-05-13T12:12:46.367+0000",
                    "updated": "2022-05-13T12:12:46.367+0000",
                    "started": "2022-05-13T12:12:46.367+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "770155",
                    "issueId": "13444489"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444489/worklog/770156",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm closed pull request #13123: ARROW-16538: [Java] Adding flexibility to mock ResultSets\nURL: https://github.com/apache/arrow/pull/13123\n\n\n",
                    "created": "2022-05-13T12:13:35.038+0000",
                    "updated": "2022-05-13T12:13:35.038+0000",
                    "started": "2022-05-13T12:13:35.038+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "770156",
                    "issueId": "13444489"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444489/worklog/770545",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot commented on PR #13123:\nURL: https://github.com/apache/arrow/pull/13123#issuecomment-1126840807\n\n   Benchmark runs are scheduled for baseline = d9346927a0cb79c53464c43c9f991907fca63f10 and contender = 745a5879ff4beaa897cf02afae37af52bf73f184. 745a5879ff4beaa897cf02afae37af52bf73f184 is a master commit associated with this PR. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Finished :arrow_down:0.0% :arrow_up:0.0%] [ec2-t3-xlarge-us-east-2](https://conbench.ursa.dev/compare/runs/a1bbafdfd3ec4d149f9f4d1cfebaea06...0394330e35214fd68f9ecee60f8d7c28/)\n   [Finished :arrow_down:0.27% :arrow_up:0.0%] [test-mac-arm](https://conbench.ursa.dev/compare/runs/d90d26403e1f424f94409593cf2fb235...a1fafe2b89d54cc8b837fa8b2d5a54c2/)\n   [Failed :arrow_down:0.36% :arrow_up:0.0%] [ursa-i9-9960x](https://conbench.ursa.dev/compare/runs/f8db3985ea5d48a68b33ec4e5163a1d8...29bc19654a9c4448ac7e0ea2faa4a1e3/)\n   [Finished :arrow_down:0.04% :arrow_up:0.04%] [ursa-thinkcentre-m75q](https://conbench.ursa.dev/compare/runs/8b8014c8858e47b4940e533e50d65a40...b9b9de1dee334ebe810aa840972db90c/)\n   Buildkite builds:\n   [Finished] [`745a5879` ec2-t3-xlarge-us-east-2](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ec2-t3-xlarge-us-east-2/builds/755)\n   [Finished] [`745a5879` test-mac-arm](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-test-mac-arm/builds/752)\n   [Failed] [`745a5879` ursa-i9-9960x](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-i9-9960x/builds/742)\n   [Finished] [`745a5879` ursa-thinkcentre-m75q](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-thinkcentre-m75q/builds/757)\n   [Finished] [`d9346927` ec2-t3-xlarge-us-east-2](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ec2-t3-xlarge-us-east-2/builds/754)\n   [Finished] [`d9346927` test-mac-arm](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-test-mac-arm/builds/751)\n   [Finished] [`d9346927` ursa-i9-9960x](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-i9-9960x/builds/741)\n   [Finished] [`d9346927` ursa-thinkcentre-m75q](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-thinkcentre-m75q/builds/756)\n   Supported benchmarks:\n   ec2-t3-xlarge-us-east-2: Supported benchmark langs: Python, R. Runs only benchmarks with cloud = True\n   test-mac-arm: Supported benchmark langs: C++, Python, R\n   ursa-i9-9960x: Supported benchmark langs: Python, R, JavaScript\n   ursa-thinkcentre-m75q: Supported benchmark langs: C++, Java\n   \n\n\n",
                    "created": "2022-05-15T01:51:37.446+0000",
                    "updated": "2022-05-15T01:51:37.446+0000",
                    "started": "2022-05-15T01:51:37.445+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "770545",
                    "issueId": "13444489"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 5400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@67ccf17f[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7e190d85[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@42327f5c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@747137ba[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5176be37[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@3a238374[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6bbad3f3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@160bf5d9[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@72687629[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@54767333[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@69ee0705[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@200292dc[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 5400,
        "customfield_12312520": null,
        "customfield_12312521": "Fri May 13 12:13:21 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-05-13T12:13:21.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16538/watchers",
            "watchCount": 1,
            "isWatching": true
        },
        "created": "2022-05-11T20:20:35.000+0000",
        "updated": "2022-05-15T01:51:37.000+0000",
        "timeoriginalestimate": null,
        "description": "The existing FakeResultSet used in tests of the JDBC adapter is challenging to use to build arbitrary ResultSets - such as would be useful in dealing with issues like ARROW-16427.\u00a0 Converting this to a more generic utility to build mock ResultSets would enable testing of JDBC vendor-specific behavior that is discovered, without actually referencing those drivers within test code.\u00a0 Finally, it would be useful to more such a utility to a general class, leaving just the test code in the existing test class.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 5400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Java] Refactor FakeResultSet to support arbitrary tests",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444489/comment/17536603",
                    "id": "17536603",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 13123\n[https://github.com/apache/arrow/pull/13123]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2022-05-13T12:13:21.720+0000",
                    "updated": "2022-05-13T12:13:21.720+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z12a7k:",
        "customfield_12314139": null
    }
}