{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13375184",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184",
    "key": "ARROW-12560",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349983",
                "id": "12349983",
                "description": "",
                "name": "5.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-07-28"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "async-util",
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12616537",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12616537",
                "type": {
                    "id": "12310360",
                    "name": "Dependent",
                    "inward": "Dependent",
                    "outward": "Dependent",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310360"
                },
                "inwardIssue": {
                    "id": "13381461",
                    "key": "ARROW-12916",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381461",
                    "fields": {
                        "summary": "[C++][Parquet] Always transfer to executor in Parquet AsyncGenerator",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 19800,
            "total": 19800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 19800,
            "total": 19800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12560/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 33,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/593970",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#issuecomment-836713973\n\n\n   I'm not sure why you're suggesting to add so much sophistication. To me there are only two interesting options: \"always\" and \"if unfinished\". So we could have `Transfer` (transfer always) vs. `TransferUnfinished`.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-10T13:40:26.202+0000",
                    "updated": "2021-05-10T13:40:26.202+0000",
                    "started": "2021-05-10T13:40:26.201+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "593970",
                    "issueId": "13375184"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/601469",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#issuecomment-847444398\n\n\n   Since I'm working on work stealing at the thread pool level I agree that idle is no longer needed.  I've cleaned this up and rebased.  It's much simpler than it was before.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-25T00:33:19.761+0000",
                    "updated": "2021-05-25T00:33:19.761+0000",
                    "started": "2021-05-25T00:33:19.760+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "601469",
                    "issueId": "13375184"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/601471",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#issuecomment-847445822\n\n\n   Also, I ran into a bit of trouble with the future callback's weak reference to the future.  Before we could just assume it was valid since all callbacks were completed before `MarkFinished` was completed.  Now, it is possible for a future to schedule a callback and that callback to far outlive the call to `MarkFinished`.  So now when a callback is scheduled (run on an executor) we make a copy of the `FutureImpl`'s shared_ptr to keep it alive until that callback has a chance to run.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-25T00:37:07.959+0000",
                    "updated": "2021-05-25T00:37:07.959+0000",
                    "started": "2021-05-25T00:37:07.959+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "601471",
                    "issueId": "13375184"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/604375",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#discussion_r642890540\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -231,26 +232,68 @@ class ConcreteFutureImpl : public FutureImpl {\n \n   void DoMarkFailed() { DoMarkFinishedOrFailed(FutureState::FAILURE); }\n \n-  void AddCallback(Callback callback) {\n+  void CheckOptions(const CallbackOptions& opts) {\n+    if (opts.should_schedule != ShouldSchedule::NEVER) {\n+      DCHECK_NE(opts.executor, NULL)\n\nReview comment:\n       `nullptr`\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -231,26 +232,68 @@ class ConcreteFutureImpl : public FutureImpl {\n \n   void DoMarkFailed() { DoMarkFinishedOrFailed(FutureState::FAILURE); }\n \n-  void AddCallback(Callback callback) {\n+  void CheckOptions(const CallbackOptions& opts) {\n+    if (opts.should_schedule != ShouldSchedule::NEVER) {\n+      DCHECK_NE(opts.executor, NULL)\n+          << \"An executor must be specified when adding a callback that might schedule\";\n+    }\n+  }\n+\n+  void AddCallback(Callback callback, CallbackOptions opts) {\n+    CheckOptions(opts);\n     std::unique_lock<std::mutex> lock(mutex_);\n+    CallbackRecord callback_record{std::move(callback), opts};\n     if (IsFutureFinished(state_)) {\n       lock.unlock();\n-      std::move(callback)();\n+      RunOrScheduleCallback(callback_record, /*from_unfinished=*/false);\n     } else {\n-      callbacks_.push_back(std::move(callback));\n+      callbacks_.push_back(std::move(callback_record));\n     }\n   }\n \n-  bool TryAddCallback(const std::function<Callback()>& callback_factory) {\n+  bool TryAddCallback(const std::function<Callback()>& callback_factory,\n+                      CallbackOptions opts) {\n+    CheckOptions(opts);\n     std::unique_lock<std::mutex> lock(mutex_);\n     if (IsFutureFinished(state_)) {\n       return false;\n     } else {\n-      callbacks_.push_back(callback_factory());\n+      callbacks_.push_back({callback_factory(), opts});\n       return true;\n     }\n   }\n \n+  bool ShouldSchedule(const CallbackRecord& callback_record, bool from_unfinished) {\n+    switch (callback_record.options.should_schedule) {\n+      case ShouldSchedule::NEVER:\n+        return false;\n+      case ShouldSchedule::ALWAYS:\n+        return true;\n+      case ShouldSchedule::IF_UNFINISHED:\n+        return from_unfinished;\n+      default:\n+        DCHECK(false) << \"Unrecognized ShouldSchedule option\";\n+        return false;\n+    }\n+  }\n+\n+  void RunOrScheduleCallback(CallbackRecord& callback_record, bool from_unfinished) {\n+    if (ShouldSchedule(callback_record, from_unfinished)) {\n+      // Need to make a copy of this to keep it alive until the callback has a chance\n\nReview comment:\n       Why \"a copy\"? It's not clear to me where a copy is being made.\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -202,8 +202,30 @@ enum class FutureState : int8_t { PENDING, SUCCESS, FAILURE };\n \n inline bool IsFutureFinished(FutureState state) { return state != FutureState::PENDING; }\n \n+/// \\brief Describes whether the callback should be scheduled or run synchronously\n\nReview comment:\n       \"Describe\"\n\n##########\nFile path: cpp/src/arrow/util/test_common.h\n##########\n@@ -85,4 +88,18 @@ inline void AssertIteratorExhausted(Iterator<T>& it) {\n \n Transformer<TestInt, TestStr> MakeFilter(std::function<bool(TestInt&)> filter);\n \n+class MockExecutor : public internal::Executor {\n\nReview comment:\n       Ideally, we should start categorizing our test utilities better instead of dumping them all in generic header files.\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -231,26 +232,68 @@ class ConcreteFutureImpl : public FutureImpl {\n \n   void DoMarkFailed() { DoMarkFinishedOrFailed(FutureState::FAILURE); }\n \n-  void AddCallback(Callback callback) {\n+  void CheckOptions(const CallbackOptions& opts) {\n+    if (opts.should_schedule != ShouldSchedule::NEVER) {\n+      DCHECK_NE(opts.executor, NULL)\n+          << \"An executor must be specified when adding a callback that might schedule\";\n+    }\n+  }\n+\n+  void AddCallback(Callback callback, CallbackOptions opts) {\n+    CheckOptions(opts);\n     std::unique_lock<std::mutex> lock(mutex_);\n+    CallbackRecord callback_record{std::move(callback), opts};\n     if (IsFutureFinished(state_)) {\n       lock.unlock();\n-      std::move(callback)();\n+      RunOrScheduleCallback(callback_record, /*from_unfinished=*/false);\n     } else {\n-      callbacks_.push_back(std::move(callback));\n+      callbacks_.push_back(std::move(callback_record));\n     }\n   }\n \n-  bool TryAddCallback(const std::function<Callback()>& callback_factory) {\n+  bool TryAddCallback(const std::function<Callback()>& callback_factory,\n+                      CallbackOptions opts) {\n+    CheckOptions(opts);\n     std::unique_lock<std::mutex> lock(mutex_);\n     if (IsFutureFinished(state_)) {\n       return false;\n     } else {\n-      callbacks_.push_back(callback_factory());\n+      callbacks_.push_back({callback_factory(), opts});\n       return true;\n     }\n   }\n \n+  bool ShouldSchedule(const CallbackRecord& callback_record, bool from_unfinished) {\n+    switch (callback_record.options.should_schedule) {\n+      case ShouldSchedule::NEVER:\n+        return false;\n+      case ShouldSchedule::ALWAYS:\n+        return true;\n+      case ShouldSchedule::IF_UNFINISHED:\n+        return from_unfinished;\n+      default:\n+        DCHECK(false) << \"Unrecognized ShouldSchedule option\";\n+        return false;\n+    }\n+  }\n+\n+  void RunOrScheduleCallback(CallbackRecord& callback_record, bool from_unfinished) {\n+    if (ShouldSchedule(callback_record, from_unfinished)) {\n+      // Need to make a copy of this to keep it alive until the callback has a chance\n+      // to be scheduled.\n+      struct CallbackTask {\n+        void operator()() { std::move(callback)(*self); }\n+\n+        Callback callback;\n+        std::shared_ptr<FutureImpl> self;\n\nReview comment:\n       The code used to be capturing a weak pointer. Is it desirable to make this a strong pointer instead?\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -231,26 +232,68 @@ class ConcreteFutureImpl : public FutureImpl {\n \n   void DoMarkFailed() { DoMarkFinishedOrFailed(FutureState::FAILURE); }\n \n-  void AddCallback(Callback callback) {\n+  void CheckOptions(const CallbackOptions& opts) {\n+    if (opts.should_schedule != ShouldSchedule::NEVER) {\n+      DCHECK_NE(opts.executor, NULL)\n+          << \"An executor must be specified when adding a callback that might schedule\";\n+    }\n+  }\n+\n+  void AddCallback(Callback callback, CallbackOptions opts) {\n+    CheckOptions(opts);\n     std::unique_lock<std::mutex> lock(mutex_);\n+    CallbackRecord callback_record{std::move(callback), opts};\n     if (IsFutureFinished(state_)) {\n       lock.unlock();\n-      std::move(callback)();\n+      RunOrScheduleCallback(callback_record, /*from_unfinished=*/false);\n     } else {\n-      callbacks_.push_back(std::move(callback));\n+      callbacks_.push_back(std::move(callback_record));\n     }\n   }\n \n-  bool TryAddCallback(const std::function<Callback()>& callback_factory) {\n+  bool TryAddCallback(const std::function<Callback()>& callback_factory,\n+                      CallbackOptions opts) {\n+    CheckOptions(opts);\n     std::unique_lock<std::mutex> lock(mutex_);\n     if (IsFutureFinished(state_)) {\n       return false;\n     } else {\n-      callbacks_.push_back(callback_factory());\n+      callbacks_.push_back({callback_factory(), opts});\n       return true;\n     }\n   }\n \n+  bool ShouldSchedule(const CallbackRecord& callback_record, bool from_unfinished) {\n+    switch (callback_record.options.should_schedule) {\n+      case ShouldSchedule::NEVER:\n+        return false;\n+      case ShouldSchedule::ALWAYS:\n+        return true;\n+      case ShouldSchedule::IF_UNFINISHED:\n+        return from_unfinished;\n+      default:\n+        DCHECK(false) << \"Unrecognized ShouldSchedule option\";\n+        return false;\n+    }\n+  }\n+\n+  void RunOrScheduleCallback(CallbackRecord& callback_record, bool from_unfinished) {\n\nReview comment:\n       The coding conventions prohibit passing mutable lrefs. You could make this a `CallbackRecord&&`, for example.\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -952,6 +951,85 @@ TEST(FutureCompletionTest, FutureVoid) {\n   }\n }\n \n+class FutureSchedulingTest : public testing::Test {\n+ public:\n+  internal::Executor* executor() { return mock_executor.get(); }\n+  int spawn_count() { return mock_executor->spawn_count; }\n+\n+  std::function<void(const Status&)> callback = [](const Status&) {};\n+  std::shared_ptr<MockExecutor> mock_executor = std::make_shared<MockExecutor>();\n+};\n+\n+TEST_F(FutureSchedulingTest, ScheduleAlways) {\n+  CallbackOptions options;\n+  options.should_schedule = ShouldSchedule::ALWAYS;\n+  options.executor = executor();\n+  // Successful future\n+  {\n+    auto fut = Future<>::Make();\n+    fut.AddCallback(callback, options);\n+    fut.MarkFinished();\n+    fut.AddCallback(callback, options);\n+    ASSERT_EQ(2, spawn_count());\n+  }\n+  // Failing future\n+  {\n+    auto fut = Future<>::Make();\n+    fut.AddCallback(callback, options);\n+    fut.MarkFinished(Status::Invalid(\"XYZ\"));\n+    fut.AddCallback(callback, options);\n+    ASSERT_EQ(4, spawn_count());\n+  }\n+}\n+\n+TEST_F(FutureSchedulingTest, ScheduleIfUnfinished) {\n+  CallbackOptions options;\n+  options.should_schedule = ShouldSchedule::IF_UNFINISHED;\n+  options.executor = executor();\n+  // Successful future\n+  {\n+    auto fut = Future<>::Make();\n+    fut.AddCallback(callback, options);\n+    fut.MarkFinished();\n+    fut.AddCallback(callback, options);\n+    ASSERT_EQ(1, spawn_count());\n\nReview comment:\n       Unfortunately, this doesn't check which of the two callbacks was spawned.\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -231,26 +232,68 @@ class ConcreteFutureImpl : public FutureImpl {\n \n   void DoMarkFailed() { DoMarkFinishedOrFailed(FutureState::FAILURE); }\n \n-  void AddCallback(Callback callback) {\n+  void CheckOptions(const CallbackOptions& opts) {\n+    if (opts.should_schedule != ShouldSchedule::NEVER) {\n+      DCHECK_NE(opts.executor, NULL)\n+          << \"An executor must be specified when adding a callback that might schedule\";\n+    }\n+  }\n+\n+  void AddCallback(Callback callback, CallbackOptions opts) {\n+    CheckOptions(opts);\n     std::unique_lock<std::mutex> lock(mutex_);\n+    CallbackRecord callback_record{std::move(callback), opts};\n\nReview comment:\n       Why doesn't `AddCallback` directly take a `CallbackRecord`?\r\n   \n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -202,8 +202,30 @@ enum class FutureState : int8_t { PENDING, SUCCESS, FAILURE };\n \n inline bool IsFutureFinished(FutureState state) { return state != FutureState::PENDING; }\n \n+/// \\brief Describes whether the callback should be scheduled or run synchronously\n+enum ShouldSchedule {\n+  /// Always run the callback synchronously (the default)\n+  NEVER = 0,\n\nReview comment:\n       We should avoid using ALL_CAPS names, because of potential clashes with macros (this is a common issue with Windows headers, unfortunately).\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -272,8 +315,8 @@ class ConcreteFutureImpl : public FutureImpl {\n     //\n     // In fact, it is important not to hold the locks because the callback\n     // may be slow or do its own locking on other resources\n-    for (auto&& callback : callbacks_) {\n-      std::move(callback)();\n+    for (auto& callback_record : callbacks_) {\n+      RunOrScheduleCallback(callback_record, /*from_unfinished=*/true);\n\nReview comment:\n       Shouldn't `from_unfinished` be false?\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -952,6 +951,85 @@ TEST(FutureCompletionTest, FutureVoid) {\n   }\n }\n \n+class FutureSchedulingTest : public testing::Test {\n+ public:\n+  internal::Executor* executor() { return mock_executor.get(); }\n+  int spawn_count() { return mock_executor->spawn_count; }\n+\n+  std::function<void(const Status&)> callback = [](const Status&) {};\n+  std::shared_ptr<MockExecutor> mock_executor = std::make_shared<MockExecutor>();\n+};\n+\n+TEST_F(FutureSchedulingTest, ScheduleAlways) {\n+  CallbackOptions options;\n+  options.should_schedule = ShouldSchedule::ALWAYS;\n+  options.executor = executor();\n+  // Successful future\n+  {\n+    auto fut = Future<>::Make();\n+    fut.AddCallback(callback, options);\n+    fut.MarkFinished();\n+    fut.AddCallback(callback, options);\n+    ASSERT_EQ(2, spawn_count());\n+  }\n+  // Failing future\n+  {\n+    auto fut = Future<>::Make();\n+    fut.AddCallback(callback, options);\n+    fut.MarkFinished(Status::Invalid(\"XYZ\"));\n+    fut.AddCallback(callback, options);\n+    ASSERT_EQ(4, spawn_count());\n+  }\n+}\n+\n+TEST_F(FutureSchedulingTest, ScheduleIfUnfinished) {\n+  CallbackOptions options;\n+  options.should_schedule = ShouldSchedule::IF_UNFINISHED;\n\nReview comment:\n       NEVER is never tested?\n\n##########\nFile path: cpp/src/arrow/util/thread_pool_test.cc\n##########\n@@ -256,6 +258,42 @@ TEST_P(TestRunSynchronously, PropagatedError) {\n INSTANTIATE_TEST_SUITE_P(TestRunSynchronously, TestRunSynchronously,\n                          ::testing::Values(false, true));\n \n+class TransferTest : public testing::Test {\n+ public:\n+  internal::Executor* executor() { return mock_executor.get(); }\n+  int spawn_count() { return mock_executor->spawn_count; }\n+\n+  std::function<void(const Status&)> callback = [](const Status&) {};\n+  std::shared_ptr<MockExecutor> mock_executor = std::make_shared<MockExecutor>();\n+};\n+\n+TEST_F(TransferTest, DefaultTransferIfNotFinished) {\n+  {\n+    Future<> fut = Future<>::Make();\n+    auto transferred = executor()->Transfer(fut);\n+    fut.MarkFinished();\n+    ASSERT_FINISHES_OK(transferred);\n+    ASSERT_EQ(1, spawn_count());\n+  }\n+  {\n+    Future<> fut = Future<>::Make();\n+    fut.MarkFinished();\n+    auto transferred = executor()->Transfer(fut);\n+    ASSERT_FINISHES_OK(transferred);\n+    ASSERT_EQ(1, spawn_count());\n+  }\n+}\n+\n+TEST_F(TransferTest, TransferAlways) {\n+  {\n+    Future<> fut = Future<>::Make();\n+    fut.MarkFinished();\n+    auto transferred = executor()->Transfer(fut, /*always_transfer=*/true);\n\nReview comment:\n       Nit, but it would probably be nicer to be able to spell this as `TransferAlways(fut)`.\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -453,30 +480,35 @@ class Future {\n   /// cyclic reference to itself through the callback.\n   template <typename OnComplete>\n   typename std::enable_if<!detail::first_arg_is_status<OnComplete>::value>::type\n-  AddCallback(OnComplete on_complete) const {\n+  AddCallback(OnComplete on_complete,\n+              CallbackOptions opts = CallbackOptions::Defaults()) const {\n     // We know impl_ will not be dangling when invoking callbacks because at least one\n     // thread will be waiting for MarkFinished to return. Thus it's safe to keep a\n     // weak reference to impl_ here\n     struct Callback {\n-      void operator()() && { std::move(on_complete)(weak_self.get().result()); }\n-      WeakFuture<T> weak_self;\n+      void operator()(const FutureImpl& impl) && {\n+        std::move(on_complete)(*static_cast<Result<ValueType>*>(impl.result_.get()));\n+      }\n       OnComplete on_complete;\n     };\n-    impl_->AddCallback(Callback{WeakFuture<T>(*this), std::move(on_complete)});\n+    impl_->AddCallback(Callback{std::move(on_complete)}, opts);\n   }\n \n   /// Overload for callbacks accepting a Status\n   template <typename OnComplete>\n   typename std::enable_if<detail::first_arg_is_status<OnComplete>::value>::type\n-  AddCallback(OnComplete on_complete) const {\n+  AddCallback(OnComplete on_complete,\n+              CallbackOptions opts = CallbackOptions::Defaults()) const {\n     static_assert(std::is_same<internal::Empty, ValueType>::value,\n                   \"Callbacks for Future<> should accept Status and not Result\");\n     struct Callback {\n-      void operator()() && { std::move(on_complete)(weak_self.get().status()); }\n-      WeakFuture<T> weak_self;\n+      void operator()(const FutureImpl& impl) && {\n+        std::move(on_complete)(\n+            static_cast<Result<ValueType>*>(impl.result_.get())->status());\n\nReview comment:\n       Can you make the `static_cast<>` dance a method on `FutureImpl`?\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -952,6 +951,85 @@ TEST(FutureCompletionTest, FutureVoid) {\n   }\n }\n \n+class FutureSchedulingTest : public testing::Test {\n+ public:\n+  internal::Executor* executor() { return mock_executor.get(); }\n+  int spawn_count() { return mock_executor->spawn_count; }\n+\n+  std::function<void(const Status&)> callback = [](const Status&) {};\n+  std::shared_ptr<MockExecutor> mock_executor = std::make_shared<MockExecutor>();\n+};\n+\n+TEST_F(FutureSchedulingTest, ScheduleAlways) {\n+  CallbackOptions options;\n+  options.should_schedule = ShouldSchedule::ALWAYS;\n+  options.executor = executor();\n+  // Successful future\n+  {\n+    auto fut = Future<>::Make();\n+    fut.AddCallback(callback, options);\n+    fut.MarkFinished();\n+    fut.AddCallback(callback, options);\n+    ASSERT_EQ(2, spawn_count());\n+  }\n+  // Failing future\n+  {\n+    auto fut = Future<>::Make();\n+    fut.AddCallback(callback, options);\n+    fut.MarkFinished(Status::Invalid(\"XYZ\"));\n+    fut.AddCallback(callback, options);\n+    ASSERT_EQ(4, spawn_count());\n+  }\n+}\n+\n+TEST_F(FutureSchedulingTest, ScheduleIfUnfinished) {\n+  CallbackOptions options;\n+  options.should_schedule = ShouldSchedule::IF_UNFINISHED;\n+  options.executor = executor();\n+  // Successful future\n+  {\n+    auto fut = Future<>::Make();\n+    fut.AddCallback(callback, options);\n+    fut.MarkFinished();\n+    fut.AddCallback(callback, options);\n+    ASSERT_EQ(1, spawn_count());\n+  }\n+  // Failing future\n+  {\n+    auto fut = Future<>::Make();\n+    fut.AddCallback(callback, options);\n+    fut.MarkFinished(Status::Invalid(\"XYZ\"));\n+    fut.AddCallback(callback, options);\n+    ASSERT_EQ(2, spawn_count());\n+  }\n+}\n+\n+class DelayedExecutor : public internal::Executor {\n\nReview comment:\n       It's a bit weird to have this in a private test file, and the mock executor in a `.h`.\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -202,8 +202,30 @@ enum class FutureState : int8_t { PENDING, SUCCESS, FAILURE };\n \n inline bool IsFutureFinished(FutureState state) { return state != FutureState::PENDING; }\n \n+/// \\brief Describes whether the callback should be scheduled or run synchronously\n+enum ShouldSchedule {\n+  /// Always run the callback synchronously (the default)\n+  NEVER = 0,\n+  /// Schedule a new task only if the future is not finished when the\n+  /// callback is added\n+  IF_UNFINISHED = 1,\n+  /// Always schedule the callback as a new task\n+  ALWAYS = 2\n+};\n+\n+/// \\brief Options that control how a continuation is run\n+struct CallbackOptions {\n+  /// Describes whether the callback should be run synchronously or scheduled\n\nReview comment:\n       \"Describe\"\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-01T08:46:31.693+0000",
                    "updated": "2021-06-01T08:46:31.693+0000",
                    "started": "2021-06-01T08:46:31.692+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604375",
                    "issueId": "13375184"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/604917",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#discussion_r643625949\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -231,26 +232,68 @@ class ConcreteFutureImpl : public FutureImpl {\n \n   void DoMarkFailed() { DoMarkFinishedOrFailed(FutureState::FAILURE); }\n \n-  void AddCallback(Callback callback) {\n+  void CheckOptions(const CallbackOptions& opts) {\n+    if (opts.should_schedule != ShouldSchedule::NEVER) {\n+      DCHECK_NE(opts.executor, NULL)\n+          << \"An executor must be specified when adding a callback that might schedule\";\n+    }\n+  }\n+\n+  void AddCallback(Callback callback, CallbackOptions opts) {\n+    CheckOptions(opts);\n     std::unique_lock<std::mutex> lock(mutex_);\n+    CallbackRecord callback_record{std::move(callback), opts};\n     if (IsFutureFinished(state_)) {\n       lock.unlock();\n-      std::move(callback)();\n+      RunOrScheduleCallback(callback_record, /*from_unfinished=*/false);\n     } else {\n-      callbacks_.push_back(std::move(callback));\n+      callbacks_.push_back(std::move(callback_record));\n     }\n   }\n \n-  bool TryAddCallback(const std::function<Callback()>& callback_factory) {\n+  bool TryAddCallback(const std::function<Callback()>& callback_factory,\n+                      CallbackOptions opts) {\n+    CheckOptions(opts);\n     std::unique_lock<std::mutex> lock(mutex_);\n     if (IsFutureFinished(state_)) {\n       return false;\n     } else {\n-      callbacks_.push_back(callback_factory());\n+      callbacks_.push_back({callback_factory(), opts});\n       return true;\n     }\n   }\n \n+  bool ShouldSchedule(const CallbackRecord& callback_record, bool from_unfinished) {\n+    switch (callback_record.options.should_schedule) {\n+      case ShouldSchedule::NEVER:\n+        return false;\n+      case ShouldSchedule::ALWAYS:\n+        return true;\n+      case ShouldSchedule::IF_UNFINISHED:\n+        return from_unfinished;\n+      default:\n+        DCHECK(false) << \"Unrecognized ShouldSchedule option\";\n+        return false;\n+    }\n+  }\n+\n+  void RunOrScheduleCallback(CallbackRecord& callback_record, bool from_unfinished) {\n+    if (ShouldSchedule(callback_record, from_unfinished)) {\n+      // Need to make a copy of this to keep it alive until the callback has a chance\n\nReview comment:\n       The copy is a few lines down when we call `shared_from_this`.  I'll move the comment and make it more explicit.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T03:29:23.528+0000",
                    "updated": "2021-06-02T03:29:23.528+0000",
                    "started": "2021-06-02T03:29:23.528+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604917",
                    "issueId": "13375184"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/604918",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#discussion_r643628821\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -231,26 +232,68 @@ class ConcreteFutureImpl : public FutureImpl {\n \n   void DoMarkFailed() { DoMarkFinishedOrFailed(FutureState::FAILURE); }\n \n-  void AddCallback(Callback callback) {\n+  void CheckOptions(const CallbackOptions& opts) {\n+    if (opts.should_schedule != ShouldSchedule::NEVER) {\n+      DCHECK_NE(opts.executor, NULL)\n+          << \"An executor must be specified when adding a callback that might schedule\";\n+    }\n+  }\n+\n+  void AddCallback(Callback callback, CallbackOptions opts) {\n+    CheckOptions(opts);\n     std::unique_lock<std::mutex> lock(mutex_);\n+    CallbackRecord callback_record{std::move(callback), opts};\n     if (IsFutureFinished(state_)) {\n       lock.unlock();\n-      std::move(callback)();\n+      RunOrScheduleCallback(callback_record, /*from_unfinished=*/false);\n     } else {\n-      callbacks_.push_back(std::move(callback));\n+      callbacks_.push_back(std::move(callback_record));\n     }\n   }\n \n-  bool TryAddCallback(const std::function<Callback()>& callback_factory) {\n+  bool TryAddCallback(const std::function<Callback()>& callback_factory,\n+                      CallbackOptions opts) {\n+    CheckOptions(opts);\n     std::unique_lock<std::mutex> lock(mutex_);\n     if (IsFutureFinished(state_)) {\n       return false;\n     } else {\n-      callbacks_.push_back(callback_factory());\n+      callbacks_.push_back({callback_factory(), opts});\n       return true;\n     }\n   }\n \n+  bool ShouldSchedule(const CallbackRecord& callback_record, bool from_unfinished) {\n+    switch (callback_record.options.should_schedule) {\n+      case ShouldSchedule::NEVER:\n+        return false;\n+      case ShouldSchedule::ALWAYS:\n+        return true;\n+      case ShouldSchedule::IF_UNFINISHED:\n+        return from_unfinished;\n+      default:\n+        DCHECK(false) << \"Unrecognized ShouldSchedule option\";\n+        return false;\n+    }\n+  }\n+\n+  void RunOrScheduleCallback(CallbackRecord& callback_record, bool from_unfinished) {\n+    if (ShouldSchedule(callback_record, from_unfinished)) {\n+      // Need to make a copy of this to keep it alive until the callback has a chance\n+      // to be scheduled.\n+      struct CallbackTask {\n+        void operator()() { std::move(callback)(*self); }\n+\n+        Callback callback;\n+        std::shared_ptr<FutureImpl> self;\n\nReview comment:\n       The weak pointer in the old implementation was used to prevent futures from creating a circular reference on themselves (callback references future which references callback).\r\n   \r\n   Unfortunately, the weak pointer relied on the future remaining valid until all callbacks had run.  If all callbacks run synchronously this is easy (whomever is calling `MarkFinished` must have a valid reference until all callbacks finish).  Once we start scheduling callbacks we run into the problem where `MarkFinished` can return before some callbacks have run and then when those callbacks get scheduled the future has been deleted.\r\n   \r\n   This fix isn't just a change to a strong pointer though (that would introduce the circular reference problem again).  Instead of the callback itself having a reference to the future I changed it so that the callback took the FutureImpl in as an argument (note, this is the internal `FutureImpl` callback and not the publicly exposed `Future` callback).  This allowed me to avoid the circular reference because the strong pointer is created when the callback is being triggered and not when the callback is being added.\r\n   \r\n   Also, the strong pointer is only created if it is a scheduled callback.  Any existing performance should remain the same since no strong pointer of `shared_from_this` call is made.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T03:39:00.725+0000",
                    "updated": "2021-06-02T03:39:00.725+0000",
                    "started": "2021-06-02T03:39:00.725+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604918",
                    "issueId": "13375184"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/604919",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#discussion_r643630671\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -272,8 +315,8 @@ class ConcreteFutureImpl : public FutureImpl {\n     //\n     // In fact, it is important not to hold the locks because the callback\n     // may be slow or do its own locking on other resources\n-    for (auto&& callback : callbacks_) {\n-      std::move(callback)();\n+    for (auto& callback_record : callbacks_) {\n+      RunOrScheduleCallback(callback_record, /*from_unfinished=*/true);\n\nReview comment:\n       Hmm, `from_unfinished` is supposed to mean \"was the callback added when the future was unfinished\" but I can see how that is vague.  I could just remove this option entirely.  The `TryAddCallback` function already gives you this capability (it is used in `Transfer`) and so it isn't used anywhere.  Any strong opinion?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T03:45:31.965+0000",
                    "updated": "2021-06-02T03:45:31.965+0000",
                    "started": "2021-06-02T03:45:31.965+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604919",
                    "issueId": "13375184"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/604922",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#discussion_r643632152\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -202,8 +202,30 @@ enum class FutureState : int8_t { PENDING, SUCCESS, FAILURE };\n \n inline bool IsFutureFinished(FutureState state) { return state != FutureState::PENDING; }\n \n+/// \\brief Describes whether the callback should be scheduled or run synchronously\n+enum ShouldSchedule {\n+  /// Always run the callback synchronously (the default)\n+  NEVER = 0,\n\nReview comment:\n       Hmm, technically the style guide prefers `kAlways` but I see `Always` used more often in Arrow.  Although some of the gandiva code uses kAlways. (https://google.github.io/styleguide/cppguide.html#Enumerator_Names).  Any preference?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T03:50:44.793+0000",
                    "updated": "2021-06-02T03:50:44.793+0000",
                    "started": "2021-06-02T03:50:44.792+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604922",
                    "issueId": "13375184"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/604923",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#discussion_r643632996\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -272,8 +315,8 @@ class ConcreteFutureImpl : public FutureImpl {\n     //\n     // In fact, it is important not to hold the locks because the callback\n     // may be slow or do its own locking on other resources\n-    for (auto&& callback : callbacks_) {\n-      std::move(callback)();\n+    for (auto& callback_record : callbacks_) {\n+      RunOrScheduleCallback(callback_record, /*from_unfinished=*/true);\n\nReview comment:\n       On the bright side, if we remove `IF_UNFINISHED` then we can change `ShouldSchedule` to a `bool`.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T03:53:43.486+0000",
                    "updated": "2021-06-02T03:53:43.486+0000",
                    "started": "2021-06-02T03:53:43.486+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604923",
                    "issueId": "13375184"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/604924",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#discussion_r643634671\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -453,30 +480,35 @@ class Future {\n   /// cyclic reference to itself through the callback.\n   template <typename OnComplete>\n   typename std::enable_if<!detail::first_arg_is_status<OnComplete>::value>::type\n-  AddCallback(OnComplete on_complete) const {\n+  AddCallback(OnComplete on_complete,\n+              CallbackOptions opts = CallbackOptions::Defaults()) const {\n     // We know impl_ will not be dangling when invoking callbacks because at least one\n     // thread will be waiting for MarkFinished to return. Thus it's safe to keep a\n     // weak reference to impl_ here\n     struct Callback {\n-      void operator()() && { std::move(on_complete)(weak_self.get().result()); }\n-      WeakFuture<T> weak_self;\n+      void operator()(const FutureImpl& impl) && {\n+        std::move(on_complete)(*static_cast<Result<ValueType>*>(impl.result_.get()));\n+      }\n       OnComplete on_complete;\n     };\n-    impl_->AddCallback(Callback{WeakFuture<T>(*this), std::move(on_complete)});\n+    impl_->AddCallback(Callback{std::move(on_complete)}, opts);\n   }\n \n   /// Overload for callbacks accepting a Status\n   template <typename OnComplete>\n   typename std::enable_if<detail::first_arg_is_status<OnComplete>::value>::type\n-  AddCallback(OnComplete on_complete) const {\n+  AddCallback(OnComplete on_complete,\n+              CallbackOptions opts = CallbackOptions::Defaults()) const {\n     static_assert(std::is_same<internal::Empty, ValueType>::value,\n                   \"Callbacks for Future<> should accept Status and not Result\");\n     struct Callback {\n-      void operator()() && { std::move(on_complete)(weak_self.get().status()); }\n-      WeakFuture<T> weak_self;\n+      void operator()(const FutureImpl& impl) && {\n+        std::move(on_complete)(\n+            static_cast<Result<ValueType>*>(impl.result_.get())->status());\n\nReview comment:\n       It is a method on `Future` (named `GetResult`) but `FutureImpl` is type-erased and so it has no reference to `ValueType`.  If it were a `.cc` file I could extract it into an anonymous function but no luck there because of templates.  I think I can create a `future_internal.h`.  Would it be acceptable to create a method `GetResultFromFutureImpl` inside of `arrow::detail`?  Or is there some other trick I can use?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T03:59:28.507+0000",
                    "updated": "2021-06-02T03:59:28.507+0000",
                    "started": "2021-06-02T03:59:28.507+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604924",
                    "issueId": "13375184"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/604925",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#discussion_r643634671\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -453,30 +480,35 @@ class Future {\n   /// cyclic reference to itself through the callback.\n   template <typename OnComplete>\n   typename std::enable_if<!detail::first_arg_is_status<OnComplete>::value>::type\n-  AddCallback(OnComplete on_complete) const {\n+  AddCallback(OnComplete on_complete,\n+              CallbackOptions opts = CallbackOptions::Defaults()) const {\n     // We know impl_ will not be dangling when invoking callbacks because at least one\n     // thread will be waiting for MarkFinished to return. Thus it's safe to keep a\n     // weak reference to impl_ here\n     struct Callback {\n-      void operator()() && { std::move(on_complete)(weak_self.get().result()); }\n-      WeakFuture<T> weak_self;\n+      void operator()(const FutureImpl& impl) && {\n+        std::move(on_complete)(*static_cast<Result<ValueType>*>(impl.result_.get()));\n+      }\n       OnComplete on_complete;\n     };\n-    impl_->AddCallback(Callback{WeakFuture<T>(*this), std::move(on_complete)});\n+    impl_->AddCallback(Callback{std::move(on_complete)}, opts);\n   }\n \n   /// Overload for callbacks accepting a Status\n   template <typename OnComplete>\n   typename std::enable_if<detail::first_arg_is_status<OnComplete>::value>::type\n-  AddCallback(OnComplete on_complete) const {\n+  AddCallback(OnComplete on_complete,\n+              CallbackOptions opts = CallbackOptions::Defaults()) const {\n     static_assert(std::is_same<internal::Empty, ValueType>::value,\n                   \"Callbacks for Future<> should accept Status and not Result\");\n     struct Callback {\n-      void operator()() && { std::move(on_complete)(weak_self.get().status()); }\n-      WeakFuture<T> weak_self;\n+      void operator()(const FutureImpl& impl) && {\n+        std::move(on_complete)(\n+            static_cast<Result<ValueType>*>(impl.result_.get())->status());\n\nReview comment:\n       It is a method on `Future` (named `GetResult`) but `FutureImpl` is type-erased and so it has no reference to `ValueType`.  If it were a `.cc` file I could extract it into an anonymous function but no luck there because of templates.  Would it be acceptable to create a method `GetResultFromFutureImpl` inside of `arrow::detail`?  Or is there some other trick I can use?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T03:59:53.865+0000",
                    "updated": "2021-06-02T03:59:53.865+0000",
                    "started": "2021-06-02T03:59:53.865+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604925",
                    "issueId": "13375184"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/604927",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#discussion_r643636029\n\n\n\n##########\nFile path: cpp/src/arrow/util/test_common.h\n##########\n@@ -85,4 +88,18 @@ inline void AssertIteratorExhausted(Iterator<T>& it) {\n \n Transformer<TestInt, TestStr> MakeFilter(std::function<bool(TestInt&)> filter);\n \n+class MockExecutor : public internal::Executor {\n\nReview comment:\n       There is a bit of categorization based on folder (e.g. `util/test_common.h` vs `io/test_common.h`).  This file isn't really all that large.  However, it could probably be split into `test_iterator_common.h` and `test_thread_pool_common.h`.  Or am I missing the point?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T04:03:56.949+0000",
                    "updated": "2021-06-02T04:03:56.949+0000",
                    "started": "2021-06-02T04:03:56.949+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604927",
                    "issueId": "13375184"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/604928",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#discussion_r643636361\n\n\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -952,6 +951,85 @@ TEST(FutureCompletionTest, FutureVoid) {\n   }\n }\n \n+class FutureSchedulingTest : public testing::Test {\n+ public:\n+  internal::Executor* executor() { return mock_executor.get(); }\n+  int spawn_count() { return mock_executor->spawn_count; }\n+\n+  std::function<void(const Status&)> callback = [](const Status&) {};\n+  std::shared_ptr<MockExecutor> mock_executor = std::make_shared<MockExecutor>();\n+};\n+\n+TEST_F(FutureSchedulingTest, ScheduleAlways) {\n+  CallbackOptions options;\n+  options.should_schedule = ShouldSchedule::ALWAYS;\n+  options.executor = executor();\n+  // Successful future\n+  {\n+    auto fut = Future<>::Make();\n+    fut.AddCallback(callback, options);\n+    fut.MarkFinished();\n+    fut.AddCallback(callback, options);\n+    ASSERT_EQ(2, spawn_count());\n+  }\n+  // Failing future\n+  {\n+    auto fut = Future<>::Make();\n+    fut.AddCallback(callback, options);\n+    fut.MarkFinished(Status::Invalid(\"XYZ\"));\n+    fut.AddCallback(callback, options);\n+    ASSERT_EQ(4, spawn_count());\n+  }\n+}\n+\n+TEST_F(FutureSchedulingTest, ScheduleIfUnfinished) {\n+  CallbackOptions options;\n+  options.should_schedule = ShouldSchedule::IF_UNFINISHED;\n+  options.executor = executor();\n+  // Successful future\n+  {\n+    auto fut = Future<>::Make();\n+    fut.AddCallback(callback, options);\n+    fut.MarkFinished();\n+    fut.AddCallback(callback, options);\n+    ASSERT_EQ(1, spawn_count());\n+  }\n+  // Failing future\n+  {\n+    auto fut = Future<>::Make();\n+    fut.AddCallback(callback, options);\n+    fut.MarkFinished(Status::Invalid(\"XYZ\"));\n+    fut.AddCallback(callback, options);\n+    ASSERT_EQ(2, spawn_count());\n+  }\n+}\n+\n+class DelayedExecutor : public internal::Executor {\n\nReview comment:\n       My rationale was only that `DelayedExecutor` is only used in `future_test.cc` while `MockExecutor` is used in `future_test.cc` and `thread_pool_test.cc` but I see your point.  I'll move this into `test_common.h`.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T04:05:03.520+0000",
                    "updated": "2021-06-02T04:05:03.520+0000",
                    "started": "2021-06-02T04:05:03.520+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604928",
                    "issueId": "13375184"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/604929",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#issuecomment-852702836\n\n\n   @pitrou Don't worry about the delay, I've been plenty busy elsewhere.  I have a just a few follow-up questions and then I'll make the changes.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T04:07:02.491+0000",
                    "updated": "2021-06-02T04:07:02.491+0000",
                    "started": "2021-06-02T04:07:02.491+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604929",
                    "issueId": "13375184"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/604973",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#discussion_r643691040\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -453,30 +480,35 @@ class Future {\n   /// cyclic reference to itself through the callback.\n   template <typename OnComplete>\n   typename std::enable_if<!detail::first_arg_is_status<OnComplete>::value>::type\n-  AddCallback(OnComplete on_complete) const {\n+  AddCallback(OnComplete on_complete,\n+              CallbackOptions opts = CallbackOptions::Defaults()) const {\n     // We know impl_ will not be dangling when invoking callbacks because at least one\n     // thread will be waiting for MarkFinished to return. Thus it's safe to keep a\n     // weak reference to impl_ here\n     struct Callback {\n-      void operator()() && { std::move(on_complete)(weak_self.get().result()); }\n-      WeakFuture<T> weak_self;\n+      void operator()(const FutureImpl& impl) && {\n+        std::move(on_complete)(*static_cast<Result<ValueType>*>(impl.result_.get()));\n+      }\n       OnComplete on_complete;\n     };\n-    impl_->AddCallback(Callback{WeakFuture<T>(*this), std::move(on_complete)});\n+    impl_->AddCallback(Callback{std::move(on_complete)}, opts);\n   }\n \n   /// Overload for callbacks accepting a Status\n   template <typename OnComplete>\n   typename std::enable_if<detail::first_arg_is_status<OnComplete>::value>::type\n-  AddCallback(OnComplete on_complete) const {\n+  AddCallback(OnComplete on_complete,\n+              CallbackOptions opts = CallbackOptions::Defaults()) const {\n     static_assert(std::is_same<internal::Empty, ValueType>::value,\n                   \"Callbacks for Future<> should accept Status and not Result\");\n     struct Callback {\n-      void operator()() && { std::move(on_complete)(weak_self.get().status()); }\n-      WeakFuture<T> weak_self;\n+      void operator()(const FutureImpl& impl) && {\n+        std::move(on_complete)(\n+            static_cast<Result<ValueType>*>(impl.result_.get())->status());\n\nReview comment:\n       Ignore this.  I forgot type erased classes can still have templated functions.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T06:36:09.352+0000",
                    "updated": "2021-06-02T06:36:09.352+0000",
                    "started": "2021-06-02T06:36:09.352+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604973",
                    "issueId": "13375184"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/605178",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#discussion_r643959976\n\n\n\n##########\nFile path: cpp/src/arrow/util/test_common.h\n##########\n@@ -85,4 +88,18 @@ inline void AssertIteratorExhausted(Iterator<T>& it) {\n \n Transformer<TestInt, TestStr> MakeFilter(std::function<bool(TestInt&)> filter);\n \n+class MockExecutor : public internal::Executor {\n\nReview comment:\n       I think we have `arrow/testing/future_util.h`. We could move the mock executor into that file, or into a separate `arrow/testing/executor_util.h`.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T13:26:34.143+0000",
                    "updated": "2021-06-02T13:26:34.143+0000",
                    "started": "2021-06-02T13:26:34.143+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "605178",
                    "issueId": "13375184"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/605179",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#discussion_r643960575\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -202,8 +202,30 @@ enum class FutureState : int8_t { PENDING, SUCCESS, FAILURE };\n \n inline bool IsFutureFinished(FutureState state) { return state != FutureState::PENDING; }\n \n+/// \\brief Describes whether the callback should be scheduled or run synchronously\n+enum ShouldSchedule {\n+  /// Always run the callback synchronously (the default)\n+  NEVER = 0,\n\nReview comment:\n       `Always` sounds fine to me.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T13:27:09.326+0000",
                    "updated": "2021-06-02T13:27:09.326+0000",
                    "started": "2021-06-02T13:27:09.326+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "605179",
                    "issueId": "13375184"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/605181",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#discussion_r643961399\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -231,26 +232,68 @@ class ConcreteFutureImpl : public FutureImpl {\n \n   void DoMarkFailed() { DoMarkFinishedOrFailed(FutureState::FAILURE); }\n \n-  void AddCallback(Callback callback) {\n+  void CheckOptions(const CallbackOptions& opts) {\n+    if (opts.should_schedule != ShouldSchedule::NEVER) {\n+      DCHECK_NE(opts.executor, NULL)\n+          << \"An executor must be specified when adding a callback that might schedule\";\n+    }\n+  }\n+\n+  void AddCallback(Callback callback, CallbackOptions opts) {\n+    CheckOptions(opts);\n     std::unique_lock<std::mutex> lock(mutex_);\n+    CallbackRecord callback_record{std::move(callback), opts};\n     if (IsFutureFinished(state_)) {\n       lock.unlock();\n-      std::move(callback)();\n+      RunOrScheduleCallback(callback_record, /*from_unfinished=*/false);\n     } else {\n-      callbacks_.push_back(std::move(callback));\n+      callbacks_.push_back(std::move(callback_record));\n     }\n   }\n \n-  bool TryAddCallback(const std::function<Callback()>& callback_factory) {\n+  bool TryAddCallback(const std::function<Callback()>& callback_factory,\n+                      CallbackOptions opts) {\n+    CheckOptions(opts);\n     std::unique_lock<std::mutex> lock(mutex_);\n     if (IsFutureFinished(state_)) {\n       return false;\n     } else {\n-      callbacks_.push_back(callback_factory());\n+      callbacks_.push_back({callback_factory(), opts});\n       return true;\n     }\n   }\n \n+  bool ShouldSchedule(const CallbackRecord& callback_record, bool from_unfinished) {\n+    switch (callback_record.options.should_schedule) {\n+      case ShouldSchedule::NEVER:\n+        return false;\n+      case ShouldSchedule::ALWAYS:\n+        return true;\n+      case ShouldSchedule::IF_UNFINISHED:\n+        return from_unfinished;\n+      default:\n+        DCHECK(false) << \"Unrecognized ShouldSchedule option\";\n+        return false;\n+    }\n+  }\n+\n+  void RunOrScheduleCallback(CallbackRecord& callback_record, bool from_unfinished) {\n+    if (ShouldSchedule(callback_record, from_unfinished)) {\n+      // Need to make a copy of this to keep it alive until the callback has a chance\n\nReview comment:\n       If it's only the `shared_ptr` copy, then I'm not sure it's worth mentioning.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T13:28:08.601+0000",
                    "updated": "2021-06-02T13:28:08.601+0000",
                    "started": "2021-06-02T13:28:08.601+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "605181",
                    "issueId": "13375184"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/605182",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#discussion_r643962243\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -231,26 +232,68 @@ class ConcreteFutureImpl : public FutureImpl {\n \n   void DoMarkFailed() { DoMarkFinishedOrFailed(FutureState::FAILURE); }\n \n-  void AddCallback(Callback callback) {\n+  void CheckOptions(const CallbackOptions& opts) {\n+    if (opts.should_schedule != ShouldSchedule::NEVER) {\n+      DCHECK_NE(opts.executor, NULL)\n+          << \"An executor must be specified when adding a callback that might schedule\";\n+    }\n+  }\n+\n+  void AddCallback(Callback callback, CallbackOptions opts) {\n+    CheckOptions(opts);\n     std::unique_lock<std::mutex> lock(mutex_);\n+    CallbackRecord callback_record{std::move(callback), opts};\n     if (IsFutureFinished(state_)) {\n       lock.unlock();\n-      std::move(callback)();\n+      RunOrScheduleCallback(callback_record, /*from_unfinished=*/false);\n     } else {\n-      callbacks_.push_back(std::move(callback));\n+      callbacks_.push_back(std::move(callback_record));\n     }\n   }\n \n-  bool TryAddCallback(const std::function<Callback()>& callback_factory) {\n+  bool TryAddCallback(const std::function<Callback()>& callback_factory,\n+                      CallbackOptions opts) {\n+    CheckOptions(opts);\n     std::unique_lock<std::mutex> lock(mutex_);\n     if (IsFutureFinished(state_)) {\n       return false;\n     } else {\n-      callbacks_.push_back(callback_factory());\n+      callbacks_.push_back({callback_factory(), opts});\n       return true;\n     }\n   }\n \n+  bool ShouldSchedule(const CallbackRecord& callback_record, bool from_unfinished) {\n+    switch (callback_record.options.should_schedule) {\n+      case ShouldSchedule::NEVER:\n+        return false;\n+      case ShouldSchedule::ALWAYS:\n+        return true;\n+      case ShouldSchedule::IF_UNFINISHED:\n+        return from_unfinished;\n+      default:\n+        DCHECK(false) << \"Unrecognized ShouldSchedule option\";\n+        return false;\n+    }\n+  }\n+\n+  void RunOrScheduleCallback(CallbackRecord& callback_record, bool from_unfinished) {\n+    if (ShouldSchedule(callback_record, from_unfinished)) {\n+      // Need to make a copy of this to keep it alive until the callback has a chance\n+      // to be scheduled.\n+      struct CallbackTask {\n+        void operator()() { std::move(callback)(*self); }\n+\n+        Callback callback;\n+        std::shared_ptr<FutureImpl> self;\n\nReview comment:\n       Ah, ok. Thanks for the clarification.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T13:28:54.195+0000",
                    "updated": "2021-06-02T13:28:54.195+0000",
                    "started": "2021-06-02T13:28:54.195+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "605182",
                    "issueId": "13375184"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/worklog/605183",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10258:\nURL: https://github.com/apache/arrow/pull/10258#discussion_r643963486\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -272,8 +315,8 @@ class ConcreteFutureImpl : public FutureImpl {\n     //\n     // In fact, it is important not to hold the locks because the callback\n     // may be slow or do its own locking on other resources\n-    for (auto&& callback : callbacks_) {\n-      std::move(callback)();\n+    for (auto& callback_record : callbacks_) {\n+      RunOrScheduleCallback(callback_record, /*from_unfinished=*/true);\n\nReview comment:\n       I think `IfUnfinished` is ok, perhaps the `from_unfinished` variable needs better naming or an explanatory comment though :-)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T13:30:08.697+0000",
                    "updated": "2021-06-02T13:30:08.697+0000",
                    "started": "2021-06-02T13:30:08.696+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "605183",
                    "issueId": "13375184"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 19800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@ed123a2[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1e99de78[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@36c171ac[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@66fb1312[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@34020e51[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@512daab5[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6cdcfd2d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@52810027[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7655eca0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@4a1198dd[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@412f3127[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@1b75811d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 19800,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Jun 07 15:54:48 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-06-07T15:54:48.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12560/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2021-04-27T00:19:47.000+0000",
        "updated": "2021-06-07T15:54:48.000+0000",
        "timeoriginalestimate": null,
        "description": "Imagine there is a slow map function (that could run in parallel) and a vector generator given a long vector of tasks.\u00a0 If we apply map to the generator and then readahead we won't actually get any parallelism because the vector generator returns everything synchronously and so no thread task will ever be submitted.\r\n\r\nThis hypothetical situation is a reality in some situations in the scanner.\u00a0 For example, if scanning CSV files and the CPU threads fall behind the I/O threads then all callbacks will be synchronous (since the futures will already have been completed by the I/O threads).\r\n\r\nIn such a situation we might benefit from creating a new thread task even though we wouldn't normally create one.\u00a0 For example, if we have an idle core.\u00a0 You can think of this as an analogue of work stealing.\r\n\r\nOn the other hand, creating new thread tasks at any random callback might not be the most efficient. We could mitigate this by marking a callback as \"potentially long\" as some kind of hint when we add the callback to indicate it as eligible for eager thread creation.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "5.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 19800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Investigate utilizing aggressive thread task creation when adding callback to finished future",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/comment/17333037",
                    "id": "17333037",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "I don't understand. If you want parallelism, why not use the CPU thread pool?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-04-27T08:31:39.349+0000",
                    "updated": "2021-04-27T08:31:39.349+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/comment/17333511",
                    "id": "17333511",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "The problem is that we are using the CPU thread pool.\u00a0 So, imagine for a moment that we are able to parse/decode CSV blocks in parallel (this may indeed be possible someday so hopefully it isn't too hard to imagine).\r\n\r\nAlso imagine that we have some fixed block readahead of 10.\r\n\r\nThen we have something like the following (this is just rough pseudocode, we can assume ParseAndDecode is dropping the result in a vector somewhere and we aren't checking errors)...\r\n{code:java}\r\nfor (int i = 0; i < 10; i++)\r\n{\r\n\u00a0\u00a0\u00a0 source().Then(block => ParseAndDecode(block));\r\n}\r\n{code}\r\nWe want `source()` to be a background generator (reading along on its own I/O thread).\u00a0 We want `ParseAndDecode` to run on the CPU thread.\r\n\r\nEverything works fine if the I/O is slower than `ParseAndDecode`.\u00a0 Every call to `source()` returns an unfinished future and, when it is finished, we will transfer to the CPU pool (creating a new thread task) and run the thread task.\u00a0 So there will be 10 thread tasks for 10 blocks and some of those thread tasks may run in parallel (which is what we are after with parallel readahead here).\r\n\r\nOn the other hand, if I/O is faster than `ParseAndDecode` then calls to `source()` will start returning finished futures (the call to `Transfer` would have done nothing because the future was already finished).\u00a0 There is no need to transfer, we are already on the CPU thread pool.\u00a0 However, no thread task is created.\u00a0 The entire operation runs serially as a single thread task.\u00a0 In this case we want to create a new thread task to do our CPU work.\u00a0 The cost of `ParseAndDecode` is expensive so we know we aren't creating too many thread tasks.\u00a0 The main thread can then carry on and issue the next call to `source()`.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2021-04-27T19:39:50.132+0000",
                    "updated": "2021-04-27T19:39:50.132+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/comment/17333515",
                    "id": "17333515",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "I see, thanks. So, basically, our current transfer functionality doesn't work as expected. Perhaps we need a TransferAlways that does what we need here?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-04-27T19:48:43.750+0000",
                    "updated": "2021-04-27T19:48:43.750+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/comment/17333518",
                    "id": "17333518",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Yes, a `TransferAlways` would work.\u00a0 I tried a few iterations but they didn't work as intended.\u00a0 The thread task has to be spawned by the consumer in this case instead of the producer.\u00a0 One way it could work is by having `Transfer` \"mark\" the future in some way so that callbacks added to the future are always spawned as new thread tasks.\r\n\r\nThe utility could be more generally used outside of transfer (e.g. it could be used with an expensive map function to get a partitioned fan-out) but the synchronous utilities we have (e.g. TaskGroup) could achieve the same thing in those cases.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2021-04-27T19:56:18.136+0000",
                    "updated": "2021-04-27T19:56:18.136+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/comment/17333538",
                    "id": "17333538",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Actually, just to clarify, it wouldn't be `TransferAlways` exactly. If there are no CPU cores free then there is no advantage to transfer (and potentially a disadvantage of creating many excess thread tasks).",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2021-04-27T20:36:30.288+0000",
                    "updated": "2021-04-27T20:36:30.288+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/comment/17333540",
                    "id": "17333540",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Well, as you said, even if there are no CPU cores free, there may be still an advantage in requesting an IO before the callback actually runs.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-04-27T20:43:15.882+0000",
                    "updated": "2021-04-27T20:43:15.882+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375184/comment/17358681",
                    "id": "17358681",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 10258\n[https://github.com/apache/arrow/pull/10258]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-06-07T15:54:48.607+0000",
                    "updated": "2021-06-07T15:54:48.607+0000"
                }
            ],
            "maxResults": 7,
            "total": 7,
            "startAt": 0
        },
        "customfield_12311820": "0|z0qh2o:",
        "customfield_12314139": null
    }
}