{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13426731",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731",
    "key": "ARROW-15591",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351550",
                "id": "12351550",
                "name": "9.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-08-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available",
            "substrait"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=vibhatha",
            "name": "vibhatha",
            "key": "vibhatha",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
            },
            "displayName": "Vibhatha Lakmal Abeykoon",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 9600,
            "total": 9600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 9600,
            "total": 9600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15591/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 16,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/worklog/769663",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha opened a new pull request, #13130:\nURL: https://github.com/apache/arrow/pull/13130\n\n   Draft PR: The feature is not yet fully implemented. Working on figuring out a few missing pieces and ways to implement it clearly. \n\n\n",
                    "created": "2022-05-12T13:57:52.031+0000",
                    "updated": "2022-05-12T13:57:52.031+0000",
                    "started": "2022-05-12T13:57:52.030+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "769663",
                    "issueId": "13426731"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/worklog/769664",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13130:\nURL: https://github.com/apache/arrow/pull/13130#issuecomment-1125030496\n\n   https://issues.apache.org/jira/browse/ARROW-15591\n\n\n",
                    "created": "2022-05-12T13:58:17.360+0000",
                    "updated": "2022-05-12T13:58:17.360+0000",
                    "started": "2022-05-12T13:58:17.360+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "769664",
                    "issueId": "13426731"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/worklog/786863",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on PR #13130:\nURL: https://github.com/apache/arrow/pull/13130#issuecomment-1171742125\n\n   So I studied this a bit more and I also had a very poor understanding of the aggregate rel in the past.  Substrait's aggregate node is considerably more flexible than Acero's current implementation.  There will be some limitations.\r\n   \r\n    * Substrait's aggregate node supports \"grouping sets\" which is the ability to group by multiple sets of keys at the same time.  For example: https://www.db-fiddle.com/f/4QQnTGkyENZtxBKrWtimAT/0  Acero does not have support for grouping sets.\r\n      * If `AggregateRel::groupings` has more than 1 element then we should reject the plan.\r\n      * If someone needed to polyfill this behavior they could do so with a `UNION ALL` I believe (although I don't think we yet support the union node)\r\n    * Substrait's grouping keys can be arbitrary expressions.  Acero's grouping keys are `FieldRef`.\r\n      * All instances of `AggregateRel::groupings[0]::grouping_expressions` must be direct references or else we reject the plan.\r\n      * If someone needed to polyfill this behavior they could do so by first running a projection so that the expressions become fields to reference.\r\n    * Substrait's measures support filtering.  Acero does not support this.\r\n      * If any `AggregateRel::measures::filter` is specified then we should reject the plan.\r\n      * I do not believe this can be fixed with a straightforward polyfill, we should add a JIRA.\r\n    * Substrait's measures are potentially non-unary functions\r\n      * If any `AggregateRel::measures::measure::arguments` has size != 1 then we should reject the plan.\r\n      * I do not believe this can be fixed with a straightforward polyfill, however, there are not yet any standard aggregate functions defined which are non-unary.\r\n    * Substrait's measures take in arguments as expressions\r\n      * If any `AggregateRel::measures::measure::arguments` is not a direct reference then we should reject the plan.\r\n      * If someone needed to polyfill this behavior they could do so by first running a projection so that the expressions become fields to reference.\r\n   \r\n   So, the mapping between Acero's AggregateNodeOptions and Substrait's AggregateRel should be:\r\n   \r\n   *  `AggregateNodeOptions::keys[N] == AggregateRel::groupings[0]::grouping_expressions[N]::selection::struct_field::field`\r\n   * `AggregateNodeOptions::aggregates[N]::function == AggregateRel::measures[N]::measure::function_reference`\r\n   * `AggregateNodeOptions::aggregates[N]::options == IGNORE FOR NOW`\r\n   * `AggregateNodeOptions::aggregates[N]::target == AggregateRel::measures[N]::measure::arguments[0]::selection::struct_field::field`\r\n   * `AggregateNodeOptions::aggregates[N]::name == ALWAYS EMPTY`\n\n\n",
                    "created": "2022-06-30T22:37:18.058+0000",
                    "updated": "2022-06-30T22:37:18.058+0000",
                    "started": "2022-06-30T22:37:18.058+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "786863",
                    "issueId": "13426731"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/worklog/787718",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on PR #13130:\nURL: https://github.com/apache/arrow/pull/13130#issuecomment-1174485067\n\n   cc @westonpace \n\n\n",
                    "created": "2022-07-05T00:55:57.996+0000",
                    "updated": "2022-07-05T00:55:57.996+0000",
                    "started": "2022-07-05T00:55:57.995+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "787718",
                    "issueId": "13426731"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/worklog/788083",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13130:\nURL: https://github.com/apache/arrow/pull/13130#discussion_r914295005\n\n\n##########\ncpp/src/arrow/engine/substrait/relation_internal.cc:\n##########\n@@ -309,6 +309,75 @@ Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n       join_dec.inputs.emplace_back(std::move(right));\n       return std::move(join_dec);\n     }\n+    case substrait::Rel::RelTypeCase::kAggregate: {\n+      const auto& aggregate = rel.aggregate();\n+      RETURN_NOT_OK(CheckRelCommon(aggregate));\n+\n+      if (!aggregate.has_input()) {\n+        return Status::Invalid(\"substrait::AggregateRel with no input relation\");\n+      }\n+\n+      ARROW_ASSIGN_OR_RAISE(auto input, FromProto(aggregate.input(), ext_set));\n+\n+      if (aggregate.groupings_size() > 1) {\n+        return Status::Invalid(\"Grouping sets not supported.\");\n+      }\n+      std::vector<FieldRef> keys;\n+      auto group = aggregate.groupings(0);\n+      keys.reserve(group.grouping_expressions_size());\n+      for (int exp_id = 0; exp_id < group.grouping_expressions_size(); exp_id++) {\n+        const auto& expr = FromProto(group.grouping_expressions(exp_id), ext_set);\n\nReview Comment:\n   Use `ARROW_ASSIGN_OR_RAISE` here instead of using `->` later.  Otherwise, if something goes wrong converting the expression, it will result in an abort (which we don't want) instead of an invalid status (which we would want).\n\n\n\n##########\ncpp/src/arrow/engine/substrait/relation_internal.cc:\n##########\n@@ -309,6 +309,75 @@ Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n       join_dec.inputs.emplace_back(std::move(right));\n       return std::move(join_dec);\n     }\n+    case substrait::Rel::RelTypeCase::kAggregate: {\n+      const auto& aggregate = rel.aggregate();\n+      RETURN_NOT_OK(CheckRelCommon(aggregate));\n+\n+      if (!aggregate.has_input()) {\n+        return Status::Invalid(\"substrait::AggregateRel with no input relation\");\n+      }\n+\n+      ARROW_ASSIGN_OR_RAISE(auto input, FromProto(aggregate.input(), ext_set));\n+\n+      if (aggregate.groupings_size() > 1) {\n+        return Status::Invalid(\"Grouping sets not supported.\");\n+      }\n+      std::vector<FieldRef> keys;\n+      auto group = aggregate.groupings(0);\n+      keys.reserve(group.grouping_expressions_size());\n+      for (int exp_id = 0; exp_id < group.grouping_expressions_size(); exp_id++) {\n+        const auto& expr = FromProto(group.grouping_expressions(exp_id), ext_set);\n+        const auto& field_ref = expr->field_ref();\n\nReview Comment:\n   ```suggestion\r\n           const auto* field_ref = expr->field_ref();\r\n   ```\n\n\n\n##########\ncpp/src/arrow/engine/substrait/relation_internal.cc:\n##########\n@@ -309,6 +309,75 @@ Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n       join_dec.inputs.emplace_back(std::move(right));\n       return std::move(join_dec);\n     }\n+    case substrait::Rel::RelTypeCase::kAggregate: {\n+      const auto& aggregate = rel.aggregate();\n+      RETURN_NOT_OK(CheckRelCommon(aggregate));\n+\n+      if (!aggregate.has_input()) {\n+        return Status::Invalid(\"substrait::AggregateRel with no input relation\");\n+      }\n+\n+      ARROW_ASSIGN_OR_RAISE(auto input, FromProto(aggregate.input(), ext_set));\n+\n+      if (aggregate.groupings_size() > 1) {\n+        return Status::Invalid(\"Grouping sets not supported.\");\n\nReview Comment:\n   ```suggestion\r\n           return Status::NotImplemented(\"Grouping sets not supported.\");\r\n   ```\n\n\n\n##########\ncpp/src/arrow/engine/substrait/relation_internal.cc:\n##########\n@@ -309,6 +309,75 @@ Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n       join_dec.inputs.emplace_back(std::move(right));\n       return std::move(join_dec);\n     }\n+    case substrait::Rel::RelTypeCase::kAggregate: {\n+      const auto& aggregate = rel.aggregate();\n+      RETURN_NOT_OK(CheckRelCommon(aggregate));\n+\n+      if (!aggregate.has_input()) {\n+        return Status::Invalid(\"substrait::AggregateRel with no input relation\");\n+      }\n+\n+      ARROW_ASSIGN_OR_RAISE(auto input, FromProto(aggregate.input(), ext_set));\n+\n+      if (aggregate.groupings_size() > 1) {\n+        return Status::Invalid(\"Grouping sets not supported.\");\n+      }\n+      std::vector<FieldRef> keys;\n+      auto group = aggregate.groupings(0);\n+      keys.reserve(group.grouping_expressions_size());\n+      for (int exp_id = 0; exp_id < group.grouping_expressions_size(); exp_id++) {\n+        const auto& expr = FromProto(group.grouping_expressions(exp_id), ext_set);\n+        const auto& field_ref = expr->field_ref();\n+        if (field_ref) {\n+          keys.emplace_back(std::move(*field_ref));\n+        } else {\n+          return Status::Invalid(\n+              \"Only accept a direct reference as the grouping expression for aggregates\");\n+        }\n+      }\n+      // denotes how many unique aggregation functions are used\n+      // measure_id refers to the corresponding function in the\n+      // extensionsion\n+      int measure_size = aggregate.measures_size();\n+      std::vector<compute::Aggregate> aggregates;\n+      aggregates.reserve(measure_size);\n+      for (int measure_id = 0; measure_id < measure_size; measure_id++) {\n+        const auto& agg_measure = aggregate.measures(measure_id);\n+        if (agg_measure.has_measure()) {\n+          if (agg_measure.has_filter()) {\n+            return Status::Invalid(\"Aggregate filters are not supported.\");\n\nReview Comment:\n   ```suggestion\r\n               return Status::NotImplemented(\"Aggregate filters are not supported.\");\r\n   ```\n\n\n\n##########\ncpp/src/arrow/engine/substrait/relation_internal.cc:\n##########\n@@ -309,6 +309,75 @@ Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n       join_dec.inputs.emplace_back(std::move(right));\n       return std::move(join_dec);\n     }\n+    case substrait::Rel::RelTypeCase::kAggregate: {\n+      const auto& aggregate = rel.aggregate();\n+      RETURN_NOT_OK(CheckRelCommon(aggregate));\n+\n+      if (!aggregate.has_input()) {\n+        return Status::Invalid(\"substrait::AggregateRel with no input relation\");\n+      }\n+\n+      ARROW_ASSIGN_OR_RAISE(auto input, FromProto(aggregate.input(), ext_set));\n+\n+      if (aggregate.groupings_size() > 1) {\n+        return Status::Invalid(\"Grouping sets not supported.\");\n+      }\n+      std::vector<FieldRef> keys;\n+      auto group = aggregate.groupings(0);\n+      keys.reserve(group.grouping_expressions_size());\n+      for (int exp_id = 0; exp_id < group.grouping_expressions_size(); exp_id++) {\n+        const auto& expr = FromProto(group.grouping_expressions(exp_id), ext_set);\n+        const auto& field_ref = expr->field_ref();\n+        if (field_ref) {\n+          keys.emplace_back(std::move(*field_ref));\n+        } else {\n+          return Status::Invalid(\n+              \"Only accept a direct reference as the grouping expression for aggregates\");\n+        }\n+      }\n+      // denotes how many unique aggregation functions are used\n+      // measure_id refers to the corresponding function in the\n+      // extensionsion\n+      int measure_size = aggregate.measures_size();\n+      std::vector<compute::Aggregate> aggregates;\n+      aggregates.reserve(measure_size);\n+      for (int measure_id = 0; measure_id < measure_size; measure_id++) {\n+        const auto& agg_measure = aggregate.measures(measure_id);\n+        if (agg_measure.has_measure()) {\n+          if (agg_measure.has_filter()) {\n+            return Status::Invalid(\"Aggregate filters are not supported.\");\n+          }\n+          const auto& agg_func = agg_measure.measure();\n+          if (agg_func.args_size() != 1) {\n+            return Status::Invalid(\"Aggregate function must be a unary function.\");\n+          }\n+          int func_reference = agg_func.function_reference();\n+          ARROW_ASSIGN_OR_RAISE(auto func_record, ext_set.DecodeFunction(func_reference));\n+          // aggreagte function name\n+          auto func_name = std::string(func_record.id.name);\n+          // aggregate output column name\n+          std::string agg_col_name =\n+              func_name + \"(\" + std::to_string(func_reference) + \")\";\n\nReview Comment:\n   I'm not sure there is any advantage to giving these columns a name vs just leaving them as empty strings\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -443,8 +443,9 @@ struct DefaultExtensionIdRegistry : ExtensionIdRegistryImpl {\n     // ARROW-15535.\n     for (util::string_view name : {\n              \"add\",\n-             \"equal\",\n-             \"is_not_distinct_from\",\n+             \"equal\",                 // added to support join operator\n\nReview Comment:\n   The comments are probably not needed as this will change significantly in the function mapping PR but they don't hurt.\n\n\n\n##########\ncpp/src/arrow/engine/substrait/relation_internal.cc:\n##########\n@@ -309,6 +309,75 @@ Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n       join_dec.inputs.emplace_back(std::move(right));\n       return std::move(join_dec);\n     }\n+    case substrait::Rel::RelTypeCase::kAggregate: {\n+      const auto& aggregate = rel.aggregate();\n+      RETURN_NOT_OK(CheckRelCommon(aggregate));\n+\n+      if (!aggregate.has_input()) {\n+        return Status::Invalid(\"substrait::AggregateRel with no input relation\");\n+      }\n+\n+      ARROW_ASSIGN_OR_RAISE(auto input, FromProto(aggregate.input(), ext_set));\n+\n+      if (aggregate.groupings_size() > 1) {\n+        return Status::Invalid(\"Grouping sets not supported.\");\n+      }\n+      std::vector<FieldRef> keys;\n+      auto group = aggregate.groupings(0);\n+      keys.reserve(group.grouping_expressions_size());\n+      for (int exp_id = 0; exp_id < group.grouping_expressions_size(); exp_id++) {\n+        const auto& expr = FromProto(group.grouping_expressions(exp_id), ext_set);\n+        const auto& field_ref = expr->field_ref();\n+        if (field_ref) {\n+          keys.emplace_back(std::move(*field_ref));\n+        } else {\n+          return Status::Invalid(\n+              \"Only accept a direct reference as the grouping expression for aggregates\");\n+        }\n+      }\n+      // denotes how many unique aggregation functions are used\n+      // measure_id refers to the corresponding function in the\n+      // extensionsion\n\nReview Comment:\n   ```suggestion\r\n   ```\r\n   I'm not sure this comment is helpful.  Maybe something simple like \"A substrait measure is equivalent to an Acero aggregate\" but even that seems excessive\n\n\n\n##########\ncpp/src/arrow/engine/substrait/relation_internal.cc:\n##########\n@@ -309,6 +309,75 @@ Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n       join_dec.inputs.emplace_back(std::move(right));\n       return std::move(join_dec);\n     }\n+    case substrait::Rel::RelTypeCase::kAggregate: {\n+      const auto& aggregate = rel.aggregate();\n+      RETURN_NOT_OK(CheckRelCommon(aggregate));\n+\n+      if (!aggregate.has_input()) {\n+        return Status::Invalid(\"substrait::AggregateRel with no input relation\");\n+      }\n+\n+      ARROW_ASSIGN_OR_RAISE(auto input, FromProto(aggregate.input(), ext_set));\n+\n+      if (aggregate.groupings_size() > 1) {\n+        return Status::Invalid(\"Grouping sets not supported.\");\n+      }\n+      std::vector<FieldRef> keys;\n+      auto group = aggregate.groupings(0);\n+      keys.reserve(group.grouping_expressions_size());\n+      for (int exp_id = 0; exp_id < group.grouping_expressions_size(); exp_id++) {\n+        const auto& expr = FromProto(group.grouping_expressions(exp_id), ext_set);\n+        const auto& field_ref = expr->field_ref();\n+        if (field_ref) {\n+          keys.emplace_back(std::move(*field_ref));\n+        } else {\n+          return Status::Invalid(\n+              \"Only accept a direct reference as the grouping expression for aggregates\");\n\nReview Comment:\n   ```suggestion\r\n                 \"The grouping expression for an aggregate must be a direct reference.\");\r\n   ```\r\n   Minor nit: wording\n\n\n\n##########\ncpp/src/arrow/engine/substrait/relation_internal.cc:\n##########\n@@ -309,6 +309,75 @@ Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n       join_dec.inputs.emplace_back(std::move(right));\n       return std::move(join_dec);\n     }\n+    case substrait::Rel::RelTypeCase::kAggregate: {\n+      const auto& aggregate = rel.aggregate();\n+      RETURN_NOT_OK(CheckRelCommon(aggregate));\n+\n+      if (!aggregate.has_input()) {\n+        return Status::Invalid(\"substrait::AggregateRel with no input relation\");\n+      }\n+\n+      ARROW_ASSIGN_OR_RAISE(auto input, FromProto(aggregate.input(), ext_set));\n+\n+      if (aggregate.groupings_size() > 1) {\n+        return Status::Invalid(\"Grouping sets not supported.\");\n+      }\n+      std::vector<FieldRef> keys;\n+      auto group = aggregate.groupings(0);\n+      keys.reserve(group.grouping_expressions_size());\n+      for (int exp_id = 0; exp_id < group.grouping_expressions_size(); exp_id++) {\n+        const auto& expr = FromProto(group.grouping_expressions(exp_id), ext_set);\n+        const auto& field_ref = expr->field_ref();\n+        if (field_ref) {\n+          keys.emplace_back(std::move(*field_ref));\n+        } else {\n+          return Status::Invalid(\n+              \"Only accept a direct reference as the grouping expression for aggregates\");\n+        }\n+      }\n+      // denotes how many unique aggregation functions are used\n+      // measure_id refers to the corresponding function in the\n+      // extensionsion\n+      int measure_size = aggregate.measures_size();\n+      std::vector<compute::Aggregate> aggregates;\n+      aggregates.reserve(measure_size);\n+      for (int measure_id = 0; measure_id < measure_size; measure_id++) {\n+        const auto& agg_measure = aggregate.measures(measure_id);\n+        if (agg_measure.has_measure()) {\n+          if (agg_measure.has_filter()) {\n+            return Status::Invalid(\"Aggregate filters are not supported.\");\n+          }\n+          const auto& agg_func = agg_measure.measure();\n+          if (agg_func.args_size() != 1) {\n+            return Status::Invalid(\"Aggregate function must be a unary function.\");\n\nReview Comment:\n   ```suggestion\r\n               return Status::NotImplemented(\"Aggregate function must be a unary function.\");\r\n   ```\n\n\n\n##########\ncpp/src/arrow/engine/substrait/relation_internal.cc:\n##########\n@@ -309,6 +309,75 @@ Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n       join_dec.inputs.emplace_back(std::move(right));\n       return std::move(join_dec);\n     }\n+    case substrait::Rel::RelTypeCase::kAggregate: {\n+      const auto& aggregate = rel.aggregate();\n+      RETURN_NOT_OK(CheckRelCommon(aggregate));\n+\n+      if (!aggregate.has_input()) {\n+        return Status::Invalid(\"substrait::AggregateRel with no input relation\");\n+      }\n+\n+      ARROW_ASSIGN_OR_RAISE(auto input, FromProto(aggregate.input(), ext_set));\n+\n+      if (aggregate.groupings_size() > 1) {\n+        return Status::Invalid(\"Grouping sets not supported.\");\n+      }\n+      std::vector<FieldRef> keys;\n+      auto group = aggregate.groupings(0);\n+      keys.reserve(group.grouping_expressions_size());\n+      for (int exp_id = 0; exp_id < group.grouping_expressions_size(); exp_id++) {\n+        const auto& expr = FromProto(group.grouping_expressions(exp_id), ext_set);\n+        const auto& field_ref = expr->field_ref();\n+        if (field_ref) {\n+          keys.emplace_back(std::move(*field_ref));\n+        } else {\n+          return Status::Invalid(\n+              \"Only accept a direct reference as the grouping expression for aggregates\");\n+        }\n+      }\n+      // denotes how many unique aggregation functions are used\n+      // measure_id refers to the corresponding function in the\n+      // extensionsion\n+      int measure_size = aggregate.measures_size();\n+      std::vector<compute::Aggregate> aggregates;\n+      aggregates.reserve(measure_size);\n+      for (int measure_id = 0; measure_id < measure_size; measure_id++) {\n+        const auto& agg_measure = aggregate.measures(measure_id);\n+        if (agg_measure.has_measure()) {\n+          if (agg_measure.has_filter()) {\n+            return Status::Invalid(\"Aggregate filters are not supported.\");\n+          }\n+          const auto& agg_func = agg_measure.measure();\n+          if (agg_func.args_size() != 1) {\n+            return Status::Invalid(\"Aggregate function must be a unary function.\");\n+          }\n+          int func_reference = agg_func.function_reference();\n+          ARROW_ASSIGN_OR_RAISE(auto func_record, ext_set.DecodeFunction(func_reference));\n+          // aggreagte function name\n+          auto func_name = std::string(func_record.id.name);\n+          // aggregate output column name\n+          std::string agg_col_name =\n+              func_name + \"(\" + std::to_string(func_reference) + \")\";\n+          // aggregate target\n+          ARROW_ASSIGN_OR_RAISE(auto field_expr, FromProto(agg_func.args(0), ext_set));\n+          auto target = field_expr.field_ref();\n+          if (!target) {\n+            return Status::Invalid(\n+                \"Only accept a direct reference as the aggregate expression.\");\n+          }\n+          // TODO: Implement function options in Substrait\n\nReview Comment:\n   We shouldn't have a TODO without some kind of JIRA reference.  I'm not sure we need a TODO here though.  Maybe just get rid of this line and keep the next line about setting function options to nullptr.\n\n\n\n##########\ncpp/src/arrow/engine/substrait/relation_internal.cc:\n##########\n@@ -309,6 +309,75 @@ Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n       join_dec.inputs.emplace_back(std::move(right));\n       return std::move(join_dec);\n     }\n+    case substrait::Rel::RelTypeCase::kAggregate: {\n+      const auto& aggregate = rel.aggregate();\n+      RETURN_NOT_OK(CheckRelCommon(aggregate));\n+\n+      if (!aggregate.has_input()) {\n+        return Status::Invalid(\"substrait::AggregateRel with no input relation\");\n+      }\n+\n+      ARROW_ASSIGN_OR_RAISE(auto input, FromProto(aggregate.input(), ext_set));\n+\n+      if (aggregate.groupings_size() > 1) {\n+        return Status::Invalid(\"Grouping sets not supported.\");\n+      }\n+      std::vector<FieldRef> keys;\n+      auto group = aggregate.groupings(0);\n+      keys.reserve(group.grouping_expressions_size());\n+      for (int exp_id = 0; exp_id < group.grouping_expressions_size(); exp_id++) {\n+        const auto& expr = FromProto(group.grouping_expressions(exp_id), ext_set);\n+        const auto& field_ref = expr->field_ref();\n+        if (field_ref) {\n+          keys.emplace_back(std::move(*field_ref));\n+        } else {\n+          return Status::Invalid(\n+              \"Only accept a direct reference as the grouping expression for aggregates\");\n+        }\n+      }\n+      // denotes how many unique aggregation functions are used\n+      // measure_id refers to the corresponding function in the\n+      // extensionsion\n+      int measure_size = aggregate.measures_size();\n+      std::vector<compute::Aggregate> aggregates;\n+      aggregates.reserve(measure_size);\n+      for (int measure_id = 0; measure_id < measure_size; measure_id++) {\n+        const auto& agg_measure = aggregate.measures(measure_id);\n+        if (agg_measure.has_measure()) {\n+          if (agg_measure.has_filter()) {\n+            return Status::Invalid(\"Aggregate filters are not supported.\");\n+          }\n+          const auto& agg_func = agg_measure.measure();\n+          if (agg_func.args_size() != 1) {\n+            return Status::Invalid(\"Aggregate function must be a unary function.\");\n+          }\n+          int func_reference = agg_func.function_reference();\n+          ARROW_ASSIGN_OR_RAISE(auto func_record, ext_set.DecodeFunction(func_reference));\n+          // aggreagte function name\n+          auto func_name = std::string(func_record.id.name);\n+          // aggregate output column name\n+          std::string agg_col_name =\n+              func_name + \"(\" + std::to_string(func_reference) + \")\";\n+          // aggregate target\n+          ARROW_ASSIGN_OR_RAISE(auto field_expr, FromProto(agg_func.args(0), ext_set));\n+          auto target = field_expr.field_ref();\n+          if (!target) {\n+            return Status::Invalid(\n+                \"Only accept a direct reference as the aggregate expression.\");\n\nReview Comment:\n   ```suggestion\r\n                   \"The input expression to an aggregate function must be a direct reference.\");\r\n   ```\n\n\n\n",
                    "created": "2022-07-06T00:16:32.671+0000",
                    "updated": "2022-07-06T00:16:32.671+0000",
                    "started": "2022-07-06T00:16:32.671+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "788083",
                    "issueId": "13426731"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/worklog/788113",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on PR #13130:\nURL: https://github.com/apache/arrow/pull/13130#issuecomment-1175716618\n\n   > This looks correct. I have a few questions. Maybe it would be good to also add an end-to-end test now that we have Substrait working in python?\r\n   \r\n   @westonpace I was also thinking about this. I sort of roughly sketched it mentally like this. \r\n   \r\n   Create a test suite for substrait in Python where we use the `testing` dataset or any generated data to do the dataflow operations and add unit tests for each relation in a set of PRs. Since we have incorporated more relations now, I think a few small PRs can help with this. I will go ahead and add a JIRA to record this. By the way we were thinking about saving space for the lengthy strings required for creating Substrait plans. Is it in action now or if not we can integrate it later on. \n\n\n",
                    "created": "2022-07-06T02:43:39.713+0000",
                    "updated": "2022-07-06T02:43:39.713+0000",
                    "started": "2022-07-06T02:43:39.712+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "788113",
                    "issueId": "13426731"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/worklog/788114",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on code in PR #13130:\nURL: https://github.com/apache/arrow/pull/13130#discussion_r914365089\n\n\n##########\ncpp/src/arrow/engine/substrait/relation_internal.cc:\n##########\n@@ -309,6 +309,75 @@ Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n       join_dec.inputs.emplace_back(std::move(right));\n       return std::move(join_dec);\n     }\n+    case substrait::Rel::RelTypeCase::kAggregate: {\n+      const auto& aggregate = rel.aggregate();\n+      RETURN_NOT_OK(CheckRelCommon(aggregate));\n+\n+      if (!aggregate.has_input()) {\n+        return Status::Invalid(\"substrait::AggregateRel with no input relation\");\n+      }\n+\n+      ARROW_ASSIGN_OR_RAISE(auto input, FromProto(aggregate.input(), ext_set));\n+\n+      if (aggregate.groupings_size() > 1) {\n+        return Status::Invalid(\"Grouping sets not supported.\");\n+      }\n+      std::vector<FieldRef> keys;\n+      auto group = aggregate.groupings(0);\n+      keys.reserve(group.grouping_expressions_size());\n+      for (int exp_id = 0; exp_id < group.grouping_expressions_size(); exp_id++) {\n+        const auto& expr = FromProto(group.grouping_expressions(exp_id), ext_set);\n+        const auto& field_ref = expr->field_ref();\n+        if (field_ref) {\n+          keys.emplace_back(std::move(*field_ref));\n+        } else {\n+          return Status::Invalid(\n+              \"Only accept a direct reference as the grouping expression for aggregates\");\n+        }\n+      }\n+      // denotes how many unique aggregation functions are used\n+      // measure_id refers to the corresponding function in the\n+      // extensionsion\n+      int measure_size = aggregate.measures_size();\n+      std::vector<compute::Aggregate> aggregates;\n+      aggregates.reserve(measure_size);\n+      for (int measure_id = 0; measure_id < measure_size; measure_id++) {\n+        const auto& agg_measure = aggregate.measures(measure_id);\n+        if (agg_measure.has_measure()) {\n+          if (agg_measure.has_filter()) {\n+            return Status::Invalid(\"Aggregate filters are not supported.\");\n+          }\n+          const auto& agg_func = agg_measure.measure();\n+          if (agg_func.args_size() != 1) {\n+            return Status::Invalid(\"Aggregate function must be a unary function.\");\n+          }\n+          int func_reference = agg_func.function_reference();\n+          ARROW_ASSIGN_OR_RAISE(auto func_record, ext_set.DecodeFunction(func_reference));\n+          // aggreagte function name\n+          auto func_name = std::string(func_record.id.name);\n+          // aggregate output column name\n+          std::string agg_col_name =\n+              func_name + \"(\" + std::to_string(func_reference) + \")\";\n\nReview Comment:\n   You have a good point there, I just added it for some readability. We can ignore it too. \n\n\n\n",
                    "created": "2022-07-06T02:46:08.984+0000",
                    "updated": "2022-07-06T02:46:08.984+0000",
                    "started": "2022-07-06T02:46:08.984+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "788114",
                    "issueId": "13426731"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/worklog/788137",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on code in PR #13130:\nURL: https://github.com/apache/arrow/pull/13130#discussion_r914415771\n\n\n##########\ncpp/src/arrow/engine/substrait/relation_internal.cc:\n##########\n@@ -309,6 +309,75 @@ Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n       join_dec.inputs.emplace_back(std::move(right));\n       return std::move(join_dec);\n     }\n+    case substrait::Rel::RelTypeCase::kAggregate: {\n+      const auto& aggregate = rel.aggregate();\n+      RETURN_NOT_OK(CheckRelCommon(aggregate));\n+\n+      if (!aggregate.has_input()) {\n+        return Status::Invalid(\"substrait::AggregateRel with no input relation\");\n+      }\n+\n+      ARROW_ASSIGN_OR_RAISE(auto input, FromProto(aggregate.input(), ext_set));\n+\n+      if (aggregate.groupings_size() > 1) {\n+        return Status::Invalid(\"Grouping sets not supported.\");\n+      }\n+      std::vector<FieldRef> keys;\n+      auto group = aggregate.groupings(0);\n+      keys.reserve(group.grouping_expressions_size());\n+      for (int exp_id = 0; exp_id < group.grouping_expressions_size(); exp_id++) {\n+        const auto& expr = FromProto(group.grouping_expressions(exp_id), ext_set);\n\nReview Comment:\n   Ah, thanks for noting this.\n\n\n\n",
                    "created": "2022-07-06T04:58:32.814+0000",
                    "updated": "2022-07-06T04:58:32.814+0000",
                    "started": "2022-07-06T04:58:32.814+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "788137",
                    "issueId": "13426731"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/worklog/789724",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13130:\nURL: https://github.com/apache/arrow/pull/13130#discussion_r918293275\n\n\n##########\ncpp/src/arrow/engine/substrait/relation_internal.cc:\n##########\n@@ -308,6 +308,71 @@ Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n       join_dec.inputs.emplace_back(std::move(right));\n       return std::move(join_dec);\n     }\n+    case substrait::Rel::RelTypeCase::kAggregate: {\n+      const auto& aggregate = rel.aggregate();\n+      RETURN_NOT_OK(CheckRelCommon(aggregate));\n+\n+      if (!aggregate.has_input()) {\n+        return Status::Invalid(\"substrait::AggregateRel with no input relation\");\n+      }\n+\n+      ARROW_ASSIGN_OR_RAISE(auto input, FromProto(aggregate.input(), ext_set));\n+\n+      if (aggregate.groupings_size() > 1) {\n+        return Status::NotImplemented(\"Grouping sets not supported.\");\n+      }\n+      std::vector<FieldRef> keys;\n+      auto group = aggregate.groupings(0);\n+      keys.reserve(group.grouping_expressions_size());\n+      for (int exp_id = 0; exp_id < group.grouping_expressions_size(); exp_id++) {\n+        ARROW_ASSIGN_OR_RAISE(auto expr,\n+                              FromProto(group.grouping_expressions(exp_id), ext_set));\n+        const auto* field_ref = expr.field_ref();\n+        if (field_ref) {\n+          keys.emplace_back(std::move(*field_ref));\n+        } else {\n+          return Status::Invalid(\n+              \"The grouping expression for an aggregate must be a direct reference.\");\n+        }\n+      }\n+\n+      int measure_size = aggregate.measures_size();\n+      std::vector<compute::Aggregate> aggregates;\n+      aggregates.reserve(measure_size);\n+      for (int measure_id = 0; measure_id < measure_size; measure_id++) {\n+        const auto& agg_measure = aggregate.measures(measure_id);\n+        if (agg_measure.has_measure()) {\n+          if (agg_measure.has_filter()) {\n+            return Status::NotImplemented(\"Aggregate filters are not supported.\");\n+          }\n+          const auto& agg_func = agg_measure.measure();\n+          if (agg_func.arguments_size() != 1) {\n+            return Status::NotImplemented(\"Aggregate function must be a unary function.\");\n+          }\n+          int func_reference = agg_func.function_reference();\n+          ARROW_ASSIGN_OR_RAISE(auto func_record, ext_set.DecodeFunction(func_reference));\n+          // aggreagte function name\n+          auto func_name = std::string(func_record.id.name);\n+          // aggregate target\n+          auto subs_func_args = agg_func.arguments(0);\n+          ARROW_ASSIGN_OR_RAISE(auto field_expr,\n+                                FromProto(subs_func_args.value(), ext_set));\n+          auto target = field_expr.field_ref();\n+          if (!target) {\n+            return Status::Invalid(\n+                \"The input expression to an aggregate function must be a direct \"\n+                \"reference.\");\n+          }\n+          aggregates.emplace_back(compute::Aggregate{std::move(func_name), NULLPTR,\n+                                                     std::move(*target), std::move(\"\")});\n\nReview Comment:\n   ```suggestion\r\n             aggregates.emplace_back(compute::Aggregate{std::move(func_name), NULLPTR,\r\n                                                        std::move(*target), std::move(\"\")});\r\n   ```\r\n   \r\n   Minor nit.  It might be better to use:\r\n   \r\n   ```\r\n             // If you are going to create the instance yourself you can just use push_back\r\n             aggregates.push_back(compute::Aggregate{std::move(func_name), NULLPTR,\r\n                                                        std::move(*target), std::move(\"\")});\r\n   ```\r\n   \r\n   or...\r\n   \r\n   ```\r\n             // If you are using emplace_back you do not need to create the instance\r\n             // yourself.\r\n             aggregates.emplace_back(std::move(func_name), NULLPTR,\r\n                                                        std::move(*target), std::move(\"\"));\r\n   ```\n\n\n\n##########\ncpp/src/arrow/engine/substrait/relation_internal.cc:\n##########\n@@ -308,6 +308,71 @@ Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n       join_dec.inputs.emplace_back(std::move(right));\n       return std::move(join_dec);\n     }\n+    case substrait::Rel::RelTypeCase::kAggregate: {\n+      const auto& aggregate = rel.aggregate();\n+      RETURN_NOT_OK(CheckRelCommon(aggregate));\n+\n+      if (!aggregate.has_input()) {\n+        return Status::Invalid(\"substrait::AggregateRel with no input relation\");\n+      }\n+\n+      ARROW_ASSIGN_OR_RAISE(auto input, FromProto(aggregate.input(), ext_set));\n+\n+      if (aggregate.groupings_size() > 1) {\n+        return Status::NotImplemented(\"Grouping sets not supported.\");\n\nReview Comment:\n   ```suggestion\r\n           return Status::NotImplemented(\"Grouping sets not supported.  AggregateRel::groupings may not have more than one item\");\r\n   ```\r\n   \r\n   Minor nit: If someone gets this error they might not immediately realize how to modify the substrait plan to support Acero.\n\n\n\n##########\ncpp/src/arrow/engine/substrait/serde_test.cc:\n##########\n@@ -1383,5 +1383,350 @@ TEST(Substrait, JoinPlanInvalidKeys) {\n   }\n }\n \n+TEST(Substrait, AggregateBase) {\n\nReview Comment:\n   ```suggestion\r\n   TEST(Substrait, AggregateBasic) {\r\n   ```\r\n   \r\n   Minor nit: `Base` might lead one to think that this is meant to be extended somehow.\n\n\n\n##########\ncpp/src/arrow/engine/substrait/serde_test.cc:\n##########\n@@ -1383,5 +1383,350 @@ TEST(Substrait, JoinPlanInvalidKeys) {\n   }\n }\n \n+TEST(Substrait, AggregateBase) {\n+  ASSERT_OK_AND_ASSIGN(auto buf, internal::SubstraitFromJSON(\"Plan\", R\"({\n+    \"relations\": [{\n+      \"rel\": {\n+        \"aggregate\": {\n+          \"input\": {\n+            \"read\": {\n+              \"base_schema\": {\n+                \"names\": [\"A\", \"B\", \"C\"],\n+                \"struct\": {\n+                  \"types\": [{\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }]\n+                }\n+              },\n+              \"local_files\": { \n+                \"items\": [\n+                  {\n+                    \"uri_file\": \"file:///tmp/dat.parquet\",\n+                    \"parquet\": {}\n+                  }\n+                ]\n+              }\n+            }\n+          },\n+          \"groupings\": [{\n+            \"groupingExpressions\": [{\n+              \"selection\": {\n+                \"directReference\": {\n+                  \"structField\": {\n+                    \"field\": 0\n+                  }\n+                }\n+              }\n+            }]\n+          }],\n+          \"measures\": [{\n+            \"measure\": {\n+              \"functionReference\": 0,\n+              \"arguments\": [{\n+                \"value\": {\n+                  \"selection\": {\n+                    \"directReference\": {\n+                      \"structField\": {\n+                        \"field\": 1\n+                      }\n+                    }\n+                  }\n+                }\n+            }],\n+              \"sorts\": [],\n+              \"phase\": \"AGGREGATION_PHASE_INITIAL_TO_RESULT\",\n+              \"outputType\": {\n+                \"i64\": {}\n+              }\n+            }\n+          }]\n+        }\n+      }\n+    }],\n+    \"extensionUris\": [{\n+      \"extension_uri_anchor\": 0,\n+      \"uri\": \"https://github.com/apache/arrow/blob/master/format/substrait/extension_types.yaml\"\n+    }],\n+    \"extensions\": [{\n+      \"extension_function\": {\n+        \"extension_uri_reference\": 0,\n+        \"function_anchor\": 0,\n+        \"name\": \"count\"\n\nReview Comment:\n   This plan wouldn't actually work I think.  Since there is a grouping it will be a hash aggregate and will need to use `hash_count` instead of `count`.  However, we are not running the test end-to-end so I think we get away with it.  Still, might be nice to update it to be accurate.\n\n\n\n",
                    "created": "2022-07-11T19:54:22.748+0000",
                    "updated": "2022-07-11T19:54:22.748+0000",
                    "started": "2022-07-11T19:54:22.747+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789724",
                    "issueId": "13426731"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/worklog/790310",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on code in PR #13130:\nURL: https://github.com/apache/arrow/pull/13130#discussion_r919761437\n\n\n##########\ncpp/src/arrow/engine/substrait/relation_internal.cc:\n##########\n@@ -308,6 +308,71 @@ Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n       join_dec.inputs.emplace_back(std::move(right));\n       return std::move(join_dec);\n     }\n+    case substrait::Rel::RelTypeCase::kAggregate: {\n+      const auto& aggregate = rel.aggregate();\n+      RETURN_NOT_OK(CheckRelCommon(aggregate));\n+\n+      if (!aggregate.has_input()) {\n+        return Status::Invalid(\"substrait::AggregateRel with no input relation\");\n+      }\n+\n+      ARROW_ASSIGN_OR_RAISE(auto input, FromProto(aggregate.input(), ext_set));\n+\n+      if (aggregate.groupings_size() > 1) {\n+        return Status::NotImplemented(\"Grouping sets not supported.\");\n+      }\n+      std::vector<FieldRef> keys;\n+      auto group = aggregate.groupings(0);\n+      keys.reserve(group.grouping_expressions_size());\n+      for (int exp_id = 0; exp_id < group.grouping_expressions_size(); exp_id++) {\n+        ARROW_ASSIGN_OR_RAISE(auto expr,\n+                              FromProto(group.grouping_expressions(exp_id), ext_set));\n+        const auto* field_ref = expr.field_ref();\n+        if (field_ref) {\n+          keys.emplace_back(std::move(*field_ref));\n+        } else {\n+          return Status::Invalid(\n+              \"The grouping expression for an aggregate must be a direct reference.\");\n+        }\n+      }\n+\n+      int measure_size = aggregate.measures_size();\n+      std::vector<compute::Aggregate> aggregates;\n+      aggregates.reserve(measure_size);\n+      for (int measure_id = 0; measure_id < measure_size; measure_id++) {\n+        const auto& agg_measure = aggregate.measures(measure_id);\n+        if (agg_measure.has_measure()) {\n+          if (agg_measure.has_filter()) {\n+            return Status::NotImplemented(\"Aggregate filters are not supported.\");\n+          }\n+          const auto& agg_func = agg_measure.measure();\n+          if (agg_func.arguments_size() != 1) {\n+            return Status::NotImplemented(\"Aggregate function must be a unary function.\");\n+          }\n+          int func_reference = agg_func.function_reference();\n+          ARROW_ASSIGN_OR_RAISE(auto func_record, ext_set.DecodeFunction(func_reference));\n+          // aggreagte function name\n+          auto func_name = std::string(func_record.id.name);\n+          // aggregate target\n+          auto subs_func_args = agg_func.arguments(0);\n+          ARROW_ASSIGN_OR_RAISE(auto field_expr,\n+                                FromProto(subs_func_args.value(), ext_set));\n+          auto target = field_expr.field_ref();\n+          if (!target) {\n+            return Status::Invalid(\n+                \"The input expression to an aggregate function must be a direct \"\n+                \"reference.\");\n+          }\n+          aggregates.emplace_back(compute::Aggregate{std::move(func_name), NULLPTR,\n+                                                     std::move(*target), std::move(\"\")});\n\nReview Comment:\n   Can we do it without the move constructor deifned?\n\n\n\n",
                    "created": "2022-07-13T07:50:41.872+0000",
                    "updated": "2022-07-13T07:50:41.872+0000",
                    "started": "2022-07-13T07:50:41.871+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "790310",
                    "issueId": "13426731"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/worklog/792073",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13130:\nURL: https://github.com/apache/arrow/pull/13130#discussion_r923297309\n\n\n##########\ncpp/src/arrow/engine/substrait/serde_test.cc:\n##########\n@@ -1383,5 +1383,350 @@ TEST(Substrait, JoinPlanInvalidKeys) {\n   }\n }\n \n+TEST(Substrait, AggregateBasic) {\n+  ASSERT_OK_AND_ASSIGN(auto buf, internal::SubstraitFromJSON(\"Plan\", R\"({\n+    \"relations\": [{\n+      \"rel\": {\n+        \"aggregate\": {\n+          \"input\": {\n+            \"read\": {\n+              \"base_schema\": {\n+                \"names\": [\"A\", \"B\", \"C\"],\n+                \"struct\": {\n+                  \"types\": [{\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }]\n+                }\n+              },\n+              \"local_files\": { \n+                \"items\": [\n+                  {\n+                    \"uri_file\": \"file:///tmp/dat.parquet\",\n+                    \"parquet\": {}\n+                  }\n+                ]\n+              }\n+            }\n+          },\n+          \"groupings\": [{\n+            \"groupingExpressions\": [{\n+              \"selection\": {\n+                \"directReference\": {\n+                  \"structField\": {\n+                    \"field\": 0\n+                  }\n+                }\n+              }\n+            }]\n+          }],\n+          \"measures\": [{\n+            \"measure\": {\n+              \"functionReference\": 0,\n+              \"arguments\": [{\n+                \"value\": {\n+                  \"selection\": {\n+                    \"directReference\": {\n+                      \"structField\": {\n+                        \"field\": 1\n+                      }\n+                    }\n+                  }\n+                }\n+            }],\n+              \"sorts\": [],\n+              \"phase\": \"AGGREGATION_PHASE_INITIAL_TO_RESULT\",\n+              \"outputType\": {\n+                \"i64\": {}\n+              }\n+            }\n+          }]\n+        }\n+      }\n+    }],\n+    \"extensionUris\": [{\n+      \"extension_uri_anchor\": 0,\n+      \"uri\": \"https://github.com/apache/arrow/blob/master/format/substrait/extension_types.yaml\"\n+    }],\n+    \"extensions\": [{\n+      \"extension_function\": {\n+        \"extension_uri_reference\": 0,\n+        \"function_anchor\": 0,\n+        \"name\": \"hash_count\"\n+      }\n+    }],\n+  })\"));\n+\n+  auto sp_ext_id_reg = substrait::MakeExtensionIdRegistry();\n+  ExtensionIdRegistry* ext_id_reg = sp_ext_id_reg.get();\n+  // invalid before registration\n+  ExtensionSet ext_set_invalid(ext_id_reg);\n+  ASSERT_OK_AND_ASSIGN(auto sink_decls, DeserializePlans(\n+                                            *buf, [] { return kNullConsumer; },\n+                                            ext_id_reg, &ext_set_invalid));\n\nReview Comment:\n   ```suggestion\r\n     ASSERT_OK_AND_ASSIGN(auto sink_decls, DeserializePlans(\r\n                                               *buf, [] { return kNullConsumer; });\r\n   ```\r\n   \r\n   The third argument (`ext_id_reg`) is optional if you want to just use the default extension registry (which should be fine for this test).  The fourth argument `&ext_set_invalid` is an out-parameter, and also optional, so not needed for this test.\n\n\n\n##########\ncpp/src/arrow/engine/substrait/serde_test.cc:\n##########\n@@ -1383,5 +1383,350 @@ TEST(Substrait, JoinPlanInvalidKeys) {\n   }\n }\n \n+TEST(Substrait, AggregateBasic) {\n+  ASSERT_OK_AND_ASSIGN(auto buf, internal::SubstraitFromJSON(\"Plan\", R\"({\n+    \"relations\": [{\n+      \"rel\": {\n+        \"aggregate\": {\n+          \"input\": {\n+            \"read\": {\n+              \"base_schema\": {\n+                \"names\": [\"A\", \"B\", \"C\"],\n+                \"struct\": {\n+                  \"types\": [{\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }]\n+                }\n+              },\n+              \"local_files\": { \n+                \"items\": [\n+                  {\n+                    \"uri_file\": \"file:///tmp/dat.parquet\",\n+                    \"parquet\": {}\n+                  }\n+                ]\n+              }\n+            }\n+          },\n+          \"groupings\": [{\n+            \"groupingExpressions\": [{\n+              \"selection\": {\n+                \"directReference\": {\n+                  \"structField\": {\n+                    \"field\": 0\n+                  }\n+                }\n+              }\n+            }]\n+          }],\n+          \"measures\": [{\n+            \"measure\": {\n+              \"functionReference\": 0,\n+              \"arguments\": [{\n+                \"value\": {\n+                  \"selection\": {\n+                    \"directReference\": {\n+                      \"structField\": {\n+                        \"field\": 1\n+                      }\n+                    }\n+                  }\n+                }\n+            }],\n+              \"sorts\": [],\n+              \"phase\": \"AGGREGATION_PHASE_INITIAL_TO_RESULT\",\n+              \"outputType\": {\n+                \"i64\": {}\n+              }\n+            }\n+          }]\n+        }\n+      }\n+    }],\n+    \"extensionUris\": [{\n+      \"extension_uri_anchor\": 0,\n+      \"uri\": \"https://github.com/apache/arrow/blob/master/format/substrait/extension_types.yaml\"\n+    }],\n+    \"extensions\": [{\n+      \"extension_function\": {\n+        \"extension_uri_reference\": 0,\n+        \"function_anchor\": 0,\n+        \"name\": \"hash_count\"\n+      }\n+    }],\n+  })\"));\n+\n+  auto sp_ext_id_reg = substrait::MakeExtensionIdRegistry();\n+  ExtensionIdRegistry* ext_id_reg = sp_ext_id_reg.get();\n+  // invalid before registration\n+  ExtensionSet ext_set_invalid(ext_id_reg);\n+  ASSERT_OK_AND_ASSIGN(auto sink_decls, DeserializePlans(\n+                                            *buf, [] { return kNullConsumer; },\n+                                            ext_id_reg, &ext_set_invalid));\n+  auto agg_decl = sink_decls[0].inputs[0];\n+\n+  const auto& agg_rel = agg_decl.get<compute::Declaration>();\n+\n+  const auto& agg_options =\n+      checked_cast<const compute::AggregateNodeOptions&>(*agg_rel->options);\n+\n+  EXPECT_EQ(agg_rel->factory_name, \"aggregate\");\n+  EXPECT_EQ(agg_options.aggregates[0].name, \"\");\n+  EXPECT_EQ(agg_options.aggregates[0].function, \"hash_count\");\n+}\n+\n+TEST(Substrait, AggregateInvalidRel) {\n+  ASSERT_OK_AND_ASSIGN(auto buf, internal::SubstraitFromJSON(\"Plan\", R\"({\n+    \"relations\": [{\n+      \"rel\": {\n+        \"aggregate\": {\n+        }\n+      }\n+    }],\n+    \"extensionUris\": [{\n+      \"extension_uri_anchor\": 0,\n+      \"uri\": \"https://github.com/apache/arrow/blob/master/format/substrait/extension_types.yaml\"\n+    }],\n+    \"extensions\": [{\n+      \"extension_function\": {\n+        \"extension_uri_reference\": 0,\n+        \"function_anchor\": 0,\n+        \"name\": \"hash_count\"\n+      }\n+    }],\n+  })\"));\n+\n+  auto sp_ext_id_reg = substrait::MakeExtensionIdRegistry();\n+  ExtensionIdRegistry* ext_id_reg = sp_ext_id_reg.get();\n+  // invalid before registration\n+  ExtensionSet ext_set_invalid(ext_id_reg);\n+  ASSERT_RAISES(Invalid,\n+                DeserializePlans(\n+                    *buf, [] { return kNullConsumer; }, ext_id_reg, &ext_set_invalid));\n\nReview Comment:\n   ```suggestion\r\n     ASSERT_RAISES(Invalid,\r\n                   DeserializePlans(\r\n                       *buf, [] { return kNullConsumer; }));\r\n   ```\n\n\n\n##########\ncpp/src/arrow/engine/substrait/serde_test.cc:\n##########\n@@ -1383,5 +1383,350 @@ TEST(Substrait, JoinPlanInvalidKeys) {\n   }\n }\n \n+TEST(Substrait, AggregateBasic) {\n+  ASSERT_OK_AND_ASSIGN(auto buf, internal::SubstraitFromJSON(\"Plan\", R\"({\n+    \"relations\": [{\n+      \"rel\": {\n+        \"aggregate\": {\n+          \"input\": {\n+            \"read\": {\n+              \"base_schema\": {\n+                \"names\": [\"A\", \"B\", \"C\"],\n+                \"struct\": {\n+                  \"types\": [{\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }]\n+                }\n+              },\n+              \"local_files\": { \n+                \"items\": [\n+                  {\n+                    \"uri_file\": \"file:///tmp/dat.parquet\",\n+                    \"parquet\": {}\n+                  }\n+                ]\n+              }\n+            }\n+          },\n+          \"groupings\": [{\n+            \"groupingExpressions\": [{\n+              \"selection\": {\n+                \"directReference\": {\n+                  \"structField\": {\n+                    \"field\": 0\n+                  }\n+                }\n+              }\n+            }]\n+          }],\n+          \"measures\": [{\n+            \"measure\": {\n+              \"functionReference\": 0,\n+              \"arguments\": [{\n+                \"value\": {\n+                  \"selection\": {\n+                    \"directReference\": {\n+                      \"structField\": {\n+                        \"field\": 1\n+                      }\n+                    }\n+                  }\n+                }\n+            }],\n+              \"sorts\": [],\n+              \"phase\": \"AGGREGATION_PHASE_INITIAL_TO_RESULT\",\n+              \"outputType\": {\n+                \"i64\": {}\n+              }\n+            }\n+          }]\n+        }\n+      }\n+    }],\n+    \"extensionUris\": [{\n+      \"extension_uri_anchor\": 0,\n+      \"uri\": \"https://github.com/apache/arrow/blob/master/format/substrait/extension_types.yaml\"\n+    }],\n+    \"extensions\": [{\n+      \"extension_function\": {\n+        \"extension_uri_reference\": 0,\n+        \"function_anchor\": 0,\n+        \"name\": \"hash_count\"\n+      }\n+    }],\n+  })\"));\n+\n+  auto sp_ext_id_reg = substrait::MakeExtensionIdRegistry();\n+  ExtensionIdRegistry* ext_id_reg = sp_ext_id_reg.get();\n+  // invalid before registration\n+  ExtensionSet ext_set_invalid(ext_id_reg);\n+  ASSERT_OK_AND_ASSIGN(auto sink_decls, DeserializePlans(\n+                                            *buf, [] { return kNullConsumer; },\n+                                            ext_id_reg, &ext_set_invalid));\n+  auto agg_decl = sink_decls[0].inputs[0];\n+\n+  const auto& agg_rel = agg_decl.get<compute::Declaration>();\n+\n+  const auto& agg_options =\n+      checked_cast<const compute::AggregateNodeOptions&>(*agg_rel->options);\n+\n+  EXPECT_EQ(agg_rel->factory_name, \"aggregate\");\n+  EXPECT_EQ(agg_options.aggregates[0].name, \"\");\n+  EXPECT_EQ(agg_options.aggregates[0].function, \"hash_count\");\n+}\n+\n+TEST(Substrait, AggregateInvalidRel) {\n+  ASSERT_OK_AND_ASSIGN(auto buf, internal::SubstraitFromJSON(\"Plan\", R\"({\n+    \"relations\": [{\n+      \"rel\": {\n+        \"aggregate\": {\n+        }\n+      }\n+    }],\n+    \"extensionUris\": [{\n+      \"extension_uri_anchor\": 0,\n+      \"uri\": \"https://github.com/apache/arrow/blob/master/format/substrait/extension_types.yaml\"\n+    }],\n+    \"extensions\": [{\n+      \"extension_function\": {\n+        \"extension_uri_reference\": 0,\n+        \"function_anchor\": 0,\n+        \"name\": \"hash_count\"\n+      }\n+    }],\n+  })\"));\n+\n+  auto sp_ext_id_reg = substrait::MakeExtensionIdRegistry();\n+  ExtensionIdRegistry* ext_id_reg = sp_ext_id_reg.get();\n+  // invalid before registration\n+  ExtensionSet ext_set_invalid(ext_id_reg);\n+  ASSERT_RAISES(Invalid,\n+                DeserializePlans(\n+                    *buf, [] { return kNullConsumer; }, ext_id_reg, &ext_set_invalid));\n+}\n+\n+TEST(Substrait, AggregateInvalidFunction) {\n+  ASSERT_OK_AND_ASSIGN(auto buf, internal::SubstraitFromJSON(\"Plan\", R\"({\n+    \"relations\": [{\n+      \"rel\": {\n+        \"aggregate\": {\n+          \"input\": {\n+            \"read\": {\n+              \"base_schema\": {\n+                \"names\": [\"A\", \"B\", \"C\"],\n+                \"struct\": {\n+                  \"types\": [{\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }]\n+                }\n+              },\n+              \"local_files\": { \n+                \"items\": [\n+                  {\n+                    \"uri_file\": \"file:///tmp/dat.parquet\",\n+                    \"parquet\": {}\n+                  }\n+                ]\n+              }\n+            }\n+          },\n+          \"groupings\": [{\n+            \"groupingExpressions\": [{\n+              \"selection\": {\n+                \"directReference\": {\n+                  \"structField\": {\n+                    \"field\": 0\n+                  }\n+                }\n+              }\n+            }]\n+          }],\n+          \"measures\": [{\n+          }]\n+        }\n+      }\n+    }],\n+    \"extensionUris\": [{\n+      \"extension_uri_anchor\": 0,\n+      \"uri\": \"https://github.com/apache/arrow/blob/master/format/substrait/extension_types.yaml\"\n+    }],\n+    \"extensions\": [{\n+      \"extension_function\": {\n+        \"extension_uri_reference\": 0,\n+        \"function_anchor\": 0,\n+        \"name\": \"hash_count\"\n+      }\n+    }],\n+  })\"));\n+\n+  auto sp_ext_id_reg = substrait::MakeExtensionIdRegistry();\n+  ExtensionIdRegistry* ext_id_reg = sp_ext_id_reg.get();\n+  // invalid before registration\n+  ExtensionSet ext_set_invalid(ext_id_reg);\n+  ASSERT_RAISES(Invalid,\n+                DeserializePlans(\n+                    *buf, [] { return kNullConsumer; }, ext_id_reg, &ext_set_invalid));\n\nReview Comment:\n   ```suggestion\r\n     ASSERT_RAISES(Invalid,\r\n                   DeserializePlans(\r\n                       *buf, [] { return kNullConsumer; }));\r\n   ```\n\n\n\n##########\ncpp/src/arrow/engine/substrait/serde_test.cc:\n##########\n@@ -1383,5 +1383,350 @@ TEST(Substrait, JoinPlanInvalidKeys) {\n   }\n }\n \n+TEST(Substrait, AggregateBasic) {\n+  ASSERT_OK_AND_ASSIGN(auto buf, internal::SubstraitFromJSON(\"Plan\", R\"({\n+    \"relations\": [{\n+      \"rel\": {\n+        \"aggregate\": {\n+          \"input\": {\n+            \"read\": {\n+              \"base_schema\": {\n+                \"names\": [\"A\", \"B\", \"C\"],\n+                \"struct\": {\n+                  \"types\": [{\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }]\n+                }\n+              },\n+              \"local_files\": { \n+                \"items\": [\n+                  {\n+                    \"uri_file\": \"file:///tmp/dat.parquet\",\n+                    \"parquet\": {}\n+                  }\n+                ]\n+              }\n+            }\n+          },\n+          \"groupings\": [{\n+            \"groupingExpressions\": [{\n+              \"selection\": {\n+                \"directReference\": {\n+                  \"structField\": {\n+                    \"field\": 0\n+                  }\n+                }\n+              }\n+            }]\n+          }],\n+          \"measures\": [{\n+            \"measure\": {\n+              \"functionReference\": 0,\n+              \"arguments\": [{\n+                \"value\": {\n+                  \"selection\": {\n+                    \"directReference\": {\n+                      \"structField\": {\n+                        \"field\": 1\n+                      }\n+                    }\n+                  }\n+                }\n+            }],\n+              \"sorts\": [],\n+              \"phase\": \"AGGREGATION_PHASE_INITIAL_TO_RESULT\",\n+              \"outputType\": {\n+                \"i64\": {}\n+              }\n+            }\n+          }]\n+        }\n+      }\n+    }],\n+    \"extensionUris\": [{\n+      \"extension_uri_anchor\": 0,\n+      \"uri\": \"https://github.com/apache/arrow/blob/master/format/substrait/extension_types.yaml\"\n+    }],\n+    \"extensions\": [{\n+      \"extension_function\": {\n+        \"extension_uri_reference\": 0,\n+        \"function_anchor\": 0,\n+        \"name\": \"hash_count\"\n+      }\n+    }],\n+  })\"));\n+\n+  auto sp_ext_id_reg = substrait::MakeExtensionIdRegistry();\n+  ExtensionIdRegistry* ext_id_reg = sp_ext_id_reg.get();\n+  // invalid before registration\n+  ExtensionSet ext_set_invalid(ext_id_reg);\n+  ASSERT_OK_AND_ASSIGN(auto sink_decls, DeserializePlans(\n+                                            *buf, [] { return kNullConsumer; },\n+                                            ext_id_reg, &ext_set_invalid));\n+  auto agg_decl = sink_decls[0].inputs[0];\n+\n+  const auto& agg_rel = agg_decl.get<compute::Declaration>();\n+\n+  const auto& agg_options =\n+      checked_cast<const compute::AggregateNodeOptions&>(*agg_rel->options);\n+\n+  EXPECT_EQ(agg_rel->factory_name, \"aggregate\");\n+  EXPECT_EQ(agg_options.aggregates[0].name, \"\");\n+  EXPECT_EQ(agg_options.aggregates[0].function, \"hash_count\");\n+}\n+\n+TEST(Substrait, AggregateInvalidRel) {\n+  ASSERT_OK_AND_ASSIGN(auto buf, internal::SubstraitFromJSON(\"Plan\", R\"({\n+    \"relations\": [{\n+      \"rel\": {\n+        \"aggregate\": {\n+        }\n+      }\n+    }],\n+    \"extensionUris\": [{\n+      \"extension_uri_anchor\": 0,\n+      \"uri\": \"https://github.com/apache/arrow/blob/master/format/substrait/extension_types.yaml\"\n+    }],\n+    \"extensions\": [{\n+      \"extension_function\": {\n+        \"extension_uri_reference\": 0,\n+        \"function_anchor\": 0,\n+        \"name\": \"hash_count\"\n+      }\n+    }],\n+  })\"));\n+\n+  auto sp_ext_id_reg = substrait::MakeExtensionIdRegistry();\n+  ExtensionIdRegistry* ext_id_reg = sp_ext_id_reg.get();\n+  // invalid before registration\n+  ExtensionSet ext_set_invalid(ext_id_reg);\n+  ASSERT_RAISES(Invalid,\n+                DeserializePlans(\n+                    *buf, [] { return kNullConsumer; }, ext_id_reg, &ext_set_invalid));\n+}\n+\n+TEST(Substrait, AggregateInvalidFunction) {\n+  ASSERT_OK_AND_ASSIGN(auto buf, internal::SubstraitFromJSON(\"Plan\", R\"({\n+    \"relations\": [{\n+      \"rel\": {\n+        \"aggregate\": {\n+          \"input\": {\n+            \"read\": {\n+              \"base_schema\": {\n+                \"names\": [\"A\", \"B\", \"C\"],\n+                \"struct\": {\n+                  \"types\": [{\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }]\n+                }\n+              },\n+              \"local_files\": { \n+                \"items\": [\n+                  {\n+                    \"uri_file\": \"file:///tmp/dat.parquet\",\n+                    \"parquet\": {}\n+                  }\n+                ]\n+              }\n+            }\n+          },\n+          \"groupings\": [{\n+            \"groupingExpressions\": [{\n+              \"selection\": {\n+                \"directReference\": {\n+                  \"structField\": {\n+                    \"field\": 0\n+                  }\n+                }\n+              }\n+            }]\n+          }],\n+          \"measures\": [{\n+          }]\n+        }\n+      }\n+    }],\n+    \"extensionUris\": [{\n+      \"extension_uri_anchor\": 0,\n+      \"uri\": \"https://github.com/apache/arrow/blob/master/format/substrait/extension_types.yaml\"\n+    }],\n+    \"extensions\": [{\n+      \"extension_function\": {\n+        \"extension_uri_reference\": 0,\n+        \"function_anchor\": 0,\n+        \"name\": \"hash_count\"\n+      }\n+    }],\n+  })\"));\n+\n+  auto sp_ext_id_reg = substrait::MakeExtensionIdRegistry();\n+  ExtensionIdRegistry* ext_id_reg = sp_ext_id_reg.get();\n+  // invalid before registration\n+  ExtensionSet ext_set_invalid(ext_id_reg);\n+  ASSERT_RAISES(Invalid,\n+                DeserializePlans(\n+                    *buf, [] { return kNullConsumer; }, ext_id_reg, &ext_set_invalid));\n+}\n+\n+TEST(Substrait, AggregateInvalidAggFuncArgs) {\n+  ASSERT_OK_AND_ASSIGN(auto buf, internal::SubstraitFromJSON(\"Plan\", R\"({\n+    \"relations\": [{\n+      \"rel\": {\n+        \"aggregate\": {\n+          \"input\": {\n+            \"read\": {\n+              \"base_schema\": {\n+                \"names\": [\"A\", \"B\", \"C\"],\n+                \"struct\": {\n+                  \"types\": [{\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }]\n+                }\n+              },\n+              \"local_files\": { \n+                \"items\": [\n+                  {\n+                    \"uri_file\": \"file:///tmp/dat.parquet\",\n+                    \"parquet\": {}\n+                  }\n+                ]\n+              }\n+            }\n+          },\n+          \"groupings\": [{\n+            \"groupingExpressions\": [{\n+              \"selection\": {\n+                \"directReference\": {\n+                  \"structField\": {\n+                    \"field\": 0\n+                  }\n+                }\n+              }\n+            }]\n+          }],\n+          \"measures\": [{\n+            \"measure\": {\n+              \"functionReference\": 0,\n+              \"args\": [],\n+              \"sorts\": [],\n+              \"phase\": \"AGGREGATION_PHASE_INITIAL_TO_RESULT\",\n+              \"outputType\": {\n+                \"i64\": {}\n+              }\n+            }\n+          }]\n+        }\n+      }\n+    }],\n+    \"extensionUris\": [{\n+      \"extension_uri_anchor\": 0,\n+      \"uri\": \"https://github.com/apache/arrow/blob/master/format/substrait/extension_types.yaml\"\n+    }],\n+    \"extensions\": [{\n+      \"extension_function\": {\n+        \"extension_uri_reference\": 0,\n+        \"function_anchor\": 0,\n+        \"name\": \"hash_count\"\n+      }\n+    }],\n+  })\"));\n+\n+  auto sp_ext_id_reg = substrait::MakeExtensionIdRegistry();\n+  ExtensionIdRegistry* ext_id_reg = sp_ext_id_reg.get();\n+  // invalid before registration\n+  ExtensionSet ext_set_invalid(ext_id_reg);\n+  ASSERT_RAISES(NotImplemented,\n+                DeserializePlans(\n+                    *buf, [] { return kNullConsumer; }, ext_id_reg, &ext_set_invalid));\n+}\n+\n+TEST(Substrait, AggregateWithFilter) {\n+  ASSERT_OK_AND_ASSIGN(auto buf, internal::SubstraitFromJSON(\"Plan\", R\"({\n+    \"relations\": [{\n+      \"rel\": {\n+        \"aggregate\": {\n+          \"input\": {\n+            \"read\": {\n+              \"base_schema\": {\n+                \"names\": [\"A\", \"B\", \"C\"],\n+                \"struct\": {\n+                  \"types\": [{\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }]\n+                }\n+              },\n+              \"local_files\": { \n+                \"items\": [\n+                  {\n+                    \"uri_file\": \"file:///tmp/dat.parquet\",\n+                    \"parquet\": {}\n+                  }\n+                ]\n+              }\n+            }\n+          },\n+          \"groupings\": [{\n+            \"groupingExpressions\": [{\n+              \"selection\": {\n+                \"directReference\": {\n+                  \"structField\": {\n+                    \"field\": 0\n+                  }\n+                }\n+              }\n+            }]\n+          }],\n+          \"measures\": [{\n+            \"measure\": {\n+              \"functionReference\": 0,\n+              \"args\": [],\n+              \"sorts\": [],\n+              \"phase\": \"AGGREGATION_PHASE_INITIAL_TO_RESULT\",\n+              \"outputType\": {\n+                \"i64\": {}\n+              }\n+            }\n+          }]\n+        }\n+      }\n+    }],\n+    \"extensionUris\": [{\n+      \"extension_uri_anchor\": 0,\n+      \"uri\": \"https://github.com/apache/arrow/blob/master/format/substrait/extension_types.yaml\"\n+    }],\n+    \"extensions\": [{\n+      \"extension_function\": {\n+        \"extension_uri_reference\": 0,\n+        \"function_anchor\": 0,\n+        \"name\": \"equal\"\n+      }\n+    }],\n+  })\"));\n+\n+  auto sp_ext_id_reg = substrait::MakeExtensionIdRegistry();\n+  ExtensionIdRegistry* ext_id_reg = sp_ext_id_reg.get();\n+  // invalid before registration\n+  ExtensionSet ext_set_invalid(ext_id_reg);\n+  ASSERT_RAISES(NotImplemented,\n+                DeserializePlans(\n+                    *buf, [] { return kNullConsumer; }, ext_id_reg, &ext_set_invalid));\n\nReview Comment:\n   ```suggestion\r\n     ASSERT_RAISES(NotImplemented,\r\n                   DeserializePlans(\r\n                       *buf, [] { return kNullConsumer; }));\r\n   ```\n\n\n\n##########\ncpp/src/arrow/engine/substrait/serde_test.cc:\n##########\n@@ -1383,5 +1383,350 @@ TEST(Substrait, JoinPlanInvalidKeys) {\n   }\n }\n \n+TEST(Substrait, AggregateBasic) {\n+  ASSERT_OK_AND_ASSIGN(auto buf, internal::SubstraitFromJSON(\"Plan\", R\"({\n+    \"relations\": [{\n+      \"rel\": {\n+        \"aggregate\": {\n+          \"input\": {\n+            \"read\": {\n+              \"base_schema\": {\n+                \"names\": [\"A\", \"B\", \"C\"],\n+                \"struct\": {\n+                  \"types\": [{\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }]\n+                }\n+              },\n+              \"local_files\": { \n+                \"items\": [\n+                  {\n+                    \"uri_file\": \"file:///tmp/dat.parquet\",\n+                    \"parquet\": {}\n+                  }\n+                ]\n+              }\n+            }\n+          },\n+          \"groupings\": [{\n+            \"groupingExpressions\": [{\n+              \"selection\": {\n+                \"directReference\": {\n+                  \"structField\": {\n+                    \"field\": 0\n+                  }\n+                }\n+              }\n+            }]\n+          }],\n+          \"measures\": [{\n+            \"measure\": {\n+              \"functionReference\": 0,\n+              \"arguments\": [{\n+                \"value\": {\n+                  \"selection\": {\n+                    \"directReference\": {\n+                      \"structField\": {\n+                        \"field\": 1\n+                      }\n+                    }\n+                  }\n+                }\n+            }],\n+              \"sorts\": [],\n+              \"phase\": \"AGGREGATION_PHASE_INITIAL_TO_RESULT\",\n+              \"outputType\": {\n+                \"i64\": {}\n+              }\n+            }\n+          }]\n+        }\n+      }\n+    }],\n+    \"extensionUris\": [{\n+      \"extension_uri_anchor\": 0,\n+      \"uri\": \"https://github.com/apache/arrow/blob/master/format/substrait/extension_types.yaml\"\n+    }],\n+    \"extensions\": [{\n+      \"extension_function\": {\n+        \"extension_uri_reference\": 0,\n+        \"function_anchor\": 0,\n+        \"name\": \"hash_count\"\n+      }\n+    }],\n+  })\"));\n+\n+  auto sp_ext_id_reg = substrait::MakeExtensionIdRegistry();\n+  ExtensionIdRegistry* ext_id_reg = sp_ext_id_reg.get();\n+  // invalid before registration\n+  ExtensionSet ext_set_invalid(ext_id_reg);\n+  ASSERT_OK_AND_ASSIGN(auto sink_decls, DeserializePlans(\n+                                            *buf, [] { return kNullConsumer; },\n+                                            ext_id_reg, &ext_set_invalid));\n+  auto agg_decl = sink_decls[0].inputs[0];\n+\n+  const auto& agg_rel = agg_decl.get<compute::Declaration>();\n+\n+  const auto& agg_options =\n+      checked_cast<const compute::AggregateNodeOptions&>(*agg_rel->options);\n+\n+  EXPECT_EQ(agg_rel->factory_name, \"aggregate\");\n+  EXPECT_EQ(agg_options.aggregates[0].name, \"\");\n+  EXPECT_EQ(agg_options.aggregates[0].function, \"hash_count\");\n+}\n+\n+TEST(Substrait, AggregateInvalidRel) {\n+  ASSERT_OK_AND_ASSIGN(auto buf, internal::SubstraitFromJSON(\"Plan\", R\"({\n+    \"relations\": [{\n+      \"rel\": {\n+        \"aggregate\": {\n+        }\n+      }\n+    }],\n+    \"extensionUris\": [{\n+      \"extension_uri_anchor\": 0,\n+      \"uri\": \"https://github.com/apache/arrow/blob/master/format/substrait/extension_types.yaml\"\n+    }],\n+    \"extensions\": [{\n+      \"extension_function\": {\n+        \"extension_uri_reference\": 0,\n+        \"function_anchor\": 0,\n+        \"name\": \"hash_count\"\n+      }\n+    }],\n+  })\"));\n+\n+  auto sp_ext_id_reg = substrait::MakeExtensionIdRegistry();\n+  ExtensionIdRegistry* ext_id_reg = sp_ext_id_reg.get();\n+  // invalid before registration\n+  ExtensionSet ext_set_invalid(ext_id_reg);\n+  ASSERT_RAISES(Invalid,\n+                DeserializePlans(\n+                    *buf, [] { return kNullConsumer; }, ext_id_reg, &ext_set_invalid));\n+}\n+\n+TEST(Substrait, AggregateInvalidFunction) {\n+  ASSERT_OK_AND_ASSIGN(auto buf, internal::SubstraitFromJSON(\"Plan\", R\"({\n+    \"relations\": [{\n+      \"rel\": {\n+        \"aggregate\": {\n+          \"input\": {\n+            \"read\": {\n+              \"base_schema\": {\n+                \"names\": [\"A\", \"B\", \"C\"],\n+                \"struct\": {\n+                  \"types\": [{\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }]\n+                }\n+              },\n+              \"local_files\": { \n+                \"items\": [\n+                  {\n+                    \"uri_file\": \"file:///tmp/dat.parquet\",\n+                    \"parquet\": {}\n+                  }\n+                ]\n+              }\n+            }\n+          },\n+          \"groupings\": [{\n+            \"groupingExpressions\": [{\n+              \"selection\": {\n+                \"directReference\": {\n+                  \"structField\": {\n+                    \"field\": 0\n+                  }\n+                }\n+              }\n+            }]\n+          }],\n+          \"measures\": [{\n+          }]\n+        }\n+      }\n+    }],\n+    \"extensionUris\": [{\n+      \"extension_uri_anchor\": 0,\n+      \"uri\": \"https://github.com/apache/arrow/blob/master/format/substrait/extension_types.yaml\"\n+    }],\n+    \"extensions\": [{\n+      \"extension_function\": {\n+        \"extension_uri_reference\": 0,\n+        \"function_anchor\": 0,\n+        \"name\": \"hash_count\"\n+      }\n+    }],\n+  })\"));\n+\n+  auto sp_ext_id_reg = substrait::MakeExtensionIdRegistry();\n+  ExtensionIdRegistry* ext_id_reg = sp_ext_id_reg.get();\n+  // invalid before registration\n+  ExtensionSet ext_set_invalid(ext_id_reg);\n+  ASSERT_RAISES(Invalid,\n+                DeserializePlans(\n+                    *buf, [] { return kNullConsumer; }, ext_id_reg, &ext_set_invalid));\n+}\n+\n+TEST(Substrait, AggregateInvalidAggFuncArgs) {\n+  ASSERT_OK_AND_ASSIGN(auto buf, internal::SubstraitFromJSON(\"Plan\", R\"({\n+    \"relations\": [{\n+      \"rel\": {\n+        \"aggregate\": {\n+          \"input\": {\n+            \"read\": {\n+              \"base_schema\": {\n+                \"names\": [\"A\", \"B\", \"C\"],\n+                \"struct\": {\n+                  \"types\": [{\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }, {\n+                    \"i32\": {}\n+                  }]\n+                }\n+              },\n+              \"local_files\": { \n+                \"items\": [\n+                  {\n+                    \"uri_file\": \"file:///tmp/dat.parquet\",\n+                    \"parquet\": {}\n+                  }\n+                ]\n+              }\n+            }\n+          },\n+          \"groupings\": [{\n+            \"groupingExpressions\": [{\n+              \"selection\": {\n+                \"directReference\": {\n+                  \"structField\": {\n+                    \"field\": 0\n+                  }\n+                }\n+              }\n+            }]\n+          }],\n+          \"measures\": [{\n+            \"measure\": {\n+              \"functionReference\": 0,\n+              \"args\": [],\n+              \"sorts\": [],\n+              \"phase\": \"AGGREGATION_PHASE_INITIAL_TO_RESULT\",\n+              \"outputType\": {\n+                \"i64\": {}\n+              }\n+            }\n+          }]\n+        }\n+      }\n+    }],\n+    \"extensionUris\": [{\n+      \"extension_uri_anchor\": 0,\n+      \"uri\": \"https://github.com/apache/arrow/blob/master/format/substrait/extension_types.yaml\"\n+    }],\n+    \"extensions\": [{\n+      \"extension_function\": {\n+        \"extension_uri_reference\": 0,\n+        \"function_anchor\": 0,\n+        \"name\": \"hash_count\"\n+      }\n+    }],\n+  })\"));\n+\n+  auto sp_ext_id_reg = substrait::MakeExtensionIdRegistry();\n+  ExtensionIdRegistry* ext_id_reg = sp_ext_id_reg.get();\n+  // invalid before registration\n+  ExtensionSet ext_set_invalid(ext_id_reg);\n+  ASSERT_RAISES(NotImplemented,\n+                DeserializePlans(\n+                    *buf, [] { return kNullConsumer; }, ext_id_reg, &ext_set_invalid));\n\nReview Comment:\n   ```suggestion\r\n     ASSERT_RAISES(NotImplemented,\r\n                   DeserializePlans(\r\n                       *buf, [] { return kNullConsumer; }));\r\n   ```\n\n\n\n",
                    "created": "2022-07-18T12:08:41.622+0000",
                    "updated": "2022-07-18T12:08:41.622+0000",
                    "started": "2022-07-18T12:08:41.622+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "792073",
                    "issueId": "13426731"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/worklog/792075",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on PR #13130:\nURL: https://github.com/apache/arrow/pull/13130#issuecomment-1187254843\n\n   > I noticed we can probably simplify the unit tests just a bit. Otherwise this is good to go.\r\n   \r\n   I will update the test cases.\n\n\n",
                    "created": "2022-07-18T12:16:07.133+0000",
                    "updated": "2022-07-18T12:16:07.133+0000",
                    "started": "2022-07-18T12:16:07.133+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "792075",
                    "issueId": "13426731"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/worklog/792225",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on PR #13130:\nURL: https://github.com/apache/arrow/pull/13130#issuecomment-1187701516\n\n   @westonpace this looks okay now. WDYT?\n\n\n",
                    "created": "2022-07-18T16:20:09.810+0000",
                    "updated": "2022-07-18T16:20:09.810+0000",
                    "started": "2022-07-18T16:20:09.809+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "792225",
                    "issueId": "13426731"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/worklog/795087",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace merged PR #13130:\nURL: https://github.com/apache/arrow/pull/13130\n\n\n",
                    "created": "2022-07-25T23:59:17.886+0000",
                    "updated": "2022-07-25T23:59:17.886+0000",
                    "started": "2022-07-25T23:59:17.886+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "795087",
                    "issueId": "13426731"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/worklog/795095",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on PR #13130:\nURL: https://github.com/apache/arrow/pull/13130#issuecomment-1194892969\n\n   > Thanks for sticking with this. Apologies for the delay in reviewing.\r\n   \r\n   No worries! Thank you for the support, glad this is in. \n\n\n",
                    "created": "2022-07-26T02:13:46.822+0000",
                    "updated": "2022-07-26T02:13:46.822+0000",
                    "started": "2022-07-26T02:13:46.822+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "795095",
                    "issueId": "13426731"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/worklog/795188",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot commented on PR #13130:\nURL: https://github.com/apache/arrow/pull/13130#issuecomment-1195235288\n\n   Benchmark runs are scheduled for baseline = 898e12e67759de3df8e6c3ca75e3701c58ab50b3 and contender = 87cefe80c7126a6bf91b809159f39c9aa2a8db61. 87cefe80c7126a6bf91b809159f39c9aa2a8db61 is a master commit associated with this PR. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Failed :arrow_down:0.0% :arrow_up:0.0%] [ec2-t3-xlarge-us-east-2](https://conbench.ursa.dev/compare/runs/2699dd1e3eda46dbb0176f300558f1e7...af69d38b1add4eb6ae046bc0528b1d34/)\n   [Finished :arrow_down:0.41% :arrow_up:0.0%] [test-mac-arm](https://conbench.ursa.dev/compare/runs/586bb8fafe8f4f87b41f283594a0d1fb...c8921a35d4b740e5a97fe17cb385016a/)\n   [Finished :arrow_down:0.0% :arrow_up:0.0%] [ursa-i9-9960x](https://conbench.ursa.dev/compare/runs/6ceff0b16f69450cbcad1111e8f95ee5...f2de322a9eeb4fd38fa16d76a0ccb630/)\n   [Finished :arrow_down:0.64% :arrow_up:0.04%] [ursa-thinkcentre-m75q](https://conbench.ursa.dev/compare/runs/610f65c7d7ac433d81c6f4971b5de63d...caa268d4e9504335806e349636f31607/)\n   Buildkite builds:\n   [Failed] [`87cefe80` ec2-t3-xlarge-us-east-2](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ec2-t3-xlarge-us-east-2/builds/1198)\n   [Finished] [`87cefe80` test-mac-arm](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-test-mac-arm/builds/1210)\n   [Finished] [`87cefe80` ursa-i9-9960x](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-i9-9960x/builds/1192)\n   [Finished] [`87cefe80` ursa-thinkcentre-m75q](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-thinkcentre-m75q/builds/1212)\n   [Failed] [`898e12e6` ec2-t3-xlarge-us-east-2](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ec2-t3-xlarge-us-east-2/builds/1197)\n   [Finished] [`898e12e6` test-mac-arm](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-test-mac-arm/builds/1209)\n   [Finished] [`898e12e6` ursa-i9-9960x](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-i9-9960x/builds/1191)\n   [Finished] [`898e12e6` ursa-thinkcentre-m75q](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-thinkcentre-m75q/builds/1211)\n   Supported benchmarks:\n   ec2-t3-xlarge-us-east-2: Supported benchmark langs: Python, R. Runs only benchmarks with cloud = True\n   test-mac-arm: Supported benchmark langs: C++, Python, R\n   ursa-i9-9960x: Supported benchmark langs: Python, R, JavaScript\n   ursa-thinkcentre-m75q: Supported benchmark langs: C++, Java\n   \n\n\n",
                    "created": "2022-07-26T09:21:53.832+0000",
                    "updated": "2022-07-26T09:21:53.832+0000",
                    "started": "2022-07-26T09:21:53.832+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "795188",
                    "issueId": "13426731"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 9600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@7a95c573[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1400d401[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5e64afac[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@4c56c8bd[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@40b47a85[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@38ac5705[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@434e9673[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@39a7ad87[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5aa48864[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@6af84a[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@37a00b3a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@33ef53dc[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 9600,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Jul 25 23:59:22 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-07-25T23:59:22.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15591/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2022-02-05T02:37:49.000+0000",
        "updated": "2022-07-26T09:21:54.000+0000",
        "timeoriginalestimate": null,
        "description": "The streaming execution engine supports aggregation (i.e. group by).  The Substrait consumer does not currently consume aggregation relations.  We should add support for this.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 9600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Add support for aggregation to the Substrait consumer",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/comment/17535821",
                    "id": "17535821",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=vibhatha",
                        "name": "vibhatha",
                        "key": "vibhatha",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
                        },
                        "displayName": "Vibhatha Lakmal Abeykoon",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "[~westonpace]\u00a0\r\n\r\nI have a few doubts about this.\r\n\r\nLooking into this sample Substrait plan generated by `{color:#FF0000}isthmus{color}`\r\n{code:java}\r\n\"relations\": [{\r\n\u00a0 \u00a0 \u00a0 \"rel\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \"aggregate\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"input\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"read\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"base_schema\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"names\": [\"A\", \"B\", \"C\"],\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"struct\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"types\": [{\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"i32\": {}\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }, {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"i32\": {}\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }, {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"i32\": {}\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }]\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"local_files\": {\u00a0\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"items\": [\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"uri_file\": \"file:///tmp/dat.parquet\",\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"format\": \"FILE_FORMAT_PARQUET\"\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ]\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"groupings\": [{\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"groupingExpressions\": [{\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"selection\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"directReference\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"structField\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"field\": 0\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }]\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }],\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"measures\": [{\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"measure\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"functionReference\": 0,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"args\": [],\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"sorts\": [],\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"phase\": \"AGGREGATION_PHASE_INITIAL_TO_RESULT\",\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"outputType\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"i64\": {}\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }]\r\n\u00a0 \u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 }],\r\n\u00a0 \u00a0 \"extensionUris\": [{\r\n\u00a0 \u00a0 \u00a0 \"extension_uri_anchor\": 0,\r\n\u00a0 \u00a0 \u00a0 \"uri\": \"https://github.com/apache/arrow/blob/master/format/substrait/extension_types.yaml\"\r\n\u00a0 \u00a0 }],\r\n\u00a0 \u00a0 \"extensions\": [{\r\n\u00a0 \u00a0 \u00a0 \"extension_function\": {\r\n\u00a0 \u00a0 \u00a0 \u00a0 \"extension_uri_reference\": 0,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \"function_anchor\": 0,\r\n\u00a0 \u00a0 \u00a0 \u00a0 \"name\": \"count\"\r\n\u00a0 \u00a0 \u00a0 }\r\n\u00a0 \u00a0 }],{code}\r\n\u00a0\r\n\r\nThis is a sample Substrait Plan for a Groupby operation based on the query\r\n\r\n\u00a0\r\n{code:java}\r\nselect count(a) from T1 group by b{code}\r\n\u00a0\r\n\r\nIn here, we can clearly extract the targets and may be names from `groupings`.\r\nBut extracting the `{color:#FF0000}aggregates{color}` is not very clear.\u00a0\r\n\r\nBecause `measures` include list of `{color:#FF0000}AggregateFunction{color}` which is not a 1:1 mapping with `{color:#FF0000}Aggregate{color}` defined in Arrow.\u00a0\r\n{code:java}\r\nstruct ARROW_EXPORT Aggregate {  \r\n  /// the name of the aggregation function  \r\n  std::string function;\r\n  /// options for the aggregation function\r\n  const FunctionOptions* options;\r\n}; {code}\r\nIf we take a look at the measures(Optional, required if no grouping sets), it contains the `{color:#FF0000}functionReference{color}` which can be\u00a0\r\nextracted from the extensions where the `{color:#FF0000}function_anchor{color}` is what is referred by `{color:#FF0000}functionReference{color}`.\r\n\r\nIs this a valid statement?\u00a0\r\n\r\nTo extract aggregates, I think we can iterate through measures and get the `{color:#FF0000}functionReferences{color}` and then\r\nfrom the extensions we can get the corresponding ones. There can be a two measures, but it would point to\u00a0\r\nthe same `{color:#FF0000}extension_function{color}`.\u00a0\r\n\r\nIs this thought process accurate with the Substrait definition? Is there a cleaner way than this to extract this information?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=vibhatha",
                        "name": "vibhatha",
                        "key": "vibhatha",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
                        },
                        "displayName": "Vibhatha Lakmal Abeykoon",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-05-12T02:47:20.339+0000",
                    "updated": "2022-05-12T02:47:20.339+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/comment/17535917",
                    "id": "17535917",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "First of all, how did you get that cool red text?\r\n\r\nThe measure:\r\n{noformat}\r\n\"measure\": {\r\n              \"functionReference\": 0,\r\n              \"args\": [],\r\n              \"sorts\": [],\r\n              \"phase\": \"AGGREGATION_PHASE_INITIAL_TO_RESULT\",\r\n              \"outputType\": {\r\n                \"i64\": {}\r\n              }\r\n            }\r\n{noformat}\r\n\r\nwill have to map to:\r\n\r\n{noformat}\r\nAggregate{\"hash_count\", CountOptions{}}\r\n{noformat}\r\n\r\n{quote}\r\nIf we take a look at the measures(Optional, required if no grouping sets), it contains the `functionReference` which can be \r\nextracted from the extensions where the `function_anchor` is what is referred by `functionReference`.\r\n{quote}\r\n\r\nYes.  We have to do the same thing for scalar functions.  We should reuse code where we can.  Mapping aggregate functions is probably a separate JIRA all on its own.  You might want to take a look at ARROW-15582 where I propose a general way of doing this.  I believe [~sanjibansg] has a prototype for scalar functions but he is out until next week so this ticket might be best to wait until he is back and we can collaborate.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-05-12T07:17:01.473+0000",
                    "updated": "2022-05-12T07:17:01.473+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/comment/17535923",
                    "id": "17535923",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=vibhatha",
                        "name": "vibhatha",
                        "key": "vibhatha",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
                        },
                        "displayName": "Vibhatha Lakmal Abeykoon",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "[~westonpace]\u00a0\r\n\r\n> First of all, how did you get that cool red text?\r\n\r\nUnfortunately this is manual labor :D\u00a0(I selected the text and colored it, don't know if there is a shortcut for catching ``)\r\n\r\nAnother issue I am having is how to identify the keys (aggregation applied columns). It is not included within the Substrait very neatly. There are expressions which falls inside the aggregator relation, but that is not a clear way to extract items. I generated the query from an old fork (`{color:#FF0000}isthmus{color}`). I am re-checking it now.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=vibhatha",
                        "name": "vibhatha",
                        "key": "vibhatha",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
                        },
                        "displayName": "Vibhatha Lakmal Abeykoon",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-05-12T07:26:07.910+0000",
                    "updated": "2022-05-12T07:26:07.910+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426731/comment/17571139",
                    "id": "17571139",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 13130\n[https://github.com/apache/arrow/pull/13130]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-07-25T23:59:22.541+0000",
                    "updated": "2022-07-25T23:59:22.541+0000"
                }
            ],
            "maxResults": 4,
            "total": 4,
            "startAt": 0
        },
        "customfield_12311820": "0|z0za28:",
        "customfield_12314139": null
    }
}