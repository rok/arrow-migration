{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13293624",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624",
    "key": "ARROW-8199",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
            "name": "Minor",
            "id": "4"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "2.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12340948",
                "id": "12340948",
                "description": "",
                "name": "0.16.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-02-07"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12610992",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12610992",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "inwardIssue": {
                    "id": "13359705",
                    "key": "ARROW-11703",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13359705",
                    "fields": {
                        "summary": "[R] Implement dplyr::arrange()",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=kou",
            "name": "kou",
            "key": "kou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=kou&avatarId=30762",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kou&avatarId=30762",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kou&avatarId=30762",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kou&avatarId=30762"
            },
            "displayName": "Kouhei Sutou",
            "active": true,
            "timeZone": "Asia/Tokyo"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=swilson314",
            "name": "swilson314",
            "key": "swilson314",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
            },
            "displayName": "Scott Wilson",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=swilson314",
            "name": "swilson314",
            "key": "swilson314",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
            },
            "displayName": "Scott Wilson",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 19800,
            "total": 19800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 19800,
            "total": 19800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-8199/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 33,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/508970",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou opened a new pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612\n\n\n   Summary:\r\n   \r\n     * Deprecate SortToIndices()\r\n   \r\n     * Add SortIndices() because we use \"sort_indices\" as kernel name in\r\n       #7240\r\n   \r\n     * Add support for sort indices in descending order on Array\r\n   \r\n     * Rename existing \"sort_indices\" kernel to \"array_sort_indices\" and\r\n       introduce \"sort_indices\" meta function to support RecordBatch and\r\n       Table\r\n   \r\n   Benchmark:\r\n   \r\n   Summary:\r\n   \r\n     * No performance regression in existing sort on array\r\n   \r\n     * Same performance as sort on array when the number of sort keys is 1\r\n   \r\n     * 1.5x-100x slower than sort on array when the number of sort keys is 2\r\n   \r\n   Before:\r\n   \r\n       ----------------------------------------------------------------------------------\r\n       Benchmark                                                     Time             CPU\r\n       ----------------------------------------------------------------------------------\r\n       SortToIndicesInt64Count/32768/10000/min_time:1.000        15685 ns        15682 ns\r\n       SortToIndicesInt64Count/32768/100/min_time:1.000          15961 ns        15957 ns\r\n       SortToIndicesInt64Count/32768/10/min_time:1.000           16473 ns        16469 ns\r\n       SortToIndicesInt64Count/32768/2/min_time:1.000            27993 ns        27987 ns\r\n       SortToIndicesInt64Count/32768/1/min_time:1.000             5609 ns         5608 ns\r\n       SortToIndicesInt64Count/32768/0/min_time:1.000            13143 ns        13141 ns\r\n       SortToIndicesInt64Count/1048576/1/min_time:1.000         134695 ns       134670 ns\r\n       SortToIndicesInt64Count/8388608/1/min_time:1.000        1243992 ns      1243260 ns\r\n       SortToIndicesInt64Compare/32768/10000/min_time:1.000     193632 ns       193595 ns\r\n       SortToIndicesInt64Compare/32768/100/min_time:1.000       194876 ns       194837 ns\r\n       SortToIndicesInt64Compare/32768/10/min_time:1.000        182362 ns       182324 ns\r\n       SortToIndicesInt64Compare/32768/2/min_time:1.000         111607 ns       111584 ns\r\n       SortToIndicesInt64Compare/32768/1/min_time:1.000           5642 ns         5641 ns\r\n       SortToIndicesInt64Compare/32768/0/min_time:1.000         190302 ns       190268 ns\r\n       SortToIndicesInt64Compare/1048576/1/min_time:1.000       134743 ns       134718 ns\r\n       SortToIndicesInt64Compare/8388608/1/min_time:1.000      1261404 ns      1249362 ns\r\n   \r\n   After:\r\n   \r\n       -------------------------------------------------------------------------------------\r\n       Benchmark                                                        Time             CPU\r\n       -------------------------------------------------------------------------------------\r\n       ArraySortIndicesInt64Count/32768/10000/min_time:1.000        14769 ns        14766 ns\r\n       ArraySortIndicesInt64Count/32768/100/min_time:1.000          15207 ns        15204 ns\r\n       ArraySortIndicesInt64Count/32768/10/min_time:1.000           15892 ns        15889 ns\r\n       ArraySortIndicesInt64Count/32768/2/min_time:1.000            30107 ns        30100 ns\r\n       ArraySortIndicesInt64Count/32768/1/min_time:1.000             5509 ns         5508 ns\r\n       ArraySortIndicesInt64Count/32768/0/min_time:1.000            12699 ns        12696 ns\r\n       ArraySortIndicesInt64Count/1048576/1/min_time:1.000         132585 ns       132557 ns\r\n       ArraySortIndicesInt64Count/8388608/1/min_time:1.000        1236596 ns      1235842 ns\r\n       ArraySortIndicesInt64Compare/32768/10000/min_time:1.000     193259 ns       193217 ns\r\n       ArraySortIndicesInt64Compare/32768/100/min_time:1.000       190010 ns       189973 ns\r\n       ArraySortIndicesInt64Compare/32768/10/min_time:1.000        179923 ns       179879 ns\r\n       ArraySortIndicesInt64Compare/32768/2/min_time:1.000         111100 ns       111074 ns\r\n       ArraySortIndicesInt64Compare/32768/1/min_time:1.000           5660 ns         5659 ns\r\n       ArraySortIndicesInt64Compare/32768/0/min_time:1.000         186521 ns       186476 ns\r\n       ArraySortIndicesInt64Compare/1048576/1/min_time:1.000       132863 ns       132832 ns\r\n       ArraySortIndicesInt64Compare/8388608/1/min_time:1.000      1266383 ns      1265765 ns\r\n       TableSortIndicesInt64Count/32768/10000/min_time:1.000        21812 ns        21807 ns\r\n       TableSortIndicesInt64Count/32768/100/min_time:1.000          22494 ns        22490 ns\r\n       TableSortIndicesInt64Count/32768/10/min_time:1.000           17300 ns        17296 ns\r\n       TableSortIndicesInt64Count/32768/2/min_time:1.000            29927 ns        29921 ns\r\n       TableSortIndicesInt64Count/32768/1/min_time:1.000             5877 ns         5875 ns\r\n       TableSortIndicesInt64Count/32768/0/min_time:1.000            20394 ns        20390 ns\r\n       TableSortIndicesInt64Count/1048576/1/min_time:1.000         132904 ns       132871 ns\r\n       TableSortIndicesInt64Count/8388608/1/min_time:1.000        1342693 ns      1341943 ns\r\n       TableSortIndicesInt64Compare/32768/10000/min_time:1.000     203163 ns       203106 ns\r\n       TableSortIndicesInt64Compare/32768/100/min_time:1.000       199531 ns       199477 ns\r\n       TableSortIndicesInt64Compare/32768/10/min_time:1.000        185968 ns       185916 ns\r\n       TableSortIndicesInt64Compare/32768/2/min_time:1.000         113571 ns       113540 ns\r\n       TableSortIndicesInt64Compare/32768/1/min_time:1.000           6251 ns         6249 ns\r\n       TableSortIndicesInt64Compare/32768/0/min_time:1.000         183650 ns       183609 ns\r\n       TableSortIndicesInt64Compare/1048576/1/min_time:1.000       131701 ns       131674 ns\r\n       TableSortIndicesInt64Compare/8388608/1/min_time:1.000      1264413 ns      1263622 ns\r\n       TableSortIndicesInt64Int64/32768/10000/min_time:1.000       313368 ns       313310 ns\r\n       TableSortIndicesInt64Int64/32768/100/min_time:1.000         313425 ns       313361 ns\r\n       TableSortIndicesInt64Int64/32768/10/min_time:1.000          337051 ns       336987 ns\r\n       TableSortIndicesInt64Int64/32768/2/min_time:1.000           402063 ns       401973 ns\r\n       TableSortIndicesInt64Int64/32768/1/min_time:1.000           254660 ns       254612 ns\r\n       TableSortIndicesInt64Int64/32768/0/min_time:1.000           305887 ns       305815 ns\r\n       TableSortIndicesInt64Int64/1048576/1/min_time:1.000       11157920 ns     11155020 ns\r\n       TableSortIndicesInt64Int64/8388608/1/min_time:1.000      106529839 ns    106501576 ns\r\n   \r\n   Follow-up tasks:\r\n   \r\n     * Improve performance when the number of sort keys is 2 or greater\r\n   \r\n       * Idea1: Use counting sort for small range data like on array\r\n   \r\n       * Idea2: Use threading and merge sort\r\n   \r\n     * Add support multi-column partition Nth indices on Table\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-09T03:43:53.597+0000",
                    "updated": "2020-11-09T03:43:53.597+0000",
                    "started": "2020-11-09T03:43:53.596+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "508970",
                    "issueId": "13293624"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/508972",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612#issuecomment-723737307\n\n\n   https://issues.apache.org/jira/browse/ARROW-8199\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-09T03:47:24.028+0000",
                    "updated": "2020-11-09T03:47:24.028+0000",
                    "started": "2020-11-09T03:47:24.028+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "508972",
                    "issueId": "13293624"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/508974",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on a change in pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612#discussion_r519538131\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -112,11 +114,12 @@ inline void VisitRawValuesInline(const ArrayType& values,\n }\n \n template <typename ArrowType>\n-class CompareSorter {\n+class ArrayCompareSorter {\n   using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n \n  public:\n-  void Sort(uint64_t* indices_begin, uint64_t* indices_end, const ArrayType& values) {\n+  void Sort(uint64_t* indices_begin, uint64_t* indices_end, const ArrayType& values,\n+            const ArraySortOptions& options) {\n\nReview comment:\n       This change is for order support on array.\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.cc\n##########\n@@ -135,5 +149,9 @@ Result<std::shared_ptr<Table>> Take(const Table& table, const ChunkedArray& indi\n   return result.table();\n }\n \n+Result<std::shared_ptr<Array>> SortToIndices(const Array& values, ExecContext* ctx) {\n+  return SortIndices(values, ctx);\n+}\n+\n\nReview comment:\n       This hunk is for `SortToIndices()` -> `SortIndices()` rename.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -125,35 +128,43 @@ class CompareSorter {\n           std::stable_partition(indices_begin, indices_end,\n                                 [&values](uint64_t ind) { return !values.IsNull(ind); });\n     }\n-    std::stable_sort(indices_begin, nulls_begin,\n-                     [&values](uint64_t left, uint64_t right) {\n-                       return values.GetView(left) < values.GetView(right);\n-                     });\n+    if (options.order == SortOrder::ASCENDING) {\n+      std::stable_sort(indices_begin, nulls_begin,\n+                       [&values](uint64_t left, uint64_t right) {\n+                         return values.GetView(left) < values.GetView(right);\n+                       });\n+    } else {\n+      std::stable_sort(indices_begin, nulls_begin,\n+                       [&values](uint64_t left, uint64_t right) {\n+                         return values.GetView(left) > values.GetView(right);\n+                       });\n+    }\n   }\n };\n \n template <typename ArrowType>\n-class CountSorter {\n+class ArrayCountSorter {\n   using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n   using c_type = typename ArrowType::c_type;\n \n  public:\n-  CountSorter() = default;\n+  ArrayCountSorter() = default;\n \n-  explicit CountSorter(c_type min, c_type max) { SetMinMax(min, max); }\n+  explicit ArrayCountSorter(c_type min, c_type max) { SetMinMax(min, max); }\n \n   // Assume: max >= min && (max - min) < 4Gi\n   void SetMinMax(c_type min, c_type max) {\n     min_ = min;\n     value_range_ = static_cast<uint32_t>(max - min) + 1;\n   }\n \n-  void Sort(uint64_t* indices_begin, uint64_t* indices_end, const ArrayType& values) {\n+  void Sort(uint64_t* indices_begin, uint64_t* indices_end, const ArrayType& values,\n+            const ArraySortOptions& options) {\n     // 32bit counter performs much better than 64bit one\n     if (values.length() < (1LL << 32)) {\n-      SortInternal<uint32_t>(indices_begin, indices_end, values);\n+      SortInternal<uint32_t>(indices_begin, indices_end, values, options);\n     } else {\n-      SortInternal<uint64_t>(indices_begin, indices_end, values);\n+      SortInternal<uint64_t>(indices_begin, indices_end, values, options);\n\nReview comment:\n       This change is for order support on array.\r\n   \n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -125,35 +128,43 @@ class CompareSorter {\n           std::stable_partition(indices_begin, indices_end,\n                                 [&values](uint64_t ind) { return !values.IsNull(ind); });\n     }\n-    std::stable_sort(indices_begin, nulls_begin,\n-                     [&values](uint64_t left, uint64_t right) {\n-                       return values.GetView(left) < values.GetView(right);\n-                     });\n+    if (options.order == SortOrder::ASCENDING) {\n+      std::stable_sort(indices_begin, nulls_begin,\n+                       [&values](uint64_t left, uint64_t right) {\n+                         return values.GetView(left) < values.GetView(right);\n+                       });\n+    } else {\n+      std::stable_sort(indices_begin, nulls_begin,\n+                       [&values](uint64_t left, uint64_t right) {\n+                         return values.GetView(left) > values.GetView(right);\n+                       });\n+    }\n\nReview comment:\n       This change is for order support on array.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -163,36 +174,49 @@ class CountSorter {\n \n   template <typename CounterType>\n   void SortInternal(uint64_t* indices_begin, uint64_t* indices_end,\n-                    const ArrayType& values) {\n+                    const ArrayType& values, const ArraySortOptions& options) {\n     const uint32_t value_range = value_range_;\n \n     // first slot reserved for prefix sum\n     std::vector<CounterType> counts(1 + value_range);\n \n-    VisitRawValuesInline(\n-        values, [&](c_type v) { ++counts[v - min_ + 1]; }, []() {});\n-\n-    for (uint32_t i = 1; i <= value_range; ++i) {\n-      counts[i] += counts[i - 1];\n+    if (options.order == SortOrder::ASCENDING) {\n+      VisitRawValuesInline(\n+          values, [&](c_type v) { ++counts[v - min_ + 1]; }, []() {});\n+      for (uint32_t i = 1; i <= value_range; ++i) {\n+        counts[i] += counts[i - 1];\n+      }\n+      uint32_t null_position = counts[value_range];\n+      int64_t index = 0;\n+      VisitRawValuesInline(\n+          values, [&](c_type v) { indices_begin[counts[v - min_]++] = index++; },\n+          [&]() { indices_begin[null_position++] = index++; });\n+    } else {\n+      VisitRawValuesInline(\n+          values, [&](c_type v) { ++counts[v - min_]; }, []() {});\n+      for (uint32_t i = value_range; i >= 1; --i) {\n+        counts[i - 1] += counts[i];\n+      }\n+      uint32_t null_position = counts[0];\n+      int64_t index = 0;\n+      VisitRawValuesInline(\n+          values, [&](c_type v) { indices_begin[counts[v - min_ + 1]++] = index++; },\n+          [&]() { indices_begin[null_position++] = index++; });\n     }\n-\n-    int64_t index = 0;\n-    VisitRawValuesInline(\n-        values, [&](c_type v) { indices_begin[counts[v - min_]++] = index++; },\n-        [&]() { indices_begin[counts[value_range]++] = index++; });\n   }\n };\n\nReview comment:\n       This change is for order support on array.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort_test.cc\n##########\n@@ -209,138 +214,155 @@ TYPED_TEST(TestNthToIndicesRandom, RandomValues) {\n using arrow::internal::checked_pointer_cast;\n \n template <typename ArrowType>\n-class TestSortToIndicesKernel : public TestBase {\n+class TestArraySortIndicesKernel : public TestBase {\n\nReview comment:\n       This hunk is for renaming `SortToIndices()` -> `SortIndices()`. No logic change.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -236,36 +260,40 @@ class CountOrCompareSorter {\n };\n \n template <typename Type, typename Enable = void>\n-struct Sorter;\n+struct ArraySorter;\n \n template <>\n-struct Sorter<UInt8Type> {\n-  CountSorter<UInt8Type> impl;\n-  Sorter() : impl(0, 255) {}\n+struct ArraySorter<UInt8Type> {\n+  ArrayCountSorter<UInt8Type> impl;\n+  ArraySorter() : impl(0, 255) {}\n };\n \n template <>\n-struct Sorter<Int8Type> {\n-  CountSorter<Int8Type> impl;\n-  Sorter() : impl(-128, 127) {}\n+struct ArraySorter<Int8Type> {\n+  ArrayCountSorter<Int8Type> impl;\n+  ArraySorter() : impl(-128, 127) {}\n };\n \n template <typename Type>\n-struct Sorter<Type, enable_if_t<is_integer_type<Type>::value &&\n-                                (sizeof(typename Type::c_type) > 1)>> {\n-  CountOrCompareSorter<Type> impl;\n+struct ArraySorter<Type, enable_if_t<is_integer_type<Type>::value &&\n+                                     (sizeof(typename Type::c_type) > 1)>> {\n+  ArrayCountOrCompareSorter<Type> impl;\n };\n \n template <typename Type>\n-struct Sorter<Type, enable_if_t<is_floating_type<Type>::value ||\n-                                is_base_binary_type<Type>::value>> {\n-  CompareSorter<Type> impl;\n+struct ArraySorter<Type, enable_if_t<is_floating_type<Type>::value ||\n+                                     is_base_binary_type<Type>::value>> {\n+  ArrayCompareSorter<Type> impl;\n };\n\nReview comment:\n       `Array` prefix is added to distinguish array and table related codes.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -112,11 +114,12 @@ inline void VisitRawValuesInline(const ArrayType& values,\n }\n \n template <typename ArrowType>\n-class CompareSorter {\n+class ArrayCompareSorter {\n\nReview comment:\n       `Array` prefix is added to distinguish array and table related codes.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -125,35 +128,43 @@ class CompareSorter {\n           std::stable_partition(indices_begin, indices_end,\n                                 [&values](uint64_t ind) { return !values.IsNull(ind); });\n     }\n-    std::stable_sort(indices_begin, nulls_begin,\n-                     [&values](uint64_t left, uint64_t right) {\n-                       return values.GetView(left) < values.GetView(right);\n-                     });\n+    if (options.order == SortOrder::ASCENDING) {\n+      std::stable_sort(indices_begin, nulls_begin,\n+                       [&values](uint64_t left, uint64_t right) {\n+                         return values.GetView(left) < values.GetView(right);\n+                       });\n+    } else {\n+      std::stable_sort(indices_begin, nulls_begin,\n+                       [&values](uint64_t left, uint64_t right) {\n+                         return values.GetView(left) > values.GetView(right);\n+                       });\n+    }\n   }\n };\n \n template <typename ArrowType>\n-class CountSorter {\n+class ArrayCountSorter {\n   using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n   using c_type = typename ArrowType::c_type;\n \n  public:\n-  CountSorter() = default;\n+  ArrayCountSorter() = default;\n \n-  explicit CountSorter(c_type min, c_type max) { SetMinMax(min, max); }\n+  explicit ArrayCountSorter(c_type min, c_type max) { SetMinMax(min, max); }\n\nReview comment:\n       `Array` prefix is added to distinguish array and table related codes.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -299,12 +327,344 @@ void AddSortingKernels(VectorKernel base, VectorFunction* func) {\n   }\n }\n \n+class TableSorter : public TypeVisitor {\n\nReview comment:\n       For multi-column sorting on table.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-09T03:52:29.805+0000",
                    "updated": "2020-11-09T03:52:29.805+0000",
                    "started": "2020-11-09T03:52:29.804+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "508974",
                    "issueId": "13293624"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/508983",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mrkn commented on a change in pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612#discussion_r519569356\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -125,35 +128,43 @@ class CompareSorter {\n           std::stable_partition(indices_begin, indices_end,\n                                 [&values](uint64_t ind) { return !values.IsNull(ind); });\n     }\n-    std::stable_sort(indices_begin, nulls_begin,\n-                     [&values](uint64_t left, uint64_t right) {\n-                       return values.GetView(left) < values.GetView(right);\n-                     });\n+    if (options.order == SortOrder::ASCENDING) {\n+      std::stable_sort(indices_begin, nulls_begin,\n+                       [&values](uint64_t left, uint64_t right) {\n+                         return values.GetView(left) < values.GetView(right);\n+                       });\n+    } else {\n+      std::stable_sort(indices_begin, nulls_begin,\n+                       [&values](uint64_t left, uint64_t right) {\n+                         return values.GetView(left) > values.GetView(right);\n\nReview comment:\n       This requires that all of `==`, `<`, and `>` are implemented in the value type.\r\n   Instead, writing `right < left` here only requires `==` and `<`.\r\n   IMHO, requiring only `==` and `<` is better to support extension types in the future.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-09T06:03:17.572+0000",
                    "updated": "2020-11-09T06:03:17.572+0000",
                    "started": "2020-11-09T06:03:17.572+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "508983",
                    "issueId": "13293624"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/508984",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on a change in pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612#discussion_r519569932\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -125,35 +128,43 @@ class CompareSorter {\n           std::stable_partition(indices_begin, indices_end,\n                                 [&values](uint64_t ind) { return !values.IsNull(ind); });\n     }\n-    std::stable_sort(indices_begin, nulls_begin,\n-                     [&values](uint64_t left, uint64_t right) {\n-                       return values.GetView(left) < values.GetView(right);\n-                     });\n+    if (options.order == SortOrder::ASCENDING) {\n+      std::stable_sort(indices_begin, nulls_begin,\n+                       [&values](uint64_t left, uint64_t right) {\n+                         return values.GetView(left) < values.GetView(right);\n+                       });\n+    } else {\n+      std::stable_sort(indices_begin, nulls_begin,\n+                       [&values](uint64_t left, uint64_t right) {\n+                         return values.GetView(left) > values.GetView(right);\n\nReview comment:\n       Good catch!\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-09T06:05:32.016+0000",
                    "updated": "2020-11-09T06:05:32.016+0000",
                    "started": "2020-11-09T06:05:32.016+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "508984",
                    "issueId": "13293624"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/510073",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612#issuecomment-725086749\n\n\n   @cyb70289 @pitrou Do you want to review this?\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T02:25:30.447+0000",
                    "updated": "2020-11-11T02:25:30.447+0000",
                    "started": "2020-11-11T02:25:30.447+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510073",
                    "issueId": "13293624"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/510082",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612#issuecomment-725094232\n\n\n   Also update kernel document? `docs/source/cpp/compute.rst`\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T02:48:49.436+0000",
                    "updated": "2020-11-11T02:48:49.436+0000",
                    "started": "2020-11-11T02:48:49.436+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510082",
                    "issueId": "13293624"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/510084",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612#issuecomment-725098578\n\n\n   Done.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T03:04:40.045+0000",
                    "updated": "2020-11-11T03:04:40.045+0000",
                    "started": "2020-11-11T03:04:40.045+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510084",
                    "issueId": "13293624"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/510111",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612#issuecomment-725205535\n\n\n   @kou I'm okay with this patch.\r\n   As you listed in follow up tasks, sorting arrays separately and merging afterwards should be faster. And I think there are other chances to improve performance.\r\n   \r\n   Some random thoughts:\r\n   - Looks you are returning a flat index array, does it make sense to return array of tuple (chunk_index, offset_in_chunk)? Maybe easier for client code to use?\r\n   - For multi column sorting, in one iteration, current code compares values column by column till first non-equal found. I don't know if a radix sort approach is better, e.g. sort by 2nd-order column first, then sort by 1st-order column. It may be possible to leverage existing array based sorting code(counting sort, etc).\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T05:21:08.496+0000",
                    "updated": "2020-11-11T05:21:08.496+0000",
                    "started": "2020-11-11T05:21:08.496+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510111",
                    "issueId": "13293624"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/510123",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612#issuecomment-725225424\n\n\n   Thanks for your comments!\r\n   \r\n   > Looks you are returning a flat index array, does it make sense to return array of tuple (chunk_index, offset_in_chunk)? Maybe easier for client code to use?\r\n   \r\n   Each column in table may have the different number of chunks. For example, `{\"a\": [[1, 2], [3], [4, 5, 6]], \"b\": [[1, 2, 3], [4, 5, 6]]}`. If we want to return `chunk_index` and `offset_in_chunk`, we need to return them for each column. It may decrease performance.\r\n   \r\n   > For multi column sorting, in one iteration, current code compares values column by column till first non-equal found. I don't know if a radix sort approach is better, e.g. sort by 2nd-order column first, then sort by 1st-order column. It may be possible to leverage existing array based sorting code(counting sort, etc).\r\n   \r\n   It's interesting! I've added the idea to follow-up tasks in the pull request description.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T06:18:06.368+0000",
                    "updated": "2020-11-11T06:18:06.368+0000",
                    "started": "2020-11-11T06:18:06.367+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510123",
                    "issueId": "13293624"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/510296",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612#discussion_r521405090\n\n\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.h\n##########\n@@ -58,6 +58,34 @@ struct ARROW_EXPORT TakeOptions : public FunctionOptions {\n   static TakeOptions Defaults() { return BoundsCheck(); }\n };\n \n+enum SortOrder {\n\nReview comment:\n       Make this a `enum class`?\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.h\n##########\n@@ -58,6 +58,34 @@ struct ARROW_EXPORT TakeOptions : public FunctionOptions {\n   static TakeOptions Defaults() { return BoundsCheck(); }\n };\n \n+enum SortOrder {\n+  ASCENDING,\n+  DESCENDING,\n\nReview comment:\n       Nit, but sometimes all-uppercase values conflict with some C macros (especially on Windows). `Ascending` perhaps?\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.h\n##########\n@@ -165,8 +194,50 @@ Result<std::shared_ptr<Array>> NthToIndices(const Array& values, int64_t n,\n /// \\param[in] ctx the function execution context, optional\n /// \\return offsets indices that would sort an array\n ARROW_EXPORT\n-Result<std::shared_ptr<Array>> SortToIndices(const Array& values,\n-                                             ExecContext* ctx = NULLPTR);\n+Result<std::shared_ptr<Array>> SortIndices(const Array& values,\n+                                           ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Returns the indices that would sort an array in the\n+/// specified order.\n+///\n+/// Perform an indirect sort of array. The output array will contain\n+/// indices that would sort an array, which would be the same length\n+/// as input. Nulls will be stably partitioned to the end of the output.\n\nReview comment:\n       Add \"regardless of order\"?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -346,14 +374,396 @@ void AddSortingKernels(VectorKernel base, VectorFunction* func) {\n   }\n }\n \n+class TableSorter : public TypeVisitor {\n+ private:\n+  struct ResolvedSortKey {\n+    ResolvedSortKey(const ChunkedArray& chunked_array, const SortOrder order)\n+        : order(order) {\n+      type = chunked_array.type().get();\n+      null_count = chunked_array.null_count();\n+      num_chunks = chunked_array.num_chunks();\n+      for (const auto& chunk : chunked_array.chunks()) {\n+        chunks.push_back(chunk.get());\n+      }\n+    }\n+\n+    template <typename ArrayType>\n+    ArrayType* ResolveChunk(int64_t index, int64_t& chunk_index) const {\n+      if (num_chunks == 1) {\n+        chunk_index = index;\n+        return static_cast<ArrayType*>(chunks[0]);\n+      } else {\n+        int64_t offset = 0;\n+        for (size_t i = 0; i < num_chunks; ++i) {\n+          if (index < offset + chunks[i]->length()) {\n+            chunk_index = index - offset;\n+            return static_cast<ArrayType*>(chunks[i]);\n+          }\n+          offset += chunks[i]->length();\n+        }\n+        return nullptr;\n+      }\n+    }\n+\n+    SortOrder order;\n+    DataType* type;\n+    int64_t null_count;\n+    size_t num_chunks;\n\nReview comment:\n       `int64_t`?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -346,14 +374,396 @@ void AddSortingKernels(VectorKernel base, VectorFunction* func) {\n   }\n }\n \n+class TableSorter : public TypeVisitor {\n+ private:\n+  struct ResolvedSortKey {\n+    ResolvedSortKey(const ChunkedArray& chunked_array, const SortOrder order)\n+        : order(order) {\n+      type = chunked_array.type().get();\n+      null_count = chunked_array.null_count();\n+      num_chunks = chunked_array.num_chunks();\n+      for (const auto& chunk : chunked_array.chunks()) {\n+        chunks.push_back(chunk.get());\n+      }\n+    }\n+\n+    template <typename ArrayType>\n+    ArrayType* ResolveChunk(int64_t index, int64_t& chunk_index) const {\n+      if (num_chunks == 1) {\n+        chunk_index = index;\n+        return static_cast<ArrayType*>(chunks[0]);\n+      } else {\n+        int64_t offset = 0;\n+        for (size_t i = 0; i < num_chunks; ++i) {\n+          if (index < offset + chunks[i]->length()) {\n+            chunk_index = index - offset;\n+            return static_cast<ArrayType*>(chunks[i]);\n+          }\n+          offset += chunks[i]->length();\n+        }\n+        return nullptr;\n+      }\n+    }\n+\n+    SortOrder order;\n+    DataType* type;\n+    int64_t null_count;\n+    size_t num_chunks;\n+    std::vector<Array*> chunks;\n+  };\n+\n+  class Comparer : public TypeVisitor {\n+   public:\n+    Comparer(const Table& table, const std::vector<SortKey>& sort_keys)\n+        : TypeVisitor(), status_(Status::OK()) {\n+      for (const auto& sort_key : sort_keys) {\n+        const auto& chunked_array = table.GetColumnByName(sort_key.name);\n+        if (!chunked_array) {\n+          status_ = Status::Invalid(\"Nonexistent sort key column: \", sort_key.name);\n+          return;\n+        }\n+        sort_keys_.emplace_back(*chunked_array, sort_key.order);\n+      }\n+    }\n+\n+    Status status() { return status_; }\n+\n+    const std::vector<ResolvedSortKey>& sort_keys() { return sort_keys_; }\n+\n+    bool Compare(uint64_t left, uint64_t right, size_t start_sort_key_index) {\n+      current_left_ = left;\n+      current_right_ = right;\n+      current_compared_ = 0;\n+      auto num_sort_keys = sort_keys_.size();\n+      for (size_t i = start_sort_key_index; i < num_sort_keys; ++i) {\n+        current_sort_key_index_ = i;\n+        status_ = sort_keys_[i].type->Accept(this);\n+        if (current_compared_ != 0) {\n+          break;\n+        }\n+      }\n+      return current_compared_ < 0;\n+    }\n+\n+#define VISIT(TYPE)                                \\\n+  Status Visit(const TYPE##Type& type) override {  \\\n+    current_compared_ = CompareType<TYPE##Type>(); \\\n+    return Status::OK();                           \\\n+  }\n+\n+    VISIT(Int8)\n+    VISIT(Int16)\n+    VISIT(Int32)\n+    VISIT(Int64)\n+    VISIT(UInt8)\n+    VISIT(UInt16)\n+    VISIT(UInt32)\n+    VISIT(UInt64)\n+    VISIT(Float)\n+    VISIT(Double)\n+    VISIT(String)\n+    VISIT(Binary)\n+    VISIT(LargeString)\n+    VISIT(LargeBinary)\n+\n+#undef VISIT\n+\n+   private:\n+    template <typename Type>\n+    int32_t CompareType() {\n+      using ArrayType = typename TypeTraits<Type>::ArrayType;\n+      const auto& sort_key = sort_keys_[current_sort_key_index_];\n+      auto order = sort_key.order;\n+      int64_t index_left = 0;\n+      auto array_left = sort_key.ResolveChunk<ArrayType>(current_left_, index_left);\n+      int64_t index_right = 0;\n+      auto array_right = sort_key.ResolveChunk<ArrayType>(current_right_, index_right);\n+      if (sort_key.null_count > 0) {\n+        auto is_null_left = array_left->IsNull(index_left);\n+        auto is_null_right = array_right->IsNull(index_right);\n+        if (is_null_left && is_null_right) {\n+          return 0;\n+        } else if (is_null_left) {\n+          return 1;\n+        } else if (is_null_right) {\n+          return -1;\n+        }\n+      }\n+      auto left = array_left->GetView(index_left);\n+      auto right = array_right->GetView(index_right);\n+      int32_t compared;\n+      if (left == right) {\n+        compared = 0;\n+      } else if (left > right) {\n+        compared = 1;\n+      } else {\n+        compared = -1;\n+      }\n+      if (order == SortOrder::DESCENDING) {\n+        compared = -compared;\n+      }\n+      return compared;\n+    }\n+\n+    Status status_;\n+    std::vector<ResolvedSortKey> sort_keys_;\n+    int64_t current_left_;\n+    int64_t current_right_;\n+    size_t current_sort_key_index_;\n+    int32_t current_compared_;\n+  };\n+\n+ public:\n+  TableSorter(uint64_t* indices_begin, uint64_t* indices_end, const Table& table,\n+              const SortOptions& options)\n+      : indices_begin_(indices_begin),\n+        indices_end_(indices_end),\n+        comparer_(table, options.sort_keys) {}\n+\n+  Status Sort() {\n+    ARROW_RETURN_NOT_OK(comparer_.status());\n+    return comparer_.sort_keys()[0].type->Accept(this);\n+  }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE##Type& type) override { return SortInternal<TYPE##Type>(); }\n+\n+  VISIT(Int8)\n+  VISIT(Int16)\n+  VISIT(Int32)\n+  VISIT(Int64)\n+  VISIT(UInt8)\n+  VISIT(UInt16)\n+  VISIT(UInt32)\n+  VISIT(UInt64)\n+  VISIT(Float)\n+  VISIT(Double)\n+  VISIT(String)\n+  VISIT(Binary)\n+  VISIT(LargeString)\n+  VISIT(LargeBinary)\n+\n+#undef VISIT\n+\n+ private:\n+  template <typename Type>\n+  Status SortInternal() {\n+    using ArrayType = typename TypeTraits<Type>::ArrayType;\n+    std::iota(indices_begin_, indices_end_, 0);\n+\n+    auto& comparer = comparer_;\n+    const auto& first_sort_key = comparer.sort_keys()[0];\n+    auto nulls_begin = indices_end_;\n+    nulls_begin = PartitionNullsInternal<Type>(first_sort_key);\n+    std::stable_sort(\n+        indices_begin_, nulls_begin,\n+        [&first_sort_key, &comparer](uint64_t left, uint64_t right) {\n+          int64_t index_left = 0;\n+          auto array_left = first_sort_key.ResolveChunk<ArrayType>(left, index_left);\n+          int64_t index_right = 0;\n+          auto array_right = first_sort_key.ResolveChunk<ArrayType>(right, index_right);\n+          auto value_left = array_left->GetView(index_left);\n+          auto value_right = array_right->GetView(index_right);\n+          if (value_left == value_right) {\n+            return comparer.Compare(left, right, 1);\n+          } else {\n+            auto compared = value_left < value_right;\n+            if (first_sort_key.order == SortOrder::ASCENDING) {\n+              return compared;\n+            } else {\n+              return !compared;\n+            }\n+          }\n+        });\n+    return Status::OK();\n+  }\n+\n+  template <typename Type>\n+  enable_if_t<!is_floating_type<Type>::value, uint64_t*> PartitionNullsInternal(\n+      const ResolvedSortKey& first_sort_key) {\n+    using ArrayType = typename TypeTraits<Type>::ArrayType;\n+    if (first_sort_key.null_count == 0) {\n+      return indices_end_;\n+    }\n+    StablePartitioner partitioner;\n+    auto nulls_begin =\n+        partitioner(indices_begin_, indices_end_, [&first_sort_key](uint64_t index) {\n+          int64_t index_chunk = 0;\n+          auto chunk = first_sort_key.ResolveChunk<ArrayType>(index, index_chunk);\n+          return !chunk->IsNull(index_chunk);\n+        });\n+    auto& comparer = comparer_;\n+    std::stable_sort(nulls_begin, indices_end_,\n+                     [&comparer](uint64_t left, uint64_t right) {\n+                       return comparer.Compare(left, right, 1);\n+                     });\n+    return nulls_begin;\n+  }\n+\n+  template <typename Type>\n+  enable_if_t<is_floating_type<Type>::value, uint64_t*> PartitionNullsInternal(\n+      const ResolvedSortKey& first_sort_key) {\n+    using ArrayType = typename TypeTraits<Type>::ArrayType;\n+    StablePartitioner partitioner;\n+    if (first_sort_key.null_count == 0) {\n+      return partitioner(indices_begin_, indices_end_, [&first_sort_key](uint64_t index) {\n+        int64_t index_chunk = 0;\n+        auto chunk = first_sort_key.ResolveChunk<ArrayType>(index, index_chunk);\n+        return !std::isnan(chunk->GetView(index_chunk));\n+      });\n+    }\n+    auto nans_and_nulls_begin =\n+        partitioner(indices_begin_, indices_end_, [&first_sort_key](uint64_t index) {\n+          int64_t index_chunk = 0;\n+          auto chunk = first_sort_key.ResolveChunk<ArrayType>(index, index_chunk);\n+          return !chunk->IsNull(index_chunk) && !std::isnan(chunk->GetView(index_chunk));\n+        });\n+    auto nulls_begin = nans_and_nulls_begin;\n+    if (first_sort_key.null_count < static_cast<int64_t>(indices_end_ - nulls_begin)) {\n+      // move Nulls after NaN\n+      nulls_begin = partitioner(\n+          nans_and_nulls_begin, indices_end_, [&first_sort_key](uint64_t index) {\n+            int64_t index_chunk = 0;\n+            auto chunk = first_sort_key.ResolveChunk<ArrayType>(index, index_chunk);\n+            return !chunk->IsNull(index_chunk);\n+          });\n+    }\n+    auto& comparer = comparer_;\n+    if (nans_and_nulls_begin != nulls_begin) {\n+      std::stable_sort(nans_and_nulls_begin, nulls_begin,\n+                       [&comparer](uint64_t left, uint64_t right) {\n+                         return comparer.Compare(left, right, 1);\n+                       });\n+    }\n+    std::stable_sort(nulls_begin, indices_end_,\n+                     [&comparer](uint64_t left, uint64_t right) {\n+                       return comparer.Compare(left, right, 1);\n+                     });\n+    return nans_and_nulls_begin;\n+  }\n+\n+  uint64_t* indices_begin_;\n+  uint64_t* indices_end_;\n+  Comparer comparer_;\n+};\n+\n const FunctionDoc sort_indices_doc(\n+    \"Return the indices that would sort an array, record batch or table\",\n+    (\"This function computes an array of indices that define a stable sort\\n\"\n+     \"of the input array, record batch or table.  Null values are considered\\n\"\n+     \"greater than any other value and are therefore sorted at the end of the\\n\"\n+     \"input. For floating-point types, NaNs are considered greater than any\\n\"\n+     \"other non-null value, but smaller than null values.\"),\n+    {\"input\"}, \"SortOptions\");\n+\n+class SortIndicesMetaFunction : public MetaFunction {\n+ public:\n+  SortIndicesMetaFunction()\n+      : MetaFunction(\"sort_indices\", Arity::Unary(), &sort_indices_doc) {}\n+\n+  Result<Datum> ExecuteImpl(const std::vector<Datum>& args,\n+                            const FunctionOptions* options,\n+                            ExecContext* ctx) const override {\n+    const SortOptions& sort_options = static_cast<const SortOptions&>(*options);\n+    switch (args[0].kind()) {\n+      case Datum::ARRAY:\n+        return SortIndices(*args[0].make_array(), sort_options, ctx);\n+        break;\n+      case Datum::CHUNKED_ARRAY:\n+        return SortIndices(*args[0].chunked_array(), sort_options, ctx);\n+        break;\n+      case Datum::RECORD_BATCH: {\n+        ARROW_ASSIGN_OR_RAISE(auto table,\n+                              Table::FromRecordBatches({args[0].record_batch()}));\n+        return SortIndices(*table, sort_options, ctx);\n+      } break;\n+      case Datum::TABLE:\n+        return SortIndices(*args[0].table(), sort_options, ctx);\n+        break;\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for sort_indices operation: \"\n+        \"values=\",\n+        args[0].ToString());\n+  }\n+\n+ private:\n+  Result<std::shared_ptr<Array>> SortIndices(const Array& values,\n+                                             const SortOptions& options,\n+                                             ExecContext* ctx) const {\n+    SortOrder order = SortOrder::ASCENDING;\n+    if (!options.sort_keys.empty()) {\n+      order = options.sort_keys[0].order;\n+    }\n+    ArraySortOptions array_options(order);\n+    ARROW_ASSIGN_OR_RAISE(\n+        Datum result, CallFunction(\"array_sort_indices\", {values}, &array_options, ctx));\n+    return result.make_array();\n+  }\n+\n+  Result<std::shared_ptr<Array>> SortIndices(const ChunkedArray& values,\n+                                             const SortOptions& options,\n+                                             ExecContext* ctx) const {\n+    SortOrder order = SortOrder::ASCENDING;\n+    if (!options.sort_keys.empty()) {\n+      order = options.sort_keys[0].order;\n+    }\n+    ArraySortOptions array_options(order);\n+\n+    std::shared_ptr<Array> array_values;\n+    if (values.num_chunks() == 1) {\n+      array_values = values.chunk(0);\n+    } else {\n+      ARROW_ASSIGN_OR_RAISE(array_values,\n+                            Concatenate(values.chunks(), ctx->memory_pool()));\n\nReview comment:\n       This is weird. Why are you concatenating chunks for the ChunkedArray case but not for the Table case? I would expect both cases to be handled similarly (regardless of the solution).\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -346,14 +374,396 @@ void AddSortingKernels(VectorKernel base, VectorFunction* func) {\n   }\n }\n \n+class TableSorter : public TypeVisitor {\n+ private:\n+  struct ResolvedSortKey {\n+    ResolvedSortKey(const ChunkedArray& chunked_array, const SortOrder order)\n+        : order(order) {\n+      type = chunked_array.type().get();\n+      null_count = chunked_array.null_count();\n+      num_chunks = chunked_array.num_chunks();\n+      for (const auto& chunk : chunked_array.chunks()) {\n+        chunks.push_back(chunk.get());\n+      }\n+    }\n+\n+    template <typename ArrayType>\n+    ArrayType* ResolveChunk(int64_t index, int64_t& chunk_index) const {\n+      if (num_chunks == 1) {\n+        chunk_index = index;\n+        return static_cast<ArrayType*>(chunks[0]);\n+      } else {\n+        int64_t offset = 0;\n+        for (size_t i = 0; i < num_chunks; ++i) {\n+          if (index < offset + chunks[i]->length()) {\n+            chunk_index = index - offset;\n+            return static_cast<ArrayType*>(chunks[i]);\n+          }\n+          offset += chunks[i]->length();\n+        }\n+        return nullptr;\n+      }\n+    }\n+\n+    SortOrder order;\n+    DataType* type;\n+    int64_t null_count;\n+    size_t num_chunks;\n+    std::vector<Array*> chunks;\n+  };\n+\n+  class Comparer : public TypeVisitor {\n+   public:\n+    Comparer(const Table& table, const std::vector<SortKey>& sort_keys)\n+        : TypeVisitor(), status_(Status::OK()) {\n+      for (const auto& sort_key : sort_keys) {\n+        const auto& chunked_array = table.GetColumnByName(sort_key.name);\n+        if (!chunked_array) {\n+          status_ = Status::Invalid(\"Nonexistent sort key column: \", sort_key.name);\n+          return;\n+        }\n+        sort_keys_.emplace_back(*chunked_array, sort_key.order);\n+      }\n+    }\n+\n+    Status status() { return status_; }\n+\n+    const std::vector<ResolvedSortKey>& sort_keys() { return sort_keys_; }\n+\n+    bool Compare(uint64_t left, uint64_t right, size_t start_sort_key_index) {\n+      current_left_ = left;\n+      current_right_ = right;\n+      current_compared_ = 0;\n+      auto num_sort_keys = sort_keys_.size();\n+      for (size_t i = start_sort_key_index; i < num_sort_keys; ++i) {\n+        current_sort_key_index_ = i;\n+        status_ = sort_keys_[i].type->Accept(this);\n+        if (current_compared_ != 0) {\n+          break;\n+        }\n+      }\n+      return current_compared_ < 0;\n+    }\n+\n+#define VISIT(TYPE)                                \\\n+  Status Visit(const TYPE##Type& type) override {  \\\n+    current_compared_ = CompareType<TYPE##Type>(); \\\n+    return Status::OK();                           \\\n+  }\n+\n+    VISIT(Int8)\n+    VISIT(Int16)\n+    VISIT(Int32)\n+    VISIT(Int64)\n+    VISIT(UInt8)\n+    VISIT(UInt16)\n+    VISIT(UInt32)\n+    VISIT(UInt64)\n+    VISIT(Float)\n+    VISIT(Double)\n+    VISIT(String)\n+    VISIT(Binary)\n+    VISIT(LargeString)\n+    VISIT(LargeBinary)\n+\n+#undef VISIT\n+\n+   private:\n+    template <typename Type>\n+    int32_t CompareType() {\n+      using ArrayType = typename TypeTraits<Type>::ArrayType;\n+      const auto& sort_key = sort_keys_[current_sort_key_index_];\n+      auto order = sort_key.order;\n+      int64_t index_left = 0;\n+      auto array_left = sort_key.ResolveChunk<ArrayType>(current_left_, index_left);\n+      int64_t index_right = 0;\n+      auto array_right = sort_key.ResolveChunk<ArrayType>(current_right_, index_right);\n+      if (sort_key.null_count > 0) {\n+        auto is_null_left = array_left->IsNull(index_left);\n+        auto is_null_right = array_right->IsNull(index_right);\n+        if (is_null_left && is_null_right) {\n+          return 0;\n+        } else if (is_null_left) {\n+          return 1;\n+        } else if (is_null_right) {\n+          return -1;\n+        }\n+      }\n+      auto left = array_left->GetView(index_left);\n+      auto right = array_right->GetView(index_right);\n+      int32_t compared;\n+      if (left == right) {\n+        compared = 0;\n+      } else if (left > right) {\n+        compared = 1;\n+      } else {\n+        compared = -1;\n+      }\n+      if (order == SortOrder::DESCENDING) {\n+        compared = -compared;\n+      }\n+      return compared;\n+    }\n+\n+    Status status_;\n+    std::vector<ResolvedSortKey> sort_keys_;\n+    int64_t current_left_;\n+    int64_t current_right_;\n+    size_t current_sort_key_index_;\n+    int32_t current_compared_;\n+  };\n+\n+ public:\n+  TableSorter(uint64_t* indices_begin, uint64_t* indices_end, const Table& table,\n+              const SortOptions& options)\n+      : indices_begin_(indices_begin),\n+        indices_end_(indices_end),\n+        comparer_(table, options.sort_keys) {}\n+\n+  Status Sort() {\n+    ARROW_RETURN_NOT_OK(comparer_.status());\n+    return comparer_.sort_keys()[0].type->Accept(this);\n+  }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE##Type& type) override { return SortInternal<TYPE##Type>(); }\n+\n+  VISIT(Int8)\n+  VISIT(Int16)\n+  VISIT(Int32)\n+  VISIT(Int64)\n+  VISIT(UInt8)\n+  VISIT(UInt16)\n+  VISIT(UInt32)\n+  VISIT(UInt64)\n+  VISIT(Float)\n+  VISIT(Double)\n+  VISIT(String)\n+  VISIT(Binary)\n+  VISIT(LargeString)\n+  VISIT(LargeBinary)\n+\n+#undef VISIT\n+\n+ private:\n+  template <typename Type>\n+  Status SortInternal() {\n\nReview comment:\n       Can you add comments when you define a non-trivial class or method?\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.h\n##########\n@@ -58,6 +58,34 @@ struct ARROW_EXPORT TakeOptions : public FunctionOptions {\n   static TakeOptions Defaults() { return BoundsCheck(); }\n };\n \n+enum SortOrder {\n+  ASCENDING,\n+  DESCENDING,\n+};\n+\n+/// \\brief One sort key for PartitionNthIndices (TODO) and SortIndices\n+struct ARROW_EXPORT SortKey {\n+  explicit SortKey(std::string name, SortOrder order = ASCENDING)\n+      : name(name), order(order) {}\n+\n+  /// The name of the sort key.\n+  std::string name;\n+  /// How to order by this sort key.\n+  SortOrder order;\n+};\n+\n+struct ARROW_EXPORT ArraySortOptions : public FunctionOptions {\n+  explicit ArraySortOptions(SortOrder order = SortOrder::ASCENDING) : order(order) {}\n+\n+  SortOrder order;\n+};\n+\n+struct ARROW_EXPORT SortOptions : public FunctionOptions {\n\nReview comment:\n       Perhaps name this \"TableSortOptions\"?\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.h\n##########\n@@ -58,6 +58,34 @@ struct ARROW_EXPORT TakeOptions : public FunctionOptions {\n   static TakeOptions Defaults() { return BoundsCheck(); }\n };\n \n+enum SortOrder {\n+  ASCENDING,\n+  DESCENDING,\n+};\n+\n+/// \\brief One sort key for PartitionNthIndices (TODO) and SortIndices\n+struct ARROW_EXPORT SortKey {\n+  explicit SortKey(std::string name, SortOrder order = ASCENDING)\n+      : name(name), order(order) {}\n+\n+  /// The name of the sort key.\n\nReview comment:\n       You mean sort column?\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.h\n##########\n@@ -165,8 +194,50 @@ Result<std::shared_ptr<Array>> NthToIndices(const Array& values, int64_t n,\n /// \\param[in] ctx the function execution context, optional\n /// \\return offsets indices that would sort an array\n ARROW_EXPORT\n-Result<std::shared_ptr<Array>> SortToIndices(const Array& values,\n-                                             ExecContext* ctx = NULLPTR);\n+Result<std::shared_ptr<Array>> SortIndices(const Array& values,\n+                                           ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Returns the indices that would sort an array in the\n+/// specified order.\n+///\n+/// Perform an indirect sort of array. The output array will contain\n+/// indices that would sort an array, which would be the same length\n+/// as input. Nulls will be stably partitioned to the end of the output.\n+///\n+/// For example given values = [null, 1, 3.3, null, 2, 5.3] and order\n+/// = SortOrder::DESCENDING, the output will be [5, 2, 4, 1, 0,\n+/// 3].\n+///\n+/// \\param[in] values array to sort\n+/// \\param[in] order ascending or descending\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return offsets indices that would sort an array\n+ARROW_EXPORT\n+Result<std::shared_ptr<Array>> SortIndices(const Array& values, SortOrder order,\n\nReview comment:\n       Why not `order = SortOrder::Ascending`? This would avoid declaring two separate overloads.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -346,14 +374,396 @@ void AddSortingKernels(VectorKernel base, VectorFunction* func) {\n   }\n }\n \n+class TableSorter : public TypeVisitor {\n+ private:\n+  struct ResolvedSortKey {\n+    ResolvedSortKey(const ChunkedArray& chunked_array, const SortOrder order)\n+        : order(order) {\n+      type = chunked_array.type().get();\n+      null_count = chunked_array.null_count();\n+      num_chunks = chunked_array.num_chunks();\n+      for (const auto& chunk : chunked_array.chunks()) {\n+        chunks.push_back(chunk.get());\n+      }\n+    }\n+\n+    template <typename ArrayType>\n+    ArrayType* ResolveChunk(int64_t index, int64_t& chunk_index) const {\n\nReview comment:\n       Can you add a comment describing what this method does?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -346,14 +374,396 @@ void AddSortingKernels(VectorKernel base, VectorFunction* func) {\n   }\n }\n \n+class TableSorter : public TypeVisitor {\n+ private:\n+  struct ResolvedSortKey {\n+    ResolvedSortKey(const ChunkedArray& chunked_array, const SortOrder order)\n+        : order(order) {\n+      type = chunked_array.type().get();\n+      null_count = chunked_array.null_count();\n+      num_chunks = chunked_array.num_chunks();\n+      for (const auto& chunk : chunked_array.chunks()) {\n+        chunks.push_back(chunk.get());\n+      }\n+    }\n+\n+    template <typename ArrayType>\n+    ArrayType* ResolveChunk(int64_t index, int64_t& chunk_index) const {\n+      if (num_chunks == 1) {\n+        chunk_index = index;\n+        return static_cast<ArrayType*>(chunks[0]);\n+      } else {\n+        int64_t offset = 0;\n+        for (size_t i = 0; i < num_chunks; ++i) {\n+          if (index < offset + chunks[i]->length()) {\n+            chunk_index = index - offset;\n+            return static_cast<ArrayType*>(chunks[i]);\n+          }\n+          offset += chunks[i]->length();\n+        }\n+        return nullptr;\n+      }\n+    }\n+\n+    SortOrder order;\n+    DataType* type;\n+    int64_t null_count;\n+    size_t num_chunks;\n+    std::vector<Array*> chunks;\n+  };\n+\n+  class Comparer : public TypeVisitor {\n+   public:\n+    Comparer(const Table& table, const std::vector<SortKey>& sort_keys)\n+        : TypeVisitor(), status_(Status::OK()) {\n+      for (const auto& sort_key : sort_keys) {\n+        const auto& chunked_array = table.GetColumnByName(sort_key.name);\n+        if (!chunked_array) {\n+          status_ = Status::Invalid(\"Nonexistent sort key column: \", sort_key.name);\n+          return;\n+        }\n+        sort_keys_.emplace_back(*chunked_array, sort_key.order);\n+      }\n+    }\n+\n+    Status status() { return status_; }\n+\n+    const std::vector<ResolvedSortKey>& sort_keys() { return sort_keys_; }\n+\n+    bool Compare(uint64_t left, uint64_t right, size_t start_sort_key_index) {\n\nReview comment:\n       Add a comment?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort_test.cc\n##########\n@@ -364,32 +400,264 @@ TYPED_TEST(TestSortToIndicesKernelRandomCount, SortRandomValuesCount) {\n   int range = 2000;\n   for (int test = 0; test < times; test++) {\n     for (auto null_probability : {0.0, 0.1, 0.5, 1.0}) {\n-      auto array = rand.Generate(length, range, null_probability);\n-      ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> offsets, SortToIndices(*array));\n-      ValidateSorted<ArrayType>(*checked_pointer_cast<ArrayType>(array),\n-                                *checked_pointer_cast<UInt64Array>(offsets));\n+      for (auto order : {SortOrder::ASCENDING, SortOrder::DESCENDING}) {\n+        auto array = rand.Generate(length, range, null_probability);\n+        ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> offsets, SortIndices(*array, order));\n+        ValidateSorted<ArrayType>(*checked_pointer_cast<ArrayType>(array),\n+                                  *checked_pointer_cast<UInt64Array>(offsets), order);\n+      }\n     }\n   }\n }\n \n // Long array with big value range: std::stable_sort\n-TYPED_TEST_SUITE(TestSortToIndicesKernelRandomCompare, IntegralArrowTypes);\n+TYPED_TEST_SUITE(TestArraySortIndicesKernelRandomCompare, IntegralArrowTypes);\n \n-TYPED_TEST(TestSortToIndicesKernelRandomCompare, SortRandomValuesCompare) {\n+TYPED_TEST(TestArraySortIndicesKernelRandomCompare, SortRandomValuesCompare) {\n   using ArrayType = typename TypeTraits<TypeParam>::ArrayType;\n \n   Random<TypeParam> rand(0x5487657);\n   int times = 5;\n   int length = 4000;\n   for (int test = 0; test < times; test++) {\n     for (auto null_probability : {0.0, 0.1, 0.5, 1.0}) {\n-      auto array = rand.Generate(length, null_probability);\n-      ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> offsets, SortToIndices(*array));\n-      ValidateSorted<ArrayType>(*checked_pointer_cast<ArrayType>(array),\n-                                *checked_pointer_cast<UInt64Array>(offsets));\n+      for (auto order : {SortOrder::ASCENDING, SortOrder::DESCENDING}) {\n+        auto array = rand.Generate(length, null_probability);\n+        ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> offsets, SortIndices(*array, order));\n+        ValidateSorted<ArrayType>(*checked_pointer_cast<ArrayType>(array),\n+                                  *checked_pointer_cast<UInt64Array>(offsets), order);\n+      }\n     }\n   }\n }\n \n+class TestTableSortIndices : public ::testing::Test {\n+ protected:\n+  void AssertSortIndices(const std::shared_ptr<Table> table, const SortOptions& options,\n+                         const std::shared_ptr<Array> expected) {\n+    ASSERT_OK_AND_ASSIGN(auto actual, SortIndices(*table, options));\n+    AssertArraysEqual(*expected, *actual);\n+  }\n+\n+  void AssertSortIndices(const std::shared_ptr<Table> table, const SortOptions& options,\n+                         const std::string expected) {\n+    AssertSortIndices(table, options, ArrayFromJSON(uint64(), expected));\n+  }\n+};\n+\n+TEST_F(TestTableSortIndices, SortNull) {\n+  auto table = TableFromJSON(schema({\n+                                 {field(\"a\", uint8())},\n+                                 {field(\"b\", uint8())},\n+                             }),\n+                             {\"[\"\n+                              \"{\\\"a\\\": null, \\\"b\\\": 5},\"\n+                              \"{\\\"a\\\": 1,    \\\"b\\\": 3},\"\n+                              \"{\\\"a\\\": 3,    \\\"b\\\": null},\"\n+                              \"{\\\"a\\\": null, \\\"b\\\": null},\"\n+                              \"{\\\"a\\\": 2,    \\\"b\\\": 5},\"\n+                              \"{\\\"a\\\": 1,    \\\"b\\\": 5}\"\n+                              \"]\"});\n+  SortOptions options(\n+      {SortKey(\"a\", SortOrder::ASCENDING), SortKey(\"b\", SortOrder::DESCENDING)});\n+  this->AssertSortIndices(table, options, \"[5, 1, 4, 2, 0, 3]\");\n+}\n+\n+TEST_F(TestTableSortIndices, SortNaN) {\n+  auto table = TableFromJSON(schema({\n+                                 {field(\"a\", float32())},\n+                                 {field(\"b\", float32())},\n+                             }),\n+                             {\"[\"\n+                              \"{\\\"a\\\": null, \\\"b\\\": 5},\"\n+                              \"{\\\"a\\\": 1,    \\\"b\\\": 3},\"\n+                              \"{\\\"a\\\": 3,    \\\"b\\\": null},\"\n+                              \"{\\\"a\\\": null, \\\"b\\\": null},\"\n+                              \"{\\\"a\\\": NaN,  \\\"b\\\": null},\"\n+                              \"{\\\"a\\\": NaN,  \\\"b\\\": 5},\"\n+                              \"{\\\"a\\\": NaN,  \\\"b\\\": NaN},\"\n+                              \"{\\\"a\\\": 1,    \\\"b\\\": 5}\"\n+                              \"]\"});\n+  SortOptions options(\n+      {SortKey(\"a\", SortOrder::ASCENDING), SortKey(\"b\", SortOrder::DESCENDING)});\n+  this->AssertSortIndices(table, options, \"[7, 1, 2, 5, 6, 4, 0, 3]\");\n+}\n+\n+using RandomParam = std::tuple<std::string, double>;\n+class TestTableSortIndicesRandom : public testing::TestWithParam<RandomParam> {\n+  class Comparator : public TypeVisitor {\n+   public:\n+    bool operator()(const Table& table, const SortOptions& options, uint64_t lhs,\n+                    uint64_t rhs) {\n+      lhs_ = lhs;\n+      rhs_ = rhs;\n+      for (const auto& sort_key : options.sort_keys) {\n+        auto chunked_array = table.GetColumnByName(sort_key.name);\n+        lhs_array_ = findTargetArray(chunked_array, lhs, lhs_index_);\n+        rhs_array_ = findTargetArray(chunked_array, rhs, rhs_index_);\n+        if (rhs_array_->IsNull(rhs_index_) && lhs_array_->IsNull(lhs_index_)) continue;\n+        if (rhs_array_->IsNull(rhs_index_)) return true;\n+        if (lhs_array_->IsNull(lhs_index_)) return false;\n+        status_ = lhs_array_->type()->Accept(this);\n+        if (compared_ == 0) continue;\n+        if (sort_key.order == SortOrder::ASCENDING) {\n+          return compared_ < 0;\n+        } else {\n+          return compared_ > 0;\n+        }\n+      }\n+      return lhs < rhs;\n+    }\n+\n+    Status status() const { return status_; }\n+\n+#define VISIT(TYPE)                               \\\n+  Status Visit(const TYPE##Type& type) override { \\\n+    compared_ = CompareType<TYPE##Type>();        \\\n+    return Status::OK();                          \\\n+  }\n+\n+    VISIT(Int8)\n+    VISIT(Int16)\n+    VISIT(Int32)\n+    VISIT(Int64)\n+    VISIT(UInt8)\n+    VISIT(UInt16)\n+    VISIT(UInt32)\n+    VISIT(UInt64)\n+    VISIT(Float)\n+    VISIT(Double)\n+    VISIT(String)\n+\n+#undef VISIT\n+\n+   private:\n+    std::shared_ptr<Array> findTargetArray(std::shared_ptr<ChunkedArray> chunked_array,\n\nReview comment:\n       I would expect `const Array* FindTargetArray(const ChunkedArray&, int64_t index, int64_t* chunk_index)`\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -346,14 +374,396 @@ void AddSortingKernels(VectorKernel base, VectorFunction* func) {\n   }\n }\n \n+class TableSorter : public TypeVisitor {\n+ private:\n+  struct ResolvedSortKey {\n+    ResolvedSortKey(const ChunkedArray& chunked_array, const SortOrder order)\n+        : order(order) {\n+      type = chunked_array.type().get();\n+      null_count = chunked_array.null_count();\n+      num_chunks = chunked_array.num_chunks();\n+      for (const auto& chunk : chunked_array.chunks()) {\n+        chunks.push_back(chunk.get());\n+      }\n+    }\n+\n+    template <typename ArrayType>\n+    ArrayType* ResolveChunk(int64_t index, int64_t& chunk_index) const {\n+      if (num_chunks == 1) {\n+        chunk_index = index;\n+        return static_cast<ArrayType*>(chunks[0]);\n+      } else {\n+        int64_t offset = 0;\n+        for (size_t i = 0; i < num_chunks; ++i) {\n+          if (index < offset + chunks[i]->length()) {\n+            chunk_index = index - offset;\n+            return static_cast<ArrayType*>(chunks[i]);\n+          }\n+          offset += chunks[i]->length();\n+        }\n+        return nullptr;\n+      }\n+    }\n+\n+    SortOrder order;\n+    DataType* type;\n+    int64_t null_count;\n+    size_t num_chunks;\n+    std::vector<Array*> chunks;\n+  };\n+\n+  class Comparer : public TypeVisitor {\n+   public:\n+    Comparer(const Table& table, const std::vector<SortKey>& sort_keys)\n+        : TypeVisitor(), status_(Status::OK()) {\n+      for (const auto& sort_key : sort_keys) {\n+        const auto& chunked_array = table.GetColumnByName(sort_key.name);\n+        if (!chunked_array) {\n+          status_ = Status::Invalid(\"Nonexistent sort key column: \", sort_key.name);\n+          return;\n+        }\n+        sort_keys_.emplace_back(*chunked_array, sort_key.order);\n+      }\n+    }\n+\n+    Status status() { return status_; }\n+\n+    const std::vector<ResolvedSortKey>& sort_keys() { return sort_keys_; }\n+\n+    bool Compare(uint64_t left, uint64_t right, size_t start_sort_key_index) {\n+      current_left_ = left;\n+      current_right_ = right;\n+      current_compared_ = 0;\n+      auto num_sort_keys = sort_keys_.size();\n+      for (size_t i = start_sort_key_index; i < num_sort_keys; ++i) {\n+        current_sort_key_index_ = i;\n+        status_ = sort_keys_[i].type->Accept(this);\n+        if (current_compared_ != 0) {\n+          break;\n+        }\n+      }\n+      return current_compared_ < 0;\n+    }\n+\n+#define VISIT(TYPE)                                \\\n+  Status Visit(const TYPE##Type& type) override {  \\\n+    current_compared_ = CompareType<TYPE##Type>(); \\\n+    return Status::OK();                           \\\n+  }\n+\n+    VISIT(Int8)\n+    VISIT(Int16)\n+    VISIT(Int32)\n+    VISIT(Int64)\n+    VISIT(UInt8)\n+    VISIT(UInt16)\n+    VISIT(UInt32)\n+    VISIT(UInt64)\n+    VISIT(Float)\n+    VISIT(Double)\n+    VISIT(String)\n+    VISIT(Binary)\n+    VISIT(LargeString)\n+    VISIT(LargeBinary)\n+\n+#undef VISIT\n+\n+   private:\n+    template <typename Type>\n+    int32_t CompareType() {\n+      using ArrayType = typename TypeTraits<Type>::ArrayType;\n+      const auto& sort_key = sort_keys_[current_sort_key_index_];\n+      auto order = sort_key.order;\n+      int64_t index_left = 0;\n+      auto array_left = sort_key.ResolveChunk<ArrayType>(current_left_, index_left);\n+      int64_t index_right = 0;\n+      auto array_right = sort_key.ResolveChunk<ArrayType>(current_right_, index_right);\n+      if (sort_key.null_count > 0) {\n+        auto is_null_left = array_left->IsNull(index_left);\n+        auto is_null_right = array_right->IsNull(index_right);\n+        if (is_null_left && is_null_right) {\n+          return 0;\n+        } else if (is_null_left) {\n+          return 1;\n+        } else if (is_null_right) {\n+          return -1;\n+        }\n+      }\n+      auto left = array_left->GetView(index_left);\n+      auto right = array_right->GetView(index_right);\n+      int32_t compared;\n+      if (left == right) {\n+        compared = 0;\n+      } else if (left > right) {\n+        compared = 1;\n+      } else {\n+        compared = -1;\n+      }\n+      if (order == SortOrder::DESCENDING) {\n+        compared = -compared;\n+      }\n+      return compared;\n+    }\n+\n+    Status status_;\n+    std::vector<ResolvedSortKey> sort_keys_;\n+    int64_t current_left_;\n+    int64_t current_right_;\n+    size_t current_sort_key_index_;\n+    int32_t current_compared_;\n+  };\n+\n+ public:\n+  TableSorter(uint64_t* indices_begin, uint64_t* indices_end, const Table& table,\n+              const SortOptions& options)\n+      : indices_begin_(indices_begin),\n+        indices_end_(indices_end),\n+        comparer_(table, options.sort_keys) {}\n+\n+  Status Sort() {\n+    ARROW_RETURN_NOT_OK(comparer_.status());\n+    return comparer_.sort_keys()[0].type->Accept(this);\n+  }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE##Type& type) override { return SortInternal<TYPE##Type>(); }\n+\n+  VISIT(Int8)\n+  VISIT(Int16)\n+  VISIT(Int32)\n+  VISIT(Int64)\n+  VISIT(UInt8)\n+  VISIT(UInt16)\n+  VISIT(UInt32)\n+  VISIT(UInt64)\n+  VISIT(Float)\n+  VISIT(Double)\n+  VISIT(String)\n+  VISIT(Binary)\n+  VISIT(LargeString)\n+  VISIT(LargeBinary)\n+\n+#undef VISIT\n+\n+ private:\n+  template <typename Type>\n+  Status SortInternal() {\n+    using ArrayType = typename TypeTraits<Type>::ArrayType;\n+    std::iota(indices_begin_, indices_end_, 0);\n+\n+    auto& comparer = comparer_;\n+    const auto& first_sort_key = comparer.sort_keys()[0];\n+    auto nulls_begin = indices_end_;\n+    nulls_begin = PartitionNullsInternal<Type>(first_sort_key);\n+    std::stable_sort(\n+        indices_begin_, nulls_begin,\n+        [&first_sort_key, &comparer](uint64_t left, uint64_t right) {\n+          int64_t index_left = 0;\n+          auto array_left = first_sort_key.ResolveChunk<ArrayType>(left, index_left);\n+          int64_t index_right = 0;\n+          auto array_right = first_sort_key.ResolveChunk<ArrayType>(right, index_right);\n+          auto value_left = array_left->GetView(index_left);\n+          auto value_right = array_right->GetView(index_right);\n+          if (value_left == value_right) {\n+            return comparer.Compare(left, right, 1);\n\nReview comment:\n       Performance will probably be very bad if there are lots of equal values in the first column, right?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort_test.cc\n##########\n@@ -228,134 +233,165 @@ TYPED_TEST(TestNthToIndicesRandom, RandomValues) {\n using arrow::internal::checked_pointer_cast;\n \n template <typename ArrowType>\n-class TestSortToIndicesKernel : public TestBase {\n+class TestArraySortIndicesKernel : public TestBase {\n  private:\n-  void AssertSortToIndicesArrays(const std::shared_ptr<Array> values,\n-                                 const std::shared_ptr<Array> expected) {\n-    ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> actual, SortToIndices(*values));\n+  void AssertArraysSortIndices(const std::shared_ptr<Array> values, SortOrder order,\n+                               const std::shared_ptr<Array> expected) {\n+    ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> actual, SortIndices(*values, order));\n     ASSERT_OK(actual->ValidateFull());\n     AssertArraysEqual(*expected, *actual);\n   }\n \n  protected:\n-  virtual void AssertSortToIndices(const std::string& values,\n-                                   const std::string& expected) {\n+  virtual void AssertSortIndices(const std::string& values, SortOrder order,\n+                                 const std::string& expected) {\n     auto type = TypeTraits<ArrowType>::type_singleton();\n-    AssertSortToIndicesArrays(ArrayFromJSON(type, values),\n-                              ArrayFromJSON(uint64(), expected));\n+    AssertArraysSortIndices(ArrayFromJSON(type, values), order,\n+                            ArrayFromJSON(uint64(), expected));\n+  }\n+\n+  virtual void AssertSortIndices(const std::string& values, const std::string& expected) {\n+    AssertSortIndices(values, SortOrder::ASCENDING, expected);\n   }\n };\n \n template <typename ArrowType>\n-class TestSortToIndicesKernelForReal : public TestSortToIndicesKernel<ArrowType> {};\n-TYPED_TEST_SUITE(TestSortToIndicesKernelForReal, RealArrowTypes);\n+class TestArraySortIndicesKernelForReal : public TestArraySortIndicesKernel<ArrowType> {};\n+TYPED_TEST_SUITE(TestArraySortIndicesKernelForReal, RealArrowTypes);\n \n template <typename ArrowType>\n-class TestSortToIndicesKernelForIntegral : public TestSortToIndicesKernel<ArrowType> {};\n-TYPED_TEST_SUITE(TestSortToIndicesKernelForIntegral, IntegralArrowTypes);\n+class TestArraySortIndicesKernelForIntegral\n+    : public TestArraySortIndicesKernel<ArrowType> {};\n+TYPED_TEST_SUITE(TestArraySortIndicesKernelForIntegral, IntegralArrowTypes);\n \n template <typename ArrowType>\n-class TestSortToIndicesKernelForStrings : public TestSortToIndicesKernel<ArrowType> {};\n-TYPED_TEST_SUITE(TestSortToIndicesKernelForStrings, testing::Types<StringType>);\n+class TestArraySortIndicesKernelForStrings\n+    : public TestArraySortIndicesKernel<ArrowType> {};\n+TYPED_TEST_SUITE(TestArraySortIndicesKernelForStrings, testing::Types<StringType>);\n+\n+TYPED_TEST(TestArraySortIndicesKernelForReal, SortReal) {\n+  this->AssertSortIndices(\"[]\", \"[]\");\n+\n+  this->AssertSortIndices(\"[3.4, 2.6, 6.3]\", \"[1, 0, 2]\");\n+  this->AssertSortIndices(\"[1.1, 2.4, 3.5, 4.3, 5.1, 6.8, 7.3]\", \"[0,1,2,3,4,5,6]\");\n\nReview comment:\n       Nit, but can you always use the same convention for spacing JSON values?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort_benchmark.cc\n##########\n@@ -56,17 +57,99 @@ static void SortToIndicesInt64Compare(benchmark::State& state) {\n   auto max = std::numeric_limits<int64_t>::max();\n   auto values = rand.Int64(array_size, min, max, args.null_proportion);\n \n-  SortToIndicesBenchmark(state, values);\n+  ArraySortIndicesBenchmark(state, values);\n }\n \n-BENCHMARK(SortToIndicesInt64Count)\n+static void TableSortIndicesBenchmark(benchmark::State& state,\n+                                      const std::shared_ptr<Table>& table,\n+                                      const SortOptions& options) {\n+  for (auto _ : state) {\n+    ABORT_NOT_OK(SortIndices(*table, options).status());\n+  }\n+  state.SetItemsProcessed(state.iterations() * table->num_rows());\n+}\n+\n+static void TableSortIndicesInt64Count(benchmark::State& state) {\n+  RegressionArgs args(state);\n+\n+  const int64_t array_size = args.size / sizeof(int64_t);\n+  auto rand = random::RandomArrayGenerator(kSeed);\n+  auto values = rand.Int64(array_size, -100, 100, args.null_proportion);\n+  std::vector<std::shared_ptr<Field>> fields = {{field(\"int64\", int64())}};\n+  auto table = Table::Make(schema(fields), {values}, array_size);\n+  SortOptions options({SortKey(\"int64\", SortOrder::ASCENDING)});\n+\n+  TableSortIndicesBenchmark(state, table, options);\n+}\n+\n+static void TableSortIndicesInt64Compare(benchmark::State& state) {\n+  RegressionArgs args(state);\n+\n+  const int64_t array_size = args.size / sizeof(int64_t);\n+  auto rand = random::RandomArrayGenerator(kSeed);\n+\n+  auto min = std::numeric_limits<int64_t>::min();\n+  auto max = std::numeric_limits<int64_t>::max();\n+  auto values = rand.Int64(array_size, min, max, args.null_proportion);\n+  std::vector<std::shared_ptr<Field>> fields = {{field(\"int64\", int64())}};\n+  auto table = Table::Make(schema(fields), {values}, array_size);\n+  SortOptions options({SortKey(\"int64\", SortOrder::ASCENDING)});\n+\n+  TableSortIndicesBenchmark(state, table, options);\n+}\n+\n+static void TableSortIndicesInt64Int64(benchmark::State& state) {\n+  RegressionArgs args(state);\n+\n+  const int64_t array_size = args.size / sizeof(int64_t);\n+  auto rand = random::RandomArrayGenerator(kSeed);\n+\n+  auto min = std::numeric_limits<int64_t>::min();\n+  auto max = std::numeric_limits<int64_t>::max();\n\nReview comment:\n       You will probably get almost no duplicate values with this.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -346,14 +374,396 @@ void AddSortingKernels(VectorKernel base, VectorFunction* func) {\n   }\n }\n \n+class TableSorter : public TypeVisitor {\n+ private:\n+  struct ResolvedSortKey {\n+    ResolvedSortKey(const ChunkedArray& chunked_array, const SortOrder order)\n+        : order(order) {\n+      type = chunked_array.type().get();\n+      null_count = chunked_array.null_count();\n+      num_chunks = chunked_array.num_chunks();\n+      for (const auto& chunk : chunked_array.chunks()) {\n+        chunks.push_back(chunk.get());\n+      }\n+    }\n+\n+    template <typename ArrayType>\n+    ArrayType* ResolveChunk(int64_t index, int64_t& chunk_index) const {\n+      if (num_chunks == 1) {\n+        chunk_index = index;\n+        return static_cast<ArrayType*>(chunks[0]);\n+      } else {\n+        int64_t offset = 0;\n+        for (size_t i = 0; i < num_chunks; ++i) {\n+          if (index < offset + chunks[i]->length()) {\n+            chunk_index = index - offset;\n+            return static_cast<ArrayType*>(chunks[i]);\n+          }\n+          offset += chunks[i]->length();\n+        }\n+        return nullptr;\n+      }\n+    }\n+\n+    SortOrder order;\n+    DataType* type;\n+    int64_t null_count;\n+    size_t num_chunks;\n+    std::vector<Array*> chunks;\n+  };\n+\n+  class Comparer : public TypeVisitor {\n+   public:\n+    Comparer(const Table& table, const std::vector<SortKey>& sort_keys)\n+        : TypeVisitor(), status_(Status::OK()) {\n+      for (const auto& sort_key : sort_keys) {\n+        const auto& chunked_array = table.GetColumnByName(sort_key.name);\n+        if (!chunked_array) {\n+          status_ = Status::Invalid(\"Nonexistent sort key column: \", sort_key.name);\n+          return;\n+        }\n+        sort_keys_.emplace_back(*chunked_array, sort_key.order);\n+      }\n+    }\n+\n+    Status status() { return status_; }\n+\n+    const std::vector<ResolvedSortKey>& sort_keys() { return sort_keys_; }\n+\n+    bool Compare(uint64_t left, uint64_t right, size_t start_sort_key_index) {\n+      current_left_ = left;\n+      current_right_ = right;\n+      current_compared_ = 0;\n+      auto num_sort_keys = sort_keys_.size();\n+      for (size_t i = start_sort_key_index; i < num_sort_keys; ++i) {\n+        current_sort_key_index_ = i;\n+        status_ = sort_keys_[i].type->Accept(this);\n+        if (current_compared_ != 0) {\n+          break;\n+        }\n+      }\n+      return current_compared_ < 0;\n+    }\n+\n+#define VISIT(TYPE)                                \\\n+  Status Visit(const TYPE##Type& type) override {  \\\n+    current_compared_ = CompareType<TYPE##Type>(); \\\n+    return Status::OK();                           \\\n+  }\n+\n+    VISIT(Int8)\n+    VISIT(Int16)\n+    VISIT(Int32)\n+    VISIT(Int64)\n+    VISIT(UInt8)\n+    VISIT(UInt16)\n+    VISIT(UInt32)\n+    VISIT(UInt64)\n+    VISIT(Float)\n+    VISIT(Double)\n+    VISIT(String)\n+    VISIT(Binary)\n+    VISIT(LargeString)\n+    VISIT(LargeBinary)\n+\n+#undef VISIT\n+\n+   private:\n+    template <typename Type>\n+    int32_t CompareType() {\n+      using ArrayType = typename TypeTraits<Type>::ArrayType;\n+      const auto& sort_key = sort_keys_[current_sort_key_index_];\n+      auto order = sort_key.order;\n+      int64_t index_left = 0;\n+      auto array_left = sort_key.ResolveChunk<ArrayType>(current_left_, index_left);\n+      int64_t index_right = 0;\n+      auto array_right = sort_key.ResolveChunk<ArrayType>(current_right_, index_right);\n+      if (sort_key.null_count > 0) {\n+        auto is_null_left = array_left->IsNull(index_left);\n+        auto is_null_right = array_right->IsNull(index_right);\n+        if (is_null_left && is_null_right) {\n+          return 0;\n+        } else if (is_null_left) {\n+          return 1;\n+        } else if (is_null_right) {\n+          return -1;\n+        }\n+      }\n+      auto left = array_left->GetView(index_left);\n+      auto right = array_right->GetView(index_right);\n+      int32_t compared;\n+      if (left == right) {\n+        compared = 0;\n+      } else if (left > right) {\n+        compared = 1;\n+      } else {\n+        compared = -1;\n+      }\n+      if (order == SortOrder::DESCENDING) {\n+        compared = -compared;\n+      }\n+      return compared;\n+    }\n+\n+    Status status_;\n+    std::vector<ResolvedSortKey> sort_keys_;\n+    int64_t current_left_;\n+    int64_t current_right_;\n+    size_t current_sort_key_index_;\n+    int32_t current_compared_;\n+  };\n+\n+ public:\n+  TableSorter(uint64_t* indices_begin, uint64_t* indices_end, const Table& table,\n+              const SortOptions& options)\n+      : indices_begin_(indices_begin),\n+        indices_end_(indices_end),\n+        comparer_(table, options.sort_keys) {}\n+\n+  Status Sort() {\n+    ARROW_RETURN_NOT_OK(comparer_.status());\n+    return comparer_.sort_keys()[0].type->Accept(this);\n+  }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE##Type& type) override { return SortInternal<TYPE##Type>(); }\n+\n+  VISIT(Int8)\n+  VISIT(Int16)\n+  VISIT(Int32)\n+  VISIT(Int64)\n+  VISIT(UInt8)\n+  VISIT(UInt16)\n+  VISIT(UInt32)\n+  VISIT(UInt64)\n+  VISIT(Float)\n+  VISIT(Double)\n+  VISIT(String)\n+  VISIT(Binary)\n+  VISIT(LargeString)\n+  VISIT(LargeBinary)\n+\n+#undef VISIT\n+\n+ private:\n+  template <typename Type>\n+  Status SortInternal() {\n+    using ArrayType = typename TypeTraits<Type>::ArrayType;\n+    std::iota(indices_begin_, indices_end_, 0);\n+\n+    auto& comparer = comparer_;\n+    const auto& first_sort_key = comparer.sort_keys()[0];\n+    auto nulls_begin = indices_end_;\n+    nulls_begin = PartitionNullsInternal<Type>(first_sort_key);\n+    std::stable_sort(\n+        indices_begin_, nulls_begin,\n+        [&first_sort_key, &comparer](uint64_t left, uint64_t right) {\n+          int64_t index_left = 0;\n+          auto array_left = first_sort_key.ResolveChunk<ArrayType>(left, index_left);\n+          int64_t index_right = 0;\n+          auto array_right = first_sort_key.ResolveChunk<ArrayType>(right, index_right);\n+          auto value_left = array_left->GetView(index_left);\n+          auto value_right = array_right->GetView(index_right);\n+          if (value_left == value_right) {\n+            return comparer.Compare(left, right, 1);\n+          } else {\n+            auto compared = value_left < value_right;\n+            if (first_sort_key.order == SortOrder::ASCENDING) {\n+              return compared;\n+            } else {\n+              return !compared;\n+            }\n+          }\n+        });\n+    return Status::OK();\n+  }\n+\n+  template <typename Type>\n+  enable_if_t<!is_floating_type<Type>::value, uint64_t*> PartitionNullsInternal(\n+      const ResolvedSortKey& first_sort_key) {\n+    using ArrayType = typename TypeTraits<Type>::ArrayType;\n+    if (first_sort_key.null_count == 0) {\n+      return indices_end_;\n+    }\n+    StablePartitioner partitioner;\n+    auto nulls_begin =\n+        partitioner(indices_begin_, indices_end_, [&first_sort_key](uint64_t index) {\n+          int64_t index_chunk = 0;\n+          auto chunk = first_sort_key.ResolveChunk<ArrayType>(index, index_chunk);\n+          return !chunk->IsNull(index_chunk);\n+        });\n+    auto& comparer = comparer_;\n+    std::stable_sort(nulls_begin, indices_end_,\n+                     [&comparer](uint64_t left, uint64_t right) {\n+                       return comparer.Compare(left, right, 1);\n+                     });\n+    return nulls_begin;\n+  }\n+\n+  template <typename Type>\n+  enable_if_t<is_floating_type<Type>::value, uint64_t*> PartitionNullsInternal(\n+      const ResolvedSortKey& first_sort_key) {\n+    using ArrayType = typename TypeTraits<Type>::ArrayType;\n+    StablePartitioner partitioner;\n+    if (first_sort_key.null_count == 0) {\n+      return partitioner(indices_begin_, indices_end_, [&first_sort_key](uint64_t index) {\n+        int64_t index_chunk = 0;\n+        auto chunk = first_sort_key.ResolveChunk<ArrayType>(index, index_chunk);\n+        return !std::isnan(chunk->GetView(index_chunk));\n+      });\n+    }\n+    auto nans_and_nulls_begin =\n+        partitioner(indices_begin_, indices_end_, [&first_sort_key](uint64_t index) {\n+          int64_t index_chunk = 0;\n+          auto chunk = first_sort_key.ResolveChunk<ArrayType>(index, index_chunk);\n+          return !chunk->IsNull(index_chunk) && !std::isnan(chunk->GetView(index_chunk));\n+        });\n+    auto nulls_begin = nans_and_nulls_begin;\n+    if (first_sort_key.null_count < static_cast<int64_t>(indices_end_ - nulls_begin)) {\n+      // move Nulls after NaN\n+      nulls_begin = partitioner(\n+          nans_and_nulls_begin, indices_end_, [&first_sort_key](uint64_t index) {\n+            int64_t index_chunk = 0;\n+            auto chunk = first_sort_key.ResolveChunk<ArrayType>(index, index_chunk);\n+            return !chunk->IsNull(index_chunk);\n+          });\n+    }\n+    auto& comparer = comparer_;\n+    if (nans_and_nulls_begin != nulls_begin) {\n+      std::stable_sort(nans_and_nulls_begin, nulls_begin,\n+                       [&comparer](uint64_t left, uint64_t right) {\n+                         return comparer.Compare(left, right, 1);\n+                       });\n+    }\n+    std::stable_sort(nulls_begin, indices_end_,\n+                     [&comparer](uint64_t left, uint64_t right) {\n+                       return comparer.Compare(left, right, 1);\n+                     });\n+    return nans_and_nulls_begin;\n+  }\n+\n+  uint64_t* indices_begin_;\n+  uint64_t* indices_end_;\n+  Comparer comparer_;\n+};\n+\n const FunctionDoc sort_indices_doc(\n+    \"Return the indices that would sort an array, record batch or table\",\n+    (\"This function computes an array of indices that define a stable sort\\n\"\n+     \"of the input array, record batch or table.  Null values are considered\\n\"\n+     \"greater than any other value and are therefore sorted at the end of the\\n\"\n+     \"input. For floating-point types, NaNs are considered greater than any\\n\"\n+     \"other non-null value, but smaller than null values.\"),\n+    {\"input\"}, \"SortOptions\");\n+\n+class SortIndicesMetaFunction : public MetaFunction {\n+ public:\n+  SortIndicesMetaFunction()\n+      : MetaFunction(\"sort_indices\", Arity::Unary(), &sort_indices_doc) {}\n+\n+  Result<Datum> ExecuteImpl(const std::vector<Datum>& args,\n+                            const FunctionOptions* options,\n+                            ExecContext* ctx) const override {\n+    const SortOptions& sort_options = static_cast<const SortOptions&>(*options);\n+    switch (args[0].kind()) {\n+      case Datum::ARRAY:\n+        return SortIndices(*args[0].make_array(), sort_options, ctx);\n+        break;\n+      case Datum::CHUNKED_ARRAY:\n+        return SortIndices(*args[0].chunked_array(), sort_options, ctx);\n+        break;\n+      case Datum::RECORD_BATCH: {\n+        ARROW_ASSIGN_OR_RAISE(auto table,\n+                              Table::FromRecordBatches({args[0].record_batch()}));\n+        return SortIndices(*table, sort_options, ctx);\n+      } break;\n+      case Datum::TABLE:\n+        return SortIndices(*args[0].table(), sort_options, ctx);\n+        break;\n+      default:\n+        break;\n+    }\n+    return Status::NotImplemented(\n+        \"Unsupported types for sort_indices operation: \"\n+        \"values=\",\n+        args[0].ToString());\n+  }\n+\n+ private:\n+  Result<std::shared_ptr<Array>> SortIndices(const Array& values,\n+                                             const SortOptions& options,\n+                                             ExecContext* ctx) const {\n+    SortOrder order = SortOrder::ASCENDING;\n+    if (!options.sort_keys.empty()) {\n+      order = options.sort_keys[0].order;\n+    }\n+    ArraySortOptions array_options(order);\n+    ARROW_ASSIGN_OR_RAISE(\n+        Datum result, CallFunction(\"array_sort_indices\", {values}, &array_options, ctx));\n+    return result.make_array();\n+  }\n+\n+  Result<std::shared_ptr<Array>> SortIndices(const ChunkedArray& values,\n+                                             const SortOptions& options,\n+                                             ExecContext* ctx) const {\n+    SortOrder order = SortOrder::ASCENDING;\n+    if (!options.sort_keys.empty()) {\n+      order = options.sort_keys[0].order;\n+    }\n+    ArraySortOptions array_options(order);\n+\n+    std::shared_ptr<Array> array_values;\n+    if (values.num_chunks() == 1) {\n+      array_values = values.chunk(0);\n+    } else {\n+      ARROW_ASSIGN_OR_RAISE(array_values,\n+                            Concatenate(values.chunks(), ctx->memory_pool()));\n+    }\n+    ARROW_ASSIGN_OR_RAISE(Datum result, CallFunction(\"array_sort_indices\", {array_values},\n+                                                     &array_options, ctx));\n+    return result.make_array();\n+  }\n+\n+  Result<Datum> SortIndices(const Table& table, const SortOptions& options,\n+                            ExecContext* ctx) const {\n+    auto n_sort_keys = options.sort_keys.size();\n+    if (n_sort_keys == 0) {\n+      return Status::Invalid(\"Must specify one or more sort keys\");\n+    }\n+    if (n_sort_keys == 1) {\n+      auto chunked_array = table.GetColumnByName(options.sort_keys[0].name);\n+      if (!chunked_array) {\n+        return Status::Invalid(\"Nonexistent sort key column: \",\n+                               options.sort_keys[0].name);\n+      }\n+      return SortIndices(*chunked_array, options, ctx);\n+    }\n+\n+    auto out_type = uint64();\n+    auto length = table.num_rows();\n+    auto buffer_size = BitUtil::BytesForBits(\n+        length * std::static_pointer_cast<UInt64Type>(out_type)->bit_width());\n\nReview comment:\n       `sizeof(uint64_t)` perhaps?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort_test.cc\n##########\n@@ -364,32 +400,264 @@ TYPED_TEST(TestSortToIndicesKernelRandomCount, SortRandomValuesCount) {\n   int range = 2000;\n   for (int test = 0; test < times; test++) {\n     for (auto null_probability : {0.0, 0.1, 0.5, 1.0}) {\n-      auto array = rand.Generate(length, range, null_probability);\n-      ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> offsets, SortToIndices(*array));\n-      ValidateSorted<ArrayType>(*checked_pointer_cast<ArrayType>(array),\n-                                *checked_pointer_cast<UInt64Array>(offsets));\n+      for (auto order : {SortOrder::ASCENDING, SortOrder::DESCENDING}) {\n+        auto array = rand.Generate(length, range, null_probability);\n+        ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> offsets, SortIndices(*array, order));\n+        ValidateSorted<ArrayType>(*checked_pointer_cast<ArrayType>(array),\n+                                  *checked_pointer_cast<UInt64Array>(offsets), order);\n+      }\n     }\n   }\n }\n \n // Long array with big value range: std::stable_sort\n-TYPED_TEST_SUITE(TestSortToIndicesKernelRandomCompare, IntegralArrowTypes);\n+TYPED_TEST_SUITE(TestArraySortIndicesKernelRandomCompare, IntegralArrowTypes);\n \n-TYPED_TEST(TestSortToIndicesKernelRandomCompare, SortRandomValuesCompare) {\n+TYPED_TEST(TestArraySortIndicesKernelRandomCompare, SortRandomValuesCompare) {\n   using ArrayType = typename TypeTraits<TypeParam>::ArrayType;\n \n   Random<TypeParam> rand(0x5487657);\n   int times = 5;\n   int length = 4000;\n   for (int test = 0; test < times; test++) {\n     for (auto null_probability : {0.0, 0.1, 0.5, 1.0}) {\n-      auto array = rand.Generate(length, null_probability);\n-      ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> offsets, SortToIndices(*array));\n-      ValidateSorted<ArrayType>(*checked_pointer_cast<ArrayType>(array),\n-                                *checked_pointer_cast<UInt64Array>(offsets));\n+      for (auto order : {SortOrder::ASCENDING, SortOrder::DESCENDING}) {\n+        auto array = rand.Generate(length, null_probability);\n+        ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> offsets, SortIndices(*array, order));\n+        ValidateSorted<ArrayType>(*checked_pointer_cast<ArrayType>(array),\n+                                  *checked_pointer_cast<UInt64Array>(offsets), order);\n+      }\n     }\n   }\n }\n \n+class TestTableSortIndices : public ::testing::Test {\n+ protected:\n+  void AssertSortIndices(const std::shared_ptr<Table> table, const SortOptions& options,\n+                         const std::shared_ptr<Array> expected) {\n+    ASSERT_OK_AND_ASSIGN(auto actual, SortIndices(*table, options));\n+    AssertArraysEqual(*expected, *actual);\n+  }\n+\n+  void AssertSortIndices(const std::shared_ptr<Table> table, const SortOptions& options,\n+                         const std::string expected) {\n+    AssertSortIndices(table, options, ArrayFromJSON(uint64(), expected));\n+  }\n+};\n+\n+TEST_F(TestTableSortIndices, SortNull) {\n+  auto table = TableFromJSON(schema({\n+                                 {field(\"a\", uint8())},\n+                                 {field(\"b\", uint8())},\n+                             }),\n+                             {\"[\"\n+                              \"{\\\"a\\\": null, \\\"b\\\": 5},\"\n+                              \"{\\\"a\\\": 1,    \\\"b\\\": 3},\"\n+                              \"{\\\"a\\\": 3,    \\\"b\\\": null},\"\n+                              \"{\\\"a\\\": null, \\\"b\\\": null},\"\n+                              \"{\\\"a\\\": 2,    \\\"b\\\": 5},\"\n+                              \"{\\\"a\\\": 1,    \\\"b\\\": 5}\"\n+                              \"]\"});\n+  SortOptions options(\n+      {SortKey(\"a\", SortOrder::ASCENDING), SortKey(\"b\", SortOrder::DESCENDING)});\n+  this->AssertSortIndices(table, options, \"[5, 1, 4, 2, 0, 3]\");\n+}\n+\n+TEST_F(TestTableSortIndices, SortNaN) {\n+  auto table = TableFromJSON(schema({\n+                                 {field(\"a\", float32())},\n+                                 {field(\"b\", float32())},\n+                             }),\n+                             {\"[\"\n+                              \"{\\\"a\\\": null, \\\"b\\\": 5},\"\n+                              \"{\\\"a\\\": 1,    \\\"b\\\": 3},\"\n+                              \"{\\\"a\\\": 3,    \\\"b\\\": null},\"\n+                              \"{\\\"a\\\": null, \\\"b\\\": null},\"\n+                              \"{\\\"a\\\": NaN,  \\\"b\\\": null},\"\n+                              \"{\\\"a\\\": NaN,  \\\"b\\\": 5},\"\n+                              \"{\\\"a\\\": NaN,  \\\"b\\\": NaN},\"\n+                              \"{\\\"a\\\": 1,    \\\"b\\\": 5}\"\n+                              \"]\"});\n+  SortOptions options(\n+      {SortKey(\"a\", SortOrder::ASCENDING), SortKey(\"b\", SortOrder::DESCENDING)});\n+  this->AssertSortIndices(table, options, \"[7, 1, 2, 5, 6, 4, 0, 3]\");\n+}\n+\n+using RandomParam = std::tuple<std::string, double>;\n+class TestTableSortIndicesRandom : public testing::TestWithParam<RandomParam> {\n+  class Comparator : public TypeVisitor {\n\nReview comment:\n       Can you add comments when you define non-trivial classes and methods? This would help reading the code later.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -346,14 +374,396 @@ void AddSortingKernels(VectorKernel base, VectorFunction* func) {\n   }\n }\n \n+class TableSorter : public TypeVisitor {\n+ private:\n+  struct ResolvedSortKey {\n+    ResolvedSortKey(const ChunkedArray& chunked_array, const SortOrder order)\n+        : order(order) {\n+      type = chunked_array.type().get();\n+      null_count = chunked_array.null_count();\n+      num_chunks = chunked_array.num_chunks();\n+      for (const auto& chunk : chunked_array.chunks()) {\n+        chunks.push_back(chunk.get());\n+      }\n+    }\n+\n+    template <typename ArrayType>\n+    ArrayType* ResolveChunk(int64_t index, int64_t& chunk_index) const {\n\nReview comment:\n       Also, please make it `int64_t* chunk_index`. Out-parameters should be pointers.\r\n   (you could also return a `std::pair` or a dedicated struct... anyway)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T15:36:26.664+0000",
                    "updated": "2020-11-11T15:36:26.664+0000",
                    "started": "2020-11-11T15:36:26.664+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510296",
                    "issueId": "13293624"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/513937",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on a change in pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612#discussion_r526610796\n\n\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.h\n##########\n@@ -58,6 +58,34 @@ struct ARROW_EXPORT TakeOptions : public FunctionOptions {\n   static TakeOptions Defaults() { return BoundsCheck(); }\n };\n \n+enum SortOrder {\n\nReview comment:\n       Yes. Thanks.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-19T05:53:58.068+0000",
                    "updated": "2020-11-19T05:53:58.068+0000",
                    "started": "2020-11-19T05:53:58.067+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513937",
                    "issueId": "13293624"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/513938",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on a change in pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612#discussion_r526610856\n\n\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.h\n##########\n@@ -58,6 +58,34 @@ struct ARROW_EXPORT TakeOptions : public FunctionOptions {\n   static TakeOptions Defaults() { return BoundsCheck(); }\n };\n \n+enum SortOrder {\n+  ASCENDING,\n+  DESCENDING,\n+};\n+\n+/// \\brief One sort key for PartitionNthIndices (TODO) and SortIndices\n+struct ARROW_EXPORT SortKey {\n+  explicit SortKey(std::string name, SortOrder order = ASCENDING)\n+      : name(name), order(order) {}\n+\n+  /// The name of the sort key.\n\nReview comment:\n       Thanks. Fixed.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-19T05:54:15.272+0000",
                    "updated": "2020-11-19T05:54:15.272+0000",
                    "started": "2020-11-19T05:54:15.271+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513938",
                    "issueId": "13293624"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/513939",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on a change in pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612#discussion_r526611003\n\n\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.h\n##########\n@@ -58,6 +58,34 @@ struct ARROW_EXPORT TakeOptions : public FunctionOptions {\n   static TakeOptions Defaults() { return BoundsCheck(); }\n };\n \n+enum SortOrder {\n+  ASCENDING,\n+  DESCENDING,\n\nReview comment:\n       OK. Renamed.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-19T05:54:38.833+0000",
                    "updated": "2020-11-19T05:54:38.833+0000",
                    "started": "2020-11-19T05:54:38.833+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513939",
                    "issueId": "13293624"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/513940",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on a change in pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612#discussion_r526611674\n\n\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.h\n##########\n@@ -165,8 +194,50 @@ Result<std::shared_ptr<Array>> NthToIndices(const Array& values, int64_t n,\n /// \\param[in] ctx the function execution context, optional\n /// \\return offsets indices that would sort an array\n ARROW_EXPORT\n-Result<std::shared_ptr<Array>> SortToIndices(const Array& values,\n-                                             ExecContext* ctx = NULLPTR);\n+Result<std::shared_ptr<Array>> SortIndices(const Array& values,\n+                                           ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Returns the indices that would sort an array in the\n+/// specified order.\n+///\n+/// Perform an indirect sort of array. The output array will contain\n+/// indices that would sort an array, which would be the same length\n+/// as input. Nulls will be stably partitioned to the end of the output.\n+///\n+/// For example given values = [null, 1, 3.3, null, 2, 5.3] and order\n+/// = SortOrder::DESCENDING, the output will be [5, 2, 4, 1, 0,\n+/// 3].\n+///\n+/// \\param[in] values array to sort\n+/// \\param[in] order ascending or descending\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return offsets indices that would sort an array\n+ARROW_EXPORT\n+Result<std::shared_ptr<Array>> SortIndices(const Array& values, SortOrder order,\n\nReview comment:\n       I wanted to accept `SortIndices(array, ctx)` usage but it may not be used.\r\n   I've removed the SortIndices(array, ctx)` and added `SortOrder::Ascending` as the default value.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-19T05:56:43.291+0000",
                    "updated": "2020-11-19T05:56:43.291+0000",
                    "started": "2020-11-19T05:56:43.291+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513940",
                    "issueId": "13293624"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/513941",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on a change in pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612#discussion_r526611732\n\n\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.h\n##########\n@@ -165,8 +194,50 @@ Result<std::shared_ptr<Array>> NthToIndices(const Array& values, int64_t n,\n /// \\param[in] ctx the function execution context, optional\n /// \\return offsets indices that would sort an array\n ARROW_EXPORT\n-Result<std::shared_ptr<Array>> SortToIndices(const Array& values,\n-                                             ExecContext* ctx = NULLPTR);\n+Result<std::shared_ptr<Array>> SortIndices(const Array& values,\n+                                           ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Returns the indices that would sort an array in the\n+/// specified order.\n+///\n+/// Perform an indirect sort of array. The output array will contain\n+/// indices that would sort an array, which would be the same length\n+/// as input. Nulls will be stably partitioned to the end of the output.\n\nReview comment:\n       Added.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-19T05:56:56.816+0000",
                    "updated": "2020-11-19T05:56:56.816+0000",
                    "started": "2020-11-19T05:56:56.816+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513941",
                    "issueId": "13293624"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/513943",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on a change in pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612#discussion_r526612209\n\n\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.h\n##########\n@@ -58,6 +58,34 @@ struct ARROW_EXPORT TakeOptions : public FunctionOptions {\n   static TakeOptions Defaults() { return BoundsCheck(); }\n };\n \n+enum SortOrder {\n+  ASCENDING,\n+  DESCENDING,\n+};\n+\n+/// \\brief One sort key for PartitionNthIndices (TODO) and SortIndices\n+struct ARROW_EXPORT SortKey {\n+  explicit SortKey(std::string name, SortOrder order = ASCENDING)\n+      : name(name), order(order) {}\n+\n+  /// The name of the sort key.\n+  std::string name;\n+  /// How to order by this sort key.\n+  SortOrder order;\n+};\n+\n+struct ARROW_EXPORT ArraySortOptions : public FunctionOptions {\n+  explicit ArraySortOptions(SortOrder order = SortOrder::ASCENDING) : order(order) {}\n+\n+  SortOrder order;\n+};\n+\n+struct ARROW_EXPORT SortOptions : public FunctionOptions {\n\nReview comment:\n       I want to keep this because this is used by all inputs (`Array`, `ChunkedArray`, `RecordBatch` and `Table`) with the `sort_indices()` compute kernel.\r\n   So I think that no `Table` prefix is suitable.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-19T05:58:35.578+0000",
                    "updated": "2020-11-19T05:58:35.578+0000",
                    "started": "2020-11-19T05:58:35.578+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513943",
                    "issueId": "13293624"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/513945",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on a change in pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612#discussion_r526612518\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -346,14 +374,396 @@ void AddSortingKernels(VectorKernel base, VectorFunction* func) {\n   }\n }\n \n+class TableSorter : public TypeVisitor {\n+ private:\n+  struct ResolvedSortKey {\n+    ResolvedSortKey(const ChunkedArray& chunked_array, const SortOrder order)\n+        : order(order) {\n+      type = chunked_array.type().get();\n+      null_count = chunked_array.null_count();\n+      num_chunks = chunked_array.num_chunks();\n+      for (const auto& chunk : chunked_array.chunks()) {\n+        chunks.push_back(chunk.get());\n+      }\n+    }\n+\n+    template <typename ArrayType>\n+    ArrayType* ResolveChunk(int64_t index, int64_t& chunk_index) const {\n\nReview comment:\n       Added comments and changed to use new dedicated struct.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-19T05:59:33.558+0000",
                    "updated": "2020-11-19T05:59:33.558+0000",
                    "started": "2020-11-19T05:59:33.557+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513945",
                    "issueId": "13293624"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/513946",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on a change in pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612#discussion_r526612843\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -346,14 +374,396 @@ void AddSortingKernels(VectorKernel base, VectorFunction* func) {\n   }\n }\n \n+class TableSorter : public TypeVisitor {\n+ private:\n+  struct ResolvedSortKey {\n+    ResolvedSortKey(const ChunkedArray& chunked_array, const SortOrder order)\n+        : order(order) {\n+      type = chunked_array.type().get();\n+      null_count = chunked_array.null_count();\n+      num_chunks = chunked_array.num_chunks();\n+      for (const auto& chunk : chunked_array.chunks()) {\n+        chunks.push_back(chunk.get());\n+      }\n+    }\n+\n+    template <typename ArrayType>\n+    ArrayType* ResolveChunk(int64_t index, int64_t& chunk_index) const {\n+      if (num_chunks == 1) {\n+        chunk_index = index;\n+        return static_cast<ArrayType*>(chunks[0]);\n+      } else {\n+        int64_t offset = 0;\n+        for (size_t i = 0; i < num_chunks; ++i) {\n+          if (index < offset + chunks[i]->length()) {\n+            chunk_index = index - offset;\n+            return static_cast<ArrayType*>(chunks[i]);\n+          }\n+          offset += chunks[i]->length();\n+        }\n+        return nullptr;\n+      }\n+    }\n+\n+    SortOrder order;\n+    DataType* type;\n+    int64_t null_count;\n+    size_t num_chunks;\n\nReview comment:\n       Fixed. It should be `int` because `ChunkedArray::num_chunks()` returns `int`.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-19T06:00:27.022+0000",
                    "updated": "2020-11-19T06:00:27.022+0000",
                    "started": "2020-11-19T06:00:27.021+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513946",
                    "issueId": "13293624"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/worklog/513947",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on a change in pull request #8612:\nURL: https://github.com/apache/arrow/pull/8612#discussion_r526612977\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -346,14 +374,396 @@ void AddSortingKernels(VectorKernel base, VectorFunction* func) {\n   }\n }\n \n+class TableSorter : public TypeVisitor {\n+ private:\n+  struct ResolvedSortKey {\n+    ResolvedSortKey(const ChunkedArray& chunked_array, const SortOrder order)\n+        : order(order) {\n+      type = chunked_array.type().get();\n+      null_count = chunked_array.null_count();\n+      num_chunks = chunked_array.num_chunks();\n+      for (const auto& chunk : chunked_array.chunks()) {\n+        chunks.push_back(chunk.get());\n+      }\n+    }\n+\n+    template <typename ArrayType>\n+    ArrayType* ResolveChunk(int64_t index, int64_t& chunk_index) const {\n+      if (num_chunks == 1) {\n+        chunk_index = index;\n+        return static_cast<ArrayType*>(chunks[0]);\n+      } else {\n+        int64_t offset = 0;\n+        for (size_t i = 0; i < num_chunks; ++i) {\n+          if (index < offset + chunks[i]->length()) {\n+            chunk_index = index - offset;\n+            return static_cast<ArrayType*>(chunks[i]);\n+          }\n+          offset += chunks[i]->length();\n+        }\n+        return nullptr;\n+      }\n+    }\n+\n+    SortOrder order;\n+    DataType* type;\n+    int64_t null_count;\n+    size_t num_chunks;\n+    std::vector<Array*> chunks;\n+  };\n+\n+  class Comparer : public TypeVisitor {\n+   public:\n+    Comparer(const Table& table, const std::vector<SortKey>& sort_keys)\n+        : TypeVisitor(), status_(Status::OK()) {\n+      for (const auto& sort_key : sort_keys) {\n+        const auto& chunked_array = table.GetColumnByName(sort_key.name);\n+        if (!chunked_array) {\n+          status_ = Status::Invalid(\"Nonexistent sort key column: \", sort_key.name);\n+          return;\n+        }\n+        sort_keys_.emplace_back(*chunked_array, sort_key.order);\n+      }\n+    }\n+\n+    Status status() { return status_; }\n+\n+    const std::vector<ResolvedSortKey>& sort_keys() { return sort_keys_; }\n+\n+    bool Compare(uint64_t left, uint64_t right, size_t start_sort_key_index) {\n\nReview comment:\n       Added.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-19T06:00:50.472+0000",
                    "updated": "2020-11-19T06:00:50.472+0000",
                    "started": "2020-11-19T06:00:50.472+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513947",
                    "issueId": "13293624"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/5",
            "id": "5",
            "description": "General wishlist item.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Wish",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 19800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@656660db[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1bbd06bc[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@45fd770c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@368601e9[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6776f698[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@299bd46d[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7f09345[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@17f431b[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@516da79a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@26222966[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@254bfc5c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@5e570475[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 19800,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Nov 24 17:32:04 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-11-24T17:32:04.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-8199/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2020-03-24T19:58:24.000+0000",
        "updated": "2021-03-18T03:46:26.000+0000",
        "timeoriginalestimate": null,
        "description": "I'm just coming up to speed with Arrow and am noticing a dearth of examples ... maybe I can help here.\r\n\r\nI'd like to implement multi-column sorting for Tables and just want to ensure that I'm not duplicating existing work or proposing a bad design.\r\n\r\nMy thought was to create a Table-specific version of SortToIndices() where you can specify the columns and sort order.\r\n\r\nThen I'd create Array \"views\" that use the Indices to remap from the original Array values to the values in sorted order. (Original data is not sorted, but could be as a second step.) I noticed some of the array list variants keep offsets, but didn't see anything that supports remapping per a list of indices, but this may just be my oversight?\r\n\r\nThanks in advance, Scott",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "5.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 19800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/attachment/13000998",
                "id": "13000998",
                "filename": "ArrowCsv.cpp",
                "author": {
                    "self": "https://issues.apache.org/jira/rest/api/2/user?username=swilson314",
                    "name": "swilson314",
                    "key": "swilson314",
                    "avatarUrls": {
                        "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                        "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                        "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                        "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                    },
                    "displayName": "Scott Wilson",
                    "active": true,
                    "timeZone": "America/Los_Angeles"
                },
                "created": "2020-04-23T17:34:00.135+0000",
                "size": 31684,
                "mimeType": "text/plain",
                "content": "https://issues.apache.org/jira/secure/attachment/13000998/ArrowCsv.cpp"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/attachment/13011241",
                "id": "13011241",
                "filename": "DataFrame.h",
                "author": {
                    "self": "https://issues.apache.org/jira/rest/api/2/user?username=swilson314",
                    "name": "swilson314",
                    "key": "swilson314",
                    "avatarUrls": {
                        "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                        "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                        "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                        "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                    },
                    "displayName": "Scott Wilson",
                    "active": true,
                    "timeZone": "America/Los_Angeles"
                },
                "created": "2020-09-08T20:41:00.192+0000",
                "size": 76304,
                "mimeType": "text/plain",
                "content": "https://issues.apache.org/jira/secure/attachment/13011241/DataFrame.h"
            }
        ],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Add support for multi-column sort on Table",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/comment/17066149",
                    "id": "17066149",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Sorting Tables is a bit complicated on account of chunked arrays. There isn't a multi-column sort implemented but one will eventually need to be implemented. It might be worth soliciting ideas about sorting with chunked data in general on the mailing list (we will need to employ the sorting strategies used by analytic databases which operate on chunks of tables at a time -- there are various open source DBMSs that we can use for inspiration). ",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-03-24T20:05:54.200+0000",
                    "updated": "2020-03-24T20:05:54.200+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/comment/17066226",
                    "id": "17066226",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=swilson314",
                        "name": "swilson314",
                        "key": "swilson314",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Scott Wilson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Thanks Wes. I'm trying to replace portions of my python/pandas ML pipeline with arrow C++. As such, I don't lose anything by not initially being able to support chunked arrays. Does my approach seem reasonable assuming I\u00a0 start with non-chunked arrays? Any suggestions?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=swilson314",
                        "name": "swilson314",
                        "key": "swilson314",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Scott Wilson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2020-03-24T22:12:11.952+0000",
                    "updated": "2020-03-24T22:12:11.952+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/comment/17066268",
                    "id": "17066268",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "I don't have particular suggestions. This functionality will eventually find a home in the future \"C++ data frame API\" that has been discussed for addition to the project. \r\n\r\nhttps://docs.google.com/document/d/1XHe_j87n2VHGzEbnLe786GHbbcbrzbjgG8D0IXWAeHg/edit?usp=sharing",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-03-24T23:43:23.414+0000",
                    "updated": "2020-03-24T23:43:23.414+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/comment/17066301",
                    "id": "17066301",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=swilson314",
                        "name": "swilson314",
                        "key": "swilson314",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Scott Wilson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Ah, that's already helpful. I thought you meant for Table to become the DataFrame replacement, but now I see that's not true. This makes sense given the levels of abstraction I've seen so far in Arrow. Thanks!",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=swilson314",
                        "name": "swilson314",
                        "key": "swilson314",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Scott Wilson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2020-03-25T01:09:51.059+0000",
                    "updated": "2020-03-25T01:09:51.059+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/comment/17066305",
                    "id": "17066305",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Right, Table is just a data structure. We definitely are trying to keep the in-memory data structures simple and focused on providing access to the data, so computation will live in different APIs that act on the data structures",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-03-25T01:23:36.934+0000",
                    "updated": "2020-03-25T01:23:36.934+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/comment/17090788",
                    "id": "17090788",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=swilson314",
                        "name": "swilson314",
                        "key": "swilson314",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Scott Wilson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Hi Wes,\n\nI hope you and yours are staying healthy in this strange new world!\n\nI've taken a stab at creating a DataFrame like cover for arrow::Table. My\nfirst milestone was to see if I could come up with a df.eval() like\nrepresentation for single-line transforms -- see the EVAL2 macro. Attached\nis my code, I'm not quite sure where, if anywhere, I should post it to get\nyour thoughts so I'm sending this email. (I posted an earlier version on\nJira Arrow-602.) Mainly I'd like to know if this looks like the direction\nyou're thinking for arrow::DataFrame?\n\nThanks, Scott\n\n**** Code, also included as attachment\n\n#include <cstdint>\n#include <memory>\n#include <numeric>\n#include <string>\n#include <iostream>\n#include <optional>\n#include <vector>\n#include <xutility>\n\n#include <arrow/api.h>\n#include <arrow/filesystem/localfs.h>\n#include <arrow/csv/api.h>\n#include <arrow/result.h>\n#include <arrow/builder.h>\n\n#include <boost/iterator/iterator_facade.hpp>\n#include <boost/range/iterator_range.hpp>\n#include <boost/preprocessor.hpp>\n\nusing namespace std;\nusing namespace arrow;\n\n// SBW 2020.04.15 For ArrayCoverRaw::iterator, we can simply use the the\npointer interface.\n// Wes suggests returning std::optional<T>, but sizeof(double) <\nsizeof(std::optional<double>) and\n// is not a drop-in replacement for T, i.e. optional<T> can't be used in\nexpression, need optional<T>.value().\n\n// STL container-like cover for arrow::Array.\n// Only works for Array types that support raw_values().\ntemplate<typename ArrType>\nclass ArrayCoverRaw\n{\npublic:\nusing T = typename ArrType::value_type;\nusing pointer = T*;\nusing const_pointer = const T*;\nusing reference = T&;\nusing const_reference = const T&;\n// Match size_type to Array offsets rather than using size_t and ptrdiff_t.\nusing size_type = int64_t;\nusing difference_type = int64_t;\nusing iterator = pointer;\nusing const_iterator = const_pointer;\nusing reverse_iterator = pointer;\nusing const_reverse_iterator = const_pointer;\n\nArrayCoverRaw(std::shared_ptr<ArrType>& array) : _array(array) {}\n\nsize_type size() const { return _array->length(); }\n\n// Should non-const versions fail if Array is immutable?\niterator begin() { return const_cast<pointer>(_array->raw_values()); }\niterator end() { return\nconst_cast<pointer>(_array->raw_values()+_array->length()); }\nreverse_iterator rbegin() { return\nconst_cast<pointer>(_array->raw_values()+_array->length()-1); }\nreverse_iterator rend() { return\nconst_cast<pointer>(_array->raw_values()-1); }\nconst_iterator cbegin() const { return _array->raw_values(); }\nconst_iterator cend() const { return _array->raw_values()+_array->length();\n}\nconst_reverse_iterator crbegin() const { return\n_array->raw_values()+_array->length()-1; }\nconst_reverse_iterator crend() const { return _array->raw_values()-1; }\n\n// We could return std::optional<T> to encapsulate IsNull() info, but this\nwould seem to break the expected semantics.\nreference operator[](const difference_type off) {\nassert(_array->data()->is_mutable()); return _array->raw_values()+off; }\nconst_reference operator[](const difference_type off) const { return\n_array->raw_values()+off; }\n// ISSUE: is there an interface for setting IsNull() if array is mutable.\nbool IsNull(difference_type off) const { return _array->IsNull(off); }\n\nprotected:\nstd::shared_ptr<ArrType> _array;\n};\n\n// TODO: Add ArrayCoverString and iterators, perhaps others.\n\n// Use template on RefType so we can create iterator and const_iterator by\nchanging Value.\n// Use class specializations to support Arrays that don't have raw_values().\ntemplate <typename CType, typename RefType>\nclass ChunkedArrayIterator\n: public boost::iterator_facade<ChunkedArrayIterator<CType, RefType>,\nRefType, boost::random_access_traversal_tag>\n{\npublic:\nusing difference_type = int64_t;\nusing T = CType;\nusing ArrayType = typename CTypeTraits<CType>::ArrayType;\nusing pointer = T*;\n\nexplicit ChunkedArrayIterator(std::shared_ptr<arrow::ChunkedArray> ch_arr =\n0, difference_type pos = 0)\n: _ch_arr(ch_arr)\n{\nset_position(pos);\n}\n\nbool IsNull() const\n{\nauto arr = _ch_arr->chunk(_chunk_index);\nreturn arr->IsNull(_current-_first);\n}\n\nprivate:\nfriend class boost::iterator_core_access;\n\n    bool equal(ChunkedArrayIterator<CType, RefType> const& other) const\n    {\n        return this->_position == other._position;\n    }\n\n    void increment()\n{\n_position++;\n// Need to move to next chunk?\nif ((_current == _last) && ((_chunk_index+1) < _ch_arr->num_chunks()))\n{\n_chunk_index++;\nauto arr = _ch_arr->chunk(_chunk_index);\nauto typed_arr = std::static_pointer_cast<ArrayType>(arr);\n_first = const_cast<pointer>(typed_arr->raw_values());\n_last = _first + arr->length() - 1;\n_current = _first;\n}\nelse\n{\n_current++;\n}\n}\n\nvoid decrement()\n{\n_position--;\n// Need to move to previous chunk?\nif ((_current == _first) && (_chunk_index > 0))\n{\n_chunk_index--;\nauto arr = _ch_arr->chunk(_chunk_index);\nauto typed_arr = std::static_pointer_cast<ArrayType>(arr);\n_first = const_cast<pointer>(typed_arr->raw_values());\n_last = _first + arr->length() - 1;\n_current = _last;\n}\nelse\n{\n_current--;\n}\n}\n\n    RefType& dereference() const { return *_current; }\n\nvoid advance(difference_type n)\n{\n_position += n;\nwhile (n > 0)\n{\ndifference_type max_delta = _last - _current;\nif ((max_delta >= n) || ((_chunk_index+1) == _ch_arr->num_chunks()))\n{\n_current += n;\nreturn;\n}\n// Move to next chunk.\nn -= max_delta;\n_chunk_index++;\nauto arr = _ch_arr->chunk(_chunk_index);\nauto typed_arr = std::static_pointer_cast<ArrayType>(arr);\n_first = const_cast<pointer>(typed_arr->raw_values());\n_last = _first + arr->length() - 1;\n_current = _first;\n}\nwhile (n < 0)\n{\ndifference_type max_delta = _first - _current;\nif ((max_delta <= n) || (_chunk_index == 0))\n{\n_current += n;\nreturn;\n}\n// Move to previous chunk.\nn -= max_delta;\n_chunk_index--;\nassert(_chunk_index >= 0);\nauto arr = _ch_arr->chunk(_chunk_index);\nauto typed_arr = std::static_pointer_cast<ArrayType>(arr);\n_first = const_cast<pointer>(typed_arr->raw_values());\n_last = _first + arr->length() - 1;\n_current = _last;\n}\n}\n\ndifference_type distance_to(ChunkedArrayIterator<CType, RefType> const&\nother)\n{\nreturn other._position - this->_position;\n}\n\n// Helper\nvoid set_position(difference_type pos)\n{\n_position = pos;\nconst int nchunks = _ch_arr->num_chunks();\nint64_t offset = 0;\nfor (_chunk_index = 0; _chunk_index < nchunks; _chunk_index++)\n{\nauto arr = _ch_arr->chunk(_chunk_index);\nint64_t arr_rows = arr->length();\nif (((offset+arr_rows) > pos) || ((_chunk_index+1)==nchunks))\n{\nauto typed_arr = std::static_pointer_cast<ArrayType>(arr);\n_first = const_cast<T*>(typed_arr->raw_values());\n_last = _first + arr_rows - 1;\n_current = _first + (pos-offset);\nreturn;\n}\noffset += arr_rows;\n}\nassert(false);\n}\n\nstd::shared_ptr<arrow::ChunkedArray> _ch_arr;\n// Which Array we're looking at.\nint _chunk_index = 0;\n// Pointers into current Array. Use first/last rather than begin/end for\nsymmetry of moving forward/backward.\npointer _first = 0;\npointer _current = 0;\npointer _last = 0;\n// Cache position across all chunks for support of random access.\ndifference_type _position = 0;\n};\n\n// This implementation is a subclass for Arrays that use GetView(i),\nGetString(i), etc.\n// Concrete subclass only needs to implement dereference(i).\ntemplate <typename CType>\nclass ChunkedArrayIteratorIndexImpl\n{\npublic:\nusing difference_type = int64_t;\nusing ArrayType = typename CTypeTraits<CType>::ArrayType;\n\nexplicit ChunkedArrayIteratorIndexImpl(std::shared_ptr<arrow::ChunkedArray>\nch_arr = 0, difference_type pos = 0)\n: _ch_arr(ch_arr)\n{\nset_position(pos);\n}\n\nbool IsNull() const\n{\nauto arr = _ch_arr->chunk(_chunk_index);\nreturn arr->IsNull(_current);\n}\n\nprotected:\nfriend class boost::iterator_core_access;\n\n    bool equal(ChunkedArrayIteratorIndexImpl<CType> const& other) const\n    {\n        return this->_position == other._position;\n    }\n\n    void increment()\n{\n_position++;\n// Need to move to next chunk?\nif ((_current == _last) && ((_chunk_index+1) < _ch_arr->num_chunks()))\n{\n_chunk_index++;\nauto arr = _ch_arr->chunk(_chunk_index);\n_typed_arr = std::static_pointer_cast<ArrayType>(arr);\n_last = arr->length() - 1;\n_current = 0;\n}\nelse\n{\n_current++;\n}\n}\n\nvoid decrement()\n{\n_position--;\n// Need to move to previous chunk?\nif ((_current == _first) && (_chunk_index > 0))\n{\n_chunk_index--;\nauto arr = _ch_arr->chunk(_chunk_index);\n_typed_arr = std::static_pointer_cast<ArrayType>(arr);\n_last = arr->length() - 1;\n_current = _last;\n}\nelse\n{\n_current--;\n}\n}\n\n    // RefType& dereference() const { return *_current; }\n\nvoid advance(difference_type n)\n{\n_position += n;\nwhile (n > 0)\n{\ndifference_type max_delta = _last - _current;\nif ((max_delta >= n) || ((_chunk_index+1) == _ch_arr->num_chunks()))\n{\n_current += n;\nreturn;\n}\n// Move to next chunk.\nn -= max_delta;\n_chunk_index++;\nauto arr = _ch_arr->chunk(_chunk_index);\n_typed_arr = std::static_pointer_cast<ArrayType>(arr);\n_last = arr->length() - 1;\n_current = 0;\n}\nwhile (n < 0)\n{\ndifference_type max_delta = 0 - _current;\nif ((max_delta <= n) || (_chunk_index == 0))\n{\n_current += n;\nreturn;\n}\n// Move to previous chunk.\nn -= max_delta;\n_chunk_index--;\nauto arr = _ch_arr->chunk(_chunk_index);\n_typed_arr = std::static_pointer_cast<ArrayType>(arr);\n_last = arr->length() - 1;\n_current = _last;\n}\n}\n\ndifference_type distance_to(ChunkedArrayIteratorIndexImpl<CType> const&\nother)\n{\nreturn other._position - this->_position;\n}\n\n// Helper\nvoid set_position(difference_type pos)\n{\n_position = pos;\nconst int nchunks = _ch_arr->num_chunks();\nint64_t offset = 0;\nfor (_chunk_index = 0; _chunk_index < nchunks; _chunk_index++)\n{\nauto arr = _ch_arr->chunk(_chunk_index);\nint64_t arr_rows = arr->length();\nif (((offset+arr_rows) > pos) || ((_chunk_index+1)==nchunks))\n{\n_typed_arr = std::static_pointer_cast<ArrayType>(arr);\n_last = arr_rows - 1;\n_current = (pos-offset);\nreturn;\n}\noffset += arr_rows;\n}\nassert(false);\n}\n\nstd::shared_ptr<arrow::ChunkedArray> _ch_arr;\n// Which Array we're looking at.\nint _chunk_index = 0;\n// Current Array. Use first/last rather than begin/end for symmetry of\nmoving forward/backward.\nstd::shared_ptr<ArrayType> _typed_arr;\ndifference_type _current = 0;\ndifference_type _last = 0;\n// Cache position across all chunks for support of random access.\ndifference_type _position = 0;\n};\n\n// SBW 2020.04.23 for EVAL2() macro, even though code not called, need lhs\niterator for unused code branch to compile.\nusing ConstRefString = std::string;\ntemplate<>\nclass ChunkedArrayIterator<std::string, ConstRefString> :\npublic ChunkedArrayIteratorIndexImpl<std::string>,\npublic boost::iterator_facade<ChunkedArrayIterator<std::string,\nConstRefString>, ConstRefString, boost::random_access_traversal_tag>\n{\npublic:\nusing difference_type = int64_t;\nusing RefType = ConstRefString;\n\nexplicit ChunkedArrayIterator(std::shared_ptr<arrow::ChunkedArray> ch_arr =\n0, difference_type pos = 0)\n: ChunkedArrayIteratorIndexImpl(ch_arr, pos)\n{\n}\n\n// Cache value to avoid returning pointer to temp.\n    RefType& dereference() const { _cached =\n_typed_arr->GetString(_current); return _cached; }\n\nprivate:\nmutable std::string _cached;\n};\nusing ChunkedArrayIteratorString = ChunkedArrayIterator<std::string,\nConstRefString>;\n\ntemplate<>\nclass ChunkedArrayIterator<bool, const bool> :\npublic ChunkedArrayIteratorIndexImpl<bool>,\npublic boost::iterator_facade<ChunkedArrayIterator<bool, const bool>, const\nbool, boost::random_access_traversal_tag>\n{\npublic:\nusing difference_type = int64_t;\nusing RefType = const bool;\n\nexplicit ChunkedArrayIterator(std::shared_ptr<arrow::ChunkedArray> ch_arr =\n0, difference_type pos = 0)\n: ChunkedArrayIteratorIndexImpl(ch_arr, pos)\n{\n}\n\n// Cache value to avoid returning pointer to temp.\n    RefType& dereference() const { _cached = _typed_arr->GetView(_current);\nreturn _cached; }\n\nprivate:\nmutable bool _cached;\n};\nusing ChunkedArrayIteratorBoolean = ChunkedArrayIterator<bool, const bool>;\n\n// STL container-like cover for arrow::ChunkedArray.\n// Only works for ChunkedArrays composed of Array types that support\nraw_values().\ntemplate<typename CType>\nclass ChunkedArrayCover\n{\npublic:\n// Match size_type to Array offsets rather than using size_t and ptrdiff_t.\nusing size_type = int64_t;\nusing difference_type = int64_t;\nusing iterator = typename ChunkedArrayIterator<CType, CType>;\nusing const_iterator = typename ChunkedArrayIterator<CType, const CType>;\nusing reverse_iterator = iterator;\nusing const_reverse_iterator = const_iterator;\n\nChunkedArrayCover(std::shared_ptr<ChunkedArray>& array) : _array(array) {}\n\nsize_type size() const { return _array->length(); }\n\n// Should non-const versions fail if Array is immutable?\niterator begin() { return iterator(_array); }\niterator end() { return iterator(_array, size()); }\nreverse_iterator rbegin() { return iterator(_array, size()-1); }\nreverse_iterator rend() { return iterator(_array, -1); }\nconst_iterator cbegin() const { return const_iterator(_array); }\nconst_iterator cend() const { return const_iterator(_array, size()); }\nconst_reverse_iterator crbegin() const { return const_iterator(_array,\nsize()-1); }\nconst_reverse_iterator crend() const { return const_iterator(_array, -1); }\n\nprotected:\nstd::shared_ptr<ChunkedArray> _array;\n};\n\n#if 0 // SBW 2020.04.23 No longer needed no that we're using ContRefString\n= std::string.\ntemplate<>\nclass ChunkedArrayCover<std::string>\n{\npublic:\nusing CType = std::string;\nusing size_type = int64_t;\nusing difference_type = int64_t;\n// ISSUE: no specialization for ChunkedArrayIterator<std::string,\nstd::string>\n// Not sure how to handle setting of std::string values since StringArray\ndoesn't provide LHS access.\nusing iterator = typename ChunkedArrayIterator<CType, const CType>;\nusing const_iterator = typename ChunkedArrayIterator<CType, const CType>;\nusing reverse_iterator = iterator;\nusing const_reverse_iterator = const_iterator;\n\nChunkedArrayCover(std::shared_ptr<ChunkedArray>& array) : _array(array) {}\n\nsize_type size() const { return _array->length(); }\n\n// Should non-const versions fail if Array is immutable?\niterator begin() { return iterator(_array); }\niterator end() { return iterator(_array, size()); }\nreverse_iterator rbegin() { return iterator(_array, size()-1); }\nreverse_iterator rend() { return iterator(_array, -1); }\nconst_iterator cbegin() const { return const_iterator(_array); }\nconst_iterator cend() const { return const_iterator(_array, size()); }\nconst_reverse_iterator crbegin() const { return const_iterator(_array,\nsize()-1); }\nconst_reverse_iterator crend() const { return const_iterator(_array, -1); }\n\nprotected:\nstd::shared_ptr<ChunkedArray> _array;\n};\n#endif\n\nstruct TestFrame\n{\nTestFrame(std::shared_ptr<arrow::Table> table = nullptr) : _table(table)\n{\n}\n\nauto find_column(const char* name) { return _table->GetColumnByName(name); }\n\ntemplate<typename CType> typename ChunkedArrayCover<CType>::iterator\nbegin(const char* name)\n{\nauto col = _table->GetColumnByName(name);\nassert(col != nullptr);\nChunkedArrayCover<CType> cover(col);\nreturn cover.begin();\n}\ntemplate<typename CType> typename ChunkedArrayCover<CType>::iterator\nend(const char* name)\n{\nauto col = _table->GetColumnByName(name);\nassert(col != nullptr);\nChunkedArrayCover<CType> cover(col);\nreturn cover.end();\n}\n// Append to end if Index==-1.\ntemplate<typename CType> bool add_column(const char* name, int Index = -1)\n{\nvector<CType> values(_table->num_rows());\nreturn add_column(name, values, Index);\n}\ntemplate<typename CType> bool add_column(const char* name, const\nvector<CType>& values, int Index = -1)\n{\nusing Builder = typename CTypeTraits<CType>::BuilderType;\nassert(values.size() == _table->num_rows());\nBuilder builder;\nbuilder.Resize(values.size());\nbuilder.AppendValues(values);\nshared_ptr<arrow::Array> array;\narrow::Status st = builder.Finish(&array);\nauto ch_arr = std::make_shared<ChunkedArray>(array);\nauto field = arrow::field(name, builder.type());\n// Watch for existing name and delete if necessary.\nint icol = _table->schema()->GetFieldIndex(name);\nif (icol >= 0)\n{\nstd::shared_ptr<arrow::Table> out;\n_table->RemoveColumn(icol, &out);\n_table = out;\n}\nstd::shared_ptr<arrow::Table> out;\nif (Index < 0)\nIndex = _table->num_columns();\nst = _table->AddColumn(Index, field, ch_arr, &out);\nif (st.ok())\n{\n_table = out;\nreturn true;\n}\nreturn false;\n}\n\nstd::shared_ptr<arrow::Table> _table;\n};\n\n// Generalizing std::transform() to take any number of input iterators.\n//\nhttps://medium.com/@vgasparyan1995/generalizing-std-transform-8d2c41e1f958\n// https://github.com/vgasparyan1995/transform\n#include \"F:\\Dev\\transform-master\\transform.h\"\n\n// Use BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__)\n// Use BOOST_PP_SEQ_FOR_EACH_I twice, once to build list of input\niterators, once to build arg list for lambda.\n// Use BOOST_PP_TUPLE_ELEM to pull values out of tuple.\n\n#define DF_INPUT_ITER(r, data, i, elem) \\\ndata.begin<BOOST_PP_TUPLE_ELEM(2, 0,\nelem)>(BOOST_PP_STRINGIZE(BOOST_PP_TUPLE_ELEM(2, 1, elem))) \\\n, \\\nBOOST_PP_IF(i, , data.end<BOOST_PP_TUPLE_ELEM(2, 0,\nelem)>(BOOST_PP_STRINGIZE(BOOST_PP_TUPLE_ELEM(2, 1, elem)))) \\\nBOOST_PP_COMMA_IF(BOOST_PP_NOT(i))\n\n#define LAMBDA_INPUT(r, data, i, elem) \\\nBOOST_PP_COMMA_IF(i) \\\nauto BOOST_PP_TUPLE_ELEM(2, 1, elem)\n\n// Variable args are input 2-tuples (type, name).\n// Initially used BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__), but I think this\nis clearer to add inputs as pp_sequence.\n// Function signature: transform(in1.begin(), in1.end(), in2.begin() ...\ninN.begin(), dest.begin(), lambda).\n#define EVAL2(df, dest_tuple, func_body, input_seq) \\\n{ \\\nusing dest_type = BOOST_PP_TUPLE_ELEM(2, 0, dest_tuple); \\\nconst char* dest_name = BOOST_PP_STRINGIZE(BOOST_PP_TUPLE_ELEM(2, 1,\ndest_tuple)); \\\nif (is_number_type<CTypeTraits<dest_type>::ArrowType>::value) \\\n{ \\\nif (df.find_column(dest_name) == nullptr) \\\ndf.add_column<dest_type>(dest_name); \\\nmy::transform( \\\nBOOST_PP_SEQ_FOR_EACH_I(DF_INPUT_ITER, df, input_seq) \\\ndf.begin<dest_type>(dest_name) , \\\n[] (BOOST_PP_SEQ_FOR_EACH_I(LAMBDA_INPUT, df, input_seq)) func_body ); \\\n} \\\nelse \\\n{ \\\nusing Builder = typename CTypeTraits<dest_type>::BuilderType; \\\nvector<dest_type> dest(df._table->num_rows()); \\\nmy::transform( \\\nBOOST_PP_SEQ_FOR_EACH_I(DF_INPUT_ITER, df, input_seq) \\\ndest.begin() , \\\n[] (BOOST_PP_SEQ_FOR_EACH_I(LAMBDA_INPUT, df, input_seq)) func_body ); \\\ndf.add_column<dest_type>(dest_name, dest); \\\n} \\\n}\n\n\nint main(int argc, char *argv[])\n{\nauto fs = make_shared<fs::LocalFileSystem>();\nauto r_input = fs->OpenInputStream(\"c:/temp/_DatasetP14Seizures.csv\");\n\nauto pool = default_memory_pool();\nauto read_options = arrow::csv::ReadOptions::Defaults();\nauto parse_options = arrow::csv::ParseOptions::Defaults();\nauto convert_options = arrow::csv::ConvertOptions::Defaults();\n\nauto r_table_reader = csv::TableReader::Make(pool, r_input.ValueOrDie(),\nread_options, parse_options, convert_options);\nauto r_read = r_table_reader.ValueOrDie()->Read();\nauto p_table = r_read.ValueOrDie();\n\nPrettyPrintOptions options{0};\narrow::PrettyPrint(*p_table, options, &std::cout);\n\n// Test covers and iterators.\nconst Table& tlb = *p_table;\nconst int64_t rows = tlb.num_rows();\nconst int cols = tlb.num_columns();\nfor (int c = 0; c < cols; c++)\n{\nauto f = tlb.field(c);\nconst string& name = f->name();\nint type_id = f->type()->id();\nauto ch_arr = tlb.column(c);\nauto values_buffer = ch_arr->chunk(0)->data()->buffers[1];\ncout << \"is_mutable: \" << values_buffer->is_mutable() << endl;\nswitch (type_id)\n{\ncase Type::DOUBLE:\n{\n#if 0\nusing iterator = ChunkedArrayIteratorRaw<arrow::DoubleArray, double>;\niterator it(ch_arr, 2);\ncout << it.IsNull() << endl;\nboost::iterator_range<iterator> range(it-2, it+8);\nfor (double val : range)\ncout << val << endl;\n#else\nusing cover = ChunkedArrayCover<double>;\nusing iterator = typename cover::iterator;\nusing range = typename boost::iterator_range<iterator>;\ncover cvr(ch_arr);\nauto begin = cvr.begin();\nauto end = cvr.end();\nauto rbegin = cvr.rbegin();\nauto rend = cvr.rend();\nauto it = begin;\nit += 2;\ncout << \"value_isnull: \" << it.IsNull() << endl;\nrange rng(it-2, it+8);\nfor (double val : rng)\ncout << val << endl;\n#endif\n}\nbreak;\ncase Type::STRING:\n{\nusing iterator = ChunkedArrayIteratorString;\niterator it(ch_arr, 2);\ncout << \"value_isnull: \" << it.IsNull() << endl;\nboost::iterator_range<iterator> range(it-2, it+8);\nfor (const std::string val : range)\ncout << val << endl;\n}\nbreak;\ncase Type::BOOL:\n{\nusing iterator = ChunkedArrayIteratorBoolean;\niterator it(ch_arr, 2);\ncout << \"value_isnull: \" << it.IsNull() << endl;\nboost::iterator_range<iterator> range(it-2, it+8);\nfor (bool val : range)\ncout << val << endl;\n}\nbreak;\n\ndefault:\nbreak;\n}\n}\n\n// 1 cout << is_number_type<CTypeTraits<double>::ArrowType>::value << endl;\n// 1 cout << is_number_type<CTypeTraits<int>::ArrowType>::value << endl;\n// 0 cout << is_number_type<CTypeTraits<bool>::ArrowType>::value << endl;\n// 0 cout << is_number_type<CTypeTraits<std::string>::ArrowType>::value <<\nendl;\n\n// Testing code, to check templates.\nif (false)\n{\nTestFrame df;\nauto beg = df.begin<double>(\"foo\");\nEVAL2(df, (double, dest), { return foo*foo; }, ((double, foo)));\nEVAL2(df, (double, dest), { return foo*foo; }, ((double,\nfoo))((std::string, name)));\n}\n\nif (true)\n{\nTestFrame df(p_table);\nauto beg = df.begin<double>(\"Duration\");\nEVAL2(df, (double, LogDur), { return log10(Duration); }, ((double,\nDuration)));\nEVAL2(df, (std::string, Length), { return (LogDur>3) ? \"long\" : \"short\"; },\n((double, LogDur)));\narrow::PrettyPrint(*df._table, options, &std::cout);\n}\n\nreturn 1;\n}\n\n\n\n\n-- \nScott B. Wilson\nChairman and Chief Scientist\nPersyst Development Corporation\n420 Stevens Avenue, Suite 210\nSolana Beach, CA 92075\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=swilson314",
                        "name": "swilson314",
                        "key": "swilson314",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Scott Wilson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2020-04-23T17:34:00.078+0000",
                    "updated": "2020-04-23T17:34:00.078+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/comment/17090795",
                    "id": "17090795",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "> Mainly I'd like to know if this looks like the direction you're thinking for arrow::DataFrame?\r\n\r\nNo, to be honest from a glance it's a different direction from what I've been thinking. My thoughts there actually are for the data frame internally to be a mix of yet-to-be-scanned Datasets (e.g. from CSV or Parquet files), manifest (materialized in-memory) chunked arrays, and unevaluated expressions. Analytics requests translate requests into physical query plans to be executed by the to-be-developed query engine. I haven't been able to give this my full attention since writing the design docs last year but I intend to spend a large fraction of my time on it the rest of the year.\r\n\r\nThe reasoning for wanting to push data frame operations into a query engine is to get around the memory use issues and performance problems associated with \"eager evaluation\" data frame libraries like pandas (for example, a join in pandas materializes the entire joined data frame in memory). There are similar issues around sorting (particular with the knowledge of what you want to do with the sorted data -- e.g. sort followed by a slice can be executed as a Top-K operation for substantially less memory use)\r\n\r\nThat said, I know a number of people have expressed interest in having STL interface layers in Arrow to the data structures. This would be a valuable thing to contribute to the project. It's not mutually exclusive with the stuff I wrote above but wanted to give some idea ",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-04-23T17:46:19.003+0000",
                    "updated": "2020-04-23T17:46:19.003+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/comment/17090811",
                    "id": "17090811",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=swilson314",
                        "name": "swilson314",
                        "key": "swilson314",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Scott Wilson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Ah. That will be very cool. Thanks for your feedback. I\u2019ll continue with\nthis approach, we\u2019re moving our ML pipeline from python to c++, until yours\nmaterializes.\n\nOn Thu, Apr 23, 2020 at 10:47 AM Wes McKinney (Jira) <jira@apache.org>\n\n-- \nSent from Gmail Mobile\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=swilson314",
                        "name": "swilson314",
                        "key": "swilson314",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Scott Wilson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2020-04-23T18:06:00.099+0000",
                    "updated": "2020-04-23T18:06:00.099+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/comment/17192466",
                    "id": "17192466",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=swilson314",
                        "name": "swilson314",
                        "key": "swilson314",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Scott Wilson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Hey Wes,\n\nI hope you and yours are doing well in this strange time.\n\nI'm just writing to thank you for all the work you did on Arrow and the\nvarious discussions you've posted about the design decisions that drove\nthis development, post pandas. I've largely completed my C++ DataFrame and\nreplaced python/pandas code that we use for our ML pipeline. Using the\nArrow framework, I've been able to create a DataFrame object that wraps one\nor more arrow tables. The implementation supports no-copy subsets, joins\nand concatenations, and stl-like iterators. Also supported are transforms\nusing in-place lambda functions. The net is that a ~1 TB data processing\nstep that used to take 13 h now requires 15 m.\n\nThe only kluge I put into place has to do with support for null values. I\nallow in-place editing of values, but no changes to array sizes or types.\nThis is possible because the typed arrays offer access to the underlying\nraw values. To offer the same for null values I had to create derived\nclasses for Array and ChunkedArray offer access to the cached null_counts.\n\nI've attached the DataFrame header in case it's of interest.\n\nThanks again, Scott\n\n\n\n\n-- \nScott B. Wilson\nChairman and Chief Scientist\nPersyst Development Corporation\n420 Stevens Avenue, Suite 210\nSolana Beach, CA 92075\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=swilson314",
                        "name": "swilson314",
                        "key": "swilson314",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Scott Wilson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2020-09-08T20:41:00.136+0000",
                    "updated": "2020-09-08T20:41:00.136+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/comment/17192873",
                    "id": "17192873",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "That's great news. Thanks for attaching the code -- if you apply an open source license to it (like Apache 2.0) then others may be able to reuse parts of it. ",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-09-09T13:33:23.401+0000",
                    "updated": "2020-09-09T13:33:23.401+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/comment/17193028",
                    "id": "17193028",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=swilson314",
                        "name": "swilson314",
                        "key": "swilson314",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Scott Wilson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Is there a way it could become part of the Apache Arrow project?\n\n\n\n\n-- \nScott B. Wilson\nChairman and Chief Scientist\nPersyst Development Corporation\n420 Stevens Avenue, Suite 210\nSolana Beach, CA 92075\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=swilson314",
                        "name": "swilson314",
                        "key": "swilson314",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Scott Wilson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2020-09-09T16:48:00.145+0000",
                    "updated": "2020-09-09T16:48:00.145+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/comment/17193036",
                    "id": "17193036",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Sure, it would need to be contributed at least as pull request -- depending on discussions on the mailing list about the origins of the software, since it was externally-developed we might need to obtain a software grant from your company. Then there is the question of \"productionizing\" it -- conforming it to the code style of the project and writing unit tests. \r\n\r\nFor what it's worth, people have a lot of different expectations when they hear \"data frame\", and realistically we may end up with different kinds of data frame interfaces. From what I can see in the code, this is different than what I've proposed in https://docs.google.com/document/d/1XHe_j87n2VHGzEbnLe786GHbbcbrzbjgG8D0IXWAeHg/edit#heading=h.g70gstc7jq4h but have not been able to do any development on personally. I'm not personally able to invest time in this project in the near term unfortunately. ",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-09-09T16:59:53.893+0000",
                    "updated": "2020-09-09T16:59:53.893+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/comment/17193718",
                    "id": "17193718",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=swilson314",
                        "name": "swilson314",
                        "key": "swilson314",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Scott Wilson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Ok, thanks! Seems like a fair amount of work without a really compelling\nreason....\n\n\n\n\n-- \nScott B. Wilson\nChairman and Chief Scientist\nPersyst Development Corporation\n420 Stevens Avenue, Suite 210\nSolana Beach, CA 92075\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=swilson314",
                        "name": "swilson314",
                        "key": "swilson314",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Scott Wilson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2020-09-10T16:47:00.141+0000",
                    "updated": "2020-09-10T16:47:00.141+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13293624/comment/17238276",
                    "id": "17238276",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 8612\n[https://github.com/apache/arrow/pull/8612]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2020-11-24T17:32:04.332+0000",
                    "updated": "2020-11-24T17:32:04.332+0000"
                }
            ],
            "maxResults": 14,
            "total": 14,
            "startAt": 0
        },
        "customfield_12311820": "0|z0cuwo:",
        "customfield_12314139": null
    }
}