{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13373424",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13373424",
    "key": "ARROW-12443",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349983",
                "id": "12349983",
                "description": "",
                "name": "5.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-07-28"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
            "name": "Minor",
            "id": "4"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jpedroantunes",
            "name": "jpedroantunes",
            "key": "jpedroantunes",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34060",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34060",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34060",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34060"
            },
            "displayName": "Jo\u00e3o Pedro Antunes Ferreira",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12334626",
                "id": "12334626",
                "name": "C++ - Gandiva"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jpedroantunes",
            "name": "jpedroantunes",
            "key": "jpedroantunes",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34060",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34060",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34060",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34060"
            },
            "displayName": "Jo\u00e3o Pedro Antunes Ferreira",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jpedroantunes",
            "name": "jpedroantunes",
            "key": "jpedroantunes",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34060",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34060",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34060",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34060"
            },
            "displayName": "Jo\u00e3o Pedro Antunes Ferreira",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 6600,
            "total": 6600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 6600,
            "total": 6600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12443/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 11,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13373424/worklog/584830",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jpedroantunes opened a new pull request #10095:\nURL: https://github.com/apache/arrow/pull/10095\n\n\n   Implement castVARCHAR function for varbinary input\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-19T00:49:22.311+0000",
                    "updated": "2021-04-19T00:49:22.311+0000",
                    "started": "2021-04-19T00:49:22.310+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "584830",
                    "issueId": "13373424"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13373424/worklog/584831",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10095:\nURL: https://github.com/apache/arrow/pull/10095#issuecomment-822100329\n\n\n   https://issues.apache.org/jira/browse/ARROW-12443\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-19T00:49:46.953+0000",
                    "updated": "2021-04-19T00:49:46.953+0000",
                    "started": "2021-04-19T00:49:46.953+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "584831",
                    "issueId": "13373424"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13373424/worklog/590387",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "projjal commented on a change in pull request #10095:\nURL: https://github.com/apache/arrow/pull/10095#discussion_r622178503\n\n\n\n##########\nFile path: cpp/src/gandiva/precompiled/string_ops.cc\n##########\n@@ -534,88 +534,96 @@ const char* castVARCHAR_bool_int64(gdv_int64 context, gdv_boolean value,\n }\n \n // Truncates the string to given length\n-FORCE_INLINE\n-const char* castVARCHAR_utf8_int64(gdv_int64 context, const char* data,\n-                                   gdv_int32 data_len, int64_t out_len,\n-                                   int32_t* out_length) {\n-  int32_t len = static_cast<int32_t>(out_len);\n-\n-  if (len < 0) {\n-    gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\");\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  if (len >= data_len || len == 0) {\n-    *out_length = data_len;\n-    return data;\n-  }\n-\n-  int32_t remaining = len;\n-  int32_t index = 0;\n-  bool is_multibyte = false;\n-  do {\n-    // In utf8, MSB of a single byte unicode char is always 0,\n-    // whereas for a multibyte character the MSB of each byte is 1.\n-    // So for a single byte char, a bitwise-and with x80 (10000000) will be 0\n-    // and it won't be 0 for bytes of a multibyte char\n-    char* data_ptr = const_cast<char*>(data);\n-\n-    // we advance byte by byte till the 8 byte boundary then advance 8 bytes at a time\n-    auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;\n-    num_bytes = (8 - num_bytes) & 0x07;\n-    while (num_bytes > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-      num_bytes--;\n-    }\n-    if (is_multibyte) break;\n-    while (remaining >= 8) {\n-      uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);\n-      if ((*ptr & 0x8080808080808080) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index += 8;\n-      remaining -= 8;\n-    }\n-    if (is_multibyte) break;\n-    if (remaining >= 4) {\n-      uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);\n-      if ((*ptr & 0x80808080) != 0) break;\n-      index += 4;\n-      remaining -= 4;\n-    }\n-    while (remaining > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-    }\n-    if (is_multibyte) break;\n-    // reached here; all are single byte characters\n-    *out_length = len;\n-    return data;\n-  } while (false);\n-\n-  // detected multibyte utf8 characters; slow path\n-  int32_t byte_pos = utf8_byte_pos(context, data + index, data_len - index, len - index);\n-  if (byte_pos < 0) {\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  *out_length = index + byte_pos;\n-  return data;\n-}\n+#define CAST_VARCHAR_UTF8_BINARY(TYPE)                                                 \\\n+  FORCE_INLINE                                                                         \\\n+  const char* castVARCHAR_##TYPE##_int64(gdv_int64 context, const char* data,          \\\n+                                         gdv_int32 data_len, int64_t out_len,          \\\n+                                         int32_t* out_length) {                        \\\n+    int32_t len = static_cast<int32_t>(out_len);                                       \\\n+                                                                                       \\\n+    if (len < 0) {                                                                     \\\n+      gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\"); \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    if (len >= data_len || len == 0) {                                                 \\\n+      *out_length = data_len;                                                          \\\n+      return data;                                                                     \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    int32_t remaining = len;                                                           \\\n+    int32_t index = 0;                                                                 \\\n+    bool is_multibyte = false;                                                         \\\n+    do {                                                                               \\\n+      /* In utf8, MSB of a single byte unicode char is always 0,                       \\\n+       * whereas for a multibyte character the MSB of each byte is 1.                  \\\n+       * So for a single byte char, a bitwise-and with x80 (10000000) will be 0        \\\n+       * and it won't be 0 for bytes of a multibyte char.                              \\\n+       */                                                                              \\\n+      char* data_ptr = const_cast<char*>(data);                                        \\\n+                                                                                       \\\n+      /* advance byte by byte till the 8-byte boundary then advance 8 bytes */         \\\n+      auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;                   \\\n+      num_bytes = (8 - num_bytes) & 0x07;                                              \\\n+      while (num_bytes > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+        num_bytes--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      while (remaining >= 8) {                                                         \\\n+        uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x8080808080808080) != 0) {                                        \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index += 8;                                                                    \\\n+        remaining -= 8;                                                                \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      if (remaining >= 4) {                                                            \\\n+        uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x80808080) != 0) break;                                           \\\n+        index += 4;                                                                    \\\n+        remaining -= 4;                                                                \\\n+      }                                                                                \\\n+      while (remaining > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      /* reached here; all are single byte characters */                               \\\n+      *out_length = len;                                                               \\\n+      return data;                                                                     \\\n+    } while (false);                                                                   \\\n+                                                                                       \\\n+    /* detected multibyte utf8 characters; slow path */                                \\\n+    int32_t byte_pos =                                                                 \\\n+        utf8_byte_pos(context, data + index, data_len - index, len - index);           \\\n+    if (byte_pos < 0) {                                                                \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    *out_length = index + byte_pos;                                                    \\\n+    return data;                                                                       \\\n+  }\n+\n+CAST_VARCHAR_UTF8_BINARY(utf8)\n+CAST_VARCHAR_UTF8_BINARY(binary)\n\nReview comment:\n       castVARBINARY shouldn't need utf8 handling. Thats only for varchar.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-28T13:28:02.211+0000",
                    "updated": "2021-04-28T13:28:02.211+0000",
                    "started": "2021-04-28T13:28:02.211+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "590387",
                    "issueId": "13373424"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13373424/worklog/590397",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jpedroantunes commented on a change in pull request #10095:\nURL: https://github.com/apache/arrow/pull/10095#discussion_r622185533\n\n\n\n##########\nFile path: cpp/src/gandiva/precompiled/string_ops.cc\n##########\n@@ -534,88 +534,96 @@ const char* castVARCHAR_bool_int64(gdv_int64 context, gdv_boolean value,\n }\n \n // Truncates the string to given length\n-FORCE_INLINE\n-const char* castVARCHAR_utf8_int64(gdv_int64 context, const char* data,\n-                                   gdv_int32 data_len, int64_t out_len,\n-                                   int32_t* out_length) {\n-  int32_t len = static_cast<int32_t>(out_len);\n-\n-  if (len < 0) {\n-    gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\");\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  if (len >= data_len || len == 0) {\n-    *out_length = data_len;\n-    return data;\n-  }\n-\n-  int32_t remaining = len;\n-  int32_t index = 0;\n-  bool is_multibyte = false;\n-  do {\n-    // In utf8, MSB of a single byte unicode char is always 0,\n-    // whereas for a multibyte character the MSB of each byte is 1.\n-    // So for a single byte char, a bitwise-and with x80 (10000000) will be 0\n-    // and it won't be 0 for bytes of a multibyte char\n-    char* data_ptr = const_cast<char*>(data);\n-\n-    // we advance byte by byte till the 8 byte boundary then advance 8 bytes at a time\n-    auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;\n-    num_bytes = (8 - num_bytes) & 0x07;\n-    while (num_bytes > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-      num_bytes--;\n-    }\n-    if (is_multibyte) break;\n-    while (remaining >= 8) {\n-      uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);\n-      if ((*ptr & 0x8080808080808080) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index += 8;\n-      remaining -= 8;\n-    }\n-    if (is_multibyte) break;\n-    if (remaining >= 4) {\n-      uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);\n-      if ((*ptr & 0x80808080) != 0) break;\n-      index += 4;\n-      remaining -= 4;\n-    }\n-    while (remaining > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-    }\n-    if (is_multibyte) break;\n-    // reached here; all are single byte characters\n-    *out_length = len;\n-    return data;\n-  } while (false);\n-\n-  // detected multibyte utf8 characters; slow path\n-  int32_t byte_pos = utf8_byte_pos(context, data + index, data_len - index, len - index);\n-  if (byte_pos < 0) {\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  *out_length = index + byte_pos;\n-  return data;\n-}\n+#define CAST_VARCHAR_UTF8_BINARY(TYPE)                                                 \\\n+  FORCE_INLINE                                                                         \\\n+  const char* castVARCHAR_##TYPE##_int64(gdv_int64 context, const char* data,          \\\n+                                         gdv_int32 data_len, int64_t out_len,          \\\n+                                         int32_t* out_length) {                        \\\n+    int32_t len = static_cast<int32_t>(out_len);                                       \\\n+                                                                                       \\\n+    if (len < 0) {                                                                     \\\n+      gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\"); \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    if (len >= data_len || len == 0) {                                                 \\\n+      *out_length = data_len;                                                          \\\n+      return data;                                                                     \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    int32_t remaining = len;                                                           \\\n+    int32_t index = 0;                                                                 \\\n+    bool is_multibyte = false;                                                         \\\n+    do {                                                                               \\\n+      /* In utf8, MSB of a single byte unicode char is always 0,                       \\\n+       * whereas for a multibyte character the MSB of each byte is 1.                  \\\n+       * So for a single byte char, a bitwise-and with x80 (10000000) will be 0        \\\n+       * and it won't be 0 for bytes of a multibyte char.                              \\\n+       */                                                                              \\\n+      char* data_ptr = const_cast<char*>(data);                                        \\\n+                                                                                       \\\n+      /* advance byte by byte till the 8-byte boundary then advance 8 bytes */         \\\n+      auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;                   \\\n+      num_bytes = (8 - num_bytes) & 0x07;                                              \\\n+      while (num_bytes > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+        num_bytes--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      while (remaining >= 8) {                                                         \\\n+        uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x8080808080808080) != 0) {                                        \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index += 8;                                                                    \\\n+        remaining -= 8;                                                                \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      if (remaining >= 4) {                                                            \\\n+        uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x80808080) != 0) break;                                           \\\n+        index += 4;                                                                    \\\n+        remaining -= 4;                                                                \\\n+      }                                                                                \\\n+      while (remaining > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      /* reached here; all are single byte characters */                               \\\n+      *out_length = len;                                                               \\\n+      return data;                                                                     \\\n+    } while (false);                                                                   \\\n+                                                                                       \\\n+    /* detected multibyte utf8 characters; slow path */                                \\\n+    int32_t byte_pos =                                                                 \\\n+        utf8_byte_pos(context, data + index, data_len - index, len - index);           \\\n+    if (byte_pos < 0) {                                                                \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    *out_length = index + byte_pos;                                                    \\\n+    return data;                                                                       \\\n+  }\n+\n+CAST_VARCHAR_UTF8_BINARY(utf8)\n+CAST_VARCHAR_UTF8_BINARY(binary)\n\nReview comment:\n       Sure! But this IS a castVARCHAR function receiving a binary value as input. Can you confirm that you understand correctly?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-28T13:36:02.817+0000",
                    "updated": "2021-04-28T13:36:02.817+0000",
                    "started": "2021-04-28T13:36:02.816+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "590397",
                    "issueId": "13373424"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13373424/worklog/590398",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jpedroantunes commented on a change in pull request #10095:\nURL: https://github.com/apache/arrow/pull/10095#discussion_r622185533\n\n\n\n##########\nFile path: cpp/src/gandiva/precompiled/string_ops.cc\n##########\n@@ -534,88 +534,96 @@ const char* castVARCHAR_bool_int64(gdv_int64 context, gdv_boolean value,\n }\n \n // Truncates the string to given length\n-FORCE_INLINE\n-const char* castVARCHAR_utf8_int64(gdv_int64 context, const char* data,\n-                                   gdv_int32 data_len, int64_t out_len,\n-                                   int32_t* out_length) {\n-  int32_t len = static_cast<int32_t>(out_len);\n-\n-  if (len < 0) {\n-    gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\");\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  if (len >= data_len || len == 0) {\n-    *out_length = data_len;\n-    return data;\n-  }\n-\n-  int32_t remaining = len;\n-  int32_t index = 0;\n-  bool is_multibyte = false;\n-  do {\n-    // In utf8, MSB of a single byte unicode char is always 0,\n-    // whereas for a multibyte character the MSB of each byte is 1.\n-    // So for a single byte char, a bitwise-and with x80 (10000000) will be 0\n-    // and it won't be 0 for bytes of a multibyte char\n-    char* data_ptr = const_cast<char*>(data);\n-\n-    // we advance byte by byte till the 8 byte boundary then advance 8 bytes at a time\n-    auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;\n-    num_bytes = (8 - num_bytes) & 0x07;\n-    while (num_bytes > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-      num_bytes--;\n-    }\n-    if (is_multibyte) break;\n-    while (remaining >= 8) {\n-      uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);\n-      if ((*ptr & 0x8080808080808080) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index += 8;\n-      remaining -= 8;\n-    }\n-    if (is_multibyte) break;\n-    if (remaining >= 4) {\n-      uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);\n-      if ((*ptr & 0x80808080) != 0) break;\n-      index += 4;\n-      remaining -= 4;\n-    }\n-    while (remaining > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-    }\n-    if (is_multibyte) break;\n-    // reached here; all are single byte characters\n-    *out_length = len;\n-    return data;\n-  } while (false);\n-\n-  // detected multibyte utf8 characters; slow path\n-  int32_t byte_pos = utf8_byte_pos(context, data + index, data_len - index, len - index);\n-  if (byte_pos < 0) {\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  *out_length = index + byte_pos;\n-  return data;\n-}\n+#define CAST_VARCHAR_UTF8_BINARY(TYPE)                                                 \\\n+  FORCE_INLINE                                                                         \\\n+  const char* castVARCHAR_##TYPE##_int64(gdv_int64 context, const char* data,          \\\n+                                         gdv_int32 data_len, int64_t out_len,          \\\n+                                         int32_t* out_length) {                        \\\n+    int32_t len = static_cast<int32_t>(out_len);                                       \\\n+                                                                                       \\\n+    if (len < 0) {                                                                     \\\n+      gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\"); \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    if (len >= data_len || len == 0) {                                                 \\\n+      *out_length = data_len;                                                          \\\n+      return data;                                                                     \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    int32_t remaining = len;                                                           \\\n+    int32_t index = 0;                                                                 \\\n+    bool is_multibyte = false;                                                         \\\n+    do {                                                                               \\\n+      /* In utf8, MSB of a single byte unicode char is always 0,                       \\\n+       * whereas for a multibyte character the MSB of each byte is 1.                  \\\n+       * So for a single byte char, a bitwise-and with x80 (10000000) will be 0        \\\n+       * and it won't be 0 for bytes of a multibyte char.                              \\\n+       */                                                                              \\\n+      char* data_ptr = const_cast<char*>(data);                                        \\\n+                                                                                       \\\n+      /* advance byte by byte till the 8-byte boundary then advance 8 bytes */         \\\n+      auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;                   \\\n+      num_bytes = (8 - num_bytes) & 0x07;                                              \\\n+      while (num_bytes > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+        num_bytes--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      while (remaining >= 8) {                                                         \\\n+        uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x8080808080808080) != 0) {                                        \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index += 8;                                                                    \\\n+        remaining -= 8;                                                                \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      if (remaining >= 4) {                                                            \\\n+        uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x80808080) != 0) break;                                           \\\n+        index += 4;                                                                    \\\n+        remaining -= 4;                                                                \\\n+      }                                                                                \\\n+      while (remaining > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      /* reached here; all are single byte characters */                               \\\n+      *out_length = len;                                                               \\\n+      return data;                                                                     \\\n+    } while (false);                                                                   \\\n+                                                                                       \\\n+    /* detected multibyte utf8 characters; slow path */                                \\\n+    int32_t byte_pos =                                                                 \\\n+        utf8_byte_pos(context, data + index, data_len - index, len - index);           \\\n+    if (byte_pos < 0) {                                                                \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    *out_length = index + byte_pos;                                                    \\\n+    return data;                                                                       \\\n+  }\n+\n+CAST_VARCHAR_UTF8_BINARY(utf8)\n+CAST_VARCHAR_UTF8_BINARY(binary)\n\nReview comment:\n       Sure! But this IS a castVARCHAR (this is not castVARBINARY) function receiving a binary value as input. Can you confirm that you understand correctly?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-28T13:36:26.159+0000",
                    "updated": "2021-04-28T13:36:26.159+0000",
                    "started": "2021-04-28T13:36:26.159+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "590398",
                    "issueId": "13373424"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13373424/worklog/590399",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jpedroantunes commented on a change in pull request #10095:\nURL: https://github.com/apache/arrow/pull/10095#discussion_r622185533\n\n\n\n##########\nFile path: cpp/src/gandiva/precompiled/string_ops.cc\n##########\n@@ -534,88 +534,96 @@ const char* castVARCHAR_bool_int64(gdv_int64 context, gdv_boolean value,\n }\n \n // Truncates the string to given length\n-FORCE_INLINE\n-const char* castVARCHAR_utf8_int64(gdv_int64 context, const char* data,\n-                                   gdv_int32 data_len, int64_t out_len,\n-                                   int32_t* out_length) {\n-  int32_t len = static_cast<int32_t>(out_len);\n-\n-  if (len < 0) {\n-    gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\");\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  if (len >= data_len || len == 0) {\n-    *out_length = data_len;\n-    return data;\n-  }\n-\n-  int32_t remaining = len;\n-  int32_t index = 0;\n-  bool is_multibyte = false;\n-  do {\n-    // In utf8, MSB of a single byte unicode char is always 0,\n-    // whereas for a multibyte character the MSB of each byte is 1.\n-    // So for a single byte char, a bitwise-and with x80 (10000000) will be 0\n-    // and it won't be 0 for bytes of a multibyte char\n-    char* data_ptr = const_cast<char*>(data);\n-\n-    // we advance byte by byte till the 8 byte boundary then advance 8 bytes at a time\n-    auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;\n-    num_bytes = (8 - num_bytes) & 0x07;\n-    while (num_bytes > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-      num_bytes--;\n-    }\n-    if (is_multibyte) break;\n-    while (remaining >= 8) {\n-      uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);\n-      if ((*ptr & 0x8080808080808080) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index += 8;\n-      remaining -= 8;\n-    }\n-    if (is_multibyte) break;\n-    if (remaining >= 4) {\n-      uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);\n-      if ((*ptr & 0x80808080) != 0) break;\n-      index += 4;\n-      remaining -= 4;\n-    }\n-    while (remaining > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-    }\n-    if (is_multibyte) break;\n-    // reached here; all are single byte characters\n-    *out_length = len;\n-    return data;\n-  } while (false);\n-\n-  // detected multibyte utf8 characters; slow path\n-  int32_t byte_pos = utf8_byte_pos(context, data + index, data_len - index, len - index);\n-  if (byte_pos < 0) {\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  *out_length = index + byte_pos;\n-  return data;\n-}\n+#define CAST_VARCHAR_UTF8_BINARY(TYPE)                                                 \\\n+  FORCE_INLINE                                                                         \\\n+  const char* castVARCHAR_##TYPE##_int64(gdv_int64 context, const char* data,          \\\n+                                         gdv_int32 data_len, int64_t out_len,          \\\n+                                         int32_t* out_length) {                        \\\n+    int32_t len = static_cast<int32_t>(out_len);                                       \\\n+                                                                                       \\\n+    if (len < 0) {                                                                     \\\n+      gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\"); \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    if (len >= data_len || len == 0) {                                                 \\\n+      *out_length = data_len;                                                          \\\n+      return data;                                                                     \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    int32_t remaining = len;                                                           \\\n+    int32_t index = 0;                                                                 \\\n+    bool is_multibyte = false;                                                         \\\n+    do {                                                                               \\\n+      /* In utf8, MSB of a single byte unicode char is always 0,                       \\\n+       * whereas for a multibyte character the MSB of each byte is 1.                  \\\n+       * So for a single byte char, a bitwise-and with x80 (10000000) will be 0        \\\n+       * and it won't be 0 for bytes of a multibyte char.                              \\\n+       */                                                                              \\\n+      char* data_ptr = const_cast<char*>(data);                                        \\\n+                                                                                       \\\n+      /* advance byte by byte till the 8-byte boundary then advance 8 bytes */         \\\n+      auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;                   \\\n+      num_bytes = (8 - num_bytes) & 0x07;                                              \\\n+      while (num_bytes > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+        num_bytes--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      while (remaining >= 8) {                                                         \\\n+        uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x8080808080808080) != 0) {                                        \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index += 8;                                                                    \\\n+        remaining -= 8;                                                                \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      if (remaining >= 4) {                                                            \\\n+        uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x80808080) != 0) break;                                           \\\n+        index += 4;                                                                    \\\n+        remaining -= 4;                                                                \\\n+      }                                                                                \\\n+      while (remaining > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      /* reached here; all are single byte characters */                               \\\n+      *out_length = len;                                                               \\\n+      return data;                                                                     \\\n+    } while (false);                                                                   \\\n+                                                                                       \\\n+    /* detected multibyte utf8 characters; slow path */                                \\\n+    int32_t byte_pos =                                                                 \\\n+        utf8_byte_pos(context, data + index, data_len - index, len - index);           \\\n+    if (byte_pos < 0) {                                                                \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    *out_length = index + byte_pos;                                                    \\\n+    return data;                                                                       \\\n+  }\n+\n+CAST_VARCHAR_UTF8_BINARY(utf8)\n+CAST_VARCHAR_UTF8_BINARY(binary)\n\nReview comment:\n       Sure! But did you notice that this IS a castVARCHAR function receiving a binary value as input? (This is not castVARBINARY) Can you confirm that you understand correctly?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-28T13:39:25.491+0000",
                    "updated": "2021-04-28T13:39:25.491+0000",
                    "started": "2021-04-28T13:39:25.491+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "590399",
                    "issueId": "13373424"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13373424/worklog/590402",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "projjal commented on a change in pull request #10095:\nURL: https://github.com/apache/arrow/pull/10095#discussion_r622191788\n\n\n\n##########\nFile path: cpp/src/gandiva/precompiled/string_ops.cc\n##########\n@@ -534,88 +534,96 @@ const char* castVARCHAR_bool_int64(gdv_int64 context, gdv_boolean value,\n }\n \n // Truncates the string to given length\n-FORCE_INLINE\n-const char* castVARCHAR_utf8_int64(gdv_int64 context, const char* data,\n-                                   gdv_int32 data_len, int64_t out_len,\n-                                   int32_t* out_length) {\n-  int32_t len = static_cast<int32_t>(out_len);\n-\n-  if (len < 0) {\n-    gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\");\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  if (len >= data_len || len == 0) {\n-    *out_length = data_len;\n-    return data;\n-  }\n-\n-  int32_t remaining = len;\n-  int32_t index = 0;\n-  bool is_multibyte = false;\n-  do {\n-    // In utf8, MSB of a single byte unicode char is always 0,\n-    // whereas for a multibyte character the MSB of each byte is 1.\n-    // So for a single byte char, a bitwise-and with x80 (10000000) will be 0\n-    // and it won't be 0 for bytes of a multibyte char\n-    char* data_ptr = const_cast<char*>(data);\n-\n-    // we advance byte by byte till the 8 byte boundary then advance 8 bytes at a time\n-    auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;\n-    num_bytes = (8 - num_bytes) & 0x07;\n-    while (num_bytes > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-      num_bytes--;\n-    }\n-    if (is_multibyte) break;\n-    while (remaining >= 8) {\n-      uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);\n-      if ((*ptr & 0x8080808080808080) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index += 8;\n-      remaining -= 8;\n-    }\n-    if (is_multibyte) break;\n-    if (remaining >= 4) {\n-      uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);\n-      if ((*ptr & 0x80808080) != 0) break;\n-      index += 4;\n-      remaining -= 4;\n-    }\n-    while (remaining > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-    }\n-    if (is_multibyte) break;\n-    // reached here; all are single byte characters\n-    *out_length = len;\n-    return data;\n-  } while (false);\n-\n-  // detected multibyte utf8 characters; slow path\n-  int32_t byte_pos = utf8_byte_pos(context, data + index, data_len - index, len - index);\n-  if (byte_pos < 0) {\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  *out_length = index + byte_pos;\n-  return data;\n-}\n+#define CAST_VARCHAR_UTF8_BINARY(TYPE)                                                 \\\n+  FORCE_INLINE                                                                         \\\n+  const char* castVARCHAR_##TYPE##_int64(gdv_int64 context, const char* data,          \\\n+                                         gdv_int32 data_len, int64_t out_len,          \\\n+                                         int32_t* out_length) {                        \\\n+    int32_t len = static_cast<int32_t>(out_len);                                       \\\n+                                                                                       \\\n+    if (len < 0) {                                                                     \\\n+      gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\"); \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    if (len >= data_len || len == 0) {                                                 \\\n+      *out_length = data_len;                                                          \\\n+      return data;                                                                     \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    int32_t remaining = len;                                                           \\\n+    int32_t index = 0;                                                                 \\\n+    bool is_multibyte = false;                                                         \\\n+    do {                                                                               \\\n+      /* In utf8, MSB of a single byte unicode char is always 0,                       \\\n+       * whereas for a multibyte character the MSB of each byte is 1.                  \\\n+       * So for a single byte char, a bitwise-and with x80 (10000000) will be 0        \\\n+       * and it won't be 0 for bytes of a multibyte char.                              \\\n+       */                                                                              \\\n+      char* data_ptr = const_cast<char*>(data);                                        \\\n+                                                                                       \\\n+      /* advance byte by byte till the 8-byte boundary then advance 8 bytes */         \\\n+      auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;                   \\\n+      num_bytes = (8 - num_bytes) & 0x07;                                              \\\n+      while (num_bytes > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+        num_bytes--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      while (remaining >= 8) {                                                         \\\n+        uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x8080808080808080) != 0) {                                        \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index += 8;                                                                    \\\n+        remaining -= 8;                                                                \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      if (remaining >= 4) {                                                            \\\n+        uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x80808080) != 0) break;                                           \\\n+        index += 4;                                                                    \\\n+        remaining -= 4;                                                                \\\n+      }                                                                                \\\n+      while (remaining > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      /* reached here; all are single byte characters */                               \\\n+      *out_length = len;                                                               \\\n+      return data;                                                                     \\\n+    } while (false);                                                                   \\\n+                                                                                       \\\n+    /* detected multibyte utf8 characters; slow path */                                \\\n+    int32_t byte_pos =                                                                 \\\n+        utf8_byte_pos(context, data + index, data_len - index, len - index);           \\\n+    if (byte_pos < 0) {                                                                \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    *out_length = index + byte_pos;                                                    \\\n+    return data;                                                                       \\\n+  }\n+\n+CAST_VARCHAR_UTF8_BINARY(utf8)\n+CAST_VARCHAR_UTF8_BINARY(binary)\n\nReview comment:\n       oh it makes sense. I understood incorrectly.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-28T13:42:48.213+0000",
                    "updated": "2021-04-28T13:42:48.213+0000",
                    "started": "2021-04-28T13:42:48.213+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "590402",
                    "issueId": "13373424"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13373424/worklog/591363",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "projjal commented on a change in pull request #10095:\nURL: https://github.com/apache/arrow/pull/10095#discussion_r623576984\n\n\n\n##########\nFile path: cpp/src/gandiva/precompiled/string_ops.cc\n##########\n@@ -534,88 +534,96 @@ const char* castVARCHAR_bool_int64(gdv_int64 context, gdv_boolean value,\n }\n \n // Truncates the string to given length\n-FORCE_INLINE\n-const char* castVARCHAR_utf8_int64(gdv_int64 context, const char* data,\n-                                   gdv_int32 data_len, int64_t out_len,\n-                                   int32_t* out_length) {\n-  int32_t len = static_cast<int32_t>(out_len);\n-\n-  if (len < 0) {\n-    gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\");\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  if (len >= data_len || len == 0) {\n-    *out_length = data_len;\n-    return data;\n-  }\n-\n-  int32_t remaining = len;\n-  int32_t index = 0;\n-  bool is_multibyte = false;\n-  do {\n-    // In utf8, MSB of a single byte unicode char is always 0,\n-    // whereas for a multibyte character the MSB of each byte is 1.\n-    // So for a single byte char, a bitwise-and with x80 (10000000) will be 0\n-    // and it won't be 0 for bytes of a multibyte char\n-    char* data_ptr = const_cast<char*>(data);\n-\n-    // we advance byte by byte till the 8 byte boundary then advance 8 bytes at a time\n-    auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;\n-    num_bytes = (8 - num_bytes) & 0x07;\n-    while (num_bytes > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-      num_bytes--;\n-    }\n-    if (is_multibyte) break;\n-    while (remaining >= 8) {\n-      uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);\n-      if ((*ptr & 0x8080808080808080) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index += 8;\n-      remaining -= 8;\n-    }\n-    if (is_multibyte) break;\n-    if (remaining >= 4) {\n-      uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);\n-      if ((*ptr & 0x80808080) != 0) break;\n-      index += 4;\n-      remaining -= 4;\n-    }\n-    while (remaining > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-    }\n-    if (is_multibyte) break;\n-    // reached here; all are single byte characters\n-    *out_length = len;\n-    return data;\n-  } while (false);\n-\n-  // detected multibyte utf8 characters; slow path\n-  int32_t byte_pos = utf8_byte_pos(context, data + index, data_len - index, len - index);\n-  if (byte_pos < 0) {\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  *out_length = index + byte_pos;\n-  return data;\n-}\n+#define CAST_VARCHAR_UTF8_BINARY(TYPE)                                                 \\\n+  FORCE_INLINE                                                                         \\\n+  const char* castVARCHAR_##TYPE##_int64(gdv_int64 context, const char* data,          \\\n+                                         gdv_int32 data_len, int64_t out_len,          \\\n+                                         int32_t* out_length) {                        \\\n+    int32_t len = static_cast<int32_t>(out_len);                                       \\\n+                                                                                       \\\n+    if (len < 0) {                                                                     \\\n+      gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\"); \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    if (len >= data_len || len == 0) {                                                 \\\n+      *out_length = data_len;                                                          \\\n+      return data;                                                                     \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    int32_t remaining = len;                                                           \\\n+    int32_t index = 0;                                                                 \\\n+    bool is_multibyte = false;                                                         \\\n+    do {                                                                               \\\n+      /* In utf8, MSB of a single byte unicode char is always 0,                       \\\n+       * whereas for a multibyte character the MSB of each byte is 1.                  \\\n+       * So for a single byte char, a bitwise-and with x80 (10000000) will be 0        \\\n+       * and it won't be 0 for bytes of a multibyte char.                              \\\n+       */                                                                              \\\n+      char* data_ptr = const_cast<char*>(data);                                        \\\n+                                                                                       \\\n+      /* advance byte by byte till the 8-byte boundary then advance 8 bytes */         \\\n+      auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;                   \\\n+      num_bytes = (8 - num_bytes) & 0x07;                                              \\\n+      while (num_bytes > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+        num_bytes--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      while (remaining >= 8) {                                                         \\\n+        uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x8080808080808080) != 0) {                                        \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index += 8;                                                                    \\\n+        remaining -= 8;                                                                \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      if (remaining >= 4) {                                                            \\\n+        uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x80808080) != 0) break;                                           \\\n+        index += 4;                                                                    \\\n+        remaining -= 4;                                                                \\\n+      }                                                                                \\\n+      while (remaining > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      /* reached here; all are single byte characters */                               \\\n+      *out_length = len;                                                               \\\n+      return data;                                                                     \\\n+    } while (false);                                                                   \\\n+                                                                                       \\\n+    /* detected multibyte utf8 characters; slow path */                                \\\n+    int32_t byte_pos =                                                                 \\\n+        utf8_byte_pos(context, data + index, data_len - index, len - index);           \\\n+    if (byte_pos < 0) {                                                                \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    *out_length = index + byte_pos;                                                    \\\n+    return data;                                                                       \\\n+  }\n+\n+CAST_VARCHAR_UTF8_BINARY(utf8)\n\nReview comment:\n       These macro names looks confusing. Can you name the macro CAST_VARCHAR_FROM_VARWIDTH(TYPE)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-30T04:16:55.849+0000",
                    "updated": "2021-04-30T04:16:55.849+0000",
                    "started": "2021-04-30T04:16:55.849+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "591363",
                    "issueId": "13373424"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13373424/worklog/591373",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "projjal commented on a change in pull request #10095:\nURL: https://github.com/apache/arrow/pull/10095#discussion_r623576984\n\n\n\n##########\nFile path: cpp/src/gandiva/precompiled/string_ops.cc\n##########\n@@ -534,88 +534,96 @@ const char* castVARCHAR_bool_int64(gdv_int64 context, gdv_boolean value,\n }\n \n // Truncates the string to given length\n-FORCE_INLINE\n-const char* castVARCHAR_utf8_int64(gdv_int64 context, const char* data,\n-                                   gdv_int32 data_len, int64_t out_len,\n-                                   int32_t* out_length) {\n-  int32_t len = static_cast<int32_t>(out_len);\n-\n-  if (len < 0) {\n-    gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\");\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  if (len >= data_len || len == 0) {\n-    *out_length = data_len;\n-    return data;\n-  }\n-\n-  int32_t remaining = len;\n-  int32_t index = 0;\n-  bool is_multibyte = false;\n-  do {\n-    // In utf8, MSB of a single byte unicode char is always 0,\n-    // whereas for a multibyte character the MSB of each byte is 1.\n-    // So for a single byte char, a bitwise-and with x80 (10000000) will be 0\n-    // and it won't be 0 for bytes of a multibyte char\n-    char* data_ptr = const_cast<char*>(data);\n-\n-    // we advance byte by byte till the 8 byte boundary then advance 8 bytes at a time\n-    auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;\n-    num_bytes = (8 - num_bytes) & 0x07;\n-    while (num_bytes > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-      num_bytes--;\n-    }\n-    if (is_multibyte) break;\n-    while (remaining >= 8) {\n-      uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);\n-      if ((*ptr & 0x8080808080808080) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index += 8;\n-      remaining -= 8;\n-    }\n-    if (is_multibyte) break;\n-    if (remaining >= 4) {\n-      uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);\n-      if ((*ptr & 0x80808080) != 0) break;\n-      index += 4;\n-      remaining -= 4;\n-    }\n-    while (remaining > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-    }\n-    if (is_multibyte) break;\n-    // reached here; all are single byte characters\n-    *out_length = len;\n-    return data;\n-  } while (false);\n-\n-  // detected multibyte utf8 characters; slow path\n-  int32_t byte_pos = utf8_byte_pos(context, data + index, data_len - index, len - index);\n-  if (byte_pos < 0) {\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  *out_length = index + byte_pos;\n-  return data;\n-}\n+#define CAST_VARCHAR_UTF8_BINARY(TYPE)                                                 \\\n+  FORCE_INLINE                                                                         \\\n+  const char* castVARCHAR_##TYPE##_int64(gdv_int64 context, const char* data,          \\\n+                                         gdv_int32 data_len, int64_t out_len,          \\\n+                                         int32_t* out_length) {                        \\\n+    int32_t len = static_cast<int32_t>(out_len);                                       \\\n+                                                                                       \\\n+    if (len < 0) {                                                                     \\\n+      gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\"); \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    if (len >= data_len || len == 0) {                                                 \\\n+      *out_length = data_len;                                                          \\\n+      return data;                                                                     \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    int32_t remaining = len;                                                           \\\n+    int32_t index = 0;                                                                 \\\n+    bool is_multibyte = false;                                                         \\\n+    do {                                                                               \\\n+      /* In utf8, MSB of a single byte unicode char is always 0,                       \\\n+       * whereas for a multibyte character the MSB of each byte is 1.                  \\\n+       * So for a single byte char, a bitwise-and with x80 (10000000) will be 0        \\\n+       * and it won't be 0 for bytes of a multibyte char.                              \\\n+       */                                                                              \\\n+      char* data_ptr = const_cast<char*>(data);                                        \\\n+                                                                                       \\\n+      /* advance byte by byte till the 8-byte boundary then advance 8 bytes */         \\\n+      auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;                   \\\n+      num_bytes = (8 - num_bytes) & 0x07;                                              \\\n+      while (num_bytes > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+        num_bytes--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      while (remaining >= 8) {                                                         \\\n+        uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x8080808080808080) != 0) {                                        \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index += 8;                                                                    \\\n+        remaining -= 8;                                                                \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      if (remaining >= 4) {                                                            \\\n+        uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x80808080) != 0) break;                                           \\\n+        index += 4;                                                                    \\\n+        remaining -= 4;                                                                \\\n+      }                                                                                \\\n+      while (remaining > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      /* reached here; all are single byte characters */                               \\\n+      *out_length = len;                                                               \\\n+      return data;                                                                     \\\n+    } while (false);                                                                   \\\n+                                                                                       \\\n+    /* detected multibyte utf8 characters; slow path */                                \\\n+    int32_t byte_pos =                                                                 \\\n+        utf8_byte_pos(context, data + index, data_len - index, len - index);           \\\n+    if (byte_pos < 0) {                                                                \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    *out_length = index + byte_pos;                                                    \\\n+    return data;                                                                       \\\n+  }\n+\n+CAST_VARCHAR_UTF8_BINARY(utf8)\n\nReview comment:\n       These macro names looks confusing. Can you name the macro CAST_VARCHAR_FROM_VARLEN_TYPES(TYPE)\n\n##########\nFile path: cpp/src/gandiva/precompiled/string_ops.cc\n##########\n@@ -534,88 +534,96 @@ const char* castVARCHAR_bool_int64(gdv_int64 context, gdv_boolean value,\n }\n \n // Truncates the string to given length\n-FORCE_INLINE\n-const char* castVARCHAR_utf8_int64(gdv_int64 context, const char* data,\n-                                   gdv_int32 data_len, int64_t out_len,\n-                                   int32_t* out_length) {\n-  int32_t len = static_cast<int32_t>(out_len);\n-\n-  if (len < 0) {\n-    gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\");\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  if (len >= data_len || len == 0) {\n-    *out_length = data_len;\n-    return data;\n-  }\n-\n-  int32_t remaining = len;\n-  int32_t index = 0;\n-  bool is_multibyte = false;\n-  do {\n-    // In utf8, MSB of a single byte unicode char is always 0,\n-    // whereas for a multibyte character the MSB of each byte is 1.\n-    // So for a single byte char, a bitwise-and with x80 (10000000) will be 0\n-    // and it won't be 0 for bytes of a multibyte char\n-    char* data_ptr = const_cast<char*>(data);\n-\n-    // we advance byte by byte till the 8 byte boundary then advance 8 bytes at a time\n-    auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;\n-    num_bytes = (8 - num_bytes) & 0x07;\n-    while (num_bytes > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-      num_bytes--;\n-    }\n-    if (is_multibyte) break;\n-    while (remaining >= 8) {\n-      uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);\n-      if ((*ptr & 0x8080808080808080) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index += 8;\n-      remaining -= 8;\n-    }\n-    if (is_multibyte) break;\n-    if (remaining >= 4) {\n-      uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);\n-      if ((*ptr & 0x80808080) != 0) break;\n-      index += 4;\n-      remaining -= 4;\n-    }\n-    while (remaining > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-    }\n-    if (is_multibyte) break;\n-    // reached here; all are single byte characters\n-    *out_length = len;\n-    return data;\n-  } while (false);\n-\n-  // detected multibyte utf8 characters; slow path\n-  int32_t byte_pos = utf8_byte_pos(context, data + index, data_len - index, len - index);\n-  if (byte_pos < 0) {\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  *out_length = index + byte_pos;\n-  return data;\n-}\n+#define CAST_VARCHAR_UTF8_BINARY(TYPE)                                                 \\\n+  FORCE_INLINE                                                                         \\\n+  const char* castVARCHAR_##TYPE##_int64(gdv_int64 context, const char* data,          \\\n+                                         gdv_int32 data_len, int64_t out_len,          \\\n+                                         int32_t* out_length) {                        \\\n+    int32_t len = static_cast<int32_t>(out_len);                                       \\\n+                                                                                       \\\n+    if (len < 0) {                                                                     \\\n+      gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\"); \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    if (len >= data_len || len == 0) {                                                 \\\n+      *out_length = data_len;                                                          \\\n+      return data;                                                                     \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    int32_t remaining = len;                                                           \\\n+    int32_t index = 0;                                                                 \\\n+    bool is_multibyte = false;                                                         \\\n+    do {                                                                               \\\n+      /* In utf8, MSB of a single byte unicode char is always 0,                       \\\n+       * whereas for a multibyte character the MSB of each byte is 1.                  \\\n+       * So for a single byte char, a bitwise-and with x80 (10000000) will be 0        \\\n+       * and it won't be 0 for bytes of a multibyte char.                              \\\n+       */                                                                              \\\n+      char* data_ptr = const_cast<char*>(data);                                        \\\n+                                                                                       \\\n+      /* advance byte by byte till the 8-byte boundary then advance 8 bytes */         \\\n+      auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;                   \\\n+      num_bytes = (8 - num_bytes) & 0x07;                                              \\\n+      while (num_bytes > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+        num_bytes--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      while (remaining >= 8) {                                                         \\\n+        uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x8080808080808080) != 0) {                                        \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index += 8;                                                                    \\\n+        remaining -= 8;                                                                \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      if (remaining >= 4) {                                                            \\\n+        uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x80808080) != 0) break;                                           \\\n+        index += 4;                                                                    \\\n+        remaining -= 4;                                                                \\\n+      }                                                                                \\\n+      while (remaining > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      /* reached here; all are single byte characters */                               \\\n+      *out_length = len;                                                               \\\n+      return data;                                                                     \\\n+    } while (false);                                                                   \\\n+                                                                                       \\\n+    /* detected multibyte utf8 characters; slow path */                                \\\n+    int32_t byte_pos =                                                                 \\\n+        utf8_byte_pos(context, data + index, data_len - index, len - index);           \\\n+    if (byte_pos < 0) {                                                                \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    *out_length = index + byte_pos;                                                    \\\n+    return data;                                                                       \\\n+  }\n+\n+CAST_VARCHAR_UTF8_BINARY(utf8)\n\nReview comment:\n       These macro names looks confusing. Can you name the macro CAST_VARCHAR_FROM_VARLEN_TYPE(TYPE)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-30T05:48:37.622+0000",
                    "updated": "2021-04-30T05:48:37.622+0000",
                    "started": "2021-04-30T05:48:37.622+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "591373",
                    "issueId": "13373424"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13373424/worklog/591433",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jpedroantunes commented on a change in pull request #10095:\nURL: https://github.com/apache/arrow/pull/10095#discussion_r623773567\n\n\n\n##########\nFile path: cpp/src/gandiva/precompiled/string_ops.cc\n##########\n@@ -534,88 +534,96 @@ const char* castVARCHAR_bool_int64(gdv_int64 context, gdv_boolean value,\n }\n \n // Truncates the string to given length\n-FORCE_INLINE\n-const char* castVARCHAR_utf8_int64(gdv_int64 context, const char* data,\n-                                   gdv_int32 data_len, int64_t out_len,\n-                                   int32_t* out_length) {\n-  int32_t len = static_cast<int32_t>(out_len);\n-\n-  if (len < 0) {\n-    gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\");\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  if (len >= data_len || len == 0) {\n-    *out_length = data_len;\n-    return data;\n-  }\n-\n-  int32_t remaining = len;\n-  int32_t index = 0;\n-  bool is_multibyte = false;\n-  do {\n-    // In utf8, MSB of a single byte unicode char is always 0,\n-    // whereas for a multibyte character the MSB of each byte is 1.\n-    // So for a single byte char, a bitwise-and with x80 (10000000) will be 0\n-    // and it won't be 0 for bytes of a multibyte char\n-    char* data_ptr = const_cast<char*>(data);\n-\n-    // we advance byte by byte till the 8 byte boundary then advance 8 bytes at a time\n-    auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;\n-    num_bytes = (8 - num_bytes) & 0x07;\n-    while (num_bytes > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-      num_bytes--;\n-    }\n-    if (is_multibyte) break;\n-    while (remaining >= 8) {\n-      uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);\n-      if ((*ptr & 0x8080808080808080) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index += 8;\n-      remaining -= 8;\n-    }\n-    if (is_multibyte) break;\n-    if (remaining >= 4) {\n-      uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);\n-      if ((*ptr & 0x80808080) != 0) break;\n-      index += 4;\n-      remaining -= 4;\n-    }\n-    while (remaining > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-    }\n-    if (is_multibyte) break;\n-    // reached here; all are single byte characters\n-    *out_length = len;\n-    return data;\n-  } while (false);\n-\n-  // detected multibyte utf8 characters; slow path\n-  int32_t byte_pos = utf8_byte_pos(context, data + index, data_len - index, len - index);\n-  if (byte_pos < 0) {\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  *out_length = index + byte_pos;\n-  return data;\n-}\n+#define CAST_VARCHAR_UTF8_BINARY(TYPE)                                                 \\\n+  FORCE_INLINE                                                                         \\\n+  const char* castVARCHAR_##TYPE##_int64(gdv_int64 context, const char* data,          \\\n+                                         gdv_int32 data_len, int64_t out_len,          \\\n+                                         int32_t* out_length) {                        \\\n+    int32_t len = static_cast<int32_t>(out_len);                                       \\\n+                                                                                       \\\n+    if (len < 0) {                                                                     \\\n+      gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\"); \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    if (len >= data_len || len == 0) {                                                 \\\n+      *out_length = data_len;                                                          \\\n+      return data;                                                                     \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    int32_t remaining = len;                                                           \\\n+    int32_t index = 0;                                                                 \\\n+    bool is_multibyte = false;                                                         \\\n+    do {                                                                               \\\n+      /* In utf8, MSB of a single byte unicode char is always 0,                       \\\n+       * whereas for a multibyte character the MSB of each byte is 1.                  \\\n+       * So for a single byte char, a bitwise-and with x80 (10000000) will be 0        \\\n+       * and it won't be 0 for bytes of a multibyte char.                              \\\n+       */                                                                              \\\n+      char* data_ptr = const_cast<char*>(data);                                        \\\n+                                                                                       \\\n+      /* advance byte by byte till the 8-byte boundary then advance 8 bytes */         \\\n+      auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;                   \\\n+      num_bytes = (8 - num_bytes) & 0x07;                                              \\\n+      while (num_bytes > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+        num_bytes--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      while (remaining >= 8) {                                                         \\\n+        uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x8080808080808080) != 0) {                                        \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index += 8;                                                                    \\\n+        remaining -= 8;                                                                \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      if (remaining >= 4) {                                                            \\\n+        uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x80808080) != 0) break;                                           \\\n+        index += 4;                                                                    \\\n+        remaining -= 4;                                                                \\\n+      }                                                                                \\\n+      while (remaining > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      /* reached here; all are single byte characters */                               \\\n+      *out_length = len;                                                               \\\n+      return data;                                                                     \\\n+    } while (false);                                                                   \\\n+                                                                                       \\\n+    /* detected multibyte utf8 characters; slow path */                                \\\n+    int32_t byte_pos =                                                                 \\\n+        utf8_byte_pos(context, data + index, data_len - index, len - index);           \\\n+    if (byte_pos < 0) {                                                                \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    *out_length = index + byte_pos;                                                    \\\n+    return data;                                                                       \\\n+  }\n+\n+CAST_VARCHAR_UTF8_BINARY(utf8)\n\nReview comment:\n       Name changed!\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-30T10:22:26.352+0000",
                    "updated": "2021-04-30T10:22:26.352+0000",
                    "started": "2021-04-30T10:22:26.352+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "591433",
                    "issueId": "13373424"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13373424/worklog/599606",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "praveenbingo closed pull request #10095:\nURL: https://github.com/apache/arrow/pull/10095\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-20T04:58:39.536+0000",
                    "updated": "2021-05-20T04:58:39.536+0000",
                    "started": "2021-05-20T04:58:39.536+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "599606",
                    "issueId": "13373424"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 6600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@2b3bd8cd[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@eb0b046[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@653a20b5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@6e038ed4[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@65bbb16a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@66f46e8c[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@52ffc56f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@207884ca[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1870514e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@5db5dcc2[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@714dbea6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@15f73a91[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 6600,
        "customfield_12312520": null,
        "customfield_12312521": "Thu May 20 04:58:41 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-05-20T04:58:41.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12443/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-04-19T00:48:05.000+0000",
        "updated": "2021-05-20T04:58:41.000+0000",
        "timeoriginalestimate": null,
        "description": "Implement castVARCHAR function for binary input",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 6600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Gandiva] Implement castVARCHAR function for binary input",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13373424/comment/17348056",
                    "id": "17348056",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=praveenbingo",
                        "name": "praveenbingo",
                        "key": "praveenbingo",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Praveen Kumar",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Issue resolved by pull request 10095\n[https://github.com/apache/arrow/pull/10095]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=praveenbingo",
                        "name": "praveenbingo",
                        "key": "praveenbingo",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Praveen Kumar",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2021-05-20T04:58:41.241+0000",
                    "updated": "2021-05-20T04:58:41.241+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0q688:",
        "customfield_12314139": null
    }
}