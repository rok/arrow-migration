{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13308983",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983",
    "key": "ARROW-9017",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12347769",
                "id": "12347769",
                "description": "",
                "name": "1.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-07-24"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12592488",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12592488",
                "type": {
                    "id": "12310051",
                    "name": "Supercedes",
                    "inward": "is superceded by",
                    "outward": "supercedes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310051"
                },
                "outwardIssue": {
                    "id": "13312700",
                    "key": "ARROW-9194",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312700",
                    "fields": {
                        "summary": "[C++] Array::GetScalar not implemented for decimal type",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
                            "id": "1",
                            "description": "A problem which impairs or prevents the functions of the product.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
                            "name": "Bug",
                            "subtask": false,
                            "avatarId": 21133
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=kszucs",
            "name": "kszucs",
            "key": "kszucs",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Krisztian Szucs",
            "active": true,
            "timeZone": "Europe/Budapest"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328936",
                "id": "12328936",
                "name": "Python"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
            "name": "jorisvandenbossche",
            "key": "jorisvandenbossche",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Joris Van den Bossche",
            "active": true,
            "timeZone": "Europe/Brussels"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
            "name": "jorisvandenbossche",
            "key": "jorisvandenbossche",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Joris Van den Bossche",
            "active": true,
            "timeZone": "Europe/Brussels"
        },
        "aggregateprogress": {
            "progress": 37200,
            "total": 37200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 37200,
            "total": 37200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9017/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 62,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/451033",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#discussion_r445569265\n\n\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,704 @@\n # under the License.\n \n \n-_NULL = NA = None\n-\n-\n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n \n-        self.type = null()\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n \n     def __eq__(self, other):\n-        return NA\n+        # TODO(kszucs): use c++ Equals\n+        if isinstance(other, Scalar):\n+            other = other.as_py()\n+        return self.as_py() == other\n \n+    def __hash__(self):\n+        # TODO(kszucs): use C++ hash if implemented for the type\n+        return hash(self.as_py())\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n-_NULL = NA = NullType()\n+\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n-\n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __init__(self):\n+        pass\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __eq__(self, other):\n+        return NA\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n+\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class DecimalScalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n         else:\n             tzinfo = None\n \n-        try:\n-            converter = _datetime_conversion_functions()[dtype.unit()]\n-        except KeyError:\n-            raise ValueError(\n-                'Cannot convert nanosecond timestamps without pandas'\n-            )\n-        return converter(value, tzinfo=tzinfo)\n-\n-\n-cdef dict _TIMEDELTA_CONVERSION_FUNCTIONS = {}\n-\n-\n-def _nanoseconds_to_timedelta_safe(v):\n-    if v % 1000 != 0:\n-        raise ValueError(\n-            \"Nanosecond duration {} is not safely convertible to microseconds \"\n-            \"to convert to datetime.timedelta. Install pandas to return as \"\n-            \"Timedelta with nanosecond support or access the .value \"\n-            \"attribute.\".format(v))\n-    micros = v // 1000\n-\n-    return datetime.timedelta(microseconds=micros)\n-\n+        return _datetime_from_int(sp.value, unit=dtype.unit(), tzinfo=tzinfo)\n \n-def _timedelta_conversion_functions():\n-    if _TIMEDELTA_CONVERSION_FUNCTIONS:\n-        return _TIMEDELTA_CONVERSION_FUNCTIONS\n \n-    _TIMEDELTA_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: lambda v: datetime.timedelta(seconds=v),\n-        TimeUnit_MILLI: lambda v: datetime.timedelta(milliseconds=v),\n-        TimeUnit_MICRO: lambda v: datetime.timedelta(microseconds=v),\n-        TimeUnit_NANO: _nanoseconds_to_timedelta_safe\n-    })\n-\n-    try:\n-        import pandas as pd\n-        _TIMEDELTA_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda v: pd.Timedelta(v, unit='ns')\n-        )\n-    except ImportError:\n-        pass\n-\n-    return _TIMEDELTA_CONVERSION_FUNCTIONS\n-\n-\n-cdef class DurationValue(ArrayValue):\n+cdef class DurationScalar(Scalar):\n     \"\"\"\n-    Concrete class for duration array elements.\n+    Concrete class for duration scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        cdef CDurationType* dtype = <CDurationType*> ap.type().get()\n-\n-        cdef int64_t value = ap.Value(self.index)\n-        converter = _timedelta_conversion_functions()[dtype.unit()]\n-        return converter(value)\n-\n+        cdef:\n+            CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+            CDurationType* dtype = <CDurationType*> sp.type.get()\n+            TimeUnit unit = dtype.unit()\n \n-cdef class HalfFloatValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float16 array elements.\n-    \"\"\"\n+        if not sp.is_valid:\n+            return None\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python float.\n-        \"\"\"\n-        cdef CHalfFloatArray* ap = <CHalfFloatArray*> self.sp_array.get()\n-        return PyHalf_FromHalf(ap.Value(self.index))\n+        if unit == TimeUnit_SECOND:\n+            return datetime.timedelta(seconds=sp.value)\n+        elif unit == TimeUnit_MILLI:\n+            return datetime.timedelta(milliseconds=sp.value)\n+        elif unit == TimeUnit_MICRO:\n+            return datetime.timedelta(microseconds=sp.value)\n+        else:\n+            # TimeUnit_NANO: prefer pandas timestamps if available\n+            if _pandas_api.have_pandas:\n+                return _pandas_api.pd.Timedelta(sp.value, unit='ns')\n+            # otherwise safely truncate to microsecond resolution timedelta\n+            if sp.value % 1000 != 0:\n+                raise ValueError(\n+                    \"Nanosecond duration {} is not safely convertible to \"\n+                    \"microseconds to convert to datetime.timedelta. Install \"\n+                    \"pandas to return as Timedelta with nanosecond support or \"\n+                    \"access the .value attribute.\".format(sp.value)\n+                )\n+            return datetime.timedelta(microseconds=sp.value // 1000)\n \n \n-cdef class FloatValue(ArrayValue):\n+cdef class BinaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for float32 array elements.\n+    Concrete class for binary-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def as_buffer(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return a view over this value as a Buffer object.\n         \"\"\"\n-        cdef CFloatArray* ap = <CFloatArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n-\n-\n-cdef class DoubleValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float64 array elements.\n-    \"\"\"\n+        cdef CBinaryScalar* sp = <CBinaryScalar*> self.wrapped.get()\n+        return pyarrow_wrap_buffer(sp.value) if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value as a Python bytes.\n         \"\"\"\n-        cdef CDoubleArray* ap = <CDoubleArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return self.as_buffer().to_pybytes()\n+        else:\n+            return None\n \n \n-cdef class DecimalValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for decimal128 array elements.\n-    \"\"\"\n+cdef class LargeBinaryScalar(BinaryScalar):\n+    pass\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python Decimal.\n-        \"\"\"\n-        cdef:\n-            CDecimal128Array* ap = <CDecimal128Array*> self.sp_array.get()\n-            c_string s = ap.FormatValue(self.index)\n-        return _pydecimal.Decimal(s.decode('utf8'))\n \n+cdef class FixedSizeBinaryScalar(BinaryScalar):\n+    pass\n \n-cdef class StringValue(ArrayValue):\n+\n+cdef class StringScalar(BinaryScalar):\n     \"\"\"\n-    Concrete class for string (utf8) array elements.\n+    Concrete class for string-like (utf8) scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Return this value as a Python string.\n         \"\"\"\n-        cdef CStringArray* ap = <CStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return frombytes(self.as_buffer().to_pybytes())\n+        else:\n+            return None\n \n-    def as_buffer(self):\n-        \"\"\"\n-        Return a view over this value as a Buffer object.\n-        \"\"\"\n-        cdef:\n-            CStringArray* ap = <CStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+cdef class LargeStringScalar(StringScalar):\n+    pass\n \n \n-cdef class LargeStringValue(ArrayValue):\n+cdef class ListScalar(Scalar):\n     \"\"\"\n-    Concrete class for large string (utf8) array elements.\n+    Concrete class for list-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    cdef array(self):\n+        cdef CListScalar* sp = <CListScalar*> self.wrapped.get()\n+        if sp.is_valid:\n+            return pyarrow_wrap_array(sp.value)\n+        else:\n+            return None\n+\n+    def __len__(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Return the number of values.\n         \"\"\"\n-        cdef CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        return len(self.array())\n \n-    def as_buffer(self):\n+    def __getitem__(self, i):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return the value at the given index.\n         \"\"\"\n-        cdef:\n-            CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n-\n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+        return self.array()[_normalize_index(i, len(self))]\n \n-\n-cdef class BinaryValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for variable-sized binary array elements.\n-    \"\"\"\n+    def __iter__(self):\n+        \"\"\"\n+        Iterate over this element's values.\n+        \"\"\"\n+        return iter(self.array())\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python bytes object.\n+        Return this value as a Python list.\n         \"\"\"\n-        cdef:\n-            const uint8_t* ptr\n-            int32_t length\n-            CBinaryArray* ap = <CBinaryArray*> self.sp_array.get()\n+        arr = self.array()\n+        return None if arr is None else arr.to_pylist()\n \n-        ptr = ap.GetValue(self.index, &length)\n-        return cp.PyBytes_FromStringAndSize(<const char*>(ptr), length)\n \n-    def as_buffer(self):\n-        \"\"\"\n-        Return a view over this value as a Buffer object.\n-        \"\"\"\n-        cdef:\n-            CBinaryArray* ap = <CBinaryArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+cdef class FixedSizeListScalar(ListScalar):\n+    pass\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n \n+cdef class LargeListScalar(ListScalar):\n+    pass\n \n-cdef class LargeBinaryValue(ArrayValue):\n+\n+cdef class StructScalar(Scalar):\n     \"\"\"\n-    Concrete class for large variable-sized binary array elements.\n+    Concrete class for struct scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def __len__(self):\n+        cdef CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+        return sp.value.size()\n+\n+    def __getitem__(self, key):\n         \"\"\"\n-        Return this value as a Python bytes object.\n+        Return the child value for the given field.\n+\n+        Parameters\n+        ----------\n+        index : Union[int, str]\n+            Index / position or name of the field.\n+\n+        Returns\n+        -------\n+        result : Scalar\n         \"\"\"\n         cdef:\n-            const uint8_t* ptr\n-            int64_t length\n-            CLargeBinaryArray* ap = <CLargeBinaryArray*> self.sp_array.get()\n+            CFieldRef ref\n+            CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+\n+        if isinstance(key, (bytes, str)):\n+            ref = CFieldRef(<c_string> tobytes(key))\n+        elif isinstance(key, int):\n+            ref = CFieldRef(<int> key)\n+        else:\n+            raise TypeError('Expected integer or string index')\n \n-        ptr = ap.GetValue(self.index, &length)\n-        return cp.PyBytes_FromStringAndSize(<const char*>(ptr), length)\n+        try:\n+            return Scalar.wrap(GetResultValue(sp.field(ref)))\n+        except ArrowInvalid:\n+            raise IndexError(key)\n \n-    def as_buffer(self):\n+    def as_py(self):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return this value as a Python dict.\n         \"\"\"\n         cdef:\n-            CLargeBinaryArray* ap = <CLargeBinaryArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+            CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+            CStructType* dtype = <CStructType*> sp.type.get()\n+            vector[shared_ptr[CField]] fields = dtype.fields()\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+        if sp.is_valid:\n+            return {frombytes(fields[i].get().name()): Scalar.wrap(sp.value[i])\n\nReview comment:\n       This is also what we seem to do on master\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-25T13:45:04.172+0000",
                    "updated": "2020-06-25T13:45:04.172+0000",
                    "started": "2020-06-25T13:45:04.172+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "451033",
                    "issueId": "13308983"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/451036",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#issuecomment-649551591\n\n\n   https://issues.apache.org/jira/browse/ARROW-9017\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-25T13:47:04.374+0000",
                    "updated": "2020-06-25T13:47:04.374+0000",
                    "started": "2020-06-25T13:47:04.374+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "451036",
                    "issueId": "13308983"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/451077",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#discussion_r445603562\n\n\n\n##########\nFile path: python/pyarrow/util.py\n##########\n@@ -41,6 +41,24 @@ def wrapper(*args, **kwargs):\n     return wrapper\n \n \n+def _deprecate_class(old_name, new_class, next_version,\n+                     instancecheck=True):\n+    \"\"\"\n+    Raise warning if a deprecated class is used in an isinstance check.\n\nReview comment:\n       > Really nice!\r\n   > \r\n   > Could we add a `is_valid` attribute to the python scalar as well? Now the only way to check for a null value is to do `.as_py() is None` ?\r\n   Definitely!\r\n   > \r\n   > Might not be related to the changes in this PR, but reviewing this triggered me to test scalar casting:\r\n   > \r\n   > ```\r\n   > In [2]: s = pa.scalar(pd.Timestamp(\"2012-01-01\")) \r\n   >    ...:  \r\n   >    ...: import pyarrow.compute as pc \r\n   >    ...: pc.cast(s, pa.timestamp('ns'))  \r\n   > ../src/arrow/compute/kernels/scalar_cast_temporal.cc:130:  Check failed: (batch[0].kind()) == (Datum::ARRAY) \r\n   > ...\r\n   > Aborted (core dumped)\r\n   > ```\r\n   I think the cast kernel doesn't support scalars yet, on the other hand the scalars have custom `CastTo` implementation which we may want to remove in favor of `compute.Cast`?\r\n   \r\n   cc @bkietz \r\n   \r\n   \n\n##########\nFile path: python/pyarrow/util.py\n##########\n@@ -41,6 +41,24 @@ def wrapper(*args, **kwargs):\n     return wrapper\n \n \n+def _deprecate_class(old_name, new_class, next_version,\n+                     instancecheck=True):\n+    \"\"\"\n+    Raise warning if a deprecated class is used in an isinstance check.\n\nReview comment:\n       > Really nice!\r\n   > \r\n   > Could we add a `is_valid` attribute to the python scalar as well? Now the only way to check for a null value is to do `.as_py() is None` ?\r\n   \r\n   Definitely!\r\n   \r\n   > \r\n   > Might not be related to the changes in this PR, but reviewing this triggered me to test scalar casting:\r\n   > \r\n   > ```\r\n   > In [2]: s = pa.scalar(pd.Timestamp(\"2012-01-01\")) \r\n   >    ...:  \r\n   >    ...: import pyarrow.compute as pc \r\n   >    ...: pc.cast(s, pa.timestamp('ns'))  \r\n   > ../src/arrow/compute/kernels/scalar_cast_temporal.cc:130:  Check failed: (batch[0].kind()) == (Datum::ARRAY) \r\n   > ...\r\n   > Aborted (core dumped)\r\n   > ```\r\n   I think the cast kernel doesn't support scalars yet, on the other hand the scalars have custom `CastTo` implementation which we may want to remove in favor of `compute.Cast`?\r\n   \r\n   cc @bkietz \r\n   \r\n   \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-25T14:31:55.549+0000",
                    "updated": "2020-06-25T14:31:55.549+0000",
                    "started": "2020-06-25T14:31:55.549+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "451077",
                    "issueId": "13308983"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/451080",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#discussion_r445604627\n\n\n\n##########\nFile path: python/pyarrow/tests/test_scalars.py\n##########\n@@ -17,426 +17,395 @@\n \n import datetime\n import pytest\n-import unittest\n \n import numpy as np\n \n import pyarrow as pa\n \n \n-class TestScalars(unittest.TestCase):\n-\n-    def test_null_singleton(self):\n-        with pytest.raises(Exception):\n-            pa.NAType()\n+@pytest.mark.parametrize(['value', 'ty', 'klass', 'deprecated'], [\n+    (None, None, pa.NullScalar, pa.NullType),\n+    (False, None, pa.BooleanScalar, pa.BooleanValue),\n+    (True, None, pa.BooleanScalar, pa.BooleanValue),\n+    (1, None, pa.Int64Scalar, pa.Int64Value),\n+    (-1, None, pa.Int64Scalar, pa.Int64Value),\n+    (1, pa.int8(), pa.Int8Scalar, pa.Int8Value),\n+    (1, pa.uint8(), pa.UInt8Scalar, pa.UInt8Value),\n+    (1, pa.int16(), pa.Int16Scalar, pa.Int16Value),\n+    (1, pa.uint16(), pa.UInt16Scalar, pa.UInt16Value),\n+    (1, pa.int32(), pa.Int32Scalar, pa.Int32Value),\n+    (1, pa.uint32(), pa.UInt32Scalar, pa.UInt32Value),\n+    (1, pa.int64(), pa.Int64Scalar, pa.Int64Value),\n+    (1, pa.uint64(), pa.UInt64Scalar, pa.UInt64Value),\n+    (1.0, None, pa.DoubleScalar, pa.DoubleValue),\n+    (np.float16(1.0), pa.float16(), pa.HalfFloatScalar, pa.HalfFloatValue),\n+    (1.0, pa.float32(), pa.FloatScalar, pa.FloatValue),\n+    (\"string\", None, pa.StringScalar, pa.StringValue),\n+    (b\"bytes\", None, pa.BinaryScalar, pa.BinaryValue),\n+    ([1, 2, 3], None, pa.ListScalar, pa.ListValue),\n+    ([1, 2, 3, 4], pa.large_list(pa.int8()), pa.LargeListScalar,\n+     pa.LargeListValue),\n+    # date\n+    # time\n+])\n+def test_type_inference(value, ty, klass, deprecated):\n+    s = pa.scalar(value, type=ty)\n+    assert isinstance(s, klass)\n+    assert s == value\n+    with pytest.warns(FutureWarning):\n+        isinstance(s, deprecated)\n+\n+\n+def test_null_singleton():\n+    with pytest.raises(Exception):\n+        pa.NullScalar()\n+\n+\n+def test_nulls():\n+    arr = pa.array([None, None])\n+    for v in arr:\n+        assert v is pa.NA\n+        assert v.as_py() is None\n+\n+\n+def test_null_equality():\n+    assert (pa.NA == pa.NA) is pa.NA\n+    assert (pa.NA == 1) is pa.NA\n\nReview comment:\n       Great question, I assume it should follow the same semantics as `Null` does.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-25T14:33:14.337+0000",
                    "updated": "2020-06-25T14:33:14.337+0000",
                    "started": "2020-06-25T14:33:14.337+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "451080",
                    "issueId": "13308983"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/451084",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#issuecomment-649590873\n\n\n   > Really nice!\r\n   > \r\n   > Could we add a `is_valid` attribute to the python scalar as well? Now the only way to check for a null value is to do `.as_py() is None` ?\r\n   \r\n   Definitely!\r\n   \r\n   > \r\n   > Might not be related to the changes in this PR, but reviewing this triggered me to test scalar casting:\r\n   > \r\n   > ```\r\n   > In [2]: s = pa.scalar(pd.Timestamp(\"2012-01-01\")) \r\n   >    ...:  \r\n   >    ...: import pyarrow.compute as pc \r\n   >    ...: pc.cast(s, pa.timestamp('ns'))  \r\n   > ../src/arrow/compute/kernels/scalar_cast_temporal.cc:130:  Check failed: (batch[0].kind()) == (Datum::ARRAY) \r\n   > ...\r\n   > Aborted (core dumped)\r\n   > ```\r\n   I think the cast kernel doesn't support scalars yet, on the other hand the scalars have custom `CastTo` implementation which we may want to remove in favor of `compute.Cast`?\r\n   \r\n   cc @bkietz \r\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-25T14:38:04.395+0000",
                    "updated": "2020-06-25T14:38:04.395+0000",
                    "started": "2020-06-25T14:38:04.395+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "451084",
                    "issueId": "13308983"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/451085",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#discussion_r445603562\n\n\n\n##########\nFile path: python/pyarrow/util.py\n##########\n@@ -41,6 +41,24 @@ def wrapper(*args, **kwargs):\n     return wrapper\n \n \n+def _deprecate_class(old_name, new_class, next_version,\n+                     instancecheck=True):\n+    \"\"\"\n+    Raise warning if a deprecated class is used in an isinstance check.\n\nReview comment:\n       The deprecated classes cannot be instantiated, so we don't need to worry about it for now - although we can add support for overriding `__init__` for later reuse.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-25T14:38:07.359+0000",
                    "updated": "2020-06-25T14:38:07.359+0000",
                    "started": "2020-06-25T14:38:07.358+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "451085",
                    "issueId": "13308983"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/451530",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#discussion_r446147913\n\n\n\n##########\nFile path: python/pyarrow/_dataset.pyx\n##########\n@@ -216,22 +216,18 @@ cdef class Expression:\n     @staticmethod\n     def _scalar(value):\n         cdef:\n-            shared_ptr[CScalar] scalar\n-\n-        if value is None:\n-            scalar.reset(new CNullScalar())\n-        elif isinstance(value, bool):\n-            scalar = MakeScalar(<c_bool>value)\n-        elif isinstance(value, float):\n-            scalar = MakeScalar(<double>value)\n-        elif isinstance(value, int):\n-            scalar = MakeScalar(<int64_t>value)\n-        elif isinstance(value, (bytes, str)):\n-            scalar = MakeStringScalar(tobytes(value))\n\nReview comment:\n       Removed it.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-26T12:17:37.626+0000",
                    "updated": "2020-06-26T12:17:37.626+0000",
                    "started": "2020-06-26T12:17:37.626+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "451530",
                    "issueId": "13308983"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/451531",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#discussion_r446148105\n\n\n\n##########\nFile path: python/pyarrow/tests/test_parquet.py\n##########\n@@ -2028,7 +2028,7 @@ def test_filters_invalid_pred_op(tempdir, use_legacy_dataset):\n                                     use_legacy_dataset=use_legacy_dataset)\n         assert dataset.read().num_rows == 0\n \n-    with pytest.raises(ValueError if use_legacy_dataset else TypeError):\n+    with pytest.raises(ValueError if use_legacy_dataset else pa.ArrowInvalid):\n         # dataset API returns TypeError when trying create invalid comparison\n\nReview comment:\n       Nice, updated.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-26T12:18:02.522+0000",
                    "updated": "2020-06-26T12:18:02.522+0000",
                    "started": "2020-06-26T12:18:02.522+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "451531",
                    "issueId": "13308983"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/451535",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#discussion_r446148546\n\n\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,704 @@\n # under the License.\n \n \n-_NULL = NA = None\n-\n-\n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n \n-        self.type = null()\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n \n     def __eq__(self, other):\n-        return NA\n+        # TODO(kszucs): use c++ Equals\n+        if isinstance(other, Scalar):\n+            other = other.as_py()\n+        return self.as_py() == other\n \n+    def __hash__(self):\n+        # TODO(kszucs): use C++ hash if implemented for the type\n+        return hash(self.as_py())\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n-_NULL = NA = NullType()\n+\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n-\n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __init__(self):\n+        pass\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __eq__(self, other):\n+        return NA\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n+\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class DecimalScalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n         else:\n             tzinfo = None\n \n-        try:\n-            converter = _datetime_conversion_functions()[dtype.unit()]\n-        except KeyError:\n-            raise ValueError(\n-                'Cannot convert nanosecond timestamps without pandas'\n-            )\n-        return converter(value, tzinfo=tzinfo)\n-\n-\n-cdef dict _TIMEDELTA_CONVERSION_FUNCTIONS = {}\n-\n-\n-def _nanoseconds_to_timedelta_safe(v):\n-    if v % 1000 != 0:\n-        raise ValueError(\n-            \"Nanosecond duration {} is not safely convertible to microseconds \"\n-            \"to convert to datetime.timedelta. Install pandas to return as \"\n-            \"Timedelta with nanosecond support or access the .value \"\n-            \"attribute.\".format(v))\n-    micros = v // 1000\n-\n-    return datetime.timedelta(microseconds=micros)\n-\n+        return _datetime_from_int(sp.value, unit=dtype.unit(), tzinfo=tzinfo)\n \n-def _timedelta_conversion_functions():\n-    if _TIMEDELTA_CONVERSION_FUNCTIONS:\n-        return _TIMEDELTA_CONVERSION_FUNCTIONS\n \n-    _TIMEDELTA_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: lambda v: datetime.timedelta(seconds=v),\n-        TimeUnit_MILLI: lambda v: datetime.timedelta(milliseconds=v),\n-        TimeUnit_MICRO: lambda v: datetime.timedelta(microseconds=v),\n-        TimeUnit_NANO: _nanoseconds_to_timedelta_safe\n-    })\n-\n-    try:\n-        import pandas as pd\n-        _TIMEDELTA_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda v: pd.Timedelta(v, unit='ns')\n-        )\n-    except ImportError:\n-        pass\n-\n-    return _TIMEDELTA_CONVERSION_FUNCTIONS\n-\n-\n-cdef class DurationValue(ArrayValue):\n+cdef class DurationScalar(Scalar):\n     \"\"\"\n-    Concrete class for duration array elements.\n+    Concrete class for duration scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        cdef CDurationType* dtype = <CDurationType*> ap.type().get()\n-\n-        cdef int64_t value = ap.Value(self.index)\n-        converter = _timedelta_conversion_functions()[dtype.unit()]\n-        return converter(value)\n-\n+        cdef:\n+            CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+            CDurationType* dtype = <CDurationType*> sp.type.get()\n+            TimeUnit unit = dtype.unit()\n \n-cdef class HalfFloatValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float16 array elements.\n-    \"\"\"\n+        if not sp.is_valid:\n+            return None\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python float.\n-        \"\"\"\n-        cdef CHalfFloatArray* ap = <CHalfFloatArray*> self.sp_array.get()\n-        return PyHalf_FromHalf(ap.Value(self.index))\n+        if unit == TimeUnit_SECOND:\n+            return datetime.timedelta(seconds=sp.value)\n+        elif unit == TimeUnit_MILLI:\n+            return datetime.timedelta(milliseconds=sp.value)\n+        elif unit == TimeUnit_MICRO:\n+            return datetime.timedelta(microseconds=sp.value)\n+        else:\n+            # TimeUnit_NANO: prefer pandas timestamps if available\n+            if _pandas_api.have_pandas:\n+                return _pandas_api.pd.Timedelta(sp.value, unit='ns')\n+            # otherwise safely truncate to microsecond resolution timedelta\n+            if sp.value % 1000 != 0:\n+                raise ValueError(\n+                    \"Nanosecond duration {} is not safely convertible to \"\n+                    \"microseconds to convert to datetime.timedelta. Install \"\n+                    \"pandas to return as Timedelta with nanosecond support or \"\n+                    \"access the .value attribute.\".format(sp.value)\n+                )\n+            return datetime.timedelta(microseconds=sp.value // 1000)\n \n \n-cdef class FloatValue(ArrayValue):\n+cdef class BinaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for float32 array elements.\n+    Concrete class for binary-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def as_buffer(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return a view over this value as a Buffer object.\n         \"\"\"\n-        cdef CFloatArray* ap = <CFloatArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n-\n-\n-cdef class DoubleValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float64 array elements.\n-    \"\"\"\n+        cdef CBinaryScalar* sp = <CBinaryScalar*> self.wrapped.get()\n+        return pyarrow_wrap_buffer(sp.value) if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value as a Python bytes.\n         \"\"\"\n-        cdef CDoubleArray* ap = <CDoubleArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return self.as_buffer().to_pybytes()\n+        else:\n+            return None\n \n \n-cdef class DecimalValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for decimal128 array elements.\n-    \"\"\"\n+cdef class LargeBinaryScalar(BinaryScalar):\n+    pass\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python Decimal.\n-        \"\"\"\n-        cdef:\n-            CDecimal128Array* ap = <CDecimal128Array*> self.sp_array.get()\n-            c_string s = ap.FormatValue(self.index)\n-        return _pydecimal.Decimal(s.decode('utf8'))\n \n+cdef class FixedSizeBinaryScalar(BinaryScalar):\n+    pass\n \n-cdef class StringValue(ArrayValue):\n+\n+cdef class StringScalar(BinaryScalar):\n     \"\"\"\n-    Concrete class for string (utf8) array elements.\n+    Concrete class for string-like (utf8) scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Return this value as a Python string.\n         \"\"\"\n-        cdef CStringArray* ap = <CStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return frombytes(self.as_buffer().to_pybytes())\n+        else:\n+            return None\n \n-    def as_buffer(self):\n-        \"\"\"\n-        Return a view over this value as a Buffer object.\n-        \"\"\"\n-        cdef:\n-            CStringArray* ap = <CStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+cdef class LargeStringScalar(StringScalar):\n+    pass\n \n \n-cdef class LargeStringValue(ArrayValue):\n+cdef class ListScalar(Scalar):\n     \"\"\"\n-    Concrete class for large string (utf8) array elements.\n+    Concrete class for list-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    cdef array(self):\n+        cdef CListScalar* sp = <CListScalar*> self.wrapped.get()\n+        if sp.is_valid:\n+            return pyarrow_wrap_array(sp.value)\n+        else:\n+            return None\n+\n+    def __len__(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Return the number of values.\n         \"\"\"\n-        cdef CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        return len(self.array())\n \n-    def as_buffer(self):\n+    def __getitem__(self, i):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return the value at the given index.\n         \"\"\"\n-        cdef:\n-            CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n-\n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+        return self.array()[_normalize_index(i, len(self))]\n \n-\n-cdef class BinaryValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for variable-sized binary array elements.\n-    \"\"\"\n+    def __iter__(self):\n+        \"\"\"\n+        Iterate over this element's values.\n+        \"\"\"\n+        return iter(self.array())\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python bytes object.\n+        Return this value as a Python list.\n         \"\"\"\n-        cdef:\n-            const uint8_t* ptr\n-            int32_t length\n-            CBinaryArray* ap = <CBinaryArray*> self.sp_array.get()\n+        arr = self.array()\n+        return None if arr is None else arr.to_pylist()\n \n-        ptr = ap.GetValue(self.index, &length)\n-        return cp.PyBytes_FromStringAndSize(<const char*>(ptr), length)\n \n-    def as_buffer(self):\n-        \"\"\"\n-        Return a view over this value as a Buffer object.\n-        \"\"\"\n-        cdef:\n-            CBinaryArray* ap = <CBinaryArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+cdef class FixedSizeListScalar(ListScalar):\n+    pass\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n \n+cdef class LargeListScalar(ListScalar):\n+    pass\n \n-cdef class LargeBinaryValue(ArrayValue):\n+\n+cdef class StructScalar(Scalar):\n     \"\"\"\n-    Concrete class for large variable-sized binary array elements.\n+    Concrete class for struct scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def __len__(self):\n+        cdef CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+        return sp.value.size()\n+\n+    def __getitem__(self, key):\n         \"\"\"\n-        Return this value as a Python bytes object.\n+        Return the child value for the given field.\n+\n+        Parameters\n+        ----------\n+        index : Union[int, str]\n+            Index / position or name of the field.\n+\n+        Returns\n+        -------\n+        result : Scalar\n         \"\"\"\n         cdef:\n-            const uint8_t* ptr\n-            int64_t length\n-            CLargeBinaryArray* ap = <CLargeBinaryArray*> self.sp_array.get()\n+            CFieldRef ref\n+            CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+\n+        if isinstance(key, (bytes, str)):\n+            ref = CFieldRef(<c_string> tobytes(key))\n+        elif isinstance(key, int):\n+            ref = CFieldRef(<int> key)\n+        else:\n+            raise TypeError('Expected integer or string index')\n \n-        ptr = ap.GetValue(self.index, &length)\n-        return cp.PyBytes_FromStringAndSize(<const char*>(ptr), length)\n+        try:\n+            return Scalar.wrap(GetResultValue(sp.field(ref)))\n+        except ArrowInvalid:\n+            raise IndexError(key)\n \n-    def as_buffer(self):\n+    def as_py(self):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return this value as a Python dict.\n         \"\"\"\n         cdef:\n-            CLargeBinaryArray* ap = <CLargeBinaryArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+            CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+            CStructType* dtype = <CStructType*> sp.type.get()\n+            vector[shared_ptr[CField]] fields = dtype.fields()\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+        if sp.is_valid:\n+            return {frombytes(fields[i].get().name()): Scalar.wrap(sp.value[i])\n\nReview comment:\n       Updated, also extended the StructScalar's API to match a python mapping.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-26T12:19:12.962+0000",
                    "updated": "2020-06-26T12:19:12.962+0000",
                    "started": "2020-06-26T12:19:12.962+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "451535",
                    "issueId": "13308983"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/451536",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#issuecomment-650149745\n\n\n   > Could we add a `is_valid` attribute to the python scalar as well? Now the only way to check for a null value is to do `.as_py() is None` ?\r\n   \r\n   Added.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-26T12:21:18.576+0000",
                    "updated": "2020-06-26T12:21:18.576+0000",
                    "started": "2020-06-26T12:21:18.576+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "451536",
                    "issueId": "13308983"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/451544",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#issuecomment-650158531\n\n\n   I'm considering to apply [cython.freelist](https://cython.readthedocs.io/en/latest/src/userguide/extension_types.html#fast-instantiation) on the scalar extension classes.\r\n   \r\n   @wesm @pitrou @jorisvandenbossche do you have any positive experience with it?\r\n   \r\n   I assume we should measure its impact before using it, so I can defer it to a follow-up.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-26T12:44:00.328+0000",
                    "updated": "2020-06-26T12:44:00.328+0000",
                    "started": "2020-06-26T12:44:00.328+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "451544",
                    "issueId": "13308983"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/451545",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#discussion_r446160460\n\n\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,704 @@\n # under the License.\n \n \n-_NULL = NA = None\n-\n-\n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n \n-        self.type = null()\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n \n     def __eq__(self, other):\n-        return NA\n+        # TODO(kszucs): use c++ Equals\n+        if isinstance(other, Scalar):\n+            other = other.as_py()\n+        return self.as_py() == other\n \n+    def __hash__(self):\n+        # TODO(kszucs): use C++ hash if implemented for the type\n+        return hash(self.as_py())\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n-_NULL = NA = NullType()\n+\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n-\n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __init__(self):\n+        pass\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __eq__(self, other):\n+        return NA\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n+\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class DecimalScalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n         else:\n             tzinfo = None\n \n-        try:\n-            converter = _datetime_conversion_functions()[dtype.unit()]\n-        except KeyError:\n-            raise ValueError(\n-                'Cannot convert nanosecond timestamps without pandas'\n-            )\n-        return converter(value, tzinfo=tzinfo)\n-\n-\n-cdef dict _TIMEDELTA_CONVERSION_FUNCTIONS = {}\n-\n-\n-def _nanoseconds_to_timedelta_safe(v):\n-    if v % 1000 != 0:\n-        raise ValueError(\n-            \"Nanosecond duration {} is not safely convertible to microseconds \"\n-            \"to convert to datetime.timedelta. Install pandas to return as \"\n-            \"Timedelta with nanosecond support or access the .value \"\n-            \"attribute.\".format(v))\n-    micros = v // 1000\n-\n-    return datetime.timedelta(microseconds=micros)\n-\n+        return _datetime_from_int(sp.value, unit=dtype.unit(), tzinfo=tzinfo)\n \n-def _timedelta_conversion_functions():\n-    if _TIMEDELTA_CONVERSION_FUNCTIONS:\n-        return _TIMEDELTA_CONVERSION_FUNCTIONS\n \n-    _TIMEDELTA_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: lambda v: datetime.timedelta(seconds=v),\n-        TimeUnit_MILLI: lambda v: datetime.timedelta(milliseconds=v),\n-        TimeUnit_MICRO: lambda v: datetime.timedelta(microseconds=v),\n-        TimeUnit_NANO: _nanoseconds_to_timedelta_safe\n-    })\n-\n-    try:\n-        import pandas as pd\n-        _TIMEDELTA_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda v: pd.Timedelta(v, unit='ns')\n-        )\n-    except ImportError:\n-        pass\n-\n-    return _TIMEDELTA_CONVERSION_FUNCTIONS\n-\n-\n-cdef class DurationValue(ArrayValue):\n+cdef class DurationScalar(Scalar):\n     \"\"\"\n-    Concrete class for duration array elements.\n+    Concrete class for duration scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        cdef CDurationType* dtype = <CDurationType*> ap.type().get()\n-\n-        cdef int64_t value = ap.Value(self.index)\n-        converter = _timedelta_conversion_functions()[dtype.unit()]\n-        return converter(value)\n-\n+        cdef:\n+            CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+            CDurationType* dtype = <CDurationType*> sp.type.get()\n+            TimeUnit unit = dtype.unit()\n \n-cdef class HalfFloatValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float16 array elements.\n-    \"\"\"\n+        if not sp.is_valid:\n+            return None\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python float.\n-        \"\"\"\n-        cdef CHalfFloatArray* ap = <CHalfFloatArray*> self.sp_array.get()\n-        return PyHalf_FromHalf(ap.Value(self.index))\n+        if unit == TimeUnit_SECOND:\n+            return datetime.timedelta(seconds=sp.value)\n+        elif unit == TimeUnit_MILLI:\n+            return datetime.timedelta(milliseconds=sp.value)\n+        elif unit == TimeUnit_MICRO:\n+            return datetime.timedelta(microseconds=sp.value)\n+        else:\n+            # TimeUnit_NANO: prefer pandas timestamps if available\n+            if _pandas_api.have_pandas:\n+                return _pandas_api.pd.Timedelta(sp.value, unit='ns')\n+            # otherwise safely truncate to microsecond resolution timedelta\n+            if sp.value % 1000 != 0:\n+                raise ValueError(\n+                    \"Nanosecond duration {} is not safely convertible to \"\n+                    \"microseconds to convert to datetime.timedelta. Install \"\n+                    \"pandas to return as Timedelta with nanosecond support or \"\n+                    \"access the .value attribute.\".format(sp.value)\n+                )\n+            return datetime.timedelta(microseconds=sp.value // 1000)\n \n \n-cdef class FloatValue(ArrayValue):\n+cdef class BinaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for float32 array elements.\n+    Concrete class for binary-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def as_buffer(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return a view over this value as a Buffer object.\n         \"\"\"\n-        cdef CFloatArray* ap = <CFloatArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n-\n-\n-cdef class DoubleValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float64 array elements.\n-    \"\"\"\n+        cdef CBinaryScalar* sp = <CBinaryScalar*> self.wrapped.get()\n+        return pyarrow_wrap_buffer(sp.value) if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value as a Python bytes.\n         \"\"\"\n-        cdef CDoubleArray* ap = <CDoubleArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return self.as_buffer().to_pybytes()\n+        else:\n+            return None\n \n \n-cdef class DecimalValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for decimal128 array elements.\n-    \"\"\"\n+cdef class LargeBinaryScalar(BinaryScalar):\n+    pass\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python Decimal.\n-        \"\"\"\n-        cdef:\n-            CDecimal128Array* ap = <CDecimal128Array*> self.sp_array.get()\n-            c_string s = ap.FormatValue(self.index)\n-        return _pydecimal.Decimal(s.decode('utf8'))\n \n+cdef class FixedSizeBinaryScalar(BinaryScalar):\n+    pass\n \n-cdef class StringValue(ArrayValue):\n+\n+cdef class StringScalar(BinaryScalar):\n     \"\"\"\n-    Concrete class for string (utf8) array elements.\n+    Concrete class for string-like (utf8) scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Return this value as a Python string.\n         \"\"\"\n-        cdef CStringArray* ap = <CStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return frombytes(self.as_buffer().to_pybytes())\n+        else:\n+            return None\n \n-    def as_buffer(self):\n-        \"\"\"\n-        Return a view over this value as a Buffer object.\n-        \"\"\"\n-        cdef:\n-            CStringArray* ap = <CStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+cdef class LargeStringScalar(StringScalar):\n+    pass\n \n \n-cdef class LargeStringValue(ArrayValue):\n+cdef class ListScalar(Scalar):\n     \"\"\"\n-    Concrete class for large string (utf8) array elements.\n+    Concrete class for list-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    cdef array(self):\n\nReview comment:\n       Exposed as `values`\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-26T12:44:15.305+0000",
                    "updated": "2020-06-26T12:44:15.305+0000",
                    "started": "2020-06-26T12:44:15.304+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "451545",
                    "issueId": "13308983"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/453011",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#discussion_r447677453\n\n\n\n##########\nFile path: python/pyarrow/lib.pxd\n##########\n@@ -179,101 +179,18 @@ cdef class Schema:\n \n \n cdef class Scalar:\n-    cdef readonly:\n-        DataType type\n-\n-\n-cdef class NAType(Scalar):\n-    pass\n-\n-\n-cdef class ArrayValue(Scalar):\n     cdef:\n-        shared_ptr[CArray] sp_array\n-        int64_t index\n-\n-    cdef void init(self, DataType type,\n-                   const shared_ptr[CArray]& sp_array, int64_t index)\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array)\n-\n-cdef class ScalarValue(Scalar):\n-    cdef:\n-        shared_ptr[CScalar] sp_scalar\n-\n-    cdef void init(self, const shared_ptr[CScalar]& sp_scalar)\n-\n-cdef class Int8Value(ArrayValue):\n-    pass\n+        shared_ptr[CScalar] wrapped\n \n+    cdef void init(self, const shared_ptr[CScalar]& wrapped)\n \n-cdef class Int64Value(ArrayValue):\n-    pass\n-\n-\n-cdef class ListValue(ArrayValue):\n-    cdef readonly:\n-        DataType value_type\n-\n-    cdef:\n-        CListArray* ap\n-\n-    cdef getitem(self, int64_t i)\n-    cdef int64_t length(self)\n-\n-\n-cdef class LargeListValue(ArrayValue):\n-    cdef readonly:\n-        DataType value_type\n-\n-    cdef:\n-        CLargeListArray* ap\n-\n-    cdef getitem(self, int64_t i)\n-    cdef int64_t length(self)\n-\n-\n-cdef class MapValue(ArrayValue):\n-    cdef readonly:\n-        DataType key_type\n-        DataType item_type\n-\n-    cdef:\n-        CMapArray* ap\n-\n-    cdef getitem(self, int64_t i)\n-    cdef int64_t length(self)\n-\n-\n-cdef class FixedSizeListValue(ArrayValue):\n-    cdef readonly:\n-        DataType value_type\n-\n-    cdef:\n-        CFixedSizeListArray* ap\n-\n-    cdef getitem(self, int64_t i)\n-    cdef int64_t length(self)\n-\n-\n-cdef class StructValue(ArrayValue):\n-    cdef:\n-        CStructArray* ap\n-\n-\n-cdef class UnionValue(ArrayValue):\n-    cdef:\n-        CUnionArray* ap\n-        list value_types\n-\n-    cdef getitem(self, int64_t i)\n-\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped)\n \n-cdef class StringValue(ArrayValue):\n-    pass\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil\n \n \n-cdef class FixedSizeBinaryValue(ArrayValue):\n+cdef class NAType(Scalar):\n\nReview comment:\n       `NullScalar` perhaps... also, why does it have its own class?\n\n##########\nFile path: python/pyarrow/includes/libarrow.pxd\n##########\n@@ -44,6 +44,11 @@ cdef extern from \"arrow/util/key_value_metadata.h\" namespace \"arrow\" nogil:\n         c_bool Contains(const c_string& key) const\n \n \n+cdef extern from \"arrow/util/decimal.h\" namespace \"arrow\" nogil:\n+    cdef cppclass CDecimal128\" arrow::Decimal128\":\n+        c_string ToString(int32_t scale) const\n\nReview comment:\n       Hmm, at some point we should be able to pretty-print scalars in C++.\n\n##########\nFile path: python/pyarrow/includes/libarrow.pxd\n##########\n@@ -877,20 +893,60 @@ cdef extern from \"arrow/api.h\" namespace \"arrow\" nogil:\n     cdef cppclass CUInt64Scalar\" arrow::UInt64Scalar\"(CScalar):\n         uint64_t value\n \n+    cdef cppclass CHalfFloatScalar\" arrow::HalfFloatScalar\"(CScalar):\n+        npy_half value\n\nReview comment:\n       Ah, cool!\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n\nReview comment:\n       Why do you need to redefine this method?\n\n##########\nFile path: python/pyarrow/tests/test_scalars.py\n##########\n@@ -16,427 +16,443 @@\n # under the License.\n \n import datetime\n+import decimal\n import pytest\n-import unittest\n \n import numpy as np\n \n import pyarrow as pa\n \n \n-class TestScalars(unittest.TestCase):\n-\n-    def test_null_singleton(self):\n-        with pytest.raises(Exception):\n-            pa.NAType()\n+@pytest.mark.parametrize(['value', 'ty', 'klass', 'deprecated'], [\n+    (False, None, pa.BooleanScalar, pa.BooleanValue),\n+    (True, None, pa.BooleanScalar, pa.BooleanValue),\n+    (1, None, pa.Int64Scalar, pa.Int64Value),\n+    (-1, None, pa.Int64Scalar, pa.Int64Value),\n+    (1, pa.int8(), pa.Int8Scalar, pa.Int8Value),\n+    (1, pa.uint8(), pa.UInt8Scalar, pa.UInt8Value),\n+    (1, pa.int16(), pa.Int16Scalar, pa.Int16Value),\n+    (1, pa.uint16(), pa.UInt16Scalar, pa.UInt16Value),\n+    (1, pa.int32(), pa.Int32Scalar, pa.Int32Value),\n+    (1, pa.uint32(), pa.UInt32Scalar, pa.UInt32Value),\n+    (1, pa.int64(), pa.Int64Scalar, pa.Int64Value),\n+    (1, pa.uint64(), pa.UInt64Scalar, pa.UInt64Value),\n+    (1.0, None, pa.DoubleScalar, pa.DoubleValue),\n+    (np.float16(1.0), pa.float16(), pa.HalfFloatScalar, pa.HalfFloatValue),\n+    (1.0, pa.float32(), pa.FloatScalar, pa.FloatValue),\n+    (\"string\", None, pa.StringScalar, pa.StringValue),\n+    (b\"bytes\", None, pa.BinaryScalar, pa.BinaryValue),\n+    ([1, 2, 3], None, pa.ListScalar, pa.ListValue),\n+    ([1, 2, 3, 4], pa.large_list(pa.int8()), pa.LargeListScalar,\n+     pa.LargeListValue),\n+    (datetime.date.today(), None, pa.Date32Scalar, pa.Date64Value),\n+    (datetime.datetime.now(), None, pa.TimestampScalar, pa.TimestampValue),\n+    ({'a': 1, 'b': [1, 2]}, None, pa.StructScalar, pa.StructValue)\n+])\n+def test_basics(value, ty, klass, deprecated):\n+    s = pa.scalar(value, type=ty)\n+    assert isinstance(s, klass)\n+    assert s == value\n+    assert s == s\n+    assert s != \"else\"\n+    assert hash(s) == hash(s)\n\nReview comment:\n       What's the point of this test? This is going to be trivially true.\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def __eq__(self, other):\n+        if hasattr(self, 'as_py'):\n+            if isinstance(other, Scalar):\n+                other = other.as_py()\n+            return self.as_py() == other\n+        else:\n+            raise NotImplementedError\n+\n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n+\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class Decimal128Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value // 1000)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n         else:\n             tzinfo = None\n \n-        try:\n-            converter = _datetime_conversion_functions()[dtype.unit()]\n-        except KeyError:\n-            raise ValueError(\n-                'Cannot convert nanosecond timestamps without pandas'\n-            )\n-        return converter(value, tzinfo=tzinfo)\n-\n-\n-cdef dict _TIMEDELTA_CONVERSION_FUNCTIONS = {}\n-\n-\n-def _nanoseconds_to_timedelta_safe(v):\n-    if v % 1000 != 0:\n-        raise ValueError(\n-            \"Nanosecond duration {} is not safely convertible to microseconds \"\n-            \"to convert to datetime.timedelta. Install pandas to return as \"\n-            \"Timedelta with nanosecond support or access the .value \"\n-            \"attribute.\".format(v))\n-    micros = v // 1000\n-\n-    return datetime.timedelta(microseconds=micros)\n-\n-\n-def _timedelta_conversion_functions():\n-    if _TIMEDELTA_CONVERSION_FUNCTIONS:\n-        return _TIMEDELTA_CONVERSION_FUNCTIONS\n-\n-    _TIMEDELTA_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: lambda v: datetime.timedelta(seconds=v),\n-        TimeUnit_MILLI: lambda v: datetime.timedelta(milliseconds=v),\n-        TimeUnit_MICRO: lambda v: datetime.timedelta(microseconds=v),\n-        TimeUnit_NANO: _nanoseconds_to_timedelta_safe\n-    })\n-\n-    try:\n-        import pandas as pd\n-        _TIMEDELTA_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda v: pd.Timedelta(v, unit='ns')\n-        )\n-    except ImportError:\n-        pass\n+        return _datetime_from_int(sp.value, unit=dtype.unit(), tzinfo=tzinfo)\n \n-    return _TIMEDELTA_CONVERSION_FUNCTIONS\n \n-\n-cdef class DurationValue(ArrayValue):\n+cdef class DurationScalar(Scalar):\n     \"\"\"\n-    Concrete class for duration array elements.\n+    Concrete class for duration scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        cdef CDurationType* dtype = <CDurationType*> ap.type().get()\n+        cdef:\n+            CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+            CDurationType* dtype = <CDurationType*> sp.type.get()\n+            TimeUnit unit = dtype.unit()\n+\n+        if not sp.is_valid:\n+            return None\n \n-        cdef int64_t value = ap.Value(self.index)\n-        converter = _timedelta_conversion_functions()[dtype.unit()]\n-        return converter(value)\n+        if unit == TimeUnit_SECOND:\n+            return datetime.timedelta(seconds=sp.value)\n+        elif unit == TimeUnit_MILLI:\n+            return datetime.timedelta(milliseconds=sp.value)\n+        elif unit == TimeUnit_MICRO:\n+            return datetime.timedelta(microseconds=sp.value)\n+        else:\n+            # TimeUnit_NANO: prefer pandas timestamps if available\n+            if _pandas_api.have_pandas:\n+                return _pandas_api.pd.Timedelta(sp.value, unit='ns')\n+            # otherwise safely truncate to microsecond resolution timedelta\n+            if sp.value % 1000 != 0:\n+                raise ValueError(\n+                    \"Nanosecond duration {} is not safely convertible to \"\n+                    \"microseconds to convert to datetime.timedelta. Install \"\n+                    \"pandas to return as Timedelta with nanosecond support or \"\n+                    \"access the .value attribute.\".format(sp.value)\n+                )\n+            return datetime.timedelta(microseconds=sp.value // 1000)\n \n \n-cdef class HalfFloatValue(ArrayValue):\n+cdef class BinaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for float16 array elements.\n+    Concrete class for binary-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def as_buffer(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return a view over this value as a Buffer object.\n         \"\"\"\n-        cdef CHalfFloatArray* ap = <CHalfFloatArray*> self.sp_array.get()\n-        return PyHalf_FromHalf(ap.Value(self.index))\n-\n-\n-cdef class FloatValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float32 array elements.\n-    \"\"\"\n+        cdef CBinaryScalar* sp = <CBinaryScalar*> self.wrapped.get()\n+        return pyarrow_wrap_buffer(sp.value) if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value as a Python bytes.\n         \"\"\"\n-        cdef CFloatArray* ap = <CFloatArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return self.as_buffer().to_pybytes()\n+        else:\n+            return None\n \n \n-cdef class DoubleValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float64 array elements.\n-    \"\"\"\n+cdef class LargeBinaryScalar(BinaryScalar):\n+    pass\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python float.\n-        \"\"\"\n-        cdef CDoubleArray* ap = <CDoubleArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+\n+cdef class FixedSizeBinaryScalar(BinaryScalar):\n+    pass\n \n \n-cdef class DecimalValue(ArrayValue):\n+cdef class StringScalar(BinaryScalar):\n     \"\"\"\n-    Concrete class for decimal128 array elements.\n+    Concrete class for string-like (utf8) scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python Decimal.\n+        Return this value as a Python string.\n         \"\"\"\n-        cdef:\n-            CDecimal128Array* ap = <CDecimal128Array*> self.sp_array.get()\n-            c_string s = ap.FormatValue(self.index)\n-        return _pydecimal.Decimal(s.decode('utf8'))\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return frombytes(self.as_buffer().to_pybytes())\n\nReview comment:\n       `str(buffer, 'utf8')` should work, since `buffer` supports the buffer protocol:\r\n   ```python\r\n   >>> buf = pa.py_buffer(b'abc')                                                                                                                                            \r\n   >>> str(buf, 'utf8')                                                                                                                                                      \r\n   'abc'\r\n   ```\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def __eq__(self, other):\n+        if hasattr(self, 'as_py'):\n+            if isinstance(other, Scalar):\n+                other = other.as_py()\n+            return self.as_py() == other\n+        else:\n+            raise NotImplementedError\n+\n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n+\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class Decimal128Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value // 1000)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n         else:\n             tzinfo = None\n \n-        try:\n-            converter = _datetime_conversion_functions()[dtype.unit()]\n-        except KeyError:\n-            raise ValueError(\n-                'Cannot convert nanosecond timestamps without pandas'\n-            )\n-        return converter(value, tzinfo=tzinfo)\n-\n-\n-cdef dict _TIMEDELTA_CONVERSION_FUNCTIONS = {}\n-\n-\n-def _nanoseconds_to_timedelta_safe(v):\n-    if v % 1000 != 0:\n-        raise ValueError(\n-            \"Nanosecond duration {} is not safely convertible to microseconds \"\n-            \"to convert to datetime.timedelta. Install pandas to return as \"\n-            \"Timedelta with nanosecond support or access the .value \"\n-            \"attribute.\".format(v))\n-    micros = v // 1000\n-\n-    return datetime.timedelta(microseconds=micros)\n-\n-\n-def _timedelta_conversion_functions():\n-    if _TIMEDELTA_CONVERSION_FUNCTIONS:\n-        return _TIMEDELTA_CONVERSION_FUNCTIONS\n-\n-    _TIMEDELTA_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: lambda v: datetime.timedelta(seconds=v),\n-        TimeUnit_MILLI: lambda v: datetime.timedelta(milliseconds=v),\n-        TimeUnit_MICRO: lambda v: datetime.timedelta(microseconds=v),\n-        TimeUnit_NANO: _nanoseconds_to_timedelta_safe\n-    })\n-\n-    try:\n-        import pandas as pd\n-        _TIMEDELTA_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda v: pd.Timedelta(v, unit='ns')\n-        )\n-    except ImportError:\n-        pass\n+        return _datetime_from_int(sp.value, unit=dtype.unit(), tzinfo=tzinfo)\n \n-    return _TIMEDELTA_CONVERSION_FUNCTIONS\n \n-\n-cdef class DurationValue(ArrayValue):\n+cdef class DurationScalar(Scalar):\n     \"\"\"\n-    Concrete class for duration array elements.\n+    Concrete class for duration scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        cdef CDurationType* dtype = <CDurationType*> ap.type().get()\n+        cdef:\n+            CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+            CDurationType* dtype = <CDurationType*> sp.type.get()\n+            TimeUnit unit = dtype.unit()\n+\n+        if not sp.is_valid:\n+            return None\n \n-        cdef int64_t value = ap.Value(self.index)\n-        converter = _timedelta_conversion_functions()[dtype.unit()]\n-        return converter(value)\n+        if unit == TimeUnit_SECOND:\n+            return datetime.timedelta(seconds=sp.value)\n+        elif unit == TimeUnit_MILLI:\n+            return datetime.timedelta(milliseconds=sp.value)\n+        elif unit == TimeUnit_MICRO:\n+            return datetime.timedelta(microseconds=sp.value)\n+        else:\n+            # TimeUnit_NANO: prefer pandas timestamps if available\n+            if _pandas_api.have_pandas:\n+                return _pandas_api.pd.Timedelta(sp.value, unit='ns')\n+            # otherwise safely truncate to microsecond resolution timedelta\n+            if sp.value % 1000 != 0:\n+                raise ValueError(\n+                    \"Nanosecond duration {} is not safely convertible to \"\n+                    \"microseconds to convert to datetime.timedelta. Install \"\n+                    \"pandas to return as Timedelta with nanosecond support or \"\n+                    \"access the .value attribute.\".format(sp.value)\n+                )\n+            return datetime.timedelta(microseconds=sp.value // 1000)\n \n \n-cdef class HalfFloatValue(ArrayValue):\n+cdef class BinaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for float16 array elements.\n+    Concrete class for binary-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def as_buffer(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return a view over this value as a Buffer object.\n         \"\"\"\n-        cdef CHalfFloatArray* ap = <CHalfFloatArray*> self.sp_array.get()\n-        return PyHalf_FromHalf(ap.Value(self.index))\n-\n-\n-cdef class FloatValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float32 array elements.\n-    \"\"\"\n+        cdef CBinaryScalar* sp = <CBinaryScalar*> self.wrapped.get()\n+        return pyarrow_wrap_buffer(sp.value) if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value as a Python bytes.\n         \"\"\"\n-        cdef CFloatArray* ap = <CFloatArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return self.as_buffer().to_pybytes()\n+        else:\n+            return None\n \n \n-cdef class DoubleValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float64 array elements.\n-    \"\"\"\n+cdef class LargeBinaryScalar(BinaryScalar):\n+    pass\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python float.\n-        \"\"\"\n-        cdef CDoubleArray* ap = <CDoubleArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+\n+cdef class FixedSizeBinaryScalar(BinaryScalar):\n+    pass\n \n \n-cdef class DecimalValue(ArrayValue):\n+cdef class StringScalar(BinaryScalar):\n     \"\"\"\n-    Concrete class for decimal128 array elements.\n+    Concrete class for string-like (utf8) scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python Decimal.\n+        Return this value as a Python string.\n         \"\"\"\n-        cdef:\n-            CDecimal128Array* ap = <CDecimal128Array*> self.sp_array.get()\n-            c_string s = ap.FormatValue(self.index)\n-        return _pydecimal.Decimal(s.decode('utf8'))\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return frombytes(self.as_buffer().to_pybytes())\n+        else:\n+            return None\n+\n \n+cdef class LargeStringScalar(StringScalar):\n+    pass\n \n-cdef class StringValue(ArrayValue):\n+\n+cdef class ListScalar(Scalar):\n     \"\"\"\n-    Concrete class for string (utf8) array elements.\n+    Concrete class for list-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    @property\n+    def values(self):\n+        cdef CListScalar* sp = <CListScalar*> self.wrapped.get()\n+        if sp.is_valid:\n+            return pyarrow_wrap_array(sp.value)\n+        else:\n+            return None\n+\n+    def __len__(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Return the number of values.\n         \"\"\"\n-        cdef CStringArray* ap = <CStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        return len(self.values)\n \n-    def as_buffer(self):\n+    def __getitem__(self, i):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return the value at the given index.\n         \"\"\"\n-        cdef:\n-            CStringArray* ap = <CStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n-\n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n-\n+        return self.values[_normalize_index(i, len(self))]\n \n-cdef class LargeStringValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large string (utf8) array elements.\n-    \"\"\"\n-\n-    def as_py(self):\n+    def __iter__(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Iterate over this element's values.\n         \"\"\"\n-        cdef CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        return iter(self.values)\n \n-    def as_buffer(self):\n+    def as_py(self):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return this value as a Python list.\n         \"\"\"\n-        cdef:\n-            CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+        arr = self.values\n+        return None if arr is None else arr.to_pylist()\n+\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+cdef class FixedSizeListScalar(ListScalar):\n+    pass\n \n \n-cdef class BinaryValue(ArrayValue):\n+cdef class LargeListScalar(ListScalar):\n+    pass\n+\n+\n+cdef class StructScalar(Scalar, collections.abc.Mapping):\n     \"\"\"\n-    Concrete class for variable-sized binary array elements.\n+    Concrete class for struct scalars.\n     \"\"\"\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python bytes object.\n-        \"\"\"\n+    def __len__(self):\n+        cdef CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+        return sp.value.size()\n+\n+    def __iter__(self):\n         cdef:\n-            const uint8_t* ptr\n-            int32_t length\n-            CBinaryArray* ap = <CBinaryArray*> self.sp_array.get()\n+            CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+            CStructType* dtype = <CStructType*> sp.type.get()\n+            vector[shared_ptr[CField]] fields = dtype.fields()\n \n-        ptr = ap.GetValue(self.index, &length)\n-        return cp.PyBytes_FromStringAndSize(<const char*>(ptr), length)\n+        if sp.is_valid:\n+            for i in range(dtype.num_fields()):\n+                yield frombytes(fields[i].get().name())\n \n-    def as_buffer(self):\n+    def __contains__(self, key):\n+        try:\n+            self[key]\n+        except IndexError:\n+            return False\n+        else:\n+            return True\n+\n+    def __getitem__(self, key):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return the child value for the given field.\n+\n+        Parameters\n+        ----------\n+        index : Union[int, str]\n+            Index / position or name of the field.\n+\n+        Returns\n+        -------\n+        result : Scalar\n         \"\"\"\n         cdef:\n-            CBinaryArray* ap = <CBinaryArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+            CFieldRef ref\n+            CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+        if isinstance(key, (bytes, str)):\n+            ref = CFieldRef(<c_string> tobytes(key))\n+        elif isinstance(key, int):\n+            ref = CFieldRef(<int> key)\n+        else:\n+            raise TypeError('Expected integer or string index')\n \n-\n-cdef class LargeBinaryValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large variable-sized binary array elements.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python bytes object.\n-        \"\"\"\n-        cdef:\n-            const uint8_t* ptr\n-            int64_t length\n-            CLargeBinaryArray* ap = <CLargeBinaryArray*> self.sp_array.get()\n-\n-        ptr = ap.GetValue(self.index, &length)\n-        return cp.PyBytes_FromStringAndSize(<const char*>(ptr), length)\n-\n-    def as_buffer(self):\n-        \"\"\"\n-        Return a view over this value as a Buffer object.\n-        \"\"\"\n-        cdef:\n-            CLargeBinaryArray* ap = <CLargeBinaryArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n-\n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n-\n-\n-cdef class ListValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for list array elements.\n-    \"\"\"\n-\n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n-    def __getitem__(self, i):\n-        \"\"\"\n-        Return the value at the given index.\n-        \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n-\n-    def __iter__(self):\n-        \"\"\"\n-        Iterate over this element's values.\n-        \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CListArray*> sp_array.get()\n-        self.value_type = pyarrow_wrap_data_type(self.ap.value_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return box_scalar(self.value_type, self.ap.values(), j)\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python list.\n-        \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            result.append(self.getitem(j).as_py())\n-\n-        return result\n-\n-\n-cdef class LargeListValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large list array elements.\n-    \"\"\"\n-\n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n-    def __getitem__(self, i):\n-        \"\"\"\n-        Return the value at the given index.\n-        \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n-\n-    def __iter__(self):\n-        \"\"\"\n-        Iterate over this element's values.\n-        \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CLargeListArray*> sp_array.get()\n-        self.value_type = pyarrow_wrap_data_type(self.ap.value_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return box_scalar(self.value_type, self.ap.values(), j)\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python list.\n-        \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            result.append(self.getitem(j).as_py())\n-\n-        return result\n-\n-\n-cdef class MapValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for map array elements.\n-    \"\"\"\n-\n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n-    def __getitem__(self, i):\n-        \"\"\"\n-        Return the value at the given index.\n-        \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n-\n-    def __iter__(self):\n-        \"\"\"\n-        Iterate over this element's values.\n-        \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CMapArray*> sp_array.get()\n-        self.key_type = pyarrow_wrap_data_type(self.ap.map_type().key_type())\n-        self.item_type = pyarrow_wrap_data_type(self.ap.map_type().item_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return (box_scalar(self.key_type, self.ap.keys(), j),\n-                box_scalar(self.item_type, self.ap.items(), j))\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n+        try:\n+            return Scalar.wrap(GetResultValue(sp.field(ref)))\n+        except ArrowInvalid:\n+            raise IndexError(key)\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python list of tuples, each containing a\n-        key and item.\n+        Return this value as a Python dict.\n         \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            key, item = self.getitem(j)\n-            result.append((key.as_py(), item.as_py()))\n-\n-        return result\n+        if self.is_valid:\n+            return {k: v.as_py() for k, v in self.items()}\n+        else:\n+            return None\n \n \n-cdef class FixedSizeListValue(ArrayValue):\n+cdef class MapScalar(ListScalar):\n     \"\"\"\n-    Concrete class for fixed size list array elements.\n+    Concrete class for map scalars.\n     \"\"\"\n \n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n     def __getitem__(self, i):\n         \"\"\"\n         Return the value at the given index.\n         \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n+        arr = self.values\n+        if arr is None:\n+            raise IndexError(i)\n+        dct = arr[_normalize_index(i, len(arr))]\n+        return (dct['key'], dct['value'])\n \n     def __iter__(self):\n         \"\"\"\n         Iterate over this element's values.\n         \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CFixedSizeListArray*> sp_array.get()\n-        self.value_type = pyarrow_wrap_data_type(self.ap.value_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return box_scalar(self.value_type, self.ap.values(), j)\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n+        arr = self.values\n+        if arr is None:\n+            return iter(zip(arr.field('key'), arr.field('value')))\n+        else:\n+            raise StopIteration\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python list.\n         \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            result.append(self.getitem(j).as_py())\n-\n-        return result\n-\n-\n-cdef class UnionValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for union array elements.\n-    \"\"\"\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CUnionArray*> sp_array.get()\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int child_id = self.ap.child_id(i)\n-        cdef shared_ptr[CArray] child = self.ap.field(child_id)\n-        cdef CDenseUnionArray* dense\n-        if self.ap.mode() == _UnionMode_SPARSE:\n-            return box_scalar(self.type[child_id].type, child, i)\n+        arr = self.values\n+        if arr is not None:\n+            return list(zip(arr.field('key'), arr.field('value')))\n         else:\n-            dense = <CDenseUnionArray*> self.ap\n-            return box_scalar(self.type[child_id].type, child,\n-                              dense.value_offset(i))\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python object.\n-\n-        The exact type depends on the underlying union member.\n-        \"\"\"\n-        return self.getitem(self.index).as_py()\n+            return None\n \n \n-cdef class FixedSizeBinaryValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for fixed-size binary array elements.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python bytes object.\n-        \"\"\"\n-        cdef:\n-            CFixedSizeBinaryArray* ap\n-            CFixedSizeBinaryType* ap_type\n-            int32_t length\n-            const char* data\n-        ap = <CFixedSizeBinaryArray*> self.sp_array.get()\n-        ap_type = <CFixedSizeBinaryType*> ap.type().get()\n-        length = ap_type.byte_width()\n-        data = <const char*> ap.GetValue(self.index)\n-        return cp.PyBytes_FromStringAndSize(data, length)\n-\n-\n-cdef class StructValue(ArrayValue):\n+cdef class DictionaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for struct array elements.\n+    Concrete class for dictionary-encoded scalars.\n     \"\"\"\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CStructArray*> sp_array.get()\n-\n-    def __getitem__(self, key):\n-        \"\"\"\n-        Return the child value for the given field name.\n-        \"\"\"\n-        cdef:\n-            CStructType* type\n-            int index\n-\n-        type = <CStructType*> self.type.type\n-        index = type.GetFieldIndex(tobytes(key))\n-\n-        if index < 0:\n-            raise KeyError(key)\n+    # @property\n+    # def index(self):\n+    #     \"\"\"\n+    #     Return this value's underlying index as a scalar.\n\nReview comment:\n       Hmm, why is this disabled? Please add a comment.\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n\nReview comment:\n       Hmm, what?\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def __eq__(self, other):\n+        if hasattr(self, 'as_py'):\n\nReview comment:\n       This `hasattr` check is pointless as, `self` is a `HalfFloatScalar`.\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def __eq__(self, other):\n+        if hasattr(self, 'as_py'):\n+            if isinstance(other, Scalar):\n+                other = other.as_py()\n+            return self.as_py() == other\n+        else:\n+            raise NotImplementedError\n+\n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n+\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class Decimal128Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n\nReview comment:\n       Why `_pydecimal`? You should be using the `decimal` module.\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n\nReview comment:\n       Why do you need to redefine this?\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n\nReview comment:\n       Add docstrings here.\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def __eq__(self, other):\n+        if hasattr(self, 'as_py'):\n+            if isinstance(other, Scalar):\n+                other = other.as_py()\n+            return self.as_py() == other\n+        else:\n+            raise NotImplementedError\n+\n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n+\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class Decimal128Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value // 1000)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n         else:\n             tzinfo = None\n \n-        try:\n-            converter = _datetime_conversion_functions()[dtype.unit()]\n-        except KeyError:\n-            raise ValueError(\n-                'Cannot convert nanosecond timestamps without pandas'\n-            )\n-        return converter(value, tzinfo=tzinfo)\n-\n-\n-cdef dict _TIMEDELTA_CONVERSION_FUNCTIONS = {}\n-\n-\n-def _nanoseconds_to_timedelta_safe(v):\n-    if v % 1000 != 0:\n-        raise ValueError(\n-            \"Nanosecond duration {} is not safely convertible to microseconds \"\n-            \"to convert to datetime.timedelta. Install pandas to return as \"\n-            \"Timedelta with nanosecond support or access the .value \"\n-            \"attribute.\".format(v))\n-    micros = v // 1000\n-\n-    return datetime.timedelta(microseconds=micros)\n-\n-\n-def _timedelta_conversion_functions():\n-    if _TIMEDELTA_CONVERSION_FUNCTIONS:\n-        return _TIMEDELTA_CONVERSION_FUNCTIONS\n-\n-    _TIMEDELTA_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: lambda v: datetime.timedelta(seconds=v),\n-        TimeUnit_MILLI: lambda v: datetime.timedelta(milliseconds=v),\n-        TimeUnit_MICRO: lambda v: datetime.timedelta(microseconds=v),\n-        TimeUnit_NANO: _nanoseconds_to_timedelta_safe\n-    })\n-\n-    try:\n-        import pandas as pd\n-        _TIMEDELTA_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda v: pd.Timedelta(v, unit='ns')\n-        )\n-    except ImportError:\n-        pass\n+        return _datetime_from_int(sp.value, unit=dtype.unit(), tzinfo=tzinfo)\n \n-    return _TIMEDELTA_CONVERSION_FUNCTIONS\n \n-\n-cdef class DurationValue(ArrayValue):\n+cdef class DurationScalar(Scalar):\n     \"\"\"\n-    Concrete class for duration array elements.\n+    Concrete class for duration scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        cdef CDurationType* dtype = <CDurationType*> ap.type().get()\n+        cdef:\n+            CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+            CDurationType* dtype = <CDurationType*> sp.type.get()\n+            TimeUnit unit = dtype.unit()\n+\n+        if not sp.is_valid:\n+            return None\n \n-        cdef int64_t value = ap.Value(self.index)\n-        converter = _timedelta_conversion_functions()[dtype.unit()]\n-        return converter(value)\n+        if unit == TimeUnit_SECOND:\n+            return datetime.timedelta(seconds=sp.value)\n+        elif unit == TimeUnit_MILLI:\n+            return datetime.timedelta(milliseconds=sp.value)\n+        elif unit == TimeUnit_MICRO:\n+            return datetime.timedelta(microseconds=sp.value)\n+        else:\n+            # TimeUnit_NANO: prefer pandas timestamps if available\n+            if _pandas_api.have_pandas:\n+                return _pandas_api.pd.Timedelta(sp.value, unit='ns')\n+            # otherwise safely truncate to microsecond resolution timedelta\n+            if sp.value % 1000 != 0:\n+                raise ValueError(\n+                    \"Nanosecond duration {} is not safely convertible to \"\n+                    \"microseconds to convert to datetime.timedelta. Install \"\n+                    \"pandas to return as Timedelta with nanosecond support or \"\n+                    \"access the .value attribute.\".format(sp.value)\n+                )\n+            return datetime.timedelta(microseconds=sp.value // 1000)\n \n \n-cdef class HalfFloatValue(ArrayValue):\n+cdef class BinaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for float16 array elements.\n+    Concrete class for binary-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def as_buffer(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return a view over this value as a Buffer object.\n         \"\"\"\n-        cdef CHalfFloatArray* ap = <CHalfFloatArray*> self.sp_array.get()\n-        return PyHalf_FromHalf(ap.Value(self.index))\n-\n-\n-cdef class FloatValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float32 array elements.\n-    \"\"\"\n+        cdef CBinaryScalar* sp = <CBinaryScalar*> self.wrapped.get()\n+        return pyarrow_wrap_buffer(sp.value) if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value as a Python bytes.\n         \"\"\"\n-        cdef CFloatArray* ap = <CFloatArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return self.as_buffer().to_pybytes()\n+        else:\n+            return None\n \n \n-cdef class DoubleValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float64 array elements.\n-    \"\"\"\n+cdef class LargeBinaryScalar(BinaryScalar):\n\nReview comment:\n       It is not safe to inherit `BinaryScalar.as_buffer`, because it is casting the C++ scalar to `CBinaryScalar`.\r\n   Instead you should redefine that method.\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def __eq__(self, other):\n+        if hasattr(self, 'as_py'):\n+            if isinstance(other, Scalar):\n+                other = other.as_py()\n+            return self.as_py() == other\n+        else:\n+            raise NotImplementedError\n+\n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n+\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class Decimal128Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value // 1000)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n\nReview comment:\n       Why do you have to do this twice? If `string_to_tzinfo` is broken, it should be fixed IMO.\n\n##########\nFile path: python/pyarrow/tests/test_dataset.py\n##########\n@@ -385,10 +385,12 @@ def test_partitioning():\n \n def test_expression_serialization():\n     a = ds.scalar(1)\n+    a_ = ds.scalar(pa.scalar(1))\n\nReview comment:\n       Uh, can you use another name? Why not `g`?\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def __eq__(self, other):\n+        if hasattr(self, 'as_py'):\n+            if isinstance(other, Scalar):\n+                other = other.as_py()\n+            return self.as_py() == other\n+        else:\n+            raise NotImplementedError\n+\n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n+\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class Decimal128Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value // 1000)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n         else:\n             tzinfo = None\n \n-        try:\n-            converter = _datetime_conversion_functions()[dtype.unit()]\n-        except KeyError:\n-            raise ValueError(\n-                'Cannot convert nanosecond timestamps without pandas'\n-            )\n-        return converter(value, tzinfo=tzinfo)\n-\n-\n-cdef dict _TIMEDELTA_CONVERSION_FUNCTIONS = {}\n-\n-\n-def _nanoseconds_to_timedelta_safe(v):\n-    if v % 1000 != 0:\n-        raise ValueError(\n-            \"Nanosecond duration {} is not safely convertible to microseconds \"\n-            \"to convert to datetime.timedelta. Install pandas to return as \"\n-            \"Timedelta with nanosecond support or access the .value \"\n-            \"attribute.\".format(v))\n-    micros = v // 1000\n-\n-    return datetime.timedelta(microseconds=micros)\n-\n-\n-def _timedelta_conversion_functions():\n-    if _TIMEDELTA_CONVERSION_FUNCTIONS:\n-        return _TIMEDELTA_CONVERSION_FUNCTIONS\n-\n-    _TIMEDELTA_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: lambda v: datetime.timedelta(seconds=v),\n-        TimeUnit_MILLI: lambda v: datetime.timedelta(milliseconds=v),\n-        TimeUnit_MICRO: lambda v: datetime.timedelta(microseconds=v),\n-        TimeUnit_NANO: _nanoseconds_to_timedelta_safe\n-    })\n-\n-    try:\n-        import pandas as pd\n-        _TIMEDELTA_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda v: pd.Timedelta(v, unit='ns')\n-        )\n-    except ImportError:\n-        pass\n+        return _datetime_from_int(sp.value, unit=dtype.unit(), tzinfo=tzinfo)\n \n-    return _TIMEDELTA_CONVERSION_FUNCTIONS\n \n-\n-cdef class DurationValue(ArrayValue):\n+cdef class DurationScalar(Scalar):\n     \"\"\"\n-    Concrete class for duration array elements.\n+    Concrete class for duration scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        cdef CDurationType* dtype = <CDurationType*> ap.type().get()\n+        cdef:\n+            CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+            CDurationType* dtype = <CDurationType*> sp.type.get()\n+            TimeUnit unit = dtype.unit()\n+\n+        if not sp.is_valid:\n+            return None\n \n-        cdef int64_t value = ap.Value(self.index)\n-        converter = _timedelta_conversion_functions()[dtype.unit()]\n-        return converter(value)\n+        if unit == TimeUnit_SECOND:\n+            return datetime.timedelta(seconds=sp.value)\n+        elif unit == TimeUnit_MILLI:\n+            return datetime.timedelta(milliseconds=sp.value)\n+        elif unit == TimeUnit_MICRO:\n+            return datetime.timedelta(microseconds=sp.value)\n+        else:\n+            # TimeUnit_NANO: prefer pandas timestamps if available\n+            if _pandas_api.have_pandas:\n+                return _pandas_api.pd.Timedelta(sp.value, unit='ns')\n+            # otherwise safely truncate to microsecond resolution timedelta\n+            if sp.value % 1000 != 0:\n+                raise ValueError(\n+                    \"Nanosecond duration {} is not safely convertible to \"\n+                    \"microseconds to convert to datetime.timedelta. Install \"\n+                    \"pandas to return as Timedelta with nanosecond support or \"\n+                    \"access the .value attribute.\".format(sp.value)\n+                )\n+            return datetime.timedelta(microseconds=sp.value // 1000)\n \n \n-cdef class HalfFloatValue(ArrayValue):\n+cdef class BinaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for float16 array elements.\n+    Concrete class for binary-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def as_buffer(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return a view over this value as a Buffer object.\n         \"\"\"\n-        cdef CHalfFloatArray* ap = <CHalfFloatArray*> self.sp_array.get()\n-        return PyHalf_FromHalf(ap.Value(self.index))\n-\n-\n-cdef class FloatValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float32 array elements.\n-    \"\"\"\n+        cdef CBinaryScalar* sp = <CBinaryScalar*> self.wrapped.get()\n+        return pyarrow_wrap_buffer(sp.value) if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value as a Python bytes.\n         \"\"\"\n-        cdef CFloatArray* ap = <CFloatArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return self.as_buffer().to_pybytes()\n+        else:\n+            return None\n \n \n-cdef class DoubleValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float64 array elements.\n-    \"\"\"\n+cdef class LargeBinaryScalar(BinaryScalar):\n+    pass\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python float.\n-        \"\"\"\n-        cdef CDoubleArray* ap = <CDoubleArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+\n+cdef class FixedSizeBinaryScalar(BinaryScalar):\n+    pass\n \n \n-cdef class DecimalValue(ArrayValue):\n+cdef class StringScalar(BinaryScalar):\n     \"\"\"\n-    Concrete class for decimal128 array elements.\n+    Concrete class for string-like (utf8) scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python Decimal.\n+        Return this value as a Python string.\n         \"\"\"\n-        cdef:\n-            CDecimal128Array* ap = <CDecimal128Array*> self.sp_array.get()\n-            c_string s = ap.FormatValue(self.index)\n-        return _pydecimal.Decimal(s.decode('utf8'))\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return frombytes(self.as_buffer().to_pybytes())\n+        else:\n+            return None\n+\n \n+cdef class LargeStringScalar(StringScalar):\n+    pass\n \n-cdef class StringValue(ArrayValue):\n+\n+cdef class ListScalar(Scalar):\n     \"\"\"\n-    Concrete class for string (utf8) array elements.\n+    Concrete class for list-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    @property\n+    def values(self):\n+        cdef CListScalar* sp = <CListScalar*> self.wrapped.get()\n+        if sp.is_valid:\n+            return pyarrow_wrap_array(sp.value)\n+        else:\n+            return None\n+\n+    def __len__(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Return the number of values.\n         \"\"\"\n-        cdef CStringArray* ap = <CStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        return len(self.values)\n \n-    def as_buffer(self):\n+    def __getitem__(self, i):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return the value at the given index.\n         \"\"\"\n-        cdef:\n-            CStringArray* ap = <CStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n-\n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n-\n+        return self.values[_normalize_index(i, len(self))]\n \n-cdef class LargeStringValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large string (utf8) array elements.\n-    \"\"\"\n-\n-    def as_py(self):\n+    def __iter__(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Iterate over this element's values.\n         \"\"\"\n-        cdef CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        return iter(self.values)\n \n-    def as_buffer(self):\n+    def as_py(self):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return this value as a Python list.\n         \"\"\"\n-        cdef:\n-            CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+        arr = self.values\n+        return None if arr is None else arr.to_pylist()\n+\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+cdef class FixedSizeListScalar(ListScalar):\n+    pass\n \n \n-cdef class BinaryValue(ArrayValue):\n+cdef class LargeListScalar(ListScalar):\n+    pass\n+\n+\n+cdef class StructScalar(Scalar, collections.abc.Mapping):\n     \"\"\"\n-    Concrete class for variable-sized binary array elements.\n+    Concrete class for struct scalars.\n     \"\"\"\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python bytes object.\n-        \"\"\"\n+    def __len__(self):\n+        cdef CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+        return sp.value.size()\n+\n+    def __iter__(self):\n         cdef:\n-            const uint8_t* ptr\n-            int32_t length\n-            CBinaryArray* ap = <CBinaryArray*> self.sp_array.get()\n+            CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+            CStructType* dtype = <CStructType*> sp.type.get()\n+            vector[shared_ptr[CField]] fields = dtype.fields()\n \n-        ptr = ap.GetValue(self.index, &length)\n-        return cp.PyBytes_FromStringAndSize(<const char*>(ptr), length)\n+        if sp.is_valid:\n+            for i in range(dtype.num_fields()):\n+                yield frombytes(fields[i].get().name())\n \n-    def as_buffer(self):\n+    def __contains__(self, key):\n+        try:\n+            self[key]\n+        except IndexError:\n+            return False\n+        else:\n+            return True\n+\n+    def __getitem__(self, key):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return the child value for the given field.\n+\n+        Parameters\n+        ----------\n+        index : Union[int, str]\n+            Index / position or name of the field.\n+\n+        Returns\n+        -------\n+        result : Scalar\n         \"\"\"\n         cdef:\n-            CBinaryArray* ap = <CBinaryArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+            CFieldRef ref\n+            CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+        if isinstance(key, (bytes, str)):\n+            ref = CFieldRef(<c_string> tobytes(key))\n+        elif isinstance(key, int):\n+            ref = CFieldRef(<int> key)\n+        else:\n+            raise TypeError('Expected integer or string index')\n \n-\n-cdef class LargeBinaryValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large variable-sized binary array elements.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python bytes object.\n-        \"\"\"\n-        cdef:\n-            const uint8_t* ptr\n-            int64_t length\n-            CLargeBinaryArray* ap = <CLargeBinaryArray*> self.sp_array.get()\n-\n-        ptr = ap.GetValue(self.index, &length)\n-        return cp.PyBytes_FromStringAndSize(<const char*>(ptr), length)\n-\n-    def as_buffer(self):\n-        \"\"\"\n-        Return a view over this value as a Buffer object.\n-        \"\"\"\n-        cdef:\n-            CLargeBinaryArray* ap = <CLargeBinaryArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n-\n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n-\n-\n-cdef class ListValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for list array elements.\n-    \"\"\"\n-\n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n-    def __getitem__(self, i):\n-        \"\"\"\n-        Return the value at the given index.\n-        \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n-\n-    def __iter__(self):\n-        \"\"\"\n-        Iterate over this element's values.\n-        \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CListArray*> sp_array.get()\n-        self.value_type = pyarrow_wrap_data_type(self.ap.value_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return box_scalar(self.value_type, self.ap.values(), j)\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python list.\n-        \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            result.append(self.getitem(j).as_py())\n-\n-        return result\n-\n-\n-cdef class LargeListValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large list array elements.\n-    \"\"\"\n-\n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n-    def __getitem__(self, i):\n-        \"\"\"\n-        Return the value at the given index.\n-        \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n-\n-    def __iter__(self):\n-        \"\"\"\n-        Iterate over this element's values.\n-        \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CLargeListArray*> sp_array.get()\n-        self.value_type = pyarrow_wrap_data_type(self.ap.value_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return box_scalar(self.value_type, self.ap.values(), j)\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python list.\n-        \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            result.append(self.getitem(j).as_py())\n-\n-        return result\n-\n-\n-cdef class MapValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for map array elements.\n-    \"\"\"\n-\n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n-    def __getitem__(self, i):\n-        \"\"\"\n-        Return the value at the given index.\n-        \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n-\n-    def __iter__(self):\n-        \"\"\"\n-        Iterate over this element's values.\n-        \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CMapArray*> sp_array.get()\n-        self.key_type = pyarrow_wrap_data_type(self.ap.map_type().key_type())\n-        self.item_type = pyarrow_wrap_data_type(self.ap.map_type().item_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return (box_scalar(self.key_type, self.ap.keys(), j),\n-                box_scalar(self.item_type, self.ap.items(), j))\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n+        try:\n+            return Scalar.wrap(GetResultValue(sp.field(ref)))\n+        except ArrowInvalid:\n+            raise IndexError(key)\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python list of tuples, each containing a\n-        key and item.\n+        Return this value as a Python dict.\n         \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            key, item = self.getitem(j)\n-            result.append((key.as_py(), item.as_py()))\n-\n-        return result\n+        if self.is_valid:\n+            return {k: v.as_py() for k, v in self.items()}\n+        else:\n+            return None\n \n \n-cdef class FixedSizeListValue(ArrayValue):\n+cdef class MapScalar(ListScalar):\n\nReview comment:\n       Same inheritance problem.\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def __eq__(self, other):\n+        if hasattr(self, 'as_py'):\n+            if isinstance(other, Scalar):\n+                other = other.as_py()\n+            return self.as_py() == other\n+        else:\n+            raise NotImplementedError\n+\n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n+\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class Decimal128Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value // 1000)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n         else:\n             tzinfo = None\n \n-        try:\n-            converter = _datetime_conversion_functions()[dtype.unit()]\n-        except KeyError:\n-            raise ValueError(\n-                'Cannot convert nanosecond timestamps without pandas'\n-            )\n-        return converter(value, tzinfo=tzinfo)\n-\n-\n-cdef dict _TIMEDELTA_CONVERSION_FUNCTIONS = {}\n-\n-\n-def _nanoseconds_to_timedelta_safe(v):\n-    if v % 1000 != 0:\n-        raise ValueError(\n-            \"Nanosecond duration {} is not safely convertible to microseconds \"\n-            \"to convert to datetime.timedelta. Install pandas to return as \"\n-            \"Timedelta with nanosecond support or access the .value \"\n-            \"attribute.\".format(v))\n-    micros = v // 1000\n-\n-    return datetime.timedelta(microseconds=micros)\n-\n-\n-def _timedelta_conversion_functions():\n-    if _TIMEDELTA_CONVERSION_FUNCTIONS:\n-        return _TIMEDELTA_CONVERSION_FUNCTIONS\n-\n-    _TIMEDELTA_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: lambda v: datetime.timedelta(seconds=v),\n-        TimeUnit_MILLI: lambda v: datetime.timedelta(milliseconds=v),\n-        TimeUnit_MICRO: lambda v: datetime.timedelta(microseconds=v),\n-        TimeUnit_NANO: _nanoseconds_to_timedelta_safe\n-    })\n-\n-    try:\n-        import pandas as pd\n-        _TIMEDELTA_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda v: pd.Timedelta(v, unit='ns')\n-        )\n-    except ImportError:\n-        pass\n+        return _datetime_from_int(sp.value, unit=dtype.unit(), tzinfo=tzinfo)\n \n-    return _TIMEDELTA_CONVERSION_FUNCTIONS\n \n-\n-cdef class DurationValue(ArrayValue):\n+cdef class DurationScalar(Scalar):\n     \"\"\"\n-    Concrete class for duration array elements.\n+    Concrete class for duration scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        cdef CDurationType* dtype = <CDurationType*> ap.type().get()\n+        cdef:\n+            CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+            CDurationType* dtype = <CDurationType*> sp.type.get()\n+            TimeUnit unit = dtype.unit()\n+\n+        if not sp.is_valid:\n+            return None\n \n-        cdef int64_t value = ap.Value(self.index)\n-        converter = _timedelta_conversion_functions()[dtype.unit()]\n-        return converter(value)\n+        if unit == TimeUnit_SECOND:\n+            return datetime.timedelta(seconds=sp.value)\n+        elif unit == TimeUnit_MILLI:\n+            return datetime.timedelta(milliseconds=sp.value)\n+        elif unit == TimeUnit_MICRO:\n+            return datetime.timedelta(microseconds=sp.value)\n+        else:\n+            # TimeUnit_NANO: prefer pandas timestamps if available\n+            if _pandas_api.have_pandas:\n+                return _pandas_api.pd.Timedelta(sp.value, unit='ns')\n+            # otherwise safely truncate to microsecond resolution timedelta\n+            if sp.value % 1000 != 0:\n+                raise ValueError(\n+                    \"Nanosecond duration {} is not safely convertible to \"\n+                    \"microseconds to convert to datetime.timedelta. Install \"\n+                    \"pandas to return as Timedelta with nanosecond support or \"\n+                    \"access the .value attribute.\".format(sp.value)\n+                )\n+            return datetime.timedelta(microseconds=sp.value // 1000)\n \n \n-cdef class HalfFloatValue(ArrayValue):\n+cdef class BinaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for float16 array elements.\n+    Concrete class for binary-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def as_buffer(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return a view over this value as a Buffer object.\n         \"\"\"\n-        cdef CHalfFloatArray* ap = <CHalfFloatArray*> self.sp_array.get()\n-        return PyHalf_FromHalf(ap.Value(self.index))\n-\n-\n-cdef class FloatValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float32 array elements.\n-    \"\"\"\n+        cdef CBinaryScalar* sp = <CBinaryScalar*> self.wrapped.get()\n+        return pyarrow_wrap_buffer(sp.value) if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value as a Python bytes.\n         \"\"\"\n-        cdef CFloatArray* ap = <CFloatArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return self.as_buffer().to_pybytes()\n+        else:\n+            return None\n \n \n-cdef class DoubleValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float64 array elements.\n-    \"\"\"\n+cdef class LargeBinaryScalar(BinaryScalar):\n+    pass\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python float.\n-        \"\"\"\n-        cdef CDoubleArray* ap = <CDoubleArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+\n+cdef class FixedSizeBinaryScalar(BinaryScalar):\n+    pass\n \n \n-cdef class DecimalValue(ArrayValue):\n+cdef class StringScalar(BinaryScalar):\n\nReview comment:\n       Same here.\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -1217,21 +764,50 @@ cdef dict _scalar_classes = {\n     _Type_INT16: Int16Scalar,\n     _Type_INT32: Int32Scalar,\n     _Type_INT64: Int64Scalar,\n+    _Type_HALF_FLOAT: HalfFloatScalar,\n     _Type_FLOAT: FloatScalar,\n     _Type_DOUBLE: DoubleScalar,\n+    _Type_DECIMAL: Decimal128Scalar,\n+    _Type_DATE32: Date32Scalar,\n+    _Type_DATE64: Date64Scalar,\n+    _Type_TIME32: Time32Scalar,\n+    _Type_TIME64: Time64Scalar,\n+    _Type_TIMESTAMP: TimestampScalar,\n+    _Type_DURATION: DurationScalar,\n+    _Type_BINARY: BinaryScalar,\n+    _Type_LARGE_BINARY: LargeBinaryScalar,\n+    _Type_FIXED_SIZE_BINARY: FixedSizeBinaryScalar,\n     _Type_STRING: StringScalar,\n+    _Type_LARGE_STRING: LargeStringScalar,\n+    _Type_LIST: ListScalar,\n+    _Type_LARGE_LIST: LargeListScalar,\n+    _Type_FIXED_SIZE_LIST: FixedSizeListScalar,\n+    _Type_STRUCT: StructScalar,\n+    _Type_MAP: MapScalar,\n+    _Type_DICTIONARY: DictionaryScalar,\n+    _Type_SPARSE_UNION: UnionScalar,\n+    _Type_DENSE_UNION: UnionScalar,\n }\n \n-cdef object box_scalar(DataType type, const shared_ptr[CArray]& sp_array,\n-                       int64_t index):\n-    cdef ArrayValue value\n \n-    if type.type.id() == _Type_NA:\n-        return _NULL\n-    elif sp_array.get().IsNull(index):\n-        return _NULL\n-    else:\n-        klass = _array_value_classes[type.type.id()]\n-        value = klass.__new__(klass)\n-        value.init(type, sp_array, index)\n-        return value\n+def scalar(value, DataType type=None, bint safe=True,\n\nReview comment:\n       It seems `safe` isn't used btw.\n\n##########\nFile path: python/pyarrow/tests/test_scalars.py\n##########\n@@ -16,427 +16,443 @@\n # under the License.\n \n import datetime\n+import decimal\n import pytest\n-import unittest\n \n import numpy as np\n \n import pyarrow as pa\n \n \n-class TestScalars(unittest.TestCase):\n-\n-    def test_null_singleton(self):\n-        with pytest.raises(Exception):\n-            pa.NAType()\n+@pytest.mark.parametrize(['value', 'ty', 'klass', 'deprecated'], [\n+    (False, None, pa.BooleanScalar, pa.BooleanValue),\n+    (True, None, pa.BooleanScalar, pa.BooleanValue),\n+    (1, None, pa.Int64Scalar, pa.Int64Value),\n+    (-1, None, pa.Int64Scalar, pa.Int64Value),\n+    (1, pa.int8(), pa.Int8Scalar, pa.Int8Value),\n+    (1, pa.uint8(), pa.UInt8Scalar, pa.UInt8Value),\n+    (1, pa.int16(), pa.Int16Scalar, pa.Int16Value),\n+    (1, pa.uint16(), pa.UInt16Scalar, pa.UInt16Value),\n+    (1, pa.int32(), pa.Int32Scalar, pa.Int32Value),\n+    (1, pa.uint32(), pa.UInt32Scalar, pa.UInt32Value),\n+    (1, pa.int64(), pa.Int64Scalar, pa.Int64Value),\n+    (1, pa.uint64(), pa.UInt64Scalar, pa.UInt64Value),\n+    (1.0, None, pa.DoubleScalar, pa.DoubleValue),\n+    (np.float16(1.0), pa.float16(), pa.HalfFloatScalar, pa.HalfFloatValue),\n+    (1.0, pa.float32(), pa.FloatScalar, pa.FloatValue),\n+    (\"string\", None, pa.StringScalar, pa.StringValue),\n+    (b\"bytes\", None, pa.BinaryScalar, pa.BinaryValue),\n+    ([1, 2, 3], None, pa.ListScalar, pa.ListValue),\n+    ([1, 2, 3, 4], pa.large_list(pa.int8()), pa.LargeListScalar,\n+     pa.LargeListValue),\n+    (datetime.date.today(), None, pa.Date32Scalar, pa.Date64Value),\n+    (datetime.datetime.now(), None, pa.TimestampScalar, pa.TimestampValue),\n+    ({'a': 1, 'b': [1, 2]}, None, pa.StructScalar, pa.StructValue)\n+])\n+def test_basics(value, ty, klass, deprecated):\n+    s = pa.scalar(value, type=ty)\n+    assert isinstance(s, klass)\n+    assert s == value\n+    assert s == s\n+    assert s != \"else\"\n+    assert hash(s) == hash(s)\n+    assert s.is_valid is True\n+    with pytest.warns(FutureWarning):\n+        isinstance(s, deprecated)\n+\n+    s = pa.scalar(None, type=s.type)\n+    assert s.is_valid is False\n+    assert s.as_py() is None\n+\n+\n+def test_null_singleton():\n+    with pytest.raises(Exception):\n+        pa.NullScalar()\n+\n+\n+def test_nulls():\n+    null = pa.scalar(None)\n+    assert null is pa.NA\n+    assert null.as_py() is None\n+    assert (null == \"something\") is pa.NA\n\nReview comment:\n       Also `assert null == pa.scalar(None)`\n\n##########\nFile path: python/pyarrow/tests/test_scalars.py\n##########\n@@ -16,427 +16,443 @@\n # under the License.\n \n import datetime\n+import decimal\n import pytest\n-import unittest\n \n import numpy as np\n \n import pyarrow as pa\n \n \n-class TestScalars(unittest.TestCase):\n-\n-    def test_null_singleton(self):\n-        with pytest.raises(Exception):\n-            pa.NAType()\n+@pytest.mark.parametrize(['value', 'ty', 'klass', 'deprecated'], [\n+    (False, None, pa.BooleanScalar, pa.BooleanValue),\n+    (True, None, pa.BooleanScalar, pa.BooleanValue),\n+    (1, None, pa.Int64Scalar, pa.Int64Value),\n+    (-1, None, pa.Int64Scalar, pa.Int64Value),\n+    (1, pa.int8(), pa.Int8Scalar, pa.Int8Value),\n+    (1, pa.uint8(), pa.UInt8Scalar, pa.UInt8Value),\n+    (1, pa.int16(), pa.Int16Scalar, pa.Int16Value),\n+    (1, pa.uint16(), pa.UInt16Scalar, pa.UInt16Value),\n+    (1, pa.int32(), pa.Int32Scalar, pa.Int32Value),\n+    (1, pa.uint32(), pa.UInt32Scalar, pa.UInt32Value),\n+    (1, pa.int64(), pa.Int64Scalar, pa.Int64Value),\n+    (1, pa.uint64(), pa.UInt64Scalar, pa.UInt64Value),\n+    (1.0, None, pa.DoubleScalar, pa.DoubleValue),\n+    (np.float16(1.0), pa.float16(), pa.HalfFloatScalar, pa.HalfFloatValue),\n+    (1.0, pa.float32(), pa.FloatScalar, pa.FloatValue),\n+    (\"string\", None, pa.StringScalar, pa.StringValue),\n+    (b\"bytes\", None, pa.BinaryScalar, pa.BinaryValue),\n+    ([1, 2, 3], None, pa.ListScalar, pa.ListValue),\n+    ([1, 2, 3, 4], pa.large_list(pa.int8()), pa.LargeListScalar,\n+     pa.LargeListValue),\n+    (datetime.date.today(), None, pa.Date32Scalar, pa.Date64Value),\n+    (datetime.datetime.now(), None, pa.TimestampScalar, pa.TimestampValue),\n+    ({'a': 1, 'b': [1, 2]}, None, pa.StructScalar, pa.StructValue)\n+])\n+def test_basics(value, ty, klass, deprecated):\n+    s = pa.scalar(value, type=ty)\n+    assert isinstance(s, klass)\n+    assert s == value\n+    assert s == s\n+    assert s != \"else\"\n+    assert hash(s) == hash(s)\n+    assert s.is_valid is True\n+    with pytest.warns(FutureWarning):\n+        isinstance(s, deprecated)\n+\n+    s = pa.scalar(None, type=s.type)\n+    assert s.is_valid is False\n+    assert s.as_py() is None\n+\n+\n+def test_null_singleton():\n+    with pytest.raises(Exception):\n\nReview comment:\n       You should a test more precise exception.\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -1217,21 +764,50 @@ cdef dict _scalar_classes = {\n     _Type_INT16: Int16Scalar,\n     _Type_INT32: Int32Scalar,\n     _Type_INT64: Int64Scalar,\n+    _Type_HALF_FLOAT: HalfFloatScalar,\n     _Type_FLOAT: FloatScalar,\n     _Type_DOUBLE: DoubleScalar,\n+    _Type_DECIMAL: Decimal128Scalar,\n+    _Type_DATE32: Date32Scalar,\n+    _Type_DATE64: Date64Scalar,\n+    _Type_TIME32: Time32Scalar,\n+    _Type_TIME64: Time64Scalar,\n+    _Type_TIMESTAMP: TimestampScalar,\n+    _Type_DURATION: DurationScalar,\n+    _Type_BINARY: BinaryScalar,\n+    _Type_LARGE_BINARY: LargeBinaryScalar,\n+    _Type_FIXED_SIZE_BINARY: FixedSizeBinaryScalar,\n     _Type_STRING: StringScalar,\n+    _Type_LARGE_STRING: LargeStringScalar,\n+    _Type_LIST: ListScalar,\n+    _Type_LARGE_LIST: LargeListScalar,\n+    _Type_FIXED_SIZE_LIST: FixedSizeListScalar,\n+    _Type_STRUCT: StructScalar,\n+    _Type_MAP: MapScalar,\n+    _Type_DICTIONARY: DictionaryScalar,\n+    _Type_SPARSE_UNION: UnionScalar,\n+    _Type_DENSE_UNION: UnionScalar,\n }\n \n-cdef object box_scalar(DataType type, const shared_ptr[CArray]& sp_array,\n-                       int64_t index):\n-    cdef ArrayValue value\n \n-    if type.type.id() == _Type_NA:\n-        return _NULL\n-    elif sp_array.get().IsNull(index):\n-        return _NULL\n-    else:\n-        klass = _array_value_classes[type.type.id()]\n-        value = klass.__new__(klass)\n-        value.init(type, sp_array, index)\n-        return value\n+def scalar(value, DataType type=None, bint safe=True,\n+           MemoryPool memory_pool=None):\n+    cdef:\n+        PyConversionOptions options\n+        shared_ptr[CScalar] scalar\n+        shared_ptr[CArray] array\n+        shared_ptr[CChunkedArray] chunked\n+\n+    options.size = 1\n+    options.pool = maybe_unbox_memory_pool(memory_pool)\n+    # options.from_pandas = from_pandas\n\nReview comment:\n       What?\n\n##########\nFile path: python/pyarrow/tests/test_scalars.py\n##########\n@@ -16,427 +16,443 @@\n # under the License.\n \n import datetime\n+import decimal\n import pytest\n-import unittest\n \n import numpy as np\n \n import pyarrow as pa\n \n \n-class TestScalars(unittest.TestCase):\n-\n-    def test_null_singleton(self):\n-        with pytest.raises(Exception):\n-            pa.NAType()\n+@pytest.mark.parametrize(['value', 'ty', 'klass', 'deprecated'], [\n+    (False, None, pa.BooleanScalar, pa.BooleanValue),\n+    (True, None, pa.BooleanScalar, pa.BooleanValue),\n+    (1, None, pa.Int64Scalar, pa.Int64Value),\n+    (-1, None, pa.Int64Scalar, pa.Int64Value),\n+    (1, pa.int8(), pa.Int8Scalar, pa.Int8Value),\n+    (1, pa.uint8(), pa.UInt8Scalar, pa.UInt8Value),\n+    (1, pa.int16(), pa.Int16Scalar, pa.Int16Value),\n+    (1, pa.uint16(), pa.UInt16Scalar, pa.UInt16Value),\n+    (1, pa.int32(), pa.Int32Scalar, pa.Int32Value),\n+    (1, pa.uint32(), pa.UInt32Scalar, pa.UInt32Value),\n+    (1, pa.int64(), pa.Int64Scalar, pa.Int64Value),\n+    (1, pa.uint64(), pa.UInt64Scalar, pa.UInt64Value),\n+    (1.0, None, pa.DoubleScalar, pa.DoubleValue),\n+    (np.float16(1.0), pa.float16(), pa.HalfFloatScalar, pa.HalfFloatValue),\n+    (1.0, pa.float32(), pa.FloatScalar, pa.FloatValue),\n+    (\"string\", None, pa.StringScalar, pa.StringValue),\n+    (b\"bytes\", None, pa.BinaryScalar, pa.BinaryValue),\n+    ([1, 2, 3], None, pa.ListScalar, pa.ListValue),\n+    ([1, 2, 3, 4], pa.large_list(pa.int8()), pa.LargeListScalar,\n+     pa.LargeListValue),\n+    (datetime.date.today(), None, pa.Date32Scalar, pa.Date64Value),\n+    (datetime.datetime.now(), None, pa.TimestampScalar, pa.TimestampValue),\n+    ({'a': 1, 'b': [1, 2]}, None, pa.StructScalar, pa.StructValue)\n+])\n+def test_basics(value, ty, klass, deprecated):\n+    s = pa.scalar(value, type=ty)\n+    assert isinstance(s, klass)\n+    assert s == value\n+    assert s == s\n+    assert s != \"else\"\n+    assert hash(s) == hash(s)\n+    assert s.is_valid is True\n+    with pytest.warns(FutureWarning):\n+        isinstance(s, deprecated)\n+\n+    s = pa.scalar(None, type=s.type)\n+    assert s.is_valid is False\n+    assert s.as_py() is None\n+\n+\n+def test_null_singleton():\n+    with pytest.raises(Exception):\n+        pa.NullScalar()\n+\n+\n+def test_nulls():\n+    null = pa.scalar(None)\n+    assert null is pa.NA\n+    assert null.as_py() is None\n+    assert (null == \"something\") is pa.NA\n\nReview comment:\n       This looks incorrect and should return `False`.\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def __eq__(self, other):\n+        if hasattr(self, 'as_py'):\n+            if isinstance(other, Scalar):\n+                other = other.as_py()\n+            return self.as_py() == other\n+        else:\n+            raise NotImplementedError\n+\n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n+\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class Decimal128Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value // 1000)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n         else:\n             tzinfo = None\n \n-        try:\n-            converter = _datetime_conversion_functions()[dtype.unit()]\n-        except KeyError:\n-            raise ValueError(\n-                'Cannot convert nanosecond timestamps without pandas'\n-            )\n-        return converter(value, tzinfo=tzinfo)\n-\n-\n-cdef dict _TIMEDELTA_CONVERSION_FUNCTIONS = {}\n-\n-\n-def _nanoseconds_to_timedelta_safe(v):\n-    if v % 1000 != 0:\n-        raise ValueError(\n-            \"Nanosecond duration {} is not safely convertible to microseconds \"\n-            \"to convert to datetime.timedelta. Install pandas to return as \"\n-            \"Timedelta with nanosecond support or access the .value \"\n-            \"attribute.\".format(v))\n-    micros = v // 1000\n-\n-    return datetime.timedelta(microseconds=micros)\n-\n-\n-def _timedelta_conversion_functions():\n-    if _TIMEDELTA_CONVERSION_FUNCTIONS:\n-        return _TIMEDELTA_CONVERSION_FUNCTIONS\n-\n-    _TIMEDELTA_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: lambda v: datetime.timedelta(seconds=v),\n-        TimeUnit_MILLI: lambda v: datetime.timedelta(milliseconds=v),\n-        TimeUnit_MICRO: lambda v: datetime.timedelta(microseconds=v),\n-        TimeUnit_NANO: _nanoseconds_to_timedelta_safe\n-    })\n-\n-    try:\n-        import pandas as pd\n-        _TIMEDELTA_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda v: pd.Timedelta(v, unit='ns')\n-        )\n-    except ImportError:\n-        pass\n+        return _datetime_from_int(sp.value, unit=dtype.unit(), tzinfo=tzinfo)\n \n-    return _TIMEDELTA_CONVERSION_FUNCTIONS\n \n-\n-cdef class DurationValue(ArrayValue):\n+cdef class DurationScalar(Scalar):\n     \"\"\"\n-    Concrete class for duration array elements.\n+    Concrete class for duration scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        cdef CDurationType* dtype = <CDurationType*> ap.type().get()\n+        cdef:\n+            CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+            CDurationType* dtype = <CDurationType*> sp.type.get()\n+            TimeUnit unit = dtype.unit()\n+\n+        if not sp.is_valid:\n+            return None\n \n-        cdef int64_t value = ap.Value(self.index)\n-        converter = _timedelta_conversion_functions()[dtype.unit()]\n-        return converter(value)\n+        if unit == TimeUnit_SECOND:\n+            return datetime.timedelta(seconds=sp.value)\n+        elif unit == TimeUnit_MILLI:\n+            return datetime.timedelta(milliseconds=sp.value)\n+        elif unit == TimeUnit_MICRO:\n+            return datetime.timedelta(microseconds=sp.value)\n+        else:\n+            # TimeUnit_NANO: prefer pandas timestamps if available\n+            if _pandas_api.have_pandas:\n+                return _pandas_api.pd.Timedelta(sp.value, unit='ns')\n+            # otherwise safely truncate to microsecond resolution timedelta\n+            if sp.value % 1000 != 0:\n+                raise ValueError(\n+                    \"Nanosecond duration {} is not safely convertible to \"\n+                    \"microseconds to convert to datetime.timedelta. Install \"\n+                    \"pandas to return as Timedelta with nanosecond support or \"\n+                    \"access the .value attribute.\".format(sp.value)\n+                )\n+            return datetime.timedelta(microseconds=sp.value // 1000)\n \n \n-cdef class HalfFloatValue(ArrayValue):\n+cdef class BinaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for float16 array elements.\n+    Concrete class for binary-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def as_buffer(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return a view over this value as a Buffer object.\n         \"\"\"\n-        cdef CHalfFloatArray* ap = <CHalfFloatArray*> self.sp_array.get()\n-        return PyHalf_FromHalf(ap.Value(self.index))\n-\n-\n-cdef class FloatValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float32 array elements.\n-    \"\"\"\n+        cdef CBinaryScalar* sp = <CBinaryScalar*> self.wrapped.get()\n+        return pyarrow_wrap_buffer(sp.value) if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value as a Python bytes.\n         \"\"\"\n-        cdef CFloatArray* ap = <CFloatArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return self.as_buffer().to_pybytes()\n+        else:\n+            return None\n \n \n-cdef class DoubleValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float64 array elements.\n-    \"\"\"\n+cdef class LargeBinaryScalar(BinaryScalar):\n+    pass\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python float.\n-        \"\"\"\n-        cdef CDoubleArray* ap = <CDoubleArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+\n+cdef class FixedSizeBinaryScalar(BinaryScalar):\n+    pass\n \n \n-cdef class DecimalValue(ArrayValue):\n+cdef class StringScalar(BinaryScalar):\n     \"\"\"\n-    Concrete class for decimal128 array elements.\n+    Concrete class for string-like (utf8) scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python Decimal.\n+        Return this value as a Python string.\n         \"\"\"\n-        cdef:\n-            CDecimal128Array* ap = <CDecimal128Array*> self.sp_array.get()\n-            c_string s = ap.FormatValue(self.index)\n-        return _pydecimal.Decimal(s.decode('utf8'))\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return frombytes(self.as_buffer().to_pybytes())\n+        else:\n+            return None\n+\n \n+cdef class LargeStringScalar(StringScalar):\n\nReview comment:\n       Same here.\r\n   \n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def __eq__(self, other):\n+        if hasattr(self, 'as_py'):\n+            if isinstance(other, Scalar):\n+                other = other.as_py()\n+            return self.as_py() == other\n+        else:\n+            raise NotImplementedError\n+\n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n+\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class Decimal128Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value // 1000)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n         else:\n             tzinfo = None\n \n-        try:\n-            converter = _datetime_conversion_functions()[dtype.unit()]\n-        except KeyError:\n-            raise ValueError(\n-                'Cannot convert nanosecond timestamps without pandas'\n-            )\n-        return converter(value, tzinfo=tzinfo)\n-\n-\n-cdef dict _TIMEDELTA_CONVERSION_FUNCTIONS = {}\n-\n-\n-def _nanoseconds_to_timedelta_safe(v):\n-    if v % 1000 != 0:\n-        raise ValueError(\n-            \"Nanosecond duration {} is not safely convertible to microseconds \"\n-            \"to convert to datetime.timedelta. Install pandas to return as \"\n-            \"Timedelta with nanosecond support or access the .value \"\n-            \"attribute.\".format(v))\n-    micros = v // 1000\n-\n-    return datetime.timedelta(microseconds=micros)\n-\n-\n-def _timedelta_conversion_functions():\n-    if _TIMEDELTA_CONVERSION_FUNCTIONS:\n-        return _TIMEDELTA_CONVERSION_FUNCTIONS\n-\n-    _TIMEDELTA_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: lambda v: datetime.timedelta(seconds=v),\n-        TimeUnit_MILLI: lambda v: datetime.timedelta(milliseconds=v),\n-        TimeUnit_MICRO: lambda v: datetime.timedelta(microseconds=v),\n-        TimeUnit_NANO: _nanoseconds_to_timedelta_safe\n-    })\n-\n-    try:\n-        import pandas as pd\n-        _TIMEDELTA_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda v: pd.Timedelta(v, unit='ns')\n-        )\n-    except ImportError:\n-        pass\n+        return _datetime_from_int(sp.value, unit=dtype.unit(), tzinfo=tzinfo)\n \n-    return _TIMEDELTA_CONVERSION_FUNCTIONS\n \n-\n-cdef class DurationValue(ArrayValue):\n+cdef class DurationScalar(Scalar):\n     \"\"\"\n-    Concrete class for duration array elements.\n+    Concrete class for duration scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        cdef CDurationType* dtype = <CDurationType*> ap.type().get()\n+        cdef:\n+            CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+            CDurationType* dtype = <CDurationType*> sp.type.get()\n+            TimeUnit unit = dtype.unit()\n+\n+        if not sp.is_valid:\n+            return None\n \n-        cdef int64_t value = ap.Value(self.index)\n-        converter = _timedelta_conversion_functions()[dtype.unit()]\n-        return converter(value)\n+        if unit == TimeUnit_SECOND:\n+            return datetime.timedelta(seconds=sp.value)\n+        elif unit == TimeUnit_MILLI:\n+            return datetime.timedelta(milliseconds=sp.value)\n+        elif unit == TimeUnit_MICRO:\n+            return datetime.timedelta(microseconds=sp.value)\n+        else:\n+            # TimeUnit_NANO: prefer pandas timestamps if available\n+            if _pandas_api.have_pandas:\n+                return _pandas_api.pd.Timedelta(sp.value, unit='ns')\n+            # otherwise safely truncate to microsecond resolution timedelta\n+            if sp.value % 1000 != 0:\n+                raise ValueError(\n+                    \"Nanosecond duration {} is not safely convertible to \"\n+                    \"microseconds to convert to datetime.timedelta. Install \"\n+                    \"pandas to return as Timedelta with nanosecond support or \"\n+                    \"access the .value attribute.\".format(sp.value)\n+                )\n+            return datetime.timedelta(microseconds=sp.value // 1000)\n \n \n-cdef class HalfFloatValue(ArrayValue):\n+cdef class BinaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for float16 array elements.\n+    Concrete class for binary-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def as_buffer(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return a view over this value as a Buffer object.\n         \"\"\"\n-        cdef CHalfFloatArray* ap = <CHalfFloatArray*> self.sp_array.get()\n-        return PyHalf_FromHalf(ap.Value(self.index))\n-\n-\n-cdef class FloatValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float32 array elements.\n-    \"\"\"\n+        cdef CBinaryScalar* sp = <CBinaryScalar*> self.wrapped.get()\n+        return pyarrow_wrap_buffer(sp.value) if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value as a Python bytes.\n         \"\"\"\n-        cdef CFloatArray* ap = <CFloatArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return self.as_buffer().to_pybytes()\n\nReview comment:\n       `buffer.to_pybytes()`\n\n##########\nFile path: python/pyarrow/tests/test_scalars.py\n##########\n@@ -16,427 +16,443 @@\n # under the License.\n \n import datetime\n+import decimal\n import pytest\n-import unittest\n \n import numpy as np\n \n import pyarrow as pa\n \n \n-class TestScalars(unittest.TestCase):\n-\n-    def test_null_singleton(self):\n-        with pytest.raises(Exception):\n-            pa.NAType()\n+@pytest.mark.parametrize(['value', 'ty', 'klass', 'deprecated'], [\n+    (False, None, pa.BooleanScalar, pa.BooleanValue),\n+    (True, None, pa.BooleanScalar, pa.BooleanValue),\n+    (1, None, pa.Int64Scalar, pa.Int64Value),\n+    (-1, None, pa.Int64Scalar, pa.Int64Value),\n+    (1, pa.int8(), pa.Int8Scalar, pa.Int8Value),\n+    (1, pa.uint8(), pa.UInt8Scalar, pa.UInt8Value),\n+    (1, pa.int16(), pa.Int16Scalar, pa.Int16Value),\n+    (1, pa.uint16(), pa.UInt16Scalar, pa.UInt16Value),\n+    (1, pa.int32(), pa.Int32Scalar, pa.Int32Value),\n+    (1, pa.uint32(), pa.UInt32Scalar, pa.UInt32Value),\n+    (1, pa.int64(), pa.Int64Scalar, pa.Int64Value),\n+    (1, pa.uint64(), pa.UInt64Scalar, pa.UInt64Value),\n+    (1.0, None, pa.DoubleScalar, pa.DoubleValue),\n+    (np.float16(1.0), pa.float16(), pa.HalfFloatScalar, pa.HalfFloatValue),\n+    (1.0, pa.float32(), pa.FloatScalar, pa.FloatValue),\n+    (\"string\", None, pa.StringScalar, pa.StringValue),\n+    (b\"bytes\", None, pa.BinaryScalar, pa.BinaryValue),\n+    ([1, 2, 3], None, pa.ListScalar, pa.ListValue),\n+    ([1, 2, 3, 4], pa.large_list(pa.int8()), pa.LargeListScalar,\n+     pa.LargeListValue),\n+    (datetime.date.today(), None, pa.Date32Scalar, pa.Date64Value),\n+    (datetime.datetime.now(), None, pa.TimestampScalar, pa.TimestampValue),\n+    ({'a': 1, 'b': [1, 2]}, None, pa.StructScalar, pa.StructValue)\n+])\n+def test_basics(value, ty, klass, deprecated):\n+    s = pa.scalar(value, type=ty)\n+    assert isinstance(s, klass)\n+    assert s == value\n+    assert s == s\n\nReview comment:\n       It would be more interesting to instantiate `s` a second time, e.g. `assert s == pa.scalar(value, type=ty)`\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -1217,21 +764,50 @@ cdef dict _scalar_classes = {\n     _Type_INT16: Int16Scalar,\n     _Type_INT32: Int32Scalar,\n     _Type_INT64: Int64Scalar,\n+    _Type_HALF_FLOAT: HalfFloatScalar,\n     _Type_FLOAT: FloatScalar,\n     _Type_DOUBLE: DoubleScalar,\n+    _Type_DECIMAL: Decimal128Scalar,\n+    _Type_DATE32: Date32Scalar,\n+    _Type_DATE64: Date64Scalar,\n+    _Type_TIME32: Time32Scalar,\n+    _Type_TIME64: Time64Scalar,\n+    _Type_TIMESTAMP: TimestampScalar,\n+    _Type_DURATION: DurationScalar,\n+    _Type_BINARY: BinaryScalar,\n+    _Type_LARGE_BINARY: LargeBinaryScalar,\n+    _Type_FIXED_SIZE_BINARY: FixedSizeBinaryScalar,\n     _Type_STRING: StringScalar,\n+    _Type_LARGE_STRING: LargeStringScalar,\n+    _Type_LIST: ListScalar,\n+    _Type_LARGE_LIST: LargeListScalar,\n+    _Type_FIXED_SIZE_LIST: FixedSizeListScalar,\n+    _Type_STRUCT: StructScalar,\n+    _Type_MAP: MapScalar,\n+    _Type_DICTIONARY: DictionaryScalar,\n+    _Type_SPARSE_UNION: UnionScalar,\n+    _Type_DENSE_UNION: UnionScalar,\n }\n \n-cdef object box_scalar(DataType type, const shared_ptr[CArray]& sp_array,\n-                       int64_t index):\n-    cdef ArrayValue value\n \n-    if type.type.id() == _Type_NA:\n-        return _NULL\n-    elif sp_array.get().IsNull(index):\n-        return _NULL\n-    else:\n-        klass = _array_value_classes[type.type.id()]\n-        value = klass.__new__(klass)\n-        value.init(type, sp_array, index)\n-        return value\n+def scalar(value, DataType type=None, bint safe=True,\n\nReview comment:\n       Can you add a docstring? Also, make `safe` and `memory_pool` keyword-only.\n\n##########\nFile path: python/pyarrow/tests/test_scalars.py\n##########\n@@ -16,427 +16,443 @@\n # under the License.\n \n import datetime\n+import decimal\n import pytest\n-import unittest\n \n import numpy as np\n \n import pyarrow as pa\n \n \n-class TestScalars(unittest.TestCase):\n-\n-    def test_null_singleton(self):\n-        with pytest.raises(Exception):\n-            pa.NAType()\n+@pytest.mark.parametrize(['value', 'ty', 'klass', 'deprecated'], [\n+    (False, None, pa.BooleanScalar, pa.BooleanValue),\n+    (True, None, pa.BooleanScalar, pa.BooleanValue),\n+    (1, None, pa.Int64Scalar, pa.Int64Value),\n+    (-1, None, pa.Int64Scalar, pa.Int64Value),\n+    (1, pa.int8(), pa.Int8Scalar, pa.Int8Value),\n+    (1, pa.uint8(), pa.UInt8Scalar, pa.UInt8Value),\n+    (1, pa.int16(), pa.Int16Scalar, pa.Int16Value),\n+    (1, pa.uint16(), pa.UInt16Scalar, pa.UInt16Value),\n+    (1, pa.int32(), pa.Int32Scalar, pa.Int32Value),\n+    (1, pa.uint32(), pa.UInt32Scalar, pa.UInt32Value),\n+    (1, pa.int64(), pa.Int64Scalar, pa.Int64Value),\n+    (1, pa.uint64(), pa.UInt64Scalar, pa.UInt64Value),\n+    (1.0, None, pa.DoubleScalar, pa.DoubleValue),\n+    (np.float16(1.0), pa.float16(), pa.HalfFloatScalar, pa.HalfFloatValue),\n+    (1.0, pa.float32(), pa.FloatScalar, pa.FloatValue),\n+    (\"string\", None, pa.StringScalar, pa.StringValue),\n+    (b\"bytes\", None, pa.BinaryScalar, pa.BinaryValue),\n+    ([1, 2, 3], None, pa.ListScalar, pa.ListValue),\n+    ([1, 2, 3, 4], pa.large_list(pa.int8()), pa.LargeListScalar,\n+     pa.LargeListValue),\n+    (datetime.date.today(), None, pa.Date32Scalar, pa.Date64Value),\n+    (datetime.datetime.now(), None, pa.TimestampScalar, pa.TimestampValue),\n+    ({'a': 1, 'b': [1, 2]}, None, pa.StructScalar, pa.StructValue)\n+])\n+def test_basics(value, ty, klass, deprecated):\n+    s = pa.scalar(value, type=ty)\n+    assert isinstance(s, klass)\n+    assert s == value\n+    assert s == s\n+    assert s != \"else\"\n+    assert hash(s) == hash(s)\n+    assert s.is_valid is True\n+    with pytest.warns(FutureWarning):\n+        isinstance(s, deprecated)\n+\n+    s = pa.scalar(None, type=s.type)\n+    assert s.is_valid is False\n+    assert s.as_py() is None\n\nReview comment:\n       Also `assert s != pa.scalar(value, type=ty)`\n\n##########\nFile path: python/pyarrow/tests/test_parquet.py\n##########\n@@ -2028,7 +2028,7 @@ def test_filters_invalid_pred_op(tempdir, use_legacy_dataset):\n                                     use_legacy_dataset=use_legacy_dataset)\n         assert dataset.read().num_rows == 0\n \n-    with pytest.raises(ValueError if use_legacy_dataset else TypeError):\n+    with pytest.raises(ValueError):\n         # dataset API returns TypeError when trying create invalid comparison\n\nReview comment:\n       Comment seems obsolete?\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def __eq__(self, other):\n+        if hasattr(self, 'as_py'):\n+            if isinstance(other, Scalar):\n+                other = other.as_py()\n+            return self.as_py() == other\n+        else:\n+            raise NotImplementedError\n+\n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n+\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class Decimal128Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value // 1000)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n         else:\n             tzinfo = None\n \n-        try:\n-            converter = _datetime_conversion_functions()[dtype.unit()]\n-        except KeyError:\n-            raise ValueError(\n-                'Cannot convert nanosecond timestamps without pandas'\n-            )\n-        return converter(value, tzinfo=tzinfo)\n-\n-\n-cdef dict _TIMEDELTA_CONVERSION_FUNCTIONS = {}\n-\n-\n-def _nanoseconds_to_timedelta_safe(v):\n-    if v % 1000 != 0:\n-        raise ValueError(\n-            \"Nanosecond duration {} is not safely convertible to microseconds \"\n-            \"to convert to datetime.timedelta. Install pandas to return as \"\n-            \"Timedelta with nanosecond support or access the .value \"\n-            \"attribute.\".format(v))\n-    micros = v // 1000\n-\n-    return datetime.timedelta(microseconds=micros)\n-\n-\n-def _timedelta_conversion_functions():\n-    if _TIMEDELTA_CONVERSION_FUNCTIONS:\n-        return _TIMEDELTA_CONVERSION_FUNCTIONS\n-\n-    _TIMEDELTA_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: lambda v: datetime.timedelta(seconds=v),\n-        TimeUnit_MILLI: lambda v: datetime.timedelta(milliseconds=v),\n-        TimeUnit_MICRO: lambda v: datetime.timedelta(microseconds=v),\n-        TimeUnit_NANO: _nanoseconds_to_timedelta_safe\n-    })\n-\n-    try:\n-        import pandas as pd\n-        _TIMEDELTA_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda v: pd.Timedelta(v, unit='ns')\n-        )\n-    except ImportError:\n-        pass\n+        return _datetime_from_int(sp.value, unit=dtype.unit(), tzinfo=tzinfo)\n \n-    return _TIMEDELTA_CONVERSION_FUNCTIONS\n \n-\n-cdef class DurationValue(ArrayValue):\n+cdef class DurationScalar(Scalar):\n     \"\"\"\n-    Concrete class for duration array elements.\n+    Concrete class for duration scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        cdef CDurationType* dtype = <CDurationType*> ap.type().get()\n+        cdef:\n+            CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+            CDurationType* dtype = <CDurationType*> sp.type.get()\n+            TimeUnit unit = dtype.unit()\n+\n+        if not sp.is_valid:\n+            return None\n \n-        cdef int64_t value = ap.Value(self.index)\n-        converter = _timedelta_conversion_functions()[dtype.unit()]\n-        return converter(value)\n+        if unit == TimeUnit_SECOND:\n+            return datetime.timedelta(seconds=sp.value)\n+        elif unit == TimeUnit_MILLI:\n+            return datetime.timedelta(milliseconds=sp.value)\n+        elif unit == TimeUnit_MICRO:\n+            return datetime.timedelta(microseconds=sp.value)\n+        else:\n+            # TimeUnit_NANO: prefer pandas timestamps if available\n+            if _pandas_api.have_pandas:\n+                return _pandas_api.pd.Timedelta(sp.value, unit='ns')\n+            # otherwise safely truncate to microsecond resolution timedelta\n+            if sp.value % 1000 != 0:\n+                raise ValueError(\n+                    \"Nanosecond duration {} is not safely convertible to \"\n+                    \"microseconds to convert to datetime.timedelta. Install \"\n+                    \"pandas to return as Timedelta with nanosecond support or \"\n+                    \"access the .value attribute.\".format(sp.value)\n+                )\n+            return datetime.timedelta(microseconds=sp.value // 1000)\n \n \n-cdef class HalfFloatValue(ArrayValue):\n+cdef class BinaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for float16 array elements.\n+    Concrete class for binary-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def as_buffer(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return a view over this value as a Buffer object.\n         \"\"\"\n-        cdef CHalfFloatArray* ap = <CHalfFloatArray*> self.sp_array.get()\n-        return PyHalf_FromHalf(ap.Value(self.index))\n-\n-\n-cdef class FloatValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float32 array elements.\n-    \"\"\"\n+        cdef CBinaryScalar* sp = <CBinaryScalar*> self.wrapped.get()\n+        return pyarrow_wrap_buffer(sp.value) if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value as a Python bytes.\n         \"\"\"\n-        cdef CFloatArray* ap = <CFloatArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return self.as_buffer().to_pybytes()\n+        else:\n+            return None\n \n \n-cdef class DoubleValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float64 array elements.\n-    \"\"\"\n+cdef class LargeBinaryScalar(BinaryScalar):\n+    pass\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python float.\n-        \"\"\"\n-        cdef CDoubleArray* ap = <CDoubleArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+\n+cdef class FixedSizeBinaryScalar(BinaryScalar):\n\nReview comment:\n       Same here.\n\n##########\nFile path: python/pyarrow/tests/test_convert_builtin.py\n##########\n@@ -968,25 +968,31 @@ def test_sequence_timestamp_from_int_with_unit():\n     arr_s = pa.array(data, type=s)\n     assert len(arr_s) == 1\n     assert arr_s.type == s\n-    assert repr(arr_s[0]) == \"datetime.datetime(1970, 1, 1, 0, 0, 1)\"\n+    assert repr(arr_s[0].as_py()) == \"datetime.datetime(1970, 1, 1, 0, 0, 1)\"\n\nReview comment:\n       What is being tested here? If you're testing the `as_py()` result, then `repr` isn't needed. Otherwise, you may instead call `str(arr_s[0])`.\n\n##########\nFile path: python/pyarrow/tests/test_scalars.py\n##########\n@@ -16,427 +16,443 @@\n # under the License.\n \n import datetime\n+import decimal\n import pytest\n-import unittest\n \n import numpy as np\n \n import pyarrow as pa\n \n \n-class TestScalars(unittest.TestCase):\n-\n-    def test_null_singleton(self):\n-        with pytest.raises(Exception):\n-            pa.NAType()\n+@pytest.mark.parametrize(['value', 'ty', 'klass', 'deprecated'], [\n+    (False, None, pa.BooleanScalar, pa.BooleanValue),\n+    (True, None, pa.BooleanScalar, pa.BooleanValue),\n+    (1, None, pa.Int64Scalar, pa.Int64Value),\n+    (-1, None, pa.Int64Scalar, pa.Int64Value),\n+    (1, pa.int8(), pa.Int8Scalar, pa.Int8Value),\n+    (1, pa.uint8(), pa.UInt8Scalar, pa.UInt8Value),\n+    (1, pa.int16(), pa.Int16Scalar, pa.Int16Value),\n+    (1, pa.uint16(), pa.UInt16Scalar, pa.UInt16Value),\n+    (1, pa.int32(), pa.Int32Scalar, pa.Int32Value),\n+    (1, pa.uint32(), pa.UInt32Scalar, pa.UInt32Value),\n+    (1, pa.int64(), pa.Int64Scalar, pa.Int64Value),\n+    (1, pa.uint64(), pa.UInt64Scalar, pa.UInt64Value),\n+    (1.0, None, pa.DoubleScalar, pa.DoubleValue),\n+    (np.float16(1.0), pa.float16(), pa.HalfFloatScalar, pa.HalfFloatValue),\n+    (1.0, pa.float32(), pa.FloatScalar, pa.FloatValue),\n+    (\"string\", None, pa.StringScalar, pa.StringValue),\n+    (b\"bytes\", None, pa.BinaryScalar, pa.BinaryValue),\n+    ([1, 2, 3], None, pa.ListScalar, pa.ListValue),\n+    ([1, 2, 3, 4], pa.large_list(pa.int8()), pa.LargeListScalar,\n+     pa.LargeListValue),\n+    (datetime.date.today(), None, pa.Date32Scalar, pa.Date64Value),\n+    (datetime.datetime.now(), None, pa.TimestampScalar, pa.TimestampValue),\n+    ({'a': 1, 'b': [1, 2]}, None, pa.StructScalar, pa.StructValue)\n+])\n+def test_basics(value, ty, klass, deprecated):\n+    s = pa.scalar(value, type=ty)\n+    assert isinstance(s, klass)\n+    assert s == value\n+    assert s == s\n+    assert s != \"else\"\n+    assert hash(s) == hash(s)\n+    assert s.is_valid is True\n+    with pytest.warns(FutureWarning):\n+        isinstance(s, deprecated)\n\nReview comment:\n       `assert isinstance` perhaps?\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def __eq__(self, other):\n+        if hasattr(self, 'as_py'):\n+            if isinstance(other, Scalar):\n+                other = other.as_py()\n+            return self.as_py() == other\n+        else:\n+            raise NotImplementedError\n+\n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n+\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class Decimal128Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value // 1000)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n         else:\n             tzinfo = None\n \n-        try:\n-            converter = _datetime_conversion_functions()[dtype.unit()]\n-        except KeyError:\n-            raise ValueError(\n-                'Cannot convert nanosecond timestamps without pandas'\n-            )\n-        return converter(value, tzinfo=tzinfo)\n-\n-\n-cdef dict _TIMEDELTA_CONVERSION_FUNCTIONS = {}\n-\n-\n-def _nanoseconds_to_timedelta_safe(v):\n-    if v % 1000 != 0:\n-        raise ValueError(\n-            \"Nanosecond duration {} is not safely convertible to microseconds \"\n-            \"to convert to datetime.timedelta. Install pandas to return as \"\n-            \"Timedelta with nanosecond support or access the .value \"\n-            \"attribute.\".format(v))\n-    micros = v // 1000\n-\n-    return datetime.timedelta(microseconds=micros)\n-\n-\n-def _timedelta_conversion_functions():\n-    if _TIMEDELTA_CONVERSION_FUNCTIONS:\n-        return _TIMEDELTA_CONVERSION_FUNCTIONS\n-\n-    _TIMEDELTA_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: lambda v: datetime.timedelta(seconds=v),\n-        TimeUnit_MILLI: lambda v: datetime.timedelta(milliseconds=v),\n-        TimeUnit_MICRO: lambda v: datetime.timedelta(microseconds=v),\n-        TimeUnit_NANO: _nanoseconds_to_timedelta_safe\n-    })\n-\n-    try:\n-        import pandas as pd\n-        _TIMEDELTA_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda v: pd.Timedelta(v, unit='ns')\n-        )\n-    except ImportError:\n-        pass\n+        return _datetime_from_int(sp.value, unit=dtype.unit(), tzinfo=tzinfo)\n \n-    return _TIMEDELTA_CONVERSION_FUNCTIONS\n \n-\n-cdef class DurationValue(ArrayValue):\n+cdef class DurationScalar(Scalar):\n     \"\"\"\n-    Concrete class for duration array elements.\n+    Concrete class for duration scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        cdef CDurationType* dtype = <CDurationType*> ap.type().get()\n+        cdef:\n+            CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+            CDurationType* dtype = <CDurationType*> sp.type.get()\n+            TimeUnit unit = dtype.unit()\n+\n+        if not sp.is_valid:\n+            return None\n \n-        cdef int64_t value = ap.Value(self.index)\n-        converter = _timedelta_conversion_functions()[dtype.unit()]\n-        return converter(value)\n+        if unit == TimeUnit_SECOND:\n+            return datetime.timedelta(seconds=sp.value)\n+        elif unit == TimeUnit_MILLI:\n+            return datetime.timedelta(milliseconds=sp.value)\n+        elif unit == TimeUnit_MICRO:\n+            return datetime.timedelta(microseconds=sp.value)\n+        else:\n+            # TimeUnit_NANO: prefer pandas timestamps if available\n+            if _pandas_api.have_pandas:\n+                return _pandas_api.pd.Timedelta(sp.value, unit='ns')\n+            # otherwise safely truncate to microsecond resolution timedelta\n+            if sp.value % 1000 != 0:\n+                raise ValueError(\n+                    \"Nanosecond duration {} is not safely convertible to \"\n+                    \"microseconds to convert to datetime.timedelta. Install \"\n+                    \"pandas to return as Timedelta with nanosecond support or \"\n+                    \"access the .value attribute.\".format(sp.value)\n+                )\n+            return datetime.timedelta(microseconds=sp.value // 1000)\n \n \n-cdef class HalfFloatValue(ArrayValue):\n+cdef class BinaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for float16 array elements.\n+    Concrete class for binary-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def as_buffer(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return a view over this value as a Buffer object.\n         \"\"\"\n-        cdef CHalfFloatArray* ap = <CHalfFloatArray*> self.sp_array.get()\n-        return PyHalf_FromHalf(ap.Value(self.index))\n-\n-\n-cdef class FloatValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float32 array elements.\n-    \"\"\"\n+        cdef CBinaryScalar* sp = <CBinaryScalar*> self.wrapped.get()\n+        return pyarrow_wrap_buffer(sp.value) if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value as a Python bytes.\n         \"\"\"\n-        cdef CFloatArray* ap = <CFloatArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return self.as_buffer().to_pybytes()\n+        else:\n+            return None\n \n \n-cdef class DoubleValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float64 array elements.\n-    \"\"\"\n+cdef class LargeBinaryScalar(BinaryScalar):\n+    pass\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python float.\n-        \"\"\"\n-        cdef CDoubleArray* ap = <CDoubleArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+\n+cdef class FixedSizeBinaryScalar(BinaryScalar):\n+    pass\n \n \n-cdef class DecimalValue(ArrayValue):\n+cdef class StringScalar(BinaryScalar):\n     \"\"\"\n-    Concrete class for decimal128 array elements.\n+    Concrete class for string-like (utf8) scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python Decimal.\n+        Return this value as a Python string.\n         \"\"\"\n-        cdef:\n-            CDecimal128Array* ap = <CDecimal128Array*> self.sp_array.get()\n-            c_string s = ap.FormatValue(self.index)\n-        return _pydecimal.Decimal(s.decode('utf8'))\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return frombytes(self.as_buffer().to_pybytes())\n+        else:\n+            return None\n+\n \n+cdef class LargeStringScalar(StringScalar):\n+    pass\n \n-cdef class StringValue(ArrayValue):\n+\n+cdef class ListScalar(Scalar):\n     \"\"\"\n-    Concrete class for string (utf8) array elements.\n+    Concrete class for list-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    @property\n+    def values(self):\n+        cdef CListScalar* sp = <CListScalar*> self.wrapped.get()\n+        if sp.is_valid:\n+            return pyarrow_wrap_array(sp.value)\n+        else:\n+            return None\n+\n+    def __len__(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Return the number of values.\n         \"\"\"\n-        cdef CStringArray* ap = <CStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        return len(self.values)\n \n-    def as_buffer(self):\n+    def __getitem__(self, i):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return the value at the given index.\n         \"\"\"\n-        cdef:\n-            CStringArray* ap = <CStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n-\n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n-\n+        return self.values[_normalize_index(i, len(self))]\n \n-cdef class LargeStringValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large string (utf8) array elements.\n-    \"\"\"\n-\n-    def as_py(self):\n+    def __iter__(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Iterate over this element's values.\n         \"\"\"\n-        cdef CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        return iter(self.values)\n \n-    def as_buffer(self):\n+    def as_py(self):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return this value as a Python list.\n         \"\"\"\n-        cdef:\n-            CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+        arr = self.values\n+        return None if arr is None else arr.to_pylist()\n+\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+cdef class FixedSizeListScalar(ListScalar):\n+    pass\n \n \n-cdef class BinaryValue(ArrayValue):\n+cdef class LargeListScalar(ListScalar):\n+    pass\n+\n+\n+cdef class StructScalar(Scalar, collections.abc.Mapping):\n     \"\"\"\n-    Concrete class for variable-sized binary array elements.\n+    Concrete class for struct scalars.\n     \"\"\"\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python bytes object.\n-        \"\"\"\n+    def __len__(self):\n+        cdef CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+        return sp.value.size()\n+\n+    def __iter__(self):\n         cdef:\n-            const uint8_t* ptr\n-            int32_t length\n-            CBinaryArray* ap = <CBinaryArray*> self.sp_array.get()\n+            CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+            CStructType* dtype = <CStructType*> sp.type.get()\n+            vector[shared_ptr[CField]] fields = dtype.fields()\n \n-        ptr = ap.GetValue(self.index, &length)\n-        return cp.PyBytes_FromStringAndSize(<const char*>(ptr), length)\n+        if sp.is_valid:\n+            for i in range(dtype.num_fields()):\n+                yield frombytes(fields[i].get().name())\n \n-    def as_buffer(self):\n+    def __contains__(self, key):\n+        try:\n+            self[key]\n+        except IndexError:\n+            return False\n+        else:\n+            return True\n+\n+    def __getitem__(self, key):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return the child value for the given field.\n+\n+        Parameters\n+        ----------\n+        index : Union[int, str]\n+            Index / position or name of the field.\n+\n+        Returns\n+        -------\n+        result : Scalar\n         \"\"\"\n         cdef:\n-            CBinaryArray* ap = <CBinaryArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+            CFieldRef ref\n+            CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+        if isinstance(key, (bytes, str)):\n+            ref = CFieldRef(<c_string> tobytes(key))\n+        elif isinstance(key, int):\n+            ref = CFieldRef(<int> key)\n+        else:\n+            raise TypeError('Expected integer or string index')\n \n-\n-cdef class LargeBinaryValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large variable-sized binary array elements.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python bytes object.\n-        \"\"\"\n-        cdef:\n-            const uint8_t* ptr\n-            int64_t length\n-            CLargeBinaryArray* ap = <CLargeBinaryArray*> self.sp_array.get()\n-\n-        ptr = ap.GetValue(self.index, &length)\n-        return cp.PyBytes_FromStringAndSize(<const char*>(ptr), length)\n-\n-    def as_buffer(self):\n-        \"\"\"\n-        Return a view over this value as a Buffer object.\n-        \"\"\"\n-        cdef:\n-            CLargeBinaryArray* ap = <CLargeBinaryArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n-\n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n-\n-\n-cdef class ListValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for list array elements.\n-    \"\"\"\n-\n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n-    def __getitem__(self, i):\n-        \"\"\"\n-        Return the value at the given index.\n-        \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n-\n-    def __iter__(self):\n-        \"\"\"\n-        Iterate over this element's values.\n-        \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CListArray*> sp_array.get()\n-        self.value_type = pyarrow_wrap_data_type(self.ap.value_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return box_scalar(self.value_type, self.ap.values(), j)\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python list.\n-        \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            result.append(self.getitem(j).as_py())\n-\n-        return result\n-\n-\n-cdef class LargeListValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large list array elements.\n-    \"\"\"\n-\n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n-    def __getitem__(self, i):\n-        \"\"\"\n-        Return the value at the given index.\n-        \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n-\n-    def __iter__(self):\n-        \"\"\"\n-        Iterate over this element's values.\n-        \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CLargeListArray*> sp_array.get()\n-        self.value_type = pyarrow_wrap_data_type(self.ap.value_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return box_scalar(self.value_type, self.ap.values(), j)\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python list.\n-        \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            result.append(self.getitem(j).as_py())\n-\n-        return result\n-\n-\n-cdef class MapValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for map array elements.\n-    \"\"\"\n-\n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n-    def __getitem__(self, i):\n-        \"\"\"\n-        Return the value at the given index.\n-        \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n-\n-    def __iter__(self):\n-        \"\"\"\n-        Iterate over this element's values.\n-        \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CMapArray*> sp_array.get()\n-        self.key_type = pyarrow_wrap_data_type(self.ap.map_type().key_type())\n-        self.item_type = pyarrow_wrap_data_type(self.ap.map_type().item_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return (box_scalar(self.key_type, self.ap.keys(), j),\n-                box_scalar(self.item_type, self.ap.items(), j))\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n+        try:\n+            return Scalar.wrap(GetResultValue(sp.field(ref)))\n+        except ArrowInvalid:\n+            raise IndexError(key)\n\nReview comment:\n       Ideally, this should be `KeyError` for string keys.\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def __eq__(self, other):\n+        if hasattr(self, 'as_py'):\n+            if isinstance(other, Scalar):\n+                other = other.as_py()\n+            return self.as_py() == other\n+        else:\n+            raise NotImplementedError\n+\n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n+\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class Decimal128Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value // 1000)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n         else:\n             tzinfo = None\n \n-        try:\n-            converter = _datetime_conversion_functions()[dtype.unit()]\n-        except KeyError:\n-            raise ValueError(\n-                'Cannot convert nanosecond timestamps without pandas'\n-            )\n-        return converter(value, tzinfo=tzinfo)\n-\n-\n-cdef dict _TIMEDELTA_CONVERSION_FUNCTIONS = {}\n-\n-\n-def _nanoseconds_to_timedelta_safe(v):\n-    if v % 1000 != 0:\n-        raise ValueError(\n-            \"Nanosecond duration {} is not safely convertible to microseconds \"\n-            \"to convert to datetime.timedelta. Install pandas to return as \"\n-            \"Timedelta with nanosecond support or access the .value \"\n-            \"attribute.\".format(v))\n-    micros = v // 1000\n-\n-    return datetime.timedelta(microseconds=micros)\n-\n-\n-def _timedelta_conversion_functions():\n-    if _TIMEDELTA_CONVERSION_FUNCTIONS:\n-        return _TIMEDELTA_CONVERSION_FUNCTIONS\n-\n-    _TIMEDELTA_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: lambda v: datetime.timedelta(seconds=v),\n-        TimeUnit_MILLI: lambda v: datetime.timedelta(milliseconds=v),\n-        TimeUnit_MICRO: lambda v: datetime.timedelta(microseconds=v),\n-        TimeUnit_NANO: _nanoseconds_to_timedelta_safe\n-    })\n-\n-    try:\n-        import pandas as pd\n-        _TIMEDELTA_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda v: pd.Timedelta(v, unit='ns')\n-        )\n-    except ImportError:\n-        pass\n+        return _datetime_from_int(sp.value, unit=dtype.unit(), tzinfo=tzinfo)\n \n-    return _TIMEDELTA_CONVERSION_FUNCTIONS\n \n-\n-cdef class DurationValue(ArrayValue):\n+cdef class DurationScalar(Scalar):\n     \"\"\"\n-    Concrete class for duration array elements.\n+    Concrete class for duration scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        cdef CDurationType* dtype = <CDurationType*> ap.type().get()\n+        cdef:\n+            CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+            CDurationType* dtype = <CDurationType*> sp.type.get()\n+            TimeUnit unit = dtype.unit()\n+\n+        if not sp.is_valid:\n+            return None\n \n-        cdef int64_t value = ap.Value(self.index)\n-        converter = _timedelta_conversion_functions()[dtype.unit()]\n-        return converter(value)\n+        if unit == TimeUnit_SECOND:\n+            return datetime.timedelta(seconds=sp.value)\n+        elif unit == TimeUnit_MILLI:\n+            return datetime.timedelta(milliseconds=sp.value)\n+        elif unit == TimeUnit_MICRO:\n+            return datetime.timedelta(microseconds=sp.value)\n+        else:\n+            # TimeUnit_NANO: prefer pandas timestamps if available\n+            if _pandas_api.have_pandas:\n+                return _pandas_api.pd.Timedelta(sp.value, unit='ns')\n+            # otherwise safely truncate to microsecond resolution timedelta\n+            if sp.value % 1000 != 0:\n+                raise ValueError(\n+                    \"Nanosecond duration {} is not safely convertible to \"\n+                    \"microseconds to convert to datetime.timedelta. Install \"\n+                    \"pandas to return as Timedelta with nanosecond support or \"\n+                    \"access the .value attribute.\".format(sp.value)\n+                )\n+            return datetime.timedelta(microseconds=sp.value // 1000)\n \n \n-cdef class HalfFloatValue(ArrayValue):\n+cdef class BinaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for float16 array elements.\n+    Concrete class for binary-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def as_buffer(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return a view over this value as a Buffer object.\n         \"\"\"\n-        cdef CHalfFloatArray* ap = <CHalfFloatArray*> self.sp_array.get()\n-        return PyHalf_FromHalf(ap.Value(self.index))\n-\n-\n-cdef class FloatValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float32 array elements.\n-    \"\"\"\n+        cdef CBinaryScalar* sp = <CBinaryScalar*> self.wrapped.get()\n+        return pyarrow_wrap_buffer(sp.value) if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value as a Python bytes.\n         \"\"\"\n-        cdef CFloatArray* ap = <CFloatArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return self.as_buffer().to_pybytes()\n+        else:\n+            return None\n \n \n-cdef class DoubleValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float64 array elements.\n-    \"\"\"\n+cdef class LargeBinaryScalar(BinaryScalar):\n+    pass\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python float.\n-        \"\"\"\n-        cdef CDoubleArray* ap = <CDoubleArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+\n+cdef class FixedSizeBinaryScalar(BinaryScalar):\n+    pass\n \n \n-cdef class DecimalValue(ArrayValue):\n+cdef class StringScalar(BinaryScalar):\n     \"\"\"\n-    Concrete class for decimal128 array elements.\n+    Concrete class for string-like (utf8) scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python Decimal.\n+        Return this value as a Python string.\n         \"\"\"\n-        cdef:\n-            CDecimal128Array* ap = <CDecimal128Array*> self.sp_array.get()\n-            c_string s = ap.FormatValue(self.index)\n-        return _pydecimal.Decimal(s.decode('utf8'))\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return frombytes(self.as_buffer().to_pybytes())\n+        else:\n+            return None\n+\n \n+cdef class LargeStringScalar(StringScalar):\n+    pass\n \n-cdef class StringValue(ArrayValue):\n+\n+cdef class ListScalar(Scalar):\n     \"\"\"\n-    Concrete class for string (utf8) array elements.\n+    Concrete class for list-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    @property\n+    def values(self):\n+        cdef CListScalar* sp = <CListScalar*> self.wrapped.get()\n+        if sp.is_valid:\n+            return pyarrow_wrap_array(sp.value)\n+        else:\n+            return None\n+\n+    def __len__(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Return the number of values.\n         \"\"\"\n-        cdef CStringArray* ap = <CStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        return len(self.values)\n \n-    def as_buffer(self):\n+    def __getitem__(self, i):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return the value at the given index.\n         \"\"\"\n-        cdef:\n-            CStringArray* ap = <CStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n-\n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n-\n+        return self.values[_normalize_index(i, len(self))]\n \n-cdef class LargeStringValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large string (utf8) array elements.\n-    \"\"\"\n-\n-    def as_py(self):\n+    def __iter__(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Iterate over this element's values.\n         \"\"\"\n-        cdef CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        return iter(self.values)\n \n-    def as_buffer(self):\n+    def as_py(self):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return this value as a Python list.\n         \"\"\"\n-        cdef:\n-            CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+        arr = self.values\n+        return None if arr is None else arr.to_pylist()\n+\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+cdef class FixedSizeListScalar(ListScalar):\n+    pass\n \n \n-cdef class BinaryValue(ArrayValue):\n+cdef class LargeListScalar(ListScalar):\n+    pass\n+\n+\n+cdef class StructScalar(Scalar, collections.abc.Mapping):\n     \"\"\"\n-    Concrete class for variable-sized binary array elements.\n+    Concrete class for struct scalars.\n     \"\"\"\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python bytes object.\n-        \"\"\"\n+    def __len__(self):\n+        cdef CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+        return sp.value.size()\n+\n+    def __iter__(self):\n         cdef:\n-            const uint8_t* ptr\n-            int32_t length\n-            CBinaryArray* ap = <CBinaryArray*> self.sp_array.get()\n+            CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+            CStructType* dtype = <CStructType*> sp.type.get()\n+            vector[shared_ptr[CField]] fields = dtype.fields()\n \n-        ptr = ap.GetValue(self.index, &length)\n-        return cp.PyBytes_FromStringAndSize(<const char*>(ptr), length)\n+        if sp.is_valid:\n+            for i in range(dtype.num_fields()):\n+                yield frombytes(fields[i].get().name())\n \n-    def as_buffer(self):\n+    def __contains__(self, key):\n+        try:\n+            self[key]\n+        except IndexError:\n+            return False\n+        else:\n+            return True\n+\n+    def __getitem__(self, key):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return the child value for the given field.\n+\n+        Parameters\n+        ----------\n+        index : Union[int, str]\n+            Index / position or name of the field.\n+\n+        Returns\n+        -------\n+        result : Scalar\n         \"\"\"\n         cdef:\n-            CBinaryArray* ap = <CBinaryArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+            CFieldRef ref\n+            CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+        if isinstance(key, (bytes, str)):\n+            ref = CFieldRef(<c_string> tobytes(key))\n+        elif isinstance(key, int):\n+            ref = CFieldRef(<int> key)\n+        else:\n+            raise TypeError('Expected integer or string index')\n \n-\n-cdef class LargeBinaryValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large variable-sized binary array elements.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python bytes object.\n-        \"\"\"\n-        cdef:\n-            const uint8_t* ptr\n-            int64_t length\n-            CLargeBinaryArray* ap = <CLargeBinaryArray*> self.sp_array.get()\n-\n-        ptr = ap.GetValue(self.index, &length)\n-        return cp.PyBytes_FromStringAndSize(<const char*>(ptr), length)\n-\n-    def as_buffer(self):\n-        \"\"\"\n-        Return a view over this value as a Buffer object.\n-        \"\"\"\n-        cdef:\n-            CLargeBinaryArray* ap = <CLargeBinaryArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n-\n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n-\n-\n-cdef class ListValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for list array elements.\n-    \"\"\"\n-\n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n-    def __getitem__(self, i):\n-        \"\"\"\n-        Return the value at the given index.\n-        \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n-\n-    def __iter__(self):\n-        \"\"\"\n-        Iterate over this element's values.\n-        \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CListArray*> sp_array.get()\n-        self.value_type = pyarrow_wrap_data_type(self.ap.value_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return box_scalar(self.value_type, self.ap.values(), j)\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python list.\n-        \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            result.append(self.getitem(j).as_py())\n-\n-        return result\n-\n-\n-cdef class LargeListValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large list array elements.\n-    \"\"\"\n-\n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n-    def __getitem__(self, i):\n-        \"\"\"\n-        Return the value at the given index.\n-        \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n-\n-    def __iter__(self):\n-        \"\"\"\n-        Iterate over this element's values.\n-        \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CLargeListArray*> sp_array.get()\n-        self.value_type = pyarrow_wrap_data_type(self.ap.value_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return box_scalar(self.value_type, self.ap.values(), j)\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python list.\n-        \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            result.append(self.getitem(j).as_py())\n-\n-        return result\n-\n-\n-cdef class MapValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for map array elements.\n-    \"\"\"\n-\n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n-    def __getitem__(self, i):\n-        \"\"\"\n-        Return the value at the given index.\n-        \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n-\n-    def __iter__(self):\n-        \"\"\"\n-        Iterate over this element's values.\n-        \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CMapArray*> sp_array.get()\n-        self.key_type = pyarrow_wrap_data_type(self.ap.map_type().key_type())\n-        self.item_type = pyarrow_wrap_data_type(self.ap.map_type().item_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return (box_scalar(self.key_type, self.ap.keys(), j),\n-                box_scalar(self.item_type, self.ap.items(), j))\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n+        try:\n+            return Scalar.wrap(GetResultValue(sp.field(ref)))\n+        except ArrowInvalid:\n+            raise IndexError(key)\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python list of tuples, each containing a\n-        key and item.\n+        Return this value as a Python dict.\n         \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            key, item = self.getitem(j)\n-            result.append((key.as_py(), item.as_py()))\n-\n-        return result\n+        if self.is_valid:\n+            return {k: v.as_py() for k, v in self.items()}\n+        else:\n+            return None\n \n \n-cdef class FixedSizeListValue(ArrayValue):\n+cdef class MapScalar(ListScalar):\n     \"\"\"\n-    Concrete class for fixed size list array elements.\n+    Concrete class for map scalars.\n     \"\"\"\n \n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n     def __getitem__(self, i):\n         \"\"\"\n         Return the value at the given index.\n         \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n+        arr = self.values\n+        if arr is None:\n+            raise IndexError(i)\n+        dct = arr[_normalize_index(i, len(arr))]\n+        return (dct['key'], dct['value'])\n \n     def __iter__(self):\n         \"\"\"\n         Iterate over this element's values.\n         \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CFixedSizeListArray*> sp_array.get()\n-        self.value_type = pyarrow_wrap_data_type(self.ap.value_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return box_scalar(self.value_type, self.ap.values(), j)\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n+        arr = self.values\n+        if arr is None:\n+            return iter(zip(arr.field('key'), arr.field('value')))\n+        else:\n+            raise StopIteration\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python list.\n         \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            result.append(self.getitem(j).as_py())\n-\n-        return result\n-\n-\n-cdef class UnionValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for union array elements.\n-    \"\"\"\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CUnionArray*> sp_array.get()\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int child_id = self.ap.child_id(i)\n-        cdef shared_ptr[CArray] child = self.ap.field(child_id)\n-        cdef CDenseUnionArray* dense\n-        if self.ap.mode() == _UnionMode_SPARSE:\n-            return box_scalar(self.type[child_id].type, child, i)\n+        arr = self.values\n+        if arr is not None:\n+            return list(zip(arr.field('key'), arr.field('value')))\n         else:\n-            dense = <CDenseUnionArray*> self.ap\n-            return box_scalar(self.type[child_id].type, child,\n-                              dense.value_offset(i))\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python object.\n-\n-        The exact type depends on the underlying union member.\n-        \"\"\"\n-        return self.getitem(self.index).as_py()\n+            return None\n \n \n-cdef class FixedSizeBinaryValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for fixed-size binary array elements.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python bytes object.\n-        \"\"\"\n-        cdef:\n-            CFixedSizeBinaryArray* ap\n-            CFixedSizeBinaryType* ap_type\n-            int32_t length\n-            const char* data\n-        ap = <CFixedSizeBinaryArray*> self.sp_array.get()\n-        ap_type = <CFixedSizeBinaryType*> ap.type().get()\n-        length = ap_type.byte_width()\n-        data = <const char*> ap.GetValue(self.index)\n-        return cp.PyBytes_FromStringAndSize(data, length)\n-\n-\n-cdef class StructValue(ArrayValue):\n+cdef class DictionaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for struct array elements.\n+    Concrete class for dictionary-encoded scalars.\n     \"\"\"\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CStructArray*> sp_array.get()\n-\n-    def __getitem__(self, key):\n-        \"\"\"\n-        Return the child value for the given field name.\n-        \"\"\"\n-        cdef:\n-            CStructType* type\n-            int index\n-\n-        type = <CStructType*> self.type.type\n-        index = type.GetFieldIndex(tobytes(key))\n-\n-        if index < 0:\n-            raise KeyError(key)\n+    # @property\n+    # def index(self):\n+    #     \"\"\"\n+    #     Return this value's underlying index as a scalar.\n+    #     \"\"\"\n+    #     cdef CDictionaryScalar* sp = <CDictionaryScalar*> self.wrapped.get()\n+    #     return Scalar.wrap(sp.index)\n \n-        return pyarrow_wrap_array(self.ap.field(index))[self.index]\n-\n-    def as_py(self):\n+    @property\n+    def value(self):\n         \"\"\"\n-        Return this value as a Python dict.\n+        Return this value's underlying dictionary value as a scalar.\n         \"\"\"\n-        cdef:\n-            vector[shared_ptr[CField]] child_fields = self.type.type.fields()\n-\n-        wrapped_arrays = [pyarrow_wrap_array(self.ap.field(i))\n-                          for i in range(self.ap.num_fields())]\n-        child_names = [child.get().name() for child in child_fields]\n-        # Return the struct as a dict\n-        return {\n-            frombytes(name): child_array[self.index].as_py()\n-            for name, child_array in zip(child_names, wrapped_arrays)\n-        }\n-\n-\n-cdef class DictionaryValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for dictionary-encoded array elements.\n-    \"\"\"\n+        cdef CDictionaryScalar* sp = <CDictionaryScalar*> self.wrapped.get()\n+        return Scalar.wrap(sp.value)\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python object.\n \n         The exact type depends on the dictionary value type.\n         \"\"\"\n-        return self.dictionary_value.as_py()\n+        value = self.value\n+        return None if value is None else value.as_py()\n \n-    @property\n-    def index_value(self):\n-        \"\"\"\n-        Return this value's underlying index as a ArrayValue of the right\n-        signed integer type.\n-        \"\"\"\n-        cdef CDictionaryArray* darr = <CDictionaryArray*>(self.sp_array.get())\n-        indices = pyarrow_wrap_array(darr.indices())\n-        return indices[self.index]\n+    # TODO(kszucs): deprecate these\n+    # @property\n+    # def index_value(self):\n+    #     index = self.index\n+    #     return None if index is None else self.index\n \n     @property\n     def dictionary_value(self):\n-        \"\"\"\n-        Return this value's underlying dictionary value as a ArrayValue.\n-        \"\"\"\n-        cdef CDictionaryArray* darr = <CDictionaryArray*>(self.sp_array.get())\n-        dictionary = pyarrow_wrap_array(darr.dictionary())\n-        return dictionary[self.index_value.as_py()]\n-\n-\n-cdef dict _array_value_classes = {\n-    _Type_BOOL: BooleanValue,\n-    _Type_UINT8: UInt8Value,\n-    _Type_UINT16: UInt16Value,\n-    _Type_UINT32: UInt32Value,\n-    _Type_UINT64: UInt64Value,\n-    _Type_INT8: Int8Value,\n-    _Type_INT16: Int16Value,\n-    _Type_INT32: Int32Value,\n-    _Type_INT64: Int64Value,\n-    _Type_DATE32: Date32Value,\n-    _Type_DATE64: Date64Value,\n-    _Type_TIME32: Time32Value,\n-    _Type_TIME64: Time64Value,\n-    _Type_TIMESTAMP: TimestampValue,\n-    _Type_DURATION: DurationValue,\n-    _Type_HALF_FLOAT: HalfFloatValue,\n-    _Type_FLOAT: FloatValue,\n-    _Type_DOUBLE: DoubleValue,\n-    _Type_LIST: ListValue,\n-    _Type_LARGE_LIST: LargeListValue,\n-    _Type_MAP: MapValue,\n-    _Type_FIXED_SIZE_LIST: FixedSizeListValue,\n-    _Type_SPARSE_UNION: UnionValue,\n-    _Type_DENSE_UNION: UnionValue,\n-    _Type_BINARY: BinaryValue,\n-    _Type_STRING: StringValue,\n-    _Type_LARGE_BINARY: LargeBinaryValue,\n-    _Type_LARGE_STRING: LargeStringValue,\n-    _Type_FIXED_SIZE_BINARY: FixedSizeBinaryValue,\n-    _Type_DECIMAL: DecimalValue,\n-    _Type_STRUCT: StructValue,\n-    _Type_DICTIONARY: DictionaryValue,\n-}\n-\n-cdef class ScalarValue(Scalar):\n-    \"\"\"\n-    The base class for scalars.\n-    \"\"\"\n-\n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly.\"\n-                        .format(self.__class__.__name__))\n-\n-    cdef void init(self, const shared_ptr[CScalar]& sp_scalar):\n-        self.sp_scalar = sp_scalar\n-\n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n-\n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n-\n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ScalarValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplemented(\n-                \"Cannot compare scalars that don't support as_py()\")\n-\n-    def __hash__(self):\n-        return hash(self.as_py())\n-\n-\n-cdef class NullScalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for null scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python None.\n-        \"\"\"\n-        return None\n-\n-\n-cdef class BooleanScalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for boolean scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python bool.\n-        \"\"\"\n-        cdef CBooleanScalar* sp = <CBooleanScalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class UInt8Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for uint8 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class Int8Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for int8 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CInt8Scalar* sp = <CInt8Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class UInt16Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for uint16 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class Int16Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for int16 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CInt16Scalar* sp = <CInt16Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class UInt32Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for uint32 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class Int32Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for int32 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CInt32Scalar* sp = <CInt32Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class UInt64Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for uint64 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class Int64Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for int64 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CInt64Scalar* sp = <CInt64Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n+        value = self.value\n+        return None if value is None else self.value\n \n \n-cdef class FloatScalar(ScalarValue):\n+cdef class UnionScalar(Scalar):\n     \"\"\"\n-    Concrete class for float scalars.\n+    Concrete class for Union scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    @property\n+    def value(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value's underlying dictionary value as a scalar.\n         \"\"\"\n-        cdef CFloatScalar* sp = <CFloatScalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class DoubleScalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for double scalars.\n-    \"\"\"\n+        cdef CDictionaryScalar* sp = <CDictionaryScalar*> self.wrapped.get()\n\nReview comment:\n       UnionScalar\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def __eq__(self, other):\n+        if hasattr(self, 'as_py'):\n+            if isinstance(other, Scalar):\n+                other = other.as_py()\n+            return self.as_py() == other\n+        else:\n+            raise NotImplementedError\n+\n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n+\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class Decimal128Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value // 1000)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n         else:\n             tzinfo = None\n \n-        try:\n-            converter = _datetime_conversion_functions()[dtype.unit()]\n-        except KeyError:\n-            raise ValueError(\n-                'Cannot convert nanosecond timestamps without pandas'\n-            )\n-        return converter(value, tzinfo=tzinfo)\n-\n-\n-cdef dict _TIMEDELTA_CONVERSION_FUNCTIONS = {}\n-\n-\n-def _nanoseconds_to_timedelta_safe(v):\n-    if v % 1000 != 0:\n-        raise ValueError(\n-            \"Nanosecond duration {} is not safely convertible to microseconds \"\n-            \"to convert to datetime.timedelta. Install pandas to return as \"\n-            \"Timedelta with nanosecond support or access the .value \"\n-            \"attribute.\".format(v))\n-    micros = v // 1000\n-\n-    return datetime.timedelta(microseconds=micros)\n-\n-\n-def _timedelta_conversion_functions():\n-    if _TIMEDELTA_CONVERSION_FUNCTIONS:\n-        return _TIMEDELTA_CONVERSION_FUNCTIONS\n-\n-    _TIMEDELTA_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: lambda v: datetime.timedelta(seconds=v),\n-        TimeUnit_MILLI: lambda v: datetime.timedelta(milliseconds=v),\n-        TimeUnit_MICRO: lambda v: datetime.timedelta(microseconds=v),\n-        TimeUnit_NANO: _nanoseconds_to_timedelta_safe\n-    })\n-\n-    try:\n-        import pandas as pd\n-        _TIMEDELTA_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda v: pd.Timedelta(v, unit='ns')\n-        )\n-    except ImportError:\n-        pass\n+        return _datetime_from_int(sp.value, unit=dtype.unit(), tzinfo=tzinfo)\n \n-    return _TIMEDELTA_CONVERSION_FUNCTIONS\n \n-\n-cdef class DurationValue(ArrayValue):\n+cdef class DurationScalar(Scalar):\n     \"\"\"\n-    Concrete class for duration array elements.\n+    Concrete class for duration scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        cdef CDurationType* dtype = <CDurationType*> ap.type().get()\n+        cdef:\n+            CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+            CDurationType* dtype = <CDurationType*> sp.type.get()\n+            TimeUnit unit = dtype.unit()\n+\n+        if not sp.is_valid:\n+            return None\n \n-        cdef int64_t value = ap.Value(self.index)\n-        converter = _timedelta_conversion_functions()[dtype.unit()]\n-        return converter(value)\n+        if unit == TimeUnit_SECOND:\n+            return datetime.timedelta(seconds=sp.value)\n+        elif unit == TimeUnit_MILLI:\n+            return datetime.timedelta(milliseconds=sp.value)\n+        elif unit == TimeUnit_MICRO:\n+            return datetime.timedelta(microseconds=sp.value)\n+        else:\n+            # TimeUnit_NANO: prefer pandas timestamps if available\n+            if _pandas_api.have_pandas:\n+                return _pandas_api.pd.Timedelta(sp.value, unit='ns')\n+            # otherwise safely truncate to microsecond resolution timedelta\n+            if sp.value % 1000 != 0:\n+                raise ValueError(\n+                    \"Nanosecond duration {} is not safely convertible to \"\n+                    \"microseconds to convert to datetime.timedelta. Install \"\n+                    \"pandas to return as Timedelta with nanosecond support or \"\n+                    \"access the .value attribute.\".format(sp.value)\n+                )\n+            return datetime.timedelta(microseconds=sp.value // 1000)\n \n \n-cdef class HalfFloatValue(ArrayValue):\n+cdef class BinaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for float16 array elements.\n+    Concrete class for binary-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def as_buffer(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return a view over this value as a Buffer object.\n         \"\"\"\n-        cdef CHalfFloatArray* ap = <CHalfFloatArray*> self.sp_array.get()\n-        return PyHalf_FromHalf(ap.Value(self.index))\n-\n-\n-cdef class FloatValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float32 array elements.\n-    \"\"\"\n+        cdef CBinaryScalar* sp = <CBinaryScalar*> self.wrapped.get()\n+        return pyarrow_wrap_buffer(sp.value) if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value as a Python bytes.\n         \"\"\"\n-        cdef CFloatArray* ap = <CFloatArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return self.as_buffer().to_pybytes()\n+        else:\n+            return None\n \n \n-cdef class DoubleValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float64 array elements.\n-    \"\"\"\n+cdef class LargeBinaryScalar(BinaryScalar):\n+    pass\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python float.\n-        \"\"\"\n-        cdef CDoubleArray* ap = <CDoubleArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+\n+cdef class FixedSizeBinaryScalar(BinaryScalar):\n+    pass\n \n \n-cdef class DecimalValue(ArrayValue):\n+cdef class StringScalar(BinaryScalar):\n     \"\"\"\n-    Concrete class for decimal128 array elements.\n+    Concrete class for string-like (utf8) scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python Decimal.\n+        Return this value as a Python string.\n         \"\"\"\n-        cdef:\n-            CDecimal128Array* ap = <CDecimal128Array*> self.sp_array.get()\n-            c_string s = ap.FormatValue(self.index)\n-        return _pydecimal.Decimal(s.decode('utf8'))\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return frombytes(self.as_buffer().to_pybytes())\n+        else:\n+            return None\n+\n \n+cdef class LargeStringScalar(StringScalar):\n+    pass\n \n-cdef class StringValue(ArrayValue):\n+\n+cdef class ListScalar(Scalar):\n     \"\"\"\n-    Concrete class for string (utf8) array elements.\n+    Concrete class for list-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    @property\n+    def values(self):\n+        cdef CListScalar* sp = <CListScalar*> self.wrapped.get()\n+        if sp.is_valid:\n+            return pyarrow_wrap_array(sp.value)\n+        else:\n+            return None\n+\n+    def __len__(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Return the number of values.\n         \"\"\"\n-        cdef CStringArray* ap = <CStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        return len(self.values)\n \n-    def as_buffer(self):\n+    def __getitem__(self, i):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return the value at the given index.\n         \"\"\"\n-        cdef:\n-            CStringArray* ap = <CStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n-\n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n-\n+        return self.values[_normalize_index(i, len(self))]\n \n-cdef class LargeStringValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large string (utf8) array elements.\n-    \"\"\"\n-\n-    def as_py(self):\n+    def __iter__(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Iterate over this element's values.\n         \"\"\"\n-        cdef CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        return iter(self.values)\n \n-    def as_buffer(self):\n+    def as_py(self):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return this value as a Python list.\n         \"\"\"\n-        cdef:\n-            CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+        arr = self.values\n+        return None if arr is None else arr.to_pylist()\n+\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+cdef class FixedSizeListScalar(ListScalar):\n+    pass\n \n \n-cdef class BinaryValue(ArrayValue):\n+cdef class LargeListScalar(ListScalar):\n\nReview comment:\n       Same here.\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def __eq__(self, other):\n+        if hasattr(self, 'as_py'):\n+            if isinstance(other, Scalar):\n+                other = other.as_py()\n+            return self.as_py() == other\n+        else:\n+            raise NotImplementedError\n+\n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n+\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class Decimal128Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value // 1000)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n         else:\n             tzinfo = None\n \n-        try:\n-            converter = _datetime_conversion_functions()[dtype.unit()]\n-        except KeyError:\n-            raise ValueError(\n-                'Cannot convert nanosecond timestamps without pandas'\n-            )\n-        return converter(value, tzinfo=tzinfo)\n-\n-\n-cdef dict _TIMEDELTA_CONVERSION_FUNCTIONS = {}\n-\n-\n-def _nanoseconds_to_timedelta_safe(v):\n-    if v % 1000 != 0:\n-        raise ValueError(\n-            \"Nanosecond duration {} is not safely convertible to microseconds \"\n-            \"to convert to datetime.timedelta. Install pandas to return as \"\n-            \"Timedelta with nanosecond support or access the .value \"\n-            \"attribute.\".format(v))\n-    micros = v // 1000\n-\n-    return datetime.timedelta(microseconds=micros)\n-\n-\n-def _timedelta_conversion_functions():\n-    if _TIMEDELTA_CONVERSION_FUNCTIONS:\n-        return _TIMEDELTA_CONVERSION_FUNCTIONS\n-\n-    _TIMEDELTA_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: lambda v: datetime.timedelta(seconds=v),\n-        TimeUnit_MILLI: lambda v: datetime.timedelta(milliseconds=v),\n-        TimeUnit_MICRO: lambda v: datetime.timedelta(microseconds=v),\n-        TimeUnit_NANO: _nanoseconds_to_timedelta_safe\n-    })\n-\n-    try:\n-        import pandas as pd\n-        _TIMEDELTA_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda v: pd.Timedelta(v, unit='ns')\n-        )\n-    except ImportError:\n-        pass\n+        return _datetime_from_int(sp.value, unit=dtype.unit(), tzinfo=tzinfo)\n \n-    return _TIMEDELTA_CONVERSION_FUNCTIONS\n \n-\n-cdef class DurationValue(ArrayValue):\n+cdef class DurationScalar(Scalar):\n     \"\"\"\n-    Concrete class for duration array elements.\n+    Concrete class for duration scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        cdef CDurationType* dtype = <CDurationType*> ap.type().get()\n+        cdef:\n+            CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+            CDurationType* dtype = <CDurationType*> sp.type.get()\n+            TimeUnit unit = dtype.unit()\n+\n+        if not sp.is_valid:\n+            return None\n \n-        cdef int64_t value = ap.Value(self.index)\n-        converter = _timedelta_conversion_functions()[dtype.unit()]\n-        return converter(value)\n+        if unit == TimeUnit_SECOND:\n+            return datetime.timedelta(seconds=sp.value)\n+        elif unit == TimeUnit_MILLI:\n+            return datetime.timedelta(milliseconds=sp.value)\n+        elif unit == TimeUnit_MICRO:\n+            return datetime.timedelta(microseconds=sp.value)\n+        else:\n+            # TimeUnit_NANO: prefer pandas timestamps if available\n+            if _pandas_api.have_pandas:\n+                return _pandas_api.pd.Timedelta(sp.value, unit='ns')\n+            # otherwise safely truncate to microsecond resolution timedelta\n+            if sp.value % 1000 != 0:\n+                raise ValueError(\n+                    \"Nanosecond duration {} is not safely convertible to \"\n+                    \"microseconds to convert to datetime.timedelta. Install \"\n+                    \"pandas to return as Timedelta with nanosecond support or \"\n+                    \"access the .value attribute.\".format(sp.value)\n+                )\n+            return datetime.timedelta(microseconds=sp.value // 1000)\n \n \n-cdef class HalfFloatValue(ArrayValue):\n+cdef class BinaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for float16 array elements.\n+    Concrete class for binary-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def as_buffer(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return a view over this value as a Buffer object.\n         \"\"\"\n-        cdef CHalfFloatArray* ap = <CHalfFloatArray*> self.sp_array.get()\n-        return PyHalf_FromHalf(ap.Value(self.index))\n-\n-\n-cdef class FloatValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float32 array elements.\n-    \"\"\"\n+        cdef CBinaryScalar* sp = <CBinaryScalar*> self.wrapped.get()\n+        return pyarrow_wrap_buffer(sp.value) if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value as a Python bytes.\n         \"\"\"\n-        cdef CFloatArray* ap = <CFloatArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return self.as_buffer().to_pybytes()\n+        else:\n+            return None\n \n \n-cdef class DoubleValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float64 array elements.\n-    \"\"\"\n+cdef class LargeBinaryScalar(BinaryScalar):\n+    pass\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python float.\n-        \"\"\"\n-        cdef CDoubleArray* ap = <CDoubleArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+\n+cdef class FixedSizeBinaryScalar(BinaryScalar):\n+    pass\n \n \n-cdef class DecimalValue(ArrayValue):\n+cdef class StringScalar(BinaryScalar):\n     \"\"\"\n-    Concrete class for decimal128 array elements.\n+    Concrete class for string-like (utf8) scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python Decimal.\n+        Return this value as a Python string.\n         \"\"\"\n-        cdef:\n-            CDecimal128Array* ap = <CDecimal128Array*> self.sp_array.get()\n-            c_string s = ap.FormatValue(self.index)\n-        return _pydecimal.Decimal(s.decode('utf8'))\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return frombytes(self.as_buffer().to_pybytes())\n+        else:\n+            return None\n+\n \n+cdef class LargeStringScalar(StringScalar):\n+    pass\n \n-cdef class StringValue(ArrayValue):\n+\n+cdef class ListScalar(Scalar):\n     \"\"\"\n-    Concrete class for string (utf8) array elements.\n+    Concrete class for list-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    @property\n+    def values(self):\n+        cdef CListScalar* sp = <CListScalar*> self.wrapped.get()\n+        if sp.is_valid:\n+            return pyarrow_wrap_array(sp.value)\n+        else:\n+            return None\n+\n+    def __len__(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Return the number of values.\n         \"\"\"\n-        cdef CStringArray* ap = <CStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        return len(self.values)\n \n-    def as_buffer(self):\n+    def __getitem__(self, i):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return the value at the given index.\n         \"\"\"\n-        cdef:\n-            CStringArray* ap = <CStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n-\n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n-\n+        return self.values[_normalize_index(i, len(self))]\n \n-cdef class LargeStringValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large string (utf8) array elements.\n-    \"\"\"\n-\n-    def as_py(self):\n+    def __iter__(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Iterate over this element's values.\n         \"\"\"\n-        cdef CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        return iter(self.values)\n \n-    def as_buffer(self):\n+    def as_py(self):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return this value as a Python list.\n         \"\"\"\n-        cdef:\n-            CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+        arr = self.values\n+        return None if arr is None else arr.to_pylist()\n+\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+cdef class FixedSizeListScalar(ListScalar):\n\nReview comment:\n       Like above, you cannot inherit `ListScalar.values` safely.\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def __eq__(self, other):\n+        if hasattr(self, 'as_py'):\n+            if isinstance(other, Scalar):\n+                other = other.as_py()\n+            return self.as_py() == other\n+        else:\n+            raise NotImplementedError\n+\n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n+\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class Decimal128Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value // 1000)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n         else:\n             tzinfo = None\n \n-        try:\n-            converter = _datetime_conversion_functions()[dtype.unit()]\n-        except KeyError:\n-            raise ValueError(\n-                'Cannot convert nanosecond timestamps without pandas'\n-            )\n-        return converter(value, tzinfo=tzinfo)\n-\n-\n-cdef dict _TIMEDELTA_CONVERSION_FUNCTIONS = {}\n-\n-\n-def _nanoseconds_to_timedelta_safe(v):\n-    if v % 1000 != 0:\n-        raise ValueError(\n-            \"Nanosecond duration {} is not safely convertible to microseconds \"\n-            \"to convert to datetime.timedelta. Install pandas to return as \"\n-            \"Timedelta with nanosecond support or access the .value \"\n-            \"attribute.\".format(v))\n-    micros = v // 1000\n-\n-    return datetime.timedelta(microseconds=micros)\n-\n-\n-def _timedelta_conversion_functions():\n-    if _TIMEDELTA_CONVERSION_FUNCTIONS:\n-        return _TIMEDELTA_CONVERSION_FUNCTIONS\n-\n-    _TIMEDELTA_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: lambda v: datetime.timedelta(seconds=v),\n-        TimeUnit_MILLI: lambda v: datetime.timedelta(milliseconds=v),\n-        TimeUnit_MICRO: lambda v: datetime.timedelta(microseconds=v),\n-        TimeUnit_NANO: _nanoseconds_to_timedelta_safe\n-    })\n-\n-    try:\n-        import pandas as pd\n-        _TIMEDELTA_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda v: pd.Timedelta(v, unit='ns')\n-        )\n-    except ImportError:\n-        pass\n+        return _datetime_from_int(sp.value, unit=dtype.unit(), tzinfo=tzinfo)\n \n-    return _TIMEDELTA_CONVERSION_FUNCTIONS\n \n-\n-cdef class DurationValue(ArrayValue):\n+cdef class DurationScalar(Scalar):\n     \"\"\"\n-    Concrete class for duration array elements.\n+    Concrete class for duration scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        cdef CDurationType* dtype = <CDurationType*> ap.type().get()\n+        cdef:\n+            CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+            CDurationType* dtype = <CDurationType*> sp.type.get()\n+            TimeUnit unit = dtype.unit()\n+\n+        if not sp.is_valid:\n+            return None\n \n-        cdef int64_t value = ap.Value(self.index)\n-        converter = _timedelta_conversion_functions()[dtype.unit()]\n-        return converter(value)\n+        if unit == TimeUnit_SECOND:\n+            return datetime.timedelta(seconds=sp.value)\n+        elif unit == TimeUnit_MILLI:\n+            return datetime.timedelta(milliseconds=sp.value)\n+        elif unit == TimeUnit_MICRO:\n+            return datetime.timedelta(microseconds=sp.value)\n+        else:\n+            # TimeUnit_NANO: prefer pandas timestamps if available\n+            if _pandas_api.have_pandas:\n+                return _pandas_api.pd.Timedelta(sp.value, unit='ns')\n+            # otherwise safely truncate to microsecond resolution timedelta\n+            if sp.value % 1000 != 0:\n+                raise ValueError(\n+                    \"Nanosecond duration {} is not safely convertible to \"\n+                    \"microseconds to convert to datetime.timedelta. Install \"\n+                    \"pandas to return as Timedelta with nanosecond support or \"\n+                    \"access the .value attribute.\".format(sp.value)\n+                )\n+            return datetime.timedelta(microseconds=sp.value // 1000)\n \n \n-cdef class HalfFloatValue(ArrayValue):\n+cdef class BinaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for float16 array elements.\n+    Concrete class for binary-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def as_buffer(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return a view over this value as a Buffer object.\n         \"\"\"\n-        cdef CHalfFloatArray* ap = <CHalfFloatArray*> self.sp_array.get()\n-        return PyHalf_FromHalf(ap.Value(self.index))\n-\n-\n-cdef class FloatValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float32 array elements.\n-    \"\"\"\n+        cdef CBinaryScalar* sp = <CBinaryScalar*> self.wrapped.get()\n+        return pyarrow_wrap_buffer(sp.value) if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value as a Python bytes.\n         \"\"\"\n-        cdef CFloatArray* ap = <CFloatArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return self.as_buffer().to_pybytes()\n+        else:\n+            return None\n \n \n-cdef class DoubleValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float64 array elements.\n-    \"\"\"\n+cdef class LargeBinaryScalar(BinaryScalar):\n+    pass\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python float.\n-        \"\"\"\n-        cdef CDoubleArray* ap = <CDoubleArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+\n+cdef class FixedSizeBinaryScalar(BinaryScalar):\n+    pass\n \n \n-cdef class DecimalValue(ArrayValue):\n+cdef class StringScalar(BinaryScalar):\n     \"\"\"\n-    Concrete class for decimal128 array elements.\n+    Concrete class for string-like (utf8) scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python Decimal.\n+        Return this value as a Python string.\n         \"\"\"\n-        cdef:\n-            CDecimal128Array* ap = <CDecimal128Array*> self.sp_array.get()\n-            c_string s = ap.FormatValue(self.index)\n-        return _pydecimal.Decimal(s.decode('utf8'))\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return frombytes(self.as_buffer().to_pybytes())\n+        else:\n+            return None\n+\n \n+cdef class LargeStringScalar(StringScalar):\n+    pass\n \n-cdef class StringValue(ArrayValue):\n+\n+cdef class ListScalar(Scalar):\n     \"\"\"\n-    Concrete class for string (utf8) array elements.\n+    Concrete class for list-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    @property\n+    def values(self):\n+        cdef CListScalar* sp = <CListScalar*> self.wrapped.get()\n+        if sp.is_valid:\n+            return pyarrow_wrap_array(sp.value)\n+        else:\n+            return None\n+\n+    def __len__(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Return the number of values.\n         \"\"\"\n-        cdef CStringArray* ap = <CStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        return len(self.values)\n \n-    def as_buffer(self):\n+    def __getitem__(self, i):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return the value at the given index.\n         \"\"\"\n-        cdef:\n-            CStringArray* ap = <CStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n-\n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n-\n+        return self.values[_normalize_index(i, len(self))]\n \n-cdef class LargeStringValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large string (utf8) array elements.\n-    \"\"\"\n-\n-    def as_py(self):\n+    def __iter__(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Iterate over this element's values.\n         \"\"\"\n-        cdef CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        return iter(self.values)\n \n-    def as_buffer(self):\n+    def as_py(self):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return this value as a Python list.\n         \"\"\"\n-        cdef:\n-            CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+        arr = self.values\n+        return None if arr is None else arr.to_pylist()\n+\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+cdef class FixedSizeListScalar(ListScalar):\n+    pass\n \n \n-cdef class BinaryValue(ArrayValue):\n+cdef class LargeListScalar(ListScalar):\n+    pass\n+\n+\n+cdef class StructScalar(Scalar, collections.abc.Mapping):\n     \"\"\"\n-    Concrete class for variable-sized binary array elements.\n+    Concrete class for struct scalars.\n     \"\"\"\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python bytes object.\n-        \"\"\"\n+    def __len__(self):\n+        cdef CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+        return sp.value.size()\n+\n+    def __iter__(self):\n         cdef:\n-            const uint8_t* ptr\n-            int32_t length\n-            CBinaryArray* ap = <CBinaryArray*> self.sp_array.get()\n+            CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+            CStructType* dtype = <CStructType*> sp.type.get()\n+            vector[shared_ptr[CField]] fields = dtype.fields()\n \n-        ptr = ap.GetValue(self.index, &length)\n-        return cp.PyBytes_FromStringAndSize(<const char*>(ptr), length)\n+        if sp.is_valid:\n+            for i in range(dtype.num_fields()):\n+                yield frombytes(fields[i].get().name())\n \n-    def as_buffer(self):\n+    def __contains__(self, key):\n+        try:\n+            self[key]\n+        except IndexError:\n+            return False\n+        else:\n+            return True\n+\n+    def __getitem__(self, key):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return the child value for the given field.\n+\n+        Parameters\n+        ----------\n+        index : Union[int, str]\n+            Index / position or name of the field.\n+\n+        Returns\n+        -------\n+        result : Scalar\n         \"\"\"\n         cdef:\n-            CBinaryArray* ap = <CBinaryArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+            CFieldRef ref\n+            CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+        if isinstance(key, (bytes, str)):\n+            ref = CFieldRef(<c_string> tobytes(key))\n+        elif isinstance(key, int):\n+            ref = CFieldRef(<int> key)\n+        else:\n+            raise TypeError('Expected integer or string index')\n \n-\n-cdef class LargeBinaryValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large variable-sized binary array elements.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python bytes object.\n-        \"\"\"\n-        cdef:\n-            const uint8_t* ptr\n-            int64_t length\n-            CLargeBinaryArray* ap = <CLargeBinaryArray*> self.sp_array.get()\n-\n-        ptr = ap.GetValue(self.index, &length)\n-        return cp.PyBytes_FromStringAndSize(<const char*>(ptr), length)\n-\n-    def as_buffer(self):\n-        \"\"\"\n-        Return a view over this value as a Buffer object.\n-        \"\"\"\n-        cdef:\n-            CLargeBinaryArray* ap = <CLargeBinaryArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n-\n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n-\n-\n-cdef class ListValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for list array elements.\n-    \"\"\"\n-\n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n-    def __getitem__(self, i):\n-        \"\"\"\n-        Return the value at the given index.\n-        \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n-\n-    def __iter__(self):\n-        \"\"\"\n-        Iterate over this element's values.\n-        \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CListArray*> sp_array.get()\n-        self.value_type = pyarrow_wrap_data_type(self.ap.value_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return box_scalar(self.value_type, self.ap.values(), j)\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python list.\n-        \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            result.append(self.getitem(j).as_py())\n-\n-        return result\n-\n-\n-cdef class LargeListValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large list array elements.\n-    \"\"\"\n-\n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n-    def __getitem__(self, i):\n-        \"\"\"\n-        Return the value at the given index.\n-        \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n-\n-    def __iter__(self):\n-        \"\"\"\n-        Iterate over this element's values.\n-        \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CLargeListArray*> sp_array.get()\n-        self.value_type = pyarrow_wrap_data_type(self.ap.value_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return box_scalar(self.value_type, self.ap.values(), j)\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python list.\n-        \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            result.append(self.getitem(j).as_py())\n-\n-        return result\n-\n-\n-cdef class MapValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for map array elements.\n-    \"\"\"\n-\n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n-    def __getitem__(self, i):\n-        \"\"\"\n-        Return the value at the given index.\n-        \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n-\n-    def __iter__(self):\n-        \"\"\"\n-        Iterate over this element's values.\n-        \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CMapArray*> sp_array.get()\n-        self.key_type = pyarrow_wrap_data_type(self.ap.map_type().key_type())\n-        self.item_type = pyarrow_wrap_data_type(self.ap.map_type().item_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return (box_scalar(self.key_type, self.ap.keys(), j),\n-                box_scalar(self.item_type, self.ap.items(), j))\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n+        try:\n+            return Scalar.wrap(GetResultValue(sp.field(ref)))\n+        except ArrowInvalid:\n+            raise IndexError(key)\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python list of tuples, each containing a\n-        key and item.\n+        Return this value as a Python dict.\n         \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            key, item = self.getitem(j)\n-            result.append((key.as_py(), item.as_py()))\n-\n-        return result\n+        if self.is_valid:\n+            return {k: v.as_py() for k, v in self.items()}\n+        else:\n+            return None\n \n \n-cdef class FixedSizeListValue(ArrayValue):\n+cdef class MapScalar(ListScalar):\n     \"\"\"\n-    Concrete class for fixed size list array elements.\n+    Concrete class for map scalars.\n     \"\"\"\n \n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n     def __getitem__(self, i):\n         \"\"\"\n         Return the value at the given index.\n         \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n+        arr = self.values\n+        if arr is None:\n+            raise IndexError(i)\n+        dct = arr[_normalize_index(i, len(arr))]\n+        return (dct['key'], dct['value'])\n \n     def __iter__(self):\n         \"\"\"\n         Iterate over this element's values.\n         \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CFixedSizeListArray*> sp_array.get()\n-        self.value_type = pyarrow_wrap_data_type(self.ap.value_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return box_scalar(self.value_type, self.ap.values(), j)\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n+        arr = self.values\n+        if arr is None:\n+            return iter(zip(arr.field('key'), arr.field('value')))\n+        else:\n+            raise StopIteration\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python list.\n         \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            result.append(self.getitem(j).as_py())\n-\n-        return result\n-\n-\n-cdef class UnionValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for union array elements.\n-    \"\"\"\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CUnionArray*> sp_array.get()\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int child_id = self.ap.child_id(i)\n-        cdef shared_ptr[CArray] child = self.ap.field(child_id)\n-        cdef CDenseUnionArray* dense\n-        if self.ap.mode() == _UnionMode_SPARSE:\n-            return box_scalar(self.type[child_id].type, child, i)\n+        arr = self.values\n+        if arr is not None:\n+            return list(zip(arr.field('key'), arr.field('value')))\n         else:\n-            dense = <CDenseUnionArray*> self.ap\n-            return box_scalar(self.type[child_id].type, child,\n-                              dense.value_offset(i))\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python object.\n-\n-        The exact type depends on the underlying union member.\n-        \"\"\"\n-        return self.getitem(self.index).as_py()\n+            return None\n \n \n-cdef class FixedSizeBinaryValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for fixed-size binary array elements.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python bytes object.\n-        \"\"\"\n-        cdef:\n-            CFixedSizeBinaryArray* ap\n-            CFixedSizeBinaryType* ap_type\n-            int32_t length\n-            const char* data\n-        ap = <CFixedSizeBinaryArray*> self.sp_array.get()\n-        ap_type = <CFixedSizeBinaryType*> ap.type().get()\n-        length = ap_type.byte_width()\n-        data = <const char*> ap.GetValue(self.index)\n-        return cp.PyBytes_FromStringAndSize(data, length)\n-\n-\n-cdef class StructValue(ArrayValue):\n+cdef class DictionaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for struct array elements.\n+    Concrete class for dictionary-encoded scalars.\n     \"\"\"\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CStructArray*> sp_array.get()\n-\n-    def __getitem__(self, key):\n-        \"\"\"\n-        Return the child value for the given field name.\n-        \"\"\"\n-        cdef:\n-            CStructType* type\n-            int index\n-\n-        type = <CStructType*> self.type.type\n-        index = type.GetFieldIndex(tobytes(key))\n-\n-        if index < 0:\n-            raise KeyError(key)\n+    # @property\n+    # def index(self):\n+    #     \"\"\"\n+    #     Return this value's underlying index as a scalar.\n+    #     \"\"\"\n+    #     cdef CDictionaryScalar* sp = <CDictionaryScalar*> self.wrapped.get()\n+    #     return Scalar.wrap(sp.index)\n \n-        return pyarrow_wrap_array(self.ap.field(index))[self.index]\n-\n-    def as_py(self):\n+    @property\n+    def value(self):\n         \"\"\"\n-        Return this value as a Python dict.\n+        Return this value's underlying dictionary value as a scalar.\n         \"\"\"\n-        cdef:\n-            vector[shared_ptr[CField]] child_fields = self.type.type.fields()\n-\n-        wrapped_arrays = [pyarrow_wrap_array(self.ap.field(i))\n-                          for i in range(self.ap.num_fields())]\n-        child_names = [child.get().name() for child in child_fields]\n-        # Return the struct as a dict\n-        return {\n-            frombytes(name): child_array[self.index].as_py()\n-            for name, child_array in zip(child_names, wrapped_arrays)\n-        }\n-\n-\n-cdef class DictionaryValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for dictionary-encoded array elements.\n-    \"\"\"\n+        cdef CDictionaryScalar* sp = <CDictionaryScalar*> self.wrapped.get()\n+        return Scalar.wrap(sp.value)\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python object.\n \n         The exact type depends on the dictionary value type.\n         \"\"\"\n-        return self.dictionary_value.as_py()\n+        value = self.value\n+        return None if value is None else value.as_py()\n \n-    @property\n-    def index_value(self):\n-        \"\"\"\n-        Return this value's underlying index as a ArrayValue of the right\n-        signed integer type.\n-        \"\"\"\n-        cdef CDictionaryArray* darr = <CDictionaryArray*>(self.sp_array.get())\n-        indices = pyarrow_wrap_array(darr.indices())\n-        return indices[self.index]\n+    # TODO(kszucs): deprecate these\n+    # @property\n+    # def index_value(self):\n+    #     index = self.index\n+    #     return None if index is None else self.index\n \n     @property\n     def dictionary_value(self):\n-        \"\"\"\n-        Return this value's underlying dictionary value as a ArrayValue.\n-        \"\"\"\n-        cdef CDictionaryArray* darr = <CDictionaryArray*>(self.sp_array.get())\n-        dictionary = pyarrow_wrap_array(darr.dictionary())\n-        return dictionary[self.index_value.as_py()]\n-\n-\n-cdef dict _array_value_classes = {\n-    _Type_BOOL: BooleanValue,\n-    _Type_UINT8: UInt8Value,\n-    _Type_UINT16: UInt16Value,\n-    _Type_UINT32: UInt32Value,\n-    _Type_UINT64: UInt64Value,\n-    _Type_INT8: Int8Value,\n-    _Type_INT16: Int16Value,\n-    _Type_INT32: Int32Value,\n-    _Type_INT64: Int64Value,\n-    _Type_DATE32: Date32Value,\n-    _Type_DATE64: Date64Value,\n-    _Type_TIME32: Time32Value,\n-    _Type_TIME64: Time64Value,\n-    _Type_TIMESTAMP: TimestampValue,\n-    _Type_DURATION: DurationValue,\n-    _Type_HALF_FLOAT: HalfFloatValue,\n-    _Type_FLOAT: FloatValue,\n-    _Type_DOUBLE: DoubleValue,\n-    _Type_LIST: ListValue,\n-    _Type_LARGE_LIST: LargeListValue,\n-    _Type_MAP: MapValue,\n-    _Type_FIXED_SIZE_LIST: FixedSizeListValue,\n-    _Type_SPARSE_UNION: UnionValue,\n-    _Type_DENSE_UNION: UnionValue,\n-    _Type_BINARY: BinaryValue,\n-    _Type_STRING: StringValue,\n-    _Type_LARGE_BINARY: LargeBinaryValue,\n-    _Type_LARGE_STRING: LargeStringValue,\n-    _Type_FIXED_SIZE_BINARY: FixedSizeBinaryValue,\n-    _Type_DECIMAL: DecimalValue,\n-    _Type_STRUCT: StructValue,\n-    _Type_DICTIONARY: DictionaryValue,\n-}\n-\n-cdef class ScalarValue(Scalar):\n-    \"\"\"\n-    The base class for scalars.\n-    \"\"\"\n-\n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly.\"\n-                        .format(self.__class__.__name__))\n-\n-    cdef void init(self, const shared_ptr[CScalar]& sp_scalar):\n-        self.sp_scalar = sp_scalar\n-\n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n-\n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n-\n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ScalarValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplemented(\n-                \"Cannot compare scalars that don't support as_py()\")\n-\n-    def __hash__(self):\n-        return hash(self.as_py())\n-\n-\n-cdef class NullScalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for null scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python None.\n-        \"\"\"\n-        return None\n-\n-\n-cdef class BooleanScalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for boolean scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python bool.\n-        \"\"\"\n-        cdef CBooleanScalar* sp = <CBooleanScalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class UInt8Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for uint8 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class Int8Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for int8 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CInt8Scalar* sp = <CInt8Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class UInt16Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for uint16 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class Int16Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for int16 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CInt16Scalar* sp = <CInt16Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class UInt32Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for uint32 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class Int32Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for int32 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CInt32Scalar* sp = <CInt32Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class UInt64Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for uint64 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class Int64Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for int64 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CInt64Scalar* sp = <CInt64Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n+        value = self.value\n+        return None if value is None else self.value\n \n \n-cdef class FloatScalar(ScalarValue):\n+cdef class UnionScalar(Scalar):\n     \"\"\"\n-    Concrete class for float scalars.\n+    Concrete class for Union scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    @property\n+    def value(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value's underlying dictionary value as a scalar.\n\nReview comment:\n       There's no dictionary here.\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def __eq__(self, other):\n+        if hasattr(self, 'as_py'):\n+            if isinstance(other, Scalar):\n+                other = other.as_py()\n+            return self.as_py() == other\n+        else:\n+            raise NotImplementedError\n+\n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n+\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class Decimal128Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value // 1000)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n         else:\n             tzinfo = None\n \n-        try:\n-            converter = _datetime_conversion_functions()[dtype.unit()]\n-        except KeyError:\n-            raise ValueError(\n-                'Cannot convert nanosecond timestamps without pandas'\n-            )\n-        return converter(value, tzinfo=tzinfo)\n-\n-\n-cdef dict _TIMEDELTA_CONVERSION_FUNCTIONS = {}\n-\n-\n-def _nanoseconds_to_timedelta_safe(v):\n-    if v % 1000 != 0:\n-        raise ValueError(\n-            \"Nanosecond duration {} is not safely convertible to microseconds \"\n-            \"to convert to datetime.timedelta. Install pandas to return as \"\n-            \"Timedelta with nanosecond support or access the .value \"\n-            \"attribute.\".format(v))\n-    micros = v // 1000\n-\n-    return datetime.timedelta(microseconds=micros)\n-\n-\n-def _timedelta_conversion_functions():\n-    if _TIMEDELTA_CONVERSION_FUNCTIONS:\n-        return _TIMEDELTA_CONVERSION_FUNCTIONS\n-\n-    _TIMEDELTA_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: lambda v: datetime.timedelta(seconds=v),\n-        TimeUnit_MILLI: lambda v: datetime.timedelta(milliseconds=v),\n-        TimeUnit_MICRO: lambda v: datetime.timedelta(microseconds=v),\n-        TimeUnit_NANO: _nanoseconds_to_timedelta_safe\n-    })\n-\n-    try:\n-        import pandas as pd\n-        _TIMEDELTA_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda v: pd.Timedelta(v, unit='ns')\n-        )\n-    except ImportError:\n-        pass\n+        return _datetime_from_int(sp.value, unit=dtype.unit(), tzinfo=tzinfo)\n \n-    return _TIMEDELTA_CONVERSION_FUNCTIONS\n \n-\n-cdef class DurationValue(ArrayValue):\n+cdef class DurationScalar(Scalar):\n     \"\"\"\n-    Concrete class for duration array elements.\n+    Concrete class for duration scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        cdef CDurationType* dtype = <CDurationType*> ap.type().get()\n+        cdef:\n+            CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+            CDurationType* dtype = <CDurationType*> sp.type.get()\n+            TimeUnit unit = dtype.unit()\n+\n+        if not sp.is_valid:\n+            return None\n \n-        cdef int64_t value = ap.Value(self.index)\n-        converter = _timedelta_conversion_functions()[dtype.unit()]\n-        return converter(value)\n+        if unit == TimeUnit_SECOND:\n+            return datetime.timedelta(seconds=sp.value)\n+        elif unit == TimeUnit_MILLI:\n+            return datetime.timedelta(milliseconds=sp.value)\n+        elif unit == TimeUnit_MICRO:\n+            return datetime.timedelta(microseconds=sp.value)\n+        else:\n+            # TimeUnit_NANO: prefer pandas timestamps if available\n+            if _pandas_api.have_pandas:\n+                return _pandas_api.pd.Timedelta(sp.value, unit='ns')\n+            # otherwise safely truncate to microsecond resolution timedelta\n+            if sp.value % 1000 != 0:\n+                raise ValueError(\n+                    \"Nanosecond duration {} is not safely convertible to \"\n+                    \"microseconds to convert to datetime.timedelta. Install \"\n+                    \"pandas to return as Timedelta with nanosecond support or \"\n+                    \"access the .value attribute.\".format(sp.value)\n+                )\n+            return datetime.timedelta(microseconds=sp.value // 1000)\n \n \n-cdef class HalfFloatValue(ArrayValue):\n+cdef class BinaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for float16 array elements.\n+    Concrete class for binary-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def as_buffer(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return a view over this value as a Buffer object.\n         \"\"\"\n-        cdef CHalfFloatArray* ap = <CHalfFloatArray*> self.sp_array.get()\n-        return PyHalf_FromHalf(ap.Value(self.index))\n-\n-\n-cdef class FloatValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float32 array elements.\n-    \"\"\"\n+        cdef CBinaryScalar* sp = <CBinaryScalar*> self.wrapped.get()\n+        return pyarrow_wrap_buffer(sp.value) if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value as a Python bytes.\n         \"\"\"\n-        cdef CFloatArray* ap = <CFloatArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return self.as_buffer().to_pybytes()\n+        else:\n+            return None\n \n \n-cdef class DoubleValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float64 array elements.\n-    \"\"\"\n+cdef class LargeBinaryScalar(BinaryScalar):\n+    pass\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python float.\n-        \"\"\"\n-        cdef CDoubleArray* ap = <CDoubleArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+\n+cdef class FixedSizeBinaryScalar(BinaryScalar):\n+    pass\n \n \n-cdef class DecimalValue(ArrayValue):\n+cdef class StringScalar(BinaryScalar):\n     \"\"\"\n-    Concrete class for decimal128 array elements.\n+    Concrete class for string-like (utf8) scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python Decimal.\n+        Return this value as a Python string.\n         \"\"\"\n-        cdef:\n-            CDecimal128Array* ap = <CDecimal128Array*> self.sp_array.get()\n-            c_string s = ap.FormatValue(self.index)\n-        return _pydecimal.Decimal(s.decode('utf8'))\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return frombytes(self.as_buffer().to_pybytes())\n+        else:\n+            return None\n+\n \n+cdef class LargeStringScalar(StringScalar):\n+    pass\n \n-cdef class StringValue(ArrayValue):\n+\n+cdef class ListScalar(Scalar):\n     \"\"\"\n-    Concrete class for string (utf8) array elements.\n+    Concrete class for list-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    @property\n+    def values(self):\n+        cdef CListScalar* sp = <CListScalar*> self.wrapped.get()\n+        if sp.is_valid:\n+            return pyarrow_wrap_array(sp.value)\n+        else:\n+            return None\n+\n+    def __len__(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Return the number of values.\n         \"\"\"\n-        cdef CStringArray* ap = <CStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        return len(self.values)\n \n-    def as_buffer(self):\n+    def __getitem__(self, i):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return the value at the given index.\n         \"\"\"\n-        cdef:\n-            CStringArray* ap = <CStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n-\n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n-\n+        return self.values[_normalize_index(i, len(self))]\n \n-cdef class LargeStringValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large string (utf8) array elements.\n-    \"\"\"\n-\n-    def as_py(self):\n+    def __iter__(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Iterate over this element's values.\n         \"\"\"\n-        cdef CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        return iter(self.values)\n \n-    def as_buffer(self):\n+    def as_py(self):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return this value as a Python list.\n         \"\"\"\n-        cdef:\n-            CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+        arr = self.values\n+        return None if arr is None else arr.to_pylist()\n+\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+cdef class FixedSizeListScalar(ListScalar):\n+    pass\n \n \n-cdef class BinaryValue(ArrayValue):\n+cdef class LargeListScalar(ListScalar):\n+    pass\n+\n+\n+cdef class StructScalar(Scalar, collections.abc.Mapping):\n     \"\"\"\n-    Concrete class for variable-sized binary array elements.\n+    Concrete class for struct scalars.\n     \"\"\"\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python bytes object.\n-        \"\"\"\n+    def __len__(self):\n+        cdef CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+        return sp.value.size()\n+\n+    def __iter__(self):\n         cdef:\n-            const uint8_t* ptr\n-            int32_t length\n-            CBinaryArray* ap = <CBinaryArray*> self.sp_array.get()\n+            CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+            CStructType* dtype = <CStructType*> sp.type.get()\n+            vector[shared_ptr[CField]] fields = dtype.fields()\n \n-        ptr = ap.GetValue(self.index, &length)\n-        return cp.PyBytes_FromStringAndSize(<const char*>(ptr), length)\n+        if sp.is_valid:\n+            for i in range(dtype.num_fields()):\n+                yield frombytes(fields[i].get().name())\n \n-    def as_buffer(self):\n+    def __contains__(self, key):\n+        try:\n+            self[key]\n+        except IndexError:\n+            return False\n+        else:\n+            return True\n+\n+    def __getitem__(self, key):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return the child value for the given field.\n+\n+        Parameters\n+        ----------\n+        index : Union[int, str]\n+            Index / position or name of the field.\n+\n+        Returns\n+        -------\n+        result : Scalar\n         \"\"\"\n         cdef:\n-            CBinaryArray* ap = <CBinaryArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+            CFieldRef ref\n+            CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+        if isinstance(key, (bytes, str)):\n+            ref = CFieldRef(<c_string> tobytes(key))\n+        elif isinstance(key, int):\n+            ref = CFieldRef(<int> key)\n+        else:\n+            raise TypeError('Expected integer or string index')\n \n-\n-cdef class LargeBinaryValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large variable-sized binary array elements.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python bytes object.\n-        \"\"\"\n-        cdef:\n-            const uint8_t* ptr\n-            int64_t length\n-            CLargeBinaryArray* ap = <CLargeBinaryArray*> self.sp_array.get()\n-\n-        ptr = ap.GetValue(self.index, &length)\n-        return cp.PyBytes_FromStringAndSize(<const char*>(ptr), length)\n-\n-    def as_buffer(self):\n-        \"\"\"\n-        Return a view over this value as a Buffer object.\n-        \"\"\"\n-        cdef:\n-            CLargeBinaryArray* ap = <CLargeBinaryArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n-\n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n-\n-\n-cdef class ListValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for list array elements.\n-    \"\"\"\n-\n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n-    def __getitem__(self, i):\n-        \"\"\"\n-        Return the value at the given index.\n-        \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n-\n-    def __iter__(self):\n-        \"\"\"\n-        Iterate over this element's values.\n-        \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CListArray*> sp_array.get()\n-        self.value_type = pyarrow_wrap_data_type(self.ap.value_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return box_scalar(self.value_type, self.ap.values(), j)\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python list.\n-        \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            result.append(self.getitem(j).as_py())\n-\n-        return result\n-\n-\n-cdef class LargeListValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for large list array elements.\n-    \"\"\"\n-\n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n-    def __getitem__(self, i):\n-        \"\"\"\n-        Return the value at the given index.\n-        \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n-\n-    def __iter__(self):\n-        \"\"\"\n-        Iterate over this element's values.\n-        \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CLargeListArray*> sp_array.get()\n-        self.value_type = pyarrow_wrap_data_type(self.ap.value_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return box_scalar(self.value_type, self.ap.values(), j)\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python list.\n-        \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            result.append(self.getitem(j).as_py())\n-\n-        return result\n-\n-\n-cdef class MapValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for map array elements.\n-    \"\"\"\n-\n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n-    def __getitem__(self, i):\n-        \"\"\"\n-        Return the value at the given index.\n-        \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n-\n-    def __iter__(self):\n-        \"\"\"\n-        Iterate over this element's values.\n-        \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CMapArray*> sp_array.get()\n-        self.key_type = pyarrow_wrap_data_type(self.ap.map_type().key_type())\n-        self.item_type = pyarrow_wrap_data_type(self.ap.map_type().item_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return (box_scalar(self.key_type, self.ap.keys(), j),\n-                box_scalar(self.item_type, self.ap.items(), j))\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n+        try:\n+            return Scalar.wrap(GetResultValue(sp.field(ref)))\n+        except ArrowInvalid:\n+            raise IndexError(key)\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python list of tuples, each containing a\n-        key and item.\n+        Return this value as a Python dict.\n         \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            key, item = self.getitem(j)\n-            result.append((key.as_py(), item.as_py()))\n-\n-        return result\n+        if self.is_valid:\n+            return {k: v.as_py() for k, v in self.items()}\n+        else:\n+            return None\n \n \n-cdef class FixedSizeListValue(ArrayValue):\n+cdef class MapScalar(ListScalar):\n     \"\"\"\n-    Concrete class for fixed size list array elements.\n+    Concrete class for map scalars.\n     \"\"\"\n \n-    def __len__(self):\n-        \"\"\"\n-        Return the number of values.\n-        \"\"\"\n-        return self.length()\n-\n     def __getitem__(self, i):\n         \"\"\"\n         Return the value at the given index.\n         \"\"\"\n-        return self.getitem(_normalize_index(i, self.length()))\n+        arr = self.values\n+        if arr is None:\n+            raise IndexError(i)\n+        dct = arr[_normalize_index(i, len(arr))]\n+        return (dct['key'], dct['value'])\n \n     def __iter__(self):\n         \"\"\"\n         Iterate over this element's values.\n         \"\"\"\n-        for i in range(len(self)):\n-            yield self.getitem(i)\n-        raise StopIteration\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CFixedSizeListArray*> sp_array.get()\n-        self.value_type = pyarrow_wrap_data_type(self.ap.value_type())\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int64_t j = self.ap.value_offset(self.index) + i\n-        return box_scalar(self.value_type, self.ap.values(), j)\n-\n-    cdef int64_t length(self):\n-        return self.ap.value_length(self.index)\n+        arr = self.values\n+        if arr is None:\n+            return iter(zip(arr.field('key'), arr.field('value')))\n+        else:\n+            raise StopIteration\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python list.\n         \"\"\"\n-        cdef:\n-            int64_t j\n-            list result = []\n-\n-        for j in range(len(self)):\n-            result.append(self.getitem(j).as_py())\n-\n-        return result\n-\n-\n-cdef class UnionValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for union array elements.\n-    \"\"\"\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CUnionArray*> sp_array.get()\n-\n-    cdef getitem(self, int64_t i):\n-        cdef int child_id = self.ap.child_id(i)\n-        cdef shared_ptr[CArray] child = self.ap.field(child_id)\n-        cdef CDenseUnionArray* dense\n-        if self.ap.mode() == _UnionMode_SPARSE:\n-            return box_scalar(self.type[child_id].type, child, i)\n+        arr = self.values\n+        if arr is not None:\n+            return list(zip(arr.field('key'), arr.field('value')))\n         else:\n-            dense = <CDenseUnionArray*> self.ap\n-            return box_scalar(self.type[child_id].type, child,\n-                              dense.value_offset(i))\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python object.\n-\n-        The exact type depends on the underlying union member.\n-        \"\"\"\n-        return self.getitem(self.index).as_py()\n+            return None\n \n \n-cdef class FixedSizeBinaryValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for fixed-size binary array elements.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python bytes object.\n-        \"\"\"\n-        cdef:\n-            CFixedSizeBinaryArray* ap\n-            CFixedSizeBinaryType* ap_type\n-            int32_t length\n-            const char* data\n-        ap = <CFixedSizeBinaryArray*> self.sp_array.get()\n-        ap_type = <CFixedSizeBinaryType*> ap.type().get()\n-        length = ap_type.byte_width()\n-        data = <const char*> ap.GetValue(self.index)\n-        return cp.PyBytes_FromStringAndSize(data, length)\n-\n-\n-cdef class StructValue(ArrayValue):\n+cdef class DictionaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for struct array elements.\n+    Concrete class for dictionary-encoded scalars.\n     \"\"\"\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n-        self.ap = <CStructArray*> sp_array.get()\n-\n-    def __getitem__(self, key):\n-        \"\"\"\n-        Return the child value for the given field name.\n-        \"\"\"\n-        cdef:\n-            CStructType* type\n-            int index\n-\n-        type = <CStructType*> self.type.type\n-        index = type.GetFieldIndex(tobytes(key))\n-\n-        if index < 0:\n-            raise KeyError(key)\n+    # @property\n+    # def index(self):\n+    #     \"\"\"\n+    #     Return this value's underlying index as a scalar.\n+    #     \"\"\"\n+    #     cdef CDictionaryScalar* sp = <CDictionaryScalar*> self.wrapped.get()\n+    #     return Scalar.wrap(sp.index)\n \n-        return pyarrow_wrap_array(self.ap.field(index))[self.index]\n-\n-    def as_py(self):\n+    @property\n+    def value(self):\n         \"\"\"\n-        Return this value as a Python dict.\n+        Return this value's underlying dictionary value as a scalar.\n         \"\"\"\n-        cdef:\n-            vector[shared_ptr[CField]] child_fields = self.type.type.fields()\n-\n-        wrapped_arrays = [pyarrow_wrap_array(self.ap.field(i))\n-                          for i in range(self.ap.num_fields())]\n-        child_names = [child.get().name() for child in child_fields]\n-        # Return the struct as a dict\n-        return {\n-            frombytes(name): child_array[self.index].as_py()\n-            for name, child_array in zip(child_names, wrapped_arrays)\n-        }\n-\n-\n-cdef class DictionaryValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for dictionary-encoded array elements.\n-    \"\"\"\n+        cdef CDictionaryScalar* sp = <CDictionaryScalar*> self.wrapped.get()\n+        return Scalar.wrap(sp.value)\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python object.\n \n         The exact type depends on the dictionary value type.\n         \"\"\"\n-        return self.dictionary_value.as_py()\n+        value = self.value\n+        return None if value is None else value.as_py()\n \n-    @property\n-    def index_value(self):\n-        \"\"\"\n-        Return this value's underlying index as a ArrayValue of the right\n-        signed integer type.\n-        \"\"\"\n-        cdef CDictionaryArray* darr = <CDictionaryArray*>(self.sp_array.get())\n-        indices = pyarrow_wrap_array(darr.indices())\n-        return indices[self.index]\n+    # TODO(kszucs): deprecate these\n+    # @property\n+    # def index_value(self):\n+    #     index = self.index\n+    #     return None if index is None else self.index\n \n     @property\n     def dictionary_value(self):\n-        \"\"\"\n-        Return this value's underlying dictionary value as a ArrayValue.\n-        \"\"\"\n-        cdef CDictionaryArray* darr = <CDictionaryArray*>(self.sp_array.get())\n-        dictionary = pyarrow_wrap_array(darr.dictionary())\n-        return dictionary[self.index_value.as_py()]\n-\n-\n-cdef dict _array_value_classes = {\n-    _Type_BOOL: BooleanValue,\n-    _Type_UINT8: UInt8Value,\n-    _Type_UINT16: UInt16Value,\n-    _Type_UINT32: UInt32Value,\n-    _Type_UINT64: UInt64Value,\n-    _Type_INT8: Int8Value,\n-    _Type_INT16: Int16Value,\n-    _Type_INT32: Int32Value,\n-    _Type_INT64: Int64Value,\n-    _Type_DATE32: Date32Value,\n-    _Type_DATE64: Date64Value,\n-    _Type_TIME32: Time32Value,\n-    _Type_TIME64: Time64Value,\n-    _Type_TIMESTAMP: TimestampValue,\n-    _Type_DURATION: DurationValue,\n-    _Type_HALF_FLOAT: HalfFloatValue,\n-    _Type_FLOAT: FloatValue,\n-    _Type_DOUBLE: DoubleValue,\n-    _Type_LIST: ListValue,\n-    _Type_LARGE_LIST: LargeListValue,\n-    _Type_MAP: MapValue,\n-    _Type_FIXED_SIZE_LIST: FixedSizeListValue,\n-    _Type_SPARSE_UNION: UnionValue,\n-    _Type_DENSE_UNION: UnionValue,\n-    _Type_BINARY: BinaryValue,\n-    _Type_STRING: StringValue,\n-    _Type_LARGE_BINARY: LargeBinaryValue,\n-    _Type_LARGE_STRING: LargeStringValue,\n-    _Type_FIXED_SIZE_BINARY: FixedSizeBinaryValue,\n-    _Type_DECIMAL: DecimalValue,\n-    _Type_STRUCT: StructValue,\n-    _Type_DICTIONARY: DictionaryValue,\n-}\n-\n-cdef class ScalarValue(Scalar):\n-    \"\"\"\n-    The base class for scalars.\n-    \"\"\"\n-\n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly.\"\n-                        .format(self.__class__.__name__))\n-\n-    cdef void init(self, const shared_ptr[CScalar]& sp_scalar):\n-        self.sp_scalar = sp_scalar\n-\n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n-\n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n-\n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ScalarValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplemented(\n-                \"Cannot compare scalars that don't support as_py()\")\n-\n-    def __hash__(self):\n-        return hash(self.as_py())\n-\n-\n-cdef class NullScalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for null scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python None.\n-        \"\"\"\n-        return None\n-\n-\n-cdef class BooleanScalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for boolean scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python bool.\n-        \"\"\"\n-        cdef CBooleanScalar* sp = <CBooleanScalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class UInt8Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for uint8 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class Int8Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for int8 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CInt8Scalar* sp = <CInt8Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class UInt16Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for uint16 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class Int16Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for int16 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CInt16Scalar* sp = <CInt16Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class UInt32Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for uint32 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class Int32Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for int32 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CInt32Scalar* sp = <CInt32Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class UInt64Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for uint64 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class Int64Scalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for int64 scalars.\n-    \"\"\"\n-\n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python int.\n-        \"\"\"\n-        cdef CInt64Scalar* sp = <CInt64Scalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n+        value = self.value\n+        return None if value is None else self.value\n \n \n-cdef class FloatScalar(ScalarValue):\n+cdef class UnionScalar(Scalar):\n     \"\"\"\n-    Concrete class for float scalars.\n+    Concrete class for Union scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    @property\n+    def value(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value's underlying dictionary value as a scalar.\n         \"\"\"\n-        cdef CFloatScalar* sp = <CFloatScalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class DoubleScalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for double scalars.\n-    \"\"\"\n+        cdef CDictionaryScalar* sp = <CDictionaryScalar*> self.wrapped.get()\n+        return Scalar.wrap(sp.value)\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n-        \"\"\"\n-        cdef CDoubleScalar* sp = <CDoubleScalar*> self.sp_scalar.get()\n-        return sp.value if sp.is_valid else None\n-\n-\n-cdef class StringScalar(ScalarValue):\n-    \"\"\"\n-    Concrete class for string scalars.\n-    \"\"\"\n+        Return this value as a Python object.\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python string.\n+        The exact type depends on the dictionary value type.\n\nReview comment:\n       Not \"dictionary\"\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-30T13:48:47.441+0000",
                    "updated": "2020-06-30T13:48:47.441+0000",
                    "started": "2020-06-30T13:48:47.441+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "453011",
                    "issueId": "13308983"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/453015",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#issuecomment-651806049\n\n\n   Ok, at a quick glance, it seems that null container tests work properly regardless:\r\n   ```python\r\n   >>> s = set()                                                                                                                                                                  \r\n   >>> s.add(pa.scalar(None))                                                                                                                                                     \r\n   >>> s                                                                                                                                                                          \r\n   {<pyarrow.NullScalar: None>}\r\n   >>> pa.scalar(None) in s                                                                                                                                                       \r\n   True\r\n   >>> s.add(pa.scalar(None, pa.int64()))                                                                                                                                         \r\n   >>> s.add(pa.scalar(12, pa.int64()))                                                                                                                                           \r\n   >>> s                                                                                                                                                                          \r\n   {<pyarrow.Int64Scalar: 12>,\r\n    <pyarrow.NullScalar: None>,\r\n    <pyarrow.Int64Scalar: None>}\r\n   >>> pa.scalar(None, pa.int64()) in s                                                                                                                                           \r\n   True\r\n   >>> pa.scalar(None, pa.int32()) in s                                                                                                                                           \r\n   False\r\n   ```\r\n   ```python\r\n   >>> l = [pa.scalar(None)]                                                                                                                                                      \r\n   >>> pa.scalar(None) in l                                                                                                                                                       \r\n   True\r\n   >>> pa.scalar(None, pa.int64()) in l                                                                                                                                           \r\n   False\r\n   ```\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-30T13:54:38.072+0000",
                    "updated": "2020-06-30T13:54:38.072+0000",
                    "started": "2020-06-30T13:54:38.072+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "453015",
                    "issueId": "13308983"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/453032",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#discussion_r447725217\n\n\n\n##########\nFile path: python/pyarrow/includes/libarrow.pxd\n##########\n@@ -44,6 +44,11 @@ cdef extern from \"arrow/util/key_value_metadata.h\" namespace \"arrow\" nogil:\n         c_bool Contains(const c_string& key) const\n \n \n+cdef extern from \"arrow/util/decimal.h\" namespace \"arrow\" nogil:\n+    cdef cppclass CDecimal128\" arrow::Decimal128\":\n+        c_string ToString(int32_t scale) const\n\nReview comment:\n       Created jira https://issues.apache.org/jira/browse/ARROW-9279\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-30T14:25:44.228+0000",
                    "updated": "2020-06-30T14:25:44.228+0000",
                    "started": "2020-06-30T14:25:44.227+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "453032",
                    "issueId": "13308983"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/453033",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#discussion_r447725569\n\n\n\n##########\nFile path: python/pyarrow/lib.pxd\n##########\n@@ -179,101 +179,18 @@ cdef class Schema:\n \n \n cdef class Scalar:\n-    cdef readonly:\n-        DataType type\n-\n-\n-cdef class NAType(Scalar):\n-    pass\n-\n-\n-cdef class ArrayValue(Scalar):\n     cdef:\n-        shared_ptr[CArray] sp_array\n-        int64_t index\n-\n-    cdef void init(self, DataType type,\n-                   const shared_ptr[CArray]& sp_array, int64_t index)\n-\n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array)\n-\n-cdef class ScalarValue(Scalar):\n-    cdef:\n-        shared_ptr[CScalar] sp_scalar\n-\n-    cdef void init(self, const shared_ptr[CScalar]& sp_scalar)\n-\n-cdef class Int8Value(ArrayValue):\n-    pass\n+        shared_ptr[CScalar] wrapped\n \n+    cdef void init(self, const shared_ptr[CScalar]& wrapped)\n \n-cdef class Int64Value(ArrayValue):\n-    pass\n-\n-\n-cdef class ListValue(ArrayValue):\n-    cdef readonly:\n-        DataType value_type\n-\n-    cdef:\n-        CListArray* ap\n-\n-    cdef getitem(self, int64_t i)\n-    cdef int64_t length(self)\n-\n-\n-cdef class LargeListValue(ArrayValue):\n-    cdef readonly:\n-        DataType value_type\n-\n-    cdef:\n-        CLargeListArray* ap\n-\n-    cdef getitem(self, int64_t i)\n-    cdef int64_t length(self)\n-\n-\n-cdef class MapValue(ArrayValue):\n-    cdef readonly:\n-        DataType key_type\n-        DataType item_type\n-\n-    cdef:\n-        CMapArray* ap\n-\n-    cdef getitem(self, int64_t i)\n-    cdef int64_t length(self)\n-\n-\n-cdef class FixedSizeListValue(ArrayValue):\n-    cdef readonly:\n-        DataType value_type\n-\n-    cdef:\n-        CFixedSizeListArray* ap\n-\n-    cdef getitem(self, int64_t i)\n-    cdef int64_t length(self)\n-\n-\n-cdef class StructValue(ArrayValue):\n-    cdef:\n-        CStructArray* ap\n-\n-\n-cdef class UnionValue(ArrayValue):\n-    cdef:\n-        CUnionArray* ap\n-        list value_types\n-\n-    cdef getitem(self, int64_t i)\n-\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped)\n \n-cdef class StringValue(ArrayValue):\n-    pass\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil\n \n \n-cdef class FixedSizeBinaryValue(ArrayValue):\n+cdef class NAType(Scalar):\n\nReview comment:\n       Forgot to rename it in the `.pxd` file.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-30T14:26:17.540+0000",
                    "updated": "2020-06-30T14:26:17.540+0000",
                    "started": "2020-06-30T14:26:17.540+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "453033",
                    "issueId": "13308983"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/453036",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#discussion_r447731034\n\n\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n\nReview comment:\n       Well, it was the behavior before the refactor. Shall we check proper equality with NullScalar instead?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-30T14:33:06.117+0000",
                    "updated": "2020-06-30T14:33:06.117+0000",
                    "started": "2020-06-30T14:33:06.117+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "453036",
                    "issueId": "13308983"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/453040",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#discussion_r447732301\n\n\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n\nReview comment:\n       Well, it should probably return `False` for non-nulls?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-30T14:34:44.525+0000",
                    "updated": "2020-06-30T14:34:44.525+0000",
                    "started": "2020-06-30T14:34:44.525+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "453040",
                    "issueId": "13308983"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/453044",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#discussion_r447733611\n\n\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n\nReview comment:\n       Once I override `__eq__` the inherited `__hash__` gets removed.\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n\nReview comment:\n       Same as above. \n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def __eq__(self, other):\n+        if hasattr(self, 'as_py'):\n\nReview comment:\n       Right.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-30T14:36:43.250+0000",
                    "updated": "2020-06-30T14:36:43.250+0000",
                    "started": "2020-06-30T14:36:43.250+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "453044",
                    "issueId": "13308983"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/worklog/453046",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#discussion_r447734944\n\n\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,745 @@\n # under the License.\n \n \n-_NULL = NA = None\n+import collections\n \n \n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n+\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n-        self.type = null()\n+    @property\n+    def is_valid(self):\n+        return self.wrapped.get().is_valid\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n+\n+    def equals(self, Scalar other):\n+        return self.wrapped.get().Equals(other.unwrap().get()[0])\n \n     def __eq__(self, other):\n-        return NA\n+        try:\n+            if not isinstance(other, Scalar):\n+                other = scalar(other, type=self.type)\n+            return self.equals(other)\n+        except (TypeError, ValueError, ArrowInvalid):\n+            return NotImplemented\n+\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n \n-_NULL = NA = NullType()\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __init__(self):\n+        pass\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __eq__(self, other):\n+        return NA\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n+    def __hash__(self):\n+        cdef CScalarHash hasher\n+        return hasher(self.wrapped)\n+\n+    def __eq__(self, other):\n+        if hasattr(self, 'as_py'):\n+            if isinstance(other, Scalar):\n+                other = other.as_py()\n+            return self.as_py() == other\n+        else:\n+            raise NotImplementedError\n+\n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n+\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class Decimal128Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n\nReview comment:\n       `decimal` is imported as `_pydecimal` in [lib.pyx](https://github.com/apache/arrow/blob/master/python/pyarrow/lib.pyx#L23)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-30T14:38:09.621+0000",
                    "updated": "2020-06-30T14:38:09.621+0000",
                    "started": "2020-06-30T14:38:09.621+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "453046",
                    "issueId": "13308983"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 37200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@39ed585c[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@58c1e22[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@26ab903d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@4333e7c4[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@29088469[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@64d98cba[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1e89c264[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@42d81bb6[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2f1ee448[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@78a014d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@57c0793a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@55c7cddf[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 37200,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Jul 06 22:15:58 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-07-06T22:15:57.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9017/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2020-06-02T15:44:26.000+0000",
        "updated": "2020-07-06T22:16:07.000+0000",
        "timeoriginalestimate": null,
        "description": "The situation regarding scalars in Python is currently not optimal.\r\n\r\nWe have two different \"types\" of scalars:\r\n\r\n- {{ArrayValue(Scalar)}} (and subclasses of that for all types):  this is used when you access a single element of an array (eg {{arr[0]}})\r\n- {{ScalarValue(Scalar)}} (and subclasses of that for _some_ types): this is used when wrapping a C++ scalar into a python scalar, eg when you get back a scalar from a reduction like {{arr.sum()}}.\r\n\r\nAnd while we have two versions of scalars, neither of them can actually easily be used as scalar as they both can't be constructed from a python scalar (there is no {{scalar(1)}} function to use when calling a kernel, for example).\r\n\r\nI think we should try to unify those scalar classes? (which probably means getting rid of the ArrayValue scalar)\r\n\r\nIn addition, there is an issue of trying to re-use python scalar <-> arrow conversion code, as this is also logic for this in the {{python_to_arrow.cc}} code. But this is probably a bigger change. cc [~kszucs] \r\n\r\n",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "10h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 37200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Python] Refactor the Scalar classes",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/comment/17123950",
                    "id": "17123950",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "body": "And comment from Ben: relevant recent addition:\r\n\r\n{code}\r\n Result<std::shared_ptr<Scalar>> Array::GetScalar(int64_t i) const;\r\n{code}",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "created": "2020-06-02T15:45:13.680+0000",
                    "updated": "2020-06-02T15:45:13.680+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/comment/17123957",
                    "id": "17123957",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "We should definitely unify those around a Cython wrapper to C++ {{arrow::Scalar}}, IMHO.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2020-06-02T15:50:59.076+0000",
                    "updated": "2020-06-02T15:50:59.076+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/comment/17124048",
                    "id": "17124048",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kszucs",
                        "name": "kszucs",
                        "key": "kszucs",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Krisztian Szucs",
                        "active": true,
                        "timeZone": "Europe/Budapest"
                    },
                    "body": "I started to factor out the elementwise conversion code required to convert single python objects to intermediate C representation. I hit a couple of roadblocks and there were also missing utilities like the GetScalar Ben has implemented recently. \r\n\r\nWe also have an outstanding issue with the auto chunking during conversion: in case of nested types a binary/string field gets chunked if the size limited is reached but the rest of the fields have a single chunk resulting a corrupted nested array.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kszucs",
                        "name": "kszucs",
                        "key": "kszucs",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Krisztian Szucs",
                        "active": true,
                        "timeZone": "Europe/Budapest"
                    },
                    "created": "2020-06-02T16:51:54.815+0000",
                    "updated": "2020-06-26T13:20:08.556+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13308983/comment/17152353",
                    "id": "17152353",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 7519\n[https://github.com/apache/arrow/pull/7519]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-07-06T22:15:58.007+0000",
                    "updated": "2020-07-06T22:15:58.007+0000"
                }
            ],
            "maxResults": 4,
            "total": 4,
            "startAt": 0
        },
        "customfield_12311820": "0|z0ffhk:",
        "customfield_12314139": null
    }
}