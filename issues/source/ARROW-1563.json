{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13103408",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408",
    "key": "ARROW-1563",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343066",
                "id": "12343066",
                "description": "",
                "name": "0.11.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-10-08"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "Analytics",
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
            "name": "uwe",
            "key": "xhochy",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
            },
            "displayName": "Uwe Korn",
            "active": true,
            "timeZone": "Europe/Berlin"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 13200,
            "total": 13200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 13200,
            "total": 13200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1563/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 30,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/136939",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy opened a new pull request #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461\n \n \n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-22T13:17:03.988+0000",
                    "updated": "2018-08-22T13:17:03.988+0000",
                    "started": "2018-08-22T13:17:03.988+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "136939",
                    "issueId": "13103408"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/137075",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461#discussion_r212044195\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/boolean.h\n ##########\n @@ -0,0 +1,83 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_COMPUTE_KERNELS_BOOLEAN_H\n+#define ARROW_COMPUTE_KERNELS_BOOLEAN_H\n+\n+#include <memory>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+#include \"arrow/compute/kernel.h\"\n+\n+namespace arrow {\n+\n+class Array;\n+class ChunkedArray;\n+class Column;\n+class DataType;\n+\n+namespace compute {\n+\n+/// \\brief Invert the values of a boolean datum\n+/// \\param[in] context the FunctionContext\n+/// \\param[in] value datum to invert\n+/// \\param[out] out resulting datum\n+///\n+/// \\since 0.11.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Status Invert(FunctionContext* context, const Datum& value, Datum* out);\n+\n+/// \\brief Element-wise AND of two boolean dates\n \n Review comment:\n   \"dates\" is the plural of \"datum\"?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-22T17:47:50.630+0000",
                    "updated": "2018-08-22T17:47:50.630+0000",
                    "started": "2018-08-22T17:47:50.630+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "137075",
                    "issueId": "13103408"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/137076",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461#discussion_r212043517\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/boolean.cc\n ##########\n @@ -0,0 +1,156 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/kernels/boolean.h\"\n+\n+#include \"arrow/compute/context.h\"\n+#include \"arrow/compute/kernels/util-internal.h\"\n+#include \"arrow/util/logging.h\"\n+\n+#include <vector>\n+\n+namespace arrow {\n+namespace compute {\n+\n+class InvertKernel : public UnaryKernel {\n+  Status Call(FunctionContext* ctx, const Datum& input, Datum* out) override {\n+    DCHECK_EQ(Datum::ARRAY, input.kind());\n+\n+    const ArrayData& in_data = *input.array();\n+    ArrayData* result;\n+\n+    if (out->kind() == Datum::NONE) {\n \n Review comment:\n   At first sight, it doesn't seem obvious what this is about. Can you comment on this?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-22T17:47:50.633+0000",
                    "updated": "2018-08-22T17:47:50.633+0000",
                    "started": "2018-08-22T17:47:50.633+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "137076",
                    "issueId": "13103408"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/137077",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461#discussion_r212045246\n \n \n\n ##########\n File path: cpp/src/arrow/util/bit-util-test.cc\n ##########\n @@ -395,6 +395,51 @@ TEST(BitmapAnd, Unaligned) {\n   }\n }\n \n+TEST(BitmapOr, Aligned) {\n \n Review comment:\n   Similar to the above, it seems `BitmapAnd`, `BitmapOr` and `BitmapXor` are using exactly the same test harness, except with different result values.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-22T17:47:50.635+0000",
                    "updated": "2018-08-22T17:47:50.635+0000",
                    "started": "2018-08-22T17:47:50.635+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "137077",
                    "issueId": "13103408"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/137078",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461#discussion_r212043008\n \n \n\n ##########\n File path: cpp/src/arrow/compute/compute-test.cc\n ##########\n @@ -1285,5 +1287,255 @@ TEST_F(TestHashKernel, ChunkedArrayInvoke) {\n   ASSERT_TRUE(encoded_out.chunked_array()->Equals(*dict_carr));\n }\n \n+class TestBooleanKernel : public ComputeFixture, public TestBase {};\n+\n+TEST_F(TestBooleanKernel, Invert) {\n+  vector<bool> values1 = {true, false, true};\n+  vector<bool> values2 = {false, true, false};\n+\n+  auto type = boolean();\n+  auto a1 = _MakeArray<BooleanType, bool>(type, values1, {});\n+  auto a2 = _MakeArray<BooleanType, bool>(type, values2, {});\n+\n+  // Plain array\n+  Datum result;\n+  ASSERT_OK(Invert(&this->ctx_, Datum(a1), &result));\n+  ASSERT_EQ(Datum::ARRAY, result.kind());\n+  std::shared_ptr<Array> result_array = result.make_array();\n+  ASSERT_TRUE(result_array->Equals(a2));\n+\n+  // Array with offset\n+  ASSERT_OK(Invert(&this->ctx_, Datum(a1->Slice(1)), &result));\n+  ASSERT_EQ(Datum::ARRAY, result.kind());\n+  result_array = result.make_array();\n+  ASSERT_TRUE(result_array->Equals(a2->Slice(1)));\n+\n+  // ChunkedArray\n+  std::vector<std::shared_ptr<Array>> ca1_arrs = {a1, a1->Slice(1)};\n+  auto ca1 = std::make_shared<ChunkedArray>(ca1_arrs);\n+  std::vector<std::shared_ptr<Array>> ca2_arrs = {a2, a2->Slice(1)};\n+  auto ca2 = std::make_shared<ChunkedArray>(ca2_arrs);\n+  ASSERT_OK(Invert(&this->ctx_, Datum(ca1), &result));\n+  ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n+  std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n+  ASSERT_TRUE(result_ca->Equals(ca2));\n+}\n+\n+TEST_F(TestBooleanKernel, And) {\n \n Review comment:\n   Is there a way to share most of the code between `TestBooleanKernel::And`, `TestBooleanKernel::Or` and ``TestBooleanKernel::Xor`? It seems they only differ by the kernel being tested and the actual test values.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-22T17:47:50.637+0000",
                    "updated": "2018-08-22T17:47:50.637+0000",
                    "started": "2018-08-22T17:47:50.636+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "137078",
                    "issueId": "13103408"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/137079",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461#discussion_r212043717\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/boolean.cc\n ##########\n @@ -0,0 +1,156 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/kernels/boolean.h\"\n+\n+#include \"arrow/compute/context.h\"\n+#include \"arrow/compute/kernels/util-internal.h\"\n+#include \"arrow/util/logging.h\"\n+\n+#include <vector>\n+\n+namespace arrow {\n+namespace compute {\n+\n+class InvertKernel : public UnaryKernel {\n+  Status Call(FunctionContext* ctx, const Datum& input, Datum* out) override {\n+    DCHECK_EQ(Datum::ARRAY, input.kind());\n+\n+    const ArrayData& in_data = *input.array();\n+    ArrayData* result;\n+\n+    if (out->kind() == Datum::NONE) {\n+      out->value = ArrayData::Make(boolean(), in_data.length);\n+    }\n+\n+    result = out->array().get();\n+\n+    // Allocate or copy bitmap\n+    result->null_count = in_data.null_count;\n+    std::shared_ptr<Buffer> validity_bitmap = in_data.buffers[0];\n+    if (in_data.offset != 0) {\n+      RETURN_NOT_OK(CopyBitmap(ctx->memory_pool(), validity_bitmap->data(),\n+                               in_data.offset, in_data.length, &validity_bitmap));\n+    }\n+    result->buffers.push_back(validity_bitmap);\n+\n+    // Allocate output data buffer\n+    std::shared_ptr<Buffer> data_buffer;\n+    RETURN_NOT_OK(InvertBitmap(ctx->memory_pool(), in_data.buffers[1]->data(),\n+                               in_data.offset, in_data.length, &data_buffer));\n+    result->buffers.push_back(data_buffer);\n+\n+    return Status::OK();\n+  }\n+};\n+\n+Status Invert(FunctionContext* ctx, const Datum& value, Datum* out) {\n+  InvertKernel kernel;\n+\n+  std::vector<Datum> result;\n+  RETURN_NOT_OK(detail::InvokeUnaryArrayKernel(ctx, &kernel, value, &result));\n+\n+  *out = detail::WrapDatumsLike(value, result);\n+  return Status::OK();\n+}\n+\n+class BinaryBooleanKernel : public BinaryKernel {\n+  virtual Status Compute(FunctionContext* ctx, const ArrayData& left,\n+                         const ArrayData& right, ArrayData* out) = 0;\n+\n+  Status Call(FunctionContext* ctx, const Datum& left, const Datum& right,\n+              Datum* out) override {\n+    DCHECK_EQ(Datum::ARRAY, right.kind());\n+    DCHECK_EQ(Datum::ARRAY, left.kind());\n+\n+    const ArrayData& left_data = *left.array();\n+    const ArrayData& right_data = *right.array();\n+    ArrayData* result;\n+\n+    if (out->kind() == Datum::NONE) {\n \n Review comment:\n   Ditto here.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-22T17:47:50.639+0000",
                    "updated": "2018-08-22T17:47:50.639+0000",
                    "started": "2018-08-22T17:47:50.638+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "137079",
                    "issueId": "13103408"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/137080",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461#discussion_r212045818\n \n \n\n ##########\n File path: cpp/src/arrow/util/bit-util.cc\n ##########\n @@ -208,6 +229,70 @@ void UnalignedBitmapAnd(const uint8_t* left, int64_t left_offset, const uint8_t*\n   writer.Finish();\n }\n \n+void AlignedBitmapOr(const uint8_t* left, int64_t left_offset, const uint8_t* right,\n \n Review comment:\n   I also wonder whether we can factor out the common harness with `BitmapAnd`'s variations (perhaps by templatizing with one or two callables?).\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-22T17:47:50.649+0000",
                    "updated": "2018-08-22T17:47:50.649+0000",
                    "started": "2018-08-22T17:47:50.649+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "137080",
                    "issueId": "13103408"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/137353",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy commented on a change in pull request #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461#discussion_r212284763\n \n \n\n ##########\n File path: cpp/src/arrow/compute/compute-test.cc\n ##########\n @@ -1285,5 +1287,255 @@ TEST_F(TestHashKernel, ChunkedArrayInvoke) {\n   ASSERT_TRUE(encoded_out.chunked_array()->Equals(*dict_carr));\n }\n \n+class TestBooleanKernel : public ComputeFixture, public TestBase {};\n+\n+TEST_F(TestBooleanKernel, Invert) {\n+  vector<bool> values1 = {true, false, true};\n+  vector<bool> values2 = {false, true, false};\n+\n+  auto type = boolean();\n+  auto a1 = _MakeArray<BooleanType, bool>(type, values1, {});\n+  auto a2 = _MakeArray<BooleanType, bool>(type, values2, {});\n+\n+  // Plain array\n+  Datum result;\n+  ASSERT_OK(Invert(&this->ctx_, Datum(a1), &result));\n+  ASSERT_EQ(Datum::ARRAY, result.kind());\n+  std::shared_ptr<Array> result_array = result.make_array();\n+  ASSERT_TRUE(result_array->Equals(a2));\n+\n+  // Array with offset\n+  ASSERT_OK(Invert(&this->ctx_, Datum(a1->Slice(1)), &result));\n+  ASSERT_EQ(Datum::ARRAY, result.kind());\n+  result_array = result.make_array();\n+  ASSERT_TRUE(result_array->Equals(a2->Slice(1)));\n+\n+  // ChunkedArray\n+  std::vector<std::shared_ptr<Array>> ca1_arrs = {a1, a1->Slice(1)};\n+  auto ca1 = std::make_shared<ChunkedArray>(ca1_arrs);\n+  std::vector<std::shared_ptr<Array>> ca2_arrs = {a2, a2->Slice(1)};\n+  auto ca2 = std::make_shared<ChunkedArray>(ca2_arrs);\n+  ASSERT_OK(Invert(&this->ctx_, Datum(ca1), &result));\n+  ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n+  std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n+  ASSERT_TRUE(result_ca->Equals(ca2));\n+}\n+\n+TEST_F(TestBooleanKernel, And) {\n \n Review comment:\n   Yes, done.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-23T12:15:09.061+0000",
                    "updated": "2018-08-23T12:15:09.061+0000",
                    "started": "2018-08-23T12:15:09.060+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "137353",
                    "issueId": "13103408"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/137354",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy commented on a change in pull request #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461#discussion_r212284832\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/boolean.h\n ##########\n @@ -0,0 +1,83 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_COMPUTE_KERNELS_BOOLEAN_H\n+#define ARROW_COMPUTE_KERNELS_BOOLEAN_H\n+\n+#include <memory>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+#include \"arrow/compute/kernel.h\"\n+\n+namespace arrow {\n+\n+class Array;\n+class ChunkedArray;\n+class Column;\n+class DataType;\n+\n+namespace compute {\n+\n+/// \\brief Invert the values of a boolean datum\n+/// \\param[in] context the FunctionContext\n+/// \\param[in] value datum to invert\n+/// \\param[out] out resulting datum\n+///\n+/// \\since 0.11.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Status Invert(FunctionContext* context, const Datum& value, Datum* out);\n+\n+/// \\brief Element-wise AND of two boolean dates\n \n Review comment:\n   As far as I know yes, but I'm not native speaker.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-23T12:15:30.503+0000",
                    "updated": "2018-08-23T12:15:30.503+0000",
                    "started": "2018-08-23T12:15:30.502+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "137354",
                    "issueId": "13103408"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/137357",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy commented on a change in pull request #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461#discussion_r212286295\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/boolean.cc\n ##########\n @@ -0,0 +1,156 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/kernels/boolean.h\"\n+\n+#include \"arrow/compute/context.h\"\n+#include \"arrow/compute/kernels/util-internal.h\"\n+#include \"arrow/util/logging.h\"\n+\n+#include <vector>\n+\n+namespace arrow {\n+namespace compute {\n+\n+class InvertKernel : public UnaryKernel {\n+  Status Call(FunctionContext* ctx, const Datum& input, Datum* out) override {\n+    DCHECK_EQ(Datum::ARRAY, input.kind());\n+\n+    const ArrayData& in_data = *input.array();\n+    ArrayData* result;\n+\n+    if (out->kind() == Datum::NONE) {\n \n Review comment:\n   Removed\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-23T12:20:23.790+0000",
                    "updated": "2018-08-23T12:20:23.790+0000",
                    "started": "2018-08-23T12:20:23.789+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "137357",
                    "issueId": "13103408"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/137358",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy commented on a change in pull request #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461#discussion_r212286309\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/boolean.cc\n ##########\n @@ -0,0 +1,156 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/kernels/boolean.h\"\n+\n+#include \"arrow/compute/context.h\"\n+#include \"arrow/compute/kernels/util-internal.h\"\n+#include \"arrow/util/logging.h\"\n+\n+#include <vector>\n+\n+namespace arrow {\n+namespace compute {\n+\n+class InvertKernel : public UnaryKernel {\n+  Status Call(FunctionContext* ctx, const Datum& input, Datum* out) override {\n+    DCHECK_EQ(Datum::ARRAY, input.kind());\n+\n+    const ArrayData& in_data = *input.array();\n+    ArrayData* result;\n+\n+    if (out->kind() == Datum::NONE) {\n+      out->value = ArrayData::Make(boolean(), in_data.length);\n+    }\n+\n+    result = out->array().get();\n+\n+    // Allocate or copy bitmap\n+    result->null_count = in_data.null_count;\n+    std::shared_ptr<Buffer> validity_bitmap = in_data.buffers[0];\n+    if (in_data.offset != 0) {\n+      RETURN_NOT_OK(CopyBitmap(ctx->memory_pool(), validity_bitmap->data(),\n+                               in_data.offset, in_data.length, &validity_bitmap));\n+    }\n+    result->buffers.push_back(validity_bitmap);\n+\n+    // Allocate output data buffer\n+    std::shared_ptr<Buffer> data_buffer;\n+    RETURN_NOT_OK(InvertBitmap(ctx->memory_pool(), in_data.buffers[1]->data(),\n+                               in_data.offset, in_data.length, &data_buffer));\n+    result->buffers.push_back(data_buffer);\n+\n+    return Status::OK();\n+  }\n+};\n+\n+Status Invert(FunctionContext* ctx, const Datum& value, Datum* out) {\n+  InvertKernel kernel;\n+\n+  std::vector<Datum> result;\n+  RETURN_NOT_OK(detail::InvokeUnaryArrayKernel(ctx, &kernel, value, &result));\n+\n+  *out = detail::WrapDatumsLike(value, result);\n+  return Status::OK();\n+}\n+\n+class BinaryBooleanKernel : public BinaryKernel {\n+  virtual Status Compute(FunctionContext* ctx, const ArrayData& left,\n+                         const ArrayData& right, ArrayData* out) = 0;\n+\n+  Status Call(FunctionContext* ctx, const Datum& left, const Datum& right,\n+              Datum* out) override {\n+    DCHECK_EQ(Datum::ARRAY, right.kind());\n+    DCHECK_EQ(Datum::ARRAY, left.kind());\n+\n+    const ArrayData& left_data = *left.array();\n+    const ArrayData& right_data = *right.array();\n+    ArrayData* result;\n+\n+    if (out->kind() == Datum::NONE) {\n \n Review comment:\n   Removed\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-23T12:20:26.282+0000",
                    "updated": "2018-08-23T12:20:26.282+0000",
                    "started": "2018-08-23T12:20:26.280+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "137358",
                    "issueId": "13103408"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/137376",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy commented on issue #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461#issuecomment-415410135\n \n \n   @pitrou Did some template magic and now there is a lot less repetition.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-23T13:16:13.314+0000",
                    "updated": "2018-08-23T13:16:13.314+0000",
                    "started": "2018-08-23T13:16:13.314+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "137376",
                    "issueId": "13103408"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/138084",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461#discussion_r212793403\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/boolean.h\n ##########\n @@ -0,0 +1,83 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_COMPUTE_KERNELS_BOOLEAN_H\n+#define ARROW_COMPUTE_KERNELS_BOOLEAN_H\n+\n+#include <memory>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+#include \"arrow/compute/kernel.h\"\n+\n+namespace arrow {\n+\n+class Array;\n+class ChunkedArray;\n+class Column;\n+class DataType;\n+\n+namespace compute {\n+\n+/// \\brief Invert the values of a boolean datum\n+/// \\param[in] context the FunctionContext\n+/// \\param[in] value datum to invert\n+/// \\param[out] out resulting datum\n+///\n+/// \\since 0.11.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Status Invert(FunctionContext* context, const Datum& value, Datum* out);\n+\n+/// \\brief Element-wise AND of two boolean dates\n \n Review comment:\n   Got to ask @wesm on this :-)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-25T08:57:12.674+0000",
                    "updated": "2018-08-25T08:57:12.674+0000",
                    "started": "2018-08-25T08:57:12.673+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "138084",
                    "issueId": "13103408"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/138085",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461#discussion_r212793420\n \n \n\n ##########\n File path: cpp/src/arrow/compute/compute-test.cc\n ##########\n @@ -1285,5 +1287,255 @@ TEST_F(TestHashKernel, ChunkedArrayInvoke) {\n   ASSERT_TRUE(encoded_out.chunked_array()->Equals(*dict_carr));\n }\n \n+class TestBooleanKernel : public ComputeFixture, public TestBase {};\n+\n+TEST_F(TestBooleanKernel, Invert) {\n+  vector<bool> values1 = {true, false, true};\n+  vector<bool> values2 = {false, true, false};\n+\n+  auto type = boolean();\n+  auto a1 = _MakeArray<BooleanType, bool>(type, values1, {});\n+  auto a2 = _MakeArray<BooleanType, bool>(type, values2, {});\n+\n+  // Plain array\n+  Datum result;\n+  ASSERT_OK(Invert(&this->ctx_, Datum(a1), &result));\n+  ASSERT_EQ(Datum::ARRAY, result.kind());\n+  std::shared_ptr<Array> result_array = result.make_array();\n+  ASSERT_TRUE(result_array->Equals(a2));\n+\n+  // Array with offset\n+  ASSERT_OK(Invert(&this->ctx_, Datum(a1->Slice(1)), &result));\n+  ASSERT_EQ(Datum::ARRAY, result.kind());\n+  result_array = result.make_array();\n+  ASSERT_TRUE(result_array->Equals(a2->Slice(1)));\n+\n+  // ChunkedArray\n+  std::vector<std::shared_ptr<Array>> ca1_arrs = {a1, a1->Slice(1)};\n+  auto ca1 = std::make_shared<ChunkedArray>(ca1_arrs);\n+  std::vector<std::shared_ptr<Array>> ca2_arrs = {a2, a2->Slice(1)};\n+  auto ca2 = std::make_shared<ChunkedArray>(ca2_arrs);\n+  ASSERT_OK(Invert(&this->ctx_, Datum(ca1), &result));\n+  ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n+  std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n+  ASSERT_TRUE(result_ca->Equals(ca2));\n+}\n+\n+TEST_F(TestBooleanKernel, And) {\n \n Review comment:\n   Much better! :-D\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-25T08:57:57.344+0000",
                    "updated": "2018-08-25T08:57:57.344+0000",
                    "started": "2018-08-25T08:57:57.342+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "138085",
                    "issueId": "13103408"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/138092",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy closed pull request #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/cpp/src/arrow/CMakeLists.txt b/cpp/src/arrow/CMakeLists.txt\nindex d96580e76f..1f0a625302 100644\n--- a/cpp/src/arrow/CMakeLists.txt\n+++ b/cpp/src/arrow/CMakeLists.txt\n@@ -56,6 +56,7 @@ if (ARROW_COMPUTE)\n   add_subdirectory(compute)\n   set(ARROW_SRCS ${ARROW_SRCS}\n     compute/context.cc\n+    compute/kernels/boolean.cc\n     compute/kernels/cast.cc\n     compute/kernels/hash.cc\n     compute/kernels/util-internal.cc\ndiff --git a/cpp/src/arrow/compute/compute-test.cc b/cpp/src/arrow/compute/compute-test.cc\nindex 269b9ddb2a..39f535738c 100644\n--- a/cpp/src/arrow/compute/compute-test.cc\n+++ b/cpp/src/arrow/compute/compute-test.cc\n@@ -40,8 +40,10 @@\n \n #include \"arrow/compute/context.h\"\n #include \"arrow/compute/kernel.h\"\n+#include \"arrow/compute/kernels/boolean.h\"\n #include \"arrow/compute/kernels/cast.h\"\n #include \"arrow/compute/kernels/hash.h\"\n+#include \"arrow/compute/kernels/util-internal.h\"\n \n using std::shared_ptr;\n using std::vector;\n@@ -1285,5 +1287,180 @@ TEST_F(TestHashKernel, ChunkedArrayInvoke) {\n   ASSERT_TRUE(encoded_out.chunked_array()->Equals(*dict_carr));\n }\n \n+struct KernelFunc {\n+  virtual Status Call(FunctionContext* ctx, const Datum& left, const Datum& right,\n+                      Datum* out) const = 0;\n+\n+  virtual ~KernelFunc() = default;\n+};\n+\n+struct AndKernelFunc : KernelFunc {\n+  Status Call(FunctionContext* ctx, const Datum& left, const Datum& right,\n+              Datum* out) const override {\n+    return And(ctx, left, right, out);\n+  }\n+};\n+\n+struct OrKernelFunc : KernelFunc {\n+  Status Call(FunctionContext* ctx, const Datum& left, const Datum& right,\n+              Datum* out) const override {\n+    return Or(ctx, left, right, out);\n+  }\n+};\n+\n+struct XorKernelFunc : KernelFunc {\n+  Status Call(FunctionContext* ctx, const Datum& left, const Datum& right,\n+              Datum* out) const override {\n+    return Xor(ctx, left, right, out);\n+  }\n+};\n+\n+class TestBooleanKernel : public ComputeFixture, public TestBase {\n+ public:\n+  void TestArrayBinary(const KernelFunc& kernel, const std::shared_ptr<Array>& left,\n+                       const std::shared_ptr<Array>& right,\n+                       const std::shared_ptr<Array>& expected) {\n+    Datum result;\n+    ASSERT_OK(kernel.Call(&this->ctx_, Datum(left), Datum(right), &result));\n+    ASSERT_EQ(Datum::ARRAY, result.kind());\n+    std::shared_ptr<Array> result_array = result.make_array();\n+    ASSERT_TRUE(result_array->Equals(expected));\n+  }\n+\n+  void TestChunkedArrayBinary(const KernelFunc& kernel,\n+                              const std::shared_ptr<ChunkedArray>& left,\n+                              const std::shared_ptr<ChunkedArray>& right,\n+                              const std::shared_ptr<ChunkedArray>& expected) {\n+    Datum result;\n+    std::shared_ptr<Array> result_array;\n+    ASSERT_OK(kernel.Call(&this->ctx_, Datum(left), Datum(right), &result));\n+    ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n+    std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n+    ASSERT_TRUE(result_ca->Equals(expected));\n+  }\n+\n+  void TestBinaryKernel(const KernelFunc& kernel, const std::vector<bool>& values1,\n+                        const std::vector<bool>& values2,\n+                        const std::vector<bool>& values3,\n+                        const std::vector<bool>& values3_nulls) {\n+    auto type = boolean();\n+    auto a1 = _MakeArray<BooleanType, bool>(type, values1, {});\n+    auto a2 = _MakeArray<BooleanType, bool>(type, values2, {});\n+    auto a3 = _MakeArray<BooleanType, bool>(type, values3, {});\n+    auto a1_nulls = _MakeArray<BooleanType, bool>(type, values1, values1);\n+    auto a2_nulls = _MakeArray<BooleanType, bool>(type, values2, values2);\n+    auto a3_nulls = _MakeArray<BooleanType, bool>(type, values3, values3_nulls);\n+\n+    TestArrayBinary(kernel, a1, a2, a3);\n+    TestArrayBinary(kernel, a1_nulls, a2_nulls, a3_nulls);\n+    TestArrayBinary(kernel, a1->Slice(1), a2->Slice(1), a3->Slice(1));\n+    TestArrayBinary(kernel, a1_nulls->Slice(1), a2_nulls->Slice(1), a3_nulls->Slice(1));\n+\n+    // ChunkedArray\n+    std::vector<std::shared_ptr<Array>> ca1_arrs = {a1, a1->Slice(1)};\n+    auto ca1 = std::make_shared<ChunkedArray>(ca1_arrs);\n+    std::vector<std::shared_ptr<Array>> ca2_arrs = {a2, a2->Slice(1)};\n+    auto ca2 = std::make_shared<ChunkedArray>(ca2_arrs);\n+    std::vector<std::shared_ptr<Array>> ca3_arrs = {a3, a3->Slice(1)};\n+    auto ca3 = std::make_shared<ChunkedArray>(ca3_arrs);\n+    TestChunkedArrayBinary(kernel, ca1, ca2, ca3);\n+\n+    // ChunkedArray with different chunks\n+    std::vector<std::shared_ptr<Array>> ca4_arrs = {a1->Slice(0, 1), a1->Slice(1),\n+                                                    a1->Slice(1, 1), a1->Slice(2)};\n+    auto ca4 = std::make_shared<ChunkedArray>(ca4_arrs);\n+    TestChunkedArrayBinary(kernel, ca4, ca2, ca3);\n+  }\n+};\n+\n+TEST_F(TestBooleanKernel, Invert) {\n+  vector<bool> values1 = {true, false, true};\n+  vector<bool> values2 = {false, true, false};\n+\n+  auto type = boolean();\n+  auto a1 = _MakeArray<BooleanType, bool>(type, values1, {});\n+  auto a2 = _MakeArray<BooleanType, bool>(type, values2, {});\n+\n+  // Plain array\n+  Datum result;\n+  ASSERT_OK(Invert(&this->ctx_, Datum(a1), &result));\n+  ASSERT_EQ(Datum::ARRAY, result.kind());\n+  std::shared_ptr<Array> result_array = result.make_array();\n+  ASSERT_TRUE(result_array->Equals(a2));\n+\n+  // Array with offset\n+  ASSERT_OK(Invert(&this->ctx_, Datum(a1->Slice(1)), &result));\n+  ASSERT_EQ(Datum::ARRAY, result.kind());\n+  result_array = result.make_array();\n+  ASSERT_TRUE(result_array->Equals(a2->Slice(1)));\n+\n+  // ChunkedArray\n+  std::vector<std::shared_ptr<Array>> ca1_arrs = {a1, a1->Slice(1)};\n+  auto ca1 = std::make_shared<ChunkedArray>(ca1_arrs);\n+  std::vector<std::shared_ptr<Array>> ca2_arrs = {a2, a2->Slice(1)};\n+  auto ca2 = std::make_shared<ChunkedArray>(ca2_arrs);\n+  ASSERT_OK(Invert(&this->ctx_, Datum(ca1), &result));\n+  ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n+  std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n+  ASSERT_TRUE(result_ca->Equals(ca2));\n+}\n+\n+TEST_F(TestBooleanKernel, And) {\n+  AndKernelFunc kernel;\n+  vector<bool> values1 = {true, false, true, false, true, true};\n+  vector<bool> values2 = {true, true, false, false, true, false};\n+  vector<bool> values3 = {true, false, false, false, true, false};\n+  TestBinaryKernel(kernel, values1, values2, values3, values3);\n+}\n+\n+TEST_F(TestBooleanKernel, Or) {\n+  OrKernelFunc kernel;\n+  vector<bool> values1 = {true, false, true, false, true, true};\n+  vector<bool> values2 = {true, true, false, false, true, false};\n+  vector<bool> values3 = {true, true, true, false, true, true};\n+  vector<bool> values3_nulls = {true, false, false, false, true, false};\n+  TestBinaryKernel(kernel, values1, values2, values3, values3_nulls);\n+}\n+\n+TEST_F(TestBooleanKernel, Xor) {\n+  XorKernelFunc kernel;\n+  vector<bool> values1 = {true, false, true, false, true, true};\n+  vector<bool> values2 = {true, true, false, false, true, false};\n+  vector<bool> values3 = {false, true, true, false, false, true};\n+  vector<bool> values3_nulls = {true, false, false, false, true, false};\n+  TestBinaryKernel(kernel, values1, values2, values3, values3_nulls);\n+}\n+\n+class TestInvokeBinaryKernel : public ComputeFixture, public TestBase {};\n+\n+class DummyBinaryKernel : public BinaryKernel {\n+  Status Call(FunctionContext* ctx, const Datum& left, const Datum& right,\n+              Datum* out) override {\n+    return Status::OK();\n+  }\n+};\n+\n+TEST_F(TestInvokeBinaryKernel, Exceptions) {\n+  DummyBinaryKernel kernel;\n+  std::vector<Datum> outputs;\n+  std::shared_ptr<Table> table;\n+  vector<bool> values1 = {true, false, true};\n+  vector<bool> values2 = {false, true, false};\n+\n+  auto type = boolean();\n+  auto a1 = _MakeArray<BooleanType, bool>(type, values1, {});\n+  auto a2 = _MakeArray<BooleanType, bool>(type, values2, {});\n+\n+  // Left is not an array-like\n+  ASSERT_RAISES(Invalid, detail::InvokeBinaryArrayKernel(\n+                             &this->ctx_, &kernel, Datum(table), Datum(a2), &outputs));\n+  // Right is not an array-like\n+  ASSERT_RAISES(Invalid, detail::InvokeBinaryArrayKernel(&this->ctx_, &kernel, Datum(a1),\n+                                                         Datum(table), &outputs));\n+  // Different sized inputs\n+  ASSERT_RAISES(Invalid, detail::InvokeBinaryArrayKernel(&this->ctx_, &kernel, Datum(a1),\n+                                                         Datum(a1->Slice(1)), &outputs));\n+}\n+\n }  // namespace compute\n }  // namespace arrow\ndiff --git a/cpp/src/arrow/compute/kernel.h b/cpp/src/arrow/compute/kernel.h\nindex 3691f4ad83..fd596f18e2 100644\n--- a/cpp/src/arrow/compute/kernel.h\n+++ b/cpp/src/arrow/compute/kernel.h\n@@ -103,6 +103,10 @@ struct ARROW_EXPORT Datum {\n     return util::get<std::shared_ptr<ArrayData>>(this->value);\n   }\n \n+  std::shared_ptr<Array> make_array() const {\n+    return MakeArray(util::get<std::shared_ptr<ArrayData>>(this->value));\n+  }\n+\n   std::shared_ptr<ChunkedArray> chunked_array() const {\n     return util::get<std::shared_ptr<ChunkedArray>>(this->value);\n   }\n@@ -135,6 +139,14 @@ class ARROW_EXPORT UnaryKernel : public OpKernel {\n   virtual Status Call(FunctionContext* ctx, const Datum& input, Datum* out) = 0;\n };\n \n+/// \\class BinaryKernel\n+/// \\brief An array-valued function of a two input arguments\n+class ARROW_EXPORT BinaryKernel : public OpKernel {\n+ public:\n+  virtual Status Call(FunctionContext* ctx, const Datum& left, const Datum& right,\n+                      Datum* out) = 0;\n+};\n+\n }  // namespace compute\n }  // namespace arrow\n \ndiff --git a/cpp/src/arrow/compute/kernels/CMakeLists.txt b/cpp/src/arrow/compute/kernels/CMakeLists.txt\nindex 715e6c6612..923c8c3bd4 100644\n--- a/cpp/src/arrow/compute/kernels/CMakeLists.txt\n+++ b/cpp/src/arrow/compute/kernels/CMakeLists.txt\n@@ -16,6 +16,7 @@\n # under the License.\n \n install(FILES\n+  boolean.h\n   cast.h\n   hash.h\n   DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}/arrow/compute/kernels\")\ndiff --git a/cpp/src/arrow/compute/kernels/boolean.cc b/cpp/src/arrow/compute/kernels/boolean.cc\nnew file mode 100644\nindex 0000000000..64853be178\n--- /dev/null\n+++ b/cpp/src/arrow/compute/kernels/boolean.cc\n@@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/kernels/boolean.h\"\n+\n+#include \"arrow/compute/context.h\"\n+#include \"arrow/compute/kernels/util-internal.h\"\n+#include \"arrow/util/logging.h\"\n+\n+#include <vector>\n+\n+namespace arrow {\n+namespace compute {\n+\n+class InvertKernel : public UnaryKernel {\n+  Status Call(FunctionContext* ctx, const Datum& input, Datum* out) override {\n+    DCHECK_EQ(Datum::ARRAY, input.kind());\n+\n+    const ArrayData& in_data = *input.array();\n+    ArrayData* result;\n+\n+    out->value = ArrayData::Make(boolean(), in_data.length);\n+    result = out->array().get();\n+\n+    // Allocate or copy bitmap\n+    result->null_count = in_data.null_count;\n+    std::shared_ptr<Buffer> validity_bitmap = in_data.buffers[0];\n+    if (in_data.offset != 0) {\n+      RETURN_NOT_OK(CopyBitmap(ctx->memory_pool(), validity_bitmap->data(),\n+                               in_data.offset, in_data.length, &validity_bitmap));\n+    }\n+    result->buffers.push_back(validity_bitmap);\n+\n+    // Allocate output data buffer\n+    std::shared_ptr<Buffer> data_buffer;\n+    RETURN_NOT_OK(InvertBitmap(ctx->memory_pool(), in_data.buffers[1]->data(),\n+                               in_data.offset, in_data.length, &data_buffer));\n+    result->buffers.push_back(data_buffer);\n+\n+    return Status::OK();\n+  }\n+};\n+\n+Status Invert(FunctionContext* ctx, const Datum& value, Datum* out) {\n+  InvertKernel kernel;\n+\n+  std::vector<Datum> result;\n+  RETURN_NOT_OK(detail::InvokeUnaryArrayKernel(ctx, &kernel, value, &result));\n+\n+  *out = detail::WrapDatumsLike(value, result);\n+  return Status::OK();\n+}\n+\n+class BinaryBooleanKernel : public BinaryKernel {\n+  virtual Status Compute(FunctionContext* ctx, const ArrayData& left,\n+                         const ArrayData& right, ArrayData* out) = 0;\n+\n+  Status Call(FunctionContext* ctx, const Datum& left, const Datum& right,\n+              Datum* out) override {\n+    DCHECK_EQ(Datum::ARRAY, right.kind());\n+    DCHECK_EQ(Datum::ARRAY, left.kind());\n+\n+    const ArrayData& left_data = *left.array();\n+    const ArrayData& right_data = *right.array();\n+    ArrayData* result;\n+    out->value = ArrayData::Make(boolean(), right_data.length);\n+\n+    result = out->array().get();\n+\n+    // If one of the arrays has a null value, the result will have a null.\n+    std::shared_ptr<Buffer> validity_bitmap;\n+    RETURN_NOT_OK(BitmapAnd(ctx->memory_pool(), left_data.buffers[0]->data(),\n+                            left_data.offset, right_data.buffers[0]->data(),\n+                            right_data.offset, right_data.length, 0, &validity_bitmap));\n+    result->buffers.push_back(validity_bitmap);\n+\n+    result->null_count =\n+        result->length - CountSetBits(validity_bitmap->data(), 0, result->length);\n+\n+    return Compute(ctx, left_data, right_data, result);\n+  }\n+};\n+\n+class AndKernel : public BinaryBooleanKernel {\n+  Status Compute(FunctionContext* ctx, const ArrayData& left, const ArrayData& right,\n+                 ArrayData* out) override {\n+    std::shared_ptr<Buffer> data_bitmap;\n+    RETURN_NOT_OK(BitmapAnd(ctx->memory_pool(), left.buffers[1]->data(), left.offset,\n+                            right.buffers[1]->data(), right.offset, right.length, 0,\n+                            &data_bitmap));\n+    out->buffers.push_back(data_bitmap);\n+    return Status::OK();\n+  }\n+};\n+\n+Status And(FunctionContext* ctx, const Datum& left, const Datum& right, Datum* out) {\n+  AndKernel kernel;\n+  return detail::InvokeBinaryArrayKernel(ctx, &kernel, left, right, out);\n+}\n+\n+class OrKernel : public BinaryBooleanKernel {\n+  Status Compute(FunctionContext* ctx, const ArrayData& left, const ArrayData& right,\n+                 ArrayData* out) override {\n+    std::shared_ptr<Buffer> data_bitmap;\n+    RETURN_NOT_OK(BitmapOr(ctx->memory_pool(), left.buffers[1]->data(), left.offset,\n+                           right.buffers[1]->data(), right.offset, right.length, 0,\n+                           &data_bitmap));\n+    out->buffers.push_back(data_bitmap);\n+    return Status::OK();\n+  }\n+};\n+\n+Status Or(FunctionContext* ctx, const Datum& left, const Datum& right, Datum* out) {\n+  OrKernel kernel;\n+  return detail::InvokeBinaryArrayKernel(ctx, &kernel, left, right, out);\n+}\n+\n+class XorKernel : public BinaryBooleanKernel {\n+  Status Compute(FunctionContext* ctx, const ArrayData& left, const ArrayData& right,\n+                 ArrayData* out) override {\n+    std::shared_ptr<Buffer> data_bitmap;\n+    RETURN_NOT_OK(BitmapXor(ctx->memory_pool(), left.buffers[1]->data(), left.offset,\n+                            right.buffers[1]->data(), right.offset, right.length, 0,\n+                            &data_bitmap));\n+    out->buffers.push_back(data_bitmap);\n+    return Status::OK();\n+  }\n+};\n+\n+Status Xor(FunctionContext* ctx, const Datum& left, const Datum& right, Datum* out) {\n+  XorKernel kernel;\n+  return detail::InvokeBinaryArrayKernel(ctx, &kernel, left, right, out);\n+}\n+\n+}  // namespace compute\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/compute/kernels/boolean.h b/cpp/src/arrow/compute/kernels/boolean.h\nnew file mode 100644\nindex 0000000000..4c4072caed\n--- /dev/null\n+++ b/cpp/src/arrow/compute/kernels/boolean.h\n@@ -0,0 +1,83 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_COMPUTE_KERNELS_BOOLEAN_H\n+#define ARROW_COMPUTE_KERNELS_BOOLEAN_H\n+\n+#include <memory>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+#include \"arrow/compute/kernel.h\"\n+\n+namespace arrow {\n+\n+class Array;\n+class ChunkedArray;\n+class Column;\n+class DataType;\n+\n+namespace compute {\n+\n+/// \\brief Invert the values of a boolean datum\n+/// \\param[in] context the FunctionContext\n+/// \\param[in] value datum to invert\n+/// \\param[out] out resulting datum\n+///\n+/// \\since 0.11.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Status Invert(FunctionContext* context, const Datum& value, Datum* out);\n+\n+/// \\brief Element-wise AND of two boolean dates\n+/// \\param[in] context the FunctionContext\n+/// \\param[in] left left operand (array)\n+/// \\param[in] right right operand (array)\n+/// \\param[out] out resulting datum\n+///\n+/// \\since 0.11.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Status And(FunctionContext* context, const Datum& left, const Datum& right, Datum* out);\n+\n+/// \\brief Element-wise OR of two boolean dates\n+/// \\param[in] context the FunctionContext\n+/// \\param[in] left left operand (array)\n+/// \\param[in] right right operand (array)\n+/// \\param[out] out resulting datum\n+///\n+/// \\since 0.11.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Status Or(FunctionContext* context, const Datum& left, const Datum& right, Datum* out);\n+\n+/// \\brief Element-wise XOR of two boolean dates\n+/// \\param[in] context the FunctionContext\n+/// \\param[in] left left operand (array)\n+/// \\param[in] right right operand (array)\n+/// \\param[out] out resulting datum\n+///\n+/// \\since 0.11.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Status Xor(FunctionContext* context, const Datum& left, const Datum& right, Datum* out);\n+\n+}  // namespace compute\n+}  // namespace arrow\n+\n+#endif  // ARROW_COMPUTE_KERNELS_CAST_H\ndiff --git a/cpp/src/arrow/compute/kernels/util-internal.cc b/cpp/src/arrow/compute/kernels/util-internal.cc\nindex 0734365859..c16e7aa052 100644\n--- a/cpp/src/arrow/compute/kernels/util-internal.cc\n+++ b/cpp/src/arrow/compute/kernels/util-internal.cc\n@@ -17,6 +17,7 @@\n \n #include \"arrow/compute/kernels/util-internal.h\"\n \n+#include <algorithm>\n #include <memory>\n #include <vector>\n \n@@ -50,6 +51,85 @@ Status InvokeUnaryArrayKernel(FunctionContext* ctx, UnaryKernel* kernel,\n   return Status::OK();\n }\n \n+Status InvokeBinaryArrayKernel(FunctionContext* ctx, BinaryKernel* kernel,\n+                               const Datum& left, const Datum& right,\n+                               std::vector<Datum>* outputs) {\n+  int64_t left_length;\n+  std::vector<std::shared_ptr<Array>> left_arrays;\n+  if (left.kind() == Datum::ARRAY) {\n+    left_length = left.array()->length;\n+    left_arrays.push_back(left.make_array());\n+  } else if (left.kind() == Datum::CHUNKED_ARRAY) {\n+    left_length = left.chunked_array()->length();\n+    left_arrays = left.chunked_array()->chunks();\n+  } else {\n+    return Status::Invalid(\"Left input Datum was not array-like\");\n+  }\n+\n+  int64_t right_length;\n+  std::vector<std::shared_ptr<Array>> right_arrays;\n+  if (right.kind() == Datum::ARRAY) {\n+    right_length = right.array()->length;\n+    right_arrays.push_back(right.make_array());\n+  } else if (right.kind() == Datum::CHUNKED_ARRAY) {\n+    right_length = right.chunked_array()->length();\n+    right_arrays = right.chunked_array()->chunks();\n+  } else {\n+    return Status::Invalid(\"Right input Datum was not array-like\");\n+  }\n+\n+  if (right_length != left_length) {\n+    return Status::Invalid(\"Right and left have different lengths\");\n+  }\n+\n+  // TODO: Remove duplication with ChunkedArray::Equals\n+  int left_chunk_idx = 0;\n+  int64_t left_start_idx = 0;\n+  int right_chunk_idx = 0;\n+  int64_t right_start_idx = 0;\n+\n+  int64_t elements_compared = 0;\n+  while (elements_compared < left_length) {\n+    const std::shared_ptr<Array> left_array = left_arrays[left_chunk_idx];\n+    const std::shared_ptr<Array> right_array = right_arrays[right_chunk_idx];\n+    int64_t common_length = std::min(left_array->length() - left_start_idx,\n+                                     right_array->length() - right_start_idx);\n+\n+    std::shared_ptr<Array> left_op = left_array->Slice(left_start_idx, common_length);\n+    std::shared_ptr<Array> right_op = right_array->Slice(right_start_idx, common_length);\n+    Datum output;\n+    RETURN_NOT_OK(kernel->Call(ctx, Datum(left_op), Datum(right_op), &output));\n+    outputs->push_back(output);\n+\n+    elements_compared += common_length;\n+\n+    // If we have exhausted the current chunk, proceed to the next one individually.\n+    if (left_start_idx + common_length == left_array->length()) {\n+      left_chunk_idx++;\n+      left_start_idx = 0;\n+    } else {\n+      left_start_idx += common_length;\n+    }\n+\n+    if (right_start_idx + common_length == right_array->length()) {\n+      right_chunk_idx++;\n+      right_start_idx = 0;\n+    } else {\n+      right_start_idx += common_length;\n+    }\n+  }\n+\n+  return Status::OK();\n+}\n+\n+Status InvokeBinaryArrayKernel(FunctionContext* ctx, BinaryKernel* kernel,\n+                               const Datum& left, const Datum& right, Datum* output) {\n+  std::vector<Datum> result;\n+  RETURN_NOT_OK(InvokeBinaryArrayKernel(ctx, kernel, left, right, &result));\n+  *output = detail::WrapDatumsLike(left, result);\n+  return Status::OK();\n+}\n+\n Datum WrapArraysLike(const Datum& value,\n                      const std::vector<std::shared_ptr<Array>>& arrays) {\n   // Create right kind of datum\ndiff --git a/cpp/src/arrow/compute/kernels/util-internal.h b/cpp/src/arrow/compute/kernels/util-internal.h\nindex acfcb4bb79..8c4b86942b 100644\n--- a/cpp/src/arrow/compute/kernels/util-internal.h\n+++ b/cpp/src/arrow/compute/kernels/util-internal.h\n@@ -52,6 +52,12 @@ namespace detail {\n Status InvokeUnaryArrayKernel(FunctionContext* ctx, UnaryKernel* kernel,\n                               const Datum& value, std::vector<Datum>* outputs);\n \n+Status InvokeBinaryArrayKernel(FunctionContext* ctx, BinaryKernel* kernel,\n+                               const Datum& left, const Datum& right,\n+                               std::vector<Datum>* outputs);\n+Status InvokeBinaryArrayKernel(FunctionContext* ctx, BinaryKernel* kernel,\n+                               const Datum& left, const Datum& right, Datum* output);\n+\n Datum WrapArraysLike(const Datum& value,\n                      const std::vector<std::shared_ptr<Array>>& arrays);\n \ndiff --git a/cpp/src/arrow/table.cc b/cpp/src/arrow/table.cc\nindex bb585033a6..9919085a57 100644\n--- a/cpp/src/arrow/table.cc\n+++ b/cpp/src/arrow/table.cc\n@@ -191,6 +191,9 @@ Column::Column(const std::shared_ptr<Field>& field, const std::shared_ptr<Array>\n Column::Column(const std::string& name, const std::shared_ptr<Array>& data)\n     : Column(::arrow::field(name, data->type()), data) {}\n \n+Column::Column(const std::string& name, const std::shared_ptr<ChunkedArray>& data)\n+    : Column(::arrow::field(name, data->type()), data) {}\n+\n Column::Column(const std::shared_ptr<Field>& field,\n                const std::shared_ptr<ChunkedArray>& data)\n     : field_(field), data_(data) {}\ndiff --git a/cpp/src/arrow/table.h b/cpp/src/arrow/table.h\nindex 43c51a7b74..f80cf29bb0 100644\n--- a/cpp/src/arrow/table.h\n+++ b/cpp/src/arrow/table.h\n@@ -103,6 +103,7 @@ class ARROW_EXPORT Column {\n \n   // Construct from name and array\n   Column(const std::string& name, const std::shared_ptr<Array>& data);\n+  Column(const std::string& name, const std::shared_ptr<ChunkedArray>& data);\n \n   int64_t length() const { return data_->length(); }\n \ndiff --git a/cpp/src/arrow/util/bit-util-test.cc b/cpp/src/arrow/util/bit-util-test.cc\nindex adb09e1bf6..48b4ff16ed 100644\n--- a/cpp/src/arrow/util/bit-util-test.cc\n+++ b/cpp/src/arrow/util/bit-util-test.cc\n@@ -31,6 +31,7 @@\n \n #include \"arrow/buffer.h\"\n #include \"arrow/memory_pool.h\"\n+#include \"arrow/test-common.h\"\n #include \"arrow/test-util.h\"\n #include \"arrow/util/bit-stream-utils.h\"\n #include \"arrow/util/bit-util.h\"\n@@ -350,49 +351,117 @@ TYPED_TEST(TestGenerateBits, NormalOperation) {\n   }\n }\n \n-TEST(BitmapAnd, Aligned) {\n-  std::shared_ptr<Buffer> left, right, out;\n-  int64_t length;\n+struct BitmapOperation {\n+  virtual Status Call(MemoryPool* pool, const uint8_t* left, int64_t left_offset,\n+                      const uint8_t* right, int64_t right_offset, int64_t length,\n+                      int64_t out_offset, std::shared_ptr<Buffer>* out_buffer) const = 0;\n \n-  for (int64_t left_offset : {0, 1, 3, 5, 7, 8, 13, 21, 38, 75, 120}) {\n-    BitmapFromVector({0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1}, left_offset, &left,\n-                     &length);\n-    for (int64_t right_offset : {left_offset, left_offset + 8, left_offset + 40}) {\n-      BitmapFromVector({0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0}, right_offset, &right,\n-                       &length);\n-      for (int64_t out_offset : {left_offset, left_offset + 16, left_offset + 24}) {\n-        ASSERT_OK(BitmapAnd(default_memory_pool(), left->mutable_data(), left_offset,\n+  virtual ~BitmapOperation() = default;\n+};\n+\n+struct BitmapAndOp : public BitmapOperation {\n+  Status Call(MemoryPool* pool, const uint8_t* left, int64_t left_offset,\n+              const uint8_t* right, int64_t right_offset, int64_t length,\n+              int64_t out_offset, std::shared_ptr<Buffer>* out_buffer) const override {\n+    return BitmapAnd(pool, left, left_offset, right, right_offset, length, out_offset,\n+                     out_buffer);\n+  }\n+};\n+\n+struct BitmapOrOp : public BitmapOperation {\n+  Status Call(MemoryPool* pool, const uint8_t* left, int64_t left_offset,\n+              const uint8_t* right, int64_t right_offset, int64_t length,\n+              int64_t out_offset, std::shared_ptr<Buffer>* out_buffer) const override {\n+    return BitmapOr(pool, left, left_offset, right, right_offset, length, out_offset,\n+                    out_buffer);\n+  }\n+};\n+\n+struct BitmapXorOp : public BitmapOperation {\n+  Status Call(MemoryPool* pool, const uint8_t* left, int64_t left_offset,\n+              const uint8_t* right, int64_t right_offset, int64_t length,\n+              int64_t out_offset, std::shared_ptr<Buffer>* out_buffer) const override {\n+    return BitmapXor(pool, left, left_offset, right, right_offset, length, out_offset,\n+                     out_buffer);\n+  }\n+};\n+\n+class BitmapOp : public TestBase {\n+ public:\n+  void TestAligned(const BitmapOperation& op, const std::vector<int>& left_bits,\n+                   const std::vector<int>& right_bits,\n+                   const std::vector<int>& result_bits) {\n+    std::shared_ptr<Buffer> left, right, out;\n+    int64_t length;\n+\n+    for (int64_t left_offset : {0, 1, 3, 5, 7, 8, 13, 21, 38, 75, 120}) {\n+      BitmapFromVector(left_bits, left_offset, &left, &length);\n+      for (int64_t right_offset : {left_offset, left_offset + 8, left_offset + 40}) {\n+        BitmapFromVector(right_bits, right_offset, &right, &length);\n+        for (int64_t out_offset : {left_offset, left_offset + 16, left_offset + 24}) {\n+          ASSERT_OK(op.Call(default_memory_pool(), left->mutable_data(), left_offset,\n                             right->mutable_data(), right_offset, length, out_offset,\n                             &out));\n-        auto reader = internal::BitmapReader(out->mutable_data(), out_offset, length);\n-        ASSERT_READER_VALUES(reader, {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0});\n+          auto reader = internal::BitmapReader(out->mutable_data(), out_offset, length);\n+          ASSERT_READER_VALUES(reader, result_bits);\n+        }\n       }\n     }\n   }\n-}\n \n-TEST(BitmapAnd, Unaligned) {\n-  std::shared_ptr<Buffer> left, right, out;\n-  int64_t length;\n-  auto offset_values = {0, 1, 3, 5, 7, 8, 13, 21, 38, 75, 120};\n+  void TestUnaligned(const BitmapOperation& op, const std::vector<int>& left_bits,\n+                     const std::vector<int>& right_bits,\n+                     const std::vector<int>& result_bits) {\n+    std::shared_ptr<Buffer> left, right, out;\n+    int64_t length;\n+    auto offset_values = {0, 1, 3, 5, 7, 8, 13, 21, 38, 75, 120};\n \n-  for (int64_t left_offset : offset_values) {\n-    BitmapFromVector({0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1}, left_offset, &left,\n-                     &length);\n+    for (int64_t left_offset : offset_values) {\n+      BitmapFromVector(left_bits, left_offset, &left, &length);\n \n-    for (int64_t right_offset : offset_values) {\n-      BitmapFromVector({0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0}, right_offset, &right,\n-                       &length);\n+      for (int64_t right_offset : offset_values) {\n+        BitmapFromVector(right_bits, right_offset, &right, &length);\n \n-      for (int64_t out_offset : offset_values) {\n-        ASSERT_OK(BitmapAnd(default_memory_pool(), left->mutable_data(), left_offset,\n+        for (int64_t out_offset : offset_values) {\n+          ASSERT_OK(op.Call(default_memory_pool(), left->mutable_data(), left_offset,\n                             right->mutable_data(), right_offset, length, out_offset,\n                             &out));\n-        auto reader = internal::BitmapReader(out->mutable_data(), out_offset, length);\n-        ASSERT_READER_VALUES(reader, {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0});\n+          auto reader = internal::BitmapReader(out->mutable_data(), out_offset, length);\n+          ASSERT_READER_VALUES(reader, result_bits);\n+        }\n       }\n     }\n   }\n+};\n+\n+TEST_F(BitmapOp, And) {\n+  BitmapAndOp op;\n+  std::vector<int> left = {0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1};\n+  std::vector<int> right = {0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0};\n+  std::vector<int> result = {0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0};\n+\n+  TestAligned(op, left, right, result);\n+  TestUnaligned(op, left, right, result);\n+}\n+\n+TEST_F(BitmapOp, Or) {\n+  BitmapOrOp op;\n+  std::vector<int> left = {0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0};\n+  std::vector<int> right = {0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0};\n+  std::vector<int> result = {0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0};\n+\n+  TestAligned(op, left, right, result);\n+  TestUnaligned(op, left, right, result);\n+}\n+\n+TEST_F(BitmapOp, XorAligned) {\n+  BitmapXorOp op;\n+  std::vector<int> left = {0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1};\n+  std::vector<int> right = {0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0};\n+  std::vector<int> result = {0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1};\n+\n+  TestAligned(op, left, right, result);\n+  TestUnaligned(op, left, right, result);\n }\n \n static inline int64_t SlowCountBits(const uint8_t* data, int64_t bit_offset,\ndiff --git a/cpp/src/arrow/util/bit-util.cc b/cpp/src/arrow/util/bit-util.cc\nindex 0d2929e187..cd3e6d1e00 100644\n--- a/cpp/src/arrow/util/bit-util.cc\n+++ b/cpp/src/arrow/util/bit-util.cc\n@@ -25,6 +25,7 @@\n \n #include <algorithm>\n #include <cstring>\n+#include <functional>\n #include <vector>\n \n #include \"arrow/buffer.h\"\n@@ -106,8 +107,9 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n   return count;\n }\n \n-Status CopyBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset, int64_t length,\n-                  std::shared_ptr<Buffer>* out) {\n+template <bool invert_bits>\n+Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n+                      int64_t length, std::shared_ptr<Buffer>* out) {\n   std::shared_ptr<Buffer> buffer;\n   RETURN_NOT_OK(AllocateEmptyBitmap(pool, length, &buffer));\n   uint8_t* dest = buffer->mutable_data();\n@@ -129,12 +131,22 @@ Status CopyBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset, int64_t\n     int64_t i = num_bytes - 1;\n     while (i + 1 > 0) {\n       uint8_t cur_byte = data[byte_offset + i];\n-      dest[i] = static_cast<uint8_t>((cur_byte >> bit_offset) | carry);\n+      if (invert_bits) {\n+        dest[i] = static_cast<uint8_t>(~((cur_byte >> bit_offset) | carry));\n+      } else {\n+        dest[i] = static_cast<uint8_t>((cur_byte >> bit_offset) | carry);\n+      }\n       carry = (cur_byte & carry_mask) << carry_shift;\n       --i;\n     }\n   } else {\n-    std::memcpy(dest, data + byte_offset, static_cast<size_t>(num_bytes));\n+    if (invert_bits) {\n+      for (int64_t i = 0; i < num_bytes; i++) {\n+        dest[i] = static_cast<uint8_t>(~(data[byte_offset + i]));\n+      }\n+    } else {\n+      std::memcpy(dest, data + byte_offset, static_cast<size_t>(num_bytes));\n+    }\n   }\n \n   for (int64_t i = length; i < length + bits_to_zero; ++i) {\n@@ -146,6 +158,16 @@ Status CopyBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset, int64_t\n   return Status::OK();\n }\n \n+Status CopyBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset, int64_t length,\n+                  std::shared_ptr<Buffer>* out) {\n+  return TransferBitmap<false>(pool, data, offset, length, out);\n+}\n+\n+Status InvertBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset, int64_t length,\n+                    std::shared_ptr<Buffer>* out) {\n+  return TransferBitmap<true>(pool, data, offset, length, out);\n+}\n+\n bool BitmapEquals(const uint8_t* left, int64_t left_offset, const uint8_t* right,\n                   int64_t right_offset, int64_t bit_length) {\n   if (left_offset % 8 == 0 && right_offset % 8 == 0) {\n@@ -176,9 +198,11 @@ bool BitmapEquals(const uint8_t* left, int64_t left_offset, const uint8_t* right\n \n namespace {\n \n-void AlignedBitmapAnd(const uint8_t* left, int64_t left_offset, const uint8_t* right,\n-                      int64_t right_offset, uint8_t* out, int64_t out_offset,\n-                      int64_t length) {\n+template <typename Op>\n+void AlignedBitmapOp(const uint8_t* left, int64_t left_offset, const uint8_t* right,\n+                     int64_t right_offset, uint8_t* out, int64_t out_offset,\n+                     int64_t length) {\n+  Op op;\n   DCHECK_EQ(left_offset % 8, right_offset % 8);\n   DCHECK_EQ(left_offset % 8, out_offset % 8);\n \n@@ -187,18 +211,20 @@ void AlignedBitmapAnd(const uint8_t* left, int64_t left_offset, const uint8_t* r\n   right += right_offset / 8;\n   out += out_offset / 8;\n   for (int64_t i = 0; i < nbytes; ++i) {\n-    out[i] = left[i] & right[i];\n+    out[i] = op(left[i], right[i]);\n   }\n }\n \n-void UnalignedBitmapAnd(const uint8_t* left, int64_t left_offset, const uint8_t* right,\n-                        int64_t right_offset, uint8_t* out, int64_t out_offset,\n-                        int64_t length) {\n+template <typename Op>\n+void UnalignedBitmapOp(const uint8_t* left, int64_t left_offset, const uint8_t* right,\n+                       int64_t right_offset, uint8_t* out, int64_t out_offset,\n+                       int64_t length) {\n+  Op op;\n   auto left_reader = internal::BitmapReader(left, left_offset, length);\n   auto right_reader = internal::BitmapReader(right, right_offset, length);\n   auto writer = internal::BitmapWriter(out, out_offset, length);\n   for (int64_t i = 0; i < length; ++i) {\n-    if (left_reader.IsSet() && right_reader.IsSet()) {\n+    if (op(left_reader.IsSet(), right_reader.IsSet())) {\n       writer.Set();\n     }\n     left_reader.Next();\n@@ -208,24 +234,46 @@ void UnalignedBitmapAnd(const uint8_t* left, int64_t left_offset, const uint8_t*\n   writer.Finish();\n }\n \n-}  // namespace\n-\n-Status BitmapAnd(MemoryPool* pool, const uint8_t* left, int64_t left_offset,\n-                 const uint8_t* right, int64_t right_offset, int64_t length,\n-                 int64_t out_offset, std::shared_ptr<Buffer>* out_buffer) {\n+template <typename BitOp, typename LogicalOp>\n+Status BitmapOp(MemoryPool* pool, const uint8_t* left, int64_t left_offset,\n+                const uint8_t* right, int64_t right_offset, int64_t length,\n+                int64_t out_offset, std::shared_ptr<Buffer>* out_buffer) {\n   if ((out_offset % 8 == left_offset % 8) && (out_offset % 8 == right_offset % 8)) {\n     // Fast case: can use bytewise AND\n     const int64_t phys_bits = length + out_offset;\n     RETURN_NOT_OK(AllocateEmptyBitmap(pool, phys_bits, out_buffer));\n-    AlignedBitmapAnd(left, left_offset, right, right_offset,\n-                     (*out_buffer)->mutable_data(), out_offset, length);\n+    AlignedBitmapOp<BitOp>(left, left_offset, right, right_offset,\n+                           (*out_buffer)->mutable_data(), out_offset, length);\n   } else {\n     // Unaligned\n     RETURN_NOT_OK(AllocateEmptyBitmap(pool, length + out_offset, out_buffer));\n-    UnalignedBitmapAnd(left, left_offset, right, right_offset,\n-                       (*out_buffer)->mutable_data(), out_offset, length);\n+    UnalignedBitmapOp<LogicalOp>(left, left_offset, right, right_offset,\n+                                 (*out_buffer)->mutable_data(), out_offset, length);\n   }\n   return Status::OK();\n }\n \n+}  // namespace\n+\n+Status BitmapAnd(MemoryPool* pool, const uint8_t* left, int64_t left_offset,\n+                 const uint8_t* right, int64_t right_offset, int64_t length,\n+                 int64_t out_offset, std::shared_ptr<Buffer>* out_buffer) {\n+  return BitmapOp<std::bit_and<uint8_t>, std::logical_and<bool>>(\n+      pool, left, left_offset, right, right_offset, length, out_offset, out_buffer);\n+}\n+\n+Status BitmapOr(MemoryPool* pool, const uint8_t* left, int64_t left_offset,\n+                const uint8_t* right, int64_t right_offset, int64_t length,\n+                int64_t out_offset, std::shared_ptr<Buffer>* out_buffer) {\n+  return BitmapOp<std::bit_or<uint8_t>, std::logical_or<bool>>(\n+      pool, left, left_offset, right, right_offset, length, out_offset, out_buffer);\n+}\n+\n+Status BitmapXor(MemoryPool* pool, const uint8_t* left, int64_t left_offset,\n+                 const uint8_t* right, int64_t right_offset, int64_t length,\n+                 int64_t out_offset, std::shared_ptr<Buffer>* out_buffer) {\n+  return BitmapOp<std::bit_xor<uint8_t>, std::bit_xor<bool>>(\n+      pool, left, left_offset, right, right_offset, length, out_offset, out_buffer);\n+}\n+\n }  // namespace arrow\ndiff --git a/cpp/src/arrow/util/bit-util.h b/cpp/src/arrow/util/bit-util.h\nindex d36ea5d5dd..4696a8cb81 100644\n--- a/cpp/src/arrow/util/bit-util.h\n+++ b/cpp/src/arrow/util/bit-util.h\n@@ -570,6 +570,19 @@ ARROW_EXPORT\n Status CopyBitmap(MemoryPool* pool, const uint8_t* bitmap, int64_t offset, int64_t length,\n                   std::shared_ptr<Buffer>* out);\n \n+/// Invert a bit range of an existing bitmap\n+///\n+/// \\param[in] pool memory pool to allocate memory from\n+/// \\param[in] bitmap source data\n+/// \\param[in] offset bit offset into the source data\n+/// \\param[in] length number of bits to copy\n+/// \\param[out] out the resulting copy\n+///\n+/// \\return Status message\n+ARROW_EXPORT\n+Status InvertBitmap(MemoryPool* pool, const uint8_t* bitmap, int64_t offset,\n+                    int64_t length, std::shared_ptr<Buffer>* out);\n+\n /// Compute the number of 1's in the given data array\n ///\n /// \\param[in] data a packed LSB-ordered bitmap as a byte array\n@@ -589,6 +602,16 @@ Status BitmapAnd(MemoryPool* pool, const uint8_t* left, int64_t left_offset,\n                  const uint8_t* right, int64_t right_offset, int64_t length,\n                  int64_t out_offset, std::shared_ptr<Buffer>* out_buffer);\n \n+ARROW_EXPORT\n+Status BitmapOr(MemoryPool* pool, const uint8_t* left, int64_t left_offset,\n+                const uint8_t* right, int64_t right_offset, int64_t length,\n+                int64_t out_offset, std::shared_ptr<Buffer>* out_buffer);\n+\n+ARROW_EXPORT\n+Status BitmapXor(MemoryPool* pool, const uint8_t* left, int64_t left_offset,\n+                 const uint8_t* right, int64_t right_offset, int64_t length,\n+                 int64_t out_offset, std::shared_ptr<Buffer>* out_buffer);\n+\n }  // namespace arrow\n \n #endif  // ARROW_UTIL_BIT_UTIL_H\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-25T11:04:54.653+0000",
                    "updated": "2018-08-25T11:04:54.653+0000",
                    "started": "2018-08-25T11:04:54.653+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "138092",
                    "issueId": "13103408"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/138151",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461#discussion_r212809037\n \n \n\n ##########\n File path: cpp/src/arrow/compute/compute-test.cc\n ##########\n @@ -1285,5 +1287,180 @@ TEST_F(TestHashKernel, ChunkedArrayInvoke) {\n   ASSERT_TRUE(encoded_out.chunked_array()->Equals(*dict_carr));\n }\n \n+struct KernelFunc {\n+  virtual Status Call(FunctionContext* ctx, const Datum& left, const Datum& right,\n+                      Datum* out) const = 0;\n+\n+  virtual ~KernelFunc() = default;\n+};\n+\n+struct AndKernelFunc : KernelFunc {\n+  Status Call(FunctionContext* ctx, const Datum& left, const Datum& right,\n+              Datum* out) const override {\n+    return And(ctx, left, right, out);\n+  }\n+};\n+\n+struct OrKernelFunc : KernelFunc {\n+  Status Call(FunctionContext* ctx, const Datum& left, const Datum& right,\n+              Datum* out) const override {\n+    return Or(ctx, left, right, out);\n+  }\n+};\n+\n+struct XorKernelFunc : KernelFunc {\n+  Status Call(FunctionContext* ctx, const Datum& left, const Datum& right,\n+              Datum* out) const override {\n+    return Xor(ctx, left, right, out);\n+  }\n+};\n \n Review comment:\n   You can use `std::function` instead of declaring these helper classes. I'll submit a follow up patch\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-25T21:19:44.650+0000",
                    "updated": "2018-08-25T21:19:44.650+0000",
                    "started": "2018-08-25T21:19:44.649+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "138151",
                    "issueId": "13103408"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/138152",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461#discussion_r212809252\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/boolean.cc\n ##########\n @@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/kernels/boolean.h\"\n+\n+#include \"arrow/compute/context.h\"\n+#include \"arrow/compute/kernels/util-internal.h\"\n+#include \"arrow/util/logging.h\"\n+\n+#include <vector>\n+\n+namespace arrow {\n+namespace compute {\n+\n+class InvertKernel : public UnaryKernel {\n+  Status Call(FunctionContext* ctx, const Datum& input, Datum* out) override {\n+    DCHECK_EQ(Datum::ARRAY, input.kind());\n+\n+    const ArrayData& in_data = *input.array();\n+    ArrayData* result;\n+\n+    out->value = ArrayData::Make(boolean(), in_data.length);\n+    result = out->array().get();\n+\n+    // Allocate or copy bitmap\n+    result->null_count = in_data.null_count;\n+    std::shared_ptr<Buffer> validity_bitmap = in_data.buffers[0];\n+    if (in_data.offset != 0) {\n+      RETURN_NOT_OK(CopyBitmap(ctx->memory_pool(), validity_bitmap->data(),\n+                               in_data.offset, in_data.length, &validity_bitmap));\n+    }\n+    result->buffers.push_back(validity_bitmap);\n+\n+    // Allocate output data buffer\n+    std::shared_ptr<Buffer> data_buffer;\n+    RETURN_NOT_OK(InvertBitmap(ctx->memory_pool(), in_data.buffers[1]->data(),\n+                               in_data.offset, in_data.length, &data_buffer));\n \n Review comment:\n   That memory allocation is happening at the bottom of the call stack is not ideal -- we should not write any more such kernels as we're just creating technical debt. \r\n   \r\n   Let's add a TODO to return to these and enable them to write into preallocated memory, otherwise pipelining (invoking multiple kernels in a row without intermediate allocations) is not possible\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-25T21:19:44.659+0000",
                    "updated": "2018-08-25T21:19:44.659+0000",
                    "started": "2018-08-25T21:19:44.659+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "138152",
                    "issueId": "13103408"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/138153",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461#discussion_r212808782\n \n \n\n ##########\n File path: cpp/src/arrow/compute/compute-test.cc\n ##########\n @@ -1285,5 +1287,180 @@ TEST_F(TestHashKernel, ChunkedArrayInvoke) {\n   ASSERT_TRUE(encoded_out.chunked_array()->Equals(*dict_carr));\n }\n \n+struct KernelFunc {\n \n Review comment:\n   Google Style guide recommends only using struct for POD. Not as much of a big deal since this is not a public API\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-25T21:19:44.672+0000",
                    "updated": "2018-08-25T21:19:44.672+0000",
                    "started": "2018-08-25T21:19:44.671+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "138153",
                    "issueId": "13103408"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/138154",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461#discussion_r212808861\n \n \n\n ##########\n File path: cpp/src/arrow/compute/compute-test.cc\n ##########\n @@ -1285,5 +1287,255 @@ TEST_F(TestHashKernel, ChunkedArrayInvoke) {\n   ASSERT_TRUE(encoded_out.chunked_array()->Equals(*dict_carr));\n }\n \n+class TestBooleanKernel : public ComputeFixture, public TestBase {};\n+\n+TEST_F(TestBooleanKernel, Invert) {\n+  vector<bool> values1 = {true, false, true};\n+  vector<bool> values2 = {false, true, false};\n+\n+  auto type = boolean();\n+  auto a1 = _MakeArray<BooleanType, bool>(type, values1, {});\n+  auto a2 = _MakeArray<BooleanType, bool>(type, values2, {});\n+\n+  // Plain array\n+  Datum result;\n+  ASSERT_OK(Invert(&this->ctx_, Datum(a1), &result));\n+  ASSERT_EQ(Datum::ARRAY, result.kind());\n+  std::shared_ptr<Array> result_array = result.make_array();\n+  ASSERT_TRUE(result_array->Equals(a2));\n+\n+  // Array with offset\n+  ASSERT_OK(Invert(&this->ctx_, Datum(a1->Slice(1)), &result));\n+  ASSERT_EQ(Datum::ARRAY, result.kind());\n+  result_array = result.make_array();\n+  ASSERT_TRUE(result_array->Equals(a2->Slice(1)));\n+\n+  // ChunkedArray\n+  std::vector<std::shared_ptr<Array>> ca1_arrs = {a1, a1->Slice(1)};\n+  auto ca1 = std::make_shared<ChunkedArray>(ca1_arrs);\n+  std::vector<std::shared_ptr<Array>> ca2_arrs = {a2, a2->Slice(1)};\n+  auto ca2 = std::make_shared<ChunkedArray>(ca2_arrs);\n+  ASSERT_OK(Invert(&this->ctx_, Datum(ca1), &result));\n+  ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n+  std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n+  ASSERT_TRUE(result_ca->Equals(ca2));\n+}\n+\n+TEST_F(TestBooleanKernel, And) {\n \n Review comment:\n   +1\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-25T21:19:44.677+0000",
                    "updated": "2018-08-25T21:19:44.677+0000",
                    "started": "2018-08-25T21:19:44.676+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "138154",
                    "issueId": "13103408"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/worklog/138155",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #2461: ARROW-1563: [C++] Implement logical unary and binary kernels for boolean arrays\nURL: https://github.com/apache/arrow/pull/2461#discussion_r212809144\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/boolean.h\n ##########\n @@ -0,0 +1,83 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_COMPUTE_KERNELS_BOOLEAN_H\n+#define ARROW_COMPUTE_KERNELS_BOOLEAN_H\n+\n+#include <memory>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+#include \"arrow/compute/kernel.h\"\n+\n+namespace arrow {\n+\n+class Array;\n+class ChunkedArray;\n+class Column;\n+class DataType;\n+\n+namespace compute {\n+\n+/// \\brief Invert the values of a boolean datum\n+/// \\param[in] context the FunctionContext\n+/// \\param[in] value datum to invert\n+/// \\param[out] out resulting datum\n+///\n+/// \\since 0.11.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Status Invert(FunctionContext* context, const Datum& value, Datum* out);\n+\n+/// \\brief Element-wise AND of two boolean dates\n \n Review comment:\n   We should use \"datums\". Both \"data\" and \"datums\" are valid plural forms of datum. To use \"data\" would be confusing\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-25T21:19:44.681+0000",
                    "updated": "2018-08-25T21:19:44.681+0000",
                    "started": "2018-08-25T21:19:44.681+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "138155",
                    "issueId": "13103408"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 13200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@22b647d0[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2bdb128c[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@22315f6a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@510d76d2[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7e4d3fe2[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@42ffe45[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2ccd3ba5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@16cc6308[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1e9ec1c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@7a4fe7b2[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3f1aeb4d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4a3b1b85[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 13200,
        "customfield_12312520": null,
        "customfield_12312521": "Sat Aug 25 11:04:52 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-08-25T11:04:52.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1563/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2017-09-19T22:09:21.000+0000",
        "updated": "2018-08-28T16:30:50.000+0000",
        "timeoriginalestimate": null,
        "description": "And, or, not (negate), xor",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "3h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 13200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Implement logical unary and binary kernels for boolean arrays",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103408/comment/16592548",
                    "id": "16592548",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "body": "Issue resolved by pull request 2461\n[https://github.com/apache/arrow/pull/2461]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "created": "2018-08-25T11:04:52.458+0000",
                    "updated": "2018-08-25T11:04:52.458+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|i3k9j3:",
        "customfield_12314139": null
    }
}