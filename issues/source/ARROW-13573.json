{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13393729",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729",
    "key": "ARROW-13573",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350323",
                "id": "12350323",
                "description": "",
                "name": "6.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-10-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "kernel",
            "pull-request-available",
            "types"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12620610",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12620610",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13386833",
                    "key": "ARROW-13222",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13386833",
                    "fields": {
                        "summary": "[C++] Support variable-width types in case_when function",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12623291",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12623291",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13402220",
                    "key": "ARROW-14042",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13402220",
                    "fields": {
                        "summary": "[C++] Improve performance on dictionaries for 'case_when' kernel",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12623509",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12623509",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13402989",
                    "key": "ARROW-14105",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13402989",
                    "fields": {
                        "summary": "[C++] Reconcile type promotion rules between if_else, case_when, coalesce, select",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12623854",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12623854",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13404130",
                    "key": "ARROW-14177",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404130",
                    "fields": {
                        "summary": "[C++] Optimize dictionary support in kernels/Support nulls in DictionaryUnifier",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 15600,
            "total": 15600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 15600,
            "total": 15600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13573/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 26,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/643019",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm opened a new pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022\n\n\n   This supports dictionaries 'natively', that is, dictionaries are no longer unpacked. (If mixed dictionary and non-dictionary arguments are given, then they will be unpacked). \r\n   \r\n   For scalar conditions, the output will have the dictionary of whichever input is selected (or no dictionary if the output is null).\r\n   \r\n   For array conditions, the output will have the dictionary of the first input. Other dictionary indices will be remapped to this dictionary. If this is not possible, an error is raised.\r\n   \r\n   TODOs:\r\n   - More complete testing with different dictionary index and value types\r\n   - Support emitting nulls in the case that dictionary indices cannot be remapped\r\n   - Check the R tests for skips that can be removed\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-27T21:36:53.809+0000",
                    "updated": "2021-08-27T21:36:53.809+0000",
                    "started": "2021-08-27T21:36:53.809+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "643019",
                    "issueId": "13393729"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/643020",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022#issuecomment-907489673\n\n\n   https://issues.apache.org/jira/browse/ARROW-13573\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-27T21:37:07.592+0000",
                    "updated": "2021-08-27T21:37:07.592+0000",
                    "started": "2021-08-27T21:37:07.592+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "643020",
                    "issueId": "13393729"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/644613",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022#issuecomment-909602386\n\n\n   One thought: we could have all dictionary types use the variable-width type implementation, meaning we'd always unify dictionaries. This would behave a little more consistently.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-31T20:20:52.136+0000",
                    "updated": "2021-08-31T20:20:52.136+0000",
                    "started": "2021-08-31T20:20:52.136+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "644613",
                    "issueId": "13393729"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/644866",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022#issuecomment-909602386\n\n\n   One thought: we could have all dictionary types use the variable-width type implementation, meaning we'd always unify dictionaries. This would behave a little more consistently.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-01T09:12:12.647+0000",
                    "updated": "2021-09-01T09:12:12.647+0000",
                    "started": "2021-09-01T09:12:12.646+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "644866",
                    "issueId": "13393729"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/647023",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022#discussion_r702935784\n\n\n\n##########\nFile path: cpp/src/arrow/array/builder_dict.h\n##########\n@@ -282,6 +294,163 @@ class DictionaryBuilderBase : public ArrayBuilder {\n     return indices_builder_.AppendEmptyValues(length);\n   }\n \n+  Status AppendScalar(const Scalar& scalar, int64_t n_repeats) override {\n+    if (!scalar.type->Equals(type())) {\n+      return Status::Invalid(\"Cannot append scalar of type \", scalar.type->ToString(),\n+                             \" to builder for type \", type()->ToString());\n+    }\n+    if (!scalar.is_valid) return AppendNulls(n_repeats);\n+\n+    const auto& dict_ty = internal::checked_cast<const DictionaryType&>(*scalar.type);\n+    const DictionaryScalar& dict_scalar =\n+        internal::checked_cast<const DictionaryScalar&>(scalar);\n+    const auto& dict = internal::checked_cast<const typename TypeTraits<T>::ArrayType&>(\n+        *dict_scalar.value.dictionary);\n+    switch (dict_ty.index_type()->id()) {\n+      case Type::UINT8: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const UInt8Scalar&>(*dict_scalar.value.index).value);\n\nReview comment:\n       What happens if `dict` has a null at this index?\n\n##########\nFile path: cpp/src/arrow/array/builder_dict.h\n##########\n@@ -282,6 +294,163 @@ class DictionaryBuilderBase : public ArrayBuilder {\n     return indices_builder_.AppendEmptyValues(length);\n   }\n \n+  Status AppendScalar(const Scalar& scalar, int64_t n_repeats) override {\n+    if (!scalar.type->Equals(type())) {\n+      return Status::Invalid(\"Cannot append scalar of type \", scalar.type->ToString(),\n+                             \" to builder for type \", type()->ToString());\n+    }\n+    if (!scalar.is_valid) return AppendNulls(n_repeats);\n+\n+    const auto& dict_ty = internal::checked_cast<const DictionaryType&>(*scalar.type);\n+    const DictionaryScalar& dict_scalar =\n+        internal::checked_cast<const DictionaryScalar&>(scalar);\n+    const auto& dict = internal::checked_cast<const typename TypeTraits<T>::ArrayType&>(\n+        *dict_scalar.value.dictionary);\n+    switch (dict_ty.index_type()->id()) {\n+      case Type::UINT8: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const UInt8Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::INT8: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const Int8Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::UINT16: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const UInt16Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::INT16: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const Int16Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::UINT32: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const UInt32Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::INT32: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const Int32Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::UINT64: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const UInt64Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::INT64: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const Int64Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      default:\n+        return Status::TypeError(\"Invalid index type: \", dict_ty);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status AppendScalars(const ScalarVector& scalars) override {\n+    for (const auto& scalar : scalars) {\n+      ARROW_RETURN_NOT_OK(AppendScalar(*scalar, /*n_repeats=*/1));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status AppendArraySlice(const ArrayData& array, int64_t offset, int64_t length) final {\n+    // Visit the indices and insert the unpacked values.\n+    const auto& dict_ty = internal::checked_cast<const DictionaryType&>(*array.type);\n+    const typename TypeTraits<T>::ArrayType dict(array.dictionary);\n+    switch (dict_ty.index_type()->id()) {\n+      case Type::UINT8: {\n+        const uint8_t* values = array.GetValues<uint8_t>(1) + offset;\n+        return VisitBitBlocks(\n+            array.buffers[0], array.offset + offset, std::min(array.length, length),\n\nReview comment:\n       Other `AppendArraySlice` implementations don't check that `length` is in bounds, so `std::min` doesn't seem necessary here.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -1058,6 +1062,109 @@ void AddFSBinaryIfElseKernel(const std::shared_ptr<IfElseFunction>& scalar_funct\n   DCHECK_OK(scalar_function->AddKernel(std::move(kernel)));\n }\n \n+// Given a reference dictionary, computes indices to map dictionary values from a\n+// comparison dictionary to the reference.\n+class DictionaryRemapper {\n\nReview comment:\n       Don't we already have `DictionaryUnifier` for this? Or am I misunderstanding?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else_test.cc\n##########\n@@ -624,6 +624,250 @@ TYPED_TEST(TestCaseWhenNumeric, ListOfType) {\n               ArrayFromJSON(type, R\"([null, null, null, [6, null]])\"));\n }\n \n+template <typename Type>\n+class TestCaseWhenDict : public ::testing::Test {};\n+\n+struct JsonDict {\n+  std::shared_ptr<DataType> type;\n+  std::string value;\n+};\n+\n+TYPED_TEST_SUITE(TestCaseWhenDict, IntegralArrowTypes);\n+\n+TYPED_TEST(TestCaseWhenDict, Simple) {\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  for (const auto& dict :\n+       {JsonDict{utf8(), R\"([\"a\", null, \"bc\", \"def\"])\"},\n+        JsonDict{int64(), \"[1, null, 2, 3]\"},\n+        JsonDict{decimal256(3, 2), R\"([\"1.23\", null, \"3.45\", \"6.78\"])\"}}) {\n+    auto type = dictionary(default_type_instance<TypeParam>(), dict.type);\n+    auto values_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict.value);\n+    auto values1 = DictArrayFromJSON(type, \"[0, null, 3, 1]\", dict.value);\n+    auto values2 = DictArrayFromJSON(type, \"[2, 1, null, 0]\", dict.value);\n+\n+    // Easy case: all arguments have the same dictionary\n+    CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1, values2},\n+                DictArrayFromJSON(type, \"[0, null, null, null]\", dict.value));\n+    CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1, values2, values1},\n+                DictArrayFromJSON(type, \"[0, null, null, 1]\", dict.value));\n+    CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values_null, values2, values1},\n+                DictArrayFromJSON(type, \"[null, null, null, 1]\", dict.value));\n+  }\n+}\n+\n+TYPED_TEST(TestCaseWhenDict, Mixed) {\n+  auto type = dictionary(default_type_instance<TypeParam>(), utf8());\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  auto dict = R\"([\"a\", null, \"bc\", \"def\"])\";\n+  auto values_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict);\n+  auto values1_dict = DictArrayFromJSON(type, \"[0, null, 3, 1]\", dict);\n+  auto values1_decoded = ArrayFromJSON(utf8(), R\"([\"a\", null, \"def\", null])\");\n+  auto values2_dict = DictArrayFromJSON(type, \"[2, 1, null, 0]\", dict);\n+  auto values2_decoded = ArrayFromJSON(utf8(), R\"([\"bc\", null, null, \"a\"])\");\n+\n+  // If we have mixed dictionary/non-dictionary arguments, we decode dictionaries\n+  CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1_dict, values2_decoded},\n+              ArrayFromJSON(utf8(), R\"([\"a\", null, null, null])\"));\n+  CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1_decoded, values2_dict},\n+              ArrayFromJSON(utf8(), R\"([\"a\", null, null, null])\"));\n+  CheckScalar(\"case_when\",\n+              {MakeStruct({cond1, cond2}), values1_dict, values2_dict, values1_decoded},\n+              ArrayFromJSON(utf8(), R\"([\"a\", null, null, null])\"));\n+  CheckScalar(\"case_when\",\n+              {MakeStruct({cond1, cond2}), values_null, values2_dict, values1_decoded},\n+              ArrayFromJSON(utf8(), R\"([null, null, null, null])\"));\n+}\n+\n+TYPED_TEST(TestCaseWhenDict, NestedSimple) {\n+  auto make_list = [](const std::shared_ptr<Array>& indices,\n+                      const std::shared_ptr<Array>& backing_array) {\n+    EXPECT_OK_AND_ASSIGN(auto result, ListArray::FromArrays(*indices, *backing_array));\n+    return result;\n+  };\n+  auto index_type = default_type_instance<TypeParam>();\n+  auto inner_type = dictionary(index_type, utf8());\n+  auto type = list(inner_type);\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  auto dict = R\"([\"a\", \"b\", \"bc\", \"def\"])\";\n+  auto values_null = make_list(ArrayFromJSON(int32(), \"[null, null, null, null, 0]\"),\n+                               DictArrayFromJSON(inner_type, \"[]\", dict));\n+  auto values1_backing = DictArrayFromJSON(inner_type, \"[0, null, 3, 1]\", dict);\n+  auto values2_backing = DictArrayFromJSON(inner_type, \"[2, 1, null, 0]\", dict);\n+  auto values1 = make_list(ArrayFromJSON(int32(), \"[0, 2, 2, 3, 4]\"), values1_backing);\n+  auto values2 = make_list(ArrayFromJSON(int32(), \"[0, 1, 2, 2, 4]\"), values2_backing);\n+\n+  CheckScalarNonRecursive(\n+      \"case_when\", {MakeStruct({cond1, cond2}), values1, values2},\n+      make_list(ArrayFromJSON(int32(), \"[0, 2, 2, null, 2]\"),\n+                DictArrayFromJSON(inner_type, \"[0, null]\", R\"([\"a\"])\")));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({cond1, cond2}), values1,\n+       make_list(ArrayFromJSON(int32(), \"[0, 1, null, 2, 4]\"), values2_backing)},\n+      make_list(ArrayFromJSON(int32(), \"[0, 2, null, null, 2]\"),\n+                DictArrayFromJSON(inner_type, \"[0, null]\", R\"([\"a\"])\")));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({cond1, cond2}), values1,\n+       make_list(ArrayFromJSON(int32(), \"[0, 1, null, 2, 4]\"), values2_backing), values1},\n+      make_list(ArrayFromJSON(int32(), \"[0, 2, null, 2, 3]\"),\n+                DictArrayFromJSON(inner_type, \"[0, null, 1]\", R\"([\"a\", \"b\"])\")));\n+\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {\n+          Datum(MakeStruct({cond1, cond2})),\n+          Datum(std::make_shared<ListScalar>(\n+              DictArrayFromJSON(inner_type, \"[0, 1]\", dict))),\n+          Datum(std::make_shared<ListScalar>(\n+              DictArrayFromJSON(inner_type, \"[2, 3]\", dict))),\n+      },\n+      make_list(ArrayFromJSON(int32(), \"[0, 2, 4, null, 6]\"),\n+                DictArrayFromJSON(inner_type, \"[0, 1, 0, 1, 2, 3]\", dict)));\n+\n+  CheckScalarNonRecursive(\n+      \"case_when\", {MakeStruct({Datum(true), Datum(false)}), values1, values2}, values1);\n+  CheckScalarNonRecursive(\n+      \"case_when\", {MakeStruct({Datum(false), Datum(true)}), values1, values2}, values2);\n+  CheckScalarNonRecursive(\"case_when\", {MakeStruct({Datum(false)}), values1, values2},\n+                          values2);\n+  CheckScalarNonRecursive(\"case_when\",\n+                          {MakeStruct({Datum(false), Datum(false)}), values1, values2},\n+                          values_null);\n+}\n+\n+TYPED_TEST(TestCaseWhenDict, DifferentDictionaries) {\n+  auto type = dictionary(default_type_instance<TypeParam>(), utf8());\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  auto dict1 = R\"([\"a\", null, \"bc\", \"def\"])\";\n+  auto dict2 = R\"([\"bc\", \"foo\", null, \"a\"])\";\n+  auto dict3 = R\"([\"def\", \"a\", \"a\", \"bc\"])\";\n+  auto values1_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict1);\n+  auto values2_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict2);\n+  auto values1 = DictArrayFromJSON(type, \"[0, null, 3, 1]\", dict1);\n+  auto values2 = DictArrayFromJSON(type, \"[2, 1, null, 0]\", dict2);\n+  auto values3 = DictArrayFromJSON(type, \"[0, 1, 2, 3]\", dict3);\n+\n+  // For scalar conditions, we borrow the dictionary of the chosen output (or the first\n+  // input when outputting null)\n+  CheckScalar(\"case_when\", {MakeStruct({Datum(true), Datum(false)}), values1, values2},\n+              values1);\n+  CheckScalar(\"case_when\", {MakeStruct({Datum(false), Datum(true)}), values1, values2},\n+              values2);\n+  CheckScalar(\"case_when\", {MakeStruct({Datum(false), Datum(false)}), values1, values2},\n+              values1_null);\n+  CheckScalar(\"case_when\", {MakeStruct({Datum(false), Datum(false)}), values2, values1},\n+              values2_null);\n+\n+  // For array conditions, we always borrow the dictionary of the first input\n+  CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1, values2},\n+              DictArrayFromJSON(type, \"[0, null, null, null]\", dict1));\n+  CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1, values2, values1},\n+              DictArrayFromJSON(type, \"[0, null, null, 1]\", dict1));\n+\n+  // When mixing dictionaries, we try to map other dictionaries onto the first one\n+  // Don't check the scalar cases since we don't remap dictionaries in that case\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({ArrayFromJSON(boolean(), \"[true, true, false, false]\")}), values1,\n+       values2},\n+      DictArrayFromJSON(type, \"[0, null, null, 2]\", dict1));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({ArrayFromJSON(boolean(), \"[true, true, false, false]\"),\n+                   ArrayFromJSON(boolean(), \"[true, false, true, false]\")}),\n+       values1, values2},\n+      DictArrayFromJSON(type, \"[0, null, null, null]\", dict1));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({ArrayFromJSON(boolean(), \"[false, false, false, false]\"),\n+                   ArrayFromJSON(boolean(), \"[true, true, true, true]\")}),\n+       values1, values3},\n+      DictArrayFromJSON(type, \"[3, 0, 0, 2]\", dict1));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({ArrayFromJSON(boolean(), \"[null, null, null, true]\"),\n+                   ArrayFromJSON(boolean(), \"[true, true, true, true]\")}),\n+       values1, values3},\n+      DictArrayFromJSON(type, \"[3, 0, 0, 1]\", dict1));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {\n+          MakeStruct({ArrayFromJSON(boolean(), \"[true, true, false, false]\")}),\n+          DictScalarFromJSON(type, \"0\", dict1),\n+          DictScalarFromJSON(type, \"0\", dict2),\n+      },\n+      DictArrayFromJSON(type, \"[0, 0, 2, 2]\", dict1));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {\n+          MakeStruct({ArrayFromJSON(boolean(), \"[true, true, false, false]\"),\n+                      ArrayFromJSON(boolean(), \"[false, false, true, true]\")}),\n+          DictScalarFromJSON(type, \"0\", dict1),\n+          DictScalarFromJSON(type, \"0\", dict2),\n+      },\n+      DictArrayFromJSON(type, \"[0, 0, 2, 2]\", dict1));\n+\n+  // If we can't map values from a dictionary, then raise an error\n+  // Unmappable value is in the else clause\n\nReview comment:\n       I'm curious: why don't we unify dictionaries instead? It would sound more useful to me. I don't see any reason for the first input to have a particular status, is there?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else_test.cc\n##########\n@@ -624,6 +624,250 @@ TYPED_TEST(TestCaseWhenNumeric, ListOfType) {\n               ArrayFromJSON(type, R\"([null, null, null, [6, null]])\"));\n }\n \n+template <typename Type>\n+class TestCaseWhenDict : public ::testing::Test {};\n+\n+struct JsonDict {\n+  std::shared_ptr<DataType> type;\n+  std::string value;\n+};\n+\n+TYPED_TEST_SUITE(TestCaseWhenDict, IntegralArrowTypes);\n+\n+TYPED_TEST(TestCaseWhenDict, Simple) {\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  for (const auto& dict :\n+       {JsonDict{utf8(), R\"([\"a\", null, \"bc\", \"def\"])\"},\n+        JsonDict{int64(), \"[1, null, 2, 3]\"},\n+        JsonDict{decimal256(3, 2), R\"([\"1.23\", null, \"3.45\", \"6.78\"])\"}}) {\n+    auto type = dictionary(default_type_instance<TypeParam>(), dict.type);\n+    auto values_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict.value);\n+    auto values1 = DictArrayFromJSON(type, \"[0, null, 3, 1]\", dict.value);\n+    auto values2 = DictArrayFromJSON(type, \"[2, 1, null, 0]\", dict.value);\n+\n+    // Easy case: all arguments have the same dictionary\n+    CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1, values2},\n+                DictArrayFromJSON(type, \"[0, null, null, null]\", dict.value));\n+    CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1, values2, values1},\n+                DictArrayFromJSON(type, \"[0, null, null, 1]\", dict.value));\n+    CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values_null, values2, values1},\n+                DictArrayFromJSON(type, \"[null, null, null, 1]\", dict.value));\n+  }\n+}\n+\n+TYPED_TEST(TestCaseWhenDict, Mixed) {\n+  auto type = dictionary(default_type_instance<TypeParam>(), utf8());\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  auto dict = R\"([\"a\", null, \"bc\", \"def\"])\";\n+  auto values_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict);\n+  auto values1_dict = DictArrayFromJSON(type, \"[0, null, 3, 1]\", dict);\n+  auto values1_decoded = ArrayFromJSON(utf8(), R\"([\"a\", null, \"def\", null])\");\n+  auto values2_dict = DictArrayFromJSON(type, \"[2, 1, null, 0]\", dict);\n+  auto values2_decoded = ArrayFromJSON(utf8(), R\"([\"bc\", null, null, \"a\"])\");\n+\n+  // If we have mixed dictionary/non-dictionary arguments, we decode dictionaries\n+  CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1_dict, values2_decoded},\n+              ArrayFromJSON(utf8(), R\"([\"a\", null, null, null])\"));\n+  CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1_decoded, values2_dict},\n+              ArrayFromJSON(utf8(), R\"([\"a\", null, null, null])\"));\n+  CheckScalar(\"case_when\",\n+              {MakeStruct({cond1, cond2}), values1_dict, values2_dict, values1_decoded},\n+              ArrayFromJSON(utf8(), R\"([\"a\", null, null, null])\"));\n+  CheckScalar(\"case_when\",\n+              {MakeStruct({cond1, cond2}), values_null, values2_dict, values1_decoded},\n+              ArrayFromJSON(utf8(), R\"([null, null, null, null])\"));\n+}\n+\n+TYPED_TEST(TestCaseWhenDict, NestedSimple) {\n+  auto make_list = [](const std::shared_ptr<Array>& indices,\n+                      const std::shared_ptr<Array>& backing_array) {\n+    EXPECT_OK_AND_ASSIGN(auto result, ListArray::FromArrays(*indices, *backing_array));\n+    return result;\n+  };\n+  auto index_type = default_type_instance<TypeParam>();\n+  auto inner_type = dictionary(index_type, utf8());\n+  auto type = list(inner_type);\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  auto dict = R\"([\"a\", \"b\", \"bc\", \"def\"])\";\n+  auto values_null = make_list(ArrayFromJSON(int32(), \"[null, null, null, null, 0]\"),\n+                               DictArrayFromJSON(inner_type, \"[]\", dict));\n+  auto values1_backing = DictArrayFromJSON(inner_type, \"[0, null, 3, 1]\", dict);\n+  auto values2_backing = DictArrayFromJSON(inner_type, \"[2, 1, null, 0]\", dict);\n+  auto values1 = make_list(ArrayFromJSON(int32(), \"[0, 2, 2, 3, 4]\"), values1_backing);\n+  auto values2 = make_list(ArrayFromJSON(int32(), \"[0, 1, 2, 2, 4]\"), values2_backing);\n+\n+  CheckScalarNonRecursive(\n\nReview comment:\n       Why is this calling `CheckScalarNonRecursive` and not `CheckScalar`? Leave a comment?\n\n##########\nFile path: cpp/src/arrow/array/validate.cc\n##########\n@@ -568,6 +568,9 @@ struct ValidateArrayFullImpl {\n   }\n \n   Status Visit(const DictionaryType& type) {\n+    if (!data.dictionary) {\n+      return Status::Invalid(\"Dictionary array has no dictionary\");\n+    }\n\nReview comment:\n       Normally this is already checked in the top-level `ValidateArray`: https://github.com/apache/arrow/blob/a93ce9907c6f7ae70591b786f040d64e0f7d7109/cpp/src/arrow/array/validate.cc#L375-L382\n\n##########\nFile path: cpp/src/arrow/array/builder_dict.h\n##########\n@@ -282,6 +294,163 @@ class DictionaryBuilderBase : public ArrayBuilder {\n     return indices_builder_.AppendEmptyValues(length);\n   }\n \n+  Status AppendScalar(const Scalar& scalar, int64_t n_repeats) override {\n+    if (!scalar.type->Equals(type())) {\n+      return Status::Invalid(\"Cannot append scalar of type \", scalar.type->ToString(),\n+                             \" to builder for type \", type()->ToString());\n+    }\n+    if (!scalar.is_valid) return AppendNulls(n_repeats);\n+\n+    const auto& dict_ty = internal::checked_cast<const DictionaryType&>(*scalar.type);\n+    const DictionaryScalar& dict_scalar =\n+        internal::checked_cast<const DictionaryScalar&>(scalar);\n+    const auto& dict = internal::checked_cast<const typename TypeTraits<T>::ArrayType&>(\n+        *dict_scalar.value.dictionary);\n+    switch (dict_ty.index_type()->id()) {\n+      case Type::UINT8: {\n\nReview comment:\n       Perhaps try to factor this out as proposed below for `AppendScalar`.\n\n##########\nFile path: cpp/src/arrow/array/builder_dict.h\n##########\n@@ -282,6 +294,163 @@ class DictionaryBuilderBase : public ArrayBuilder {\n     return indices_builder_.AppendEmptyValues(length);\n   }\n \n+  Status AppendScalar(const Scalar& scalar, int64_t n_repeats) override {\n+    if (!scalar.type->Equals(type())) {\n+      return Status::Invalid(\"Cannot append scalar of type \", scalar.type->ToString(),\n+                             \" to builder for type \", type()->ToString());\n+    }\n+    if (!scalar.is_valid) return AppendNulls(n_repeats);\n+\n+    const auto& dict_ty = internal::checked_cast<const DictionaryType&>(*scalar.type);\n+    const DictionaryScalar& dict_scalar =\n+        internal::checked_cast<const DictionaryScalar&>(scalar);\n+    const auto& dict = internal::checked_cast<const typename TypeTraits<T>::ArrayType&>(\n+        *dict_scalar.value.dictionary);\n+    switch (dict_ty.index_type()->id()) {\n+      case Type::UINT8: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const UInt8Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::INT8: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const Int8Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::UINT16: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const UInt16Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::INT16: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const Int16Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::UINT32: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const UInt32Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::INT32: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const Int32Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::UINT64: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const UInt64Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::INT64: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const Int64Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      default:\n+        return Status::TypeError(\"Invalid index type: \", dict_ty);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status AppendScalars(const ScalarVector& scalars) override {\n+    for (const auto& scalar : scalars) {\n+      ARROW_RETURN_NOT_OK(AppendScalar(*scalar, /*n_repeats=*/1));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status AppendArraySlice(const ArrayData& array, int64_t offset, int64_t length) final {\n+    // Visit the indices and insert the unpacked values.\n+    const auto& dict_ty = internal::checked_cast<const DictionaryType&>(*array.type);\n+    const typename TypeTraits<T>::ArrayType dict(array.dictionary);\n+    switch (dict_ty.index_type()->id()) {\n\nReview comment:\n       Call `Reserve(length)` before this?\n\n##########\nFile path: cpp/src/arrow/array/builder_dict.h\n##########\n@@ -282,6 +294,163 @@ class DictionaryBuilderBase : public ArrayBuilder {\n     return indices_builder_.AppendEmptyValues(length);\n   }\n \n+  Status AppendScalar(const Scalar& scalar, int64_t n_repeats) override {\n+    if (!scalar.type->Equals(type())) {\n\nReview comment:\n       Do we really want to do this check every append or should this be left to callers?\n\n##########\nFile path: cpp/src/arrow/array/builder_dict.h\n##########\n@@ -282,6 +294,163 @@ class DictionaryBuilderBase : public ArrayBuilder {\n     return indices_builder_.AppendEmptyValues(length);\n   }\n \n+  Status AppendScalar(const Scalar& scalar, int64_t n_repeats) override {\n+    if (!scalar.type->Equals(type())) {\n+      return Status::Invalid(\"Cannot append scalar of type \", scalar.type->ToString(),\n+                             \" to builder for type \", type()->ToString());\n+    }\n+    if (!scalar.is_valid) return AppendNulls(n_repeats);\n+\n+    const auto& dict_ty = internal::checked_cast<const DictionaryType&>(*scalar.type);\n+    const DictionaryScalar& dict_scalar =\n+        internal::checked_cast<const DictionaryScalar&>(scalar);\n+    const auto& dict = internal::checked_cast<const typename TypeTraits<T>::ArrayType&>(\n+        *dict_scalar.value.dictionary);\n+    switch (dict_ty.index_type()->id()) {\n+      case Type::UINT8: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const UInt8Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::INT8: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const Int8Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::UINT16: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const UInt16Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::INT16: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const Int16Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::UINT32: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const UInt32Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::INT32: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const Int32Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::UINT64: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const UInt64Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      case Type::INT64: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const Int64Scalar&>(*dict_scalar.value.index).value);\n+        for (int64_t i = 0; i < n_repeats; i++) {\n+          ARROW_RETURN_NOT_OK(Append(value));\n+        }\n+        break;\n+      }\n+      default:\n+        return Status::TypeError(\"Invalid index type: \", dict_ty);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status AppendScalars(const ScalarVector& scalars) override {\n+    for (const auto& scalar : scalars) {\n+      ARROW_RETURN_NOT_OK(AppendScalar(*scalar, /*n_repeats=*/1));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status AppendArraySlice(const ArrayData& array, int64_t offset, int64_t length) final {\n+    // Visit the indices and insert the unpacked values.\n+    const auto& dict_ty = internal::checked_cast<const DictionaryType&>(*array.type);\n+    const typename TypeTraits<T>::ArrayType dict(array.dictionary);\n+    switch (dict_ty.index_type()->id()) {\n+      case Type::UINT8: {\n+        const uint8_t* values = array.GetValues<uint8_t>(1) + offset;\n+        return VisitBitBlocks(\n+            array.buffers[0], array.offset + offset, std::min(array.length, length),\n+            [&](int64_t position) { return Append(dict.GetView(values[position])); },\n+            [&]() { return AppendNull(); });\n+      }\n\nReview comment:\n       Is it possible to factor this out to avoid repetition? For example:\r\n   ```c++\r\n   template <IndexType>\r\n   struct SliceAppender {\r\n     const IndexType* values;\r\n   \r\n     Status operator()(const ArrayData& array, int64_t offset, int64_t length) {\r\n       return VisitBitBlocks(\r\n         array.buffers[0], array.offset + offset, length,\r\n         [&](int64_t position) {\r\n           if (dict.IsNull(values[position])) return AppendNull();\r\n           return Append(dict.GetView(values[position]));\r\n         },\r\n         [&]() { return AppendNull(); });  }\r\n       );\r\n     }\r\n   }\r\n   \r\n   case Type::UINT8:\r\n     return SliceAppender{array.GetValues<uint8_t>(1) + offset}(array, offset, length);\r\n   // ...\r\n   ```\r\n   \n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else_test.cc\n##########\n@@ -624,6 +624,250 @@ TYPED_TEST(TestCaseWhenNumeric, ListOfType) {\n               ArrayFromJSON(type, R\"([null, null, null, [6, null]])\"));\n }\n \n+template <typename Type>\n+class TestCaseWhenDict : public ::testing::Test {};\n+\n+struct JsonDict {\n+  std::shared_ptr<DataType> type;\n+  std::string value;\n+};\n+\n+TYPED_TEST_SUITE(TestCaseWhenDict, IntegralArrowTypes);\n+\n+TYPED_TEST(TestCaseWhenDict, Simple) {\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  for (const auto& dict :\n+       {JsonDict{utf8(), R\"([\"a\", null, \"bc\", \"def\"])\"},\n+        JsonDict{int64(), \"[1, null, 2, 3]\"},\n+        JsonDict{decimal256(3, 2), R\"([\"1.23\", null, \"3.45\", \"6.78\"])\"}}) {\n+    auto type = dictionary(default_type_instance<TypeParam>(), dict.type);\n+    auto values_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict.value);\n+    auto values1 = DictArrayFromJSON(type, \"[0, null, 3, 1]\", dict.value);\n+    auto values2 = DictArrayFromJSON(type, \"[2, 1, null, 0]\", dict.value);\n+\n+    // Easy case: all arguments have the same dictionary\n+    CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1, values2},\n+                DictArrayFromJSON(type, \"[0, null, null, null]\", dict.value));\n+    CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1, values2, values1},\n+                DictArrayFromJSON(type, \"[0, null, null, 1]\", dict.value));\n+    CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values_null, values2, values1},\n+                DictArrayFromJSON(type, \"[null, null, null, 1]\", dict.value));\n+  }\n+}\n+\n+TYPED_TEST(TestCaseWhenDict, Mixed) {\n+  auto type = dictionary(default_type_instance<TypeParam>(), utf8());\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  auto dict = R\"([\"a\", null, \"bc\", \"def\"])\";\n+  auto values_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict);\n+  auto values1_dict = DictArrayFromJSON(type, \"[0, null, 3, 1]\", dict);\n+  auto values1_decoded = ArrayFromJSON(utf8(), R\"([\"a\", null, \"def\", null])\");\n+  auto values2_dict = DictArrayFromJSON(type, \"[2, 1, null, 0]\", dict);\n+  auto values2_decoded = ArrayFromJSON(utf8(), R\"([\"bc\", null, null, \"a\"])\");\n+\n+  // If we have mixed dictionary/non-dictionary arguments, we decode dictionaries\n+  CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1_dict, values2_decoded},\n+              ArrayFromJSON(utf8(), R\"([\"a\", null, null, null])\"));\n+  CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1_decoded, values2_dict},\n+              ArrayFromJSON(utf8(), R\"([\"a\", null, null, null])\"));\n+  CheckScalar(\"case_when\",\n+              {MakeStruct({cond1, cond2}), values1_dict, values2_dict, values1_decoded},\n+              ArrayFromJSON(utf8(), R\"([\"a\", null, null, null])\"));\n+  CheckScalar(\"case_when\",\n+              {MakeStruct({cond1, cond2}), values_null, values2_dict, values1_decoded},\n+              ArrayFromJSON(utf8(), R\"([null, null, null, null])\"));\n+}\n+\n+TYPED_TEST(TestCaseWhenDict, NestedSimple) {\n+  auto make_list = [](const std::shared_ptr<Array>& indices,\n+                      const std::shared_ptr<Array>& backing_array) {\n+    EXPECT_OK_AND_ASSIGN(auto result, ListArray::FromArrays(*indices, *backing_array));\n+    return result;\n+  };\n+  auto index_type = default_type_instance<TypeParam>();\n+  auto inner_type = dictionary(index_type, utf8());\n+  auto type = list(inner_type);\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  auto dict = R\"([\"a\", \"b\", \"bc\", \"def\"])\";\n+  auto values_null = make_list(ArrayFromJSON(int32(), \"[null, null, null, null, 0]\"),\n+                               DictArrayFromJSON(inner_type, \"[]\", dict));\n+  auto values1_backing = DictArrayFromJSON(inner_type, \"[0, null, 3, 1]\", dict);\n+  auto values2_backing = DictArrayFromJSON(inner_type, \"[2, 1, null, 0]\", dict);\n+  auto values1 = make_list(ArrayFromJSON(int32(), \"[0, 2, 2, 3, 4]\"), values1_backing);\n+  auto values2 = make_list(ArrayFromJSON(int32(), \"[0, 1, 2, 2, 4]\"), values2_backing);\n+\n+  CheckScalarNonRecursive(\n+      \"case_when\", {MakeStruct({cond1, cond2}), values1, values2},\n+      make_list(ArrayFromJSON(int32(), \"[0, 2, 2, null, 2]\"),\n+                DictArrayFromJSON(inner_type, \"[0, null]\", R\"([\"a\"])\")));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({cond1, cond2}), values1,\n+       make_list(ArrayFromJSON(int32(), \"[0, 1, null, 2, 4]\"), values2_backing)},\n+      make_list(ArrayFromJSON(int32(), \"[0, 2, null, null, 2]\"),\n+                DictArrayFromJSON(inner_type, \"[0, null]\", R\"([\"a\"])\")));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({cond1, cond2}), values1,\n+       make_list(ArrayFromJSON(int32(), \"[0, 1, null, 2, 4]\"), values2_backing), values1},\n+      make_list(ArrayFromJSON(int32(), \"[0, 2, null, 2, 3]\"),\n+                DictArrayFromJSON(inner_type, \"[0, null, 1]\", R\"([\"a\", \"b\"])\")));\n+\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {\n+          Datum(MakeStruct({cond1, cond2})),\n+          Datum(std::make_shared<ListScalar>(\n+              DictArrayFromJSON(inner_type, \"[0, 1]\", dict))),\n+          Datum(std::make_shared<ListScalar>(\n+              DictArrayFromJSON(inner_type, \"[2, 3]\", dict))),\n+      },\n+      make_list(ArrayFromJSON(int32(), \"[0, 2, 4, null, 6]\"),\n+                DictArrayFromJSON(inner_type, \"[0, 1, 0, 1, 2, 3]\", dict)));\n+\n+  CheckScalarNonRecursive(\n+      \"case_when\", {MakeStruct({Datum(true), Datum(false)}), values1, values2}, values1);\n+  CheckScalarNonRecursive(\n+      \"case_when\", {MakeStruct({Datum(false), Datum(true)}), values1, values2}, values2);\n+  CheckScalarNonRecursive(\"case_when\", {MakeStruct({Datum(false)}), values1, values2},\n+                          values2);\n+  CheckScalarNonRecursive(\"case_when\",\n+                          {MakeStruct({Datum(false), Datum(false)}), values1, values2},\n+                          values_null);\n+}\n+\n+TYPED_TEST(TestCaseWhenDict, DifferentDictionaries) {\n+  auto type = dictionary(default_type_instance<TypeParam>(), utf8());\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  auto dict1 = R\"([\"a\", null, \"bc\", \"def\"])\";\n+  auto dict2 = R\"([\"bc\", \"foo\", null, \"a\"])\";\n+  auto dict3 = R\"([\"def\", \"a\", \"a\", \"bc\"])\";\n+  auto values1_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict1);\n+  auto values2_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict2);\n+  auto values1 = DictArrayFromJSON(type, \"[0, null, 3, 1]\", dict1);\n+  auto values2 = DictArrayFromJSON(type, \"[2, 1, null, 0]\", dict2);\n\nReview comment:\n       For some reason, it looks like the nulls in the indices are placed at the same indices as the nulls in the respective dictionaries.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else_test.cc\n##########\n@@ -624,6 +624,250 @@ TYPED_TEST(TestCaseWhenNumeric, ListOfType) {\n               ArrayFromJSON(type, R\"([null, null, null, [6, null]])\"));\n }\n \n+template <typename Type>\n+class TestCaseWhenDict : public ::testing::Test {};\n+\n+struct JsonDict {\n+  std::shared_ptr<DataType> type;\n+  std::string value;\n+};\n+\n+TYPED_TEST_SUITE(TestCaseWhenDict, IntegralArrowTypes);\n+\n+TYPED_TEST(TestCaseWhenDict, Simple) {\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  for (const auto& dict :\n+       {JsonDict{utf8(), R\"([\"a\", null, \"bc\", \"def\"])\"},\n+        JsonDict{int64(), \"[1, null, 2, 3]\"},\n+        JsonDict{decimal256(3, 2), R\"([\"1.23\", null, \"3.45\", \"6.78\"])\"}}) {\n+    auto type = dictionary(default_type_instance<TypeParam>(), dict.type);\n+    auto values_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict.value);\n+    auto values1 = DictArrayFromJSON(type, \"[0, null, 3, 1]\", dict.value);\n+    auto values2 = DictArrayFromJSON(type, \"[2, 1, null, 0]\", dict.value);\n+\n+    // Easy case: all arguments have the same dictionary\n+    CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1, values2},\n+                DictArrayFromJSON(type, \"[0, null, null, null]\", dict.value));\n+    CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1, values2, values1},\n+                DictArrayFromJSON(type, \"[0, null, null, 1]\", dict.value));\n+    CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values_null, values2, values1},\n+                DictArrayFromJSON(type, \"[null, null, null, 1]\", dict.value));\n+  }\n+}\n+\n+TYPED_TEST(TestCaseWhenDict, Mixed) {\n+  auto type = dictionary(default_type_instance<TypeParam>(), utf8());\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  auto dict = R\"([\"a\", null, \"bc\", \"def\"])\";\n+  auto values_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict);\n+  auto values1_dict = DictArrayFromJSON(type, \"[0, null, 3, 1]\", dict);\n+  auto values1_decoded = ArrayFromJSON(utf8(), R\"([\"a\", null, \"def\", null])\");\n+  auto values2_dict = DictArrayFromJSON(type, \"[2, 1, null, 0]\", dict);\n+  auto values2_decoded = ArrayFromJSON(utf8(), R\"([\"bc\", null, null, \"a\"])\");\n+\n+  // If we have mixed dictionary/non-dictionary arguments, we decode dictionaries\n+  CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1_dict, values2_decoded},\n+              ArrayFromJSON(utf8(), R\"([\"a\", null, null, null])\"));\n+  CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1_decoded, values2_dict},\n+              ArrayFromJSON(utf8(), R\"([\"a\", null, null, null])\"));\n+  CheckScalar(\"case_when\",\n+              {MakeStruct({cond1, cond2}), values1_dict, values2_dict, values1_decoded},\n+              ArrayFromJSON(utf8(), R\"([\"a\", null, null, null])\"));\n+  CheckScalar(\"case_when\",\n+              {MakeStruct({cond1, cond2}), values_null, values2_dict, values1_decoded},\n+              ArrayFromJSON(utf8(), R\"([null, null, null, null])\"));\n+}\n+\n+TYPED_TEST(TestCaseWhenDict, NestedSimple) {\n+  auto make_list = [](const std::shared_ptr<Array>& indices,\n+                      const std::shared_ptr<Array>& backing_array) {\n+    EXPECT_OK_AND_ASSIGN(auto result, ListArray::FromArrays(*indices, *backing_array));\n+    return result;\n+  };\n+  auto index_type = default_type_instance<TypeParam>();\n+  auto inner_type = dictionary(index_type, utf8());\n+  auto type = list(inner_type);\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  auto dict = R\"([\"a\", \"b\", \"bc\", \"def\"])\";\n+  auto values_null = make_list(ArrayFromJSON(int32(), \"[null, null, null, null, 0]\"),\n+                               DictArrayFromJSON(inner_type, \"[]\", dict));\n+  auto values1_backing = DictArrayFromJSON(inner_type, \"[0, null, 3, 1]\", dict);\n+  auto values2_backing = DictArrayFromJSON(inner_type, \"[2, 1, null, 0]\", dict);\n+  auto values1 = make_list(ArrayFromJSON(int32(), \"[0, 2, 2, 3, 4]\"), values1_backing);\n+  auto values2 = make_list(ArrayFromJSON(int32(), \"[0, 1, 2, 2, 4]\"), values2_backing);\n+\n+  CheckScalarNonRecursive(\n+      \"case_when\", {MakeStruct({cond1, cond2}), values1, values2},\n+      make_list(ArrayFromJSON(int32(), \"[0, 2, 2, null, 2]\"),\n+                DictArrayFromJSON(inner_type, \"[0, null]\", R\"([\"a\"])\")));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({cond1, cond2}), values1,\n+       make_list(ArrayFromJSON(int32(), \"[0, 1, null, 2, 4]\"), values2_backing)},\n+      make_list(ArrayFromJSON(int32(), \"[0, 2, null, null, 2]\"),\n+                DictArrayFromJSON(inner_type, \"[0, null]\", R\"([\"a\"])\")));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({cond1, cond2}), values1,\n+       make_list(ArrayFromJSON(int32(), \"[0, 1, null, 2, 4]\"), values2_backing), values1},\n+      make_list(ArrayFromJSON(int32(), \"[0, 2, null, 2, 3]\"),\n+                DictArrayFromJSON(inner_type, \"[0, null, 1]\", R\"([\"a\", \"b\"])\")));\n+\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {\n+          Datum(MakeStruct({cond1, cond2})),\n+          Datum(std::make_shared<ListScalar>(\n+              DictArrayFromJSON(inner_type, \"[0, 1]\", dict))),\n+          Datum(std::make_shared<ListScalar>(\n+              DictArrayFromJSON(inner_type, \"[2, 3]\", dict))),\n+      },\n+      make_list(ArrayFromJSON(int32(), \"[0, 2, 4, null, 6]\"),\n+                DictArrayFromJSON(inner_type, \"[0, 1, 0, 1, 2, 3]\", dict)));\n+\n+  CheckScalarNonRecursive(\n+      \"case_when\", {MakeStruct({Datum(true), Datum(false)}), values1, values2}, values1);\n+  CheckScalarNonRecursive(\n+      \"case_when\", {MakeStruct({Datum(false), Datum(true)}), values1, values2}, values2);\n+  CheckScalarNonRecursive(\"case_when\", {MakeStruct({Datum(false)}), values1, values2},\n+                          values2);\n+  CheckScalarNonRecursive(\"case_when\",\n+                          {MakeStruct({Datum(false), Datum(false)}), values1, values2},\n+                          values_null);\n+}\n+\n+TYPED_TEST(TestCaseWhenDict, DifferentDictionaries) {\n+  auto type = dictionary(default_type_instance<TypeParam>(), utf8());\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  auto dict1 = R\"([\"a\", null, \"bc\", \"def\"])\";\n+  auto dict2 = R\"([\"bc\", \"foo\", null, \"a\"])\";\n+  auto dict3 = R\"([\"def\", \"a\", \"a\", \"bc\"])\";\n+  auto values1_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict1);\n+  auto values2_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict2);\n+  auto values1 = DictArrayFromJSON(type, \"[0, null, 3, 1]\", dict1);\n+  auto values2 = DictArrayFromJSON(type, \"[2, 1, null, 0]\", dict2);\n+  auto values3 = DictArrayFromJSON(type, \"[0, 1, 2, 3]\", dict3);\n+\n+  // For scalar conditions, we borrow the dictionary of the chosen output (or the first\n+  // input when outputting null)\n+  CheckScalar(\"case_when\", {MakeStruct({Datum(true), Datum(false)}), values1, values2},\n+              values1);\n+  CheckScalar(\"case_when\", {MakeStruct({Datum(false), Datum(true)}), values1, values2},\n+              values2);\n+  CheckScalar(\"case_when\", {MakeStruct({Datum(false), Datum(false)}), values1, values2},\n+              values1_null);\n+  CheckScalar(\"case_when\", {MakeStruct({Datum(false), Datum(false)}), values2, values1},\n+              values2_null);\n+\n+  // For array conditions, we always borrow the dictionary of the first input\n+  CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1, values2},\n+              DictArrayFromJSON(type, \"[0, null, null, null]\", dict1));\n+  CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1, values2, values1},\n+              DictArrayFromJSON(type, \"[0, null, null, 1]\", dict1));\n+\n+  // When mixing dictionaries, we try to map other dictionaries onto the first one\n+  // Don't check the scalar cases since we don't remap dictionaries in that case\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({ArrayFromJSON(boolean(), \"[true, true, false, false]\")}), values1,\n+       values2},\n+      DictArrayFromJSON(type, \"[0, null, null, 2]\", dict1));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({ArrayFromJSON(boolean(), \"[true, true, false, false]\"),\n+                   ArrayFromJSON(boolean(), \"[true, false, true, false]\")}),\n+       values1, values2},\n+      DictArrayFromJSON(type, \"[0, null, null, null]\", dict1));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({ArrayFromJSON(boolean(), \"[false, false, false, false]\"),\n+                   ArrayFromJSON(boolean(), \"[true, true, true, true]\")}),\n+       values1, values3},\n+      DictArrayFromJSON(type, \"[3, 0, 0, 2]\", dict1));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({ArrayFromJSON(boolean(), \"[null, null, null, true]\"),\n+                   ArrayFromJSON(boolean(), \"[true, true, true, true]\")}),\n+       values1, values3},\n+      DictArrayFromJSON(type, \"[3, 0, 0, 1]\", dict1));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {\n+          MakeStruct({ArrayFromJSON(boolean(), \"[true, true, false, false]\")}),\n+          DictScalarFromJSON(type, \"0\", dict1),\n+          DictScalarFromJSON(type, \"0\", dict2),\n+      },\n+      DictArrayFromJSON(type, \"[0, 0, 2, 2]\", dict1));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {\n+          MakeStruct({ArrayFromJSON(boolean(), \"[true, true, false, false]\"),\n+                      ArrayFromJSON(boolean(), \"[false, false, true, true]\")}),\n+          DictScalarFromJSON(type, \"0\", dict1),\n+          DictScalarFromJSON(type, \"0\", dict2),\n+      },\n+      DictArrayFromJSON(type, \"[0, 0, 2, 2]\", dict1));\n+\n+  // If we can't map values from a dictionary, then raise an error\n+  // Unmappable value is in the else clause\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid,\n+      ::testing::HasSubstr(\n+          \"Cannot map dictionary index 1 at position 1 to the common dictionary\"),\n+      CallFunction(\n+          \"case_when\",\n+          {MakeStruct({ArrayFromJSON(boolean(), \"[false, false, false, false]\")}),\n+           values1, values2}));\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid,\n+      ::testing::HasSubstr(\"Cannot map dictionary index 1 to the common dictionary\"),\n+      CallFunction(\n+          \"case_when\",\n+          {MakeStruct({ArrayFromJSON(boolean(), \"[false, false, false, false]\")}),\n+           values1, DictScalarFromJSON(type, \"1\", dict2)}));\n+  // Unmappable value is in a branch (test multiple times to ensure coverage of branches\n+  // in impl)\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid,\n+      ::testing::HasSubstr(\n+          \"Cannot map dictionary index 1 at position 1 to the common dictionary\"),\n+      CallFunction(\"case_when\",\n+                   {MakeStruct({Datum(false),\n+                                ArrayFromJSON(boolean(), \"[true, true, true, true]\")}),\n+                    values1, values2}));\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid,\n+      ::testing::HasSubstr(\n+          \"Cannot map dictionary index 1 at position 1 to the common dictionary\"),\n+      CallFunction(\"case_when\",\n+                   {MakeStruct({Datum(false),\n+                                ArrayFromJSON(boolean(), \"[false, true, false, false]\")}),\n+                    values1, values2}));\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid,\n+      ::testing::HasSubstr(\n+          \"Cannot map dictionary index 1 at position 1 to the common dictionary\"),\n+      CallFunction(\"case_when\",\n+                   {MakeStruct({Datum(false),\n+                                ArrayFromJSON(boolean(), \"[null, true, null, null]\")}),\n+                    values1, values2}));\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid,\n+      ::testing::HasSubstr(\"Cannot map dictionary index 1 to the common dictionary\"),\n+      CallFunction(\"case_when\",\n+                   {MakeStruct({Datum(false),\n+                                ArrayFromJSON(boolean(), \"[true, true, true, null]\")}),\n+                    values1, DictScalarFromJSON(type, \"1\", dict2)}));\n+\n+  // ...or optionally, emit null\n+\n+  // TODO: this is not implemented yet\n\nReview comment:\n       I'm not sure I understand what this TODO is for. Emitting a null when some option is enabled?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-06T14:59:40.645+0000",
                    "updated": "2021-09-06T14:59:40.645+0000",
                    "started": "2021-09-06T14:59:40.644+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "647023",
                    "issueId": "13393729"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/647064",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022#discussion_r703002257\n\n\n\n##########\nFile path: cpp/src/arrow/array/builder_dict.h\n##########\n@@ -282,6 +294,163 @@ class DictionaryBuilderBase : public ArrayBuilder {\n     return indices_builder_.AppendEmptyValues(length);\n   }\n \n+  Status AppendScalar(const Scalar& scalar, int64_t n_repeats) override {\n+    if (!scalar.type->Equals(type())) {\n+      return Status::Invalid(\"Cannot append scalar of type \", scalar.type->ToString(),\n+                             \" to builder for type \", type()->ToString());\n+    }\n+    if (!scalar.is_valid) return AppendNulls(n_repeats);\n+\n+    const auto& dict_ty = internal::checked_cast<const DictionaryType&>(*scalar.type);\n+    const DictionaryScalar& dict_scalar =\n+        internal::checked_cast<const DictionaryScalar&>(scalar);\n+    const auto& dict = internal::checked_cast<const typename TypeTraits<T>::ArrayType&>(\n+        *dict_scalar.value.dictionary);\n+    switch (dict_ty.index_type()->id()) {\n+      case Type::UINT8: {\n+        const auto& value = dict.GetView(\n+            internal::checked_cast<const UInt8Scalar&>(*dict_scalar.value.index).value);\n\nReview comment:\n       Hmm, there should be better testing for nulls in general, I'll amend that.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-06T16:27:37.210+0000",
                    "updated": "2021-09-06T16:27:37.210+0000",
                    "started": "2021-09-06T16:27:37.209+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "647064",
                    "issueId": "13393729"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/647065",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022#discussion_r703002476\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else_test.cc\n##########\n@@ -624,6 +624,250 @@ TYPED_TEST(TestCaseWhenNumeric, ListOfType) {\n               ArrayFromJSON(type, R\"([null, null, null, [6, null]])\"));\n }\n \n+template <typename Type>\n+class TestCaseWhenDict : public ::testing::Test {};\n+\n+struct JsonDict {\n+  std::shared_ptr<DataType> type;\n+  std::string value;\n+};\n+\n+TYPED_TEST_SUITE(TestCaseWhenDict, IntegralArrowTypes);\n+\n+TYPED_TEST(TestCaseWhenDict, Simple) {\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  for (const auto& dict :\n+       {JsonDict{utf8(), R\"([\"a\", null, \"bc\", \"def\"])\"},\n+        JsonDict{int64(), \"[1, null, 2, 3]\"},\n+        JsonDict{decimal256(3, 2), R\"([\"1.23\", null, \"3.45\", \"6.78\"])\"}}) {\n+    auto type = dictionary(default_type_instance<TypeParam>(), dict.type);\n+    auto values_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict.value);\n+    auto values1 = DictArrayFromJSON(type, \"[0, null, 3, 1]\", dict.value);\n+    auto values2 = DictArrayFromJSON(type, \"[2, 1, null, 0]\", dict.value);\n+\n+    // Easy case: all arguments have the same dictionary\n+    CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1, values2},\n+                DictArrayFromJSON(type, \"[0, null, null, null]\", dict.value));\n+    CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1, values2, values1},\n+                DictArrayFromJSON(type, \"[0, null, null, 1]\", dict.value));\n+    CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values_null, values2, values1},\n+                DictArrayFromJSON(type, \"[null, null, null, 1]\", dict.value));\n+  }\n+}\n+\n+TYPED_TEST(TestCaseWhenDict, Mixed) {\n+  auto type = dictionary(default_type_instance<TypeParam>(), utf8());\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  auto dict = R\"([\"a\", null, \"bc\", \"def\"])\";\n+  auto values_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict);\n+  auto values1_dict = DictArrayFromJSON(type, \"[0, null, 3, 1]\", dict);\n+  auto values1_decoded = ArrayFromJSON(utf8(), R\"([\"a\", null, \"def\", null])\");\n+  auto values2_dict = DictArrayFromJSON(type, \"[2, 1, null, 0]\", dict);\n+  auto values2_decoded = ArrayFromJSON(utf8(), R\"([\"bc\", null, null, \"a\"])\");\n+\n+  // If we have mixed dictionary/non-dictionary arguments, we decode dictionaries\n+  CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1_dict, values2_decoded},\n+              ArrayFromJSON(utf8(), R\"([\"a\", null, null, null])\"));\n+  CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1_decoded, values2_dict},\n+              ArrayFromJSON(utf8(), R\"([\"a\", null, null, null])\"));\n+  CheckScalar(\"case_when\",\n+              {MakeStruct({cond1, cond2}), values1_dict, values2_dict, values1_decoded},\n+              ArrayFromJSON(utf8(), R\"([\"a\", null, null, null])\"));\n+  CheckScalar(\"case_when\",\n+              {MakeStruct({cond1, cond2}), values_null, values2_dict, values1_decoded},\n+              ArrayFromJSON(utf8(), R\"([null, null, null, null])\"));\n+}\n+\n+TYPED_TEST(TestCaseWhenDict, NestedSimple) {\n+  auto make_list = [](const std::shared_ptr<Array>& indices,\n+                      const std::shared_ptr<Array>& backing_array) {\n+    EXPECT_OK_AND_ASSIGN(auto result, ListArray::FromArrays(*indices, *backing_array));\n+    return result;\n+  };\n+  auto index_type = default_type_instance<TypeParam>();\n+  auto inner_type = dictionary(index_type, utf8());\n+  auto type = list(inner_type);\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  auto dict = R\"([\"a\", \"b\", \"bc\", \"def\"])\";\n+  auto values_null = make_list(ArrayFromJSON(int32(), \"[null, null, null, null, 0]\"),\n+                               DictArrayFromJSON(inner_type, \"[]\", dict));\n+  auto values1_backing = DictArrayFromJSON(inner_type, \"[0, null, 3, 1]\", dict);\n+  auto values2_backing = DictArrayFromJSON(inner_type, \"[2, 1, null, 0]\", dict);\n+  auto values1 = make_list(ArrayFromJSON(int32(), \"[0, 2, 2, 3, 4]\"), values1_backing);\n+  auto values2 = make_list(ArrayFromJSON(int32(), \"[0, 1, 2, 2, 4]\"), values2_backing);\n+\n+  CheckScalarNonRecursive(\n\nReview comment:\n       The scalar variant of the kernel will not produce the same dictionary indices so the values do not compare equal. I'll add a comment to that effect.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-06T16:28:22.689+0000",
                    "updated": "2021-09-06T16:28:22.689+0000",
                    "started": "2021-09-06T16:28:22.689+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "647065",
                    "issueId": "13393729"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/647068",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022#discussion_r703002719\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else_test.cc\n##########\n@@ -624,6 +624,250 @@ TYPED_TEST(TestCaseWhenNumeric, ListOfType) {\n               ArrayFromJSON(type, R\"([null, null, null, [6, null]])\"));\n }\n \n+template <typename Type>\n+class TestCaseWhenDict : public ::testing::Test {};\n+\n+struct JsonDict {\n+  std::shared_ptr<DataType> type;\n+  std::string value;\n+};\n+\n+TYPED_TEST_SUITE(TestCaseWhenDict, IntegralArrowTypes);\n+\n+TYPED_TEST(TestCaseWhenDict, Simple) {\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  for (const auto& dict :\n+       {JsonDict{utf8(), R\"([\"a\", null, \"bc\", \"def\"])\"},\n+        JsonDict{int64(), \"[1, null, 2, 3]\"},\n+        JsonDict{decimal256(3, 2), R\"([\"1.23\", null, \"3.45\", \"6.78\"])\"}}) {\n+    auto type = dictionary(default_type_instance<TypeParam>(), dict.type);\n+    auto values_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict.value);\n+    auto values1 = DictArrayFromJSON(type, \"[0, null, 3, 1]\", dict.value);\n+    auto values2 = DictArrayFromJSON(type, \"[2, 1, null, 0]\", dict.value);\n+\n+    // Easy case: all arguments have the same dictionary\n+    CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1, values2},\n+                DictArrayFromJSON(type, \"[0, null, null, null]\", dict.value));\n+    CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1, values2, values1},\n+                DictArrayFromJSON(type, \"[0, null, null, 1]\", dict.value));\n+    CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values_null, values2, values1},\n+                DictArrayFromJSON(type, \"[null, null, null, 1]\", dict.value));\n+  }\n+}\n+\n+TYPED_TEST(TestCaseWhenDict, Mixed) {\n+  auto type = dictionary(default_type_instance<TypeParam>(), utf8());\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  auto dict = R\"([\"a\", null, \"bc\", \"def\"])\";\n+  auto values_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict);\n+  auto values1_dict = DictArrayFromJSON(type, \"[0, null, 3, 1]\", dict);\n+  auto values1_decoded = ArrayFromJSON(utf8(), R\"([\"a\", null, \"def\", null])\");\n+  auto values2_dict = DictArrayFromJSON(type, \"[2, 1, null, 0]\", dict);\n+  auto values2_decoded = ArrayFromJSON(utf8(), R\"([\"bc\", null, null, \"a\"])\");\n+\n+  // If we have mixed dictionary/non-dictionary arguments, we decode dictionaries\n+  CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1_dict, values2_decoded},\n+              ArrayFromJSON(utf8(), R\"([\"a\", null, null, null])\"));\n+  CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1_decoded, values2_dict},\n+              ArrayFromJSON(utf8(), R\"([\"a\", null, null, null])\"));\n+  CheckScalar(\"case_when\",\n+              {MakeStruct({cond1, cond2}), values1_dict, values2_dict, values1_decoded},\n+              ArrayFromJSON(utf8(), R\"([\"a\", null, null, null])\"));\n+  CheckScalar(\"case_when\",\n+              {MakeStruct({cond1, cond2}), values_null, values2_dict, values1_decoded},\n+              ArrayFromJSON(utf8(), R\"([null, null, null, null])\"));\n+}\n+\n+TYPED_TEST(TestCaseWhenDict, NestedSimple) {\n+  auto make_list = [](const std::shared_ptr<Array>& indices,\n+                      const std::shared_ptr<Array>& backing_array) {\n+    EXPECT_OK_AND_ASSIGN(auto result, ListArray::FromArrays(*indices, *backing_array));\n+    return result;\n+  };\n+  auto index_type = default_type_instance<TypeParam>();\n+  auto inner_type = dictionary(index_type, utf8());\n+  auto type = list(inner_type);\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  auto dict = R\"([\"a\", \"b\", \"bc\", \"def\"])\";\n+  auto values_null = make_list(ArrayFromJSON(int32(), \"[null, null, null, null, 0]\"),\n+                               DictArrayFromJSON(inner_type, \"[]\", dict));\n+  auto values1_backing = DictArrayFromJSON(inner_type, \"[0, null, 3, 1]\", dict);\n+  auto values2_backing = DictArrayFromJSON(inner_type, \"[2, 1, null, 0]\", dict);\n+  auto values1 = make_list(ArrayFromJSON(int32(), \"[0, 2, 2, 3, 4]\"), values1_backing);\n+  auto values2 = make_list(ArrayFromJSON(int32(), \"[0, 1, 2, 2, 4]\"), values2_backing);\n+\n+  CheckScalarNonRecursive(\n+      \"case_when\", {MakeStruct({cond1, cond2}), values1, values2},\n+      make_list(ArrayFromJSON(int32(), \"[0, 2, 2, null, 2]\"),\n+                DictArrayFromJSON(inner_type, \"[0, null]\", R\"([\"a\"])\")));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({cond1, cond2}), values1,\n+       make_list(ArrayFromJSON(int32(), \"[0, 1, null, 2, 4]\"), values2_backing)},\n+      make_list(ArrayFromJSON(int32(), \"[0, 2, null, null, 2]\"),\n+                DictArrayFromJSON(inner_type, \"[0, null]\", R\"([\"a\"])\")));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({cond1, cond2}), values1,\n+       make_list(ArrayFromJSON(int32(), \"[0, 1, null, 2, 4]\"), values2_backing), values1},\n+      make_list(ArrayFromJSON(int32(), \"[0, 2, null, 2, 3]\"),\n+                DictArrayFromJSON(inner_type, \"[0, null, 1]\", R\"([\"a\", \"b\"])\")));\n+\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {\n+          Datum(MakeStruct({cond1, cond2})),\n+          Datum(std::make_shared<ListScalar>(\n+              DictArrayFromJSON(inner_type, \"[0, 1]\", dict))),\n+          Datum(std::make_shared<ListScalar>(\n+              DictArrayFromJSON(inner_type, \"[2, 3]\", dict))),\n+      },\n+      make_list(ArrayFromJSON(int32(), \"[0, 2, 4, null, 6]\"),\n+                DictArrayFromJSON(inner_type, \"[0, 1, 0, 1, 2, 3]\", dict)));\n+\n+  CheckScalarNonRecursive(\n+      \"case_when\", {MakeStruct({Datum(true), Datum(false)}), values1, values2}, values1);\n+  CheckScalarNonRecursive(\n+      \"case_when\", {MakeStruct({Datum(false), Datum(true)}), values1, values2}, values2);\n+  CheckScalarNonRecursive(\"case_when\", {MakeStruct({Datum(false)}), values1, values2},\n+                          values2);\n+  CheckScalarNonRecursive(\"case_when\",\n+                          {MakeStruct({Datum(false), Datum(false)}), values1, values2},\n+                          values_null);\n+}\n+\n+TYPED_TEST(TestCaseWhenDict, DifferentDictionaries) {\n+  auto type = dictionary(default_type_instance<TypeParam>(), utf8());\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, true, null, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, true, null]\");\n+  auto dict1 = R\"([\"a\", null, \"bc\", \"def\"])\";\n+  auto dict2 = R\"([\"bc\", \"foo\", null, \"a\"])\";\n+  auto dict3 = R\"([\"def\", \"a\", \"a\", \"bc\"])\";\n+  auto values1_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict1);\n+  auto values2_null = DictArrayFromJSON(type, \"[null, null, null, null]\", dict2);\n+  auto values1 = DictArrayFromJSON(type, \"[0, null, 3, 1]\", dict1);\n+  auto values2 = DictArrayFromJSON(type, \"[2, 1, null, 0]\", dict2);\n+  auto values3 = DictArrayFromJSON(type, \"[0, 1, 2, 3]\", dict3);\n+\n+  // For scalar conditions, we borrow the dictionary of the chosen output (or the first\n+  // input when outputting null)\n+  CheckScalar(\"case_when\", {MakeStruct({Datum(true), Datum(false)}), values1, values2},\n+              values1);\n+  CheckScalar(\"case_when\", {MakeStruct({Datum(false), Datum(true)}), values1, values2},\n+              values2);\n+  CheckScalar(\"case_when\", {MakeStruct({Datum(false), Datum(false)}), values1, values2},\n+              values1_null);\n+  CheckScalar(\"case_when\", {MakeStruct({Datum(false), Datum(false)}), values2, values1},\n+              values2_null);\n+\n+  // For array conditions, we always borrow the dictionary of the first input\n+  CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1, values2},\n+              DictArrayFromJSON(type, \"[0, null, null, null]\", dict1));\n+  CheckScalar(\"case_when\", {MakeStruct({cond1, cond2}), values1, values2, values1},\n+              DictArrayFromJSON(type, \"[0, null, null, 1]\", dict1));\n+\n+  // When mixing dictionaries, we try to map other dictionaries onto the first one\n+  // Don't check the scalar cases since we don't remap dictionaries in that case\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({ArrayFromJSON(boolean(), \"[true, true, false, false]\")}), values1,\n+       values2},\n+      DictArrayFromJSON(type, \"[0, null, null, 2]\", dict1));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({ArrayFromJSON(boolean(), \"[true, true, false, false]\"),\n+                   ArrayFromJSON(boolean(), \"[true, false, true, false]\")}),\n+       values1, values2},\n+      DictArrayFromJSON(type, \"[0, null, null, null]\", dict1));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({ArrayFromJSON(boolean(), \"[false, false, false, false]\"),\n+                   ArrayFromJSON(boolean(), \"[true, true, true, true]\")}),\n+       values1, values3},\n+      DictArrayFromJSON(type, \"[3, 0, 0, 2]\", dict1));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {MakeStruct({ArrayFromJSON(boolean(), \"[null, null, null, true]\"),\n+                   ArrayFromJSON(boolean(), \"[true, true, true, true]\")}),\n+       values1, values3},\n+      DictArrayFromJSON(type, \"[3, 0, 0, 1]\", dict1));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {\n+          MakeStruct({ArrayFromJSON(boolean(), \"[true, true, false, false]\")}),\n+          DictScalarFromJSON(type, \"0\", dict1),\n+          DictScalarFromJSON(type, \"0\", dict2),\n+      },\n+      DictArrayFromJSON(type, \"[0, 0, 2, 2]\", dict1));\n+  CheckScalarNonRecursive(\n+      \"case_when\",\n+      {\n+          MakeStruct({ArrayFromJSON(boolean(), \"[true, true, false, false]\"),\n+                      ArrayFromJSON(boolean(), \"[false, false, true, true]\")}),\n+          DictScalarFromJSON(type, \"0\", dict1),\n+          DictScalarFromJSON(type, \"0\", dict2),\n+      },\n+      DictArrayFromJSON(type, \"[0, 0, 2, 2]\", dict1));\n+\n+  // If we can't map values from a dictionary, then raise an error\n+  // Unmappable value is in the else clause\n\nReview comment:\n       I had mostly tried to emulate the R/dplyr behavior as closely as possible: https://github.com/apache/arrow/pull/10724#discussion_r682676388\r\n   \r\n   But unification is honestly probably easier to implement for us, so I can switch to that instead.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-06T16:29:04.523+0000",
                    "updated": "2021-09-06T16:29:04.523+0000",
                    "started": "2021-09-06T16:29:04.522+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "647068",
                    "issueId": "13393729"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/647069",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022#discussion_r703003007\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -1058,6 +1062,109 @@ void AddFSBinaryIfElseKernel(const std::shared_ptr<IfElseFunction>& scalar_funct\n   DCHECK_OK(scalar_function->AddKernel(std::move(kernel)));\n }\n \n+// Given a reference dictionary, computes indices to map dictionary values from a\n+// comparison dictionary to the reference.\n+class DictionaryRemapper {\n\nReview comment:\n       This is for if we don't want unification, however, I think we might want to just unify dictionaries always.\r\n   \r\n   IIRC, what DictionaryUnifier was missing was a way to compute a transposition map without adding new values to the internal memo table.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-06T16:29:48.072+0000",
                    "updated": "2021-09-06T16:29:48.072+0000",
                    "started": "2021-09-06T16:29:48.072+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "647069",
                    "issueId": "13393729"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/647451",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022#issuecomment-914434619\n\n\n   Changes:\r\n   - We always unify dictionaries now.\r\n   - Since this generates fresh dictionaries, to make testing easier, the dictionary variant of the kernel is compared against the non-dictionary variants.\r\n   - Refactored the various changes in the dictionary builders; handle nulls in dictionaries by emitting null indices (note that this means that we won't generate dictionaries with nulls even if we get such dictionaries in the inputs)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-07T16:05:14.431+0000",
                    "updated": "2021-09-07T16:05:14.431+0000",
                    "started": "2021-09-07T16:05:14.431+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "647451",
                    "issueId": "13393729"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/648604",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022#issuecomment-916105772\n\n\n   It looks like the RTools 40 test failure/crash is real; I'm going to need to figure out how to replicate this properly. (So far I've had little success with a VM, unfortunately.)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-09T13:37:33.576+0000",
                    "updated": "2021-09-09T13:37:33.576+0000",
                    "started": "2021-09-09T13:37:33.576+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "648604",
                    "issueId": "13393729"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/650036",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022#issuecomment-918224957\n\n\n   It looks like there's still 2 Windows failures to look into (a segfault in MinGW/32, which is hopefully more debuggable, and a failure to run one of the examples in RTools35), though the RTools40 crash is no more.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-13T14:03:58.166+0000",
                    "updated": "2021-09-13T14:03:58.166+0000",
                    "started": "2021-09-13T14:03:58.166+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "650036",
                    "issueId": "13393729"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/650155",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022#issuecomment-918417960\n\n\n   Hmm... did you make sense of the RTools 3.5 CI failure? I can't find the actual error in the logs :-/\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-13T17:34:46.670+0000",
                    "updated": "2021-09-13T17:34:46.670+0000",
                    "started": "2021-09-13T17:34:46.669+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "650155",
                    "issueId": "13393729"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/650156",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022#issuecomment-918418969\n\n\n   I'm setting up my Windows VM again since it expires every few months now :/ but it seems like the dataset example crashed when it was run, looking here: https://github.com/apache/arrow/pull/11022/checks?check_run_id=3589141006#step:12:395\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-13T17:35:52.145+0000",
                    "updated": "2021-09-13T17:35:52.145+0000",
                    "started": "2021-09-13T17:35:52.144+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "650156",
                    "issueId": "13393729"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/650166",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022#issuecomment-918435894\n\n\n   Is that example expected to be impacted by this PR? Otherwise, perhaps we should just restart the build...\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-13T17:57:10.165+0000",
                    "updated": "2021-09-13T17:57:10.165+0000",
                    "started": "2021-09-13T17:57:10.165+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "650166",
                    "issueId": "13393729"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/650167",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022#issuecomment-918436768\n\n\n   I do not expect it to be impacted but it was also failing in the last couple builds. (That said, I _think_ it wasn't failing before I turned off the unity build?)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-13T17:58:10.327+0000",
                    "updated": "2021-09-13T17:58:10.327+0000",
                    "started": "2021-09-13T17:58:10.327+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "650167",
                    "issueId": "13393729"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/650237",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022#issuecomment-918585698\n\n\n   And I did finally get the R package built on Windows - `write_dataset` causes R to crash, so I'll need to dig\u2026\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-13T21:19:12.988+0000",
                    "updated": "2021-09-13T21:19:12.988+0000",
                    "started": "2021-09-13T21:19:12.987+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "650237",
                    "issueId": "13393729"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/651929",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022#issuecomment-921140541\n\n\n   The CI is passing here, for the first time in quite a while.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-16T18:24:29.843+0000",
                    "updated": "2021-09-16T18:24:29.843+0000",
                    "started": "2021-09-16T18:24:29.843+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "651929",
                    "issueId": "13393729"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/652960",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022#discussion_r712154851\n\n\n\n##########\nFile path: ci/scripts/PKGBUILD\n##########\n@@ -80,9 +80,13 @@ build() {\n     export LIBS=\"-L${MINGW_PREFIX}/libs\"\n     export ARROW_S3=OFF\n     export ARROW_WITH_RE2=OFF\n+    # Without this, some dataset functionality segfaults\n+    export CMAKE_UNITY_BUILD=ON\n   else\n     export ARROW_S3=ON\n     export ARROW_WITH_RE2=ON\n+    # Without this, some compute functionality segfaults\n+    export CMAKE_UNITY_BUILD=OFF\n\nReview comment:\n       You mean it segfaults during compilation?\n\n##########\nFile path: cpp/src/arrow/array/builder_dict.h\n##########\n@@ -376,6 +455,37 @@ class DictionaryBuilderBase : public ArrayBuilder {\n   }\n \n  protected:\n+  template <typename c_type>\n+  Status AppendArraySliceImpl(const typename TypeTraits<T>::ArrayType& dict,\n+                              const ArrayData& array, int64_t offset, int64_t length) {\n+    const c_type* values = array.GetValues<c_type>(1) + offset;\n+    return VisitBitBlocks(\n+        array.buffers[0], array.offset + offset, length,\n+        [&](const int64_t position) {\n+          const int64_t index = static_cast<int64_t>(values[position]);\n+          if (dict.IsValid(index)) {\n+            return Append(dict.GetView(index));\n+          }\n+          return AppendNull();\n+        },\n+        [&]() { return AppendNull(); });\n+  }\n+\n+  template <typename IndexType>\n+  Status AppendScalarImpl(const typename TypeTraits<T>::ArrayType& dict,\n+                          const Scalar& index_scalar, int64_t n_repeats) {\n+    using ScalarType = typename TypeTraits<IndexType>::ScalarType;\n+    const auto index = internal::checked_cast<const ScalarType&>(index_scalar).value;\n+    if (index_scalar.is_valid && dict.IsValid(index)) {\n+      const auto& value = dict.GetView(index);\n+      for (int64_t i = 0; i < n_repeats; i++) {\n+        ARROW_RETURN_NOT_OK(Append(value));\n\nReview comment:\n       Not for this PR, but it sounds like offering a two-step API on DictionaryBuilder would allow for performance improvements:\r\n   ```c++\r\n   /// Ensure `value` is in the dict, and return its index, but doesn't append it\r\n   Result<int64_t> Encode(c_type value);\r\n   /// Append the given dictionary index\r\n   Status AppendIndex(int64_t index);\r\n   Status AppendIndices(int64_t index, int64_t nrepeats);\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/test_util.cc\n##########\n@@ -170,6 +171,74 @@ void CheckScalar(std::string func_name, const DatumVector& inputs, Datum expecte\n   }\n }\n \n+Datum CheckDictionaryNonRecursive(const std::string& func_name, const DatumVector& args) {\n+  EXPECT_OK_AND_ASSIGN(Datum actual, CallFunction(func_name, args));\n+  ValidateOutput(actual);\n+\n+  DatumVector decoded_args;\n+  decoded_args.reserve(args.size());\n+  for (const auto& arg : args) {\n+    if (arg.type()->id() == Type::DICTIONARY) {\n+      const auto& to_type = checked_cast<const DictionaryType&>(*arg.type()).value_type();\n+      EXPECT_OK_AND_ASSIGN(auto decoded, Cast(arg, to_type));\n+      decoded_args.push_back(decoded);\n+    } else {\n+      decoded_args.push_back(arg);\n+    }\n+  }\n+  EXPECT_OK_AND_ASSIGN(Datum expected, CallFunction(func_name, decoded_args));\n+\n+  if (actual.type()->id() == Type::DICTIONARY) {\n\nReview comment:\n       Hmm, it would be nice if the caller actually said whether the output is supposed to be dictionary-encoded or not. Otherwise there could be silent regressions where the output type of a kernel changes from one version to another.\n\n##########\nFile path: cpp/src/arrow/ipc/json_simple_test.cc\n##########\n@@ -1385,6 +1385,29 @@ TEST(TestScalarFromJSON, Errors) {\n   ASSERT_RAISES(Invalid, ScalarFromJSON(boolean(), \"\\\"true\\\"\", &scalar));\n }\n \n+TEST(TestDictScalarFromJSON, Basics) {\n+  auto type = dictionary(int32(), utf8());\n+  auto dict = R\"([\"whiskey\", \"tango\", \"foxtrot\"])\";\n+  auto expected_dictionary = ArrayFromJSON(utf8(), dict);\n+\n+  for (auto index : {\"null\", \"2\", \"1\", \"0\"}) {\n+    auto scalar = DictScalarFromJSON(type, index, dict);\n+    auto expected_index = ScalarFromJSON(int32(), index);\n+    AssertScalarsEqual(*DictionaryScalar::Make(expected_index, expected_dictionary),\n\nReview comment:\n       Also call `scalar->ValidateFull()`?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-20T13:31:49.465+0000",
                    "updated": "2021-09-20T13:31:49.465+0000",
                    "started": "2021-09-20T13:31:49.465+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "652960",
                    "issueId": "13393729"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/worklog/653032",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11022:\nURL: https://github.com/apache/arrow/pull/11022#discussion_r712266986\n\n\n\n##########\nFile path: cpp/src/arrow/array/builder_dict.h\n##########\n@@ -376,6 +455,37 @@ class DictionaryBuilderBase : public ArrayBuilder {\n   }\n \n  protected:\n+  template <typename c_type>\n+  Status AppendArraySliceImpl(const typename TypeTraits<T>::ArrayType& dict,\n+                              const ArrayData& array, int64_t offset, int64_t length) {\n+    const c_type* values = array.GetValues<c_type>(1) + offset;\n+    return VisitBitBlocks(\n+        array.buffers[0], array.offset + offset, length,\n+        [&](const int64_t position) {\n+          const int64_t index = static_cast<int64_t>(values[position]);\n+          if (dict.IsValid(index)) {\n+            return Append(dict.GetView(index));\n+          }\n+          return AppendNull();\n+        },\n+        [&]() { return AppendNull(); });\n+  }\n+\n+  template <typename IndexType>\n+  Status AppendScalarImpl(const typename TypeTraits<T>::ArrayType& dict,\n+                          const Scalar& index_scalar, int64_t n_repeats) {\n+    using ScalarType = typename TypeTraits<IndexType>::ScalarType;\n+    const auto index = internal::checked_cast<const ScalarType&>(index_scalar).value;\n+    if (index_scalar.is_valid && dict.IsValid(index)) {\n+      const auto& value = dict.GetView(index);\n+      for (int64_t i = 0; i < n_repeats; i++) {\n+        ARROW_RETURN_NOT_OK(Append(value));\n\nReview comment:\n       I filed ARROW-14042.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-20T15:15:55.207+0000",
                    "updated": "2021-09-20T15:15:55.207+0000",
                    "started": "2021-09-20T15:15:55.207+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "653032",
                    "issueId": "13393729"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 15600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@d4044[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6b5aaf[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3eb3e10[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@590fb2e0[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@720e0e4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@1cd5eae1[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@46145cd5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@62287e45[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@628f8524[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@513ee976[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3528e570[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@14537fc6[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 15600,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Sep 21 11:08:16 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-09-21T11:08:16.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13573/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-08-05T14:29:25.000+0000",
        "updated": "2021-09-29T19:49:04.000+0000",
        "timeoriginalestimate": null,
        "description": "case_when (and other similar kernels) currently dictionary-decode inputs, then operate on the decoded values. This is both inefficient and unexpected. We should instead operate directly on dictionary indices.\r\n\r\nOf course, this introduces more edge cases. If the dictionaries of inputs do not match, we have the following choices:\r\n # Raise an error.\r\n # Unify the dictionaries.\r\n # Use one of the dictionaries, and raise an error if an index of another dictionary cannot be mapped to an index of the chosen dictionary.\r\n # Use one of the dictionaries, and emit null if an index of another dictionary cannot be mapped to an index of the chosen dictionary. (This is what base dplyr if_else does with factors.)\r\n\r\nAll of these options are reasonable, so we should introduce an options struct. We can implement #3 and #4 at first (to cover R); #2 isn't strictly necessary, as the user can unify the dictionaries manually first, but it may be more efficient to do it this way. Similarly, #1 isn't strictly necessary.\r\n\r\n#3 and #4 are justifiable (beyond just \"it's what R does\") since users may filter down disjoint dictionaries into a set of common values and then expect to combine the remaining values with a kernel like case_when.\r\n\r\nAs described on [GitHub|https://github.com/apache/arrow/pull/10724#discussion_r682671015].",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 15600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Support dictionaries directly in case_when kernel",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/comment/17394062",
                    "id": "17394062",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Also, we can use the 'fast' approach for dictionaries (being able to write into slices, using preallocated outputs as implemented for numeric inputs, as opposed to the builder-based approach in ARROW-13222 for variable-width types) though we'll want to support nested dictionaries too (lists of dictionaries and such).",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-08-05T14:30:10.898+0000",
                    "updated": "2021-08-05T14:30:51.061+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393729/comment/17418045",
                    "id": "17418045",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 11022\n[https://github.com/apache/arrow/pull/11022]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-09-21T11:08:16.132+0000",
                    "updated": "2021-09-21T11:08:16.132+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|z0tnaw:",
        "customfield_12314139": null
    }
}