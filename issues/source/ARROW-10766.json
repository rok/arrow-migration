{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13343163",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163",
    "key": "ARROW-10766",
    "fields": {
        "parent": {
            "id": "13298042",
            "key": "ARROW-8421",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13298042",
            "fields": {
                "summary": "[Rust] [Parquet] Implement parquet writer",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                    "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                    "name": "Closed",
                    "id": "6",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                    "id": "4",
                    "description": "An improvement or enhancement to an existing feature or task.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                    "name": "Improvement",
                    "subtask": false,
                    "avatarId": 21140
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
            "name": "nevi_me",
            "key": "nevi_me",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
            },
            "displayName": "Neville Dipale",
            "active": true,
            "timeZone": "Africa/Johannesburg"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
            "name": "nevi_me",
            "key": "nevi_me",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
            },
            "displayName": "Neville Dipale",
            "active": true,
            "timeZone": "Africa/Johannesburg"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
            "name": "nevi_me",
            "key": "nevi_me",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
            },
            "displayName": "Neville Dipale",
            "active": true,
            "timeZone": "Africa/Johannesburg"
        },
        "aggregateprogress": {
            "progress": 15600,
            "total": 15600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 15600,
            "total": 15600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10766/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 26,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/524440",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me opened a new pull request #8927:\nURL: https://github.com/apache/arrow/pull/8927\n\n\n   Putting this out for those who are interested in poking through the implementation. I'm nearly done with this, but I'm now dealing with integrating the level calculations into arrays. Some tests pass, others fail\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-15T14:04:02.947+0000",
                    "updated": "2020-12-15T14:04:02.947+0000",
                    "started": "2020-12-15T14:04:02.947+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "524440",
                    "issueId": "13343163"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/524469",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8927:\nURL: https://github.com/apache/arrow/pull/8927#issuecomment-745328300\n\n\n   https://issues.apache.org/jira/browse/ARROW-10766\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-15T14:30:53.784+0000",
                    "updated": "2020-12-15T14:30:53.784+0000",
                    "started": "2020-12-15T14:30:53.783+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "524469",
                    "issueId": "13343163"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/526652",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #8927:\nURL: https://github.com/apache/arrow/pull/8927#issuecomment-748725603\n\n\n   I'd like to complete this before the Christmas break, so I've unfortunately solely been working on this on the weekend. \r\n   I'm dealing with edge-cases in the tests, and massaging everything to work.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-21T02:42:59.616+0000",
                    "updated": "2020-12-21T02:42:59.616+0000",
                    "started": "2020-12-21T02:42:59.616+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "526652",
                    "issueId": "13343163"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/530888",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #8927:\nURL: https://github.com/apache/arrow/pull/8927#issuecomment-754211680\n\n\n   I got stalled with #9093. I think it's the last blocker before I can complete this :(\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-04T20:52:01.314+0000",
                    "updated": "2021-01-04T20:52:01.314+0000",
                    "started": "2021-01-04T20:52:01.314+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "530888",
                    "issueId": "13343163"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/537189",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #8927:\nURL: https://github.com/apache/arrow/pull/8927#issuecomment-761913683\n\n\n   Closing this, will open a fresh one that's got fewer commits\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-18T00:47:16.065+0000",
                    "updated": "2021-01-18T00:47:16.065+0000",
                    "started": "2021-01-18T00:47:16.064+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "537189",
                    "issueId": "13343163"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/537190",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me closed pull request #8927:\nURL: https://github.com/apache/arrow/pull/8927\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-18T00:47:19.031+0000",
                    "updated": "2021-01-18T00:47:19.031+0000",
                    "started": "2021-01-18T00:47:19.030+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "537190",
                    "issueId": "13343163"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/537191",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me opened a new pull request #9240:\nURL: https://github.com/apache/arrow/pull/9240\n\n\n   This mainly computes definition and repetition leves for lists.\r\n   It also partially adds deeply nested write support.\r\n   I am however going to complete this in a separate PR.\r\n   \r\n   This has really been challenging because we can't roundtrip without nested writers,\r\n   so it's taken me months to complete.\r\n   In the process, I've had to rely on using Spark to verify my work.\r\n   \r\n   This PR is also not optimised. I've left TODOs in a few places (sparingly).\r\n   The biggest next step is to remove array_mask: Vec<u8> and replace it with a bitpacked vector to save memory.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-18T00:53:43.808+0000",
                    "updated": "2021-01-18T00:53:43.808+0000",
                    "started": "2021-01-18T00:53:43.807+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "537191",
                    "issueId": "13343163"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/537192",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #9240:\nURL: https://github.com/apache/arrow/pull/9240#issuecomment-761915678\n\n\n   https://issues.apache.org/jira/browse/ARROW-10766\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-18T00:54:08.810+0000",
                    "updated": "2021-01-18T00:54:08.810+0000",
                    "started": "2021-01-18T00:54:08.810+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "537192",
                    "issueId": "13343163"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/537193",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #9240:\nURL: https://github.com/apache/arrow/pull/9240#issuecomment-761919066\n\n\n   Hi everyone interested in the Parquet writer.\r\n   \r\n   This PR effectively gives us the ability to compute how to write arbitrarily nested types. It has the side effect that nested lists can also be written.\r\n   There's a few places where I need to tidy up, but they're dependent on the Arrow reader (ARROW-10391), which unfortunately might be a lot of work on its own. I'm a bit worried that I might have to rework a fair share of the writer to handle nesting correctly. I've already seen instances where we don't always have enough information to arrive at the correct solution.\r\n   \r\n   I'll open JIRAs as I go along.\r\n   \r\n   For reviewers, please note:\r\n   \r\n   This has taken me a few months on weekends to get right. I've iterated over various solutions to arrive here.\r\n   The implementation is not optimal (I haven't benchmarked the latest impl), but I'm confident that it's correct.\r\n   the extensive tests on the levels.rs will allow us to refactor with some confidence.\r\n   \r\n   I've spent far too long on this, so I practically don't have any fresh eyes here. I worked on all the edge-cases that I could think with lists and structs. I've documented them, but I'll review the doc comments and add more detail where I still feel that it's lacking.\r\n   \r\n   Thank you \u2764\ufe0f\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-18T01:06:19.172+0000",
                    "updated": "2021-01-18T01:06:19.172+0000",
                    "started": "2021-01-18T01:06:19.172+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "537193",
                    "issueId": "13343163"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/537194",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "codecov-io commented on pull request #9240:\nURL: https://github.com/apache/arrow/pull/9240#issuecomment-761919741\n\n\n   # [Codecov](https://codecov.io/gh/apache/arrow/pull/9240?src=pr&el=h1) Report\n   > Merging [#9240](https://codecov.io/gh/apache/arrow/pull/9240?src=pr&el=desc) (75487cf) into [master](https://codecov.io/gh/apache/arrow/commit/1393188e1aa1b3d59993ce7d4ade7f7ac8570959?el=desc) (1393188) will **increase** coverage by `0.14%`.\n   > The diff coverage is `85.38%`.\n   \n   [![Impacted file tree graph](https://codecov.io/gh/apache/arrow/pull/9240/graphs/tree.svg?width=650&height=150&src=pr&token=LpTCFbqVT1)](https://codecov.io/gh/apache/arrow/pull/9240?src=pr&el=tree)\n   \n   ```diff\n   @@            Coverage Diff             @@\n   ##           master    #9240      +/-   ##\n   ==========================================\n   + Coverage   81.61%   81.75%   +0.14%     \n   ==========================================\n     Files         215      215              \n     Lines       51867    52400     +533     \n   ==========================================\n   + Hits        42329    42839     +510     \n   - Misses       9538     9561      +23     \n   ```\n   \n   \n   | [Impacted Files](https://codecov.io/gh/apache/arrow/pull/9240?src=pr&el=tree) | Coverage \u0394 | |\n   |---|---|---|\n   | [rust/parquet/src/arrow/array\\_reader.rs](https://codecov.io/gh/apache/arrow/pull/9240/diff?src=pr&el=tree#diff-cnVzdC9wYXJxdWV0L3NyYy9hcnJvdy9hcnJheV9yZWFkZXIucnM=) | `75.00% <71.42%> (+3.59%)` | :arrow_up: |\n   | [rust/parquet/src/arrow/levels.rs](https://codecov.io/gh/apache/arrow/pull/9240/diff?src=pr&el=tree#diff-cnVzdC9wYXJxdWV0L3NyYy9hcnJvdy9sZXZlbHMucnM=) | `81.55% <84.69%> (+9.71%)` | :arrow_up: |\n   | [rust/parquet/src/arrow/arrow\\_writer.rs](https://codecov.io/gh/apache/arrow/pull/9240/diff?src=pr&el=tree#diff-cnVzdC9wYXJxdWV0L3NyYy9hcnJvdy9hcnJvd193cml0ZXIucnM=) | `96.78% <100.00%> (+1.20%)` | :arrow_up: |\n   | [rust/parquet/src/arrow/schema.rs](https://codecov.io/gh/apache/arrow/pull/9240/diff?src=pr&el=tree#diff-cnVzdC9wYXJxdWV0L3NyYy9hcnJvdy9zY2hlbWEucnM=) | `91.67% <100.00%> (+0.17%)` | :arrow_up: |\n   | [rust/arrow/src/ipc/gen/Schema.rs](https://codecov.io/gh/apache/arrow/pull/9240/diff?src=pr&el=tree#diff-cnVzdC9hcnJvdy9zcmMvaXBjL2dlbi9TY2hlbWEucnM=) | `40.43% <0.00%> (+0.71%)` | :arrow_up: |\n   | [rust/arrow/src/array/equal/utils.rs](https://codecov.io/gh/apache/arrow/pull/9240/diff?src=pr&el=tree#diff-cnVzdC9hcnJvdy9zcmMvYXJyYXkvZXF1YWwvdXRpbHMucnM=) | `74.75% <0.00%> (+0.97%)` | :arrow_up: |\n   | [rust/arrow/src/ipc/convert.rs](https://codecov.io/gh/apache/arrow/pull/9240/diff?src=pr&el=tree#diff-cnVzdC9hcnJvdy9zcmMvaXBjL2NvbnZlcnQucnM=) | `93.67% <0.00%> (+1.58%)` | :arrow_up: |\n   | [rust/arrow/src/array/transform/fixed\\_binary.rs](https://codecov.io/gh/apache/arrow/pull/9240/diff?src=pr&el=tree#diff-cnVzdC9hcnJvdy9zcmMvYXJyYXkvdHJhbnNmb3JtL2ZpeGVkX2JpbmFyeS5ycw==) | `84.21% <0.00%> (+5.26%)` | :arrow_up: |\n   \n   ------\n   \n   [Continue to review full report at Codecov](https://codecov.io/gh/apache/arrow/pull/9240?src=pr&el=continue).\n   > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n   > `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n   > Powered by [Codecov](https://codecov.io/gh/apache/arrow/pull/9240?src=pr&el=footer). Last update [71b6b9c...75487cf](https://codecov.io/gh/apache/arrow/pull/9240?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-18T01:09:13.842+0000",
                    "updated": "2021-01-18T01:09:13.842+0000",
                    "started": "2021-01-18T01:09:13.842+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "537194",
                    "issueId": "13343163"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/537198",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #9240:\nURL: https://github.com/apache/arrow/pull/9240#discussion_r559270842\n\n\n\n##########\nFile path: rust/parquet/src/arrow/levels.rs\n##########\n@@ -20,12 +20,12 @@\n //! Contains the algorithm for computing definition and repetition levels.\n //! The algorithm works by tracking the slots of an array that should ultimately be populated when\n //! writing to Parquet.\n-//! Parquet achieves nesting through definition levels and repetition levels \\[1\\].\n+//! Parquet achieves nesting through definition levels and repetition levels [1].\n\nReview comment:\n       rebase gone bad. I'll fix this\n\n##########\nFile path: rust/parquet/src/arrow/levels.rs\n##########\n@@ -294,40 +242,1158 @@ impl LevelInfo {\n                 // Need to check for these cases not implemented in C++:\n                 // - \"Writing DictionaryArray with nested dictionary type not yet supported\"\n                 // - \"Writing DictionaryArray with null encoded in dictionary type not yet supported\"\n-                vec![Self {\n-                    definition: self.get_primitive_def_levels(array, field),\n-                    repetition: self.repetition.clone(),\n-                    definition_mask: self.definition_mask.clone(),\n+                // vec![self.get_primitive_def_levels(array, field, array_mask)]\n+                vec![self.calculate_child_levels(\n+                    array_offsets,\n+                    array_mask,\n+                    false,\n+                    field.is_nullable(),\n+                )]\n+            }\n+        }\n+    }\n+\n+    /// Calculate child/leaf array levels.\n+    ///\n+    /// The algorithm works by incrementing definitions of array values based on whether:\n+    /// - a value is optional or required (is_nullable)\n+    /// - a list value is repeated + optional or required (is_list)\n+    ///\n+    /// *Examples:*\n\nReview comment:\n       I'll review this. I shouldn't have 2 *Examples:* headings.\n\n##########\nFile path: rust/parquet/src/arrow/levels.rs\n##########\n@@ -294,40 +242,1158 @@ impl LevelInfo {\n                 // Need to check for these cases not implemented in C++:\n                 // - \"Writing DictionaryArray with nested dictionary type not yet supported\"\n                 // - \"Writing DictionaryArray with null encoded in dictionary type not yet supported\"\n-                vec![Self {\n-                    definition: self.get_primitive_def_levels(array, field),\n-                    repetition: self.repetition.clone(),\n-                    definition_mask: self.definition_mask.clone(),\n+                // vec![self.get_primitive_def_levels(array, field, array_mask)]\n+                vec![self.calculate_child_levels(\n+                    array_offsets,\n+                    array_mask,\n+                    false,\n+                    field.is_nullable(),\n+                )]\n+            }\n+        }\n+    }\n+\n+    /// Calculate child/leaf array levels.\n+    ///\n+    /// The algorithm works by incrementing definitions of array values based on whether:\n+    /// - a value is optional or required (is_nullable)\n+    /// - a list value is repeated + optional or required (is_list)\n+    ///\n+    /// *Examples:*\n+    ///\n+    /// A record batch always starts at a populated definition = level 0.\n+    /// When a batch only has a primitive, i.e. `<batch<primitive[a]>>, column `a`\n+    /// can only have a maximum level of 1 if it is not null.\n+    /// If it is not null, we increment by 1, such that the null slots will = level 1.\n+    /// The above applies to types that have no repetition (anything not a list or map).\n+    ///\n+    /// If a batch has lists, then we increment by up to 2 levels:\n+    /// - 1 level for the list\n+    /// - 1 level if the list itself is nullable\n+    ///\n+    /// A list's child then gets incremented using the above rules.\n+    ///\n+    /// A special case is when at the root of the schema. We always increment the\n+    /// level regardless of whether the child is nullable or not. If we do not do\n+    /// this, we could have a non-nullable array having a definition of 0.\n+    ///\n+    /// *Examples*\n+    ///\n+    /// A batch with only a primitive that's non-nullable. `<primitive[required]>`:\n+    /// * We don't increment the definition level as the array is not optional.\n+    /// * This would leave us with a definition of 0, so the special case applies.\n+    /// * The definition level becomes 1.\n+    ///\n+    /// A batch with only a primitive that's nullable. `<primitive[optional]>`:\n+    /// * The definition level becomes 1, as we increment it once.\n+    ///\n+    /// A batch with a single non-nullable list (both list and child not null):\n+    /// * We calculate the level twice, for the list, and for the child.\n+    /// * At the list, the level becomes 1, where 0 indicates that the list is\n+    ///  empty, and 1 says it's not (determined through offsets).\n+    /// * At the primitive level\n\nReview comment:\n       I didn't finish this\n\n##########\nFile path: rust/parquet/src/arrow/levels.rs\n##########\n@@ -294,40 +242,1158 @@ impl LevelInfo {\n                 // Need to check for these cases not implemented in C++:\n                 // - \"Writing DictionaryArray with nested dictionary type not yet supported\"\n                 // - \"Writing DictionaryArray with null encoded in dictionary type not yet supported\"\n-                vec![Self {\n-                    definition: self.get_primitive_def_levels(array, field),\n-                    repetition: self.repetition.clone(),\n-                    definition_mask: self.definition_mask.clone(),\n+                // vec![self.get_primitive_def_levels(array, field, array_mask)]\n+                vec![self.calculate_child_levels(\n+                    array_offsets,\n+                    array_mask,\n+                    false,\n+                    field.is_nullable(),\n+                )]\n+            }\n+        }\n+    }\n+\n+    /// Calculate child/leaf array levels.\n+    ///\n+    /// The algorithm works by incrementing definitions of array values based on whether:\n+    /// - a value is optional or required (is_nullable)\n+    /// - a list value is repeated + optional or required (is_list)\n+    ///\n+    /// *Examples:*\n+    ///\n+    /// A record batch always starts at a populated definition = level 0.\n+    /// When a batch only has a primitive, i.e. `<batch<primitive[a]>>, column `a`\n+    /// can only have a maximum level of 1 if it is not null.\n+    /// If it is not null, we increment by 1, such that the null slots will = level 1.\n+    /// The above applies to types that have no repetition (anything not a list or map).\n+    ///\n+    /// If a batch has lists, then we increment by up to 2 levels:\n+    /// - 1 level for the list\n+    /// - 1 level if the list itself is nullable\n+    ///\n+    /// A list's child then gets incremented using the above rules.\n+    ///\n+    /// A special case is when at the root of the schema. We always increment the\n+    /// level regardless of whether the child is nullable or not. If we do not do\n+    /// this, we could have a non-nullable array having a definition of 0.\n+    ///\n+    /// *Examples*\n+    ///\n+    /// A batch with only a primitive that's non-nullable. `<primitive[required]>`:\n+    /// * We don't increment the definition level as the array is not optional.\n+    /// * This would leave us with a definition of 0, so the special case applies.\n+    /// * The definition level becomes 1.\n+    ///\n+    /// A batch with only a primitive that's nullable. `<primitive[optional]>`:\n+    /// * The definition level becomes 1, as we increment it once.\n+    ///\n+    /// A batch with a single non-nullable list (both list and child not null):\n+    /// * We calculate the level twice, for the list, and for the child.\n+    /// * At the list, the level becomes 1, where 0 indicates that the list is\n+    ///  empty, and 1 says it's not (determined through offsets).\n+    /// * At the primitive level\n+    fn calculate_child_levels(\n+        &self,\n+        // we use 64-bit offsets to also accommodate large arrays\n+        array_offsets: Vec<i64>,\n+        array_mask: Vec<bool>,\n+        is_list: bool,\n+        is_nullable: bool,\n+    ) -> Self {\n+        let mut definition = vec![];\n+        let mut repetition = vec![];\n+        let mut merged_array_mask = vec![];\n+\n+        // determine the total level increment based on data types\n+        let max_definition = match is_list {\n+            false => {\n+                if self.max_definition == 0 {\n+                    1\n+                } else {\n+                    self.max_definition + is_nullable as i16\n+                }\n+            }\n+            true => self.max_definition + 1 + is_nullable as i16,\n+        };\n+\n+        match (self.is_list, is_list) {\n+            (false, false) => {\n+                self.definition\n+                    .iter()\n+                    .zip(array_mask.into_iter().zip(&self.array_mask))\n+                    .for_each(|(def, (child_mask, parent_mask))| {\n+                        merged_array_mask.push(*parent_mask && child_mask);\n+                        match (parent_mask, child_mask) {\n+                            (true, true) => {\n+                                definition.push(max_definition);\n+                            }\n+                            (true, false) => {\n+                                // The child is only legally null if its array is nullable.\n+                                // Thus parent's max_definition is lower\n+                                definition.push(if *def <= self.max_definition {\n+                                    *def\n+                                } else {\n+                                    self.max_definition\n+                                });\n+                            }\n+                            // if the parent was false, retain its definitions\n+                            (false, _) => {\n+                                definition.push(*def);\n+                            }\n+                        }\n+                    });\n+\n+                debug_assert_eq!(definition.len(), merged_array_mask.len());\n+\n+                Self {\n+                    definition,\n+                    repetition: self.repetition.clone(), // it's None\n+                    array_offsets,\n+                    array_mask: merged_array_mask,\n+                    max_definition,\n+                    is_list: false,\n+                    is_nullable,\n+                }\n+            }\n+            (true, true) => {\n+                // parent is a list or descendant of a list, and child is a list\n+                let reps = self.repetition.clone().unwrap();\n+                // Calculate the 2 list hierarchy definitions in advance\n+                // List is not empty, but null\n+                let l2 = max_definition - is_nullable as i16;\n+                // List is not empty, and not null\n+                let l3 = max_definition;\n+\n+                let mut nulls_seen = 0;\n+\n+                self.array_offsets.windows(2).for_each(|w| {\n+                    let start = w[0] as usize;\n+                    let end = w[1] as usize;\n+                    let parent_len = end - start;\n+\n+                    if parent_len == 0 {\n+                        // If the parent length is 0, there won't be a slot for the child\n+                        let index = start + nulls_seen;\n+                        definition.push(self.definition[index]);\n+                        repetition.push(0);\n+                        merged_array_mask.push(self.array_mask[index]);\n+                        nulls_seen += 1;\n+                    } else {\n+                        (start..end).for_each(|parent_index| {\n+                            let index = parent_index + nulls_seen;\n+\n+                            // parent is either defined at this level, or earlier\n+                            let parent_def = self.definition[index];\n+                            let parent_rep = reps[index];\n+                            let parent_mask = self.array_mask[index];\n+\n+                            // valid parent, index into children\n+                            let child_start = array_offsets[parent_index] as usize;\n+                            let child_end = array_offsets[parent_index + 1] as usize;\n+                            let child_len = child_end - child_start;\n+                            let child_mask = array_mask[parent_index];\n+                            let merged_mask = parent_mask && child_mask;\n+\n+                            if child_len == 0 {\n+                                definition.push(parent_def);\n+                                repetition.push(parent_rep);\n+                                merged_array_mask.push(merged_mask);\n+                            } else {\n+                                (child_start..child_end).for_each(|child_index| {\n+                                    let rep = match (\n+                                        parent_index == start,\n+                                        child_index == child_start,\n+                                    ) {\n+                                        (true, true) => parent_rep,\n+                                        (true, false) => parent_rep + 2,\n+                                        (false, true) => parent_rep,\n+                                        (false, false) => parent_rep + 1,\n+                                    };\n+\n+                                    definition.push(if !parent_mask {\n+                                        parent_def\n+                                    } else if child_mask {\n+                                        l3\n+                                    } else {\n+                                        l2\n+                                    });\n+                                    repetition.push(rep);\n+                                    merged_array_mask.push(merged_mask);\n+                                });\n+                            }\n+                        });\n+                    }\n+                });\n+\n+                debug_assert_eq!(definition.len(), merged_array_mask.len());\n+\n+                Self {\n+                    definition,\n+                    repetition: Some(repetition),\n+                    array_offsets,\n+                    array_mask: merged_array_mask,\n+                    max_definition,\n+                    is_list: true,\n+                    is_nullable,\n+                }\n+            }\n+            (true, false) => {\n+                // List and primitive (or struct).\n+                // The list can have more values than the primitive, indicating that there\n+                // are slots where the list is empty. We use a counter to track this behaviour.\n+                let mut nulls_seen = 0;\n+\n+                // let child_max_definition = list_max_definition + is_nullable as i16;\n+                // child values are a function of parent list offsets\n+                let reps = self.repetition.as_deref().unwrap();\n+                self.array_offsets.windows(2).for_each(|w| {\n+                    let start = w[0] as usize;\n+                    let end = w[1] as usize;\n+                    let parent_len = end - start;\n+\n+                    if parent_len == 0 {\n+                        let index = start + nulls_seen;\n+                        definition.push(self.definition[index]);\n+                        repetition.push(reps[index]);\n+                        merged_array_mask.push(self.array_mask[index]);\n+                        nulls_seen += 1;\n+                    } else {\n+                        // iterate through the array, adjusting child definitions for nulls\n+                        (start..end).for_each(|child_index| {\n+                            let index = child_index + nulls_seen;\n+                            let child_mask = array_mask[child_index];\n+                            let parent_mask = self.array_mask[index];\n+                            let parent_def = self.definition[index];\n+\n+                            if !parent_mask || parent_def < self.max_definition {\n+                                definition.push(parent_def);\n+                                repetition.push(reps[index]);\n+                                merged_array_mask.push(parent_mask);\n+                            } else {\n+                                definition.push(max_definition - !child_mask as i16);\n+                                repetition.push(reps[index]);\n+                                merged_array_mask.push(child_mask);\n+                            }\n+                        });\n+                    }\n+                });\n+\n+                debug_assert_eq!(definition.len(), merged_array_mask.len());\n+\n+                Self {\n+                    definition,\n+                    repetition: Some(repetition),\n                     array_offsets: self.array_offsets.clone(),\n-                    array_mask: self.array_mask.clone(),\n-                    is_list: self.is_list,\n-                    max_definition: level,\n-                    is_nullable: field.is_nullable(),\n-                }]\n+                    array_mask: merged_array_mask,\n+                    max_definition,\n+                    is_list: true,\n+                    is_nullable,\n+                }\n+            }\n+            (false, true) => {\n+                // Encountering a list for the first time.\n+                // Calculate the 2 list hierarchy definitions in advance\n+\n+                // List is not empty, but null (if nullable)\n+                let l2 = max_definition - is_nullable as i16;\n+                // List is not empty, and not null\n+                let l3 = max_definition;\n+\n+                self.definition\n+                    .iter()\n+                    .enumerate()\n+                    .for_each(|(parent_index, def)| {\n+                        let child_from = array_offsets[parent_index];\n+                        let child_to = array_offsets[parent_index + 1];\n+                        let child_len = child_to - child_from;\n+                        let child_mask = array_mask[parent_index];\n+                        let parent_mask = self.array_mask[parent_index];\n+\n+                        match (parent_mask, child_len) {\n+                            (true, 0) => {\n+                                // empty slot that is valid, i.e. {\"parent\": {\"child\": [] } }\n+                                definition.push(if child_mask {\n+                                    l2\n+                                } else {\n+                                    self.max_definition\n+                                });\n+                                repetition.push(0);\n+                                merged_array_mask.push(child_mask);\n+                            }\n+                            (false, 0) => {\n+                                definition.push(*def);\n+                                repetition.push(0);\n+                                merged_array_mask.push(child_mask);\n+                            }\n+                            (true, _) => {\n+                                (child_from..child_to).for_each(|child_index| {\n+                                    definition.push(if child_mask { l3 } else { l2 });\n+                                    // mark the first child slot as 0, and the next as 1\n+                                    repetition.push(if child_index == child_from {\n+                                        0\n+                                    } else {\n+                                        1\n+                                    });\n+                                    merged_array_mask.push(child_mask);\n+                                });\n+                            }\n+                            (false, _) => {\n+                                (child_from..child_to).for_each(|child_index| {\n+                                    definition.push(*def);\n+                                    // mark the first child slot as 0, and the next as 1\n+                                    repetition.push(if child_index == child_from {\n+                                        0\n+                                    } else {\n+                                        1\n+                                    });\n+                                    merged_array_mask.push(false);\n+                                });\n+                            }\n+                        }\n+                    });\n+\n+                debug_assert_eq!(definition.len(), merged_array_mask.len());\n+\n+                Self {\n+                    definition,\n+                    repetition: Some(repetition),\n+                    array_offsets,\n+                    array_mask: merged_array_mask,\n+                    max_definition,\n+                    is_list: true,\n+                    is_nullable,\n+                }\n             }\n         }\n     }\n \n-    /// Get the definition levels of the numeric array, with level 0 being null and 1 being not null\n-    /// In the case where the array in question is a child of either a list or struct, the levels\n-    /// are incremented in accordance with the `level` parameter.\n-    /// Parent levels are either 0 or 1, and are used to higher (correct terminology?) leaves as null\n-    fn get_primitive_def_levels(&self, array: &ArrayRef, field: &Field) -> Vec<i16> {\n-        let mut array_index = 0;\n-        let max_def_level = self.definition.iter().max().unwrap();\n-        let mut primitive_def_levels = vec![];\n-        self.definition.iter().for_each(|def_level| {\n-            if !field.is_nullable() && *max_def_level > 1 {\n-                primitive_def_levels.push(*def_level - 1);\n-                array_index += 1;\n-            } else if def_level < max_def_level {\n-                primitive_def_levels.push(*def_level);\n-                array_index += 1;\n-            } else {\n-                primitive_def_levels.push(def_level - array.is_null(array_index) as i16);\n-                array_index += 1;\n+    /// Get the offsets of an array as 64-bit values, and validity masks as booleans\n+    /// - Primitive, binary and struct arrays' offsets will be a sequence, masks obtained from validity bitmap\n+    /// - List array offsets will be the value offsets, masks are computed from offsets\n+    fn get_array_offsets_and_masks(array: &ArrayRef) -> (Vec<i64>, Vec<bool>) {\n+        match array.data_type() {\n+            DataType::Null\n+            | DataType::Boolean\n+            | DataType::Int8\n+            | DataType::Int16\n+            | DataType::Int32\n+            | DataType::Int64\n+            | DataType::UInt8\n+            | DataType::UInt16\n+            | DataType::UInt32\n+            | DataType::UInt64\n+            | DataType::Float16\n+            | DataType::Float32\n+            | DataType::Float64\n+            | DataType::Timestamp(_, _)\n+            | DataType::Date32(_)\n+            | DataType::Date64(_)\n+            | DataType::Time32(_)\n+            | DataType::Time64(_)\n+            | DataType::Duration(_)\n+            | DataType::Interval(_)\n+            | DataType::Binary\n+            | DataType::LargeBinary\n+            | DataType::Utf8\n+            | DataType::LargeUtf8\n+            | DataType::Struct(_)\n+            | DataType::Dictionary(_, _)\n+            | DataType::Decimal(_, _) => {\n+                let array_mask = match array.data().null_buffer() {\n+                    Some(buf) => get_bool_array_slice(buf, array.offset(), array.len()),\n+                    None => vec![true; array.len()],\n+                };\n+                ((0..=(array.len() as i64)).collect(), array_mask)\n+            }\n+            DataType::List(_) => {\n+                let data = array.data();\n+                let offsets = unsafe { data.buffers()[0].typed_data::<i32>() };\n+                let offsets = offsets\n+                    .to_vec()\n+                    .into_iter()\n+                    .map(|v| v as i64)\n+                    .collect::<Vec<i64>>();\n+                let masks = offsets.windows(2).map(|w| w[1] > w[0]).collect();\n+                (offsets, masks)\n+            }\n+            DataType::LargeList(_) => {\n+                let offsets =\n+                    unsafe { array.data().buffers()[0].typed_data::<i64>() }.to_vec();\n+                let masks = offsets.windows(2).map(|w| w[1] > w[0]).collect();\n+                (offsets, masks)\n+            }\n+            DataType::FixedSizeBinary(_)\n+            | DataType::FixedSizeList(_, _)\n+            | DataType::Union(_) => {\n+                unimplemented!(\"Getting offsets not yet implemented\")\n+            }\n+        }\n+    }\n+\n+    /// Given a level's information, calculate the offsets required to index an array correctly.\n+    pub(crate) fn filter_array_indices(&self) -> Vec<usize> {\n+        // happy path if not dealing with lists\n+        if !self.is_list {\n+            return self\n+                .definition\n+                .iter()\n+                .enumerate()\n+                .filter_map(|(i, def)| {\n+                    if *def == self.max_definition {\n+                        Some(i)\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .collect();\n+        }\n+        let mut filtered = vec![];\n+        // remove slots that are false from definition_mask\n+        let mut index = 0;\n+        self.definition.iter().for_each(|def| {\n+            if *def == self.max_definition {\n+                filtered.push(index);\n+            }\n+            if *def >= self.max_definition - self.is_nullable as i16 {\n+                index += 1;\n             }\n         });\n-        primitive_def_levels\n+        filtered\n+    }\n+}\n+\n+/// Convert an Arrow buffer to a boolean array slice\n+/// TODO: this was created for buffers, so might not work for bool array, might be slow too\n+#[inline]\n+fn get_bool_array_slice(\n+    buffer: &arrow::buffer::Buffer,\n+    offset: usize,\n+    len: usize,\n+) -> Vec<bool> {\n+    let data = buffer.as_slice();\n+    (offset..(len + offset))\n+        .map(|i| arrow::util::bit_util::get_bit(data, i))\n+        .collect()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::sync::Arc;\n+\n+    use arrow::{\n+        array::ListArray,\n+        array::{Array, ArrayData, Int32Array},\n+        buffer::Buffer,\n+        datatypes::Schema,\n+    };\n+    use arrow::{\n+        array::{Float32Array, Float64Array, Int16Array},\n+        datatypes::ToByteSlice,\n+    };\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_calculate_array_levels_twitter_example() {\n+        // based on the example at https://blog.twitter.com/engineering/en_us/a/2013/dremel-made-simple-with-parquet.html\n+        // [[a, b, c], [d, e, f, g]], [[h], [i,j]]\n+        let parent_levels = LevelInfo {\n+            definition: vec![0, 0],\n+            repetition: None,\n+            array_offsets: vec![0, 1, 2], // 2 records, root offsets always sequential\n+            array_mask: vec![true, true], // both lists defined\n+            max_definition: 0,\n+            is_list: false,     // root is never list\n+            is_nullable: false, // root in example is non-nullable\n+        };\n+        // offset into array, each level1 has 2 values\n+        let array_offsets = vec![0, 2, 4];\n+        let array_mask = vec![true, true];\n+\n+        // calculate level1 levels\n+        let levels = parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask,\n+            true,\n+            false,\n+        );\n+        //\n+        let expected_levels = LevelInfo {\n+            definition: vec![1, 1, 1, 1],\n+            repetition: Some(vec![0, 1, 0, 1]),\n+            array_offsets,\n+            array_mask: vec![true, true, true, true],\n+            max_definition: 1,\n+            is_list: true,\n+            is_nullable: false,\n+        };\n+        // the separate asserts make it easier to see what's failing\n+        assert_eq!(&levels.definition, &expected_levels.definition);\n+        assert_eq!(&levels.repetition, &expected_levels.repetition);\n+        assert_eq!(&levels.array_mask, &expected_levels.array_mask);\n+        assert_eq!(&levels.array_offsets, &expected_levels.array_offsets);\n+        assert_eq!(&levels.max_definition, &expected_levels.max_definition);\n+        assert_eq!(&levels.is_list, &expected_levels.is_list);\n+        assert_eq!(&levels.is_nullable, &expected_levels.is_nullable);\n+        // this assert is to help if there are more variables added to the struct\n+        assert_eq!(&levels, &expected_levels);\n+\n+        // level2\n+        let parent_levels = levels;\n+        let array_offsets = vec![0, 3, 7, 8, 10];\n+        let array_mask = vec![true, true, true, true];\n+        let levels = parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask,\n+            true,\n+            false,\n+        );\n+        let expected_levels = LevelInfo {\n+            definition: vec![2, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n+            repetition: Some(vec![0, 2, 2, 1, 2, 2, 2, 0, 1, 2]),\n+            array_offsets,\n+            array_mask: vec![true; 10],\n+            max_definition: 2,\n+            is_list: true,\n+            is_nullable: false,\n+        };\n+        assert_eq!(&levels.definition, &expected_levels.definition);\n+        assert_eq!(&levels.repetition, &expected_levels.repetition);\n+        assert_eq!(&levels.array_mask, &expected_levels.array_mask);\n+        assert_eq!(&levels.max_definition, &expected_levels.max_definition);\n+        assert_eq!(&levels.array_offsets, &expected_levels.array_offsets);\n+        assert_eq!(&levels.is_list, &expected_levels.is_list);\n+        assert_eq!(&levels.is_nullable, &expected_levels.is_nullable);\n+        assert_eq!(&levels, &expected_levels);\n+    }\n+\n+    #[test]\n+    fn test_calculate_one_level_1() {\n+        // This test calculates the levels for a non-null primitive array\n+        let parent_levels = LevelInfo {\n+            definition: vec![0; 10],\n+            repetition: None,\n+            array_offsets: (0..=10).collect(),\n+            array_mask: vec![true; 10],\n+            max_definition: 0,\n+            is_list: false,\n+            is_nullable: false,\n+        };\n+        let array_offsets: Vec<i64> = (0..=10).collect();\n+        let array_mask = vec![true; 10];\n+\n+        let levels = parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask.clone(),\n+            false,\n+            false,\n+        );\n+        let expected_levels = LevelInfo {\n+            definition: vec![1; 10],\n+            repetition: None,\n+            array_offsets,\n+            array_mask,\n+            max_definition: 1,\n+            is_list: false,\n+            is_nullable: false,\n+        };\n+        assert_eq!(&levels, &expected_levels);\n+    }\n+\n+    #[test]\n+    fn test_calculate_one_level_2() {\n+        // This test calculates the levels for a non-null primitive array\n+        let parent_levels = LevelInfo {\n+            definition: vec![0; 5],\n+            repetition: None,\n+            array_offsets: (0..=5).collect(),\n+            array_mask: vec![true, true, true, true, true],\n+            max_definition: 0,\n+            is_list: false,\n+            is_nullable: false,\n+        };\n+        let array_offsets: Vec<i64> = (0..=5).collect();\n+        let array_mask = vec![true, false, true, true, false];\n+\n+        let levels = parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask.clone(),\n+            false,\n+            true,\n+        );\n+        let expected_levels = LevelInfo {\n+            definition: vec![1, 0, 1, 1, 0],\n+            repetition: None,\n+            array_offsets,\n+            array_mask,\n+            max_definition: 1,\n+            is_list: false,\n+            is_nullable: true,\n+        };\n+        assert_eq!(&levels, &expected_levels);\n+    }\n+\n+    #[test]\n+    fn test_calculate_array_levels_1() {\n+        // if all array values are defined (e.g. batch<list<_>>)\n+        // [[0], [1], [2], [3], [4]]\n+        let parent_levels = LevelInfo {\n+            definition: vec![0; 5],\n+            repetition: None,\n+            array_offsets: vec![0, 1, 2, 3, 4, 5],\n+            array_mask: vec![true, true, true, true, true],\n+            max_definition: 0,\n+            is_list: false,\n+            is_nullable: false,\n+        };\n+        let array_offsets = vec![0, 2, 2, 4, 8, 11];\n+        let array_mask = vec![true, false, true, true, true];\n+\n+        let levels = parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask,\n+            true,\n+            true,\n+        );\n+        // array: [[0, 0], _1_, [2, 2], [3, 3, 3, 3], [4, 4, 4]]\n+        // all values are defined as we do not have nulls on the root (batch)\n+        // repetition:\n+        //   0: 0, 1\n+        //   1:\n+        //   2: 0, 1\n+        //   3: 0, 1, 1, 1\n+        //   4: 0, 1, 1\n+        let expected_levels = LevelInfo {\n+            definition: vec![2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n+            repetition: Some(vec![0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1]),\n+            array_offsets,\n+            array_mask: vec![\n+                true, true, false, true, true, true, true, true, true, true, true, true,\n+            ],\n+            max_definition: 2,\n+            is_list: true,\n+            is_nullable: true,\n+        };\n+        assert_eq!(&levels.definition, &expected_levels.definition);\n+        assert_eq!(&levels.repetition, &expected_levels.repetition);\n+        assert_eq!(&levels.array_offsets, &expected_levels.array_offsets);\n+        assert_eq!(&levels.max_definition, &expected_levels.max_definition);\n+        assert_eq!(&levels.is_list, &expected_levels.is_list);\n+        assert_eq!(&levels.is_nullable, &expected_levels.is_nullable);\n+        assert_eq!(&levels, &expected_levels);\n+    }\n+\n+    #[test]\n+    fn test_calculate_array_levels_2() {\n+        // If some values are null\n\nReview comment:\n       Some of these comments need updating. They're from 2-3 iterations ago, and though correct, they might be referring to incorrect definition levels relative to the test cases.\n\n##########\nFile path: rust/parquet/src/arrow/levels.rs\n##########\n@@ -294,40 +242,1158 @@ impl LevelInfo {\n                 // Need to check for these cases not implemented in C++:\n                 // - \"Writing DictionaryArray with nested dictionary type not yet supported\"\n                 // - \"Writing DictionaryArray with null encoded in dictionary type not yet supported\"\n-                vec![Self {\n-                    definition: self.get_primitive_def_levels(array, field),\n-                    repetition: self.repetition.clone(),\n-                    definition_mask: self.definition_mask.clone(),\n+                // vec![self.get_primitive_def_levels(array, field, array_mask)]\n+                vec![self.calculate_child_levels(\n+                    array_offsets,\n+                    array_mask,\n+                    false,\n+                    field.is_nullable(),\n+                )]\n+            }\n+        }\n+    }\n+\n+    /// Calculate child/leaf array levels.\n+    ///\n+    /// The algorithm works by incrementing definitions of array values based on whether:\n+    /// - a value is optional or required (is_nullable)\n+    /// - a list value is repeated + optional or required (is_list)\n+    ///\n+    /// *Examples:*\n+    ///\n+    /// A record batch always starts at a populated definition = level 0.\n+    /// When a batch only has a primitive, i.e. `<batch<primitive[a]>>, column `a`\n+    /// can only have a maximum level of 1 if it is not null.\n+    /// If it is not null, we increment by 1, such that the null slots will = level 1.\n+    /// The above applies to types that have no repetition (anything not a list or map).\n+    ///\n+    /// If a batch has lists, then we increment by up to 2 levels:\n+    /// - 1 level for the list\n+    /// - 1 level if the list itself is nullable\n+    ///\n+    /// A list's child then gets incremented using the above rules.\n+    ///\n+    /// A special case is when at the root of the schema. We always increment the\n+    /// level regardless of whether the child is nullable or not. If we do not do\n+    /// this, we could have a non-nullable array having a definition of 0.\n+    ///\n+    /// *Examples*\n+    ///\n+    /// A batch with only a primitive that's non-nullable. `<primitive[required]>`:\n+    /// * We don't increment the definition level as the array is not optional.\n+    /// * This would leave us with a definition of 0, so the special case applies.\n+    /// * The definition level becomes 1.\n+    ///\n+    /// A batch with only a primitive that's nullable. `<primitive[optional]>`:\n+    /// * The definition level becomes 1, as we increment it once.\n+    ///\n+    /// A batch with a single non-nullable list (both list and child not null):\n+    /// * We calculate the level twice, for the list, and for the child.\n+    /// * At the list, the level becomes 1, where 0 indicates that the list is\n+    ///  empty, and 1 says it's not (determined through offsets).\n+    /// * At the primitive level\n+    fn calculate_child_levels(\n+        &self,\n+        // we use 64-bit offsets to also accommodate large arrays\n+        array_offsets: Vec<i64>,\n+        array_mask: Vec<bool>,\n+        is_list: bool,\n+        is_nullable: bool,\n+    ) -> Self {\n+        let mut definition = vec![];\n+        let mut repetition = vec![];\n+        let mut merged_array_mask = vec![];\n+\n+        // determine the total level increment based on data types\n+        let max_definition = match is_list {\n+            false => {\n+                if self.max_definition == 0 {\n+                    1\n+                } else {\n+                    self.max_definition + is_nullable as i16\n+                }\n+            }\n+            true => self.max_definition + 1 + is_nullable as i16,\n+        };\n+\n+        match (self.is_list, is_list) {\n+            (false, false) => {\n+                self.definition\n+                    .iter()\n+                    .zip(array_mask.into_iter().zip(&self.array_mask))\n+                    .for_each(|(def, (child_mask, parent_mask))| {\n+                        merged_array_mask.push(*parent_mask && child_mask);\n+                        match (parent_mask, child_mask) {\n+                            (true, true) => {\n+                                definition.push(max_definition);\n+                            }\n+                            (true, false) => {\n+                                // The child is only legally null if its array is nullable.\n+                                // Thus parent's max_definition is lower\n+                                definition.push(if *def <= self.max_definition {\n+                                    *def\n+                                } else {\n+                                    self.max_definition\n+                                });\n+                            }\n+                            // if the parent was false, retain its definitions\n+                            (false, _) => {\n+                                definition.push(*def);\n+                            }\n+                        }\n+                    });\n+\n+                debug_assert_eq!(definition.len(), merged_array_mask.len());\n+\n+                Self {\n+                    definition,\n+                    repetition: self.repetition.clone(), // it's None\n+                    array_offsets,\n+                    array_mask: merged_array_mask,\n+                    max_definition,\n+                    is_list: false,\n+                    is_nullable,\n+                }\n+            }\n+            (true, true) => {\n+                // parent is a list or descendant of a list, and child is a list\n+                let reps = self.repetition.clone().unwrap();\n+                // Calculate the 2 list hierarchy definitions in advance\n+                // List is not empty, but null\n+                let l2 = max_definition - is_nullable as i16;\n+                // List is not empty, and not null\n+                let l3 = max_definition;\n+\n+                let mut nulls_seen = 0;\n+\n+                self.array_offsets.windows(2).for_each(|w| {\n+                    let start = w[0] as usize;\n+                    let end = w[1] as usize;\n+                    let parent_len = end - start;\n+\n+                    if parent_len == 0 {\n+                        // If the parent length is 0, there won't be a slot for the child\n+                        let index = start + nulls_seen;\n+                        definition.push(self.definition[index]);\n+                        repetition.push(0);\n+                        merged_array_mask.push(self.array_mask[index]);\n+                        nulls_seen += 1;\n+                    } else {\n+                        (start..end).for_each(|parent_index| {\n+                            let index = parent_index + nulls_seen;\n+\n+                            // parent is either defined at this level, or earlier\n+                            let parent_def = self.definition[index];\n+                            let parent_rep = reps[index];\n+                            let parent_mask = self.array_mask[index];\n+\n+                            // valid parent, index into children\n+                            let child_start = array_offsets[parent_index] as usize;\n+                            let child_end = array_offsets[parent_index + 1] as usize;\n+                            let child_len = child_end - child_start;\n+                            let child_mask = array_mask[parent_index];\n+                            let merged_mask = parent_mask && child_mask;\n+\n+                            if child_len == 0 {\n+                                definition.push(parent_def);\n+                                repetition.push(parent_rep);\n+                                merged_array_mask.push(merged_mask);\n+                            } else {\n+                                (child_start..child_end).for_each(|child_index| {\n+                                    let rep = match (\n+                                        parent_index == start,\n+                                        child_index == child_start,\n+                                    ) {\n+                                        (true, true) => parent_rep,\n+                                        (true, false) => parent_rep + 2,\n+                                        (false, true) => parent_rep,\n+                                        (false, false) => parent_rep + 1,\n+                                    };\n+\n+                                    definition.push(if !parent_mask {\n+                                        parent_def\n+                                    } else if child_mask {\n+                                        l3\n+                                    } else {\n+                                        l2\n+                                    });\n+                                    repetition.push(rep);\n+                                    merged_array_mask.push(merged_mask);\n+                                });\n+                            }\n+                        });\n+                    }\n+                });\n+\n+                debug_assert_eq!(definition.len(), merged_array_mask.len());\n+\n+                Self {\n+                    definition,\n+                    repetition: Some(repetition),\n+                    array_offsets,\n+                    array_mask: merged_array_mask,\n+                    max_definition,\n+                    is_list: true,\n+                    is_nullable,\n+                }\n+            }\n+            (true, false) => {\n+                // List and primitive (or struct).\n+                // The list can have more values than the primitive, indicating that there\n+                // are slots where the list is empty. We use a counter to track this behaviour.\n+                let mut nulls_seen = 0;\n+\n+                // let child_max_definition = list_max_definition + is_nullable as i16;\n+                // child values are a function of parent list offsets\n+                let reps = self.repetition.as_deref().unwrap();\n+                self.array_offsets.windows(2).for_each(|w| {\n+                    let start = w[0] as usize;\n+                    let end = w[1] as usize;\n+                    let parent_len = end - start;\n+\n+                    if parent_len == 0 {\n+                        let index = start + nulls_seen;\n+                        definition.push(self.definition[index]);\n+                        repetition.push(reps[index]);\n+                        merged_array_mask.push(self.array_mask[index]);\n+                        nulls_seen += 1;\n+                    } else {\n+                        // iterate through the array, adjusting child definitions for nulls\n+                        (start..end).for_each(|child_index| {\n+                            let index = child_index + nulls_seen;\n+                            let child_mask = array_mask[child_index];\n+                            let parent_mask = self.array_mask[index];\n+                            let parent_def = self.definition[index];\n+\n+                            if !parent_mask || parent_def < self.max_definition {\n+                                definition.push(parent_def);\n+                                repetition.push(reps[index]);\n+                                merged_array_mask.push(parent_mask);\n+                            } else {\n+                                definition.push(max_definition - !child_mask as i16);\n+                                repetition.push(reps[index]);\n+                                merged_array_mask.push(child_mask);\n+                            }\n+                        });\n+                    }\n+                });\n+\n+                debug_assert_eq!(definition.len(), merged_array_mask.len());\n+\n+                Self {\n+                    definition,\n+                    repetition: Some(repetition),\n                     array_offsets: self.array_offsets.clone(),\n-                    array_mask: self.array_mask.clone(),\n-                    is_list: self.is_list,\n-                    max_definition: level,\n-                    is_nullable: field.is_nullable(),\n-                }]\n+                    array_mask: merged_array_mask,\n+                    max_definition,\n+                    is_list: true,\n+                    is_nullable,\n+                }\n+            }\n+            (false, true) => {\n+                // Encountering a list for the first time.\n+                // Calculate the 2 list hierarchy definitions in advance\n+\n+                // List is not empty, but null (if nullable)\n+                let l2 = max_definition - is_nullable as i16;\n+                // List is not empty, and not null\n+                let l3 = max_definition;\n+\n+                self.definition\n+                    .iter()\n+                    .enumerate()\n+                    .for_each(|(parent_index, def)| {\n+                        let child_from = array_offsets[parent_index];\n+                        let child_to = array_offsets[parent_index + 1];\n+                        let child_len = child_to - child_from;\n+                        let child_mask = array_mask[parent_index];\n+                        let parent_mask = self.array_mask[parent_index];\n+\n+                        match (parent_mask, child_len) {\n+                            (true, 0) => {\n+                                // empty slot that is valid, i.e. {\"parent\": {\"child\": [] } }\n+                                definition.push(if child_mask {\n+                                    l2\n+                                } else {\n+                                    self.max_definition\n+                                });\n+                                repetition.push(0);\n+                                merged_array_mask.push(child_mask);\n+                            }\n+                            (false, 0) => {\n+                                definition.push(*def);\n+                                repetition.push(0);\n+                                merged_array_mask.push(child_mask);\n+                            }\n+                            (true, _) => {\n+                                (child_from..child_to).for_each(|child_index| {\n+                                    definition.push(if child_mask { l3 } else { l2 });\n+                                    // mark the first child slot as 0, and the next as 1\n+                                    repetition.push(if child_index == child_from {\n+                                        0\n+                                    } else {\n+                                        1\n+                                    });\n+                                    merged_array_mask.push(child_mask);\n+                                });\n+                            }\n+                            (false, _) => {\n+                                (child_from..child_to).for_each(|child_index| {\n+                                    definition.push(*def);\n+                                    // mark the first child slot as 0, and the next as 1\n+                                    repetition.push(if child_index == child_from {\n+                                        0\n+                                    } else {\n+                                        1\n+                                    });\n+                                    merged_array_mask.push(false);\n+                                });\n+                            }\n+                        }\n+                    });\n+\n+                debug_assert_eq!(definition.len(), merged_array_mask.len());\n+\n+                Self {\n+                    definition,\n+                    repetition: Some(repetition),\n+                    array_offsets,\n+                    array_mask: merged_array_mask,\n+                    max_definition,\n+                    is_list: true,\n+                    is_nullable,\n+                }\n             }\n         }\n     }\n \n-    /// Get the definition levels of the numeric array, with level 0 being null and 1 being not null\n-    /// In the case where the array in question is a child of either a list or struct, the levels\n-    /// are incremented in accordance with the `level` parameter.\n-    /// Parent levels are either 0 or 1, and are used to higher (correct terminology?) leaves as null\n-    fn get_primitive_def_levels(&self, array: &ArrayRef, field: &Field) -> Vec<i16> {\n-        let mut array_index = 0;\n-        let max_def_level = self.definition.iter().max().unwrap();\n-        let mut primitive_def_levels = vec![];\n-        self.definition.iter().for_each(|def_level| {\n-            if !field.is_nullable() && *max_def_level > 1 {\n-                primitive_def_levels.push(*def_level - 1);\n-                array_index += 1;\n-            } else if def_level < max_def_level {\n-                primitive_def_levels.push(*def_level);\n-                array_index += 1;\n-            } else {\n-                primitive_def_levels.push(def_level - array.is_null(array_index) as i16);\n-                array_index += 1;\n+    /// Get the offsets of an array as 64-bit values, and validity masks as booleans\n+    /// - Primitive, binary and struct arrays' offsets will be a sequence, masks obtained from validity bitmap\n+    /// - List array offsets will be the value offsets, masks are computed from offsets\n+    fn get_array_offsets_and_masks(array: &ArrayRef) -> (Vec<i64>, Vec<bool>) {\n+        match array.data_type() {\n+            DataType::Null\n+            | DataType::Boolean\n+            | DataType::Int8\n+            | DataType::Int16\n+            | DataType::Int32\n+            | DataType::Int64\n+            | DataType::UInt8\n+            | DataType::UInt16\n+            | DataType::UInt32\n+            | DataType::UInt64\n+            | DataType::Float16\n+            | DataType::Float32\n+            | DataType::Float64\n+            | DataType::Timestamp(_, _)\n+            | DataType::Date32(_)\n+            | DataType::Date64(_)\n+            | DataType::Time32(_)\n+            | DataType::Time64(_)\n+            | DataType::Duration(_)\n+            | DataType::Interval(_)\n+            | DataType::Binary\n+            | DataType::LargeBinary\n+            | DataType::Utf8\n+            | DataType::LargeUtf8\n+            | DataType::Struct(_)\n+            | DataType::Dictionary(_, _)\n+            | DataType::Decimal(_, _) => {\n+                let array_mask = match array.data().null_buffer() {\n+                    Some(buf) => get_bool_array_slice(buf, array.offset(), array.len()),\n+                    None => vec![true; array.len()],\n+                };\n+                ((0..=(array.len() as i64)).collect(), array_mask)\n+            }\n+            DataType::List(_) => {\n+                let data = array.data();\n+                let offsets = unsafe { data.buffers()[0].typed_data::<i32>() };\n+                let offsets = offsets\n+                    .to_vec()\n+                    .into_iter()\n+                    .map(|v| v as i64)\n+                    .collect::<Vec<i64>>();\n+                let masks = offsets.windows(2).map(|w| w[1] > w[0]).collect();\n+                (offsets, masks)\n+            }\n+            DataType::LargeList(_) => {\n+                let offsets =\n+                    unsafe { array.data().buffers()[0].typed_data::<i64>() }.to_vec();\n+                let masks = offsets.windows(2).map(|w| w[1] > w[0]).collect();\n+                (offsets, masks)\n+            }\n+            DataType::FixedSizeBinary(_)\n+            | DataType::FixedSizeList(_, _)\n+            | DataType::Union(_) => {\n+                unimplemented!(\"Getting offsets not yet implemented\")\n+            }\n+        }\n+    }\n+\n+    /// Given a level's information, calculate the offsets required to index an array correctly.\n+    pub(crate) fn filter_array_indices(&self) -> Vec<usize> {\n+        // happy path if not dealing with lists\n+        if !self.is_list {\n+            return self\n+                .definition\n+                .iter()\n+                .enumerate()\n+                .filter_map(|(i, def)| {\n+                    if *def == self.max_definition {\n+                        Some(i)\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .collect();\n+        }\n+        let mut filtered = vec![];\n+        // remove slots that are false from definition_mask\n+        let mut index = 0;\n+        self.definition.iter().for_each(|def| {\n+            if *def == self.max_definition {\n+                filtered.push(index);\n+            }\n+            if *def >= self.max_definition - self.is_nullable as i16 {\n+                index += 1;\n             }\n         });\n-        primitive_def_levels\n+        filtered\n+    }\n+}\n+\n+/// Convert an Arrow buffer to a boolean array slice\n+/// TODO: this was created for buffers, so might not work for bool array, might be slow too\n+#[inline]\n+fn get_bool_array_slice(\n+    buffer: &arrow::buffer::Buffer,\n+    offset: usize,\n+    len: usize,\n+) -> Vec<bool> {\n+    let data = buffer.as_slice();\n+    (offset..(len + offset))\n+        .map(|i| arrow::util::bit_util::get_bit(data, i))\n+        .collect()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::sync::Arc;\n+\n+    use arrow::{\n+        array::ListArray,\n+        array::{Array, ArrayData, Int32Array},\n+        buffer::Buffer,\n+        datatypes::Schema,\n+    };\n+    use arrow::{\n+        array::{Float32Array, Float64Array, Int16Array},\n+        datatypes::ToByteSlice,\n+    };\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_calculate_array_levels_twitter_example() {\n+        // based on the example at https://blog.twitter.com/engineering/en_us/a/2013/dremel-made-simple-with-parquet.html\n+        // [[a, b, c], [d, e, f, g]], [[h], [i,j]]\n+        let parent_levels = LevelInfo {\n+            definition: vec![0, 0],\n+            repetition: None,\n+            array_offsets: vec![0, 1, 2], // 2 records, root offsets always sequential\n+            array_mask: vec![true, true], // both lists defined\n+            max_definition: 0,\n+            is_list: false,     // root is never list\n+            is_nullable: false, // root in example is non-nullable\n+        };\n+        // offset into array, each level1 has 2 values\n+        let array_offsets = vec![0, 2, 4];\n+        let array_mask = vec![true, true];\n+\n+        // calculate level1 levels\n+        let levels = parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask,\n+            true,\n+            false,\n+        );\n+        //\n+        let expected_levels = LevelInfo {\n+            definition: vec![1, 1, 1, 1],\n+            repetition: Some(vec![0, 1, 0, 1]),\n+            array_offsets,\n+            array_mask: vec![true, true, true, true],\n+            max_definition: 1,\n+            is_list: true,\n+            is_nullable: false,\n+        };\n+        // the separate asserts make it easier to see what's failing\n+        assert_eq!(&levels.definition, &expected_levels.definition);\n+        assert_eq!(&levels.repetition, &expected_levels.repetition);\n+        assert_eq!(&levels.array_mask, &expected_levels.array_mask);\n+        assert_eq!(&levels.array_offsets, &expected_levels.array_offsets);\n+        assert_eq!(&levels.max_definition, &expected_levels.max_definition);\n+        assert_eq!(&levels.is_list, &expected_levels.is_list);\n+        assert_eq!(&levels.is_nullable, &expected_levels.is_nullable);\n+        // this assert is to help if there are more variables added to the struct\n+        assert_eq!(&levels, &expected_levels);\n+\n+        // level2\n+        let parent_levels = levels;\n+        let array_offsets = vec![0, 3, 7, 8, 10];\n+        let array_mask = vec![true, true, true, true];\n+        let levels = parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask,\n+            true,\n+            false,\n+        );\n+        let expected_levels = LevelInfo {\n+            definition: vec![2, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n+            repetition: Some(vec![0, 2, 2, 1, 2, 2, 2, 0, 1, 2]),\n+            array_offsets,\n+            array_mask: vec![true; 10],\n+            max_definition: 2,\n+            is_list: true,\n+            is_nullable: false,\n+        };\n+        assert_eq!(&levels.definition, &expected_levels.definition);\n+        assert_eq!(&levels.repetition, &expected_levels.repetition);\n+        assert_eq!(&levels.array_mask, &expected_levels.array_mask);\n+        assert_eq!(&levels.max_definition, &expected_levels.max_definition);\n+        assert_eq!(&levels.array_offsets, &expected_levels.array_offsets);\n+        assert_eq!(&levels.is_list, &expected_levels.is_list);\n+        assert_eq!(&levels.is_nullable, &expected_levels.is_nullable);\n+        assert_eq!(&levels, &expected_levels);\n+    }\n+\n+    #[test]\n+    fn test_calculate_one_level_1() {\n+        // This test calculates the levels for a non-null primitive array\n+        let parent_levels = LevelInfo {\n+            definition: vec![0; 10],\n+            repetition: None,\n+            array_offsets: (0..=10).collect(),\n+            array_mask: vec![true; 10],\n+            max_definition: 0,\n+            is_list: false,\n+            is_nullable: false,\n+        };\n+        let array_offsets: Vec<i64> = (0..=10).collect();\n+        let array_mask = vec![true; 10];\n+\n+        let levels = parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask.clone(),\n+            false,\n+            false,\n+        );\n+        let expected_levels = LevelInfo {\n+            definition: vec![1; 10],\n+            repetition: None,\n+            array_offsets,\n+            array_mask,\n+            max_definition: 1,\n+            is_list: false,\n+            is_nullable: false,\n+        };\n+        assert_eq!(&levels, &expected_levels);\n+    }\n+\n+    #[test]\n+    fn test_calculate_one_level_2() {\n+        // This test calculates the levels for a non-null primitive array\n+        let parent_levels = LevelInfo {\n+            definition: vec![0; 5],\n+            repetition: None,\n+            array_offsets: (0..=5).collect(),\n+            array_mask: vec![true, true, true, true, true],\n+            max_definition: 0,\n+            is_list: false,\n+            is_nullable: false,\n+        };\n+        let array_offsets: Vec<i64> = (0..=5).collect();\n+        let array_mask = vec![true, false, true, true, false];\n+\n+        let levels = parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask.clone(),\n+            false,\n+            true,\n+        );\n+        let expected_levels = LevelInfo {\n+            definition: vec![1, 0, 1, 1, 0],\n+            repetition: None,\n+            array_offsets,\n+            array_mask,\n+            max_definition: 1,\n+            is_list: false,\n+            is_nullable: true,\n+        };\n+        assert_eq!(&levels, &expected_levels);\n+    }\n+\n+    #[test]\n+    fn test_calculate_array_levels_1() {\n+        // if all array values are defined (e.g. batch<list<_>>)\n+        // [[0], [1], [2], [3], [4]]\n+        let parent_levels = LevelInfo {\n+            definition: vec![0; 5],\n+            repetition: None,\n+            array_offsets: vec![0, 1, 2, 3, 4, 5],\n+            array_mask: vec![true, true, true, true, true],\n+            max_definition: 0,\n+            is_list: false,\n+            is_nullable: false,\n+        };\n+        let array_offsets = vec![0, 2, 2, 4, 8, 11];\n+        let array_mask = vec![true, false, true, true, true];\n+\n+        let levels = parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask,\n+            true,\n+            true,\n+        );\n+        // array: [[0, 0], _1_, [2, 2], [3, 3, 3, 3], [4, 4, 4]]\n+        // all values are defined as we do not have nulls on the root (batch)\n+        // repetition:\n+        //   0: 0, 1\n+        //   1:\n+        //   2: 0, 1\n+        //   3: 0, 1, 1, 1\n+        //   4: 0, 1, 1\n+        let expected_levels = LevelInfo {\n+            definition: vec![2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n+            repetition: Some(vec![0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1]),\n+            array_offsets,\n+            array_mask: vec![\n+                true, true, false, true, true, true, true, true, true, true, true, true,\n+            ],\n+            max_definition: 2,\n+            is_list: true,\n+            is_nullable: true,\n+        };\n+        assert_eq!(&levels.definition, &expected_levels.definition);\n+        assert_eq!(&levels.repetition, &expected_levels.repetition);\n+        assert_eq!(&levels.array_offsets, &expected_levels.array_offsets);\n+        assert_eq!(&levels.max_definition, &expected_levels.max_definition);\n+        assert_eq!(&levels.is_list, &expected_levels.is_list);\n+        assert_eq!(&levels.is_nullable, &expected_levels.is_nullable);\n+        assert_eq!(&levels, &expected_levels);\n+    }\n+\n+    #[test]\n+    fn test_calculate_array_levels_2() {\n+        // If some values are null\n+        //\n+        // This emulates an array in the form: <struct<list<?>>\n+        // with values:\n+        // - 0: [0, 1], but is null because of the struct\n+        // - 1: []\n+        // - 2: [2, 3], but is null because of the struct\n+        // - 3: [4, 5, 6, 7]\n+        // - 4: [8, 9, 10]\n+        //\n+        // If the first values of a list are null due to a parent, we have to still account for them\n+        // while indexing, because they would affect the way the child is indexed\n+        // i.e. in the above example, we have to know that [0, 1] has to be skipped\n+        let parent_levels = LevelInfo {\n+            definition: vec![0, 1, 0, 1, 1],\n+            repetition: None,\n+            array_offsets: vec![0, 1, 2, 3, 4, 5],\n+            array_mask: vec![false, true, false, true, true],\n+            max_definition: 1,\n+            is_list: false,\n+            is_nullable: true,\n+        };\n+        let array_offsets = vec![0, 2, 2, 4, 8, 11];\n+        let array_mask = vec![true, false, true, true, true];\n+\n+        let levels = parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask,\n+            true,\n+            true,\n+        );\n+        let expected_levels = LevelInfo {\n+            // 0 1 [2] are 0 (not defined at level 1)\n+            // [2] is 1, but has 0 slots so is not populated (defined at level 1 only)\n+            // 2 3 [4] are 0\n+            // 4 5 6 7 [8] are 1 (defined at level 1 only)\n+            // 8 9 10 [11] are 2 (defined at both levels)\n+            definition: vec![0, 0, 1, 0, 0, 3, 3, 3, 3, 3, 3, 3],\n+            repetition: Some(vec![0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1]),\n+            array_offsets,\n+            array_mask: vec![\n+                false, false, false, false, false, true, true, true, true, true, true,\n+                true,\n+            ],\n+            max_definition: 3,\n+            is_nullable: true,\n+            is_list: true,\n+        };\n+        assert_eq!(&levels.definition, &expected_levels.definition);\n+        assert_eq!(&levels.repetition, &expected_levels.repetition);\n+        assert_eq!(&levels.array_offsets, &expected_levels.array_offsets);\n+        assert_eq!(&levels.max_definition, &expected_levels.max_definition);\n+        assert_eq!(&levels.is_list, &expected_levels.is_list);\n+        assert_eq!(&levels.is_nullable, &expected_levels.is_nullable);\n+        assert_eq!(&levels, &expected_levels);\n+\n+        // nested lists (using previous test)\n+        let nested_parent_levels = levels;\n+        let array_offsets = vec![0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22];\n+        let array_mask = vec![\n+            true, true, true, true, true, true, true, true, true, true, true,\n+        ];\n+        let levels = nested_parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask,\n+            true,\n+            true,\n+        );\n+        let expected_levels = LevelInfo {\n+            // (def: 0) 0 1 [2] are 0 (take parent)\n+            // (def: 0) 2 3 [4] are 0 (take parent)\n+            // (def: 0) 4 5 [6] are 0 (take parent)\n+            // (def: 0) 6 7 [8] are 0 (take parent)\n+            // (def: 1) 8 9 [10] are 1 (take parent)\n+            // (def: 1) 10 11 [12] are 1 (take parent)\n+            // (def: 1) 12 23 [14] are 1 (take parent)\n+            // (def: 1) 14 15 [16] are 1 (take parent)\n+            // (def: 2) 16 17 [18] are 2 (defined at all levels)\n+            // (def: 2) 18 19 [20] are 2 (defined at all levels)\n+            // (def: 2) 20 21 [22] are 2 (defined at all levels)\n+            //\n+            // 0 1 [2] are 0 (not defined at level 1)\n+            // [2] is 1, but has 0 slots so is not populated (defined at level 1 only)\n+            // 2 3 [4] are 0\n+            // 4 5 6 7 [8] are 1 (defined at level 1 only)\n+            // 8 9 10 [11] are 2 (defined at both levels)\n+            //\n+            // 0: [[100, 101], [102, 103]]\n+            // 1: []\n+            // 2: [[104, 105], [106, 107]]\n+            // 3: [[108, 109], [110, 111], [112, 113], [114, 115]]\n+            // 4: [[116, 117], [118, 119], [120, 121]]\n+            definition: vec![\n+                0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+            ],\n+            repetition: Some(vec![\n+                0, 2, 1, 2, 0, 0, 2, 1, 2, 0, 2, 1, 2, 1, 2, 1, 2, 0, 2, 1, 2, 1, 2,\n+            ]),\n+            array_offsets,\n+            array_mask: vec![\n+                false, false, false, false, false, false, false, false, false, true,\n+                true, true, true, true, true, true, true, true, true, true, true, true,\n+                true,\n+            ],\n+            max_definition: 5,\n+            is_nullable: true,\n+            is_list: true,\n+        };\n+        assert_eq!(&levels.definition, &expected_levels.definition);\n+        assert_eq!(&levels.repetition, &expected_levels.repetition);\n+        assert_eq!(&levels.array_offsets, &expected_levels.array_offsets);\n+        assert_eq!(&levels.array_mask, &expected_levels.array_mask);\n+        assert_eq!(&levels.max_definition, &expected_levels.max_definition);\n+        assert_eq!(&levels.is_list, &expected_levels.is_list);\n+        assert_eq!(&levels.is_nullable, &expected_levels.is_nullable);\n+        assert_eq!(&levels, &expected_levels);\n+    }\n+\n+    #[test]\n+    fn test_calculate_array_levels_nested_list() {\n+        // if all array values are defined (e.g. batch<list<_>>)\n+        // The array at this level looks like:\n+        // 0: [a]\n+        // 1: [a]\n+        // 2: [a]\n+        // 3: [a]\n+        let parent_levels = LevelInfo {\n+            definition: vec![1, 1, 1, 1],\n+            repetition: None,\n+            array_offsets: vec![0, 1, 2, 3, 4],\n+            array_mask: vec![true, true, true, true],\n+            max_definition: 1,\n+            is_list: false,\n+            is_nullable: false,\n+        };\n+        // 0: null ([], but mask is false, so it's not just an empty list)\n+        // 1: [1, 2, 3]\n+        // 2: [4, 5]\n+        // 3: [6, 7]\n+        let array_offsets = vec![0, 1, 4, 6, 8];\n+        let array_mask = vec![false, true, true, true];\n+\n+        let levels = parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask,\n+            true,\n+            true,\n+        );\n+        // 0: [null], level 1 is defined, but not 2\n+        // 1: [1, 2, 3]\n+        // 2: [4, 5]\n+        // 3: [6, 7]\n+        let expected_levels = LevelInfo {\n+            definition: vec![2, 3, 3, 3, 3, 3, 3, 3],\n+            repetition: Some(vec![0, 0, 1, 1, 0, 1, 0, 1]),\n+            array_offsets,\n+            array_mask: vec![false, true, true, true, true, true, true, true],\n+            max_definition: 3,\n+            is_list: true,\n+            is_nullable: true,\n+        };\n+        assert_eq!(&levels.definition, &expected_levels.definition);\n+        assert_eq!(&levels.repetition, &expected_levels.repetition);\n+        assert_eq!(&levels.array_offsets, &expected_levels.array_offsets);\n+        assert_eq!(&levels.max_definition, &expected_levels.max_definition);\n+        assert_eq!(&levels.is_list, &expected_levels.is_list);\n+        assert_eq!(&levels.is_nullable, &expected_levels.is_nullable);\n+        assert_eq!(&levels, &expected_levels);\n+\n+        // nested lists (using previous test)\n+        let nested_parent_levels = levels;\n+        // 0: [null] (was a populated null slot at the parent)\n+        // 1: [201]\n+        // 2: [202, 203]\n+        // 3: null ([])\n+        // 4: [204, 205, 206]\n+        // 5: [207, 208, 209, 210]\n+        // 6: [] (tests a non-null empty list slot)\n+        // 7: [211, 212, 213, 214, 215]\n+        let array_offsets = vec![0, 1, 2, 4, 4, 7, 11, 11, 16];\n+        // logically, the fist slot of the mask is false\n+        let array_mask = vec![true, true, true, false, true, true, true, true];\n+        let levels = nested_parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask,\n+            true,\n+            true,\n+        );\n+        // We have 7 array values, and at least 15 primitives (from array_offsets)\n+        // 0: (-)[null], parent was null, no value populated here\n+        // 1: (0)[201], (1)[202, 203], (2)[[null]]\n+        // 2: (3)[204, 205, 206], (4)[207, 208, 209, 210]\n+        // 3: (5)[[]], (6)[211, 212, 213, 214, 215]\n+        //\n+        // In a JSON syntax with the schema: <struct<list<list<primitive>>>>, this translates into:\n+        // 0: {\"struct\": [ null ]}\n+        // 1: {\"struct\": [ [201], [202, 203], [] ]}\n+        // 2: {\"struct\": [ [204, 205, 206], [207, 208, 209, 210] ]}\n+        // 3: {\"struct\": [ [], [211, 212, 213, 214, 215] ]}\n+        let expected_levels = LevelInfo {\n+            definition: vec![2, 5, 5, 5, 3, 5, 5, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5],\n+            repetition: Some(vec![0, 0, 1, 2, 1, 0, 2, 2, 1, 2, 2, 2, 0, 1, 2, 2, 2, 2]),\n+            array_mask: vec![\n+                false, true, true, true, false, true, true, true, true, true, true, true,\n+                true, true, true, true, true, true,\n+            ],\n+            array_offsets,\n+            is_list: true,\n+            is_nullable: true,\n+            max_definition: 5,\n+        };\n+        assert_eq!(&levels.definition, &expected_levels.definition);\n+        assert_eq!(&levels.repetition, &expected_levels.repetition);\n+        assert_eq!(&levels.array_offsets, &expected_levels.array_offsets);\n+        assert_eq!(&levels.array_mask, &expected_levels.array_mask);\n+        assert_eq!(&levels.max_definition, &expected_levels.max_definition);\n+        assert_eq!(&levels.is_list, &expected_levels.is_list);\n+        assert_eq!(&levels.is_nullable, &expected_levels.is_nullable);\n+        assert_eq!(&levels, &expected_levels);\n+    }\n+\n+    #[test]\n+    fn test_calculate_nested_struct_levels() {\n+        // tests a <struct[a]<struct[b]<int[c]>>\n+        // array:\n+        //  - {a: {b: {c: 1}}}\n+        //  - {a: {b: {c: null}}}\n+        //  - {a: {b: {c: 3}}}\n+        //  - {a: {b: null}}\n+        //  - {a: null}}\n+        //  - {a: {b: {c: 6}}}\n+        let a_levels = LevelInfo {\n+            definition: vec![1, 1, 1, 1, 0, 1],\n+            repetition: None,\n+            array_offsets: (0..=6).collect(),\n+            array_mask: vec![true, true, true, true, false, true],\n+            max_definition: 1,\n+            is_list: false,\n+            is_nullable: true,\n+        };\n+        // b's offset and mask\n+        let b_offsets: Vec<i64> = (0..=6).collect();\n+        let b_mask = vec![true, true, true, false, false, true];\n+        // b's expected levels\n+        let b_expected_levels = LevelInfo {\n+            definition: vec![2, 2, 2, 1, 0, 2],\n+            repetition: None,\n+            array_offsets: (0..=6).collect(),\n+            array_mask: vec![true, true, true, false, false, true],\n+            max_definition: 2,\n+            is_list: false,\n+            is_nullable: true,\n+        };\n+        let b_levels =\n+            a_levels.calculate_child_levels(b_offsets.clone(), b_mask, false, true);\n+        assert_eq!(&b_expected_levels, &b_levels);\n+\n+        // c's offset and mask\n+        let c_offsets = b_offsets;\n+        let c_mask = vec![true, false, true, false, false, true];\n+        // c's expected levels\n+        let c_expected_levels = LevelInfo {\n+            definition: vec![3, 2, 3, 1, 0, 3],\n+            repetition: None,\n+            array_offsets: c_offsets.clone(),\n+            array_mask: vec![true, false, true, false, false, true],\n+            max_definition: 3,\n+            is_list: false,\n+            is_nullable: true,\n+        };\n+        let c_levels = b_levels.calculate_child_levels(c_offsets, c_mask, false, true);\n+        assert_eq!(&c_expected_levels, &c_levels);\n+    }\n+\n+    #[test]\n+    fn list_single_column() {\n+        // this tests the level generation from the arrow_writer equivalent test\n+\n+        let a_values = Int32Array::from(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+        let a_value_offsets =\n+            arrow::buffer::Buffer::from(&[0, 1, 3, 3, 6, 10].to_byte_slice());\n+        let a_list_type =\n+            DataType::List(Box::new(Field::new(\"item\", DataType::Int32, true)));\n+        let a_list_data = ArrayData::builder(a_list_type.clone())\n+            .len(5)\n+            .add_buffer(a_value_offsets)\n+            .null_bit_buffer(Buffer::from(vec![0b00011011]))\n+            .add_child_data(a_values.data())\n+            .build();\n+\n+        assert_eq!(a_list_data.null_count(), 1);\n+\n+        let a = ListArray::from(a_list_data);\n+        let values = Arc::new(a);\n+\n+        let schema = Schema::new(vec![Field::new(\"item\", a_list_type, true)]);\n+\n+        let batch = RecordBatch::try_new(Arc::new(schema), vec![values]).unwrap();\n+\n+        let expected_batch_level = LevelInfo {\n+            definition: vec![0; 5],\n+            repetition: None,\n+            array_offsets: (0..=5).collect(),\n+            array_mask: vec![true, true, true, true, true],\n+            max_definition: 0,\n+            is_list: false,\n+            is_nullable: false,\n+        };\n+\n+        let batch_level = LevelInfo::new_from_batch(&batch);\n+        assert_eq!(&batch_level, &expected_batch_level);\n+\n+        // calculate the list's level\n+        let mut levels = vec![];\n+        batch\n+            .columns()\n+            .iter()\n+            .zip(batch.schema().fields())\n+            .for_each(|(array, field)| {\n+                let mut array_levels = batch_level.calculate_array_levels(array, field);\n+                levels.append(&mut array_levels);\n+            });\n+        assert_eq!(levels.len(), 1);\n+\n+        let list_level = levels.get(0).unwrap();\n+\n+        let expected_level = LevelInfo {\n+            definition: vec![3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 3],\n+            repetition: Some(vec![0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1]),\n+            array_offsets: vec![0, 1, 3, 3, 6, 10],\n+            array_mask: vec![\n+                true, true, true, false, true, true, true, true, true, true, true,\n+            ],\n+            max_definition: 3,\n+            is_list: true,\n+            is_nullable: true,\n+        };\n+        assert_eq!(&list_level.definition, &expected_level.definition);\n+        assert_eq!(&list_level.repetition, &expected_level.repetition);\n+        assert_eq!(&list_level.array_offsets, &expected_level.array_offsets);\n+        assert_eq!(&list_level.array_mask, &expected_level.array_mask);\n+        assert_eq!(&list_level.max_definition, &expected_level.max_definition);\n+        assert_eq!(&list_level.is_list, &expected_level.is_list);\n+        assert_eq!(&list_level.is_nullable, &expected_level.is_nullable);\n+        assert_eq!(list_level, &expected_level);\n+    }\n+\n+    #[test]\n+    fn mixed_struct_list() {\n+        // this tests the level generation from the equivalent arrow_writer_complex test\n+\n+        // define schema\n+        let struct_field_d = Field::new(\"d\", DataType::Float64, true);\n+        let struct_field_f = Field::new(\"f\", DataType::Float32, true);\n+        let struct_field_g = Field::new(\n+            \"g\",\n+            DataType::List(Box::new(Field::new(\"items\", DataType::Int16, false))),\n+            false,\n+        );\n+        let struct_field_e = Field::new(\n+            \"e\",\n+            DataType::Struct(vec![struct_field_f.clone(), struct_field_g.clone()]),\n+            true,\n+        );\n+        let schema = Schema::new(vec![\n+            Field::new(\"a\", DataType::Int32, false),\n+            Field::new(\"b\", DataType::Int32, true),\n+            Field::new(\n+                \"c\",\n+                DataType::Struct(vec![struct_field_d.clone(), struct_field_e.clone()]),\n+                false,\n+            ),\n+        ]);\n+\n+        // create some data\n+        let a = Int32Array::from(vec![1, 2, 3, 4, 5]);\n+        let b = Int32Array::from(vec![Some(1), None, None, Some(4), Some(5)]);\n+        let d = Float64Array::from(vec![None, None, None, Some(1.0), None]);\n+        let f = Float32Array::from(vec![Some(0.0), None, Some(333.3), None, Some(5.25)]);\n+\n+        let g_value = Int16Array::from(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+\n+        // Construct a buffer for value offsets, for the nested array:\n+        //  [[1], [2, 3], null, [4, 5, 6], [7, 8, 9, 10]]\n+        let g_value_offsets =\n+            arrow::buffer::Buffer::from(&[0, 1, 3, 3, 6, 10].to_byte_slice());\n+\n+        // Construct a list array from the above two\n+        let g_list_data = ArrayData::builder(struct_field_g.data_type().clone())\n+            .len(5)\n+            .add_buffer(g_value_offsets)\n+            .add_child_data(g_value.data())\n+            .build();\n+        let g = ListArray::from(g_list_data);\n+\n+        let e = StructArray::from(vec![\n+            (struct_field_f, Arc::new(f) as ArrayRef),\n+            (struct_field_g, Arc::new(g) as ArrayRef),\n+        ]);\n+\n+        let c = StructArray::from(vec![\n+            (struct_field_d, Arc::new(d) as ArrayRef),\n+            (struct_field_e, Arc::new(e) as ArrayRef),\n+        ]);\n+\n+        // build a record batch\n+        let batch = RecordBatch::try_new(\n+            Arc::new(schema),\n+            vec![Arc::new(a), Arc::new(b), Arc::new(c)],\n+        )\n+        .unwrap();\n+\n+        //////////////////////////////////////////////\n+        let expected_batch_level = LevelInfo {\n+            definition: vec![0; 5],\n+            repetition: None,\n+            array_offsets: (0..=5).collect(),\n+            array_mask: vec![true, true, true, true, true],\n+            max_definition: 0,\n+            is_list: false,\n+            is_nullable: false,\n+        };\n+\n+        let batch_level = LevelInfo::new_from_batch(&batch);\n+        assert_eq!(&batch_level, &expected_batch_level);\n+\n+        // calculate the list's level\n+        let mut levels = vec![];\n+        batch\n+            .columns()\n+            .iter()\n+            .zip(batch.schema().fields())\n+            .for_each(|(array, field)| {\n+                let mut array_levels = batch_level.calculate_array_levels(array, field);\n+                levels.append(&mut array_levels);\n+            });\n+        assert_eq!(levels.len(), 5);\n+\n+        // test \"a\" levels\n+        let list_level = levels.get(0).unwrap();\n+\n+        let expected_level = LevelInfo {\n+            definition: vec![1, 1, 1, 1, 1],\n+            repetition: None,\n+            array_offsets: vec![0, 1, 2, 3, 4, 5],\n+            array_mask: vec![true, true, true, true, true],\n+            max_definition: 1,\n+            is_list: false,\n+            is_nullable: false,\n+        };\n+        assert_eq!(list_level, &expected_level);\n+\n+        // test \"b\" levels\n+        let list_level = levels.get(1).unwrap();\n+\n+        let expected_level = LevelInfo {\n+            definition: vec![1, 0, 0, 1, 1],\n+            repetition: None,\n+            array_offsets: vec![0, 1, 2, 3, 4, 5],\n+            array_mask: vec![true, false, false, true, true],\n+            max_definition: 1,\n+            is_list: false,\n+            is_nullable: true,\n+        };\n+        assert_eq!(list_level, &expected_level);\n+\n+        // test \"d\" levels\n+        let list_level = levels.get(2).unwrap();\n+\n+        let expected_level = LevelInfo {\n+            definition: vec![1, 1, 1, 2, 1],\n+            repetition: None,\n+            array_offsets: vec![0, 1, 2, 3, 4, 5],\n+            array_mask: vec![false, false, false, true, false],\n+            max_definition: 2,\n+            is_list: false,\n+            is_nullable: true,\n+        };\n+        assert_eq!(list_level, &expected_level);\n+\n+        // test \"f\" levels\n+        let list_level = levels.get(3).unwrap();\n+\n+        let expected_level = LevelInfo {\n+            definition: vec![3, 2, 3, 2, 3],\n+            repetition: None,\n+            array_offsets: vec![0, 1, 2, 3, 4, 5],\n+            array_mask: vec![true, false, true, false, true],\n+            max_definition: 3,\n+            is_list: false,\n+            is_nullable: true,\n+        };\n+        assert_eq!(list_level, &expected_level);\n+    }\n+\n+    #[test]\n+    fn test_filter_array_indices() {\n+        let level = LevelInfo {\n\nReview comment:\n       I didn't have enough test cases to compute here. I'll add more when I increase coverage of deeply-nested lists\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-18T01:20:42.019+0000",
                    "updated": "2021-01-18T01:20:42.019+0000",
                    "started": "2021-01-18T01:20:42.019+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "537198",
                    "issueId": "13343163"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/537199",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #9240:\nURL: https://github.com/apache/arrow/pull/9240#discussion_r559273034\n\n\n\n##########\nFile path: rust/parquet/src/arrow/array_reader.rs\n##########\n@@ -1369,13 +1394,12 @@ impl<'a> TypeVisitor<Option<Box<dyn ArrayReader>>, &'a ArrayReaderBuilderContext\n         let item_reader_type = item_reader.get_data_type().clone();\n \n         match item_reader_type {\n-            ArrowType::List(_)\n-            | ArrowType::FixedSizeList(_, _)\n-            | ArrowType::Struct(_)\n-            | ArrowType::Dictionary(_, _) => Err(ArrowError(format!(\n-                \"reading List({:?}) into arrow not supported yet\",\n-                item_type\n-            ))),\n+            ArrowType::FixedSizeList(_, _) | ArrowType::Dictionary(_, _) => {\n\nReview comment:\n       I need to revert this.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-18T01:27:02.902+0000",
                    "updated": "2021-01-18T01:27:02.902+0000",
                    "started": "2021-01-18T01:27:02.902+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "537199",
                    "issueId": "13343163"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/538211",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #9240:\nURL: https://github.com/apache/arrow/pull/9240#issuecomment-763335236\n\n\n   @sunchao this is good to review\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-20T05:06:59.793+0000",
                    "updated": "2021-01-20T05:06:59.793+0000",
                    "started": "2021-01-20T05:06:59.793+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "538211",
                    "issueId": "13343163"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/538212",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me edited a comment on pull request #9240:\nURL: https://github.com/apache/arrow/pull/9240#issuecomment-763335236\n\n\n   @sunchao may you please kindly review this when you get a chance\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-20T05:07:34.782+0000",
                    "updated": "2021-01-20T05:07:34.782+0000",
                    "started": "2021-01-20T05:07:34.782+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "538212",
                    "issueId": "13343163"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/538213",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on pull request #9240:\nURL: https://github.com/apache/arrow/pull/9240#issuecomment-763336390\n\n\n   Sure. Thanks for pinging me. Will take a look soon.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-20T05:10:00.643+0000",
                    "updated": "2021-01-20T05:10:00.643+0000",
                    "started": "2021-01-20T05:10:00.643+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "538213",
                    "issueId": "13343163"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/538775",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtyler commented on a change in pull request #9240:\nURL: https://github.com/apache/arrow/pull/9240#discussion_r561361029\n\n\n\n##########\nFile path: rust/parquet/src/arrow/array_reader.rs\n##########\n@@ -912,11 +912,36 @@ impl<OffsetSize: OffsetSizeTrait> ArrayReader for ListArrayReader<OffsetSize> {\n             ));\n         }\n \n-        // Need to remove from the values array the nulls that represent null lists rather than null items\n-        // null lists have def_level = 0\n+        // List definitions can be encoded as 4 values:\n+        // - n + 0: the list slot is null\n+        // - n + 1: the list slot is not null, but is empty (i.e. [])\n+        // - n + 2: the list slot is not null, but its child is empty (i.e. [ null ])\n+        // - n + 3: the list slot is not null, and its child is not empty\n+        // Where n is the max definition level of the list's parent.\n+        // If a Parquet schema's only leaf is the list, then n = 0.\n+\n+        // TODO: ARROW-10391 - add a test case with a non-nullable child, check if max is 3\n+        let list_field_type = match self.get_data_type() {\n+            ArrowType::List(field)\n+            | ArrowType::FixedSizeList(field, _)\n+            | ArrowType::LargeList(field) => field,\n+            _ => {\n+                // Panic: this is safe as we only write lists from list datatypes\n+                unreachable!()\n\nReview comment:\n       For my own curiosity, is there a specific reason to use `unreachable!` rather than `panic!` in cases like this? I understand the outcome will be the same.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-21T00:24:58.487+0000",
                    "updated": "2021-01-21T00:24:58.487+0000",
                    "started": "2021-01-21T00:24:58.487+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "538775",
                    "issueId": "13343163"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/539297",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #9240:\nURL: https://github.com/apache/arrow/pull/9240#discussion_r562158835\n\n\n\n##########\nFile path: rust/parquet/src/arrow/array_reader.rs\n##########\n@@ -912,11 +912,36 @@ impl<OffsetSize: OffsetSizeTrait> ArrayReader for ListArrayReader<OffsetSize> {\n             ));\n         }\n \n-        // Need to remove from the values array the nulls that represent null lists rather than null items\n-        // null lists have def_level = 0\n+        // List definitions can be encoded as 4 values:\n+        // - n + 0: the list slot is null\n+        // - n + 1: the list slot is not null, but is empty (i.e. [])\n+        // - n + 2: the list slot is not null, but its child is empty (i.e. [ null ])\n+        // - n + 3: the list slot is not null, and its child is not empty\n+        // Where n is the max definition level of the list's parent.\n+        // If a Parquet schema's only leaf is the list, then n = 0.\n+\n+        // TODO: ARROW-10391 - add a test case with a non-nullable child, check if max is 3\n+        let list_field_type = match self.get_data_type() {\n+            ArrowType::List(field)\n+            | ArrowType::FixedSizeList(field, _)\n+            | ArrowType::LargeList(field) => field,\n+            _ => {\n+                // Panic: this is safe as we only write lists from list datatypes\n+                unreachable!()\n\nReview comment:\n       They don't make any difference, `unreachable!()` will call `panic!()` with a message about unreachable code being reached. So it's probably a more descriptive panic.\r\n   \r\n   I tohught that marking a condition as `unreachable!()` lets the compiler optimise out that condition, but it seems like only its `unsafe` equivalent does.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-21T19:57:30.050+0000",
                    "updated": "2021-01-21T19:57:30.050+0000",
                    "started": "2021-01-21T19:57:30.050+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "539297",
                    "issueId": "13343163"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/539792",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtyler commented on a change in pull request #9240:\nURL: https://github.com/apache/arrow/pull/9240#discussion_r561361029\n\n\n\n##########\nFile path: rust/parquet/src/arrow/array_reader.rs\n##########\n@@ -912,11 +912,36 @@ impl<OffsetSize: OffsetSizeTrait> ArrayReader for ListArrayReader<OffsetSize> {\n             ));\n         }\n \n-        // Need to remove from the values array the nulls that represent null lists rather than null items\n-        // null lists have def_level = 0\n+        // List definitions can be encoded as 4 values:\n+        // - n + 0: the list slot is null\n+        // - n + 1: the list slot is not null, but is empty (i.e. [])\n+        // - n + 2: the list slot is not null, but its child is empty (i.e. [ null ])\n+        // - n + 3: the list slot is not null, and its child is not empty\n+        // Where n is the max definition level of the list's parent.\n+        // If a Parquet schema's only leaf is the list, then n = 0.\n+\n+        // TODO: ARROW-10391 - add a test case with a non-nullable child, check if max is 3\n+        let list_field_type = match self.get_data_type() {\n+            ArrowType::List(field)\n+            | ArrowType::FixedSizeList(field, _)\n+            | ArrowType::LargeList(field) => field,\n+            _ => {\n+                // Panic: this is safe as we only write lists from list datatypes\n+                unreachable!()\n\nReview comment:\n       For my own curiosity, is there a specific reason to use `unreachable!` rather than `panic!` in cases like this? I understand the outcome will be the same.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-22T06:15:55.448+0000",
                    "updated": "2021-01-22T06:15:55.448+0000",
                    "started": "2021-01-22T06:15:55.448+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "539792",
                    "issueId": "13343163"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/539935",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #9240:\nURL: https://github.com/apache/arrow/pull/9240#discussion_r562158835\n\n\n\n##########\nFile path: rust/parquet/src/arrow/array_reader.rs\n##########\n@@ -912,11 +912,36 @@ impl<OffsetSize: OffsetSizeTrait> ArrayReader for ListArrayReader<OffsetSize> {\n             ));\n         }\n \n-        // Need to remove from the values array the nulls that represent null lists rather than null items\n-        // null lists have def_level = 0\n+        // List definitions can be encoded as 4 values:\n+        // - n + 0: the list slot is null\n+        // - n + 1: the list slot is not null, but is empty (i.e. [])\n+        // - n + 2: the list slot is not null, but its child is empty (i.e. [ null ])\n+        // - n + 3: the list slot is not null, and its child is not empty\n+        // Where n is the max definition level of the list's parent.\n+        // If a Parquet schema's only leaf is the list, then n = 0.\n+\n+        // TODO: ARROW-10391 - add a test case with a non-nullable child, check if max is 3\n+        let list_field_type = match self.get_data_type() {\n+            ArrowType::List(field)\n+            | ArrowType::FixedSizeList(field, _)\n+            | ArrowType::LargeList(field) => field,\n+            _ => {\n+                // Panic: this is safe as we only write lists from list datatypes\n+                unreachable!()\n\nReview comment:\n       They don't make any difference, `unreachable!()` will call `panic!()` with a message about unreachable code being reached. So it's probably a more descriptive panic.\r\n   \r\n   I tohught that marking a condition as `unreachable!()` lets the compiler optimise out that condition, but it seems like only its `unsafe` equivalent does.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-22T06:38:06.914+0000",
                    "updated": "2021-01-22T06:38:06.914+0000",
                    "started": "2021-01-22T06:38:06.913+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "539935",
                    "issueId": "13343163"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/worklog/540179",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb closed pull request #9240:\nURL: https://github.com/apache/arrow/pull/9240\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-22T12:46:21.063+0000",
                    "updated": "2021-01-22T12:46:21.063+0000",
                    "started": "2021-01-22T12:46:21.063+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "540179",
                    "issueId": "13343163"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 15600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@3edb2a19[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3418989f[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@649322[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@70c82fd1[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@560fdef8[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@76165ba7[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@52cf2bc4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@634830eb[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4b98da64[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@f977bd3[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@242df0ee[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@6c043e8[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 15600,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Jan 22 12:46:17 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-01-22T12:46:17.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10766/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-11-29T11:30:26.000+0000",
        "updated": "2021-01-22T22:26:37.000+0000",
        "timeoriginalestimate": null,
        "description": "This extends on ARROW-9728 by only focusing on list array repetition and definition levels",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 15600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] Compute nested definition and repetition for list arrays",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343163/comment/17270108",
                    "id": "17270108",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
                        "name": "alamb",
                        "key": "alamb",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
                        },
                        "displayName": "Andrew Lamb",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 9240\n[https://github.com/apache/arrow/pull/9240]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
                        "name": "alamb",
                        "key": "alamb",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
                        },
                        "displayName": "Andrew Lamb",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-01-22T12:46:17.383+0000",
                    "updated": "2021-01-22T12:46:17.383+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0l0w8:",
        "customfield_12314139": null
    }
}