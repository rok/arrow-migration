{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13358006",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006",
    "key": "ARROW-11590",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12608413",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12608413",
                "type": {
                    "id": "12310360",
                    "name": "Dependent",
                    "inward": "Dependent",
                    "outward": "Dependent",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310360"
                },
                "outwardIssue": {
                    "id": "13358002",
                    "key": "ARROW-11588",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358002",
                    "fields": {
                        "summary": "[C++] Add traceable general purpose queue(s)",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/3",
                            "id": "3",
                            "description": "A task that needs to be done.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21148&avatarType=issuetype",
                            "name": "Task",
                            "subtask": false,
                            "avatarId": 21148
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 27000,
            "total": 27000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 27000,
            "total": 27000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11590/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 45,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/555017",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace opened a new pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533\n\n\n   The `AsyncThreadedTableReader` was previously creating a dedicated size 1 thread pool for readahead (similar to the way the serial reader behaves).  This allowed for parallel readahead because the futures couldn't get worked on faster than 1 at a time anyways.  However, this introduced a thread outside of both the CPU context and the I/O context.\r\n   \r\n   This PR adds a new AsyncGenerator utility (MakeSerialReadaheadGenerator) which still provides readahead but, unlike MakeReadaheadGenerator, it does not pull in an async reentrant fashion.  This allows the I/O thread pool to be used because the serial logic will take care of ensuring that no more than one request is ever active.\r\n   \r\n   Aside: In implementing this feature we encountered an issue with futures.  The logic in SerialReadaheadGenerator is relying on callbacks being run by Future in a reliable order.  Some changes were made to Future to ensure this.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-20T01:11:27.807+0000",
                    "updated": "2021-02-20T01:11:27.807+0000",
                    "started": "2021-02-20T01:11:27.806+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "555017",
                    "issueId": "13358006"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/555018",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533#issuecomment-782497139\n\n\n   https://issues.apache.org/jira/browse/ARROW-11590\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-20T01:11:42.295+0000",
                    "updated": "2021-02-20T01:11:42.295+0000",
                    "started": "2021-02-20T01:11:42.295+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "555018",
                    "issueId": "13358006"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/555019",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533#discussion_r579564527\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -250,30 +250,40 @@ class ConcreteFutureImpl : public FutureImpl {\n   }\n \n   void DoMarkFinishedOrFailed(FutureState state) {\n-    {\n-      // Lock the hypothetical waiter first, and the future after.\n-      // This matches the locking order done in FutureWaiter constructor.\n-      std::unique_lock<std::mutex> waiter_lock(global_waiter_mutex);\n-      std::unique_lock<std::mutex> lock(mutex_);\n-\n-      DCHECK(!IsFutureFinished(state_)) << \"Future already marked finished\";\n-      state_ = state;\n-      if (waiter_ != nullptr) {\n-        waiter_->MarkFutureFinishedUnlocked(waiter_arg_, state);\n-      }\n+    // Lock the hypothetical waiter first, and the future after.\n+    // This matches the locking order done in FutureWaiter constructor.\n+    std::unique_lock<std::mutex> waiter_lock(global_waiter_mutex);\n+    std::unique_lock<std::mutex> lock(mutex_);\n+\n+    DCHECK(!IsFutureFinished(state_)) << \"Future already marked finished\";\n+    state_ = state;\n+    if (waiter_ != nullptr) {\n+      waiter_->MarkFutureFinishedUnlocked(waiter_arg_, state);\n     }\n+\n+    // Waiters are alerted before callbacks are run\n+    waiter_lock.unlock();\n     cv_.notify_all();\n \n-    // run callbacks, lock not needed since the future is finsihed by this\n-    // point so nothing else can modify the callbacks list and it is safe\n-    // to iterate.\n-    //\n-    // In fact, it is important not to hold the locks because the callback\n-    // may be slow or do its own locking on other resources\n-    for (auto&& callback : callbacks_) {\n-      std::move(callback)();\n+    std::vector<Callback> callbacks_to_run = std::move(callbacks_);\n\nReview comment:\n       @pitrou @bkietz This adds a bit of overhead to callback execution but it ensures that TryAddCallback will only return false if all previously added callbacks have finished.  Callbacks can now be added while the future is in the process of being completed which opens up the door for concurrent access to `callbacks_` hence the lock and move.\r\n   \r\n   Note, this is unrelated to the lockfree queue.  My first iteration of serial readahead used mutex & std::queue and still ran into this problem.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-20T01:16:27.894+0000",
                    "updated": "2021-02-20T01:16:27.894+0000",
                    "started": "2021-02-20T01:16:27.894+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "555019",
                    "issueId": "13358006"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/555302",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533#discussion_r579724055\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -250,30 +250,40 @@ class ConcreteFutureImpl : public FutureImpl {\n   }\n \n   void DoMarkFinishedOrFailed(FutureState state) {\n-    {\n-      // Lock the hypothetical waiter first, and the future after.\n-      // This matches the locking order done in FutureWaiter constructor.\n-      std::unique_lock<std::mutex> waiter_lock(global_waiter_mutex);\n-      std::unique_lock<std::mutex> lock(mutex_);\n-\n-      DCHECK(!IsFutureFinished(state_)) << \"Future already marked finished\";\n-      state_ = state;\n-      if (waiter_ != nullptr) {\n-        waiter_->MarkFutureFinishedUnlocked(waiter_arg_, state);\n-      }\n+    // Lock the hypothetical waiter first, and the future after.\n+    // This matches the locking order done in FutureWaiter constructor.\n+    std::unique_lock<std::mutex> waiter_lock(global_waiter_mutex);\n+    std::unique_lock<std::mutex> lock(mutex_);\n+\n+    DCHECK(!IsFutureFinished(state_)) << \"Future already marked finished\";\n+    state_ = state;\n+    if (waiter_ != nullptr) {\n+      waiter_->MarkFutureFinishedUnlocked(waiter_arg_, state);\n     }\n+\n+    // Waiters are alerted before callbacks are run\n+    waiter_lock.unlock();\n     cv_.notify_all();\n \n-    // run callbacks, lock not needed since the future is finsihed by this\n-    // point so nothing else can modify the callbacks list and it is safe\n-    // to iterate.\n-    //\n-    // In fact, it is important not to hold the locks because the callback\n-    // may be slow or do its own locking on other resources\n-    for (auto&& callback : callbacks_) {\n-      std::move(callback)();\n+    std::vector<Callback> callbacks_to_run = std::move(callbacks_);\n\nReview comment:\n       Nevermind.  Even with the change it still isn't very safe to try and rely on `AddCallback` ordering.  Parent layers were doing things like...\r\n   ```\r\n   if (fut.IsFinished()) {\r\n     // Do something, this can run before all callbacks run\r\n   }\r\n   ```\r\n   Preventing the future itself from being marked finished until after all the callbacks run seems like too much complexity and performance hit.  Instead, if something needs to ensure a callback is run it needs to use `Then` and return a new future even though this added a bit of complexity (need to store shared_ptr in the queue) to serial readback.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-20T23:38:36.007+0000",
                    "updated": "2021-02-20T23:38:36.007+0000",
                    "started": "2021-02-20T23:38:36.007+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "555302",
                    "issueId": "13358006"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/555303",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533#discussion_r579724159\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -250,30 +250,40 @@ class ConcreteFutureImpl : public FutureImpl {\n   }\n \n   void DoMarkFinishedOrFailed(FutureState state) {\n-    {\n-      // Lock the hypothetical waiter first, and the future after.\n-      // This matches the locking order done in FutureWaiter constructor.\n-      std::unique_lock<std::mutex> waiter_lock(global_waiter_mutex);\n-      std::unique_lock<std::mutex> lock(mutex_);\n-\n-      DCHECK(!IsFutureFinished(state_)) << \"Future already marked finished\";\n-      state_ = state;\n-      if (waiter_ != nullptr) {\n-        waiter_->MarkFutureFinishedUnlocked(waiter_arg_, state);\n-      }\n+    // Lock the hypothetical waiter first, and the future after.\n+    // This matches the locking order done in FutureWaiter constructor.\n+    std::unique_lock<std::mutex> waiter_lock(global_waiter_mutex);\n+    std::unique_lock<std::mutex> lock(mutex_);\n+\n+    DCHECK(!IsFutureFinished(state_)) << \"Future already marked finished\";\n+    state_ = state;\n+    if (waiter_ != nullptr) {\n+      waiter_->MarkFutureFinishedUnlocked(waiter_arg_, state);\n     }\n+\n+    // Waiters are alerted before callbacks are run\n+    waiter_lock.unlock();\n     cv_.notify_all();\n \n-    // run callbacks, lock not needed since the future is finsihed by this\n-    // point so nothing else can modify the callbacks list and it is safe\n-    // to iterate.\n-    //\n-    // In fact, it is important not to hold the locks because the callback\n-    // may be slow or do its own locking on other resources\n-    for (auto&& callback : callbacks_) {\n-      std::move(callback)();\n+    std::vector<Callback> callbacks_to_run = std::move(callbacks_);\n\nReview comment:\n       Also, since this comment is probably confusing now.  It was explaining a change to `Future` that I went back and reverted.  There are no changes to `Future` as part of this PR.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-20T23:39:21.816+0000",
                    "updated": "2021-02-20T23:39:21.816+0000",
                    "started": "2021-02-20T23:39:21.815+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "555303",
                    "issueId": "13358006"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/555315",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533#issuecomment-782770086\n\n\n   Some of the Windows builds are failing with...\r\n   ```\r\n   C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits(1271): error C2338: You've instantiated std::aligned_storage<Len, Align> with an extended alignment (in other words, Align > alignof(max_align_t)). Before VS 2017 15.8, the member type would non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 was fixed to handle this correctly, but the fix inherently changes layout and breaks binary compatibility (*only* for uses of aligned_storage with extended alignments). Please define either (1) _ENABLE_EXTENDED_ALIGNED_STORAGE to acknowledge that you understand this message and that you actually want a type with an extended alignment, or (2) _DISABLE_EXTENDED_ALIGNED_STORAGE to silence this message and get the old non-conformant behavior.\r\n   ```\r\n   ...so I'll need to investigate.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-21T00:18:05.632+0000",
                    "updated": "2021-02-21T00:18:05.632+0000",
                    "started": "2021-02-21T00:18:05.631+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "555315",
                    "issueId": "13358006"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/556618",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533#discussion_r581450731\n\n\n\n##########\nFile path: cpp/src/arrow/vendored/ProducerConsumerQueue.h\n##########\n@@ -0,0 +1,214 @@\n+// Vendored from git tag v2021.02.15.00\n+\n+/*\n+ * Copyright (c) Facebook, Inc. and its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+// @author Bo Hu (bhu@fb.com)\n+// @author Jordan DeLong (delong.j@fb.com)\n+\n+#pragma once\n+\n+#include <atomic>\n+#include <cassert>\n+#include <cstdlib>\n+#include <memory>\n+#include <stdexcept>\n+#include <type_traits>\n+#include <utility>\n+\n+namespace arrow_vendored {\n+namespace folly {\n+\n+// Vendored from folly/Portability.h\n+namespace {\n+#if defined(__arm__)\n+#define FOLLY_ARM 1\n+#else\n+#define FOLLY_ARM 0\n+#endif\n+\n+#if defined(__s390x__)\n+#define FOLLY_S390X 1\n+#else\n+#define FOLLY_S390X 0\n+#endif\n+\n+constexpr bool kIsArchArm = FOLLY_ARM == 1;\n+constexpr bool kIsArchS390X = FOLLY_S390X == 1;\n+}  // namespace\n+\n+// Vendored from folly/lang/Align.h\n+namespace {\n+\n+constexpr std::size_t hardware_destructive_interference_size =\n+    (kIsArchArm || kIsArchS390X) ? 64 : 128;\n+\n+}  // namespace\n+\n+/*\n+ * ProducerConsumerQueue is a one producer and one consumer queue\n+ * without locks.\n+ */\n+template <class T>\n+struct ProducerConsumerQueue {\n+  typedef T value_type;\n+\n+  ProducerConsumerQueue(const ProducerConsumerQueue&) = delete;\n+  ProducerConsumerQueue& operator=(const ProducerConsumerQueue&) = delete;\n+\n+  // size must be >= 2.\n+  //\n+  // Also, note that the number of usable slots in the queue at any\n+  // given time is actually (size-1), so if you start with an empty queue,\n+  // isFull() will return true after size-1 insertions.\n+  explicit ProducerConsumerQueue(uint32_t size)\n+      : size_(size),\n+        records_(static_cast<T*>(std::malloc(sizeof(T) * size))),\n+        readIndex_(0),\n+        writeIndex_(0) {\n+    assert(size >= 2);\n+    if (!records_) {\n+      throw std::bad_alloc();\n+    }\n+  }\n+\n+  ~ProducerConsumerQueue() {\n+    // We need to destruct anything that may still exist in our queue.\n+    // (No real synchronization needed at destructor time: only one\n+    // thread can be doing this.)\n+    if (!std::is_trivially_destructible<T>::value) {\n+      size_t readIndex = readIndex_;\n+      size_t endIndex = writeIndex_;\n+      while (readIndex != endIndex) {\n+        records_[readIndex].~T();\n+        if (++readIndex == size_) {\n+          readIndex = 0;\n+        }\n+      }\n+    }\n+\n+    std::free(records_);\n+  }\n+\n+  template <class... Args>\n+  bool write(Args&&... recordArgs) {\n+    auto const currentWrite = writeIndex_.load(std::memory_order_relaxed);\n+    auto nextRecord = currentWrite + 1;\n+    if (nextRecord == size_) {\n+      nextRecord = 0;\n+    }\n+    if (nextRecord != readIndex_.load(std::memory_order_acquire)) {\n+      new (&records_[currentWrite]) T(std::forward<Args>(recordArgs)...);\n+      writeIndex_.store(nextRecord, std::memory_order_release);\n+      return true;\n+    }\n+\n+    // queue is full\n+    return false;\n+  }\n+\n+  // move (or copy) the value at the front of the queue to given variable\n+  bool read(T& record) {\n+    auto const currentRead = readIndex_.load(std::memory_order_relaxed);\n+    if (currentRead == writeIndex_.load(std::memory_order_acquire)) {\n+      // queue is empty\n+      return false;\n+    }\n+\n+    auto nextRecord = currentRead + 1;\n+    if (nextRecord == size_) {\n+      nextRecord = 0;\n+    }\n+    record = std::move(records_[currentRead]);\n+    records_[currentRead].~T();\n+    readIndex_.store(nextRecord, std::memory_order_release);\n+    return true;\n+  }\n+\n+  // pointer to the value at the front of the queue (for use in-place) or\n+  // nullptr if empty.\n+  T* frontPtr() {\n\nReview comment:\n       You tell me.  It would be pretty trivial.  I just wasn't sure of the rules for how much we modify vendored files.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-23T22:57:34.119+0000",
                    "updated": "2021-02-23T22:57:34.119+0000",
                    "started": "2021-02-23T22:57:34.118+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "556618",
                    "issueId": "13358006"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/556630",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533#discussion_r581463408\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +179,90 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+template <typename T>\n+class SerialReadaheadGenerator {\n+ public:\n+  SerialReadaheadGenerator(AsyncGenerator<T> source_generator, int max_readahead)\n+      : state_(std::make_shared<State>(std::move(source_generator), max_readahead)) {}\n+\n+  Future<T> operator()() {\n+    if (state_->first) {\n+      // Lazy generator, need to wait for the first ask to prime the pump\n+      state_->first = false;\n+      auto next = state_->source();\n+      return next.Then(Callback{state_});\n+    } else {\n\nReview comment:\n       Done\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-23T23:24:06.033+0000",
                    "updated": "2021-02-23T23:24:06.033+0000",
                    "started": "2021-02-23T23:24:06.033+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "556630",
                    "issueId": "13358006"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/556632",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533#discussion_r581463629\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +179,90 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+template <typename T>\n+class SerialReadaheadGenerator {\n+ public:\n+  SerialReadaheadGenerator(AsyncGenerator<T> source_generator, int max_readahead)\n+      : state_(std::make_shared<State>(std::move(source_generator), max_readahead)) {}\n+\n+  Future<T> operator()() {\n+    if (state_->first) {\n+      // Lazy generator, need to wait for the first ask to prime the pump\n+      state_->first = false;\n+      auto next = state_->source();\n+      return next.Then(Callback{state_});\n+    } else {\n+      // This generator is not async-reentrant.  We won't be called until the last\n+      // future finished so we know there is something in the queue\n+      auto finished = state_->finished.load();\n+      if (finished && state_->readahead_queue.isEmpty()) {\n+        return Future<T>::MakeFinished(IterationTraits<T>::End());\n+      }\n+      auto next_ptr = state_->readahead_queue.frontPtr();\n+      DCHECK(next_ptr != NULLPTR);\n\nReview comment:\n       The first one would have been checked anyways since shared_ptr should abort on nullptr.  The second one I converted into a proper Status check.\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +179,90 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+template <typename T>\n+class SerialReadaheadGenerator {\n+ public:\n+  SerialReadaheadGenerator(AsyncGenerator<T> source_generator, int max_readahead)\n+      : state_(std::make_shared<State>(std::move(source_generator), max_readahead)) {}\n+\n+  Future<T> operator()() {\n+    if (state_->first) {\n+      // Lazy generator, need to wait for the first ask to prime the pump\n+      state_->first = false;\n+      auto next = state_->source();\n+      return next.Then(Callback{state_});\n+    } else {\n+      // This generator is not async-reentrant.  We won't be called until the last\n+      // future finished so we know there is something in the queue\n+      auto finished = state_->finished.load();\n+      if (finished && state_->readahead_queue.isEmpty()) {\n+        return Future<T>::MakeFinished(IterationTraits<T>::End());\n+      }\n+      auto next_ptr = state_->readahead_queue.frontPtr();\n+      DCHECK(next_ptr != NULLPTR);\n+      auto next = std::move(**next_ptr);\n+      state_->readahead_queue.popFront();\n+      auto last_available = state_->spaces_available.fetch_add(1);\n+      if (last_available == 0 && !finished) {\n+        // Reader idled out, we need to restart it\n+        state_->Pump(state_);\n+      }\n+      return next;\n+    }\n+  }\n+\n+ private:\n+  struct State {\n+    State(AsyncGenerator<T> source_, int max_readahead)\n+        : first(true),\n+          source(std::move(source_)),\n+          finished(false),\n+          spaces_available(max_readahead),\n+          readahead_queue(max_readahead) {}\n+\n+    void Pump(std::shared_ptr<State>& self) {\n+      // Can't do readahead_queue.write(source().Then(Callback{self})) because then the\n+      // callback might run immediately and add itself to the queue before this gets added\n+      // to the queue messing up the order\n+      auto next_slot = std::make_shared<Future<T>>();\n+      auto written = readahead_queue.write(next_slot);\n+      DCHECK(written);\n+      *next_slot = source().Then(Callback{self});\n+    }\n+\n+    // Only accessed by the consumer end\n+    bool first;\n+    // Accessed by both threads\n+    AsyncGenerator<T> source;\n+    std::atomic<bool> finished;\n+    std::atomic<uint32_t> spaces_available;\n+    util::SpscQueue<std::shared_ptr<Future<T>>> readahead_queue;\n+  };\n+\n+  struct Callback {\n+    Result<T> operator()(const Result<T>& next_result) {\n\nReview comment:\n       Done\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-23T23:25:00.320+0000",
                    "updated": "2021-02-23T23:25:00.320+0000",
                    "started": "2021-02-23T23:25:00.320+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "556632",
                    "issueId": "13358006"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/556638",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533#discussion_r581464660\n\n\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -726,6 +730,142 @@ TEST(TestAsyncUtil, CompleteBackgroundStressTest) {\n   }\n }\n \n+template <typename T>\n+class SlowSourcePreventingReentrant {\n+ public:\n+  explicit SlowSourcePreventingReentrant(AsyncGenerator<T> source)\n+      : state_(std::make_shared<State>(std::move(source))) {}\n+\n+  Future<TestInt> operator()() {\n+    if (state_->in.load()) {\n+      state_->valid.store(false);\n+    }\n+    state_->in.store(true);\n+    auto result = state_->source();\n+    result.AddCallback(Callback{state_});\n+    return result;\n+  }\n+\n+  void AssertValid() {\n+    EXPECT_EQ(true, state_->valid.load())\n+        << \"The generator was accessed in a reentrant manner\";\n+  }\n+\n+ private:\n+  struct State {\n+    explicit State(AsyncGenerator<T> source_)\n+        : source(std::move(source_)), in(false), valid(true) {}\n+\n+    AsyncGenerator<T> source;\n+    std::atomic<bool> in;\n+    std::atomic<bool> valid;\n+  };\n+  struct Callback {\n+    void operator()(const Result<T>& result) { state_->in.store(false); }\n+    std::shared_ptr<State> state_;\n+  };\n+\n+  std::shared_ptr<State> state_;\n+};\n+\n+TEST(TestAsyncUtil, SerialReadaheadSlowProducer) {\n+  AsyncGenerator<TestInt> it = BackgroundAsyncVectorIt({1, 2, 3, 4, 5});\n+  SlowSourcePreventingReentrant<TestInt> tracker(std::move(it));\n+  SerialReadaheadGenerator<TestInt> serial_readahead(tracker, 2);\n+  AssertAsyncGeneratorMatch({1, 2, 3, 4, 5},\n+                            static_cast<AsyncGenerator<TestInt>>(serial_readahead));\n+  tracker.AssertValid();\n+}\n+\n+TEST(TestAsyncUtil, SerialReadaheadSlowConsumer) {\n+  int num_delivered = 0;\n+  auto source = [&num_delivered]() {\n+    if (num_delivered < 5) {\n+      return Future<TestInt>::MakeFinished(num_delivered++);\n+    } else {\n+      return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+    }\n+  };\n+  SerialReadaheadGenerator<TestInt> serial_readahead(std::move(source), 3);\n+  SleepABit();\n+  ASSERT_EQ(0, num_delivered);\n+  ASSERT_FINISHES_OK_AND_ASSIGN(auto next, serial_readahead());\n+  ASSERT_EQ(0, next.value);\n+  ASSERT_EQ(3, num_delivered);\n+  AssertAsyncGeneratorMatch({1, 2, 3, 4},\n+                            static_cast<AsyncGenerator<TestInt>>(serial_readahead));\n+}\n+\n+TEST(TestAsyncUtil, SerialReadaheadStress) {\n+  constexpr int NTASKS = 20;\n+  constexpr int NITEMS = 50;\n+  constexpr int EXPECTED_SUM = (NITEMS * (NITEMS - 1)) / 2;\n+  for (int i = 0; i < NTASKS; i++) {\n+    AsyncGenerator<TestInt> it = BackgroundAsyncVectorIt(RangeVector(NITEMS));\n+    SerialReadaheadGenerator<TestInt> serial_readahead(it, 2);\n+    unsigned int sum = 0;\n+    auto visit_fut = VisitAsyncGenerator<TestInt>(\n+        serial_readahead, [&sum](TestInt test_int) -> Status {\n+          sum += test_int.value;\n+          // Normally sleeping in a visit function would be a faux-pas but we want to slow\n+          // the reader down to match the producer to maximize the stress\n+          std::this_thread::sleep_for(kYieldDuration);\n+          return Status::OK();\n+        });\n+    ASSERT_FINISHES_OK(visit_fut);\n+    ASSERT_EQ(EXPECTED_SUM, sum);\n+  }\n+}\n+\n+TEST(TestAsyncUtil, SerialReadaheadStressFast) {\n+  constexpr int NTASKS = 20;\n+  constexpr int NITEMS = 50;\n+  constexpr int EXPECTED_SUM = (NITEMS * (NITEMS - 1)) / 2;\n+  for (int i = 0; i < NTASKS; i++) {\n+    AsyncGenerator<TestInt> it = BackgroundAsyncVectorIt(RangeVector(NITEMS), false);\n+    SerialReadaheadGenerator<TestInt> serial_readahead(it, 2);\n+    unsigned int sum = 0;\n+    auto visit_fut = VisitAsyncGenerator<TestInt>(serial_readahead,\n+                                                  [&sum](TestInt test_int) -> Status {\n+                                                    sum += test_int.value;\n+                                                    return Status::OK();\n+                                                  });\n+    ASSERT_FINISHES_OK(visit_fut);\n+    ASSERT_EQ(EXPECTED_SUM, sum);\n\nReview comment:\n       It's more to check for race conditions.  The background thread filling callbacks and the visitor thread pulling the serial readahead both share a pointer to State.  Both of these tests were pretty useful in exposing issues with the old AddCallback version.  However, I added a reentrancy check in there for good measure and got rid of the sum stuff.\n\n##########\nFile path: cpp/src/arrow/util/queue_benchmark.cc\n##########\n@@ -0,0 +1,87 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <thread>\n+#include <vector>\n+\n+#include <benchmark/benchmark.h>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/util/queue.h\"\n+\n+namespace arrow {\n+\n+namespace util {\n+\n+static constexpr int64_t kSize = 100000;\n+\n+void throughput(benchmark::State& state) {\n\nReview comment:\n       Done\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-23T23:26:46.288+0000",
                    "updated": "2021-02-23T23:26:46.288+0000",
                    "started": "2021-02-23T23:26:46.288+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "556638",
                    "issueId": "13358006"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/562635",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533#issuecomment-793117488\n\n\n   Failing check is unrelated.  I believe I have resolved all issues and it is ready for re-review/merge.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T22:09:55.798+0000",
                    "updated": "2021-03-08T22:09:55.798+0000",
                    "started": "2021-03-08T22:09:55.798+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562635",
                    "issueId": "13358006"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/562636",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533#discussion_r589784685\n\n\n\n##########\nFile path: cpp/src/arrow/vendored/ProducerConsumerQueue.h\n##########\n@@ -0,0 +1,214 @@\n+// Vendored from git tag v2021.02.15.00\n+\n+/*\n+ * Copyright (c) Facebook, Inc. and its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+// @author Bo Hu (bhu@fb.com)\n+// @author Jordan DeLong (delong.j@fb.com)\n+\n+#pragma once\n+\n+#include <atomic>\n+#include <cassert>\n+#include <cstdlib>\n+#include <memory>\n+#include <stdexcept>\n+#include <type_traits>\n+#include <utility>\n+\n+namespace arrow_vendored {\n+namespace folly {\n+\n+// Vendored from folly/Portability.h\n+namespace {\n+#if defined(__arm__)\n+#define FOLLY_ARM 1\n+#else\n+#define FOLLY_ARM 0\n+#endif\n+\n+#if defined(__s390x__)\n+#define FOLLY_S390X 1\n+#else\n+#define FOLLY_S390X 0\n+#endif\n+\n+constexpr bool kIsArchArm = FOLLY_ARM == 1;\n+constexpr bool kIsArchS390X = FOLLY_S390X == 1;\n+}  // namespace\n+\n+// Vendored from folly/lang/Align.h\n+namespace {\n+\n+constexpr std::size_t hardware_destructive_interference_size =\n+    (kIsArchArm || kIsArchS390X) ? 64 : 128;\n+\n+}  // namespace\n+\n+/*\n+ * ProducerConsumerQueue is a one producer and one consumer queue\n+ * without locks.\n+ */\n+template <class T>\n+struct ProducerConsumerQueue {\n+  typedef T value_type;\n+\n+  ProducerConsumerQueue(const ProducerConsumerQueue&) = delete;\n+  ProducerConsumerQueue& operator=(const ProducerConsumerQueue&) = delete;\n+\n+  // size must be >= 2.\n+  //\n+  // Also, note that the number of usable slots in the queue at any\n+  // given time is actually (size-1), so if you start with an empty queue,\n+  // isFull() will return true after size-1 insertions.\n+  explicit ProducerConsumerQueue(uint32_t size)\n+      : size_(size),\n+        records_(static_cast<T*>(std::malloc(sizeof(T) * size))),\n+        readIndex_(0),\n+        writeIndex_(0) {\n+    assert(size >= 2);\n+    if (!records_) {\n+      throw std::bad_alloc();\n+    }\n+  }\n+\n+  ~ProducerConsumerQueue() {\n+    // We need to destruct anything that may still exist in our queue.\n+    // (No real synchronization needed at destructor time: only one\n+    // thread can be doing this.)\n+    if (!std::is_trivially_destructible<T>::value) {\n+      size_t readIndex = readIndex_;\n+      size_t endIndex = writeIndex_;\n+      while (readIndex != endIndex) {\n+        records_[readIndex].~T();\n+        if (++readIndex == size_) {\n+          readIndex = 0;\n+        }\n+      }\n+    }\n+\n+    std::free(records_);\n+  }\n+\n+  template <class... Args>\n+  bool write(Args&&... recordArgs) {\n+    auto const currentWrite = writeIndex_.load(std::memory_order_relaxed);\n+    auto nextRecord = currentWrite + 1;\n+    if (nextRecord == size_) {\n+      nextRecord = 0;\n+    }\n+    if (nextRecord != readIndex_.load(std::memory_order_acquire)) {\n+      new (&records_[currentWrite]) T(std::forward<Args>(recordArgs)...);\n+      writeIndex_.store(nextRecord, std::memory_order_release);\n+      return true;\n+    }\n+\n+    // queue is full\n+    return false;\n+  }\n+\n+  // move (or copy) the value at the front of the queue to given variable\n+  bool read(T& record) {\n+    auto const currentRead = readIndex_.load(std::memory_order_relaxed);\n+    if (currentRead == writeIndex_.load(std::memory_order_acquire)) {\n+      // queue is empty\n+      return false;\n+    }\n+\n+    auto nextRecord = currentRead + 1;\n+    if (nextRecord == size_) {\n+      nextRecord = 0;\n+    }\n+    record = std::move(records_[currentRead]);\n+    records_[currentRead].~T();\n+    readIndex_.store(nextRecord, std::memory_order_release);\n+    return true;\n+  }\n+\n+  // pointer to the value at the front of the queue (for use in-place) or\n+  // nullptr if empty.\n+  T* frontPtr() {\n\nReview comment:\n       Done.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T22:10:30.989+0000",
                    "updated": "2021-03-08T22:10:30.989+0000",
                    "started": "2021-03-08T22:10:30.989+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562636",
                    "issueId": "13358006"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/563132",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533#issuecomment-794043747\n\n\n   @westonpace There are conflicts now (probably trivial). Could you rebase and solve them?\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-09T15:26:02.857+0000",
                    "updated": "2021-03-09T15:26:02.857+0000",
                    "started": "2021-03-09T15:26:02.857+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "563132",
                    "issueId": "13358006"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/563144",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533#issuecomment-794064354\n\n\n   Rebased but now it's got some changes in queue_test that I'm not sure are appropriate.  I'll clean that up today.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-09T15:42:16.962+0000",
                    "updated": "2021-03-09T15:42:16.962+0000",
                    "started": "2021-03-09T15:42:16.961+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "563144",
                    "issueId": "13358006"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/563375",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533#issuecomment-794562010\n\n\n   Ok, it's all cleaned up again and ready for review/merge.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-09T22:47:54.413+0000",
                    "updated": "2021-03-09T22:47:54.413+0000",
                    "started": "2021-03-09T22:47:54.413+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "563375",
                    "issueId": "13358006"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/563756",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533#discussion_r591503004\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +179,94 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+template <typename T>\n+class SerialReadaheadGenerator {\n+ public:\n+  SerialReadaheadGenerator(AsyncGenerator<T> source_generator, int max_readahead)\n+      : state_(std::make_shared<State>(std::move(source_generator), max_readahead)) {}\n+\n+  Future<T> operator()() {\n+    if (state_->first) {\n+      // Lazy generator, need to wait for the first ask to prime the pump\n+      state_->first = false;\n+      auto next = state_->source();\n+      return next.Then(Callback{state_});\n+    }\n+\n+    // This generator is not async-reentrant.  We won't be called until the last\n+    // future finished so we know there is something in the queue\n+    auto finished = state_->finished.load();\n+    if (finished && state_->readahead_queue.IsEmpty()) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+\n+    auto next_ptr = state_->readahead_queue.FrontPtr();\n+    auto next = std::move(**next_ptr);\n+    state_->readahead_queue.PopFront();\n+\n+    auto last_available = state_->spaces_available.fetch_add(1);\n+    if (last_available == 0 && !finished) {\n+      // Reader idled out, we need to restart it\n+      ARROW_RETURN_NOT_OK(state_->Pump(state_));\n+    }\n+    return next;\n+  }\n+\n+ private:\n+  struct State {\n+    State(AsyncGenerator<T> source_, int max_readahead)\n+        : first(true),\n+          source(std::move(source_)),\n+          finished(false),\n+          spaces_available(max_readahead),\n+          readahead_queue(max_readahead) {}\n+\n+    Status Pump(const std::shared_ptr<State>& self) {\n+      // Can't do readahead_queue.write(source().Then(Callback{self})) because then the\n+      // callback might run immediately and add itself to the queue before this gets added\n+      // to the queue messing up the order\n+      auto next_slot = std::make_shared<Future<T>>();\n+      auto written = readahead_queue.Write(next_slot);\n+      if (!written) {\n+        return Status::UnknownError(\"Could not write to readahead_queue\");\n+      }\n+      *next_slot = source().Then(Callback{self});\n+      return Status::OK();\n+    }\n+\n+    // Only accessed by the consumer end\n+    bool first;\n+    // Accessed by both threads\n+    AsyncGenerator<T> source;\n+    std::atomic<bool> finished;\n+    std::atomic<uint32_t> spaces_available;\n+    util::SpscQueue<std::shared_ptr<Future<T>>> readahead_queue;\n+  };\n+\n+  struct Callback {\n+    Result<T> operator()(const Result<T>& maybe_next) {\n+      if (!maybe_next.ok()) {\n+        state_->finished.store(true);\n+        return maybe_next;\n+      }\n+      const auto& next = *maybe_next;\n+      if (next == IterationTraits<T>::End()) {\n+        state_->finished = true;\n\nReview comment:\n       Nit, but would be better to use the same convention consistently (either `= true` or `.store(true)`).\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +179,94 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+template <typename T>\n+class SerialReadaheadGenerator {\n+ public:\n+  SerialReadaheadGenerator(AsyncGenerator<T> source_generator, int max_readahead)\n+      : state_(std::make_shared<State>(std::move(source_generator), max_readahead)) {}\n+\n+  Future<T> operator()() {\n+    if (state_->first) {\n+      // Lazy generator, need to wait for the first ask to prime the pump\n+      state_->first = false;\n+      auto next = state_->source();\n+      return next.Then(Callback{state_});\n+    }\n+\n+    // This generator is not async-reentrant.  We won't be called until the last\n+    // future finished so we know there is something in the queue\n+    auto finished = state_->finished.load();\n+    if (finished && state_->readahead_queue.IsEmpty()) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+\n+    auto next_ptr = state_->readahead_queue.FrontPtr();\n+    auto next = std::move(**next_ptr);\n+    state_->readahead_queue.PopFront();\n+\n+    auto last_available = state_->spaces_available.fetch_add(1);\n+    if (last_available == 0 && !finished) {\n+      // Reader idled out, we need to restart it\n+      ARROW_RETURN_NOT_OK(state_->Pump(state_));\n+    }\n+    return next;\n+  }\n+\n+ private:\n+  struct State {\n+    State(AsyncGenerator<T> source_, int max_readahead)\n+        : first(true),\n+          source(std::move(source_)),\n+          finished(false),\n+          spaces_available(max_readahead),\n+          readahead_queue(max_readahead) {}\n+\n+    Status Pump(const std::shared_ptr<State>& self) {\n+      // Can't do readahead_queue.write(source().Then(Callback{self})) because then the\n+      // callback might run immediately and add itself to the queue before this gets added\n+      // to the queue messing up the order\n+      auto next_slot = std::make_shared<Future<T>>();\n+      auto written = readahead_queue.Write(next_slot);\n+      if (!written) {\n+        return Status::UnknownError(\"Could not write to readahead_queue\");\n+      }\n+      *next_slot = source().Then(Callback{self});\n+      return Status::OK();\n+    }\n+\n+    // Only accessed by the consumer end\n+    bool first;\n+    // Accessed by both threads\n+    AsyncGenerator<T> source;\n+    std::atomic<bool> finished;\n+    std::atomic<uint32_t> spaces_available;\n+    util::SpscQueue<std::shared_ptr<Future<T>>> readahead_queue;\n+  };\n+\n+  struct Callback {\n+    Result<T> operator()(const Result<T>& maybe_next) {\n+      if (!maybe_next.ok()) {\n+        state_->finished.store(true);\n+        return maybe_next;\n+      }\n+      const auto& next = *maybe_next;\n+      if (next == IterationTraits<T>::End()) {\n+        state_->finished = true;\n+        return maybe_next;\n+      }\n+      auto last_available = state_->spaces_available.fetch_sub(1);\n+      if (last_available > 1) {\n+        ARROW_RETURN_NOT_OK(state_->Pump(state_));\n+      }\n+      return maybe_next;\n+    }\n+\n+    std::shared_ptr<State> state_;\n\nReview comment:\n       Do we want to make this a `weak_ptr`? If for some reason the `SerialReadaheadGenerator` doesn't exist anymore, we don't want to keep pumping under the hood.\r\n   \r\n   As a separate concern, it would be nice to start thinking whether generators like this need to take a StopToken.\n\n##########\nFile path: cpp/src/arrow/vendored/ProducerConsumerQueue.h\n##########\n@@ -123,7 +123,7 @@ struct ProducerConsumerQueue {\n     return false;\n   }\n \n-  // move the value at the front of the queue to given variable\n+  // move (or copy) the value at the front of the queue to given variable\n\nReview comment:\n       Note I had changed this comment because, from reading the code, it seems it would always move the value (which is a gotcha actually). Are there cases where the value wouldn't be moved?\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +179,94 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+template <typename T>\n+class SerialReadaheadGenerator {\n+ public:\n+  SerialReadaheadGenerator(AsyncGenerator<T> source_generator, int max_readahead)\n+      : state_(std::make_shared<State>(std::move(source_generator), max_readahead)) {}\n+\n+  Future<T> operator()() {\n+    if (state_->first) {\n+      // Lazy generator, need to wait for the first ask to prime the pump\n+      state_->first = false;\n+      auto next = state_->source();\n+      return next.Then(Callback{state_});\n+    }\n+\n+    // This generator is not async-reentrant.  We won't be called until the last\n+    // future finished so we know there is something in the queue\n+    auto finished = state_->finished.load();\n+    if (finished && state_->readahead_queue.IsEmpty()) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+\n+    auto next_ptr = state_->readahead_queue.FrontPtr();\n+    auto next = std::move(**next_ptr);\n+    state_->readahead_queue.PopFront();\n+\n+    auto last_available = state_->spaces_available.fetch_add(1);\n+    if (last_available == 0 && !finished) {\n+      // Reader idled out, we need to restart it\n+      ARROW_RETURN_NOT_OK(state_->Pump(state_));\n+    }\n+    return next;\n+  }\n+\n+ private:\n+  struct State {\n+    State(AsyncGenerator<T> source_, int max_readahead)\n\nReview comment:\n       Nit: the naming convention here is reversed: `source_` should be the instance variable and `source` the local variable and/or parameter.\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +179,94 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+template <typename T>\n+class SerialReadaheadGenerator {\n+ public:\n+  SerialReadaheadGenerator(AsyncGenerator<T> source_generator, int max_readahead)\n+      : state_(std::make_shared<State>(std::move(source_generator), max_readahead)) {}\n+\n+  Future<T> operator()() {\n+    if (state_->first) {\n+      // Lazy generator, need to wait for the first ask to prime the pump\n+      state_->first = false;\n+      auto next = state_->source();\n+      return next.Then(Callback{state_});\n+    }\n+\n+    // This generator is not async-reentrant.  We won't be called until the last\n+    // future finished so we know there is something in the queue\n+    auto finished = state_->finished.load();\n+    if (finished && state_->readahead_queue.IsEmpty()) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+\n+    auto next_ptr = state_->readahead_queue.FrontPtr();\n+    auto next = std::move(**next_ptr);\n+    state_->readahead_queue.PopFront();\n+\n+    auto last_available = state_->spaces_available.fetch_add(1);\n+    if (last_available == 0 && !finished) {\n+      // Reader idled out, we need to restart it\n\nReview comment:\n       When does this happen?\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +179,94 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+template <typename T>\n+class SerialReadaheadGenerator {\n+ public:\n+  SerialReadaheadGenerator(AsyncGenerator<T> source_generator, int max_readahead)\n+      : state_(std::make_shared<State>(std::move(source_generator), max_readahead)) {}\n+\n+  Future<T> operator()() {\n+    if (state_->first) {\n+      // Lazy generator, need to wait for the first ask to prime the pump\n+      state_->first = false;\n+      auto next = state_->source();\n+      return next.Then(Callback{state_});\n+    }\n+\n+    // This generator is not async-reentrant.  We won't be called until the last\n+    // future finished so we know there is something in the queue\n+    auto finished = state_->finished.load();\n+    if (finished && state_->readahead_queue.IsEmpty()) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+\n+    auto next_ptr = state_->readahead_queue.FrontPtr();\n+    auto next = std::move(**next_ptr);\n+    state_->readahead_queue.PopFront();\n+\n+    auto last_available = state_->spaces_available.fetch_add(1);\n+    if (last_available == 0 && !finished) {\n+      // Reader idled out, we need to restart it\n+      ARROW_RETURN_NOT_OK(state_->Pump(state_));\n+    }\n+    return next;\n+  }\n+\n+ private:\n+  struct State {\n+    State(AsyncGenerator<T> source_, int max_readahead)\n+        : first(true),\n+          source(std::move(source_)),\n+          finished(false),\n+          spaces_available(max_readahead),\n+          readahead_queue(max_readahead) {}\n+\n+    Status Pump(const std::shared_ptr<State>& self) {\n+      // Can't do readahead_queue.write(source().Then(Callback{self})) because then the\n+      // callback might run immediately and add itself to the queue before this gets added\n+      // to the queue messing up the order\n+      auto next_slot = std::make_shared<Future<T>>();\n+      auto written = readahead_queue.Write(next_slot);\n+      if (!written) {\n+        return Status::UnknownError(\"Could not write to readahead_queue\");\n\nReview comment:\n       Well, doesn't this simply mean that the queue is full? Why is this an error?\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +179,94 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+template <typename T>\n+class SerialReadaheadGenerator {\n+ public:\n+  SerialReadaheadGenerator(AsyncGenerator<T> source_generator, int max_readahead)\n+      : state_(std::make_shared<State>(std::move(source_generator), max_readahead)) {}\n+\n+  Future<T> operator()() {\n+    if (state_->first) {\n+      // Lazy generator, need to wait for the first ask to prime the pump\n+      state_->first = false;\n+      auto next = state_->source();\n+      return next.Then(Callback{state_});\n+    }\n+\n+    // This generator is not async-reentrant.  We won't be called until the last\n+    // future finished so we know there is something in the queue\n+    auto finished = state_->finished.load();\n+    if (finished && state_->readahead_queue.IsEmpty()) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+\n+    auto next_ptr = state_->readahead_queue.FrontPtr();\n+    auto next = std::move(**next_ptr);\n+    state_->readahead_queue.PopFront();\n+\n+    auto last_available = state_->spaces_available.fetch_add(1);\n+    if (last_available == 0 && !finished) {\n+      // Reader idled out, we need to restart it\n+      ARROW_RETURN_NOT_OK(state_->Pump(state_));\n+    }\n+    return next;\n+  }\n+\n+ private:\n+  struct State {\n+    State(AsyncGenerator<T> source_, int max_readahead)\n+        : first(true),\n+          source(std::move(source_)),\n+          finished(false),\n+          spaces_available(max_readahead),\n+          readahead_queue(max_readahead) {}\n+\n+    Status Pump(const std::shared_ptr<State>& self) {\n+      // Can't do readahead_queue.write(source().Then(Callback{self})) because then the\n+      // callback might run immediately and add itself to the queue before this gets added\n+      // to the queue messing up the order\n+      auto next_slot = std::make_shared<Future<T>>();\n+      auto written = readahead_queue.Write(next_slot);\n+      if (!written) {\n+        return Status::UnknownError(\"Could not write to readahead_queue\");\n+      }\n+      *next_slot = source().Then(Callback{self});\n+      return Status::OK();\n+    }\n+\n+    // Only accessed by the consumer end\n+    bool first;\n+    // Accessed by both threads\n+    AsyncGenerator<T> source;\n+    std::atomic<bool> finished;\n+    std::atomic<uint32_t> spaces_available;\n+    util::SpscQueue<std::shared_ptr<Future<T>>> readahead_queue;\n\nReview comment:\n       `Future` is already basically a `shared_ptr`. Why do we need to wrap it in another one?\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -726,6 +730,138 @@ TEST(TestAsyncUtil, CompleteBackgroundStressTest) {\n   }\n }\n \n+template <typename T>\n+class ReentrantChecker {\n+ public:\n+  explicit ReentrantChecker(AsyncGenerator<T> source)\n+      : state_(std::make_shared<State>(std::move(source))) {}\n+\n+  Future<T> operator()() {\n+    if (state_->in.load()) {\n+      state_->valid.store(false);\n+    }\n+    state_->in.store(true);\n+    auto result = state_->source();\n+    return result.Then(Callback{state_});\n+  }\n+\n+  void AssertValid() {\n+    EXPECT_EQ(true, state_->valid.load())\n+        << \"The generator was accessed in a reentrant manner\";\n+  }\n+\n+ private:\n+  struct State {\n+    explicit State(AsyncGenerator<T> source_)\n+        : source(std::move(source_)), in(false), valid(true) {}\n+\n+    AsyncGenerator<T> source;\n+    std::atomic<bool> in;\n+    std::atomic<bool> valid;\n+  };\n+  struct Callback {\n+    Future<T> operator()(const Result<T>& result) {\n+      state_->in.store(false);\n+      return result;\n+    }\n+    std::shared_ptr<State> state_;\n+  };\n+\n+  std::shared_ptr<State> state_;\n+};\n+\n+TEST(TestAsyncUtil, SerialReadaheadSlowProducer) {\n+  AsyncGenerator<TestInt> it = BackgroundAsyncVectorIt({1, 2, 3, 4, 5});\n+  ReentrantChecker<TestInt> checker(std::move(it));\n+  SerialReadaheadGenerator<TestInt> serial_readahead(checker, 2);\n+  AssertAsyncGeneratorMatch({1, 2, 3, 4, 5},\n+                            static_cast<AsyncGenerator<TestInt>>(serial_readahead));\n+  checker.AssertValid();\n+}\n+\n+TEST(TestAsyncUtil, SerialReadaheadSlowConsumer) {\n+  int num_delivered = 0;\n+  auto source = [&num_delivered]() {\n+    if (num_delivered < 5) {\n+      return Future<TestInt>::MakeFinished(num_delivered++);\n+    } else {\n+      return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n+    }\n+  };\n+  SerialReadaheadGenerator<TestInt> serial_readahead(std::move(source), 3);\n+  SleepABit();\n+  ASSERT_EQ(0, num_delivered);\n\nReview comment:\n       Hmm, this may already have been discussed, but why doesn't the readahead generator start pumping as soon as you instantiate it?\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -726,6 +730,138 @@ TEST(TestAsyncUtil, CompleteBackgroundStressTest) {\n   }\n }\n \n+template <typename T>\n+class ReentrantChecker {\n+ public:\n+  explicit ReentrantChecker(AsyncGenerator<T> source)\n+      : state_(std::make_shared<State>(std::move(source))) {}\n+\n+  Future<T> operator()() {\n+    if (state_->in.load()) {\n+      state_->valid.store(false);\n+    }\n+    state_->in.store(true);\n+    auto result = state_->source();\n+    return result.Then(Callback{state_});\n+  }\n+\n+  void AssertValid() {\n+    EXPECT_EQ(true, state_->valid.load())\n+        << \"The generator was accessed in a reentrant manner\";\n+  }\n+\n+ private:\n+  struct State {\n+    explicit State(AsyncGenerator<T> source_)\n+        : source(std::move(source_)), in(false), valid(true) {}\n+\n+    AsyncGenerator<T> source;\n+    std::atomic<bool> in;\n+    std::atomic<bool> valid;\n+  };\n+  struct Callback {\n+    Future<T> operator()(const Result<T>& result) {\n+      state_->in.store(false);\n+      return result;\n+    }\n+    std::shared_ptr<State> state_;\n+  };\n+\n+  std::shared_ptr<State> state_;\n+};\n+\n+TEST(TestAsyncUtil, SerialReadaheadSlowProducer) {\n+  AsyncGenerator<TestInt> it = BackgroundAsyncVectorIt({1, 2, 3, 4, 5});\n+  ReentrantChecker<TestInt> checker(std::move(it));\n+  SerialReadaheadGenerator<TestInt> serial_readahead(checker, 2);\n+  AssertAsyncGeneratorMatch({1, 2, 3, 4, 5},\n+                            static_cast<AsyncGenerator<TestInt>>(serial_readahead));\n+  checker.AssertValid();\n+}\n+\n+TEST(TestAsyncUtil, SerialReadaheadSlowConsumer) {\n+  int num_delivered = 0;\n+  auto source = [&num_delivered]() {\n+    if (num_delivered < 5) {\n+      return Future<TestInt>::MakeFinished(num_delivered++);\n+    } else {\n+      return Future<TestInt>::MakeFinished(IterationTraits<TestInt>::End());\n\nReview comment:\n       Since this appears in various places, I think it would be nice to be able to write something like:\r\n   ```c++\r\n   return AsyncGeneratorEnd<TestInt>();\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +179,94 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+template <typename T>\n+class SerialReadaheadGenerator {\n+ public:\n+  SerialReadaheadGenerator(AsyncGenerator<T> source_generator, int max_readahead)\n+      : state_(std::make_shared<State>(std::move(source_generator), max_readahead)) {}\n+\n+  Future<T> operator()() {\n+    if (state_->first) {\n+      // Lazy generator, need to wait for the first ask to prime the pump\n+      state_->first = false;\n+      auto next = state_->source();\n+      return next.Then(Callback{state_});\n+    }\n+\n+    // This generator is not async-reentrant.  We won't be called until the last\n+    // future finished so we know there is something in the queue\n+    auto finished = state_->finished.load();\n+    if (finished && state_->readahead_queue.IsEmpty()) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+\n+    auto next_ptr = state_->readahead_queue.FrontPtr();\n+    auto next = std::move(**next_ptr);\n+    state_->readahead_queue.PopFront();\n+\n+    auto last_available = state_->spaces_available.fetch_add(1);\n+    if (last_available == 0 && !finished) {\n+      // Reader idled out, we need to restart it\n+      ARROW_RETURN_NOT_OK(state_->Pump(state_));\n+    }\n+    return next;\n+  }\n+\n+ private:\n+  struct State {\n+    State(AsyncGenerator<T> source_, int max_readahead)\n+        : first(true),\n+          source(std::move(source_)),\n+          finished(false),\n+          spaces_available(max_readahead),\n+          readahead_queue(max_readahead) {}\n+\n+    Status Pump(const std::shared_ptr<State>& self) {\n+      // Can't do readahead_queue.write(source().Then(Callback{self})) because then the\n+      // callback might run immediately and add itself to the queue before this gets added\n+      // to the queue messing up the order\n+      auto next_slot = std::make_shared<Future<T>>();\n+      auto written = readahead_queue.Write(next_slot);\n+      if (!written) {\n+        return Status::UnknownError(\"Could not write to readahead_queue\");\n+      }\n+      *next_slot = source().Then(Callback{self});\n+      return Status::OK();\n+    }\n+\n+    // Only accessed by the consumer end\n+    bool first;\n+    // Accessed by both threads\n+    AsyncGenerator<T> source;\n+    std::atomic<bool> finished;\n+    std::atomic<uint32_t> spaces_available;\n\nReview comment:\n       Can you add a comment explaining what this is? The name isn't very descriptive.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-10T13:44:54.115+0000",
                    "updated": "2021-03-10T13:44:54.115+0000",
                    "started": "2021-03-10T13:44:54.114+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "563756",
                    "issueId": "13358006"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/564510",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533#discussion_r592255544\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +179,94 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+template <typename T>\n+class SerialReadaheadGenerator {\n+ public:\n+  SerialReadaheadGenerator(AsyncGenerator<T> source_generator, int max_readahead)\n+      : state_(std::make_shared<State>(std::move(source_generator), max_readahead)) {}\n+\n+  Future<T> operator()() {\n+    if (state_->first) {\n+      // Lazy generator, need to wait for the first ask to prime the pump\n+      state_->first = false;\n+      auto next = state_->source();\n+      return next.Then(Callback{state_});\n+    }\n+\n+    // This generator is not async-reentrant.  We won't be called until the last\n+    // future finished so we know there is something in the queue\n+    auto finished = state_->finished.load();\n+    if (finished && state_->readahead_queue.IsEmpty()) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+\n+    auto next_ptr = state_->readahead_queue.FrontPtr();\n+    auto next = std::move(**next_ptr);\n+    state_->readahead_queue.PopFront();\n+\n+    auto last_available = state_->spaces_available.fetch_add(1);\n+    if (last_available == 0 && !finished) {\n+      // Reader idled out, we need to restart it\n+      ARROW_RETURN_NOT_OK(state_->Pump(state_));\n+    }\n+    return next;\n+  }\n+\n+ private:\n+  struct State {\n+    State(AsyncGenerator<T> source_, int max_readahead)\n+        : first(true),\n+          source(std::move(source_)),\n+          finished(false),\n+          spaces_available(max_readahead),\n+          readahead_queue(max_readahead) {}\n+\n+    Status Pump(const std::shared_ptr<State>& self) {\n+      // Can't do readahead_queue.write(source().Then(Callback{self})) because then the\n+      // callback might run immediately and add itself to the queue before this gets added\n+      // to the queue messing up the order\n+      auto next_slot = std::make_shared<Future<T>>();\n+      auto written = readahead_queue.Write(next_slot);\n+      if (!written) {\n+        return Status::UnknownError(\"Could not write to readahead_queue\");\n+      }\n+      *next_slot = source().Then(Callback{self});\n+      return Status::OK();\n+    }\n+\n+    // Only accessed by the consumer end\n+    bool first;\n+    // Accessed by both threads\n+    AsyncGenerator<T> source;\n+    std::atomic<bool> finished;\n+    std::atomic<uint32_t> spaces_available;\n+    util::SpscQueue<std::shared_ptr<Future<T>>> readahead_queue;\n\nReview comment:\n       We have to set the value of the future after it is added to the queue.  We want the value to be the value returned by `source().Then()` but we can't run `Then()` until after we add it to the queue.  Otherwise, if `Then` triggers synchronously it adds itself to the queue and we get items out of order.\r\n   \r\n   So we use a queue of shared pointers so we can add a pointer to the queue and set the value of that pointer later.  That's also why it's called `next_slot` instead of `next` because we are adding a slot for the future and then we go and get the future.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-11T10:47:59.336+0000",
                    "updated": "2021-03-11T10:47:59.336+0000",
                    "started": "2021-03-11T10:47:59.335+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "564510",
                    "issueId": "13358006"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/564515",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533#discussion_r592261147\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +179,94 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+template <typename T>\n+class SerialReadaheadGenerator {\n+ public:\n+  SerialReadaheadGenerator(AsyncGenerator<T> source_generator, int max_readahead)\n+      : state_(std::make_shared<State>(std::move(source_generator), max_readahead)) {}\n+\n+  Future<T> operator()() {\n+    if (state_->first) {\n+      // Lazy generator, need to wait for the first ask to prime the pump\n+      state_->first = false;\n+      auto next = state_->source();\n+      return next.Then(Callback{state_});\n+    }\n+\n+    // This generator is not async-reentrant.  We won't be called until the last\n+    // future finished so we know there is something in the queue\n+    auto finished = state_->finished.load();\n+    if (finished && state_->readahead_queue.IsEmpty()) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+\n+    auto next_ptr = state_->readahead_queue.FrontPtr();\n+    auto next = std::move(**next_ptr);\n+    state_->readahead_queue.PopFront();\n+\n+    auto last_available = state_->spaces_available.fetch_add(1);\n+    if (last_available == 0 && !finished) {\n+      // Reader idled out, we need to restart it\n+      ARROW_RETURN_NOT_OK(state_->Pump(state_));\n+    }\n+    return next;\n+  }\n+\n+ private:\n+  struct State {\n+    State(AsyncGenerator<T> source_, int max_readahead)\n+        : first(true),\n+          source(std::move(source_)),\n+          finished(false),\n+          spaces_available(max_readahead),\n+          readahead_queue(max_readahead) {}\n+\n+    Status Pump(const std::shared_ptr<State>& self) {\n+      // Can't do readahead_queue.write(source().Then(Callback{self})) because then the\n+      // callback might run immediately and add itself to the queue before this gets added\n+      // to the queue messing up the order\n+      auto next_slot = std::make_shared<Future<T>>();\n+      auto written = readahead_queue.Write(next_slot);\n+      if (!written) {\n+        return Status::UnknownError(\"Could not write to readahead_queue\");\n+      }\n+      *next_slot = source().Then(Callback{self});\n+      return Status::OK();\n+    }\n+\n+    // Only accessed by the consumer end\n+    bool first;\n+    // Accessed by both threads\n+    AsyncGenerator<T> source;\n+    std::atomic<bool> finished;\n+    std::atomic<uint32_t> spaces_available;\n+    util::SpscQueue<std::shared_ptr<Future<T>>> readahead_queue;\n+  };\n+\n+  struct Callback {\n+    Result<T> operator()(const Result<T>& maybe_next) {\n+      if (!maybe_next.ok()) {\n+        state_->finished.store(true);\n+        return maybe_next;\n+      }\n+      const auto& next = *maybe_next;\n+      if (next == IterationTraits<T>::End()) {\n+        state_->finished = true;\n+        return maybe_next;\n+      }\n+      auto last_available = state_->spaces_available.fetch_sub(1);\n+      if (last_available > 1) {\n+        ARROW_RETURN_NOT_OK(state_->Pump(state_));\n+      }\n+      return maybe_next;\n+    }\n+\n+    std::shared_ptr<State> state_;\n\nReview comment:\n       The `weak_ptr` is probably how we implement ARROW-11875.  I'd prefer to do it later as I don't want to get bogged down in testing it just yet but I can tackle it now if you want.\r\n   \r\n   As for stop tokens, nothing in this file should need to see the stop token.  Everything here is just coordinating the flow and there is nothing in here that should consume much time.  If something is cancelled it should just propagate as an invalid status.  For example, in serial readahead, if the reader is cancelled it will stop and return an invalid status.  That invalid status will reach SerialReadaheadGenerator::Callback which will check the result, find it invalid, and then stop reading.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-11T10:56:03.510+0000",
                    "updated": "2021-03-11T10:56:03.510+0000",
                    "started": "2021-03-11T10:56:03.510+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "564515",
                    "issueId": "13358006"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/564516",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533#discussion_r592263787\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +179,94 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+template <typename T>\n+class SerialReadaheadGenerator {\n+ public:\n+  SerialReadaheadGenerator(AsyncGenerator<T> source_generator, int max_readahead)\n+      : state_(std::make_shared<State>(std::move(source_generator), max_readahead)) {}\n+\n+  Future<T> operator()() {\n+    if (state_->first) {\n+      // Lazy generator, need to wait for the first ask to prime the pump\n+      state_->first = false;\n+      auto next = state_->source();\n+      return next.Then(Callback{state_});\n+    }\n+\n+    // This generator is not async-reentrant.  We won't be called until the last\n+    // future finished so we know there is something in the queue\n+    auto finished = state_->finished.load();\n+    if (finished && state_->readahead_queue.IsEmpty()) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+\n+    auto next_ptr = state_->readahead_queue.FrontPtr();\n+    auto next = std::move(**next_ptr);\n+    state_->readahead_queue.PopFront();\n+\n+    auto last_available = state_->spaces_available.fetch_add(1);\n+    if (last_available == 0 && !finished) {\n+      // Reader idled out, we need to restart it\n\nReview comment:\n       So there are two ends to this operator, the consumer and the producer.  The consumer pulls items off the readahead queue while the producer is putting items on the readahead queue.  When the producer adds an item they check to see if they filled up the queue.  If they did then they stop (and it will need to be restarted here).  If they did not then they call State::Pump and start reading the next item.\r\n   \r\n   If the producer stopped and the consumer later grabs an item off the queue then it needs to start the process up again and call State::Pump which is what is happening here.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-11T10:59:51.437+0000",
                    "updated": "2021-03-11T10:59:51.437+0000",
                    "started": "2021-03-11T10:59:51.436+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "564516",
                    "issueId": "13358006"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/worklog/564517",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9533:\nURL: https://github.com/apache/arrow/pull/9533#discussion_r592264611\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +179,94 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+template <typename T>\n+class SerialReadaheadGenerator {\n+ public:\n+  SerialReadaheadGenerator(AsyncGenerator<T> source_generator, int max_readahead)\n+      : state_(std::make_shared<State>(std::move(source_generator), max_readahead)) {}\n+\n+  Future<T> operator()() {\n+    if (state_->first) {\n+      // Lazy generator, need to wait for the first ask to prime the pump\n+      state_->first = false;\n+      auto next = state_->source();\n+      return next.Then(Callback{state_});\n+    }\n+\n+    // This generator is not async-reentrant.  We won't be called until the last\n+    // future finished so we know there is something in the queue\n+    auto finished = state_->finished.load();\n+    if (finished && state_->readahead_queue.IsEmpty()) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+\n+    auto next_ptr = state_->readahead_queue.FrontPtr();\n+    auto next = std::move(**next_ptr);\n+    state_->readahead_queue.PopFront();\n+\n+    auto last_available = state_->spaces_available.fetch_add(1);\n+    if (last_available == 0 && !finished) {\n+      // Reader idled out, we need to restart it\n+      ARROW_RETURN_NOT_OK(state_->Pump(state_));\n+    }\n+    return next;\n+  }\n+\n+ private:\n+  struct State {\n+    State(AsyncGenerator<T> source_, int max_readahead)\n+        : first(true),\n+          source(std::move(source_)),\n+          finished(false),\n+          spaces_available(max_readahead),\n+          readahead_queue(max_readahead) {}\n+\n+    Status Pump(const std::shared_ptr<State>& self) {\n+      // Can't do readahead_queue.write(source().Then(Callback{self})) because then the\n+      // callback might run immediately and add itself to the queue before this gets added\n+      // to the queue messing up the order\n+      auto next_slot = std::make_shared<Future<T>>();\n+      auto written = readahead_queue.Write(next_slot);\n+      if (!written) {\n+        return Status::UnknownError(\"Could not write to readahead_queue\");\n\nReview comment:\n       It isn't unbounded readahead.  The code should be keeping track of how many items are left in the queue (with spaces_available_).  If the queue fills up then it stops pumping futures from the generator.  So at no point should it try and write to a full queue.  If it did there would be no good option.  We can't block since we are asynchronous and we can't discard the item because the user will want it.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-11T11:01:04.404+0000",
                    "updated": "2021-03-11T11:01:04.404+0000",
                    "started": "2021-03-11T11:01:04.404+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "564517",
                    "issueId": "13358006"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/3",
            "id": "3",
            "description": "A task that needs to be done.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21148&avatarType=issuetype",
            "name": "Task",
            "subtask": false,
            "avatarId": 21148
        },
        "timespent": 27000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@424af0c6[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@395518[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4cc47e99[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@61f638c[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6f1b7aeb[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@5d79ae3d[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@32a623bd[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@4fd83566[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7ba0c254[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@6b38835b[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6800ee4a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@667d9529[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 27000,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Mar 15 13:48:02 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-03-15T13:48:02.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11590/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2021-02-10T19:11:28.000+0000",
        "updated": "2021-03-15T13:48:02.000+0000",
        "timeoriginalestimate": null,
        "description": "The current readahead accomplishes its task by using an async reentrant readahead.\u00a0 We get away with this today because the background generator is async reentrant because it runs on a thread pool of size 1 and so the underlying thread pool can only iterate the underlying iterator synchronously.\r\n\r\nHowever, in order to move to the I/O thread pool we need a readahead operator that is does not pull reentrantly.\r\n\r\nThis can be done either by submitting the next task as soon as the previous one is done or by creating a \"serial concurrency\" executor that wraps an underlying executor.\u00a0 Both approaches will need a queue so this can be done after ARROW-11588",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "7.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 27000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Move CSV background generator to IO thread pool",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358006/comment/17301653",
                    "id": "17301653",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 9533\n[https://github.com/apache/arrow/pull/9533]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-03-15T13:48:02.561+0000",
                    "updated": "2021-03-15T13:48:02.561+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0nkm0:",
        "customfield_12314139": null
    }
}