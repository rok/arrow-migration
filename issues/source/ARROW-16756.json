{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13448615",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615",
    "key": "ARROW-16756",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351550",
                "id": "12351550",
                "name": "9.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-08-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12641286",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12641286",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13448614",
                    "key": "ARROW-16755",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448614",
                    "fields": {
                        "summary": "[C++] Improve array expression and kernel evaluation performance on small inputs",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12641642",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12641642",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13449674",
                    "key": "ARROW-16819",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449674",
                    "fields": {
                        "summary": "[C++] arrow::compute::CallFunction needs a batch length for nullary functions",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12641675",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12641675",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13449793",
                    "key": "ARROW-16824",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449793",
                    "fields": {
                        "summary": "[C++] Migrate VectorKernel implementations to use ExecSpan, ArraySpan",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 50400,
            "total": 50400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 50400,
            "total": 50400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16756/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 84,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780365",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm opened a new pull request, #13364:\nURL: https://github.com/apache/arrow/pull/13364\n\n   Parent issue: ARROW-16755.\r\n   \r\n   ArraySpan has no shared pointers at all and is much cheaper to pass around, copy, and basically eliminates the current significant overhead associated with ExecBatch ExecBatchIterator. \r\n   \r\n   This PR isn't going to show meaningful performance gains in function or expression evaluation ",
                    "created": "2022-06-10T16:54:00.734+0000",
                    "updated": "2022-06-10T16:54:00.734+0000",
                    "started": "2022-06-10T16:54:00.734+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780365",
                    "issueId": "13448615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780366",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13364:\nURL: https://github.com/apache/arrow/pull/13364#issuecomment-1152555359\n\n   https://issues.apache.org/jira/browse/ARROW-16756\n\n\n",
                    "created": "2022-06-10T16:54:23.043+0000",
                    "updated": "2022-06-10T16:54:23.043+0000",
                    "started": "2022-06-10T16:54:23.043+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780366",
                    "issueId": "13448615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780367",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on PR #13364:\nURL: https://github.com/apache/arrow/pull/13364#issuecomment-1152557069\n\n   cc @save-buffer \n\n\n",
                    "created": "2022-06-10T16:55:29.750+0000",
                    "updated": "2022-06-10T16:55:29.750+0000",
                    "started": "2022-06-10T16:55:29.750+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780367",
                    "issueId": "13448615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780413",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13364:\nURL: https://github.com/apache/arrow/pull/13364#discussion_r894764398\n\n\n##########\ncpp/src/arrow/compute/exec_internal.h:\n##########\n@@ -62,16 +63,65 @@ class ARROW_EXPORT ExecBatchIterator {\n   int64_t max_chunksize() const { return max_chunksize_; }\n \n  private:\n-  ExecBatchIterator(std::vector<Datum> args, int64_t length, int64_t max_chunksize);\n+  ExecBatchIterator(const std::vector<Datum>& args, int64_t length,\n+                    int64_t max_chunksize);\n \n-  std::vector<Datum> args_;\n+  const std::vector<Datum>& args_;\n   std::vector<int> chunk_indexes_;\n   std::vector<int64_t> chunk_positions_;\n   int64_t position_;\n   int64_t length_;\n   int64_t max_chunksize_;\n };\n \n+/// \\brief Break std::vector<Datum> into a sequence of non-owning\n+/// ExecSpan for kernel execution. The lifetime of the Datum vector\n+/// must be longer than the lifetime of this object\n+class ARROW_EXPORT ExecSpanIterator {\n+ public:\n+  /// \\brief Construct iterator and do basic argument validation\n+  ///\n+  /// \\param[in] args the Datum argument, must be all array-like or scalar\n+  /// \\param[in] max_chunksize the maximum length of each ExecSpan. Depending\n+  /// on the chunk layout of ChunkedArray.\n+  static Result<std::unique_ptr<ExecSpanIterator>> Make(\n\nReview Comment:\n   Why do we need `unique_ptr` here? I think for something like an iterator it would make more sense to avoid any heap allocations\n\n\n\n##########\ncpp/src/arrow/compute/kernels/util_internal.h:\n##########\n@@ -67,14 +67,16 @@ int GetBitWidth(const DataType& type);\n // rather than duplicating compiled code to do all these in each kernel.\n PrimitiveArg GetPrimitiveArg(const ArrayData& arr);\n \n-// Augment a unary ArrayKernelExec which supports only array-like inputs with support for\n-// scalar inputs. Scalars will be transformed to 1-long arrays with the scalar's value (or\n-// null if the scalar is null) as its only element. This 1-long array will be passed to\n-// the original exec, then the only element of the resulting array will be extracted as\n-// the output scalar. This could be far more efficient, but instead of optimizing this\n-// it'd be better to support scalar inputs \"upstream\" in original exec.\n-ArrayKernelExec TrivialScalarUnaryAsArraysExec(\n-    ArrayKernelExec exec, NullHandling::type null_handling = NullHandling::INTERSECTION);\n+// Augment a unary ScalarernelExec which supports only array-like inputs with\n\nReview Comment:\n   ScalarKernelExec\n\n\n\n##########\ncpp/src/arrow/compute/exec.cc:\n##########\n@@ -325,35 +352,158 @@ bool ExecBatchIterator::Next(ExecBatch* batch) {\n   return true;\n }\n \n+// ----------------------------------------------------------------------\n+// ExecSpanIterator; to eventually replace ExecBatchIterator\n+\n+ExecSpanIterator::ExecSpanIterator(const std::vector<Datum>& args, int64_t length,\n+                                   int64_t max_chunksize)\n+    : args_(args), position_(0), length_(length), max_chunksize_(max_chunksize) {\n+  chunk_indexes_.resize(args_.size(), 0);\n+  value_positions_.resize(args_.size(), 0);\n+  value_offsets_.resize(args_.size(), 0);\n+}\n+\n+Result<std::unique_ptr<ExecSpanIterator>> ExecSpanIterator::Make(\n+    const std::vector<Datum>& args, int64_t max_chunksize) {\n+  int64_t length = 1;\n+  RETURN_NOT_OK(GetBatchLength(args, &length));\n+  max_chunksize = std::min(length, max_chunksize);\n+  return std::unique_ptr<ExecSpanIterator>(\n+      new ExecSpanIterator(args, length, max_chunksize));\n+}\n+\n+int64_t ExecSpanIterator::GetNextChunkSpan(int64_t iteration_size, ExecSpan* span) {\n+  for (size_t i = 0; i < args_.size() && iteration_size > 0; ++i) {\n+    // If the argument is not a chunked array, it's either a Scalar or Array,\n+    // in which case it doesn't influence the size of this span. Note that if\n+    // the args are all scalars the span length is 1\n+    if (!args_[i].is_chunked_array()) {\n+      continue;\n+    }\n+    const ChunkedArray* arg = args_[i].chunked_array().get();\n+    const Array* current_chunk;\n+    while (true) {\n+      current_chunk = arg->chunk(chunk_indexes_[i]).get();\n+      if (value_positions_[i] == current_chunk->length()) {\n+        // Chunk is zero-length, or was exhausted in the previous\n+        // iteration. Move to the next chunk\n+        ++chunk_indexes_[i];\n+        current_chunk = arg->chunk(chunk_indexes_[i]).get();\n+        span->values[i].SetArray(*current_chunk->data());\n+        value_positions_[i] = 0;\n+        value_offsets_[i] = current_chunk->offset();\n+        continue;\n+      }\n+      break;\n+    }\n+    iteration_size =\n+        std::min(current_chunk->length() - value_positions_[i], iteration_size);\n+  }\n+  return iteration_size;\n+}\n+\n+bool ExecSpanIterator::Next(ExecSpan* span) {\n+  if (position_ == length_) {\n+    // This also protects from degenerate cases like ChunkedArrays\n+    // without any chunks\n+    return false;\n+  }\n+\n+  if (!initialized_) {\n+    span->length = 0;\n+\n+    // The first this this is called, we populate the output span with\n\nReview Comment:\n   nit typos: `first time`... `members updated during the iteration`\n\n\n\n##########\ncpp/src/arrow/compute/exec.h:\n##########\n@@ -252,6 +254,192 @@ struct ARROW_EXPORT ExecBatch {\n inline bool operator==(const ExecBatch& l, const ExecBatch& r) { return l.Equals(r); }\n inline bool operator!=(const ExecBatch& l, const ExecBatch& r) { return !l.Equals(r); }\n \n+struct ExecValue {\n\nReview Comment:\n   Big fan of this class.\n\n\n\n##########\ncpp/src/arrow/compute/exec.h:\n##########\n@@ -252,6 +254,192 @@ struct ARROW_EXPORT ExecBatch {\n inline bool operator==(const ExecBatch& l, const ExecBatch& r) { return l.Equals(r); }\n inline bool operator!=(const ExecBatch& l, const ExecBatch& r) { return !l.Equals(r); }\n \n+struct ExecValue {\n+  enum Kind { ARRAY, SCALAR };\n+  Kind kind = ARRAY;\n+  ArraySpan array;\n+  const Scalar* scalar;\n+\n+  ExecValue(Scalar* scalar)  // NOLINT implicit conversion\n+      : kind(SCALAR), scalar(scalar) {}\n+\n+  ExecValue(ArraySpan array)  // NOLINT implicit conversion\n+      : kind(ARRAY), array(std::move(array)) {}\n+\n+  ExecValue(const ArrayData& array)  // NOLINT implicit conversion\n+      : kind(ARRAY) {\n+    this->array.SetMembers(array);\n+  }\n+\n+  ExecValue() = default;\n+  ExecValue(const ExecValue& other) = default;\n+  ExecValue& operator=(const ExecValue& other) = default;\n+  ExecValue(ExecValue&& other) = default;\n+  ExecValue& operator=(ExecValue&& other) = default;\n+\n+  int64_t length() const { return this->is_array() ? this->array.length : 1; }\n+\n+  bool is_array() const { return this->kind == ARRAY; }\n+  bool is_scalar() const { return this->kind == SCALAR; }\n+\n+  void SetArray(const ArrayData& array) {\n+    this->kind = ARRAY;\n+    this->array.SetMembers(array);\n+  }\n+\n+  void SetScalar(const Scalar* scalar) {\n+    this->kind = SCALAR;\n+    this->scalar = scalar;\n+  }\n+\n+  template <typename ExactType>\n+  const ExactType& scalar_as() const {\n+    return ::arrow::internal::checked_cast<const ExactType&>(*this->scalar);\n+  }\n+\n+  /// XXX: here only temporarily until type resolution can be cleaned\n+  /// up to not use ValueDescr\n+  ValueDescr descr() const {\n+    ValueDescr::Shape shape = this->is_array() ? ValueDescr::ARRAY : ValueDescr::SCALAR;\n+    return ValueDescr(const_cast<DataType*>(this->type())->shared_from_this(), shape);\n+  }\n+\n+  /// XXX: here temporarily for compatibility with datum, see\n+  /// e.g. MakeStructExec in scalar_nested.cc\n+  int64_t null_count() const {\n+    if (this->is_array()) {\n+      return this->array.GetNullCount();\n+    } else {\n+      return this->scalar->is_valid ? 0 : 1;\n+    }\n+  }\n+\n+  const DataType* type() const {\n+    if (this->kind == ARRAY) {\n+      return array.type;\n+    } else {\n+      return scalar->type.get();\n+    }\n+  }\n+};\n+\n+struct ARROW_EXPORT ExecResult {\n+  // The default value of the variant is ArraySpan\n+  // TODO(wesm): remove Scalar output modality in ARROW-16577\n+  util::Variant<ArraySpan, std::shared_ptr<ArrayData>, std::shared_ptr<Scalar>> value;\n+\n+  int64_t length() const {\n+    if (this->is_array_span()) {\n+      return this->array_span()->length;\n+    } else if (this->is_array_data()) {\n+      return this->array_data()->length;\n+    } else {\n+      // Should not reach here\n+      return 1;\n+    }\n+  }\n+\n+  const DataType* type() const {\n+    switch (this->value.index()) {\n+      case 0:\n+        return this->array_span()->type;\n+      case 1:\n+        return this->array_data()->type.get();\n+      default:\n+        // scalar\n+        return this->scalar()->type.get();\n+    };\n+  }\n+\n+  ArraySpan* array_span() const {\n+    return const_cast<ArraySpan*>(&util::get<ArraySpan>(this->value));\n+  }\n+  bool is_array_span() const { return this->value.index() == 0; }\n+\n+  const std::shared_ptr<ArrayData>& array_data() const {\n+    return util::get<std::shared_ptr<ArrayData>>(this->value);\n+  }\n+\n+  bool is_array_data() const { return this->value.index() == 1; }\n+\n+  const std::shared_ptr<Scalar>& scalar() const {\n+    return util::get<std::shared_ptr<Scalar>>(this->value);\n+  }\n+\n+  bool is_scalar() const { return this->value.index() == 2; }\n+};\n+\n+/// \\brief A \"lightweight\" column batch object which contains no\n+/// std::shared_ptr objects and does not have any memory ownership\n+/// semantics. Can represent a view onto an \"owning\" ExecBatch.\n+struct ARROW_EXPORT ExecSpan {\n+  ExecSpan() = default;\n+  ExecSpan(const ExecSpan& other) = default;\n+  ExecSpan& operator=(const ExecSpan& other) = default;\n+  ExecSpan(ExecSpan&& other) = default;\n+  ExecSpan& operator=(ExecSpan&& other) = default;\n+\n+  explicit ExecSpan(std::vector<ExecValue> values, int64_t length)\n+      : length(length), values(std::move(values)) {}\n+\n+  explicit ExecSpan(const ExecBatch& batch) {\n+    this->length = batch.length;\n+    this->values.resize(batch.values.size());\n+    for (size_t i = 0; i < batch.values.size(); ++i) {\n+      const Datum& in_value = batch[i];\n+      ExecValue* out_value = &this->values[i];\n+      if (in_value.is_array()) {\n+        out_value->SetArray(*in_value.array());\n+      } else {\n+        out_value->SetScalar(in_value.scalar().get());\n+      }\n+    }\n+  }\n+\n+  bool is_all_scalar() const {\n+    return std::all_of(this->values.begin(), this->values.end(),\n+                       [](const ExecValue& v) { return v.is_scalar(); });\n+  }\n+\n+  /// \\brief Return the value at the i-th index\n+  template <typename index_type>\n+  inline const ExecValue& operator[](index_type i) const {\n+    return values[i];\n+  }\n+\n+  void AddOffset(int64_t offset) {\n+    for (ExecValue& value : values) {\n+      if (value.kind == ExecValue::ARRAY) {\n+        value.array.AddOffset(offset);\n+      }\n+    }\n+  }\n+\n+  void SetOffset(int64_t offset) {\n+    for (ExecValue& value : values) {\n+      if (value.kind == ExecValue::ARRAY) {\n+        value.array.SetOffset(offset);\n+      }\n+    }\n+  }\n+\n+  /// \\brief A convenience for the number of values / arguments.\n+  int num_values() const { return static_cast<int>(values.size()); }\n+\n+  // XXX: eliminate the need for ValueDescr; copied temporarily from\n+  // ExecBatch\n+  std::vector<ValueDescr> GetDescriptors() const {\n+    std::vector<ValueDescr> result;\n+    for (const auto& value : this->values) {\n+      result.emplace_back(value.descr());\n+    }\n+    return result;\n+  }\n+\n+  int64_t length;\n+  std::vector<ExecValue> values;\n\nReview Comment:\n   I am a little sus about this std::vector. May be ok for now but eventually I'd like to avoid small heap allocations. When we add a bump allocator for this kind of stuff within Acero, I'd like to switch to that. \r\n   \r\n   If we want to support that now, we can just make this ExecSpan take a pointer to ExecValue and the number of ExecValues, so that ExecSpan doesn't have to touch the heap at all either.\n\n\n\n##########\ncpp/src/arrow/array/data.h:\n##########\n@@ -242,6 +245,127 @@ struct ARROW_EXPORT ArrayData {\n   std::shared_ptr<ArrayData> dictionary;\n };\n \n+/// \\brief A non-owning Buffer reference\n+struct ARROW_EXPORT BufferRef {\n+  // It is the user of this class's responsibility to ensure that\n+  // buffers that were const originally are not written to\n+  // accidentally.\n+  uint8_t* data = NULLPTR;\n+  int64_t size = 0;\n+  // Pointer back to buffer that owns this memory\n+  const std::shared_ptr<Buffer>* owner = NULLPTR;\n+};\n+\n+/// \\brief EXPERIMENTAL: A non-owning ArrayData reference that is cheaply\n+/// copyable and does not contain any shared_ptr objects. Do not use in public\n+/// APIs aside from compute kernels for now\n+struct ARROW_EXPORT ArraySpan {\n+  const DataType* type;\n+  int64_t length = 0;\n+  mutable int64_t null_count = kUnknownNullCount;\n+  int64_t offset = 0;\n+  BufferRef buffers[3];\n+\n+  ArraySpan() = default;\n+\n+  explicit ArraySpan(const DataType* type, int64_t length) : type(type), length(length) {}\n+  explicit ArraySpan(const ArrayData& data) { SetMembers(data); }\n+  explicit ArraySpan(const Scalar& data) { FillFromScalar(data); }\n+\n+  /// If dictionary-encoded, put dictionary in the first entry\n+  // TODO(wesm): would a std::unique_ptr<vector<...>> be better?\n\nReview Comment:\n   I don't see why it would be, `unique_ptr<vector>` here would just amount to having a pointer to a pointer to an an array instead of just a pointer to an array.\n\n\n\n##########\ncpp/src/arrow/compute/exec_internal.h:\n##########\n@@ -62,16 +63,65 @@ class ARROW_EXPORT ExecBatchIterator {\n   int64_t max_chunksize() const { return max_chunksize_; }\n \n  private:\n-  ExecBatchIterator(std::vector<Datum> args, int64_t length, int64_t max_chunksize);\n+  ExecBatchIterator(const std::vector<Datum>& args, int64_t length,\n+                    int64_t max_chunksize);\n \n-  std::vector<Datum> args_;\n+  const std::vector<Datum>& args_;\n   std::vector<int> chunk_indexes_;\n   std::vector<int64_t> chunk_positions_;\n   int64_t position_;\n   int64_t length_;\n   int64_t max_chunksize_;\n };\n \n+/// \\brief Break std::vector<Datum> into a sequence of non-owning\n+/// ExecSpan for kernel execution. The lifetime of the Datum vector\n+/// must be longer than the lifetime of this object\n+class ARROW_EXPORT ExecSpanIterator {\n+ public:\n+  /// \\brief Construct iterator and do basic argument validation\n+  ///\n+  /// \\param[in] args the Datum argument, must be all array-like or scalar\n+  /// \\param[in] max_chunksize the maximum length of each ExecSpan. Depending\n+  /// on the chunk layout of ChunkedArray.\n+  static Result<std::unique_ptr<ExecSpanIterator>> Make(\n\nReview Comment:\n   Why do we need unique_ptr here? I think for something like an iterator it would make more sense to avoid any heap allocations\r\n   \n\n\n\n",
                    "created": "2022-06-10T19:09:28.898+0000",
                    "updated": "2022-06-10T19:09:28.898+0000",
                    "started": "2022-06-10T19:09:28.898+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780413",
                    "issueId": "13448615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780414",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #13364:\nURL: https://github.com/apache/arrow/pull/13364#discussion_r894754216\n\n\n##########\ncpp/src/arrow/array/data.h:\n##########\n@@ -242,6 +245,127 @@ struct ARROW_EXPORT ArrayData {\n   std::shared_ptr<ArrayData> dictionary;\n };\n \n+/// \\brief A non-owning Buffer reference\n+struct ARROW_EXPORT BufferRef {\n+  // It is the user of this class's responsibility to ensure that\n+  // buffers that were const originally are not written to\n+  // accidentally.\n+  uint8_t* data = NULLPTR;\n+  int64_t size = 0;\n+  // Pointer back to buffer that owns this memory\n+  const std::shared_ptr<Buffer>* owner = NULLPTR;\n+};\n+\n+/// \\brief EXPERIMENTAL: A non-owning ArrayData reference that is cheaply\n+/// copyable and does not contain any shared_ptr objects. Do not use in public\n+/// APIs aside from compute kernels for now\n+struct ARROW_EXPORT ArraySpan {\n+  const DataType* type;\n+  int64_t length = 0;\n+  mutable int64_t null_count = kUnknownNullCount;\n+  int64_t offset = 0;\n+  BufferRef buffers[3];\n+\n+  ArraySpan() = default;\n+\n+  explicit ArraySpan(const DataType* type, int64_t length) : type(type), length(length) {}\n+  explicit ArraySpan(const ArrayData& data) { SetMembers(data); }\n+  explicit ArraySpan(const Scalar& data) { FillFromScalar(data); }\n+\n+  /// If dictionary-encoded, put dictionary in the first entry\n+  // TODO(wesm): would a std::unique_ptr<vector<...>> be better?\n\nReview Comment:\n   the motivation being to avoid copying the vector?\r\n   \r\n   also, is the SmallVector we have potentially useful here?\n\n\n\n##########\ncpp/src/arrow/scalar.h:\n##########\n@@ -129,6 +135,9 @@ namespace internal {\n \n struct ARROW_EXPORT PrimitiveScalarBase : public Scalar {\n   using Scalar::Scalar;\n+  /// \\brief Get an immutable pointer to the value of this scalar. May be null.\n+  virtual const void* data() const = 0;\n\nReview Comment:\n   This seems redundant with `view()` below or could be defined in terms of `view()`\n\n\n\n##########\ncpp/src/arrow/util/bitmap.h:\n##########\n@@ -53,27 +53,36 @@ class ARROW_EXPORT Bitmap : public util::ToStringOstreamable<Bitmap>,\n \n   Bitmap() = default;\n \n-  Bitmap(std::shared_ptr<Buffer> buffer, int64_t offset, int64_t length)\n-      : buffer_(std::move(buffer)), offset_(offset), length_(length) {}\n+  Bitmap(const std::shared_ptr<Buffer>& buffer, int64_t offset, int64_t length)\n\nReview Comment:\n   another refactor to consider: since this is now non-owning maybe this should be `BitmapView` or `BitmapSpan` and/or maybe should be built on top of `BufferRef`\r\n   \r\n   also, do we want to perhaps adopt a consistent naming convention for view/span/reference types? \n\n\n\n##########\ncpp/src/arrow/array/data.cc:\n##########\n@@ -128,6 +131,143 @@ int64_t ArrayData::GetNullCount() const {\n   return precomputed;\n }\n \n+// ----------------------------------------------------------------------\n+// Methods for ArraySpan\n+\n+void ArraySpan::SetMembers(const ArrayData& data) {\n+  this->type = data.type.get();\n+  this->length = data.length;\n+  this->null_count = data.null_count.load();\n+  this->offset = data.offset;\n+\n+  for (size_t i = 0; i < data.buffers.size(); ++i) {\n+    const std::shared_ptr<Buffer>& buffer = data.buffers[i];\n+    // It is the invoker-of-kernels's responsibility to ensure that\n+    // const buffers are not written to accidentally.\n+    if (buffer) {\n+      SetBuffer(i, buffer);\n+    } else {\n+      ClearBuffer(i);\n+    }\n+  }\n+\n+  // Makes sure any other buffers are seen as null / non-existent\n+  for (size_t i = data.buffers.size(); i < 3; ++i) {\n+    ClearBuffer(i);\n+  }\n+\n+  // TODO(wesm): what about extension arrays?\n\nReview Comment:\n   Seems having methods that always delegated to the storage type would let these methods be generic over extension types\n\n\n\n##########\ncpp/src/arrow/array/data.h:\n##########\n@@ -242,6 +245,127 @@ struct ARROW_EXPORT ArrayData {\n   std::shared_ptr<ArrayData> dictionary;\n };\n \n+/// \\brief A non-owning Buffer reference\n+struct ARROW_EXPORT BufferRef {\n+  // It is the user of this class's responsibility to ensure that\n+  // buffers that were const originally are not written to\n+  // accidentally.\n+  uint8_t* data = NULLPTR;\n+  int64_t size = 0;\n+  // Pointer back to buffer that owns this memory\n+  const std::shared_ptr<Buffer>* owner = NULLPTR;\n+};\n+\n+/// \\brief EXPERIMENTAL: A non-owning ArrayData reference that is cheaply\n+/// copyable and does not contain any shared_ptr objects. Do not use in public\n+/// APIs aside from compute kernels for now\n+struct ARROW_EXPORT ArraySpan {\n+  const DataType* type;\n+  int64_t length = 0;\n+  mutable int64_t null_count = kUnknownNullCount;\n+  int64_t offset = 0;\n+  BufferRef buffers[3];\n+\n+  ArraySpan() = default;\n+\n+  explicit ArraySpan(const DataType* type, int64_t length) : type(type), length(length) {}\n+  explicit ArraySpan(const ArrayData& data) { SetMembers(data); }\n+  explicit ArraySpan(const Scalar& data) { FillFromScalar(data); }\n\nReview Comment:\n   Given the number of small changes to call this constructor all over, I wonder if it's worth letting these be implicit constructors like we do for a few other 'core' types. Then again hiding the conversion might be too error-prone.\n\n\n\n",
                    "created": "2022-06-10T19:26:46.569+0000",
                    "updated": "2022-06-10T19:26:46.569+0000",
                    "started": "2022-06-10T19:26:46.569+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780414",
                    "issueId": "13448615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780447",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on code in PR #13364:\nURL: https://github.com/apache/arrow/pull/13364#discussion_r894725732\n\n\n##########\ncpp/src/arrow/array/array_nested.h:\n##########\n@@ -378,7 +378,7 @@ class ARROW_EXPORT StructArray : public Array {\n   // Return a shared pointer in case the requestor desires to share ownership\n   // with this array.  The returned array has its offset, length and null\n   // count adjusted.\n-  std::shared_ptr<Array> field(int pos) const;\n+  const std::shared_ptr<Array>& field(int pos) const;\n\nReview Comment:\n   This makes a shared_ptr copy that is often not needed\n\n\n\n##########\ncpp/src/arrow/array/data.cc:\n##########\n@@ -128,6 +131,143 @@ int64_t ArrayData::GetNullCount() const {\n   return precomputed;\n }\n \n+// ----------------------------------------------------------------------\n+// Methods for ArraySpan\n+\n+void ArraySpan::SetMembers(const ArrayData& data) {\n+  this->type = data.type.get();\n+  this->length = data.length;\n+  this->null_count = data.null_count.load();\n+  this->offset = data.offset;\n+\n+  for (size_t i = 0; i < data.buffers.size(); ++i) {\n+    const std::shared_ptr<Buffer>& buffer = data.buffers[i];\n+    // It is the invoker-of-kernels's responsibility to ensure that\n+    // const buffers are not written to accidentally.\n+    if (buffer) {\n+      SetBuffer(i, buffer);\n+    } else {\n+      ClearBuffer(i);\n+    }\n+  }\n+\n+  // Makes sure any other buffers are seen as null / non-existent\n+  for (size_t i = data.buffers.size(); i < 3; ++i) {\n+    ClearBuffer(i);\n+  }\n+\n+  // TODO(wesm): what about extension arrays?\n\nReview Comment:\n   Nothing needed, will correct comment\n\n\n\n##########\ncpp/src/arrow/array/data.cc:\n##########\n@@ -128,6 +131,143 @@ int64_t ArrayData::GetNullCount() const {\n   return precomputed;\n }\n \n+// ----------------------------------------------------------------------\n+// Methods for ArraySpan\n+\n+void ArraySpan::SetMembers(const ArrayData& data) {\n+  this->type = data.type.get();\n+  this->length = data.length;\n+  this->null_count = data.null_count.load();\n+  this->offset = data.offset;\n+\n+  for (size_t i = 0; i < data.buffers.size(); ++i) {\n+    const std::shared_ptr<Buffer>& buffer = data.buffers[i];\n+    // It is the invoker-of-kernels's responsibility to ensure that\n+    // const buffers are not written to accidentally.\n+    if (buffer) {\n+      SetBuffer(i, buffer);\n+    } else {\n+      ClearBuffer(i);\n+    }\n+  }\n+\n+  // Makes sure any other buffers are seen as null / non-existent\n+  for (size_t i = data.buffers.size(); i < 3; ++i) {\n+    ClearBuffer(i);\n+  }\n+\n+  // TODO(wesm): what about extension arrays?\n+\n+  if (this->type->id() == Type::DICTIONARY) {\n+    this->child_data.resize(1);\n+    this->child_data[0].SetMembers(*data.dictionary);\n+  } else {\n+    this->child_data.resize(data.child_data.size());\n+    for (size_t child_index = 0; child_index < data.child_data.size(); ++child_index) {\n+      this->child_data[child_index].SetMembers(*data.child_data[child_index]);\n+    }\n+  }\n+}\n+\n+void ArraySpan::FillFromScalar(const Scalar& value) {\n+  static const uint8_t kValidByte = 0x01;\n+  static const uint8_t kNullByte = 0x00;\n+\n+  this->type = value.type.get();\n+  this->length = 1;\n+\n+  // Populate null count and validity bitmap\n+  this->null_count = value.is_valid ? 0 : 1;\n+  this->buffers[0].data = const_cast<uint8_t*>(value.is_valid ? &kValidByte : &kNullByte);\n+  this->buffers[0].size = 1;\n+\n+  if (is_primitive(value.type->id())) {\n+    const auto& scalar =\n+        internal::checked_cast<const internal::PrimitiveScalarBase&>(value);\n+    const uint8_t* scalar_data = reinterpret_cast<const uint8_t*>(scalar.data());\n+    this->buffers[1].data = const_cast<uint8_t*>(scalar_data);\n+    this->buffers[1].size = scalar.type->byte_width();\n+  } else {\n+    // TODO(wesm): implement for other types\n+    DCHECK(false) << \"need to implement for other types\";\n\nReview Comment:\n   Open Jira for follow up work\n\n\n\n##########\ncpp/src/arrow/compute/kernels/scalar_if_else.cc:\n##########\n@@ -77,170 +64,239 @@ Status CheckIdenticalTypes(const Datum* begin, size_t count) {\n   return Status::OK();\n }\n \n+constexpr uint64_t kAllNull = 0;\n+constexpr uint64_t kAllValid = ~kAllNull;\n+\n+util::optional<uint64_t> GetConstantValidityWord(const ExecValue& data) {\n+  if (data.is_scalar()) {\n+    return data.scalar->is_valid ? kAllValid : kAllNull;\n+  }\n+\n+  if (data.array.null_count == data.array.length) return kAllNull;\n+  if (!data.array.MayHaveNulls()) return kAllValid;\n+\n+  // no constant validity word available\n+  return {};\n+}\n+\n // if the condition is null then output is null otherwise we take validity from the\n // selected argument\n // ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n-template <typename AllocateNullBitmap>\n-Status PromoteNullsVisitor(KernelContext* ctx, const Datum& cond_d, const Datum& left_d,\n-                           const Datum& right_d, ArrayData* output) {\n-  auto cond_const = GetConstantValidityWord(cond_d);\n-  auto left_const = GetConstantValidityWord(left_d);\n-  auto right_const = GetConstantValidityWord(right_d);\n+struct IfElseNullPromoter {\n+  KernelContext* ctx;\n+  const ArraySpan& cond;\n+  const ExecValue& left_d;\n+  const ExecValue& right_d;\n+  ExecResult* output;\n \n   enum { COND_CONST = 1, LEFT_CONST = 2, RIGHT_CONST = 4 };\n-  auto flag = COND_CONST * cond_const.has_value() | LEFT_CONST * left_const.has_value() |\n-              RIGHT_CONST * right_const.has_value();\n-\n-  const ArrayData& cond = *cond_d.array();\n-  // cond.data will always be available\n-  Bitmap cond_data{cond.buffers[1], cond.offset, cond.length};\n-  Bitmap cond_valid{cond.buffers[0], cond.offset, cond.length};\n-  Bitmap left_valid = GetBitmap(left_d, 0);\n-  Bitmap right_valid = GetBitmap(right_d, 0);\n-\n-  // cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n-  // In the following cases, we dont need to allocate out_valid bitmap\n-\n-  // if cond & left & right all ones, then output is all valid.\n-  // if output validity buffer is already allocated (NullHandling::\n-  // COMPUTED_PREALLOCATE) -> set all bits\n-  // else, return nullptr\n-  if (cond_const == kAllValid && left_const == kAllValid && right_const == kAllValid) {\n-    if (AllocateNullBitmap::value) {  // NullHandling::COMPUTED_NO_PREALLOCATE\n-      output->buffers[0] = nullptr;\n-    } else {  // NullHandling::COMPUTED_PREALLOCATE\n-      bit_util::SetBitmap(output->buffers[0]->mutable_data(), output->offset,\n-                          output->length);\n+  int64_t constant_validity_flag;\n+  util::optional<uint64_t> cond_const, left_const, right_const;\n+  Bitmap cond_data, cond_valid, left_valid, right_valid;\n+\n+  IfElseNullPromoter(KernelContext* ctx, const ExecValue& cond_d, const ExecValue& left_d,\n+                     const ExecValue& right_d, ExecResult* output)\n+      : ctx(ctx), cond(cond_d.array), left_d(left_d), right_d(right_d), output(output) {\n+    cond_const = GetConstantValidityWord(cond_d);\n+    left_const = GetConstantValidityWord(left_d);\n+    right_const = GetConstantValidityWord(right_d);\n+\n+    // Encodes whether each of the arguments is respectively all-null or\n+    // all-valid\n+    constant_validity_flag =\n+        (COND_CONST * cond_const.has_value() | LEFT_CONST * left_const.has_value() |\n+         RIGHT_CONST * right_const.has_value());\n+\n+    // cond.data will always be available / is always an array\n+    cond_data = Bitmap{cond.buffers[1].data, cond.offset, cond.length};\n+    cond_valid = Bitmap{cond.buffers[0].data, cond.offset, cond.length};\n+    left_valid = GetBitmap(left_d, 0);\n+    right_valid = GetBitmap(right_d, 0);\n+  }\n+\n+  Status ExecIntoArrayData(bool need_to_allocate) {\n+    ArrayData* out_arr = output->array_data().get();\n+\n+    // cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+    // In the following cases, we dont need to allocate out_valid bitmap\n+\n+    // if cond & left & right all ones, then output is all valid.\n+    // if output validity buffer is already allocated (NullHandling::\n+    // COMPUTED_PREALLOCATE) -> set all bits\n+    // else, return nullptr\n+    if (cond_const == kAllValid && left_const == kAllValid && right_const == kAllValid) {\n+      if (need_to_allocate) {  // NullHandling::COMPUTED_NO_PREALLOCATE\n+        out_arr->buffers[0] = nullptr;\n+      } else {  // NullHandling::COMPUTED_PREALLOCATE\n+        bit_util::SetBitmap(out_arr->buffers[0]->mutable_data(), out_arr->offset,\n+                            out_arr->length);\n+      }\n+    } else if (left_const == kAllValid && right_const == kAllValid) {\n+      // if both left and right are valid, no need to calculate out_valid bitmap. Copy\n+      // cond validity buffer\n+      if (need_to_allocate) {  // NullHandling::COMPUTED_NO_PREALLOCATE\n+        // if there's an offset, copy bitmap (cannot slice a bitmap)\n+        if (cond.offset) {\n+          ARROW_ASSIGN_OR_RAISE(\n+              out_arr->buffers[0],\n+              arrow::internal::CopyBitmap(ctx->memory_pool(), cond.buffers[0].data,\n+                                          cond.offset, cond.length));\n+        } else {\n+          // just copy assign cond validity buffer\n+          out_arr->buffers[0] = cond.GetBuffer(0);\n+        }\n+      } else {  // NullHandling::COMPUTED_PREALLOCATE\n+        arrow::internal::CopyBitmap(cond.buffers[0].data, cond.offset, cond.length,\n+                                    out_arr->buffers[0]->mutable_data(), out_arr->offset);\n+      }\n+    } else {\n+      if (need_to_allocate) {\n+        // following cases requires a separate out_valid buffer. COMPUTED_NO_PREALLOCATE\n+        // would not have allocated buffers for it.\n+        ARROW_ASSIGN_OR_RAISE(out_arr->buffers[0], ctx->AllocateBitmap(cond.length));\n+      }\n+      WriteOutput(\n+          Bitmap{out_arr->buffers[0]->mutable_data(), out_arr->offset, out_arr->length});\n     }\n     return Status::OK();\n   }\n \n-  if (left_const == kAllValid && right_const == kAllValid) {\n-    // if both left and right are valid, no need to calculate out_valid bitmap. Copy\n-    // cond validity buffer\n-    if (AllocateNullBitmap::value) {  // NullHandling::COMPUTED_NO_PREALLOCATE\n-      // if there's an offset, copy bitmap (cannot slice a bitmap)\n-      if (cond.offset) {\n-        ARROW_ASSIGN_OR_RAISE(\n-            output->buffers[0],\n-            arrow::internal::CopyBitmap(ctx->memory_pool(), cond.buffers[0]->data(),\n-                                        cond.offset, cond.length));\n-      } else {  // just copy assign cond validity buffer\n-        output->buffers[0] = cond.buffers[0];\n-      }\n-    } else {  // NullHandling::COMPUTED_PREALLOCATE\n-      arrow::internal::CopyBitmap(cond.buffers[0]->data(), cond.offset, cond.length,\n-                                  output->buffers[0]->mutable_data(), output->offset);\n+  Status ExecIntoArraySpan() {\n+    ArraySpan* out_span = output->array_span();\n+\n+    // cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+    // In the following cases, we dont need to allocate out_valid bitmap\n+\n+    // if cond & left & right all ones, then output is all valid, so set all\n+    // bits\n+    if (cond_const == kAllValid && left_const == kAllValid && right_const == kAllValid) {\n+      bit_util::SetBitmap(out_span->buffers[0].data, out_span->offset, out_span->length);\n+    } else if (left_const == kAllValid && right_const == kAllValid) {\n+      // if both left and right are valid, no need to calculate out_valid\n+      // bitmap. Copy cond validity buffer\n+      arrow::internal::CopyBitmap(cond.buffers[0].data, cond.offset, cond.length,\n+                                  out_span->buffers[0].data, out_span->offset);\n+    } else {\n+      WriteOutput(Bitmap{out_span->buffers[0].data, out_span->offset, out_span->length});\n     }\n     return Status::OK();\n   }\n \n-  // lambda function that will be used inside the visitor\n-  auto apply = [&](uint64_t c_valid, uint64_t c_data, uint64_t l_valid,\n-                   uint64_t r_valid) {\n-    return c_valid & ((c_data & l_valid) | (~c_data & r_valid));\n-  };\n-\n-  if (AllocateNullBitmap::value) {\n-    // following cases requires a separate out_valid buffer. COMPUTED_NO_PREALLOCATE\n-    // would not have allocated buffers for it.\n-    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(cond.length));\n+  Status Exec(bool need_to_allocate) {\n+    if (output->is_array_data()) {\n+      return ExecIntoArrayData(need_to_allocate);\n+    } else {\n+      if (need_to_allocate) {\n+        // TODO: turn this into a DCHECK, but have this strong error to be\n+        // helpful for now\n+        return Status::Invalid(\n+            \"Conditional kernel writing into array span must \"\n+            \"preallocate validity bitmap\");\n+      }\n\nReview Comment:\n   Turn into dcheck\n\n\n\n##########\ncpp/src/arrow/compute/kernels/scalar_random.cc:\n##########\n@@ -66,23 +66,23 @@ Status ExecRandom(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n     return Status::Invalid(\"Negative number of elements\");\n   }\n \n-  auto out_data = ArrayData::Make(float64(), options.length, 0);\n-  out_data->buffers.resize(2, nullptr);\n-\n-  ARROW_ASSIGN_OR_RAISE(out_data->buffers[1],\n-                        ctx->Allocate(options.length * sizeof(double)));\n-  double* out_buffer = out_data->template GetMutableValues<double>(1);\n-\n   if (options.initializer == RandomOptions::Seed) {\n     gen.seed(options.seed);\n   } else {\n     std::lock_guard<std::mutex> seed_gen_lock(seed_gen_mutex);\n     gen.seed(seed_gen());\n   }\n+  // TODO(wesm): refactor to use batch length instead of passing length in\n+  // options\n+  auto out_data = ArrayData::Make(float64(), options.length, 0);\n\nReview Comment:\n   Note: I found this aspect of `random()` implementation to be a huge eyesore ",
                    "created": "2022-06-10T21:53:28.258+0000",
                    "updated": "2022-06-10T21:53:28.258+0000",
                    "started": "2022-06-10T21:53:28.258+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780447",
                    "issueId": "13448615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780449",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on code in PR #13364:\nURL: https://github.com/apache/arrow/pull/13364#discussion_r894919191\n\n\n##########\ncpp/src/arrow/compute/exec_internal.h:\n##########\n@@ -62,16 +63,65 @@ class ARROW_EXPORT ExecBatchIterator {\n   int64_t max_chunksize() const { return max_chunksize_; }\n \n  private:\n-  ExecBatchIterator(std::vector<Datum> args, int64_t length, int64_t max_chunksize);\n+  ExecBatchIterator(const std::vector<Datum>& args, int64_t length,\n+                    int64_t max_chunksize);\n \n-  std::vector<Datum> args_;\n+  const std::vector<Datum>& args_;\n   std::vector<int> chunk_indexes_;\n   std::vector<int64_t> chunk_positions_;\n   int64_t position_;\n   int64_t length_;\n   int64_t max_chunksize_;\n };\n \n+/// \\brief Break std::vector<Datum> into a sequence of non-owning\n+/// ExecSpan for kernel execution. The lifetime of the Datum vector\n+/// must be longer than the lifetime of this object\n+class ARROW_EXPORT ExecSpanIterator {\n+ public:\n+  /// \\brief Construct iterator and do basic argument validation\n+  ///\n+  /// \\param[in] args the Datum argument, must be all array-like or scalar\n+  /// \\param[in] max_chunksize the maximum length of each ExecSpan. Depending\n+  /// on the chunk layout of ChunkedArray.\n+  static Result<std::unique_ptr<ExecSpanIterator>> Make(\n\nReview Comment:\n   you're right, it isn't needed. removing\n\n\n\n",
                    "created": "2022-06-10T22:14:04.789+0000",
                    "updated": "2022-06-10T22:14:04.789+0000",
                    "started": "2022-06-10T22:14:04.789+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780449",
                    "issueId": "13448615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780450",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on code in PR #13364:\nURL: https://github.com/apache/arrow/pull/13364#discussion_r894920679\n\n\n##########\ncpp/src/arrow/array/data.h:\n##########\n@@ -242,6 +245,127 @@ struct ARROW_EXPORT ArrayData {\n   std::shared_ptr<ArrayData> dictionary;\n };\n \n+/// \\brief A non-owning Buffer reference\n+struct ARROW_EXPORT BufferRef {\n+  // It is the user of this class's responsibility to ensure that\n+  // buffers that were const originally are not written to\n+  // accidentally.\n+  uint8_t* data = NULLPTR;\n+  int64_t size = 0;\n+  // Pointer back to buffer that owns this memory\n+  const std::shared_ptr<Buffer>* owner = NULLPTR;\n+};\n+\n+/// \\brief EXPERIMENTAL: A non-owning ArrayData reference that is cheaply\n+/// copyable and does not contain any shared_ptr objects. Do not use in public\n+/// APIs aside from compute kernels for now\n+struct ARROW_EXPORT ArraySpan {\n+  const DataType* type;\n+  int64_t length = 0;\n+  mutable int64_t null_count = kUnknownNullCount;\n+  int64_t offset = 0;\n+  BufferRef buffers[3];\n+\n+  ArraySpan() = default;\n+\n+  explicit ArraySpan(const DataType* type, int64_t length) : type(type), length(length) {}\n+  explicit ArraySpan(const ArrayData& data) { SetMembers(data); }\n+  explicit ArraySpan(const Scalar& data) { FillFromScalar(data); }\n\nReview Comment:\n   Making these conversions implicit seemed aggressive to me, but it would be convenient given that there's plenty of other code we will probably end up migrating to use ArraySpan after this\n\n\n\n",
                    "created": "2022-06-10T22:18:00.294+0000",
                    "updated": "2022-06-10T22:18:00.294+0000",
                    "started": "2022-06-10T22:18:00.294+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780450",
                    "issueId": "13448615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780451",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #13364:\nURL: https://github.com/apache/arrow/pull/13364#discussion_r894928013\n\n\n##########\ncpp/src/arrow/compute/kernels/codegen_internal.h:\n##########\n@@ -397,14 +400,198 @@ struct BoxScalar<Decimal256Type> {\n   static void Box(T val, Scalar* out) { checked_cast<ScalarType*>(out)->value = val; }\n };\n \n-// A VisitArrayDataInline variant that calls its visitor function with logical\n+// ----------------------------------------------------------------------\n+// Like VisitArrayDataInline, but for ArraySpans\n\nReview Comment:\n   If we can migrate everything I would rather have only one code path. \n\n\n\n",
                    "created": "2022-06-10T22:40:49.376+0000",
                    "updated": "2022-06-10T22:40:49.376+0000",
                    "started": "2022-06-10T22:40:49.376+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780451",
                    "issueId": "13448615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780452",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #13364:\nURL: https://github.com/apache/arrow/pull/13364#discussion_r894928194\n\n\n##########\ncpp/src/arrow/scalar.h:\n##########\n@@ -49,7 +49,8 @@ class Array;\n /// Scalars are useful for passing single value inputs to compute functions,\n /// or for representing individual array elements (with a non-trivial\n /// wrapping cost, though).\n-struct ARROW_EXPORT Scalar : public util::EqualityComparable<Scalar> {\n+struct ARROW_EXPORT Scalar : public std::enable_shared_from_this<Scalar>,\n\nReview Comment:\n   we could rename the helper function for now and patch up the implementation later\n\n\n\n",
                    "created": "2022-06-10T22:41:28.798+0000",
                    "updated": "2022-06-10T22:41:28.798+0000",
                    "started": "2022-06-10T22:41:28.797+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780452",
                    "issueId": "13448615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780536",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on code in PR #13364:\nURL: https://github.com/apache/arrow/pull/13364#discussion_r895059600\n\n\n##########\ncpp/src/arrow/array/data.h:\n##########\n@@ -242,6 +245,127 @@ struct ARROW_EXPORT ArrayData {\n   std::shared_ptr<ArrayData> dictionary;\n };\n \n+/// \\brief A non-owning Buffer reference\n+struct ARROW_EXPORT BufferRef {\n+  // It is the user of this class's responsibility to ensure that\n+  // buffers that were const originally are not written to\n+  // accidentally.\n+  uint8_t* data = NULLPTR;\n+  int64_t size = 0;\n+  // Pointer back to buffer that owns this memory\n+  const std::shared_ptr<Buffer>* owner = NULLPTR;\n+};\n+\n+/// \\brief EXPERIMENTAL: A non-owning ArrayData reference that is cheaply\n+/// copyable and does not contain any shared_ptr objects. Do not use in public\n+/// APIs aside from compute kernels for now\n+struct ARROW_EXPORT ArraySpan {\n+  const DataType* type;\n+  int64_t length = 0;\n+  mutable int64_t null_count = kUnknownNullCount;\n+  int64_t offset = 0;\n+  BufferRef buffers[3];\n+\n+  ArraySpan() = default;\n+\n+  explicit ArraySpan(const DataType* type, int64_t length) : type(type), length(length) {}\n+  explicit ArraySpan(const ArrayData& data) { SetMembers(data); }\n+  explicit ArraySpan(const Scalar& data) { FillFromScalar(data); }\n+\n+  /// If dictionary-encoded, put dictionary in the first entry\n+  // TODO(wesm): would a std::unique_ptr<vector<...>> be better?\n\nReview Comment:\n   I removed this comment ",
                    "created": "2022-06-11T19:27:06.850+0000",
                    "updated": "2022-06-11T19:27:06.850+0000",
                    "started": "2022-06-11T19:27:06.849+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780536",
                    "issueId": "13448615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780537",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on code in PR #13364:\nURL: https://github.com/apache/arrow/pull/13364#discussion_r895059737\n\n\n##########\ncpp/src/arrow/util/bitmap.h:\n##########\n@@ -53,27 +53,36 @@ class ARROW_EXPORT Bitmap : public util::ToStringOstreamable<Bitmap>,\n \n   Bitmap() = default;\n \n-  Bitmap(std::shared_ptr<Buffer> buffer, int64_t offset, int64_t length)\n-      : buffer_(std::move(buffer)), offset_(offset), length_(length) {}\n+  Bitmap(const std::shared_ptr<Buffer>& buffer, int64_t offset, int64_t length)\n\nReview Comment:\n   I'll rename everything to use the \"Span\" name \n\n\n\n",
                    "created": "2022-06-11T19:28:27.034+0000",
                    "updated": "2022-06-11T19:28:27.034+0000",
                    "started": "2022-06-11T19:28:27.034+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780537",
                    "issueId": "13448615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780542",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on code in PR #13364:\nURL: https://github.com/apache/arrow/pull/13364#discussion_r895066801\n\n\n##########\ncpp/src/arrow/util/bit_block_counter.h:\n##########\n@@ -490,26 +493,34 @@ static void VisitBitBlocksVoid(const std::shared_ptr<Buffer>& bitmap_buf, int64_\n }\n \n template <typename VisitNotNull, typename VisitNull>\n-static Status VisitTwoBitBlocks(const std::shared_ptr<Buffer>& left_bitmap_buf,\n-                                int64_t left_offset,\n-                                const std::shared_ptr<Buffer>& right_bitmap_buf,\n-                                int64_t right_offset, int64_t length,\n-                                VisitNotNull&& visit_not_null, VisitNull&& visit_null) {\n-  if (left_bitmap_buf == NULLPTR || right_bitmap_buf == NULLPTR) {\n+static void VisitBitBlocksVoid(const std::shared_ptr<Buffer>& bitmap_buf, int64_t offset,\n\nReview Comment:\n   I am removing the other ones\n\n\n\n",
                    "created": "2022-06-11T20:54:31.024+0000",
                    "updated": "2022-06-11T20:54:31.024+0000",
                    "started": "2022-06-11T20:54:31.023+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780542",
                    "issueId": "13448615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780543",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on code in PR #13364:\nURL: https://github.com/apache/arrow/pull/13364#discussion_r895066814\n\n\n##########\ncpp/src/arrow/type.h:\n##########\n@@ -126,7 +126,8 @@ struct ARROW_EXPORT DataTypeLayout {\n ///\n /// Simple datatypes may be entirely described by their Type::type id, but\n /// complex datatypes are usually parametric.\n-class ARROW_EXPORT DataType : public detail::Fingerprintable {\n+class ARROW_EXPORT DataType : public std::enable_shared_from_this<DataType>,\n\nReview Comment:\n   I renamed GetSharedPtr to Copy and leaving the implementation which we can revisit later\n\n\n\n##########\ncpp/src/arrow/scalar.h:\n##########\n@@ -49,7 +49,8 @@ class Array;\n /// Scalars are useful for passing single value inputs to compute functions,\n /// or for representing individual array elements (with a non-trivial\n /// wrapping cost, though).\n-struct ARROW_EXPORT Scalar : public util::EqualityComparable<Scalar> {\n+struct ARROW_EXPORT Scalar : public std::enable_shared_from_this<Scalar>,\n\nReview Comment:\n   done\n\n\n\n",
                    "created": "2022-06-11T20:54:51.086+0000",
                    "updated": "2022-06-11T20:54:51.086+0000",
                    "started": "2022-06-11T20:54:51.084+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780543",
                    "issueId": "13448615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780544",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on code in PR #13364:\nURL: https://github.com/apache/arrow/pull/13364#discussion_r895066967\n\n\n##########\ncpp/src/arrow/compute/kernels/codegen_internal.h:\n##########\n@@ -397,14 +400,198 @@ struct BoxScalar<Decimal256Type> {\n   static void Box(T val, Scalar* out) { checked_cast<ScalarType*>(out)->value = val; }\n };\n \n-// A VisitArrayDataInline variant that calls its visitor function with logical\n+// ----------------------------------------------------------------------\n+// Like VisitArrayDataInline, but for ArraySpans\n\nReview Comment:\n   done (removed VisitArrayDataInline)! I added implicit construction of ArraySpan which indeed feels more natural and makes the \"unboxing\" to raw pointers happen in a single place, rather than having code generated that duplicates the unboxing each time this template is instantiated.\n\n\n\n",
                    "created": "2022-06-11T20:56:31.269+0000",
                    "updated": "2022-06-11T20:56:31.269+0000",
                    "started": "2022-06-11T20:56:31.269+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780544",
                    "issueId": "13448615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780545",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on code in PR #13364:\nURL: https://github.com/apache/arrow/pull/13364#discussion_r895067171\n\n\n##########\ncpp/src/arrow/array/data.cc:\n##########\n@@ -128,6 +131,143 @@ int64_t ArrayData::GetNullCount() const {\n   return precomputed;\n }\n \n+// ----------------------------------------------------------------------\n+// Methods for ArraySpan\n+\n+void ArraySpan::SetMembers(const ArrayData& data) {\n+  this->type = data.type.get();\n+  this->length = data.length;\n+  this->null_count = data.null_count.load();\n+  this->offset = data.offset;\n+\n+  for (size_t i = 0; i < data.buffers.size(); ++i) {\n+    const std::shared_ptr<Buffer>& buffer = data.buffers[i];\n+    // It is the invoker-of-kernels's responsibility to ensure that\n+    // const buffers are not written to accidentally.\n+    if (buffer) {\n+      SetBuffer(i, buffer);\n+    } else {\n+      ClearBuffer(i);\n+    }\n+  }\n+\n+  // Makes sure any other buffers are seen as null / non-existent\n+  for (size_t i = data.buffers.size(); i < 3; ++i) {\n+    ClearBuffer(i);\n+  }\n+\n+  // TODO(wesm): what about extension arrays?\n\nReview Comment:\n   I removed this comment, which was worrying for nothing\n\n\n\n",
                    "created": "2022-06-11T20:58:06.296+0000",
                    "updated": "2022-06-11T20:58:06.296+0000",
                    "started": "2022-06-11T20:58:06.295+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780545",
                    "issueId": "13448615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780547",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on code in PR #13364:\nURL: https://github.com/apache/arrow/pull/13364#discussion_r895067323\n\n\n##########\ncpp/src/arrow/scalar.h:\n##########\n@@ -129,6 +135,9 @@ namespace internal {\n \n struct ARROW_EXPORT PrimitiveScalarBase : public Scalar {\n   using Scalar::Scalar;\n+  /// \\brief Get an immutable pointer to the value of this scalar. May be null.\n+  virtual const void* data() const = 0;\n\nReview Comment:\n   Removing this API since `view()` already gives me the pointer I need\n\n\n\n",
                    "created": "2022-06-11T21:00:16.485+0000",
                    "updated": "2022-06-11T21:00:16.485+0000",
                    "started": "2022-06-11T21:00:16.484+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780547",
                    "issueId": "13448615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780548",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on code in PR #13364:\nURL: https://github.com/apache/arrow/pull/13364#discussion_r895067365\n\n\n##########\ncpp/src/arrow/util/bitmap.h:\n##########\n@@ -53,27 +53,36 @@ class ARROW_EXPORT Bitmap : public util::ToStringOstreamable<Bitmap>,\n \n   Bitmap() = default;\n \n-  Bitmap(std::shared_ptr<Buffer> buffer, int64_t offset, int64_t length)\n-      : buffer_(std::move(buffer)), offset_(offset), length_(length) {}\n+  Bitmap(const std::shared_ptr<Buffer>& buffer, int64_t offset, int64_t length)\n\nReview Comment:\n   I renamed BufferRef but leaving the Bitmap discussion for follow up\n\n\n\n##########\ncpp/src/arrow/compute/exec.h:\n##########\n@@ -252,6 +254,192 @@ struct ARROW_EXPORT ExecBatch {\n inline bool operator==(const ExecBatch& l, const ExecBatch& r) { return l.Equals(r); }\n inline bool operator!=(const ExecBatch& l, const ExecBatch& r) { return !l.Equals(r); }\n \n+struct ExecValue {\n\nReview Comment:\n   thanks\n\n\n\n",
                    "created": "2022-06-11T21:00:41.534+0000",
                    "updated": "2022-06-11T21:00:41.534+0000",
                    "started": "2022-06-11T21:00:41.533+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780548",
                    "issueId": "13448615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780566",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on PR #13364:\nURL: https://github.com/apache/arrow/pull/13364#issuecomment-1153019310\n\n   I'm working on some incidental cleanups that I ran into fixing the Python UDF code paths. I'll push the closer-to-CI-green branch with the changes (e.g. removing `VisitArrayDataInline`) sometime tomorrow so we can hopefully merge this in the next couple days\n\n\n",
                    "created": "2022-06-11T23:32:30.612+0000",
                    "updated": "2022-06-11T23:32:30.612+0000",
                    "started": "2022-06-11T23:32:30.612+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780566",
                    "issueId": "13448615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/worklog/780631",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on PR #13364:\nURL: https://github.com/apache/arrow/pull/13364#issuecomment-1153220604\n\n   I went ahead and tackled ARROW-16819 which involved cleaning up the various places where nullary / zero-arguments functions were being called hackishly to get a batch length in. This also added a `length` argument to `pyarrow.compute.call_function` which allows e.g. `pc.call_function('random', [], length=100)` rather than passing the length in through the RandomOptions which was a hack\n\n\n",
                    "created": "2022-06-12T16:09:15.611+0000",
                    "updated": "2022-06-12T16:09:15.611+0000",
                    "started": "2022-06-12T16:09:15.611+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780631",
                    "issueId": "13448615"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 50400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@7603098[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3e8e4683[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@101631e1[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@5c60d73e[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@53a47996[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@645db2aa[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@45651ef9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@1f66f84c[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6f7e5aff[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@663f7d58[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@b4025b0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@23cc180c[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 50400,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Jun 13 16:11:28 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-06-13T16:11:28.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16756/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2022-06-06T16:03:25.000+0000",
        "updated": "2022-06-18T13:12:31.000+0000",
        "timeoriginalestimate": null,
        "description": "This is essential to reduce microperformance overhead as has been discussed and investigated many other places. This first stage of work is to remove the use of {{Datum}} and {{ExecBatch}} from the input side of only scalar kernels, so that we can work toward using span/view data structures as the inputs (and eventually outputs) of all kernels. ",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "14h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 50400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Introduce initial ArraySpan, ExecSpan non-owning / shared_ptr-free data structures for kernel execution, refactor scalar kernels",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13448615/comment/17553684",
                    "id": "17553684",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 13364\n[https://github.com/apache/arrow/pull/13364]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2022-06-13T16:11:28.223+0000",
                    "updated": "2022-06-13T16:11:28.223+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z12zkg:",
        "customfield_12314139": null
    }
}