{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13381560",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560",
    "key": "ARROW-12922",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350591",
                "id": "12350591",
                "description": "",
                "name": "7.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-02-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "FlightSQL",
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12629268",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12629268",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13407798",
                    "key": "ARROW-14421",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13407798",
                    "fields": {
                        "summary": "[C++][FlightRPC] Implement Flight SQL for C++",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/3",
                            "id": "3",
                            "description": "A task that needs to be done.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21148&avatarType=issuetype",
                            "name": "Task",
                            "subtask": false,
                            "avatarId": 21148
                        }
                    }
                }
            },
            {
                "id": "12629184",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12629184",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13419022",
                    "key": "ARROW-15187",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13419022",
                    "fields": {
                        "summary": "[Java][FlightRPC] Fix pom.xml for new flight-sql modules",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=kylep",
            "name": "kylep",
            "key": "kylep",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Kyle Porter",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328933",
                "id": "12328933",
                "name": "Java"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=tifflhl",
            "name": "tifflhl",
            "key": "tifflhl",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
            },
            "displayName": "Tiffany Lam",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [
            {
                "id": "13381561",
                "key": "ARROW-12923",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13381561",
                "fields": {
                    "summary": "Create stubbed API for FlightSQLClient",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/3",
                        "description": "This issue is being actively worked on at the moment by the assignee.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/inprogress.png",
                        "name": "In Progress",
                        "id": "3",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/4",
                            "id": 4,
                            "key": "indeterminate",
                            "colorName": "yellow",
                            "name": "In Progress"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            },
            {
                "id": "13381563",
                "key": "ARROW-12925",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13381563",
                "fields": {
                    "summary": "Create stubbed FlightSQLProducer API",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/3",
                        "description": "This issue is being actively worked on at the moment by the assignee.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/inprogress.png",
                        "name": "In Progress",
                        "id": "3",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/4",
                            "id": 4,
                            "key": "indeterminate",
                            "colorName": "yellow",
                            "name": "In Progress"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            },
            {
                "id": "13381565",
                "key": "ARROW-12926",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13381565",
                "fields": {
                    "summary": "Create a stubbed FlightSQL sample application ",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/3",
                        "description": "This issue is being actively worked on at the moment by the assignee.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/inprogress.png",
                        "name": "In Progress",
                        "id": "3",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/4",
                            "id": 4,
                            "key": "indeterminate",
                            "colorName": "yellow",
                            "name": "In Progress"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            }
        ],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=tifflhl",
            "name": "tifflhl",
            "key": "tifflhl",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
            },
            "displayName": "Tiffany Lam",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 73800,
            "total": 73800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 73800,
            "total": 73800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12922/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 123,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/636588",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kylepbit opened a new pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906\n\n\n   **Introduction**\r\n   This PR implements Flight SQL, which formalizes SQL semantics on top of Flight. This follows designs and is a continuation of a PR started [here](https://github.com/apache/arrow/pull/9368). You can find the original proposal [here](https://docs.google.com/document/d/1WQz32bDF06GgMdEYyzhakqUigBZkALFwDF2y1x3DTAI/edit?usp=sharing), although the document has since drifted from the actual implementation.\r\n   \r\n   **An Overview of this PR**\r\n   This PR adds a new module within Flight called flight-sql.\r\n   flight-sql is a new Flight API that provides a standard way for clients and servers to communicate with SQL-like semantics.\r\n   Like other Flight APIs, flight-sql does not provide implementation details that dictate how a client and server communicates with each other, it simply provides the SQL semantics and apply them onto the Flight API.\r\n   \r\n   **A Walkthrough of the New Module**\r\n   FlightSql.proto introduces new SQL protobuf objects.\r\n   FlightSqlClient introduces a new wrapper for a FlightClient that adds the Flight SQL semantics on the client side.\r\n   FlightSqlProducer introduces a new FlightProducer API that adapts classic Flight requests into SQL operations.\r\n   FlighSqlExample is a sample FlightSQL server implementation.\r\n   \r\n   Note that there are likely a few remaining items to be fleshed out, but they mostly pertain to metadata and adding to the list of formally specified metadata items.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-10T19:47:37.857+0000",
                    "updated": "2021-08-10T19:47:37.857+0000",
                    "started": "2021-08-10T19:47:37.856+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "636588",
                    "issueId": "13381560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/636589",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906#issuecomment-896271117\n\n\n   https://issues.apache.org/jira/browse/ARROW-12922\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-10T19:47:52.322+0000",
                    "updated": "2021-08-10T19:47:52.322+0000",
                    "started": "2021-08-10T19:47:52.321+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "636589",
                    "issueId": "13381560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/636912",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906#discussion_r686805454\n\n\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: int32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Ragne [500-1000)\n+   * Range [0-100000) is reserved for defaults. Custom options should start at 100000.\n+   *\n+   * 1. Server Information [0-500): Provides basic information about the Flight SQL Server.\n+   *\n+   * The name of the Flight SQL Server.\n+   * 0 = FLIGHT_SQL_SERVER_NAME\n+   *\n+   * The native version of the Flight SQL Server.\n+   * 1 = FLIGHT_SQL_SERVER_VERSION\n+   *\n+   * The Arrow format version of the Flight SQL Server.\n+   * 2 = FLIGHT_SQL_SERVER_ARROW_VERSION\n+   *\n+   * Indicates whether the Flight SQL Server is read only.\n+   * 3 = FLIGHT_SQL_SERVER_READ_ONLY\n+   *\n+   * 2. SQL Syntax Information [500-1000): provides information about SQL syntax supported by the Flight SQL Server.\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of catalogs.\n+   * In a SQL environment, a catalog is a collection of schemas.\n+   * 500 = SQL_DDL_CATALOG\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of schemas.\n+   * In a SQL environment, a catalog is a collection of tables, views, indexes etc.\n+   * 501 = SQL_DDL_SCHEMA\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of tables.\n+   * In a SQL environment, a table is a collection of rows of information. Each row of information\n+   * may have one or more columns of data.\n+   * 502 = SQL_DDL_TABLE\n+   *\n+   * Indicates the case sensitivity of catalog, table and schema names.\n+   * 503 = SQL_IDENTIFIER_CASE\n+   *\n+   * Indicates the supported character(s) used to surround a delimited identifier.\n+   * 504 = SQL_IDENTIFIER_QUOTE_CHAR\n+   *\n+   * Indicates case sensitivity of quoted identifiers.\n+   * 505 = SQL_QUOTED_IDENTIFIER_CASE\n+   *\n+   * If omitted, then all metadata will be retrieved.\n+   * Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must\n+   * at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved.\n+   * If additional metadata is included, the metadata IDs should start from 10,000.\n+   */\n+  repeated uint32 info = 1;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of catalogs on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name.\n+ */\n+message CommandGetCatalogs {\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of schemas on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, then schema_name.\n+ */\n+message CommandGetSchemas {\n+  /*\n+   * Specifies the Catalog to search for schemas.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, the pattern will not be used to narrow the search.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of tables, and optionally their schemas, on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  table_type: utf8,\n+ *  table_schema: bytes\n\nReview comment:\n       We should clarify the encoding of the schema (an IPC-encapsulated Flatbuffer, presumably)\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: int32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Ragne [500-1000)\n+   * Range [0-100000) is reserved for defaults. Custom options should start at 100000.\n+   *\n+   * 1. Server Information [0-500): Provides basic information about the Flight SQL Server.\n+   *\n+   * The name of the Flight SQL Server.\n+   * 0 = FLIGHT_SQL_SERVER_NAME\n+   *\n+   * The native version of the Flight SQL Server.\n+   * 1 = FLIGHT_SQL_SERVER_VERSION\n+   *\n+   * The Arrow format version of the Flight SQL Server.\n+   * 2 = FLIGHT_SQL_SERVER_ARROW_VERSION\n+   *\n+   * Indicates whether the Flight SQL Server is read only.\n+   * 3 = FLIGHT_SQL_SERVER_READ_ONLY\n+   *\n+   * 2. SQL Syntax Information [500-1000): provides information about SQL syntax supported by the Flight SQL Server.\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of catalogs.\n+   * In a SQL environment, a catalog is a collection of schemas.\n+   * 500 = SQL_DDL_CATALOG\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of schemas.\n+   * In a SQL environment, a catalog is a collection of tables, views, indexes etc.\n+   * 501 = SQL_DDL_SCHEMA\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of tables.\n+   * In a SQL environment, a table is a collection of rows of information. Each row of information\n+   * may have one or more columns of data.\n+   * 502 = SQL_DDL_TABLE\n+   *\n+   * Indicates the case sensitivity of catalog, table and schema names.\n+   * 503 = SQL_IDENTIFIER_CASE\n+   *\n+   * Indicates the supported character(s) used to surround a delimited identifier.\n+   * 504 = SQL_IDENTIFIER_QUOTE_CHAR\n+   *\n+   * Indicates case sensitivity of quoted identifiers.\n+   * 505 = SQL_QUOTED_IDENTIFIER_CASE\n+   *\n+   * If omitted, then all metadata will be retrieved.\n+   * Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must\n+   * at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved.\n+   * If additional metadata is included, the metadata IDs should start from 10,000.\n+   */\n+  repeated uint32 info = 1;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of catalogs on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name.\n+ */\n+message CommandGetCatalogs {\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of schemas on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, then schema_name.\n+ */\n+message CommandGetSchemas {\n+  /*\n+   * Specifies the Catalog to search for schemas.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, the pattern will not be used to narrow the search.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of tables, and optionally their schemas, on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  table_type: utf8,\n+ *  table_schema: bytes\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, then table_type.\n+ */\n+message CommandGetTables {\n+  /*\n+   * Specifies the Catalog to search for the tables.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, all schemas matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+\n+  /*\n+   * Specifies a filter pattern for tables to search for.\n+   * When no table_name_filter_pattern is provided, all tables matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue table_name_filter_pattern = 3;\n+\n+  // Specifies a filter of table types which must match.\n+  repeated string table_types = 4;\n+\n+  // Specifies if the schema should be returned for found tables.\n+  bool include_schema = 5;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of table types on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  table_type: utf8\n+ * >\n+ * The returned data should be ordered by table_type.\n+ */\n+message CommandGetTableTypes {\n+}\n+\n+/*\n+ * Represents a request to retrieve the primary keys of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  column_name: utf8,\n+ *  key_sequence: int,\n+ *  key_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n+ */\n+message CommandGetPrimaryKeys {\n+  // Specifies the catalog to search for the table.\n+  google.protobuf.StringValue catalog = 1;\n+\n+  // Specifies the schema to search for the table.\n+  google.protobuf.StringValue schema = 2;\n+\n+  // Specifies the table to get the primary keys for.\n+  google.protobuf.StringValue table = 3;\n+}\n+\n+/*\n+ * Represents a request to retrieve a description of the foreign key columns that reference the given table's\n+ * primary key columns (the foreign keys exported by a table) of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  pk_catalog_name: utf8,\n+ *  pk_schema_name: utf8,\n+ *  pk_table_name: utf8,\n+ *  pk_column_name: utf8,\n+ *  fk_catalog_name: utf8,\n+ *  fk_schema_name: utf8,\n+ *  fk_table_name: utf8,\n+ *  fk_column_name: utf8,\n+ *  key_sequence: int,\n+ *  fk_key_name: utf8,\n+ *  pk_key_name: utf8,\n+ *  update_rule: int,\n+ *  delete_rule: int\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n+ */\n+message CommandGetExportedKeys {\n+  // Specifies the catalog to search for the foreign key table.\n+  google.protobuf.StringValue catalog = 1;\n+\n+  // Specifies the schema to search for the foreign key table.\n+  google.protobuf.StringValue schema = 2;\n+\n+  // Specifies the foreign key table to get the foreign keys for.\n+  string table = 3;\n+}\n+\n+/*\n+ * Represents a request to retrieve the foreign keys of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  pk_catalog_name: utf8,\n+ *  pk_schema_name: utf8,\n+ *  pk_table_name: utf8,\n+ *  pk_column_name: utf8,\n+ *  fk_catalog_name: utf8,\n+ *  fk_schema_name: utf8,\n+ *  fk_table_name: utf8,\n+ *  fk_column_name: utf8,\n+ *  key_sequence: int,\n+ *  fk_key_name: utf8,\n+ *  pk_key_name: utf8,\n+ *  update_rule: int,\n+ *  delete_rule: int\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n+ */\n+message CommandGetImportedKeys {\n+  // Specifies the catalog to search for the primary key table.\n+  google.protobuf.StringValue catalog = 1;\n+\n+  // Specifies the schema to search for the primary key table.\n+  google.protobuf.StringValue schema = 2;\n+\n+  // Specifies the primary key table to get the foreign keys for.\n+  string table = 3;\n+}\n+\n+// SQL Execution Action Messages\n+\n+/*\n+ * Request message for the \"GetPreparedStatement\" action on a Flight SQL enabled backend.\n+ */\n+message ActionCreatePreparedStatementRequest {\n+  // The valid SQL string to create a prepared statement for.\n+  string query = 1;\n+}\n+\n+/*\n+ * Wrap the result of a \"GetPreparedStatement\" action.\n+ */\n+message ActionCreatePreparedStatementResult {\n+  // Opaque handle for the prepared statement on the server.\n+  bytes prepared_statement_handle = 1;\n+\n+  // If a result set generating query was provided, dataset_schema contains the \n+  // schema of the dataset as described in Schema.fbs::Schema, it is serialized as an IPC message.\n+  bytes dataset_schema = 2;\n+\n+  // If the query provided contained parameters, parameter_schema contains the \n+  // Schema of the expected parameters as described in Schema.fbs::Schema.\n\nReview comment:\n       We should also be consistent in how we describe how schemas are encoded.\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlClient.java\n##########\n@@ -0,0 +1,504 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n\nReview comment:\n       Note that this was never standardized. I don't think we should use it, here or in the other files.\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlProducer.java\n##########\n@@ -0,0 +1,704 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.ActionType;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightProducer;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementUpdate;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.UnionMode;\n+import org.apache.arrow.vector.types.pojo.ArrowType.Union;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+\n+import io.grpc.Status;\n+\n+/**\n+ * API to Implement an Arrow Flight SQL producer.\n+ */\n+public interface FlightSqlProducer extends FlightProducer, AutoCloseable {\n+  /**\n+   * Depending on the provided command, method either:\n+   * 1. Return information about a SQL query, or\n+   * 2. Return information about a prepared statement. In this case, parameters binding is allowed.\n+   *\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return information about the given SQL query, or the given prepared statement.\n+   */\n+  @Override\n+  default FlightInfo getFlightInfo(CallContext context, FlightDescriptor descriptor) {\n+    final Any command = FlightSqlUtils.parseOrThrow(descriptor.getCommand());\n+\n+    if (command.is(CommandStatementQuery.class)) {\n+      return getFlightInfoStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandStatementQuery.class), context, descriptor);\n+    } else if (command.is(CommandPreparedStatementQuery.class)) {\n+      return getFlightInfoPreparedStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandPreparedStatementQuery.class), context, descriptor);\n+    } else if (command.is(CommandGetCatalogs.class)) {\n+      return getFlightInfoCatalogs(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetCatalogs.class), context, descriptor);\n+    } else if (command.is(CommandGetSchemas.class)) {\n+      return getFlightInfoSchemas(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetSchemas.class), context, descriptor);\n+    } else if (command.is(CommandGetTables.class)) {\n+      return getFlightInfoTables(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetTables.class), context, descriptor);\n+    } else if (command.is(CommandGetTableTypes.class)) {\n+      return getFlightInfoTableTypes(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetTableTypes.class), context, descriptor);\n+    } else if (command.is(CommandGetSqlInfo.class)) {\n+      return getFlightInfoSqlInfo(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetSqlInfo.class), context, descriptor);\n+    } else if (command.is(CommandGetPrimaryKeys.class)) {\n+      return getFlightInfoPrimaryKeys(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetPrimaryKeys.class), context, descriptor);\n+    } else if (command.is(CommandGetExportedKeys.class)) {\n+      return getFlightInfoExportedKeys(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetExportedKeys.class), context, descriptor);\n+    } else if (command.is(CommandGetImportedKeys.class)) {\n+      return getFlightInfoImportedKeys(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetImportedKeys.class), context, descriptor);\n+    }\n+\n+    throw Status.INVALID_ARGUMENT.asRuntimeException();\n\nReview comment:\n       We should include an error message.\r\n   \r\n   Also, let's use Flight's CallStatus, not the gRPC Status.\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlClient.java\n##########\n@@ -0,0 +1,504 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.SyncPutListener;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.StringValue;\n+\n+import io.grpc.Status;\n+\n+/**\n+ * Flight client with Flight SQL semantics.\n+ */\n+public class FlightSqlClient {\n+  private FlightClient client;\n+\n+  public FlightSqlClient(FlightClient client) {\n+    this.client = client;\n+  }\n+\n+  /**\n+   * Execute a query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo execute(String query) {\n+    final CommandStatementQuery.Builder builder = CommandStatementQuery.newBuilder();\n+    builder.setQuery(query);\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Execute an update query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public long executeUpdate(String query) {\n+    final CommandStatementUpdate.Builder builder = CommandStatementUpdate.newBuilder();\n+    builder.setQuery(query);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    final SyncPutListener putListener = new SyncPutListener();\n+    client.startPut(descriptor, VectorSchemaRoot.of(), putListener);\n+\n+    try {\n+      final PutResult read = putListener.read();\n+      try (final ArrowBuf metadata = read.getApplicationMetadata()) {\n+        final DoPutUpdateResult doPutUpdateResult = DoPutUpdateResult.parseFrom(metadata.nioBuffer());\n+        return doPutUpdateResult.getRecordCount();\n+      }\n+    } catch (InterruptedException | ExecutionException | InvalidProtocolBufferException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  /**\n+   * Request a list of catalogs.\n+   *\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getCatalogs() {\n+    final CommandGetCatalogs.Builder builder = CommandGetCatalogs.newBuilder();\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of schemas.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSchemas(final String catalog, final String schemaFilterPattern) {\n+    final CommandGetSchemas.Builder builder = CommandGetSchemas.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Get schema for a stream.\n+   *\n+   * @param descriptor The descriptor for the stream.\n+   * @param options    RPC-layer hints for this call.\n+   */\n+  public SchemaResult getSchema(FlightDescriptor descriptor, CallOption... options) {\n+    return this.client.getSchema(descriptor, options);\n\nReview comment:\n       If we're taking `CallOptions` here maybe add that to every call?\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlClient.java\n##########\n@@ -0,0 +1,504 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.SyncPutListener;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.StringValue;\n+\n+import io.grpc.Status;\n+\n+/**\n+ * Flight client with Flight SQL semantics.\n+ */\n+public class FlightSqlClient {\n+  private FlightClient client;\n+\n+  public FlightSqlClient(FlightClient client) {\n+    this.client = client;\n+  }\n+\n+  /**\n+   * Execute a query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo execute(String query) {\n+    final CommandStatementQuery.Builder builder = CommandStatementQuery.newBuilder();\n+    builder.setQuery(query);\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Execute an update query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public long executeUpdate(String query) {\n+    final CommandStatementUpdate.Builder builder = CommandStatementUpdate.newBuilder();\n+    builder.setQuery(query);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    final SyncPutListener putListener = new SyncPutListener();\n+    client.startPut(descriptor, VectorSchemaRoot.of(), putListener);\n+\n+    try {\n+      final PutResult read = putListener.read();\n+      try (final ArrowBuf metadata = read.getApplicationMetadata()) {\n+        final DoPutUpdateResult doPutUpdateResult = DoPutUpdateResult.parseFrom(metadata.nioBuffer());\n+        return doPutUpdateResult.getRecordCount();\n+      }\n+    } catch (InterruptedException | ExecutionException | InvalidProtocolBufferException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  /**\n+   * Request a list of catalogs.\n+   *\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getCatalogs() {\n+    final CommandGetCatalogs.Builder builder = CommandGetCatalogs.newBuilder();\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of schemas.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSchemas(final String catalog, final String schemaFilterPattern) {\n+    final CommandGetSchemas.Builder builder = CommandGetSchemas.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Get schema for a stream.\n+   *\n+   * @param descriptor The descriptor for the stream.\n+   * @param options    RPC-layer hints for this call.\n+   */\n+  public SchemaResult getSchema(FlightDescriptor descriptor, CallOption... options) {\n+    return this.client.getSchema(descriptor, options);\n\nReview comment:\n       Or, maybe provide methods that just construct FlightDescriptor for you.\n\n##########\nFile path: java/flight/flight-sql/src/test/java/org/apache/arrow/flight/sql/StatementContext.java\n##########\n@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import java.io.Serializable;\n+import java.sql.Connection;\n+import java.sql.Statement;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.util.AutoCloseables;\n+import org.apache.arrow.util.Preconditions;\n+\n+/**\n+ * Context for {@link T} to be persisted in memory in between {@link FlightSqlProducer} calls.\n+ *\n+ * @param <T> the {@link Statement} to be persisted.\n+ */\n+public final class StatementContext<T extends Statement> implements AutoCloseable, Serializable {\n\nReview comment:\n       (Actually, why implement serializable if this is for in-memory usage?)\n\n##########\nFile path: java/pom.xml\n##########\n@@ -549,6 +549,27 @@\n         <version>2.8.2</version>\n         <scope>provided</scope>\n       </dependency>\n+      <dependency>\n+        <groupId>org.apache.calcite.avatica</groupId>\n+        <artifactId>avatica</artifactId>\n+        <version>1.18.0</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>org.bouncycastle</groupId>\n+        <artifactId>bcpkix-jdk15on</artifactId>\n+        <version>1.61</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>com.google.code.findbugs</groupId>\n+        <artifactId>annotations</artifactId>\n+        <version>3.0.1</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>org.hamcrest</groupId>\n+        <artifactId>hamcrest</artifactId>\n+        <version>2.2</version>\n+        <scope>test</scope>\n+      </dependency>\n\nReview comment:\n       Where do we actually use these dependencies?\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: int32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Ragne [500-1000)\n+   * Range [0-100000) is reserved for defaults. Custom options should start at 100000.\n+   *\n+   * 1. Server Information [0-500): Provides basic information about the Flight SQL Server.\n+   *\n+   * The name of the Flight SQL Server.\n+   * 0 = FLIGHT_SQL_SERVER_NAME\n+   *\n+   * The native version of the Flight SQL Server.\n+   * 1 = FLIGHT_SQL_SERVER_VERSION\n+   *\n+   * The Arrow format version of the Flight SQL Server.\n+   * 2 = FLIGHT_SQL_SERVER_ARROW_VERSION\n+   *\n+   * Indicates whether the Flight SQL Server is read only.\n+   * 3 = FLIGHT_SQL_SERVER_READ_ONLY\n+   *\n+   * 2. SQL Syntax Information [500-1000): provides information about SQL syntax supported by the Flight SQL Server.\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of catalogs.\n+   * In a SQL environment, a catalog is a collection of schemas.\n+   * 500 = SQL_DDL_CATALOG\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of schemas.\n+   * In a SQL environment, a catalog is a collection of tables, views, indexes etc.\n+   * 501 = SQL_DDL_SCHEMA\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of tables.\n+   * In a SQL environment, a table is a collection of rows of information. Each row of information\n+   * may have one or more columns of data.\n+   * 502 = SQL_DDL_TABLE\n+   *\n+   * Indicates the case sensitivity of catalog, table and schema names.\n+   * 503 = SQL_IDENTIFIER_CASE\n+   *\n+   * Indicates the supported character(s) used to surround a delimited identifier.\n+   * 504 = SQL_IDENTIFIER_QUOTE_CHAR\n+   *\n+   * Indicates case sensitivity of quoted identifiers.\n+   * 505 = SQL_QUOTED_IDENTIFIER_CASE\n+   *\n+   * If omitted, then all metadata will be retrieved.\n+   * Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must\n+   * at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved.\n+   * If additional metadata is included, the metadata IDs should start from 10,000.\n+   */\n+  repeated uint32 info = 1;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of catalogs on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name.\n+ */\n+message CommandGetCatalogs {\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of schemas on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, then schema_name.\n+ */\n+message CommandGetSchemas {\n+  /*\n+   * Specifies the Catalog to search for schemas.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, the pattern will not be used to narrow the search.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of tables, and optionally their schemas, on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  table_type: utf8,\n+ *  table_schema: bytes\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, then table_type.\n+ */\n+message CommandGetTables {\n+  /*\n+   * Specifies the Catalog to search for the tables.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, all schemas matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+\n+  /*\n+   * Specifies a filter pattern for tables to search for.\n+   * When no table_name_filter_pattern is provided, all tables matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue table_name_filter_pattern = 3;\n+\n+  // Specifies a filter of table types which must match.\n+  repeated string table_types = 4;\n+\n+  // Specifies if the schema should be returned for found tables.\n+  bool include_schema = 5;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of table types on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  table_type: utf8\n+ * >\n+ * The returned data should be ordered by table_type.\n+ */\n+message CommandGetTableTypes {\n+}\n+\n+/*\n+ * Represents a request to retrieve the primary keys of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  column_name: utf8,\n+ *  key_sequence: int,\n+ *  key_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n+ */\n+message CommandGetPrimaryKeys {\n+  // Specifies the catalog to search for the table.\n+  google.protobuf.StringValue catalog = 1;\n+\n+  // Specifies the schema to search for the table.\n+  google.protobuf.StringValue schema = 2;\n+\n+  // Specifies the table to get the primary keys for.\n+  google.protobuf.StringValue table = 3;\n+}\n+\n+/*\n+ * Represents a request to retrieve a description of the foreign key columns that reference the given table's\n+ * primary key columns (the foreign keys exported by a table) of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  pk_catalog_name: utf8,\n+ *  pk_schema_name: utf8,\n+ *  pk_table_name: utf8,\n+ *  pk_column_name: utf8,\n+ *  fk_catalog_name: utf8,\n+ *  fk_schema_name: utf8,\n+ *  fk_table_name: utf8,\n+ *  fk_column_name: utf8,\n+ *  key_sequence: int,\n+ *  fk_key_name: utf8,\n+ *  pk_key_name: utf8,\n+ *  update_rule: int,\n+ *  delete_rule: int\n\nReview comment:\n       What are the values of update_rule and delete_rule?\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: int32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Ragne [500-1000)\n+   * Range [0-100000) is reserved for defaults. Custom options should start at 100000.\n+   *\n+   * 1. Server Information [0-500): Provides basic information about the Flight SQL Server.\n+   *\n+   * The name of the Flight SQL Server.\n+   * 0 = FLIGHT_SQL_SERVER_NAME\n+   *\n+   * The native version of the Flight SQL Server.\n+   * 1 = FLIGHT_SQL_SERVER_VERSION\n+   *\n+   * The Arrow format version of the Flight SQL Server.\n+   * 2 = FLIGHT_SQL_SERVER_ARROW_VERSION\n+   *\n+   * Indicates whether the Flight SQL Server is read only.\n+   * 3 = FLIGHT_SQL_SERVER_READ_ONLY\n+   *\n+   * 2. SQL Syntax Information [500-1000): provides information about SQL syntax supported by the Flight SQL Server.\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of catalogs.\n+   * In a SQL environment, a catalog is a collection of schemas.\n+   * 500 = SQL_DDL_CATALOG\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of schemas.\n+   * In a SQL environment, a catalog is a collection of tables, views, indexes etc.\n+   * 501 = SQL_DDL_SCHEMA\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of tables.\n+   * In a SQL environment, a table is a collection of rows of information. Each row of information\n+   * may have one or more columns of data.\n+   * 502 = SQL_DDL_TABLE\n+   *\n+   * Indicates the case sensitivity of catalog, table and schema names.\n+   * 503 = SQL_IDENTIFIER_CASE\n+   *\n+   * Indicates the supported character(s) used to surround a delimited identifier.\n+   * 504 = SQL_IDENTIFIER_QUOTE_CHAR\n+   *\n+   * Indicates case sensitivity of quoted identifiers.\n+   * 505 = SQL_QUOTED_IDENTIFIER_CASE\n+   *\n+   * If omitted, then all metadata will be retrieved.\n+   * Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must\n+   * at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved.\n+   * If additional metadata is included, the metadata IDs should start from 10,000.\n+   */\n+  repeated uint32 info = 1;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of catalogs on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name.\n+ */\n+message CommandGetCatalogs {\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of schemas on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, then schema_name.\n+ */\n+message CommandGetSchemas {\n+  /*\n+   * Specifies the Catalog to search for schemas.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, the pattern will not be used to narrow the search.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of tables, and optionally their schemas, on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  table_type: utf8,\n+ *  table_schema: bytes\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, then table_type.\n+ */\n+message CommandGetTables {\n+  /*\n+   * Specifies the Catalog to search for the tables.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, all schemas matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+\n+  /*\n+   * Specifies a filter pattern for tables to search for.\n+   * When no table_name_filter_pattern is provided, all tables matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue table_name_filter_pattern = 3;\n+\n+  // Specifies a filter of table types which must match.\n+  repeated string table_types = 4;\n+\n+  // Specifies if the schema should be returned for found tables.\n+  bool include_schema = 5;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of table types on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  table_type: utf8\n+ * >\n+ * The returned data should be ordered by table_type.\n+ */\n+message CommandGetTableTypes {\n+}\n+\n+/*\n+ * Represents a request to retrieve the primary keys of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  column_name: utf8,\n+ *  key_sequence: int,\n+ *  key_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n+ */\n+message CommandGetPrimaryKeys {\n+  // Specifies the catalog to search for the table.\n+  google.protobuf.StringValue catalog = 1;\n+\n+  // Specifies the schema to search for the table.\n+  google.protobuf.StringValue schema = 2;\n+\n+  // Specifies the table to get the primary keys for.\n+  google.protobuf.StringValue table = 3;\n+}\n+\n+/*\n+ * Represents a request to retrieve a description of the foreign key columns that reference the given table's\n+ * primary key columns (the foreign keys exported by a table) of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  pk_catalog_name: utf8,\n+ *  pk_schema_name: utf8,\n+ *  pk_table_name: utf8,\n+ *  pk_column_name: utf8,\n+ *  fk_catalog_name: utf8,\n+ *  fk_schema_name: utf8,\n+ *  fk_table_name: utf8,\n+ *  fk_column_name: utf8,\n+ *  key_sequence: int,\n+ *  fk_key_name: utf8,\n+ *  pk_key_name: utf8,\n+ *  update_rule: int,\n+ *  delete_rule: int\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n+ */\n+message CommandGetExportedKeys {\n+  // Specifies the catalog to search for the foreign key table.\n+  google.protobuf.StringValue catalog = 1;\n+\n+  // Specifies the schema to search for the foreign key table.\n+  google.protobuf.StringValue schema = 2;\n+\n+  // Specifies the foreign key table to get the foreign keys for.\n+  string table = 3;\n+}\n+\n+/*\n+ * Represents a request to retrieve the foreign keys of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  pk_catalog_name: utf8,\n+ *  pk_schema_name: utf8,\n+ *  pk_table_name: utf8,\n+ *  pk_column_name: utf8,\n+ *  fk_catalog_name: utf8,\n+ *  fk_schema_name: utf8,\n+ *  fk_table_name: utf8,\n+ *  fk_column_name: utf8,\n+ *  key_sequence: int,\n+ *  fk_key_name: utf8,\n+ *  pk_key_name: utf8,\n+ *  update_rule: int,\n+ *  delete_rule: int\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n+ */\n+message CommandGetImportedKeys {\n+  // Specifies the catalog to search for the primary key table.\n+  google.protobuf.StringValue catalog = 1;\n+\n+  // Specifies the schema to search for the primary key table.\n+  google.protobuf.StringValue schema = 2;\n+\n+  // Specifies the primary key table to get the foreign keys for.\n+  string table = 3;\n+}\n+\n+// SQL Execution Action Messages\n+\n+/*\n+ * Request message for the \"GetPreparedStatement\" action on a Flight SQL enabled backend.\n+ */\n+message ActionCreatePreparedStatementRequest {\n\nReview comment:\n       Is it now \"GetPreparedStatement\" or \"CreatePreparedStatement\"?\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: int32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Ragne [500-1000)\n+   * Range [0-100000) is reserved for defaults. Custom options should start at 100000.\n\nReview comment:\n       I'm curious, why the switch to integers? Strings would naturally provide namespacing. Are there enough values that strings would be a prohibitive cost?\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlClient.java\n##########\n@@ -0,0 +1,504 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.SyncPutListener;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.StringValue;\n+\n+import io.grpc.Status;\n+\n+/**\n+ * Flight client with Flight SQL semantics.\n+ */\n+public class FlightSqlClient {\n+  private FlightClient client;\n+\n+  public FlightSqlClient(FlightClient client) {\n+    this.client = client;\n+  }\n+\n+  /**\n+   * Execute a query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo execute(String query) {\n+    final CommandStatementQuery.Builder builder = CommandStatementQuery.newBuilder();\n+    builder.setQuery(query);\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Execute an update query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public long executeUpdate(String query) {\n+    final CommandStatementUpdate.Builder builder = CommandStatementUpdate.newBuilder();\n+    builder.setQuery(query);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    final SyncPutListener putListener = new SyncPutListener();\n+    client.startPut(descriptor, VectorSchemaRoot.of(), putListener);\n+\n+    try {\n+      final PutResult read = putListener.read();\n+      try (final ArrowBuf metadata = read.getApplicationMetadata()) {\n+        final DoPutUpdateResult doPutUpdateResult = DoPutUpdateResult.parseFrom(metadata.nioBuffer());\n+        return doPutUpdateResult.getRecordCount();\n+      }\n+    } catch (InterruptedException | ExecutionException | InvalidProtocolBufferException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  /**\n+   * Request a list of catalogs.\n+   *\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getCatalogs() {\n+    final CommandGetCatalogs.Builder builder = CommandGetCatalogs.newBuilder();\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of schemas.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSchemas(final String catalog, final String schemaFilterPattern) {\n+    final CommandGetSchemas.Builder builder = CommandGetSchemas.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Get schema for a stream.\n+   *\n+   * @param descriptor The descriptor for the stream.\n+   * @param options    RPC-layer hints for this call.\n+   */\n+  public SchemaResult getSchema(FlightDescriptor descriptor, CallOption... options) {\n+    return this.client.getSchema(descriptor, options);\n+  }\n+\n+  /**\n+   * Retrieve a stream from the server.\n+   *\n+   * @param ticket  The ticket granting access to the data stream.\n+   * @param options RPC-layer hints for this call.\n+   */\n+  public FlightStream getStream(Ticket ticket, CallOption... options) {\n+    return this.client.getStream(ticket, options);\n+  }\n+\n+  /**\n+   * Request a set of Flight SQL metadata.\n+   *\n+   * @param info The set of metadata to retrieve. None to retrieve all metadata.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSqlInfo(final @Nullable int... info) {\n+    final CommandGetSqlInfo.Builder builder = CommandGetSqlInfo.newBuilder();\n+    for (final int pieceOfInfo : Objects.isNull(info) ? new int[0] : info) {\n+      builder.addInfo(pieceOfInfo);\n+    }\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of tables.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @param tableFilterPattern  The table filter pattern.\n+   * @param tableTypes          The table types to include.\n+   * @param includeSchema       True to include the schema upon return, false to not include the schema.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getTables(final @Nullable String catalog, final @Nullable String schemaFilterPattern,\n+                              final @Nullable String tableFilterPattern, final List<String> tableTypes,\n+                              final boolean includeSchema) {\n+    final CommandGetTables.Builder builder = CommandGetTables.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    if (tableFilterPattern != null) {\n+      builder.setTableNameFilterPattern(StringValue.newBuilder().setValue(tableFilterPattern).build());\n+    }\n+\n+    if (tableTypes != null) {\n+      builder.addAllTableTypes(tableTypes);\n+    }\n+    builder.setIncludeSchema(includeSchema);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request the primary keys for a table.\n+   *\n+   * @param catalog The catalog.\n+   * @param schema  The schema.\n+   * @param table   The table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getPrimaryKeys(final @Nullable String catalog, final @Nullable String schema,\n+                                   final @Nullable String table) {\n+    final CommandGetPrimaryKeys.Builder builder = CommandGetPrimaryKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    if (table != null) {\n+      builder.setTable(StringValue.newBuilder().setValue(table).build());\n+    }\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request to get info about keys on a table. The table, which exports the foreign keys, parameter must be specified.\n+   *\n+   * @param catalog The foreign key table catalog.\n+   * @param schema  The foreign key table schema.\n+   * @param table   The foreign key table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getExportedKeys(String catalog, String schema, String table) {\n+    if (null == table) {\n+      throw Status.INVALID_ARGUMENT.asRuntimeException();\n\nReview comment:\n       Objects.requireNonNull, NullPointerException, or IllegalArgumentException with a descriptive message might be more natural here (I would consider StatusRuntimeException as something that you could actually react to vs. a programming bug here)\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlClient.java\n##########\n@@ -0,0 +1,504 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.SyncPutListener;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.StringValue;\n+\n+import io.grpc.Status;\n+\n+/**\n+ * Flight client with Flight SQL semantics.\n+ */\n+public class FlightSqlClient {\n+  private FlightClient client;\n+\n+  public FlightSqlClient(FlightClient client) {\n+    this.client = client;\n+  }\n+\n+  /**\n+   * Execute a query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo execute(String query) {\n+    final CommandStatementQuery.Builder builder = CommandStatementQuery.newBuilder();\n+    builder.setQuery(query);\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Execute an update query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public long executeUpdate(String query) {\n+    final CommandStatementUpdate.Builder builder = CommandStatementUpdate.newBuilder();\n+    builder.setQuery(query);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    final SyncPutListener putListener = new SyncPutListener();\n+    client.startPut(descriptor, VectorSchemaRoot.of(), putListener);\n+\n+    try {\n+      final PutResult read = putListener.read();\n+      try (final ArrowBuf metadata = read.getApplicationMetadata()) {\n+        final DoPutUpdateResult doPutUpdateResult = DoPutUpdateResult.parseFrom(metadata.nioBuffer());\n+        return doPutUpdateResult.getRecordCount();\n+      }\n+    } catch (InterruptedException | ExecutionException | InvalidProtocolBufferException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  /**\n+   * Request a list of catalogs.\n+   *\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getCatalogs() {\n+    final CommandGetCatalogs.Builder builder = CommandGetCatalogs.newBuilder();\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of schemas.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSchemas(final String catalog, final String schemaFilterPattern) {\n+    final CommandGetSchemas.Builder builder = CommandGetSchemas.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Get schema for a stream.\n+   *\n+   * @param descriptor The descriptor for the stream.\n+   * @param options    RPC-layer hints for this call.\n+   */\n+  public SchemaResult getSchema(FlightDescriptor descriptor, CallOption... options) {\n+    return this.client.getSchema(descriptor, options);\n+  }\n+\n+  /**\n+   * Retrieve a stream from the server.\n+   *\n+   * @param ticket  The ticket granting access to the data stream.\n+   * @param options RPC-layer hints for this call.\n+   */\n+  public FlightStream getStream(Ticket ticket, CallOption... options) {\n+    return this.client.getStream(ticket, options);\n+  }\n+\n+  /**\n+   * Request a set of Flight SQL metadata.\n+   *\n+   * @param info The set of metadata to retrieve. None to retrieve all metadata.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSqlInfo(final @Nullable int... info) {\n+    final CommandGetSqlInfo.Builder builder = CommandGetSqlInfo.newBuilder();\n+    for (final int pieceOfInfo : Objects.isNull(info) ? new int[0] : info) {\n+      builder.addInfo(pieceOfInfo);\n+    }\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of tables.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @param tableFilterPattern  The table filter pattern.\n+   * @param tableTypes          The table types to include.\n+   * @param includeSchema       True to include the schema upon return, false to not include the schema.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getTables(final @Nullable String catalog, final @Nullable String schemaFilterPattern,\n+                              final @Nullable String tableFilterPattern, final List<String> tableTypes,\n+                              final boolean includeSchema) {\n+    final CommandGetTables.Builder builder = CommandGetTables.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    if (tableFilterPattern != null) {\n+      builder.setTableNameFilterPattern(StringValue.newBuilder().setValue(tableFilterPattern).build());\n+    }\n+\n+    if (tableTypes != null) {\n+      builder.addAllTableTypes(tableTypes);\n+    }\n+    builder.setIncludeSchema(includeSchema);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request the primary keys for a table.\n+   *\n+   * @param catalog The catalog.\n+   * @param schema  The schema.\n+   * @param table   The table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getPrimaryKeys(final @Nullable String catalog, final @Nullable String schema,\n+                                   final @Nullable String table) {\n+    final CommandGetPrimaryKeys.Builder builder = CommandGetPrimaryKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    if (table != null) {\n+      builder.setTable(StringValue.newBuilder().setValue(table).build());\n+    }\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request to get info about keys on a table. The table, which exports the foreign keys, parameter must be specified.\n\nReview comment:\n       Nit: this is a little confusingly worded. This is saying catalog and schema are nullable, but table is NonNull? It's a little unfortunate those annotations didn't get standardized, but maybe this info can be put in the `@param` blocks instead.\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlClient.java\n##########\n@@ -0,0 +1,504 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.SyncPutListener;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.StringValue;\n+\n+import io.grpc.Status;\n+\n+/**\n+ * Flight client with Flight SQL semantics.\n+ */\n+public class FlightSqlClient {\n+  private FlightClient client;\n+\n+  public FlightSqlClient(FlightClient client) {\n+    this.client = client;\n+  }\n+\n+  /**\n+   * Execute a query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo execute(String query) {\n+    final CommandStatementQuery.Builder builder = CommandStatementQuery.newBuilder();\n+    builder.setQuery(query);\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Execute an update query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public long executeUpdate(String query) {\n+    final CommandStatementUpdate.Builder builder = CommandStatementUpdate.newBuilder();\n+    builder.setQuery(query);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    final SyncPutListener putListener = new SyncPutListener();\n+    client.startPut(descriptor, VectorSchemaRoot.of(), putListener);\n+\n+    try {\n+      final PutResult read = putListener.read();\n+      try (final ArrowBuf metadata = read.getApplicationMetadata()) {\n+        final DoPutUpdateResult doPutUpdateResult = DoPutUpdateResult.parseFrom(metadata.nioBuffer());\n+        return doPutUpdateResult.getRecordCount();\n+      }\n+    } catch (InterruptedException | ExecutionException | InvalidProtocolBufferException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  /**\n+   * Request a list of catalogs.\n+   *\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getCatalogs() {\n+    final CommandGetCatalogs.Builder builder = CommandGetCatalogs.newBuilder();\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of schemas.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSchemas(final String catalog, final String schemaFilterPattern) {\n+    final CommandGetSchemas.Builder builder = CommandGetSchemas.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Get schema for a stream.\n+   *\n+   * @param descriptor The descriptor for the stream.\n+   * @param options    RPC-layer hints for this call.\n+   */\n+  public SchemaResult getSchema(FlightDescriptor descriptor, CallOption... options) {\n+    return this.client.getSchema(descriptor, options);\n\nReview comment:\n       nit: no need for `this.`\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlClient.java\n##########\n@@ -0,0 +1,504 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.SyncPutListener;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.StringValue;\n+\n+import io.grpc.Status;\n+\n+/**\n+ * Flight client with Flight SQL semantics.\n+ */\n+public class FlightSqlClient {\n+  private FlightClient client;\n+\n+  public FlightSqlClient(FlightClient client) {\n+    this.client = client;\n+  }\n+\n+  /**\n+   * Execute a query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo execute(String query) {\n+    final CommandStatementQuery.Builder builder = CommandStatementQuery.newBuilder();\n+    builder.setQuery(query);\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Execute an update query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public long executeUpdate(String query) {\n+    final CommandStatementUpdate.Builder builder = CommandStatementUpdate.newBuilder();\n+    builder.setQuery(query);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    final SyncPutListener putListener = new SyncPutListener();\n+    client.startPut(descriptor, VectorSchemaRoot.of(), putListener);\n+\n+    try {\n+      final PutResult read = putListener.read();\n+      try (final ArrowBuf metadata = read.getApplicationMetadata()) {\n+        final DoPutUpdateResult doPutUpdateResult = DoPutUpdateResult.parseFrom(metadata.nioBuffer());\n+        return doPutUpdateResult.getRecordCount();\n+      }\n+    } catch (InterruptedException | ExecutionException | InvalidProtocolBufferException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  /**\n+   * Request a list of catalogs.\n+   *\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getCatalogs() {\n+    final CommandGetCatalogs.Builder builder = CommandGetCatalogs.newBuilder();\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of schemas.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSchemas(final String catalog, final String schemaFilterPattern) {\n+    final CommandGetSchemas.Builder builder = CommandGetSchemas.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Get schema for a stream.\n+   *\n+   * @param descriptor The descriptor for the stream.\n+   * @param options    RPC-layer hints for this call.\n+   */\n+  public SchemaResult getSchema(FlightDescriptor descriptor, CallOption... options) {\n+    return this.client.getSchema(descriptor, options);\n+  }\n+\n+  /**\n+   * Retrieve a stream from the server.\n+   *\n+   * @param ticket  The ticket granting access to the data stream.\n+   * @param options RPC-layer hints for this call.\n+   */\n+  public FlightStream getStream(Ticket ticket, CallOption... options) {\n+    return this.client.getStream(ticket, options);\n+  }\n+\n+  /**\n+   * Request a set of Flight SQL metadata.\n+   *\n+   * @param info The set of metadata to retrieve. None to retrieve all metadata.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSqlInfo(final @Nullable int... info) {\n+    final CommandGetSqlInfo.Builder builder = CommandGetSqlInfo.newBuilder();\n+    for (final int pieceOfInfo : Objects.isNull(info) ? new int[0] : info) {\n+      builder.addInfo(pieceOfInfo);\n+    }\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of tables.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @param tableFilterPattern  The table filter pattern.\n+   * @param tableTypes          The table types to include.\n+   * @param includeSchema       True to include the schema upon return, false to not include the schema.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getTables(final @Nullable String catalog, final @Nullable String schemaFilterPattern,\n+                              final @Nullable String tableFilterPattern, final List<String> tableTypes,\n+                              final boolean includeSchema) {\n+    final CommandGetTables.Builder builder = CommandGetTables.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    if (tableFilterPattern != null) {\n+      builder.setTableNameFilterPattern(StringValue.newBuilder().setValue(tableFilterPattern).build());\n+    }\n+\n+    if (tableTypes != null) {\n+      builder.addAllTableTypes(tableTypes);\n+    }\n+    builder.setIncludeSchema(includeSchema);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request the primary keys for a table.\n+   *\n+   * @param catalog The catalog.\n+   * @param schema  The schema.\n+   * @param table   The table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getPrimaryKeys(final @Nullable String catalog, final @Nullable String schema,\n+                                   final @Nullable String table) {\n+    final CommandGetPrimaryKeys.Builder builder = CommandGetPrimaryKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    if (table != null) {\n+      builder.setTable(StringValue.newBuilder().setValue(table).build());\n+    }\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request to get info about keys on a table. The table, which exports the foreign keys, parameter must be specified.\n+   *\n+   * @param catalog The foreign key table catalog.\n+   * @param schema  The foreign key table schema.\n+   * @param table   The foreign key table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getExportedKeys(String catalog, String schema, String table) {\n+    if (null == table) {\n+      throw Status.INVALID_ARGUMENT.asRuntimeException();\n+    }\n+\n+    final CommandGetExportedKeys.Builder builder = CommandGetExportedKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    builder.setTable(table).build();\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request to get info about keys on a table. The table, which imports the foreign keys, parameter must be specified.\n+   *\n+   * @param catalog The primary key table catalog.\n+   * @param schema  The primary key table schema.\n+   * @param table   The primary key table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getImportedKeys(String catalog, String schema, String table) {\n+    if (null == table) {\n+      throw Status.INVALID_ARGUMENT.asRuntimeException();\n+    }\n+\n+    final CommandGetImportedKeys.Builder builder = CommandGetImportedKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    builder.setTable(table).build();\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of table types.\n+   *\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getTableTypes() {\n+    final CommandGetTableTypes.Builder builder = CommandGetTableTypes.newBuilder();\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Create a prepared statement on the server.\n+   *\n+   * @param query The query to prepare.\n+   * @return The representation of the prepared statement which exists on the server.\n+   */\n+  public PreparedStatement prepare(String query) {\n+    return new PreparedStatement(client, query);\n+  }\n+\n+  /**\n+   * Helper class to encapsulate Flight SQL prepared statement logic.\n+   */\n+  public static class PreparedStatement implements Closeable {\n\nReview comment:\n       Use AutoCloseable?\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlClient.java\n##########\n@@ -0,0 +1,504 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.SyncPutListener;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.StringValue;\n+\n+import io.grpc.Status;\n+\n+/**\n+ * Flight client with Flight SQL semantics.\n+ */\n+public class FlightSqlClient {\n+  private FlightClient client;\n+\n+  public FlightSqlClient(FlightClient client) {\n+    this.client = client;\n+  }\n+\n+  /**\n+   * Execute a query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo execute(String query) {\n+    final CommandStatementQuery.Builder builder = CommandStatementQuery.newBuilder();\n+    builder.setQuery(query);\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Execute an update query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public long executeUpdate(String query) {\n+    final CommandStatementUpdate.Builder builder = CommandStatementUpdate.newBuilder();\n+    builder.setQuery(query);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    final SyncPutListener putListener = new SyncPutListener();\n+    client.startPut(descriptor, VectorSchemaRoot.of(), putListener);\n+\n+    try {\n+      final PutResult read = putListener.read();\n+      try (final ArrowBuf metadata = read.getApplicationMetadata()) {\n+        final DoPutUpdateResult doPutUpdateResult = DoPutUpdateResult.parseFrom(metadata.nioBuffer());\n+        return doPutUpdateResult.getRecordCount();\n+      }\n+    } catch (InterruptedException | ExecutionException | InvalidProtocolBufferException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  /**\n+   * Request a list of catalogs.\n+   *\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getCatalogs() {\n+    final CommandGetCatalogs.Builder builder = CommandGetCatalogs.newBuilder();\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of schemas.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSchemas(final String catalog, final String schemaFilterPattern) {\n+    final CommandGetSchemas.Builder builder = CommandGetSchemas.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Get schema for a stream.\n+   *\n+   * @param descriptor The descriptor for the stream.\n+   * @param options    RPC-layer hints for this call.\n+   */\n+  public SchemaResult getSchema(FlightDescriptor descriptor, CallOption... options) {\n+    return this.client.getSchema(descriptor, options);\n+  }\n+\n+  /**\n+   * Retrieve a stream from the server.\n+   *\n+   * @param ticket  The ticket granting access to the data stream.\n+   * @param options RPC-layer hints for this call.\n+   */\n+  public FlightStream getStream(Ticket ticket, CallOption... options) {\n+    return this.client.getStream(ticket, options);\n+  }\n+\n+  /**\n+   * Request a set of Flight SQL metadata.\n+   *\n+   * @param info The set of metadata to retrieve. None to retrieve all metadata.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSqlInfo(final @Nullable int... info) {\n+    final CommandGetSqlInfo.Builder builder = CommandGetSqlInfo.newBuilder();\n+    for (final int pieceOfInfo : Objects.isNull(info) ? new int[0] : info) {\n+      builder.addInfo(pieceOfInfo);\n+    }\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of tables.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @param tableFilterPattern  The table filter pattern.\n+   * @param tableTypes          The table types to include.\n+   * @param includeSchema       True to include the schema upon return, false to not include the schema.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getTables(final @Nullable String catalog, final @Nullable String schemaFilterPattern,\n+                              final @Nullable String tableFilterPattern, final List<String> tableTypes,\n+                              final boolean includeSchema) {\n+    final CommandGetTables.Builder builder = CommandGetTables.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    if (tableFilterPattern != null) {\n+      builder.setTableNameFilterPattern(StringValue.newBuilder().setValue(tableFilterPattern).build());\n+    }\n+\n+    if (tableTypes != null) {\n+      builder.addAllTableTypes(tableTypes);\n+    }\n+    builder.setIncludeSchema(includeSchema);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request the primary keys for a table.\n+   *\n+   * @param catalog The catalog.\n+   * @param schema  The schema.\n+   * @param table   The table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getPrimaryKeys(final @Nullable String catalog, final @Nullable String schema,\n+                                   final @Nullable String table) {\n+    final CommandGetPrimaryKeys.Builder builder = CommandGetPrimaryKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    if (table != null) {\n+      builder.setTable(StringValue.newBuilder().setValue(table).build());\n+    }\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request to get info about keys on a table. The table, which exports the foreign keys, parameter must be specified.\n+   *\n+   * @param catalog The foreign key table catalog.\n+   * @param schema  The foreign key table schema.\n+   * @param table   The foreign key table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getExportedKeys(String catalog, String schema, String table) {\n+    if (null == table) {\n+      throw Status.INVALID_ARGUMENT.asRuntimeException();\n+    }\n+\n+    final CommandGetExportedKeys.Builder builder = CommandGetExportedKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    builder.setTable(table).build();\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request to get info about keys on a table. The table, which imports the foreign keys, parameter must be specified.\n+   *\n+   * @param catalog The primary key table catalog.\n+   * @param schema  The primary key table schema.\n+   * @param table   The primary key table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getImportedKeys(String catalog, String schema, String table) {\n+    if (null == table) {\n+      throw Status.INVALID_ARGUMENT.asRuntimeException();\n+    }\n+\n+    final CommandGetImportedKeys.Builder builder = CommandGetImportedKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    builder.setTable(table).build();\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of table types.\n+   *\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getTableTypes() {\n+    final CommandGetTableTypes.Builder builder = CommandGetTableTypes.newBuilder();\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Create a prepared statement on the server.\n+   *\n+   * @param query The query to prepare.\n+   * @return The representation of the prepared statement which exists on the server.\n+   */\n+  public PreparedStatement prepare(String query) {\n+    return new PreparedStatement(client, query);\n+  }\n+\n+  /**\n+   * Helper class to encapsulate Flight SQL prepared statement logic.\n+   */\n+  public static class PreparedStatement implements Closeable {\n+    private final FlightClient client;\n+    private final ActionCreatePreparedStatementResult preparedStatementResult;\n+    private AtomicLong invocationCount;\n+    private boolean isClosed;\n+    private Schema resultSetSchema = null;\n+    private Schema parameterSchema = null;\n+    private VectorSchemaRoot parameterBindingRoot;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param client The client. FlightSqlPreparedStatement does not maintain this resource.\n+     * @param sql    The query.\n+     */\n+    public PreparedStatement(FlightClient client, String sql) {\n+      this.client = client;\n+\n+      final Iterator<Result> preparedStatementResults = client.doAction(new Action(\n+          FlightSqlUtils.FLIGHT_SQL_CREATEPREPAREDSTATEMENT.getType(),\n+          Any.pack(ActionCreatePreparedStatementRequest\n+              .newBuilder()\n+              .setQuery(sql)\n+              .build())\n+              .toByteArray()));\n+\n+      preparedStatementResult = FlightSqlUtils.unpackAndParseOrThrow(\n+          preparedStatementResults.next().getBody(),\n+          ActionCreatePreparedStatementResult.class);\n+\n+      invocationCount = new AtomicLong(0);\n+      isClosed = false;\n+    }\n+\n+    /**\n+     * Set the {@link VectorSchemaRoot} containing the parameter binding from a preparedStatemnt\n+     * operation.\n+     *\n+     * @param parameterBindingRoot  a {@link VectorSchemaRoot} object contain the values to be used in the\n+     *                              PreparedStatement setters.\n+     */\n+    public void setParameters(VectorSchemaRoot parameterBindingRoot) {\n+      this.parameterBindingRoot = parameterBindingRoot;\n+    }\n+\n+    /**\n+     * Empty the {@link VectorSchemaRoot} that contains the parameter binding from a preparedStatemnt\n+     * operation.\n+     *\n+     */\n+    public void clearParameters() {\n+      this.parameterBindingRoot = null;\n+    }\n+\n+    /**\n+     * Returns the Schema of the resultset.\n+     *\n+     * @return the Schema of the resultset.\n+     */\n+    public Schema getResultSetSchema() {\n+      if (resultSetSchema == null && preparedStatementResult.getDatasetSchema() != null) {\n+        resultSetSchema = Schema.deserialize(preparedStatementResult.getDatasetSchema().asReadOnlyByteBuffer());\n+      }\n+      return resultSetSchema;\n+    }\n+\n+    /**\n+     * Returns the Schema of the parameters.\n+     *\n+     * @return the Schema of the parameters.\n+     */\n+    public Schema getParameterSchema() {\n+      if (parameterSchema == null && preparedStatementResult.getParameterSchema() != null) {\n+        parameterSchema = Schema.deserialize(preparedStatementResult.getParameterSchema().asReadOnlyByteBuffer());\n+      }\n+      return parameterSchema;\n+    }\n+\n+    /**\n+     * Executes the prepared statement query on the server.\n+     *\n+     * @return a FlightInfo object representing the stream(s) to fetch.\n+     * @throws IOException if the PreparedStatement is closed.\n+     */\n+    public FlightInfo execute() throws IOException {\n+      if (isClosed) {\n+        throw new IllegalStateException(\"Prepared statement has already been closed on the server.\");\n+      }\n+\n+      final FlightDescriptor descriptor = FlightDescriptor\n+          .command(Any.pack(CommandPreparedStatementQuery.newBuilder()\n+              .setClientExecutionHandle(\n+                  ByteString.copyFrom(ByteBuffer.allocate(Long.BYTES).putLong(invocationCount.getAndIncrement())))\n+              .setPreparedStatementHandle(preparedStatementResult.getPreparedStatementHandle())\n+              .build())\n+              .toByteArray());\n+\n+      if (parameterBindingRoot != null) {\n+        final SyncPutListener putListener = new SyncPutListener();\n+\n+        FlightClient.ClientStreamListener listener =\n+            client.startPut(descriptor, this.parameterBindingRoot, putListener);\n+\n+        listener.putNext();\n+        listener.completed();\n+      }\n\nReview comment:\n       Hmm, so creating a prepared statement and executing it with lots of different parameters will require many RPCs/round-trips. I guess that works, but I wonder if we couldn't improve that. (Then again, this at least makes it easy to delineate where each result set starts/ends). Doesn't need to be solved now though.\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlClient.java\n##########\n@@ -0,0 +1,504 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.SyncPutListener;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.StringValue;\n+\n+import io.grpc.Status;\n+\n+/**\n+ * Flight client with Flight SQL semantics.\n+ */\n+public class FlightSqlClient {\n+  private FlightClient client;\n+\n+  public FlightSqlClient(FlightClient client) {\n+    this.client = client;\n+  }\n+\n+  /**\n+   * Execute a query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo execute(String query) {\n+    final CommandStatementQuery.Builder builder = CommandStatementQuery.newBuilder();\n+    builder.setQuery(query);\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Execute an update query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public long executeUpdate(String query) {\n+    final CommandStatementUpdate.Builder builder = CommandStatementUpdate.newBuilder();\n+    builder.setQuery(query);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    final SyncPutListener putListener = new SyncPutListener();\n+    client.startPut(descriptor, VectorSchemaRoot.of(), putListener);\n+\n+    try {\n+      final PutResult read = putListener.read();\n+      try (final ArrowBuf metadata = read.getApplicationMetadata()) {\n+        final DoPutUpdateResult doPutUpdateResult = DoPutUpdateResult.parseFrom(metadata.nioBuffer());\n+        return doPutUpdateResult.getRecordCount();\n+      }\n+    } catch (InterruptedException | ExecutionException | InvalidProtocolBufferException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  /**\n+   * Request a list of catalogs.\n+   *\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getCatalogs() {\n+    final CommandGetCatalogs.Builder builder = CommandGetCatalogs.newBuilder();\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of schemas.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSchemas(final String catalog, final String schemaFilterPattern) {\n+    final CommandGetSchemas.Builder builder = CommandGetSchemas.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Get schema for a stream.\n+   *\n+   * @param descriptor The descriptor for the stream.\n+   * @param options    RPC-layer hints for this call.\n+   */\n+  public SchemaResult getSchema(FlightDescriptor descriptor, CallOption... options) {\n+    return this.client.getSchema(descriptor, options);\n+  }\n+\n+  /**\n+   * Retrieve a stream from the server.\n+   *\n+   * @param ticket  The ticket granting access to the data stream.\n+   * @param options RPC-layer hints for this call.\n+   */\n+  public FlightStream getStream(Ticket ticket, CallOption... options) {\n+    return this.client.getStream(ticket, options);\n+  }\n+\n+  /**\n+   * Request a set of Flight SQL metadata.\n+   *\n+   * @param info The set of metadata to retrieve. None to retrieve all metadata.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSqlInfo(final @Nullable int... info) {\n+    final CommandGetSqlInfo.Builder builder = CommandGetSqlInfo.newBuilder();\n+    for (final int pieceOfInfo : Objects.isNull(info) ? new int[0] : info) {\n+      builder.addInfo(pieceOfInfo);\n+    }\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of tables.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @param tableFilterPattern  The table filter pattern.\n+   * @param tableTypes          The table types to include.\n+   * @param includeSchema       True to include the schema upon return, false to not include the schema.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getTables(final @Nullable String catalog, final @Nullable String schemaFilterPattern,\n+                              final @Nullable String tableFilterPattern, final List<String> tableTypes,\n+                              final boolean includeSchema) {\n+    final CommandGetTables.Builder builder = CommandGetTables.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    if (tableFilterPattern != null) {\n+      builder.setTableNameFilterPattern(StringValue.newBuilder().setValue(tableFilterPattern).build());\n+    }\n+\n+    if (tableTypes != null) {\n+      builder.addAllTableTypes(tableTypes);\n+    }\n+    builder.setIncludeSchema(includeSchema);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request the primary keys for a table.\n+   *\n+   * @param catalog The catalog.\n+   * @param schema  The schema.\n+   * @param table   The table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getPrimaryKeys(final @Nullable String catalog, final @Nullable String schema,\n+                                   final @Nullable String table) {\n+    final CommandGetPrimaryKeys.Builder builder = CommandGetPrimaryKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    if (table != null) {\n+      builder.setTable(StringValue.newBuilder().setValue(table).build());\n+    }\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request to get info about keys on a table. The table, which exports the foreign keys, parameter must be specified.\n+   *\n+   * @param catalog The foreign key table catalog.\n+   * @param schema  The foreign key table schema.\n+   * @param table   The foreign key table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getExportedKeys(String catalog, String schema, String table) {\n+    if (null == table) {\n+      throw Status.INVALID_ARGUMENT.asRuntimeException();\n+    }\n+\n+    final CommandGetExportedKeys.Builder builder = CommandGetExportedKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    builder.setTable(table).build();\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request to get info about keys on a table. The table, which imports the foreign keys, parameter must be specified.\n+   *\n+   * @param catalog The primary key table catalog.\n+   * @param schema  The primary key table schema.\n+   * @param table   The primary key table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getImportedKeys(String catalog, String schema, String table) {\n+    if (null == table) {\n+      throw Status.INVALID_ARGUMENT.asRuntimeException();\n+    }\n+\n+    final CommandGetImportedKeys.Builder builder = CommandGetImportedKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    builder.setTable(table).build();\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of table types.\n+   *\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getTableTypes() {\n+    final CommandGetTableTypes.Builder builder = CommandGetTableTypes.newBuilder();\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Create a prepared statement on the server.\n+   *\n+   * @param query The query to prepare.\n+   * @return The representation of the prepared statement which exists on the server.\n+   */\n+  public PreparedStatement prepare(String query) {\n+    return new PreparedStatement(client, query);\n+  }\n+\n+  /**\n+   * Helper class to encapsulate Flight SQL prepared statement logic.\n+   */\n+  public static class PreparedStatement implements Closeable {\n+    private final FlightClient client;\n+    private final ActionCreatePreparedStatementResult preparedStatementResult;\n+    private AtomicLong invocationCount;\n+    private boolean isClosed;\n+    private Schema resultSetSchema = null;\n+    private Schema parameterSchema = null;\n+    private VectorSchemaRoot parameterBindingRoot;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param client The client. FlightSqlPreparedStatement does not maintain this resource.\n+     * @param sql    The query.\n+     */\n+    public PreparedStatement(FlightClient client, String sql) {\n+      this.client = client;\n+\n+      final Iterator<Result> preparedStatementResults = client.doAction(new Action(\n+          FlightSqlUtils.FLIGHT_SQL_CREATEPREPAREDSTATEMENT.getType(),\n+          Any.pack(ActionCreatePreparedStatementRequest\n+              .newBuilder()\n+              .setQuery(sql)\n+              .build())\n+              .toByteArray()));\n+\n+      preparedStatementResult = FlightSqlUtils.unpackAndParseOrThrow(\n+          preparedStatementResults.next().getBody(),\n+          ActionCreatePreparedStatementResult.class);\n+\n+      invocationCount = new AtomicLong(0);\n+      isClosed = false;\n+    }\n+\n+    /**\n+     * Set the {@link VectorSchemaRoot} containing the parameter binding from a preparedStatemnt\n+     * operation.\n+     *\n+     * @param parameterBindingRoot  a {@link VectorSchemaRoot} object contain the values to be used in the\n+     *                              PreparedStatement setters.\n+     */\n+    public void setParameters(VectorSchemaRoot parameterBindingRoot) {\n+      this.parameterBindingRoot = parameterBindingRoot;\n+    }\n+\n+    /**\n+     * Empty the {@link VectorSchemaRoot} that contains the parameter binding from a preparedStatemnt\n+     * operation.\n+     *\n\nReview comment:\n       Maybe clarify (either here or above) that this does not clear or otherwise free resources associated with the root.\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: int32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Ragne [500-1000)\n+   * Range [0-100000) is reserved for defaults. Custom options should start at 100000.\n+   *\n+   * 1. Server Information [0-500): Provides basic information about the Flight SQL Server.\n+   *\n+   * The name of the Flight SQL Server.\n+   * 0 = FLIGHT_SQL_SERVER_NAME\n+   *\n+   * The native version of the Flight SQL Server.\n+   * 1 = FLIGHT_SQL_SERVER_VERSION\n+   *\n+   * The Arrow format version of the Flight SQL Server.\n+   * 2 = FLIGHT_SQL_SERVER_ARROW_VERSION\n+   *\n+   * Indicates whether the Flight SQL Server is read only.\n+   * 3 = FLIGHT_SQL_SERVER_READ_ONLY\n+   *\n+   * 2. SQL Syntax Information [500-1000): provides information about SQL syntax supported by the Flight SQL Server.\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of catalogs.\n+   * In a SQL environment, a catalog is a collection of schemas.\n+   * 500 = SQL_DDL_CATALOG\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of schemas.\n+   * In a SQL environment, a catalog is a collection of tables, views, indexes etc.\n+   * 501 = SQL_DDL_SCHEMA\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of tables.\n+   * In a SQL environment, a table is a collection of rows of information. Each row of information\n+   * may have one or more columns of data.\n+   * 502 = SQL_DDL_TABLE\n+   *\n+   * Indicates the case sensitivity of catalog, table and schema names.\n+   * 503 = SQL_IDENTIFIER_CASE\n+   *\n+   * Indicates the supported character(s) used to surround a delimited identifier.\n+   * 504 = SQL_IDENTIFIER_QUOTE_CHAR\n+   *\n+   * Indicates case sensitivity of quoted identifiers.\n+   * 505 = SQL_QUOTED_IDENTIFIER_CASE\n+   *\n+   * If omitted, then all metadata will be retrieved.\n+   * Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must\n+   * at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved.\n+   * If additional metadata is included, the metadata IDs should start from 10,000.\n\nReview comment:\n       This is inconsistent with the values above.\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlClient.java\n##########\n@@ -0,0 +1,504 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.SyncPutListener;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.StringValue;\n+\n+import io.grpc.Status;\n+\n+/**\n+ * Flight client with Flight SQL semantics.\n+ */\n+public class FlightSqlClient {\n+  private FlightClient client;\n+\n+  public FlightSqlClient(FlightClient client) {\n+    this.client = client;\n+  }\n+\n+  /**\n+   * Execute a query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo execute(String query) {\n+    final CommandStatementQuery.Builder builder = CommandStatementQuery.newBuilder();\n+    builder.setQuery(query);\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Execute an update query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public long executeUpdate(String query) {\n+    final CommandStatementUpdate.Builder builder = CommandStatementUpdate.newBuilder();\n+    builder.setQuery(query);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    final SyncPutListener putListener = new SyncPutListener();\n+    client.startPut(descriptor, VectorSchemaRoot.of(), putListener);\n+\n+    try {\n+      final PutResult read = putListener.read();\n+      try (final ArrowBuf metadata = read.getApplicationMetadata()) {\n+        final DoPutUpdateResult doPutUpdateResult = DoPutUpdateResult.parseFrom(metadata.nioBuffer());\n+        return doPutUpdateResult.getRecordCount();\n+      }\n+    } catch (InterruptedException | ExecutionException | InvalidProtocolBufferException e) {\n\nReview comment:\n       For InterruptedException: `Thread.currentThread().interrupt()`?\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: int32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Ragne [500-1000)\n+   * Range [0-100000) is reserved for defaults. Custom options should start at 100000.\n+   *\n+   * 1. Server Information [0-500): Provides basic information about the Flight SQL Server.\n+   *\n+   * The name of the Flight SQL Server.\n+   * 0 = FLIGHT_SQL_SERVER_NAME\n+   *\n+   * The native version of the Flight SQL Server.\n+   * 1 = FLIGHT_SQL_SERVER_VERSION\n+   *\n+   * The Arrow format version of the Flight SQL Server.\n+   * 2 = FLIGHT_SQL_SERVER_ARROW_VERSION\n+   *\n+   * Indicates whether the Flight SQL Server is read only.\n+   * 3 = FLIGHT_SQL_SERVER_READ_ONLY\n+   *\n+   * 2. SQL Syntax Information [500-1000): provides information about SQL syntax supported by the Flight SQL Server.\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of catalogs.\n+   * In a SQL environment, a catalog is a collection of schemas.\n+   * 500 = SQL_DDL_CATALOG\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of schemas.\n+   * In a SQL environment, a catalog is a collection of tables, views, indexes etc.\n+   * 501 = SQL_DDL_SCHEMA\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of tables.\n+   * In a SQL environment, a table is a collection of rows of information. Each row of information\n+   * may have one or more columns of data.\n+   * 502 = SQL_DDL_TABLE\n+   *\n+   * Indicates the case sensitivity of catalog, table and schema names.\n+   * 503 = SQL_IDENTIFIER_CASE\n+   *\n+   * Indicates the supported character(s) used to surround a delimited identifier.\n+   * 504 = SQL_IDENTIFIER_QUOTE_CHAR\n+   *\n+   * Indicates case sensitivity of quoted identifiers.\n+   * 505 = SQL_QUOTED_IDENTIFIER_CASE\n+   *\n+   * If omitted, then all metadata will be retrieved.\n+   * Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must\n+   * at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved.\n+   * If additional metadata is included, the metadata IDs should start from 10,000.\n+   */\n+  repeated uint32 info = 1;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of catalogs on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name.\n+ */\n+message CommandGetCatalogs {\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of schemas on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, then schema_name.\n+ */\n+message CommandGetSchemas {\n+  /*\n+   * Specifies the Catalog to search for schemas.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, the pattern will not be used to narrow the search.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of tables, and optionally their schemas, on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  table_type: utf8,\n+ *  table_schema: bytes\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, then table_type.\n+ */\n+message CommandGetTables {\n+  /*\n+   * Specifies the Catalog to search for the tables.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, all schemas matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+\n+  /*\n+   * Specifies a filter pattern for tables to search for.\n+   * When no table_name_filter_pattern is provided, all tables matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue table_name_filter_pattern = 3;\n+\n+  // Specifies a filter of table types which must match.\n+  repeated string table_types = 4;\n+\n+  // Specifies if the schema should be returned for found tables.\n+  bool include_schema = 5;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of table types on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  table_type: utf8\n+ * >\n+ * The returned data should be ordered by table_type.\n+ */\n+message CommandGetTableTypes {\n+}\n+\n+/*\n+ * Represents a request to retrieve the primary keys of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  column_name: utf8,\n+ *  key_sequence: int,\n+ *  key_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n\nReview comment:\n       Let's keep the ordering consistent with the ordering of the fields in the schema.\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlClient.java\n##########\n@@ -0,0 +1,504 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.SyncPutListener;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.StringValue;\n+\n+import io.grpc.Status;\n+\n+/**\n+ * Flight client with Flight SQL semantics.\n+ */\n+public class FlightSqlClient {\n+  private FlightClient client;\n+\n+  public FlightSqlClient(FlightClient client) {\n+    this.client = client;\n+  }\n+\n+  /**\n+   * Execute a query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo execute(String query) {\n+    final CommandStatementQuery.Builder builder = CommandStatementQuery.newBuilder();\n+    builder.setQuery(query);\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Execute an update query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public long executeUpdate(String query) {\n+    final CommandStatementUpdate.Builder builder = CommandStatementUpdate.newBuilder();\n+    builder.setQuery(query);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    final SyncPutListener putListener = new SyncPutListener();\n+    client.startPut(descriptor, VectorSchemaRoot.of(), putListener);\n+\n+    try {\n+      final PutResult read = putListener.read();\n+      try (final ArrowBuf metadata = read.getApplicationMetadata()) {\n+        final DoPutUpdateResult doPutUpdateResult = DoPutUpdateResult.parseFrom(metadata.nioBuffer());\n+        return doPutUpdateResult.getRecordCount();\n+      }\n+    } catch (InterruptedException | ExecutionException | InvalidProtocolBufferException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  /**\n+   * Request a list of catalogs.\n+   *\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getCatalogs() {\n+    final CommandGetCatalogs.Builder builder = CommandGetCatalogs.newBuilder();\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of schemas.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSchemas(final String catalog, final String schemaFilterPattern) {\n+    final CommandGetSchemas.Builder builder = CommandGetSchemas.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Get schema for a stream.\n+   *\n+   * @param descriptor The descriptor for the stream.\n+   * @param options    RPC-layer hints for this call.\n+   */\n+  public SchemaResult getSchema(FlightDescriptor descriptor, CallOption... options) {\n+    return this.client.getSchema(descriptor, options);\n+  }\n+\n+  /**\n+   * Retrieve a stream from the server.\n+   *\n+   * @param ticket  The ticket granting access to the data stream.\n+   * @param options RPC-layer hints for this call.\n+   */\n+  public FlightStream getStream(Ticket ticket, CallOption... options) {\n+    return this.client.getStream(ticket, options);\n+  }\n+\n+  /**\n+   * Request a set of Flight SQL metadata.\n+   *\n+   * @param info The set of metadata to retrieve. None to retrieve all metadata.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSqlInfo(final @Nullable int... info) {\n+    final CommandGetSqlInfo.Builder builder = CommandGetSqlInfo.newBuilder();\n+    for (final int pieceOfInfo : Objects.isNull(info) ? new int[0] : info) {\n+      builder.addInfo(pieceOfInfo);\n+    }\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of tables.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @param tableFilterPattern  The table filter pattern.\n+   * @param tableTypes          The table types to include.\n+   * @param includeSchema       True to include the schema upon return, false to not include the schema.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getTables(final @Nullable String catalog, final @Nullable String schemaFilterPattern,\n+                              final @Nullable String tableFilterPattern, final List<String> tableTypes,\n+                              final boolean includeSchema) {\n+    final CommandGetTables.Builder builder = CommandGetTables.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    if (tableFilterPattern != null) {\n+      builder.setTableNameFilterPattern(StringValue.newBuilder().setValue(tableFilterPattern).build());\n+    }\n+\n+    if (tableTypes != null) {\n+      builder.addAllTableTypes(tableTypes);\n+    }\n+    builder.setIncludeSchema(includeSchema);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request the primary keys for a table.\n+   *\n+   * @param catalog The catalog.\n+   * @param schema  The schema.\n+   * @param table   The table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getPrimaryKeys(final @Nullable String catalog, final @Nullable String schema,\n+                                   final @Nullable String table) {\n+    final CommandGetPrimaryKeys.Builder builder = CommandGetPrimaryKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    if (table != null) {\n+      builder.setTable(StringValue.newBuilder().setValue(table).build());\n+    }\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request to get info about keys on a table. The table, which exports the foreign keys, parameter must be specified.\n+   *\n+   * @param catalog The foreign key table catalog.\n+   * @param schema  The foreign key table schema.\n+   * @param table   The foreign key table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getExportedKeys(String catalog, String schema, String table) {\n+    if (null == table) {\n+      throw Status.INVALID_ARGUMENT.asRuntimeException();\n+    }\n+\n+    final CommandGetExportedKeys.Builder builder = CommandGetExportedKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    builder.setTable(table).build();\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request to get info about keys on a table. The table, which imports the foreign keys, parameter must be specified.\n+   *\n+   * @param catalog The primary key table catalog.\n+   * @param schema  The primary key table schema.\n+   * @param table   The primary key table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getImportedKeys(String catalog, String schema, String table) {\n+    if (null == table) {\n+      throw Status.INVALID_ARGUMENT.asRuntimeException();\n+    }\n+\n+    final CommandGetImportedKeys.Builder builder = CommandGetImportedKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    builder.setTable(table).build();\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of table types.\n+   *\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getTableTypes() {\n+    final CommandGetTableTypes.Builder builder = CommandGetTableTypes.newBuilder();\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Create a prepared statement on the server.\n+   *\n+   * @param query The query to prepare.\n+   * @return The representation of the prepared statement which exists on the server.\n+   */\n+  public PreparedStatement prepare(String query) {\n+    return new PreparedStatement(client, query);\n+  }\n+\n+  /**\n+   * Helper class to encapsulate Flight SQL prepared statement logic.\n+   */\n+  public static class PreparedStatement implements Closeable {\n+    private final FlightClient client;\n+    private final ActionCreatePreparedStatementResult preparedStatementResult;\n+    private AtomicLong invocationCount;\n+    private boolean isClosed;\n+    private Schema resultSetSchema = null;\n+    private Schema parameterSchema = null;\n+    private VectorSchemaRoot parameterBindingRoot;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param client The client. FlightSqlPreparedStatement does not maintain this resource.\n+     * @param sql    The query.\n+     */\n+    public PreparedStatement(FlightClient client, String sql) {\n+      this.client = client;\n+\n+      final Iterator<Result> preparedStatementResults = client.doAction(new Action(\n+          FlightSqlUtils.FLIGHT_SQL_CREATEPREPAREDSTATEMENT.getType(),\n+          Any.pack(ActionCreatePreparedStatementRequest\n+              .newBuilder()\n+              .setQuery(sql)\n+              .build())\n+              .toByteArray()));\n+\n+      preparedStatementResult = FlightSqlUtils.unpackAndParseOrThrow(\n+          preparedStatementResults.next().getBody(),\n+          ActionCreatePreparedStatementResult.class);\n+\n+      invocationCount = new AtomicLong(0);\n+      isClosed = false;\n+    }\n+\n+    /**\n+     * Set the {@link VectorSchemaRoot} containing the parameter binding from a preparedStatemnt\n+     * operation.\n+     *\n+     * @param parameterBindingRoot  a {@link VectorSchemaRoot} object contain the values to be used in the\n+     *                              PreparedStatement setters.\n+     */\n+    public void setParameters(VectorSchemaRoot parameterBindingRoot) {\n+      this.parameterBindingRoot = parameterBindingRoot;\n+    }\n+\n+    /**\n+     * Empty the {@link VectorSchemaRoot} that contains the parameter binding from a preparedStatemnt\n+     * operation.\n+     *\n+     */\n+    public void clearParameters() {\n+      this.parameterBindingRoot = null;\n+    }\n+\n+    /**\n+     * Returns the Schema of the resultset.\n+     *\n+     * @return the Schema of the resultset.\n+     */\n+    public Schema getResultSetSchema() {\n+      if (resultSetSchema == null && preparedStatementResult.getDatasetSchema() != null) {\n+        resultSetSchema = Schema.deserialize(preparedStatementResult.getDatasetSchema().asReadOnlyByteBuffer());\n+      }\n+      return resultSetSchema;\n+    }\n+\n+    /**\n+     * Returns the Schema of the parameters.\n+     *\n+     * @return the Schema of the parameters.\n+     */\n+    public Schema getParameterSchema() {\n+      if (parameterSchema == null && preparedStatementResult.getParameterSchema() != null) {\n+        parameterSchema = Schema.deserialize(preparedStatementResult.getParameterSchema().asReadOnlyByteBuffer());\n+      }\n+      return parameterSchema;\n+    }\n+\n+    /**\n+     * Executes the prepared statement query on the server.\n+     *\n+     * @return a FlightInfo object representing the stream(s) to fetch.\n+     * @throws IOException if the PreparedStatement is closed.\n+     */\n+    public FlightInfo execute() throws IOException {\n+      if (isClosed) {\n+        throw new IllegalStateException(\"Prepared statement has already been closed on the server.\");\n\nReview comment:\n       IIRC, the original proposal had comments about standardizing some errors. This might be a candidate for that, so that the server and client can raise a consistent exception for attempting to use an already-closed statement.\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlClient.java\n##########\n@@ -0,0 +1,504 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.SyncPutListener;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.StringValue;\n+\n+import io.grpc.Status;\n+\n+/**\n+ * Flight client with Flight SQL semantics.\n+ */\n+public class FlightSqlClient {\n+  private FlightClient client;\n+\n+  public FlightSqlClient(FlightClient client) {\n+    this.client = client;\n+  }\n+\n+  /**\n+   * Execute a query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo execute(String query) {\n+    final CommandStatementQuery.Builder builder = CommandStatementQuery.newBuilder();\n+    builder.setQuery(query);\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Execute an update query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public long executeUpdate(String query) {\n+    final CommandStatementUpdate.Builder builder = CommandStatementUpdate.newBuilder();\n+    builder.setQuery(query);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    final SyncPutListener putListener = new SyncPutListener();\n+    client.startPut(descriptor, VectorSchemaRoot.of(), putListener);\n+\n+    try {\n+      final PutResult read = putListener.read();\n+      try (final ArrowBuf metadata = read.getApplicationMetadata()) {\n+        final DoPutUpdateResult doPutUpdateResult = DoPutUpdateResult.parseFrom(metadata.nioBuffer());\n+        return doPutUpdateResult.getRecordCount();\n+      }\n+    } catch (InterruptedException | ExecutionException | InvalidProtocolBufferException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  /**\n+   * Request a list of catalogs.\n+   *\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getCatalogs() {\n+    final CommandGetCatalogs.Builder builder = CommandGetCatalogs.newBuilder();\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of schemas.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSchemas(final String catalog, final String schemaFilterPattern) {\n+    final CommandGetSchemas.Builder builder = CommandGetSchemas.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Get schema for a stream.\n+   *\n+   * @param descriptor The descriptor for the stream.\n+   * @param options    RPC-layer hints for this call.\n+   */\n+  public SchemaResult getSchema(FlightDescriptor descriptor, CallOption... options) {\n+    return this.client.getSchema(descriptor, options);\n+  }\n+\n+  /**\n+   * Retrieve a stream from the server.\n+   *\n+   * @param ticket  The ticket granting access to the data stream.\n+   * @param options RPC-layer hints for this call.\n+   */\n+  public FlightStream getStream(Ticket ticket, CallOption... options) {\n+    return this.client.getStream(ticket, options);\n+  }\n+\n+  /**\n+   * Request a set of Flight SQL metadata.\n+   *\n+   * @param info The set of metadata to retrieve. None to retrieve all metadata.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSqlInfo(final @Nullable int... info) {\n+    final CommandGetSqlInfo.Builder builder = CommandGetSqlInfo.newBuilder();\n+    for (final int pieceOfInfo : Objects.isNull(info) ? new int[0] : info) {\n+      builder.addInfo(pieceOfInfo);\n+    }\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of tables.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @param tableFilterPattern  The table filter pattern.\n+   * @param tableTypes          The table types to include.\n+   * @param includeSchema       True to include the schema upon return, false to not include the schema.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getTables(final @Nullable String catalog, final @Nullable String schemaFilterPattern,\n+                              final @Nullable String tableFilterPattern, final List<String> tableTypes,\n+                              final boolean includeSchema) {\n+    final CommandGetTables.Builder builder = CommandGetTables.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    if (tableFilterPattern != null) {\n+      builder.setTableNameFilterPattern(StringValue.newBuilder().setValue(tableFilterPattern).build());\n+    }\n+\n+    if (tableTypes != null) {\n+      builder.addAllTableTypes(tableTypes);\n+    }\n+    builder.setIncludeSchema(includeSchema);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request the primary keys for a table.\n+   *\n+   * @param catalog The catalog.\n+   * @param schema  The schema.\n+   * @param table   The table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getPrimaryKeys(final @Nullable String catalog, final @Nullable String schema,\n+                                   final @Nullable String table) {\n+    final CommandGetPrimaryKeys.Builder builder = CommandGetPrimaryKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    if (table != null) {\n+      builder.setTable(StringValue.newBuilder().setValue(table).build());\n+    }\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request to get info about keys on a table. The table, which exports the foreign keys, parameter must be specified.\n+   *\n+   * @param catalog The foreign key table catalog.\n+   * @param schema  The foreign key table schema.\n+   * @param table   The foreign key table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getExportedKeys(String catalog, String schema, String table) {\n+    if (null == table) {\n+      throw Status.INVALID_ARGUMENT.asRuntimeException();\n+    }\n+\n+    final CommandGetExportedKeys.Builder builder = CommandGetExportedKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    builder.setTable(table).build();\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request to get info about keys on a table. The table, which imports the foreign keys, parameter must be specified.\n+   *\n+   * @param catalog The primary key table catalog.\n+   * @param schema  The primary key table schema.\n+   * @param table   The primary key table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getImportedKeys(String catalog, String schema, String table) {\n+    if (null == table) {\n+      throw Status.INVALID_ARGUMENT.asRuntimeException();\n+    }\n+\n+    final CommandGetImportedKeys.Builder builder = CommandGetImportedKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    builder.setTable(table).build();\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of table types.\n+   *\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getTableTypes() {\n+    final CommandGetTableTypes.Builder builder = CommandGetTableTypes.newBuilder();\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Create a prepared statement on the server.\n+   *\n+   * @param query The query to prepare.\n+   * @return The representation of the prepared statement which exists on the server.\n+   */\n+  public PreparedStatement prepare(String query) {\n+    return new PreparedStatement(client, query);\n+  }\n+\n+  /**\n+   * Helper class to encapsulate Flight SQL prepared statement logic.\n+   */\n+  public static class PreparedStatement implements Closeable {\n+    private final FlightClient client;\n+    private final ActionCreatePreparedStatementResult preparedStatementResult;\n+    private AtomicLong invocationCount;\n+    private boolean isClosed;\n+    private Schema resultSetSchema = null;\n+    private Schema parameterSchema = null;\n+    private VectorSchemaRoot parameterBindingRoot;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param client The client. FlightSqlPreparedStatement does not maintain this resource.\n\nReview comment:\n       ```suggestion\r\n        * @param client The client. PreparedStatement does not maintain this resource.\r\n   ```\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: int32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Ragne [500-1000)\n+   * Range [0-100000) is reserved for defaults. Custom options should start at 100000.\n+   *\n+   * 1. Server Information [0-500): Provides basic information about the Flight SQL Server.\n+   *\n+   * The name of the Flight SQL Server.\n+   * 0 = FLIGHT_SQL_SERVER_NAME\n+   *\n+   * The native version of the Flight SQL Server.\n+   * 1 = FLIGHT_SQL_SERVER_VERSION\n+   *\n+   * The Arrow format version of the Flight SQL Server.\n+   * 2 = FLIGHT_SQL_SERVER_ARROW_VERSION\n+   *\n+   * Indicates whether the Flight SQL Server is read only.\n+   * 3 = FLIGHT_SQL_SERVER_READ_ONLY\n+   *\n+   * 2. SQL Syntax Information [500-1000): provides information about SQL syntax supported by the Flight SQL Server.\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of catalogs.\n+   * In a SQL environment, a catalog is a collection of schemas.\n+   * 500 = SQL_DDL_CATALOG\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of schemas.\n+   * In a SQL environment, a catalog is a collection of tables, views, indexes etc.\n+   * 501 = SQL_DDL_SCHEMA\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of tables.\n+   * In a SQL environment, a table is a collection of rows of information. Each row of information\n+   * may have one or more columns of data.\n+   * 502 = SQL_DDL_TABLE\n+   *\n+   * Indicates the case sensitivity of catalog, table and schema names.\n+   * 503 = SQL_IDENTIFIER_CASE\n+   *\n+   * Indicates the supported character(s) used to surround a delimited identifier.\n+   * 504 = SQL_IDENTIFIER_QUOTE_CHAR\n+   *\n+   * Indicates case sensitivity of quoted identifiers.\n+   * 505 = SQL_QUOTED_IDENTIFIER_CASE\n+   *\n+   * If omitted, then all metadata will be retrieved.\n+   * Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must\n+   * at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved.\n+   * If additional metadata is included, the metadata IDs should start from 10,000.\n+   */\n+  repeated uint32 info = 1;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of catalogs on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name.\n+ */\n+message CommandGetCatalogs {\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of schemas on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, then schema_name.\n+ */\n+message CommandGetSchemas {\n+  /*\n+   * Specifies the Catalog to search for schemas.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, the pattern will not be used to narrow the search.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of tables, and optionally their schemas, on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  table_type: utf8,\n+ *  table_schema: bytes\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, then table_type.\n+ */\n+message CommandGetTables {\n+  /*\n+   * Specifies the Catalog to search for the tables.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, all schemas matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+\n+  /*\n+   * Specifies a filter pattern for tables to search for.\n+   * When no table_name_filter_pattern is provided, all tables matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue table_name_filter_pattern = 3;\n+\n+  // Specifies a filter of table types which must match.\n+  repeated string table_types = 4;\n+\n+  // Specifies if the schema should be returned for found tables.\n+  bool include_schema = 5;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of table types on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  table_type: utf8\n+ * >\n+ * The returned data should be ordered by table_type.\n+ */\n+message CommandGetTableTypes {\n+}\n+\n+/*\n+ * Represents a request to retrieve the primary keys of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  column_name: utf8,\n+ *  key_sequence: int,\n+ *  key_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n+ */\n+message CommandGetPrimaryKeys {\n+  // Specifies the catalog to search for the table.\n+  google.protobuf.StringValue catalog = 1;\n+\n+  // Specifies the schema to search for the table.\n+  google.protobuf.StringValue schema = 2;\n+\n+  // Specifies the table to get the primary keys for.\n+  google.protobuf.StringValue table = 3;\n+}\n+\n+/*\n+ * Represents a request to retrieve a description of the foreign key columns that reference the given table's\n+ * primary key columns (the foreign keys exported by a table) of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  pk_catalog_name: utf8,\n+ *  pk_schema_name: utf8,\n+ *  pk_table_name: utf8,\n+ *  pk_column_name: utf8,\n+ *  fk_catalog_name: utf8,\n+ *  fk_schema_name: utf8,\n+ *  fk_table_name: utf8,\n+ *  fk_column_name: utf8,\n+ *  key_sequence: int,\n+ *  fk_key_name: utf8,\n+ *  pk_key_name: utf8,\n+ *  update_rule: int,\n+ *  delete_rule: int\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n+ */\n+message CommandGetExportedKeys {\n+  // Specifies the catalog to search for the foreign key table.\n+  google.protobuf.StringValue catalog = 1;\n+\n+  // Specifies the schema to search for the foreign key table.\n+  google.protobuf.StringValue schema = 2;\n+\n+  // Specifies the foreign key table to get the foreign keys for.\n+  string table = 3;\n+}\n+\n+/*\n+ * Represents a request to retrieve the foreign keys of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  pk_catalog_name: utf8,\n+ *  pk_schema_name: utf8,\n+ *  pk_table_name: utf8,\n+ *  pk_column_name: utf8,\n+ *  fk_catalog_name: utf8,\n+ *  fk_schema_name: utf8,\n+ *  fk_table_name: utf8,\n+ *  fk_column_name: utf8,\n+ *  key_sequence: int,\n+ *  fk_key_name: utf8,\n+ *  pk_key_name: utf8,\n+ *  update_rule: int,\n+ *  delete_rule: int\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n+ */\n+message CommandGetImportedKeys {\n+  // Specifies the catalog to search for the primary key table.\n+  google.protobuf.StringValue catalog = 1;\n+\n+  // Specifies the schema to search for the primary key table.\n+  google.protobuf.StringValue schema = 2;\n+\n+  // Specifies the primary key table to get the foreign keys for.\n+  string table = 3;\n+}\n+\n+// SQL Execution Action Messages\n+\n+/*\n+ * Request message for the \"GetPreparedStatement\" action on a Flight SQL enabled backend.\n+ */\n+message ActionCreatePreparedStatementRequest {\n+  // The valid SQL string to create a prepared statement for.\n+  string query = 1;\n+}\n+\n+/*\n+ * Wrap the result of a \"GetPreparedStatement\" action.\n+ */\n+message ActionCreatePreparedStatementResult {\n+  // Opaque handle for the prepared statement on the server.\n+  bytes prepared_statement_handle = 1;\n+\n+  // If a result set generating query was provided, dataset_schema contains the \n+  // schema of the dataset as described in Schema.fbs::Schema, it is serialized as an IPC message.\n+  bytes dataset_schema = 2;\n+\n+  // If the query provided contained parameters, parameter_schema contains the \n+  // Schema of the expected parameters as described in Schema.fbs::Schema.\n+  bytes parameter_schema = 3;\n+}\n+\n+/*\n+ * Request message for the \"ClosePreparedStatement\" action on a Flight SQL enabled backend.\n+ * Closes server resources associated with the prepared statement handle.\n+ */\n+message ActionClosePreparedStatementRequest {\n+  // Opaque handle for the prepared statement on the server.\n+  bytes prepared_statement_handle = 1;\n+}\n+\n+\n+// SQL Execution Messages.\n+\n+/*\n+ * Represents a SQL query. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the query.\n+ */\n+message CommandStatementQuery {\n+  // The SQL syntax.\n+  string query = 1;\n+\n+  // Unique identifier for the instance of the prepared statement to execute.\n+  bytes client_execution_handle = 2;\n+}\n+\n\nReview comment:\n       There used to be a way to execute a query without a prepared statement, was that dropped?\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlUtils.java\n##########\n@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import java.util.List;\n+\n+import org.apache.arrow.flight.ActionType;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.Message;\n+\n+/**\n+ * Utilities to work with Flight SQL semantics.\n+ */\n+public final class FlightSqlUtils {\n+  public static final ActionType FLIGHT_SQL_CREATEPREPAREDSTATEMENT = new ActionType(\"CreatePreparedStatement\",\n+      \"Creates a reusable prepared statement resource on the server. \\n\" +\n+          \"Request Message: ActionCreatePreparedStatementRequest\\n\" +\n+          \"Response Message: ActionCreatePreparedStatementResult\");\n+\n+  public static final ActionType FLIGHT_SQL_CLOSEPREPAREDSTATEMENT = new ActionType(\"ClosePreparedStatement\",\n+      \"Closes a reusable prepared statement resource on the server. \\n\" +\n+          \"Request Message: ActionClosePreparedStatementRequest\\n\" +\n+          \"Response Message: N/A\");\n+\n+  public static final List<ActionType> FLIGHT_SQL_ACTIONS = ImmutableList.of(\n+      FLIGHT_SQL_CREATEPREPAREDSTATEMENT,\n+      FLIGHT_SQL_CLOSEPREPAREDSTATEMENT\n+  );\n+\n+  /**\n+   * Helper to parse {@link com.google.protobuf.Any} objects to the specific protobuf object.\n+   *\n+   * @param source the raw bytes source value.\n+   * @return the materialized protobuf object.\n+   */\n+  public static Any parseOrThrow(byte[] source) {\n+    try {\n+      return Any.parseFrom(source);\n+    } catch (InvalidProtocolBufferException e) {\n+      throw new AssertionError(e.getMessage());\n\nReview comment:\n       I'm not sure AssertionError is the way to go here. Maybe StatusRuntimeException, with a message indicating that the remote sent an invalid protobuf?\n\n##########\nFile path: java/flight/flight-sql/src/test/java/org/apache/arrow/flight/sql/FlightSqlExample.java\n##########\n@@ -0,0 +1,1768 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n\nReview comment:\n       Why use the Guava one over Objects.requireNonNull?\n\n##########\nFile path: java/flight/flight-sql/src/test/java/org/apache/arrow/flight/sql/StatementContext.java\n##########\n@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import java.io.Serializable;\n+import java.sql.Connection;\n+import java.sql.Statement;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.util.AutoCloseables;\n+import org.apache.arrow.util.Preconditions;\n+\n+/**\n+ * Context for {@link T} to be persisted in memory in between {@link FlightSqlProducer} calls.\n+ *\n+ * @param <T> the {@link Statement} to be persisted.\n+ */\n+public final class StatementContext<T extends Statement> implements AutoCloseable, Serializable {\n\nReview comment:\n       I think we should put this and the example in their own namespace to make it clear they're examples.\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: int32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Ragne [500-1000)\n+   * Range [0-100000) is reserved for defaults. Custom options should start at 100000.\n\nReview comment:\n       (In which case, I'd wonder if we could use integers with a oneof to provide namespacing instead.)\n\n##########\nFile path: java/flight/flight-sql/src/test/java/org/apache/arrow/flight/sql/FlightSqlExample.java\n##########\n@@ -0,0 +1,1768 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.emptyToNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static com.google.protobuf.Any.pack;\n+import static com.google.protobuf.ByteString.copyFrom;\n+import static java.lang.String.format;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.isNull;\n+import static java.util.Optional.empty;\n+import static java.util.UUID.randomUUID;\n+import static java.util.stream.StreamSupport.stream;\n+import static org.apache.arrow.adapter.jdbc.JdbcToArrow.sqlToArrowVectorIterator;\n+import static org.apache.arrow.adapter.jdbc.JdbcToArrowUtils.jdbcToArrowSchema;\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.Date;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TimeZone;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.adapter.jdbc.ArrowVectorIterator;\n+import org.apache.arrow.adapter.jdbc.JdbcFieldInfo;\n+import org.apache.arrow.adapter.jdbc.JdbcToArrowConfig;\n+import org.apache.arrow.adapter.jdbc.JdbcToArrowUtils;\n+import org.apache.arrow.flight.CallStatus;\n+import org.apache.arrow.flight.Criteria;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightEndpoint;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightRuntimeException;\n+import org.apache.arrow.flight.FlightStatusCode;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.Location;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementUpdate;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.util.AutoCloseables;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.Decimal256Vector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.LargeVarCharVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMicroVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeNanoVector;\n+import org.apache.arrow.vector.TimeSecVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.TimeStampMilliTZVector;\n+import org.apache.arrow.vector.TimeStampNanoTZVector;\n+import org.apache.arrow.vector.TimeStampSecTZVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.UInt1Vector;\n+import org.apache.arrow.vector.UInt2Vector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.UInt8Vector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+import org.apache.arrow.vector.VectorLoader;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.VectorUnloader;\n+import org.apache.arrow.vector.complex.DenseUnionVector;\n+import org.apache.arrow.vector.holders.NullableIntHolder;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.apache.arrow.vector.util.Text;\n+import org.apache.commons.dbcp2.ConnectionFactory;\n+import org.apache.commons.dbcp2.DriverManagerConnectionFactory;\n+import org.apache.commons.dbcp2.PoolableConnection;\n+import org.apache.commons.dbcp2.PoolableConnectionFactory;\n+import org.apache.commons.dbcp2.PoolingDataSource;\n+import org.apache.commons.pool2.ObjectPool;\n+import org.apache.commons.pool2.impl.GenericObjectPool;\n+import org.slf4j.Logger;\n+\n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.google.common.cache.RemovalListener;\n+import com.google.common.cache.RemovalNotification;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.ProtocolStringList;\n+\n+import io.grpc.Status;\n+\n+/**\n+ * Proof of concept {@link FlightSqlProducer} implementation showing an Apache Derby backed Flight SQL server capable\n+ * of the following workflows:\n+ * <!--\n+ * TODO Revise summary: is it still matching?\n+ * -->\n+ * - returning a list of tables from the action `GetTables`.\n+ * - creation of a prepared statement from the action `CreatePreparedStatement`.\n+ * - execution of a prepared statement by using a {@link CommandPreparedStatementQuery}\n+ * with {@link #getFlightInfo} and {@link #getStream}.\n+ */\n+public class FlightSqlExample implements FlightSqlProducer, AutoCloseable {\n+  private static final String DATABASE_URI = \"jdbc:derby:target/derbyDB\";\n+  private static final Logger LOGGER = getLogger(FlightSqlExample.class);\n+  private static final Calendar DEFAULT_CALENDAR = JdbcToArrowUtils.getUtcCalendar();\n+  private final Location location;\n+  private final PoolingDataSource<PoolableConnection> dataSource;\n+  private final LoadingCache<ByteString, ResultSet> commandExecutePreparedStatementLoadingCache;\n+  private final BufferAllocator rootAllocator = new RootAllocator();\n+  private final Cache<ByteString, StatementContext<PreparedStatement>> preparedStatementLoadingCache;\n+  private final Cache<ByteString, StatementContext<Statement>> statementLoadingCache;\n+  private final LoadingCache<ByteString, ResultSet> commandExecuteStatementLoadingCache;\n+\n+  public FlightSqlExample(final Location location) {\n+    // TODO Constructor should not be doing work.\n+    Preconditions.checkState(\n+        removeDerbyDatabaseIfExists() && populateDerbyDatabase(),\n+        \"Failed to reset Derby database!\");\n+    final ConnectionFactory connectionFactory =\n+        new DriverManagerConnectionFactory(DATABASE_URI, new Properties());\n+    final PoolableConnectionFactory poolableConnectionFactory =\n+        new PoolableConnectionFactory(connectionFactory, null);\n+    final ObjectPool<PoolableConnection> connectionPool = new GenericObjectPool<>(poolableConnectionFactory);\n+\n+    poolableConnectionFactory.setPool(connectionPool);\n+    // PoolingDataSource takes ownership of `connectionPool`\n+    dataSource = new PoolingDataSource<>(connectionPool);\n+\n+    preparedStatementLoadingCache =\n+        CacheBuilder.newBuilder()\n+            .maximumSize(100)\n+            .expireAfterWrite(10, TimeUnit.MINUTES)\n+            .removalListener(new StatementRemovalListener<PreparedStatement>())\n+            .build();\n+\n+    commandExecutePreparedStatementLoadingCache =\n+        CacheBuilder.newBuilder()\n+            .maximumSize(100)\n+            .expireAfterWrite(10, TimeUnit.MINUTES)\n+            .removalListener(new CommandExecuteStatementRemovalListener())\n+            .build(new CommandExecutePreparedStatementCacheLoader(preparedStatementLoadingCache));\n+\n+    statementLoadingCache =\n+        CacheBuilder.newBuilder()\n+            .maximumSize(100)\n+            .expireAfterWrite(10, TimeUnit.MINUTES)\n+            .removalListener(new StatementRemovalListener<>())\n+            .build();\n+\n+    commandExecuteStatementLoadingCache =\n+        CacheBuilder.newBuilder()\n+            .maximumSize(100)\n+            .expireAfterWrite(10, TimeUnit.MINUTES)\n+            .removalListener(new CommandExecuteStatementRemovalListener())\n+            .build(new CommandExecuteStatementCacheLoader(statementLoadingCache));\n+\n+    this.location = location;\n+  }\n+\n+  private static boolean removeDerbyDatabaseIfExists() {\n+    boolean wasSuccess;\n+    final Path path = Paths.get(\"target\" + File.separator + \"derbyDB\");\n+\n+    try (final Stream<Path> walk = Files.walk(path)) {\n+      /*\n+       * Iterate over all paths to delete, mapping each path to the outcome of its own\n+       * deletion as a boolean representing whether or not each individual operation was\n+       * successful; then reduce all booleans into a single answer, and store that into\n+       * `wasSuccess`, which will later be returned by this method.\n+       * If for whatever reason the resulting `Stream<Boolean>` is empty, throw an `IOException`;\n+       * this not expected.\n+       */\n+      wasSuccess = walk.sorted(Comparator.reverseOrder()).map(Path::toFile).map(File::delete)\n+          .reduce(Boolean::logicalAnd).orElseThrow(IOException::new);\n+    } catch (IOException e) {\n+      /*\n+       * The only acceptable scenario for an `IOException` to be thrown here is if\n+       * an attempt to delete an non-existing file takes place -- which should be\n+       * alright, since they would be deleted anyway.\n+       */\n+      if (!(wasSuccess = e instanceof NoSuchFileException)) {\n+        LOGGER.error(format(\"Failed attempt to clear DerbyDB: <%s>\", e.getMessage()), e);\n+      }\n+    }\n+\n+    return wasSuccess;\n+  }\n+\n+  private static boolean populateDerbyDatabase() {\n+    Optional<SQLException> exception = empty();\n+    try (final Connection connection = DriverManager.getConnection(\"jdbc:derby:target/derbyDB;create=true\");\n+         Statement statement = connection.createStatement()) {\n+      statement.execute(\"CREATE TABLE foreignTable (\" +\n+          \"id INT not null primary key GENERATED ALWAYS AS IDENTITY (START WITH 1, INCREMENT BY 1), \" +\n+          \"foreignName varchar(100), \" +\n+          \"value int)\");\n+      statement.execute(\"CREATE TABLE intTable (\" +\n+          \"id INT not null primary key GENERATED ALWAYS AS IDENTITY (START WITH 1, INCREMENT BY 1), \" +\n+          \"keyName varchar(100), \" +\n+          \"value int, \" +\n+          \"foreignId int references foreignTable(id))\");\n+      statement.execute(\"INSERT INTO foreignTable (foreignName, value) VALUES ('keyOne', 1)\");\n+      statement.execute(\"INSERT INTO foreignTable (foreignName, value) VALUES ('keyTwo', 0)\");\n+      statement.execute(\"INSERT INTO foreignTable (foreignName, value) VALUES ('keyThree', -1)\");\n+      statement.execute(\"INSERT INTO intTable (keyName, value, foreignId) VALUES ('one', 1, 1)\");\n+      statement.execute(\"INSERT INTO intTable (keyName, value, foreignId) VALUES ('zero', 0, 1)\");\n+      statement.execute(\"INSERT INTO intTable (keyName, value, foreignId) VALUES ('negative one', -1, 1)\");\n+    } catch (SQLException e) {\n+      LOGGER.error(\n+          format(\"Failed attempt to populate DerbyDB: <%s>\", e.getMessage()),\n+          (exception = Optional.of(e)).get());\n+    }\n+\n+    return !exception.isPresent();\n\nReview comment:\n       Why the convolutions with the optional?\n\n##########\nFile path: java/flight/flight-sql/src/test/java/org/apache/arrow/flight/TestFlightSql.java\n##########\n@@ -0,0 +1,653 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.isNull;\n+import static org.apache.arrow.util.AutoCloseables.close;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.Reader;\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+import java.util.stream.IntStream;\n+\n+import org.apache.arrow.flight.sql.FlightSqlClient;\n+import org.apache.arrow.flight.sql.FlightSqlClient.PreparedStatement;\n+import org.apache.arrow.flight.sql.FlightSqlExample;\n+import org.apache.arrow.flight.sql.FlightSqlProducer;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.complex.DenseUnionVector;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.apache.arrow.vector.util.Text;\n+import org.hamcrest.Matcher;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ErrorCollector;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Test direct usage of Flight SQL workflows.\n+ */\n+public class TestFlightSql {\n\nReview comment:\n       I wonder if it might make more sense to test against a 'mock' server that isn't actually backed by a database. There are a lot of details here that are tied to Apache Derby.\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlUtils.java\n##########\n@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import java.util.List;\n+\n+import org.apache.arrow.flight.ActionType;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.Message;\n+\n+/**\n+ * Utilities to work with Flight SQL semantics.\n+ */\n+public final class FlightSqlUtils {\n+  public static final ActionType FLIGHT_SQL_CREATEPREPAREDSTATEMENT = new ActionType(\"CreatePreparedStatement\",\n+      \"Creates a reusable prepared statement resource on the server. \\n\" +\n+          \"Request Message: ActionCreatePreparedStatementRequest\\n\" +\n+          \"Response Message: ActionCreatePreparedStatementResult\");\n+\n+  public static final ActionType FLIGHT_SQL_CLOSEPREPAREDSTATEMENT = new ActionType(\"ClosePreparedStatement\",\n+      \"Closes a reusable prepared statement resource on the server. \\n\" +\n+          \"Request Message: ActionClosePreparedStatementRequest\\n\" +\n+          \"Response Message: N/A\");\n+\n+  public static final List<ActionType> FLIGHT_SQL_ACTIONS = ImmutableList.of(\n+      FLIGHT_SQL_CREATEPREPAREDSTATEMENT,\n+      FLIGHT_SQL_CLOSEPREPAREDSTATEMENT\n+  );\n+\n+  /**\n+   * Helper to parse {@link com.google.protobuf.Any} objects to the specific protobuf object.\n+   *\n+   * @param source the raw bytes source value.\n+   * @return the materialized protobuf object.\n+   */\n+  public static Any parseOrThrow(byte[] source) {\n+    try {\n+      return Any.parseFrom(source);\n+    } catch (InvalidProtocolBufferException e) {\n+      throw new AssertionError(e.getMessage());\n\nReview comment:\n       And ideally, unpackAndParseOrThrow would also include the expected message in the error message (and the actual message if we got past the parsing step).\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlProducer.java\n##########\n@@ -0,0 +1,704 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.ActionType;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightProducer;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementUpdate;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.UnionMode;\n+import org.apache.arrow.vector.types.pojo.ArrowType.Union;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+\n+import io.grpc.Status;\n+\n+/**\n+ * API to Implement an Arrow Flight SQL producer.\n+ */\n+public interface FlightSqlProducer extends FlightProducer, AutoCloseable {\n+  /**\n+   * Depending on the provided command, method either:\n+   * 1. Return information about a SQL query, or\n+   * 2. Return information about a prepared statement. In this case, parameters binding is allowed.\n+   *\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return information about the given SQL query, or the given prepared statement.\n+   */\n+  @Override\n+  default FlightInfo getFlightInfo(CallContext context, FlightDescriptor descriptor) {\n+    final Any command = FlightSqlUtils.parseOrThrow(descriptor.getCommand());\n+\n+    if (command.is(CommandStatementQuery.class)) {\n+      return getFlightInfoStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandStatementQuery.class), context, descriptor);\n+    } else if (command.is(CommandPreparedStatementQuery.class)) {\n+      return getFlightInfoPreparedStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandPreparedStatementQuery.class), context, descriptor);\n+    } else if (command.is(CommandGetCatalogs.class)) {\n+      return getFlightInfoCatalogs(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetCatalogs.class), context, descriptor);\n+    } else if (command.is(CommandGetSchemas.class)) {\n+      return getFlightInfoSchemas(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetSchemas.class), context, descriptor);\n+    } else if (command.is(CommandGetTables.class)) {\n+      return getFlightInfoTables(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetTables.class), context, descriptor);\n+    } else if (command.is(CommandGetTableTypes.class)) {\n+      return getFlightInfoTableTypes(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetTableTypes.class), context, descriptor);\n+    } else if (command.is(CommandGetSqlInfo.class)) {\n+      return getFlightInfoSqlInfo(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetSqlInfo.class), context, descriptor);\n+    } else if (command.is(CommandGetPrimaryKeys.class)) {\n+      return getFlightInfoPrimaryKeys(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetPrimaryKeys.class), context, descriptor);\n+    } else if (command.is(CommandGetExportedKeys.class)) {\n+      return getFlightInfoExportedKeys(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetExportedKeys.class), context, descriptor);\n+    } else if (command.is(CommandGetImportedKeys.class)) {\n+      return getFlightInfoImportedKeys(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetImportedKeys.class), context, descriptor);\n+    }\n+\n+    throw Status.INVALID_ARGUMENT.asRuntimeException();\n+  }\n+\n+  /**\n+   * Returns the schema of the result produced by the SQL query.\n+   *\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return the result set schema.\n+   */\n+  @Override\n+  default SchemaResult getSchema(CallContext context, FlightDescriptor descriptor) {\n+    final Any command = FlightSqlUtils.parseOrThrow(descriptor.getCommand());\n+\n+    if (command.is(CommandStatementQuery.class)) {\n+      return getSchemaStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandStatementQuery.class), context, descriptor);\n+    } else if (command.is(CommandGetCatalogs.class)) {\n+      return getSchemaCatalogs();\n+    } else if (command.is(CommandGetSchemas.class)) {\n+      return getSchemaSchemas();\n+    } else if (command.is(CommandGetTables.class)) {\n+      return getSchemaTables();\n+    } else if (command.is(CommandGetTableTypes.class)) {\n+      return getSchemaTableTypes();\n+    } else if (command.is(CommandGetSqlInfo.class)) {\n+      return getSchemaSqlInfo();\n+    } else if (command.is(CommandGetPrimaryKeys.class)) {\n+      return getSchemaPrimaryKeys();\n+    } else if (command.is(CommandGetExportedKeys.class)) {\n+      return getSchemaForImportedAndExportedKeys();\n+    } else if (command.is(CommandGetImportedKeys.class)) {\n+      return getSchemaForImportedAndExportedKeys();\n+    }\n+\n+    throw Status.INVALID_ARGUMENT.asRuntimeException();\n+  }\n+\n+  /**\n+   * Depending on the provided command, method either:\n+   * 1. Return data for a stream produced by executing the provided SQL query, or\n+   * 2. Return data for a prepared statement. In this case, parameters binding is allowed.\n+   *\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  @Override\n+  default void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+    final Any command;\n+\n+    try {\n+      command = Any.parseFrom(ticket.getBytes());\n+    } catch (InvalidProtocolBufferException e) {\n+      listener.error(e);\n+      return;\n+    }\n+\n+    if (command.is(CommandStatementQuery.class)) {\n+      getStreamStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandStatementQuery.class), context, ticket, listener);\n+    } else if (command.is(CommandPreparedStatementQuery.class)) {\n+      getStreamPreparedStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandPreparedStatementQuery.class), context, ticket, listener);\n+    } else if (command.is(CommandGetCatalogs.class)) {\n+      getStreamCatalogs(context, ticket, listener);\n+    } else if (command.is(CommandGetSchemas.class)) {\n+      getStreamSchemas(FlightSqlUtils.unpackOrThrow(command, CommandGetSchemas.class), context, ticket, listener);\n+    } else if (command.is(CommandGetTables.class)) {\n+      getStreamTables(FlightSqlUtils.unpackOrThrow(command, CommandGetTables.class), context, ticket, listener);\n+    } else if (command.is(CommandGetTableTypes.class)) {\n+      getStreamTableTypes(context, ticket, listener);\n+    } else if (command.is(CommandGetSqlInfo.class)) {\n+      getStreamSqlInfo(FlightSqlUtils.unpackOrThrow(command, CommandGetSqlInfo.class), context, ticket, listener);\n+    } else if (command.is(CommandGetPrimaryKeys.class)) {\n+      getStreamPrimaryKeys(FlightSqlUtils.unpackOrThrow(command, CommandGetPrimaryKeys.class),\n+          context, ticket, listener);\n+    } else if (command.is(CommandGetExportedKeys.class)) {\n+      getStreamExportedKeys(FlightSqlUtils.unpackOrThrow(command, CommandGetExportedKeys.class),\n+          context, ticket, listener);\n+    } else if (command.is(CommandGetImportedKeys.class)) {\n+      getStreamImportedKeys(FlightSqlUtils.unpackOrThrow(command, CommandGetImportedKeys.class),\n+          context, ticket, listener);\n+    } else {\n+      throw Status.INVALID_ARGUMENT.asRuntimeException();\n+    }\n+  }\n+\n+  /**\n+   * Depending on the provided command, method either:\n+   * 1. Execute provided SQL query as an update statement, or\n+   * 2. Execute provided update SQL query prepared statement. In this case, parameters binding\n+   * is allowed, or\n+   * 3. Binds parameters to the provided prepared statement.\n+   *\n+   * @param context      Per-call context.\n+   * @param flightStream The data stream being uploaded.\n+   * @param ackStream    The data stream listener for update result acknowledgement.\n+   * @return a Runnable to process the stream.\n+   */\n+  @Override\n+  default Runnable acceptPut(CallContext context, FlightStream flightStream, StreamListener<PutResult> ackStream) {\n+    final Any command = FlightSqlUtils.parseOrThrow(flightStream.getDescriptor().getCommand());\n+\n+    if (command.is(CommandStatementUpdate.class)) {\n+      return acceptPutStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandStatementUpdate.class),\n+          context, flightStream, ackStream);\n+    } else if (command.is(CommandPreparedStatementUpdate.class)) {\n+      return acceptPutPreparedStatementUpdate(\n+          FlightSqlUtils.unpackOrThrow(command, CommandPreparedStatementUpdate.class),\n+          context, flightStream, ackStream);\n+    } else if (command.is(CommandPreparedStatementQuery.class)) {\n+      return acceptPutPreparedStatementQuery(\n+          FlightSqlUtils.unpackOrThrow(command, CommandPreparedStatementQuery.class),\n+          context, flightStream, ackStream);\n+    }\n+\n+    throw Status.INVALID_ARGUMENT.asRuntimeException();\n+  }\n+\n+  /**\n+   * Lists all available Flight SQL actions.\n+   *\n+   * @param context  Per-call context.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  @Override\n+  default void listActions(CallContext context, StreamListener<ActionType> listener) {\n+    FlightSqlUtils.FLIGHT_SQL_ACTIONS.forEach(listener::onNext);\n+    listener.onCompleted();\n+  }\n+\n+  /**\n+   * Performs the requested Flight SQL action.\n+   *\n+   * @param context  Per-call context.\n+   * @param action   Client-supplied parameters.\n+   * @param listener A stream of responses.\n+   */\n+  @Override\n+  default void doAction(CallContext context, Action action, StreamListener<Result> listener) {\n+    final String actionType = action.getType();\n+    if (actionType.equals(FlightSqlUtils.FLIGHT_SQL_CREATEPREPAREDSTATEMENT.getType())) {\n+      final ActionCreatePreparedStatementRequest request = FlightSqlUtils.unpackAndParseOrThrow(action.getBody(),\n+          ActionCreatePreparedStatementRequest.class);\n+      createPreparedStatement(request, context, listener);\n+    } else if (actionType.equals(FlightSqlUtils.FLIGHT_SQL_CLOSEPREPAREDSTATEMENT.getType())) {\n+      final ActionClosePreparedStatementRequest request = FlightSqlUtils.unpackAndParseOrThrow(action.getBody(),\n+          ActionClosePreparedStatementRequest.class);\n+      closePreparedStatement(request, context, listener);\n+    }\n+\n+    throw Status.INVALID_ARGUMENT.asRuntimeException();\n+  }\n+\n+  /**\n+   * Creates a prepared statement on the server and returns a handle and metadata for in a\n+   * {@link ActionCreatePreparedStatementResult} object in a {@link Result}\n+   * object.\n+   *\n+   * @param request  The sql command to generate the prepared statement.\n+   * @param context  Per-call context.\n+   * @param listener A stream of responses.\n+   */\n+  void createPreparedStatement(ActionCreatePreparedStatementRequest request, CallContext context,\n+                               StreamListener<Result> listener);\n+\n+  /**\n+   * Closes a prepared statement on the server. No result is expected.\n+   *\n+   * @param request  The sql command to generate the prepared statement.\n+   * @param context  Per-call context.\n+   * @param listener A stream of responses.\n+   */\n+  void closePreparedStatement(ActionClosePreparedStatementRequest request, CallContext context,\n+                              StreamListener<Result> listener);\n+\n+  /**\n+   * Gets information about a particular SQL query based data stream.\n+   *\n+   * @param command    The sql command to generate the data stream.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoStatement(CommandStatementQuery command, CallContext context,\n+                                    FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets information about a particular prepared statement data stream.\n+   *\n+   * @param command    The prepared statement to generate the data stream.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoPreparedStatement(CommandPreparedStatementQuery command,\n+                                            CallContext context, FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about a particular SQL query based data stream.\n+   *\n+   * @param command    The sql command to generate the data stream.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Schema for the stream.\n+   */\n+  SchemaResult getSchemaStatement(CommandStatementQuery command, CallContext context,\n+                                  FlightDescriptor descriptor);\n+\n+  /**\n+   * Returns data for a SQL query based data stream.\n+   *\n+   * @param command  The sql command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamStatement(CommandStatementQuery command, CallContext context, Ticket ticket,\n+                          ServerStreamListener listener);\n+\n+  /**\n+   * Returns data for a particular prepared statement query instance.\n+   *\n+   * @param command  The prepared statement to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamPreparedStatement(CommandPreparedStatementQuery command, CallContext context,\n+                                  Ticket ticket, ServerStreamListener listener);\n+\n+  /**\n+   * Accepts uploaded data for a particular SQL query based data stream.\n+   * <p>`PutResult`s must be in the form of a {@link DoPutUpdateResult}.\n+   *\n+   * @param command      The sql command to generate the data stream.\n+   * @param context      Per-call context.\n+   * @param flightStream The data stream being uploaded.\n+   * @param ackStream    The result data stream.\n+   * @return A runnable to process the stream.\n+   */\n+  Runnable acceptPutStatement(CommandStatementUpdate command, CallContext context,\n+                              FlightStream flightStream, StreamListener<PutResult> ackStream);\n+\n+  /**\n+   * Accepts uploaded data for a particular prepared statement data stream.\n+   * <p>`PutResult`s must be in the form of a {@link DoPutUpdateResult}.\n+   *\n+   * @param command      The prepared statement to generate the data stream.\n+   * @param context      Per-call context.\n+   * @param flightStream The data stream being uploaded.\n+   * @param ackStream    The result data stream.\n+   * @return A runnable to process the stream.\n+   */\n+  Runnable acceptPutPreparedStatementUpdate(CommandPreparedStatementUpdate command,\n+                                            CallContext context, FlightStream flightStream,\n+                                            StreamListener<PutResult> ackStream);\n+\n+  /**\n+   * Accepts uploaded parameter values for a particular prepared statement query.\n+   *\n+   * @param command      The prepared statement the parameter values will bind to.\n+   * @param context      Per-call context.\n+   * @param flightStream The data stream being uploaded.\n+   * @param ackStream    The result data stream.\n+   * @return A runnable to process the stream.\n+   */\n+  Runnable acceptPutPreparedStatementQuery(CommandPreparedStatementQuery command,\n+                                           CallContext context, FlightStream flightStream,\n+                                           StreamListener<PutResult> ackStream);\n+\n+  /**\n+   * Returns the SQL Info of the server by returning a\n+   * {@link CommandGetSqlInfo} in a {@link Result}.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoSqlInfo(CommandGetSqlInfo request, CallContext context,\n+                                  FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get SQL info data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaSqlInfo() {\n+    return new SchemaResult(Schemas.GET_SQL_INFO_SCHEMA);\n+  }\n+\n+  /**\n+   * Returns data for SQL info based data stream.\n+   *\n+   * @param command  The command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamSqlInfo(CommandGetSqlInfo command, CallContext context, Ticket ticket,\n+                        ServerStreamListener listener);\n+\n+  /**\n+   * Returns the available catalogs by returning a stream of\n+   * {@link CommandGetCatalogs} objects in {@link Result} objects.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoCatalogs(CommandGetCatalogs request, CallContext context,\n+                                   FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get catalogs data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaCatalogs() {\n+    return new SchemaResult(Schemas.GET_CATALOGS_SCHEMA);\n+  }\n+\n+  /**\n+   * Returns data for catalogs based data stream.\n+   *\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamCatalogs(CallContext context, Ticket ticket,\n+                         ServerStreamListener listener);\n+\n+  /**\n+   * Returns the available schemas by returning a stream of\n+   * {@link CommandGetSchemas} objects in {@link Result} objects.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoSchemas(CommandGetSchemas request, CallContext context,\n+                                  FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get schemas data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaSchemas() {\n+    return new SchemaResult(Schemas.GET_SCHEMAS_SCHEMA);\n+  }\n+\n+  /**\n+   * Returns data for schemas based data stream.\n+   *\n+   * @param command  The command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamSchemas(CommandGetSchemas command, CallContext context, Ticket ticket,\n+                        ServerStreamListener listener);\n+\n+  /**\n+   * Returns the available tables by returning a stream of\n+   * {@link CommandGetTables} objects in {@link Result} objects.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoTables(CommandGetTables request, CallContext context,\n+                                 FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get tables data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaTables() {\n+    return new SchemaResult(Schemas.GET_TABLES_SCHEMA);\n+  }\n+\n+  /**\n+   * Returns data for tables based data stream.\n+   *\n+   * @param command  The command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamTables(CommandGetTables command, CallContext context, Ticket ticket,\n+                       ServerStreamListener listener);\n+\n+  /**\n+   * Returns the available table types by returning a stream of\n+   * {@link CommandGetTableTypes} objects in {@link Result} objects.\n+   *\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoTableTypes(CommandGetTableTypes request, CallContext context,\n+                                     FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get table types data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaTableTypes() {\n+    return new SchemaResult(Schemas.GET_TABLE_TYPES_SCHEMA);\n+  }\n+\n+  /**\n+   * Returns data for table types based data stream.\n+   *\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamTableTypes(CallContext context, Ticket ticket, ServerStreamListener listener);\n+\n+  /**\n+   * Returns the available primary keys by returning a stream of\n+   * {@link CommandGetPrimaryKeys} objects in {@link Result} objects.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoPrimaryKeys(CommandGetPrimaryKeys request, CallContext context,\n+                                      FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get primary keys data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaPrimaryKeys() {\n+    final List<Field> fields = Arrays.asList(\n+        Field.nullable(\"catalog_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"schema_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"table_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"column_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"key_sequence\", MinorType.INT.getType()),\n+        Field.nullable(\"key_name\", MinorType.VARCHAR.getType()));\n+\n+    return new SchemaResult(new Schema(fields));\n+  }\n+\n+  /**\n+   * Returns data for primary keys based data stream.\n+   *\n+   * @param command  The command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamPrimaryKeys(CommandGetPrimaryKeys command, CallContext context, Ticket ticket,\n+                            ServerStreamListener listener);\n+\n+  /**\n+   * Retrieves a description of the foreign key columns that reference the given table's primary key columns\n+   * {@link CommandGetExportedKeys} objects in {@link Result} objects.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoExportedKeys(CommandGetExportedKeys request, CallContext context,\n+                                       FlightDescriptor descriptor);\n+\n+  /**\n+   * Retrieves a description of the primary key columns that are referenced by given table's foreign key columns\n+   * {@link CommandGetImportedKeys} objects in {@link Result} objects.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoImportedKeys(CommandGetImportedKeys request, CallContext context,\n+                                       FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get imported and exported keys data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaForImportedAndExportedKeys() {\n+    return new SchemaResult(Schemas.GET_IMPORTED_AND_EXPORTED_KEYS_SCHEMA);\n+  }\n+\n+  /**\n+   * Returns data for foreign keys based data stream.\n+   *\n+   * @param command  The command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamExportedKeys(CommandGetExportedKeys command, CallContext context, Ticket ticket,\n+                             ServerStreamListener listener);\n+\n+  /**\n+   * Returns data for foreign keys based data stream.\n+   *\n+   * @param command  The command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamImportedKeys(CommandGetImportedKeys command, CallContext context, Ticket ticket,\n+                             ServerStreamListener listener);\n+\n+  /**\n+   * Default schema templates for the {@link FlightSqlProducer}.\n+   */\n+  final class Schemas {\n\nReview comment:\n       static final class?\n\n##########\nFile path: java/flight/flight-sql/src/test/java/org/apache/arrow/flight/sql/FlightSqlExample.java\n##########\n@@ -0,0 +1,1768 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.emptyToNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static com.google.protobuf.Any.pack;\n+import static com.google.protobuf.ByteString.copyFrom;\n+import static java.lang.String.format;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.isNull;\n+import static java.util.Optional.empty;\n+import static java.util.UUID.randomUUID;\n+import static java.util.stream.StreamSupport.stream;\n+import static org.apache.arrow.adapter.jdbc.JdbcToArrow.sqlToArrowVectorIterator;\n+import static org.apache.arrow.adapter.jdbc.JdbcToArrowUtils.jdbcToArrowSchema;\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.Date;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TimeZone;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.adapter.jdbc.ArrowVectorIterator;\n+import org.apache.arrow.adapter.jdbc.JdbcFieldInfo;\n+import org.apache.arrow.adapter.jdbc.JdbcToArrowConfig;\n+import org.apache.arrow.adapter.jdbc.JdbcToArrowUtils;\n+import org.apache.arrow.flight.CallStatus;\n+import org.apache.arrow.flight.Criteria;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightEndpoint;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightRuntimeException;\n+import org.apache.arrow.flight.FlightStatusCode;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.Location;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementUpdate;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.util.AutoCloseables;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.Decimal256Vector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.LargeVarCharVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMicroVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeNanoVector;\n+import org.apache.arrow.vector.TimeSecVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.TimeStampMilliTZVector;\n+import org.apache.arrow.vector.TimeStampNanoTZVector;\n+import org.apache.arrow.vector.TimeStampSecTZVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.UInt1Vector;\n+import org.apache.arrow.vector.UInt2Vector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.UInt8Vector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+import org.apache.arrow.vector.VectorLoader;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.VectorUnloader;\n+import org.apache.arrow.vector.complex.DenseUnionVector;\n+import org.apache.arrow.vector.holders.NullableIntHolder;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.apache.arrow.vector.util.Text;\n+import org.apache.commons.dbcp2.ConnectionFactory;\n+import org.apache.commons.dbcp2.DriverManagerConnectionFactory;\n+import org.apache.commons.dbcp2.PoolableConnection;\n+import org.apache.commons.dbcp2.PoolableConnectionFactory;\n+import org.apache.commons.dbcp2.PoolingDataSource;\n+import org.apache.commons.pool2.ObjectPool;\n+import org.apache.commons.pool2.impl.GenericObjectPool;\n+import org.slf4j.Logger;\n+\n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.google.common.cache.RemovalListener;\n+import com.google.common.cache.RemovalNotification;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.ProtocolStringList;\n+\n+import io.grpc.Status;\n\nReview comment:\n       Ditto - use CallStatus, not io.grpc.Status.\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlProducer.java\n##########\n@@ -0,0 +1,704 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.ActionType;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightProducer;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementUpdate;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.UnionMode;\n+import org.apache.arrow.vector.types.pojo.ArrowType.Union;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+\n+import io.grpc.Status;\n+\n+/**\n+ * API to Implement an Arrow Flight SQL producer.\n+ */\n+public interface FlightSqlProducer extends FlightProducer, AutoCloseable {\n+  /**\n+   * Depending on the provided command, method either:\n+   * 1. Return information about a SQL query, or\n+   * 2. Return information about a prepared statement. In this case, parameters binding is allowed.\n+   *\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return information about the given SQL query, or the given prepared statement.\n+   */\n+  @Override\n+  default FlightInfo getFlightInfo(CallContext context, FlightDescriptor descriptor) {\n+    final Any command = FlightSqlUtils.parseOrThrow(descriptor.getCommand());\n+\n+    if (command.is(CommandStatementQuery.class)) {\n+      return getFlightInfoStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandStatementQuery.class), context, descriptor);\n+    } else if (command.is(CommandPreparedStatementQuery.class)) {\n+      return getFlightInfoPreparedStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandPreparedStatementQuery.class), context, descriptor);\n+    } else if (command.is(CommandGetCatalogs.class)) {\n+      return getFlightInfoCatalogs(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetCatalogs.class), context, descriptor);\n+    } else if (command.is(CommandGetSchemas.class)) {\n+      return getFlightInfoSchemas(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetSchemas.class), context, descriptor);\n+    } else if (command.is(CommandGetTables.class)) {\n+      return getFlightInfoTables(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetTables.class), context, descriptor);\n+    } else if (command.is(CommandGetTableTypes.class)) {\n+      return getFlightInfoTableTypes(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetTableTypes.class), context, descriptor);\n+    } else if (command.is(CommandGetSqlInfo.class)) {\n+      return getFlightInfoSqlInfo(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetSqlInfo.class), context, descriptor);\n+    } else if (command.is(CommandGetPrimaryKeys.class)) {\n+      return getFlightInfoPrimaryKeys(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetPrimaryKeys.class), context, descriptor);\n+    } else if (command.is(CommandGetExportedKeys.class)) {\n+      return getFlightInfoExportedKeys(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetExportedKeys.class), context, descriptor);\n+    } else if (command.is(CommandGetImportedKeys.class)) {\n+      return getFlightInfoImportedKeys(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetImportedKeys.class), context, descriptor);\n+    }\n+\n+    throw Status.INVALID_ARGUMENT.asRuntimeException();\n+  }\n+\n+  /**\n+   * Returns the schema of the result produced by the SQL query.\n+   *\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return the result set schema.\n+   */\n+  @Override\n+  default SchemaResult getSchema(CallContext context, FlightDescriptor descriptor) {\n+    final Any command = FlightSqlUtils.parseOrThrow(descriptor.getCommand());\n+\n+    if (command.is(CommandStatementQuery.class)) {\n+      return getSchemaStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandStatementQuery.class), context, descriptor);\n+    } else if (command.is(CommandGetCatalogs.class)) {\n+      return getSchemaCatalogs();\n+    } else if (command.is(CommandGetSchemas.class)) {\n+      return getSchemaSchemas();\n+    } else if (command.is(CommandGetTables.class)) {\n+      return getSchemaTables();\n+    } else if (command.is(CommandGetTableTypes.class)) {\n+      return getSchemaTableTypes();\n+    } else if (command.is(CommandGetSqlInfo.class)) {\n+      return getSchemaSqlInfo();\n+    } else if (command.is(CommandGetPrimaryKeys.class)) {\n+      return getSchemaPrimaryKeys();\n+    } else if (command.is(CommandGetExportedKeys.class)) {\n+      return getSchemaForImportedAndExportedKeys();\n+    } else if (command.is(CommandGetImportedKeys.class)) {\n+      return getSchemaForImportedAndExportedKeys();\n+    }\n+\n+    throw Status.INVALID_ARGUMENT.asRuntimeException();\n+  }\n+\n+  /**\n+   * Depending on the provided command, method either:\n+   * 1. Return data for a stream produced by executing the provided SQL query, or\n+   * 2. Return data for a prepared statement. In this case, parameters binding is allowed.\n+   *\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  @Override\n+  default void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+    final Any command;\n+\n+    try {\n+      command = Any.parseFrom(ticket.getBytes());\n+    } catch (InvalidProtocolBufferException e) {\n+      listener.error(e);\n+      return;\n+    }\n+\n+    if (command.is(CommandStatementQuery.class)) {\n+      getStreamStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandStatementQuery.class), context, ticket, listener);\n+    } else if (command.is(CommandPreparedStatementQuery.class)) {\n+      getStreamPreparedStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandPreparedStatementQuery.class), context, ticket, listener);\n+    } else if (command.is(CommandGetCatalogs.class)) {\n+      getStreamCatalogs(context, ticket, listener);\n+    } else if (command.is(CommandGetSchemas.class)) {\n+      getStreamSchemas(FlightSqlUtils.unpackOrThrow(command, CommandGetSchemas.class), context, ticket, listener);\n+    } else if (command.is(CommandGetTables.class)) {\n+      getStreamTables(FlightSqlUtils.unpackOrThrow(command, CommandGetTables.class), context, ticket, listener);\n+    } else if (command.is(CommandGetTableTypes.class)) {\n+      getStreamTableTypes(context, ticket, listener);\n+    } else if (command.is(CommandGetSqlInfo.class)) {\n+      getStreamSqlInfo(FlightSqlUtils.unpackOrThrow(command, CommandGetSqlInfo.class), context, ticket, listener);\n+    } else if (command.is(CommandGetPrimaryKeys.class)) {\n+      getStreamPrimaryKeys(FlightSqlUtils.unpackOrThrow(command, CommandGetPrimaryKeys.class),\n+          context, ticket, listener);\n+    } else if (command.is(CommandGetExportedKeys.class)) {\n+      getStreamExportedKeys(FlightSqlUtils.unpackOrThrow(command, CommandGetExportedKeys.class),\n+          context, ticket, listener);\n+    } else if (command.is(CommandGetImportedKeys.class)) {\n+      getStreamImportedKeys(FlightSqlUtils.unpackOrThrow(command, CommandGetImportedKeys.class),\n+          context, ticket, listener);\n+    } else {\n+      throw Status.INVALID_ARGUMENT.asRuntimeException();\n+    }\n+  }\n+\n+  /**\n+   * Depending on the provided command, method either:\n+   * 1. Execute provided SQL query as an update statement, or\n+   * 2. Execute provided update SQL query prepared statement. In this case, parameters binding\n+   * is allowed, or\n+   * 3. Binds parameters to the provided prepared statement.\n+   *\n+   * @param context      Per-call context.\n+   * @param flightStream The data stream being uploaded.\n+   * @param ackStream    The data stream listener for update result acknowledgement.\n+   * @return a Runnable to process the stream.\n+   */\n+  @Override\n+  default Runnable acceptPut(CallContext context, FlightStream flightStream, StreamListener<PutResult> ackStream) {\n+    final Any command = FlightSqlUtils.parseOrThrow(flightStream.getDescriptor().getCommand());\n+\n+    if (command.is(CommandStatementUpdate.class)) {\n+      return acceptPutStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandStatementUpdate.class),\n+          context, flightStream, ackStream);\n+    } else if (command.is(CommandPreparedStatementUpdate.class)) {\n+      return acceptPutPreparedStatementUpdate(\n+          FlightSqlUtils.unpackOrThrow(command, CommandPreparedStatementUpdate.class),\n+          context, flightStream, ackStream);\n+    } else if (command.is(CommandPreparedStatementQuery.class)) {\n+      return acceptPutPreparedStatementQuery(\n+          FlightSqlUtils.unpackOrThrow(command, CommandPreparedStatementQuery.class),\n+          context, flightStream, ackStream);\n+    }\n+\n+    throw Status.INVALID_ARGUMENT.asRuntimeException();\n+  }\n+\n+  /**\n+   * Lists all available Flight SQL actions.\n+   *\n+   * @param context  Per-call context.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  @Override\n+  default void listActions(CallContext context, StreamListener<ActionType> listener) {\n+    FlightSqlUtils.FLIGHT_SQL_ACTIONS.forEach(listener::onNext);\n+    listener.onCompleted();\n+  }\n+\n+  /**\n+   * Performs the requested Flight SQL action.\n+   *\n+   * @param context  Per-call context.\n+   * @param action   Client-supplied parameters.\n+   * @param listener A stream of responses.\n+   */\n+  @Override\n+  default void doAction(CallContext context, Action action, StreamListener<Result> listener) {\n+    final String actionType = action.getType();\n+    if (actionType.equals(FlightSqlUtils.FLIGHT_SQL_CREATEPREPAREDSTATEMENT.getType())) {\n+      final ActionCreatePreparedStatementRequest request = FlightSqlUtils.unpackAndParseOrThrow(action.getBody(),\n+          ActionCreatePreparedStatementRequest.class);\n+      createPreparedStatement(request, context, listener);\n+    } else if (actionType.equals(FlightSqlUtils.FLIGHT_SQL_CLOSEPREPAREDSTATEMENT.getType())) {\n+      final ActionClosePreparedStatementRequest request = FlightSqlUtils.unpackAndParseOrThrow(action.getBody(),\n+          ActionClosePreparedStatementRequest.class);\n+      closePreparedStatement(request, context, listener);\n+    }\n+\n+    throw Status.INVALID_ARGUMENT.asRuntimeException();\n+  }\n+\n+  /**\n+   * Creates a prepared statement on the server and returns a handle and metadata for in a\n+   * {@link ActionCreatePreparedStatementResult} object in a {@link Result}\n+   * object.\n+   *\n+   * @param request  The sql command to generate the prepared statement.\n+   * @param context  Per-call context.\n+   * @param listener A stream of responses.\n+   */\n+  void createPreparedStatement(ActionCreatePreparedStatementRequest request, CallContext context,\n+                               StreamListener<Result> listener);\n+\n+  /**\n+   * Closes a prepared statement on the server. No result is expected.\n+   *\n+   * @param request  The sql command to generate the prepared statement.\n+   * @param context  Per-call context.\n+   * @param listener A stream of responses.\n+   */\n+  void closePreparedStatement(ActionClosePreparedStatementRequest request, CallContext context,\n+                              StreamListener<Result> listener);\n+\n+  /**\n+   * Gets information about a particular SQL query based data stream.\n+   *\n+   * @param command    The sql command to generate the data stream.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoStatement(CommandStatementQuery command, CallContext context,\n+                                    FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets information about a particular prepared statement data stream.\n+   *\n+   * @param command    The prepared statement to generate the data stream.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoPreparedStatement(CommandPreparedStatementQuery command,\n+                                            CallContext context, FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about a particular SQL query based data stream.\n+   *\n+   * @param command    The sql command to generate the data stream.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Schema for the stream.\n+   */\n+  SchemaResult getSchemaStatement(CommandStatementQuery command, CallContext context,\n+                                  FlightDescriptor descriptor);\n+\n+  /**\n+   * Returns data for a SQL query based data stream.\n+   *\n+   * @param command  The sql command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamStatement(CommandStatementQuery command, CallContext context, Ticket ticket,\n+                          ServerStreamListener listener);\n+\n+  /**\n+   * Returns data for a particular prepared statement query instance.\n+   *\n+   * @param command  The prepared statement to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamPreparedStatement(CommandPreparedStatementQuery command, CallContext context,\n+                                  Ticket ticket, ServerStreamListener listener);\n+\n+  /**\n+   * Accepts uploaded data for a particular SQL query based data stream.\n+   * <p>`PutResult`s must be in the form of a {@link DoPutUpdateResult}.\n+   *\n+   * @param command      The sql command to generate the data stream.\n+   * @param context      Per-call context.\n+   * @param flightStream The data stream being uploaded.\n+   * @param ackStream    The result data stream.\n+   * @return A runnable to process the stream.\n+   */\n+  Runnable acceptPutStatement(CommandStatementUpdate command, CallContext context,\n+                              FlightStream flightStream, StreamListener<PutResult> ackStream);\n+\n+  /**\n+   * Accepts uploaded data for a particular prepared statement data stream.\n+   * <p>`PutResult`s must be in the form of a {@link DoPutUpdateResult}.\n+   *\n+   * @param command      The prepared statement to generate the data stream.\n+   * @param context      Per-call context.\n+   * @param flightStream The data stream being uploaded.\n+   * @param ackStream    The result data stream.\n+   * @return A runnable to process the stream.\n+   */\n+  Runnable acceptPutPreparedStatementUpdate(CommandPreparedStatementUpdate command,\n+                                            CallContext context, FlightStream flightStream,\n+                                            StreamListener<PutResult> ackStream);\n+\n+  /**\n+   * Accepts uploaded parameter values for a particular prepared statement query.\n+   *\n+   * @param command      The prepared statement the parameter values will bind to.\n+   * @param context      Per-call context.\n+   * @param flightStream The data stream being uploaded.\n+   * @param ackStream    The result data stream.\n+   * @return A runnable to process the stream.\n+   */\n+  Runnable acceptPutPreparedStatementQuery(CommandPreparedStatementQuery command,\n+                                           CallContext context, FlightStream flightStream,\n+                                           StreamListener<PutResult> ackStream);\n+\n+  /**\n+   * Returns the SQL Info of the server by returning a\n+   * {@link CommandGetSqlInfo} in a {@link Result}.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoSqlInfo(CommandGetSqlInfo request, CallContext context,\n+                                  FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get SQL info data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaSqlInfo() {\n+    return new SchemaResult(Schemas.GET_SQL_INFO_SCHEMA);\n+  }\n+\n+  /**\n+   * Returns data for SQL info based data stream.\n+   *\n+   * @param command  The command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamSqlInfo(CommandGetSqlInfo command, CallContext context, Ticket ticket,\n+                        ServerStreamListener listener);\n+\n+  /**\n+   * Returns the available catalogs by returning a stream of\n+   * {@link CommandGetCatalogs} objects in {@link Result} objects.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoCatalogs(CommandGetCatalogs request, CallContext context,\n+                                   FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get catalogs data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaCatalogs() {\n+    return new SchemaResult(Schemas.GET_CATALOGS_SCHEMA);\n+  }\n+\n+  /**\n+   * Returns data for catalogs based data stream.\n+   *\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamCatalogs(CallContext context, Ticket ticket,\n+                         ServerStreamListener listener);\n+\n+  /**\n+   * Returns the available schemas by returning a stream of\n+   * {@link CommandGetSchemas} objects in {@link Result} objects.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoSchemas(CommandGetSchemas request, CallContext context,\n+                                  FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get schemas data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaSchemas() {\n+    return new SchemaResult(Schemas.GET_SCHEMAS_SCHEMA);\n+  }\n+\n+  /**\n+   * Returns data for schemas based data stream.\n+   *\n+   * @param command  The command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamSchemas(CommandGetSchemas command, CallContext context, Ticket ticket,\n+                        ServerStreamListener listener);\n+\n+  /**\n+   * Returns the available tables by returning a stream of\n+   * {@link CommandGetTables} objects in {@link Result} objects.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoTables(CommandGetTables request, CallContext context,\n+                                 FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get tables data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaTables() {\n+    return new SchemaResult(Schemas.GET_TABLES_SCHEMA);\n+  }\n+\n+  /**\n+   * Returns data for tables based data stream.\n+   *\n+   * @param command  The command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamTables(CommandGetTables command, CallContext context, Ticket ticket,\n+                       ServerStreamListener listener);\n+\n+  /**\n+   * Returns the available table types by returning a stream of\n+   * {@link CommandGetTableTypes} objects in {@link Result} objects.\n+   *\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoTableTypes(CommandGetTableTypes request, CallContext context,\n+                                     FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get table types data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaTableTypes() {\n+    return new SchemaResult(Schemas.GET_TABLE_TYPES_SCHEMA);\n+  }\n+\n+  /**\n+   * Returns data for table types based data stream.\n+   *\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamTableTypes(CallContext context, Ticket ticket, ServerStreamListener listener);\n+\n+  /**\n+   * Returns the available primary keys by returning a stream of\n+   * {@link CommandGetPrimaryKeys} objects in {@link Result} objects.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoPrimaryKeys(CommandGetPrimaryKeys request, CallContext context,\n+                                      FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get primary keys data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaPrimaryKeys() {\n+    final List<Field> fields = Arrays.asList(\n+        Field.nullable(\"catalog_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"schema_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"table_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"column_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"key_sequence\", MinorType.INT.getType()),\n+        Field.nullable(\"key_name\", MinorType.VARCHAR.getType()));\n+\n+    return new SchemaResult(new Schema(fields));\n+  }\n+\n+  /**\n+   * Returns data for primary keys based data stream.\n+   *\n+   * @param command  The command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamPrimaryKeys(CommandGetPrimaryKeys command, CallContext context, Ticket ticket,\n+                            ServerStreamListener listener);\n+\n+  /**\n+   * Retrieves a description of the foreign key columns that reference the given table's primary key columns\n+   * {@link CommandGetExportedKeys} objects in {@link Result} objects.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoExportedKeys(CommandGetExportedKeys request, CallContext context,\n+                                       FlightDescriptor descriptor);\n+\n+  /**\n+   * Retrieves a description of the primary key columns that are referenced by given table's foreign key columns\n+   * {@link CommandGetImportedKeys} objects in {@link Result} objects.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoImportedKeys(CommandGetImportedKeys request, CallContext context,\n+                                       FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get imported and exported keys data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaForImportedAndExportedKeys() {\n+    return new SchemaResult(Schemas.GET_IMPORTED_AND_EXPORTED_KEYS_SCHEMA);\n+  }\n+\n+  /**\n+   * Returns data for foreign keys based data stream.\n+   *\n+   * @param command  The command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamExportedKeys(CommandGetExportedKeys command, CallContext context, Ticket ticket,\n+                             ServerStreamListener listener);\n+\n+  /**\n+   * Returns data for foreign keys based data stream.\n+   *\n+   * @param command  The command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamImportedKeys(CommandGetImportedKeys command, CallContext context, Ticket ticket,\n+                             ServerStreamListener listener);\n+\n+  /**\n+   * Default schema templates for the {@link FlightSqlProducer}.\n+   */\n+  final class Schemas {\n+    public static final Schema GET_TABLES_SCHEMA = new Schema(Arrays.asList(\n+        Field.nullable(\"catalog_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"schema_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"table_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"table_type\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"table_schema\", MinorType.VARBINARY.getType())));\n+    public static final Schema GET_TABLES_SCHEMA_NO_SCHEMA = new Schema(Arrays.asList(\n+        Field.nullable(\"catalog_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"schema_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"table_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"table_type\", MinorType.VARCHAR.getType())));\n+    public static final Schema GET_CATALOGS_SCHEMA = new Schema(\n+        Collections.singletonList(new Field(\"catalog_name\", FieldType.nullable(MinorType.VARCHAR.getType()), null)));\n+    public static final Schema GET_TABLE_TYPES_SCHEMA =\n+        new Schema(Collections.singletonList(Field.nullable(\"table_type\", MinorType.VARCHAR.getType())));\n+    public static final Schema GET_SCHEMAS_SCHEMA = new Schema(\n+        Arrays.asList(Field.nullable(\"catalog_name\", MinorType.VARCHAR.getType()),\n+            Field.nullable(\"schema_name\", MinorType.VARCHAR.getType())));\n+    public static final Schema GET_IMPORTED_AND_EXPORTED_KEYS_SCHEMA = new Schema(Arrays.asList(\n+        Field.nullable(\"pk_catalog_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"pk_schema_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"pk_table_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"pk_column_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"fk_catalog_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"fk_schema_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"fk_table_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"fk_column_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"key_sequence\", MinorType.INT.getType()),\n+        Field.nullable(\"fk_key_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"pk_key_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"update_rule\", MinorType.INT.getType()),\n+        Field.nullable(\"delete_rule\", MinorType.INT.getType())));\n+    public static final Schema GET_SQL_INFO_SCHEMA =\n+        new Schema(Arrays.asList(\n+            Field.nullable(\"info_name\", MinorType.INT.getType()),\n+            new Field(\"value\",\n+                // dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+                new FieldType(true, new Union(UnionMode.Dense, new int[] {0, 1, 2, 3}), /*dictionary=*/null),\n+                Arrays.asList(\n+                    Field.nullable(\"string_value\", MinorType.VARCHAR.getType()),\n+                    Field.nullable(\"int_value\", MinorType.INT.getType()),\n+                    Field.nullable(\"bigint_value\", MinorType.BIGINT.getType()),\n+                    Field.nullable(\"int32_bitmask\", MinorType.INT.getType())))));\n+\n+    private Schemas() {\n+      // Prevent instantiation.\n+    }\n+  }\n+\n+  /**\n+   * Reserved options for the SQL command `GetSqlInfo` used by {@link FlightSqlProducer}.\n+   */\n+  final class SqlInfo {\n\nReview comment:\n       static final class with private constructor?\n\n##########\nFile path: java/flight/flight-sql/src/test/java/org/apache/arrow/flight/sql/StatementContext.java\n##########\n@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import java.io.Serializable;\n+import java.sql.Connection;\n+import java.sql.Statement;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.util.AutoCloseables;\n+import org.apache.arrow.util.Preconditions;\n+\n+/**\n+ * Context for {@link T} to be persisted in memory in between {@link FlightSqlProducer} calls.\n+ *\n+ * @param <T> the {@link Statement} to be persisted.\n+ */\n+public final class StatementContext<T extends Statement> implements AutoCloseable, Serializable {\n\nReview comment:\n       (Notably I don't think we should encourage use of Serializable.)\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlClient.java\n##########\n@@ -0,0 +1,504 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.SyncPutListener;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.StringValue;\n+\n+import io.grpc.Status;\n+\n+/**\n+ * Flight client with Flight SQL semantics.\n+ */\n+public class FlightSqlClient {\n+  private FlightClient client;\n+\n+  public FlightSqlClient(FlightClient client) {\n+    this.client = client;\n+  }\n+\n+  /**\n+   * Execute a query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo execute(String query) {\n+    final CommandStatementQuery.Builder builder = CommandStatementQuery.newBuilder();\n+    builder.setQuery(query);\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Execute an update query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public long executeUpdate(String query) {\n+    final CommandStatementUpdate.Builder builder = CommandStatementUpdate.newBuilder();\n+    builder.setQuery(query);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    final SyncPutListener putListener = new SyncPutListener();\n+    client.startPut(descriptor, VectorSchemaRoot.of(), putListener);\n+\n+    try {\n+      final PutResult read = putListener.read();\n+      try (final ArrowBuf metadata = read.getApplicationMetadata()) {\n+        final DoPutUpdateResult doPutUpdateResult = DoPutUpdateResult.parseFrom(metadata.nioBuffer());\n+        return doPutUpdateResult.getRecordCount();\n+      }\n+    } catch (InterruptedException | ExecutionException | InvalidProtocolBufferException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  /**\n+   * Request a list of catalogs.\n+   *\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getCatalogs() {\n+    final CommandGetCatalogs.Builder builder = CommandGetCatalogs.newBuilder();\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of schemas.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSchemas(final String catalog, final String schemaFilterPattern) {\n+    final CommandGetSchemas.Builder builder = CommandGetSchemas.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Get schema for a stream.\n+   *\n+   * @param descriptor The descriptor for the stream.\n+   * @param options    RPC-layer hints for this call.\n+   */\n+  public SchemaResult getSchema(FlightDescriptor descriptor, CallOption... options) {\n+    return this.client.getSchema(descriptor, options);\n+  }\n+\n+  /**\n+   * Retrieve a stream from the server.\n+   *\n+   * @param ticket  The ticket granting access to the data stream.\n+   * @param options RPC-layer hints for this call.\n+   */\n+  public FlightStream getStream(Ticket ticket, CallOption... options) {\n+    return this.client.getStream(ticket, options);\n+  }\n+\n+  /**\n+   * Request a set of Flight SQL metadata.\n+   *\n+   * @param info The set of metadata to retrieve. None to retrieve all metadata.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSqlInfo(final @Nullable int... info) {\n+    final CommandGetSqlInfo.Builder builder = CommandGetSqlInfo.newBuilder();\n+    for (final int pieceOfInfo : Objects.isNull(info) ? new int[0] : info) {\n+      builder.addInfo(pieceOfInfo);\n+    }\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of tables.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @param tableFilterPattern  The table filter pattern.\n+   * @param tableTypes          The table types to include.\n+   * @param includeSchema       True to include the schema upon return, false to not include the schema.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getTables(final @Nullable String catalog, final @Nullable String schemaFilterPattern,\n+                              final @Nullable String tableFilterPattern, final List<String> tableTypes,\n+                              final boolean includeSchema) {\n+    final CommandGetTables.Builder builder = CommandGetTables.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    if (tableFilterPattern != null) {\n+      builder.setTableNameFilterPattern(StringValue.newBuilder().setValue(tableFilterPattern).build());\n+    }\n+\n+    if (tableTypes != null) {\n+      builder.addAllTableTypes(tableTypes);\n+    }\n+    builder.setIncludeSchema(includeSchema);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request the primary keys for a table.\n+   *\n+   * @param catalog The catalog.\n+   * @param schema  The schema.\n+   * @param table   The table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getPrimaryKeys(final @Nullable String catalog, final @Nullable String schema,\n+                                   final @Nullable String table) {\n+    final CommandGetPrimaryKeys.Builder builder = CommandGetPrimaryKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    if (table != null) {\n+      builder.setTable(StringValue.newBuilder().setValue(table).build());\n+    }\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request to get info about keys on a table. The table, which exports the foreign keys, parameter must be specified.\n+   *\n+   * @param catalog The foreign key table catalog.\n+   * @param schema  The foreign key table schema.\n+   * @param table   The foreign key table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getExportedKeys(String catalog, String schema, String table) {\n+    if (null == table) {\n+      throw Status.INVALID_ARGUMENT.asRuntimeException();\n+    }\n+\n+    final CommandGetExportedKeys.Builder builder = CommandGetExportedKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    builder.setTable(table).build();\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request to get info about keys on a table. The table, which imports the foreign keys, parameter must be specified.\n+   *\n+   * @param catalog The primary key table catalog.\n+   * @param schema  The primary key table schema.\n+   * @param table   The primary key table.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getImportedKeys(String catalog, String schema, String table) {\n+    if (null == table) {\n+      throw Status.INVALID_ARGUMENT.asRuntimeException();\n+    }\n+\n+    final CommandGetImportedKeys.Builder builder = CommandGetImportedKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    builder.setTable(table).build();\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Request a list of table types.\n+   *\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getTableTypes() {\n+    final CommandGetTableTypes.Builder builder = CommandGetTableTypes.newBuilder();\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Create a prepared statement on the server.\n+   *\n+   * @param query The query to prepare.\n+   * @return The representation of the prepared statement which exists on the server.\n+   */\n+  public PreparedStatement prepare(String query) {\n+    return new PreparedStatement(client, query);\n+  }\n+\n+  /**\n+   * Helper class to encapsulate Flight SQL prepared statement logic.\n+   */\n+  public static class PreparedStatement implements Closeable {\n+    private final FlightClient client;\n+    private final ActionCreatePreparedStatementResult preparedStatementResult;\n+    private AtomicLong invocationCount;\n+    private boolean isClosed;\n+    private Schema resultSetSchema = null;\n+    private Schema parameterSchema = null;\n+    private VectorSchemaRoot parameterBindingRoot;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param client The client. FlightSqlPreparedStatement does not maintain this resource.\n+     * @param sql    The query.\n+     */\n+    public PreparedStatement(FlightClient client, String sql) {\n+      this.client = client;\n+\n+      final Iterator<Result> preparedStatementResults = client.doAction(new Action(\n+          FlightSqlUtils.FLIGHT_SQL_CREATEPREPAREDSTATEMENT.getType(),\n+          Any.pack(ActionCreatePreparedStatementRequest\n+              .newBuilder()\n+              .setQuery(sql)\n+              .build())\n+              .toByteArray()));\n+\n+      preparedStatementResult = FlightSqlUtils.unpackAndParseOrThrow(\n+          preparedStatementResults.next().getBody(),\n+          ActionCreatePreparedStatementResult.class);\n+\n+      invocationCount = new AtomicLong(0);\n+      isClosed = false;\n+    }\n+\n+    /**\n+     * Set the {@link VectorSchemaRoot} containing the parameter binding from a preparedStatemnt\n+     * operation.\n+     *\n+     * @param parameterBindingRoot  a {@link VectorSchemaRoot} object contain the values to be used in the\n+     *                              PreparedStatement setters.\n+     */\n+    public void setParameters(VectorSchemaRoot parameterBindingRoot) {\n+      this.parameterBindingRoot = parameterBindingRoot;\n+    }\n+\n+    /**\n+     * Empty the {@link VectorSchemaRoot} that contains the parameter binding from a preparedStatemnt\n+     * operation.\n+     *\n+     */\n+    public void clearParameters() {\n+      this.parameterBindingRoot = null;\n+    }\n+\n+    /**\n+     * Returns the Schema of the resultset.\n+     *\n+     * @return the Schema of the resultset.\n+     */\n+    public Schema getResultSetSchema() {\n+      if (resultSetSchema == null && preparedStatementResult.getDatasetSchema() != null) {\n+        resultSetSchema = Schema.deserialize(preparedStatementResult.getDatasetSchema().asReadOnlyByteBuffer());\n+      }\n+      return resultSetSchema;\n+    }\n+\n+    /**\n+     * Returns the Schema of the parameters.\n+     *\n+     * @return the Schema of the parameters.\n+     */\n+    public Schema getParameterSchema() {\n+      if (parameterSchema == null && preparedStatementResult.getParameterSchema() != null) {\n+        parameterSchema = Schema.deserialize(preparedStatementResult.getParameterSchema().asReadOnlyByteBuffer());\n+      }\n+      return parameterSchema;\n+    }\n+\n+    /**\n+     * Executes the prepared statement query on the server.\n+     *\n+     * @return a FlightInfo object representing the stream(s) to fetch.\n+     * @throws IOException if the PreparedStatement is closed.\n+     */\n+    public FlightInfo execute() throws IOException {\n+      if (isClosed) {\n+        throw new IllegalStateException(\"Prepared statement has already been closed on the server.\");\n+      }\n+\n+      final FlightDescriptor descriptor = FlightDescriptor\n+          .command(Any.pack(CommandPreparedStatementQuery.newBuilder()\n+              .setClientExecutionHandle(\n+                  ByteString.copyFrom(ByteBuffer.allocate(Long.BYTES).putLong(invocationCount.getAndIncrement())))\n+              .setPreparedStatementHandle(preparedStatementResult.getPreparedStatementHandle())\n+              .build())\n+              .toByteArray());\n+\n+      if (parameterBindingRoot != null) {\n+        final SyncPutListener putListener = new SyncPutListener();\n+\n+        FlightClient.ClientStreamListener listener =\n+            client.startPut(descriptor, this.parameterBindingRoot, putListener);\n+\n+        listener.putNext();\n+        listener.completed();\n+      }\n+\n+      return client.getInfo(descriptor);\n+    }\n+\n+    /**\n+     * Executes the prepared statement update on the server.\n+     */\n+    public long executeUpdate() throws SQLException {\n+      if (isClosed) {\n+        throw new IllegalStateException(\"Prepared statement has already been closed on the server.\");\n+      }\n+\n+      final FlightDescriptor descriptor = FlightDescriptor\n+          .command(Any.pack(FlightSql.CommandPreparedStatementUpdate.newBuilder()\n+              .setClientExecutionHandle(\n+                  ByteString.copyFrom(ByteBuffer.allocate(Long.BYTES).putLong(invocationCount.getAndIncrement())))\n+              .setPreparedStatementHandle(preparedStatementResult.getPreparedStatementHandle())\n+              .build())\n+              .toByteArray());\n+\n+      if (this.parameterBindingRoot == null) {\n+        this.parameterBindingRoot = VectorSchemaRoot.of();\n+      }\n+\n+      final SyncPutListener putListener = new SyncPutListener();\n+      final FlightClient.ClientStreamListener listener =\n+          client.startPut(descriptor, this.parameterBindingRoot, putListener);\n+\n+      listener.putNext();\n+      listener.completed();\n+\n+      try {\n+        final PutResult read = putListener.read();\n+        try (final ArrowBuf metadata = read.getApplicationMetadata()) {\n+          final FlightSql.DoPutUpdateResult doPutUpdateResult =\n+              FlightSql.DoPutUpdateResult.parseFrom(metadata.nioBuffer());\n+          return doPutUpdateResult.getRecordCount();\n+        }\n+      } catch (InterruptedException | InvalidProtocolBufferException | ExecutionException e) {\n+        throw new SQLException(e);\n\nReview comment:\n       We should be consistent about what exceptions we use. We don't use SQLException for anything else.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-11T14:13:46.261+0000",
                    "updated": "2021-08-11T14:13:46.261+0000",
                    "started": "2021-08-11T14:13:46.261+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "636912",
                    "issueId": "13381560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/637012",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906#issuecomment-897022411\n\n\n   I might have missed this, but lets add some comments that this experimental.  i think for formal adoption of this protocol, we likely need an implementation in C++ and then a vote on the mailing list.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-11T17:42:53.589+0000",
                    "updated": "2021-08-11T17:42:53.589+0000",
                    "started": "2021-08-11T17:42:53.589+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637012",
                    "issueId": "13381560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/637019",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kylepbit commented on pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906#issuecomment-897028974\n\n\n   @emkornfield - Updated the PR description indicating this is experimental, let me know if that's enough.\r\n   @lidavidm - Working with team to address items you raised.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-11T17:53:01.361+0000",
                    "updated": "2021-08-11T17:53:01.361+0000",
                    "started": "2021-08-11T17:53:01.361+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637019",
                    "issueId": "13381560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/637032",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906#issuecomment-897041048\n\n\n   Sorry, I think we should clarify in the proto file itself as well (assuming we want this to be merged before the other necessities for formal adoption are ready).\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-11T18:10:20.926+0000",
                    "updated": "2021-08-11T18:10:20.926+0000",
                    "started": "2021-08-11T18:10:20.926+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637032",
                    "issueId": "13381560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/637040",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kylepbit commented on pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906#issuecomment-897051130\n\n\n   Ah - thanks @emkornfield - do you have an example, or did you just want the proto file to say experimental somewhere?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-11T18:24:37.335+0000",
                    "updated": "2021-08-11T18:24:37.335+0000",
                    "started": "2021-08-11T18:24:37.335+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637040",
                    "issueId": "13381560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/637054",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906#issuecomment-897057181\n\n\n   Probably the best thing to do would be to create our [own custom option](https://developers.google.com/protocol-buffers/docs/proto3#customoptions) for annotating items as experimental and use that for all the types.  If that is too much work, then I think just something in the proto file is fine for now.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-11T18:34:06.055+0000",
                    "updated": "2021-08-11T18:34:06.055+0000",
                    "started": "2021-08-11T18:34:06.055+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637054",
                    "issueId": "13381560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/637063",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kylepbit commented on a change in pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906#discussion_r687085264\n\n\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: int32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Ragne [500-1000)\n+   * Range [0-100000) is reserved for defaults. Custom options should start at 100000.\n\nReview comment:\n       It was switched in consideration of performance, given that there could be 1-200 of these. I assume by namespacing you refer to the prefix to differentation areas of metadata? What are you thinking of for the `oneof` solution?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-11T18:44:30.663+0000",
                    "updated": "2021-08-11T18:44:30.663+0000",
                    "started": "2021-08-11T18:44:30.663+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637063",
                    "issueId": "13381560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/637083",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906#discussion_r687108209\n\n\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: int32,\n\nReview comment:\n       ```suggestion\r\n    *  info_name: uint32,\r\n   ```\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: int32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Ragne [500-1000)\n+   * Range [0-100000) is reserved for defaults. Custom options should start at 100000.\n\nReview comment:\n       I started writing something but I realized I hadn't fully thought it through. (I was going to suggest separate fields on the request message side but you'd still have to deal with separating them in the response.) I think this is ok\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: int32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Ragne [500-1000)\n\nReview comment:\n       ```suggestion\r\n      * - Syntax Information - Range [500-1000)\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-11T19:27:21.777+0000",
                    "updated": "2021-08-11T19:27:21.777+0000",
                    "started": "2021-08-11T19:27:21.777+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637083",
                    "issueId": "13381560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/637094",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vfraga commented on a change in pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906#discussion_r687145949\n\n\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: int32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Ragne [500-1000)\n+   * Range [0-100000) is reserved for defaults. Custom options should start at 100000.\n+   *\n+   * 1. Server Information [0-500): Provides basic information about the Flight SQL Server.\n+   *\n+   * The name of the Flight SQL Server.\n+   * 0 = FLIGHT_SQL_SERVER_NAME\n+   *\n+   * The native version of the Flight SQL Server.\n+   * 1 = FLIGHT_SQL_SERVER_VERSION\n+   *\n+   * The Arrow format version of the Flight SQL Server.\n+   * 2 = FLIGHT_SQL_SERVER_ARROW_VERSION\n+   *\n+   * Indicates whether the Flight SQL Server is read only.\n+   * 3 = FLIGHT_SQL_SERVER_READ_ONLY\n+   *\n+   * 2. SQL Syntax Information [500-1000): provides information about SQL syntax supported by the Flight SQL Server.\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of catalogs.\n+   * In a SQL environment, a catalog is a collection of schemas.\n+   * 500 = SQL_DDL_CATALOG\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of schemas.\n+   * In a SQL environment, a catalog is a collection of tables, views, indexes etc.\n+   * 501 = SQL_DDL_SCHEMA\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of tables.\n+   * In a SQL environment, a table is a collection of rows of information. Each row of information\n+   * may have one or more columns of data.\n+   * 502 = SQL_DDL_TABLE\n+   *\n+   * Indicates the case sensitivity of catalog, table and schema names.\n+   * 503 = SQL_IDENTIFIER_CASE\n+   *\n+   * Indicates the supported character(s) used to surround a delimited identifier.\n+   * 504 = SQL_IDENTIFIER_QUOTE_CHAR\n+   *\n+   * Indicates case sensitivity of quoted identifiers.\n+   * 505 = SQL_QUOTED_IDENTIFIER_CASE\n+   *\n+   * If omitted, then all metadata will be retrieved.\n+   * Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must\n+   * at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved.\n+   * If additional metadata is included, the metadata IDs should start from 10,000.\n+   */\n+  repeated uint32 info = 1;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of catalogs on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name.\n+ */\n+message CommandGetCatalogs {\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of schemas on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, then schema_name.\n+ */\n+message CommandGetSchemas {\n+  /*\n+   * Specifies the Catalog to search for schemas.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, the pattern will not be used to narrow the search.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of tables, and optionally their schemas, on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  table_type: utf8,\n+ *  table_schema: bytes\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, then table_type.\n+ */\n+message CommandGetTables {\n+  /*\n+   * Specifies the Catalog to search for the tables.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, all schemas matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+\n+  /*\n+   * Specifies a filter pattern for tables to search for.\n+   * When no table_name_filter_pattern is provided, all tables matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue table_name_filter_pattern = 3;\n+\n+  // Specifies a filter of table types which must match.\n+  repeated string table_types = 4;\n+\n+  // Specifies if the schema should be returned for found tables.\n+  bool include_schema = 5;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of table types on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  table_type: utf8\n+ * >\n+ * The returned data should be ordered by table_type.\n+ */\n+message CommandGetTableTypes {\n+}\n+\n+/*\n+ * Represents a request to retrieve the primary keys of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  column_name: utf8,\n+ *  key_sequence: int,\n+ *  key_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n+ */\n+message CommandGetPrimaryKeys {\n+  // Specifies the catalog to search for the table.\n+  google.protobuf.StringValue catalog = 1;\n+\n+  // Specifies the schema to search for the table.\n+  google.protobuf.StringValue schema = 2;\n+\n+  // Specifies the table to get the primary keys for.\n+  google.protobuf.StringValue table = 3;\n+}\n+\n+/*\n+ * Represents a request to retrieve a description of the foreign key columns that reference the given table's\n+ * primary key columns (the foreign keys exported by a table) of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  pk_catalog_name: utf8,\n+ *  pk_schema_name: utf8,\n+ *  pk_table_name: utf8,\n+ *  pk_column_name: utf8,\n+ *  fk_catalog_name: utf8,\n+ *  fk_schema_name: utf8,\n+ *  fk_table_name: utf8,\n+ *  fk_column_name: utf8,\n+ *  key_sequence: int,\n+ *  fk_key_name: utf8,\n+ *  pk_key_name: utf8,\n+ *  update_rule: int,\n+ *  delete_rule: int\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n+ */\n+message CommandGetExportedKeys {\n+  // Specifies the catalog to search for the foreign key table.\n+  google.protobuf.StringValue catalog = 1;\n+\n+  // Specifies the schema to search for the foreign key table.\n+  google.protobuf.StringValue schema = 2;\n+\n+  // Specifies the foreign key table to get the foreign keys for.\n+  string table = 3;\n+}\n+\n+/*\n+ * Represents a request to retrieve the foreign keys of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  pk_catalog_name: utf8,\n+ *  pk_schema_name: utf8,\n+ *  pk_table_name: utf8,\n+ *  pk_column_name: utf8,\n+ *  fk_catalog_name: utf8,\n+ *  fk_schema_name: utf8,\n+ *  fk_table_name: utf8,\n+ *  fk_column_name: utf8,\n+ *  key_sequence: int,\n+ *  fk_key_name: utf8,\n+ *  pk_key_name: utf8,\n+ *  update_rule: int,\n+ *  delete_rule: int\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n+ */\n+message CommandGetImportedKeys {\n+  // Specifies the catalog to search for the primary key table.\n+  google.protobuf.StringValue catalog = 1;\n+\n+  // Specifies the schema to search for the primary key table.\n+  google.protobuf.StringValue schema = 2;\n+\n+  // Specifies the primary key table to get the foreign keys for.\n+  string table = 3;\n+}\n+\n+// SQL Execution Action Messages\n+\n+/*\n+ * Request message for the \"GetPreparedStatement\" action on a Flight SQL enabled backend.\n+ */\n+message ActionCreatePreparedStatementRequest {\n+  // The valid SQL string to create a prepared statement for.\n+  string query = 1;\n+}\n+\n+/*\n+ * Wrap the result of a \"GetPreparedStatement\" action.\n+ */\n+message ActionCreatePreparedStatementResult {\n+  // Opaque handle for the prepared statement on the server.\n+  bytes prepared_statement_handle = 1;\n+\n+  // If a result set generating query was provided, dataset_schema contains the \n+  // schema of the dataset as described in Schema.fbs::Schema, it is serialized as an IPC message.\n+  bytes dataset_schema = 2;\n+\n+  // If the query provided contained parameters, parameter_schema contains the \n+  // Schema of the expected parameters as described in Schema.fbs::Schema.\n+  bytes parameter_schema = 3;\n+}\n+\n+/*\n+ * Request message for the \"ClosePreparedStatement\" action on a Flight SQL enabled backend.\n+ * Closes server resources associated with the prepared statement handle.\n+ */\n+message ActionClosePreparedStatementRequest {\n+  // Opaque handle for the prepared statement on the server.\n+  bytes prepared_statement_handle = 1;\n+}\n+\n+\n+// SQL Execution Messages.\n+\n+/*\n+ * Represents a SQL query. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the query.\n+ */\n+message CommandStatementQuery {\n+  // The SQL syntax.\n+  string query = 1;\n+\n+  // Unique identifier for the instance of the prepared statement to execute.\n+  bytes client_execution_handle = 2;\n+}\n+\n\nReview comment:\n       No. We're still able to execute without it, take a look at CommandStatementQuery.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-11T20:07:23.609+0000",
                    "updated": "2021-08-11T20:07:23.609+0000",
                    "started": "2021-08-11T20:07:23.608+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637094",
                    "issueId": "13381560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/637095",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906#discussion_r687149137\n\n\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: int32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Ragne [500-1000)\n+   * Range [0-100000) is reserved for defaults. Custom options should start at 100000.\n+   *\n+   * 1. Server Information [0-500): Provides basic information about the Flight SQL Server.\n+   *\n+   * The name of the Flight SQL Server.\n+   * 0 = FLIGHT_SQL_SERVER_NAME\n+   *\n+   * The native version of the Flight SQL Server.\n+   * 1 = FLIGHT_SQL_SERVER_VERSION\n+   *\n+   * The Arrow format version of the Flight SQL Server.\n+   * 2 = FLIGHT_SQL_SERVER_ARROW_VERSION\n+   *\n+   * Indicates whether the Flight SQL Server is read only.\n+   * 3 = FLIGHT_SQL_SERVER_READ_ONLY\n+   *\n+   * 2. SQL Syntax Information [500-1000): provides information about SQL syntax supported by the Flight SQL Server.\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of catalogs.\n+   * In a SQL environment, a catalog is a collection of schemas.\n+   * 500 = SQL_DDL_CATALOG\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of schemas.\n+   * In a SQL environment, a catalog is a collection of tables, views, indexes etc.\n+   * 501 = SQL_DDL_SCHEMA\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of tables.\n+   * In a SQL environment, a table is a collection of rows of information. Each row of information\n+   * may have one or more columns of data.\n+   * 502 = SQL_DDL_TABLE\n+   *\n+   * Indicates the case sensitivity of catalog, table and schema names.\n+   * 503 = SQL_IDENTIFIER_CASE\n+   *\n+   * Indicates the supported character(s) used to surround a delimited identifier.\n+   * 504 = SQL_IDENTIFIER_QUOTE_CHAR\n+   *\n+   * Indicates case sensitivity of quoted identifiers.\n+   * 505 = SQL_QUOTED_IDENTIFIER_CASE\n+   *\n+   * If omitted, then all metadata will be retrieved.\n+   * Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must\n+   * at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved.\n+   * If additional metadata is included, the metadata IDs should start from 10,000.\n+   */\n+  repeated uint32 info = 1;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of catalogs on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name.\n+ */\n+message CommandGetCatalogs {\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of schemas on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, then schema_name.\n+ */\n+message CommandGetSchemas {\n+  /*\n+   * Specifies the Catalog to search for schemas.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, the pattern will not be used to narrow the search.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of tables, and optionally their schemas, on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  table_type: utf8,\n+ *  table_schema: bytes\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, then table_type.\n+ */\n+message CommandGetTables {\n+  /*\n+   * Specifies the Catalog to search for the tables.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, all schemas matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+\n+  /*\n+   * Specifies a filter pattern for tables to search for.\n+   * When no table_name_filter_pattern is provided, all tables matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue table_name_filter_pattern = 3;\n+\n+  // Specifies a filter of table types which must match.\n+  repeated string table_types = 4;\n+\n+  // Specifies if the schema should be returned for found tables.\n+  bool include_schema = 5;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of table types on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  table_type: utf8\n+ * >\n+ * The returned data should be ordered by table_type.\n+ */\n+message CommandGetTableTypes {\n+}\n+\n+/*\n+ * Represents a request to retrieve the primary keys of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  column_name: utf8,\n+ *  key_sequence: int,\n+ *  key_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n+ */\n+message CommandGetPrimaryKeys {\n+  // Specifies the catalog to search for the table.\n+  google.protobuf.StringValue catalog = 1;\n+\n+  // Specifies the schema to search for the table.\n+  google.protobuf.StringValue schema = 2;\n+\n+  // Specifies the table to get the primary keys for.\n+  google.protobuf.StringValue table = 3;\n+}\n+\n+/*\n+ * Represents a request to retrieve a description of the foreign key columns that reference the given table's\n+ * primary key columns (the foreign keys exported by a table) of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  pk_catalog_name: utf8,\n+ *  pk_schema_name: utf8,\n+ *  pk_table_name: utf8,\n+ *  pk_column_name: utf8,\n+ *  fk_catalog_name: utf8,\n+ *  fk_schema_name: utf8,\n+ *  fk_table_name: utf8,\n+ *  fk_column_name: utf8,\n+ *  key_sequence: int,\n+ *  fk_key_name: utf8,\n+ *  pk_key_name: utf8,\n+ *  update_rule: int,\n+ *  delete_rule: int\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n+ */\n+message CommandGetExportedKeys {\n+  // Specifies the catalog to search for the foreign key table.\n+  google.protobuf.StringValue catalog = 1;\n+\n+  // Specifies the schema to search for the foreign key table.\n+  google.protobuf.StringValue schema = 2;\n+\n+  // Specifies the foreign key table to get the foreign keys for.\n+  string table = 3;\n+}\n+\n+/*\n+ * Represents a request to retrieve the foreign keys of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  pk_catalog_name: utf8,\n+ *  pk_schema_name: utf8,\n+ *  pk_table_name: utf8,\n+ *  pk_column_name: utf8,\n+ *  fk_catalog_name: utf8,\n+ *  fk_schema_name: utf8,\n+ *  fk_table_name: utf8,\n+ *  fk_column_name: utf8,\n+ *  key_sequence: int,\n+ *  fk_key_name: utf8,\n+ *  pk_key_name: utf8,\n+ *  update_rule: int,\n+ *  delete_rule: int\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n+ */\n+message CommandGetImportedKeys {\n+  // Specifies the catalog to search for the primary key table.\n+  google.protobuf.StringValue catalog = 1;\n+\n+  // Specifies the schema to search for the primary key table.\n+  google.protobuf.StringValue schema = 2;\n+\n+  // Specifies the primary key table to get the foreign keys for.\n+  string table = 3;\n+}\n+\n+// SQL Execution Action Messages\n+\n+/*\n+ * Request message for the \"GetPreparedStatement\" action on a Flight SQL enabled backend.\n+ */\n+message ActionCreatePreparedStatementRequest {\n+  // The valid SQL string to create a prepared statement for.\n+  string query = 1;\n+}\n+\n+/*\n+ * Wrap the result of a \"GetPreparedStatement\" action.\n+ */\n+message ActionCreatePreparedStatementResult {\n+  // Opaque handle for the prepared statement on the server.\n+  bytes prepared_statement_handle = 1;\n+\n+  // If a result set generating query was provided, dataset_schema contains the \n+  // schema of the dataset as described in Schema.fbs::Schema, it is serialized as an IPC message.\n+  bytes dataset_schema = 2;\n+\n+  // If the query provided contained parameters, parameter_schema contains the \n+  // Schema of the expected parameters as described in Schema.fbs::Schema.\n+  bytes parameter_schema = 3;\n+}\n+\n+/*\n+ * Request message for the \"ClosePreparedStatement\" action on a Flight SQL enabled backend.\n+ * Closes server resources associated with the prepared statement handle.\n+ */\n+message ActionClosePreparedStatementRequest {\n+  // Opaque handle for the prepared statement on the server.\n+  bytes prepared_statement_handle = 1;\n+}\n+\n+\n+// SQL Execution Messages.\n+\n+/*\n+ * Represents a SQL query. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the query.\n+ */\n+message CommandStatementQuery {\n+  // The SQL syntax.\n+  string query = 1;\n+\n+  // Unique identifier for the instance of the prepared statement to execute.\n+  bytes client_execution_handle = 2;\n+}\n+\n\nReview comment:\n       What's the purpose of the client_execution_handle member there then? I notice the client code doesn't use it.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-11T20:10:37.455+0000",
                    "updated": "2021-08-11T20:10:37.455+0000",
                    "started": "2021-08-11T20:10:37.455+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637095",
                    "issueId": "13381560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/637110",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vfraga commented on a change in pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906#discussion_r687168849\n\n\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlClient.java\n##########\n@@ -0,0 +1,504 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.SyncPutListener;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.StringValue;\n+\n+import io.grpc.Status;\n+\n+/**\n+ * Flight client with Flight SQL semantics.\n+ */\n+public class FlightSqlClient {\n+  private FlightClient client;\n+\n+  public FlightSqlClient(FlightClient client) {\n+    this.client = client;\n+  }\n+\n+  /**\n+   * Execute a query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo execute(String query) {\n+    final CommandStatementQuery.Builder builder = CommandStatementQuery.newBuilder();\n+    builder.setQuery(query);\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Execute an update query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public long executeUpdate(String query) {\n+    final CommandStatementUpdate.Builder builder = CommandStatementUpdate.newBuilder();\n+    builder.setQuery(query);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    final SyncPutListener putListener = new SyncPutListener();\n+    client.startPut(descriptor, VectorSchemaRoot.of(), putListener);\n+\n+    try {\n+      final PutResult read = putListener.read();\n+      try (final ArrowBuf metadata = read.getApplicationMetadata()) {\n+        final DoPutUpdateResult doPutUpdateResult = DoPutUpdateResult.parseFrom(metadata.nioBuffer());\n+        return doPutUpdateResult.getRecordCount();\n+      }\n+    } catch (InterruptedException | ExecutionException | InvalidProtocolBufferException e) {\n\nReview comment:\n       This InterruptedException is already being handled by the ResultSet so that it can close graciously.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-11T20:29:49.157+0000",
                    "updated": "2021-08-11T20:29:49.157+0000",
                    "started": "2021-08-11T20:29:49.157+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637110",
                    "issueId": "13381560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/637112",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906#discussion_r687169846\n\n\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlClient.java\n##########\n@@ -0,0 +1,504 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.SyncPutListener;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.StringValue;\n+\n+import io.grpc.Status;\n+\n+/**\n+ * Flight client with Flight SQL semantics.\n+ */\n+public class FlightSqlClient {\n+  private FlightClient client;\n+\n+  public FlightSqlClient(FlightClient client) {\n+    this.client = client;\n+  }\n+\n+  /**\n+   * Execute a query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo execute(String query) {\n+    final CommandStatementQuery.Builder builder = CommandStatementQuery.newBuilder();\n+    builder.setQuery(query);\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Execute an update query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public long executeUpdate(String query) {\n+    final CommandStatementUpdate.Builder builder = CommandStatementUpdate.newBuilder();\n+    builder.setQuery(query);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    final SyncPutListener putListener = new SyncPutListener();\n+    client.startPut(descriptor, VectorSchemaRoot.of(), putListener);\n+\n+    try {\n+      final PutResult read = putListener.read();\n+      try (final ArrowBuf metadata = read.getApplicationMetadata()) {\n+        final DoPutUpdateResult doPutUpdateResult = DoPutUpdateResult.parseFrom(metadata.nioBuffer());\n+        return doPutUpdateResult.getRecordCount();\n+      }\n+    } catch (InterruptedException | ExecutionException | InvalidProtocolBufferException e) {\n\nReview comment:\n       I think it comes from SyncPutListener though: https://github.com/apache/arrow/blob/4fa983281bdabc3d6eb78b23261809e2b245b4f2/java/flight/flight-core/src/main/java/org/apache/arrow/flight/SyncPutListener.java#L63\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-11T20:31:15.854+0000",
                    "updated": "2021-08-11T20:31:15.854+0000",
                    "started": "2021-08-11T20:31:15.854+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637112",
                    "issueId": "13381560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/637121",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vfraga commented on a change in pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906#discussion_r687168849\n\n\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlClient.java\n##########\n@@ -0,0 +1,504 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.SyncPutListener;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.StringValue;\n+\n+import io.grpc.Status;\n+\n+/**\n+ * Flight client with Flight SQL semantics.\n+ */\n+public class FlightSqlClient {\n+  private FlightClient client;\n+\n+  public FlightSqlClient(FlightClient client) {\n+    this.client = client;\n+  }\n+\n+  /**\n+   * Execute a query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo execute(String query) {\n+    final CommandStatementQuery.Builder builder = CommandStatementQuery.newBuilder();\n+    builder.setQuery(query);\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor);\n+  }\n+\n+  /**\n+   * Execute an update query on the server.\n+   *\n+   * @param query The query to execute.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public long executeUpdate(String query) {\n+    final CommandStatementUpdate.Builder builder = CommandStatementUpdate.newBuilder();\n+    builder.setQuery(query);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    final SyncPutListener putListener = new SyncPutListener();\n+    client.startPut(descriptor, VectorSchemaRoot.of(), putListener);\n+\n+    try {\n+      final PutResult read = putListener.read();\n+      try (final ArrowBuf metadata = read.getApplicationMetadata()) {\n+        final DoPutUpdateResult doPutUpdateResult = DoPutUpdateResult.parseFrom(metadata.nioBuffer());\n+        return doPutUpdateResult.getRecordCount();\n+      }\n+    } catch (InterruptedException | ExecutionException | InvalidProtocolBufferException e) {\n\nReview comment:\n       This InterruptedException is already being handled by the ResultSet so that it can close graciously.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-11T20:49:13.570+0000",
                    "updated": "2021-08-11T20:49:13.570+0000",
                    "started": "2021-08-11T20:49:13.570+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637121",
                    "issueId": "13381560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/638784",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kylepbit commented on a change in pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906#discussion_r690597459\n\n\n\n##########\nFile path: java/flight/flight-sql/src/test/java/org/apache/arrow/flight/TestFlightSql.java\n##########\n@@ -0,0 +1,653 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.isNull;\n+import static org.apache.arrow.util.AutoCloseables.close;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.Reader;\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+import java.util.stream.IntStream;\n+\n+import org.apache.arrow.flight.sql.FlightSqlClient;\n+import org.apache.arrow.flight.sql.FlightSqlClient.PreparedStatement;\n+import org.apache.arrow.flight.sql.FlightSqlExample;\n+import org.apache.arrow.flight.sql.FlightSqlProducer;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.complex.DenseUnionVector;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.apache.arrow.vector.util.Text;\n+import org.hamcrest.Matcher;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ErrorCollector;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Test direct usage of Flight SQL workflows.\n+ */\n+public class TestFlightSql {\n\nReview comment:\n       @lidavidm - Derby was chosen to give us a more fully-fledged backend, which could be reused for implementation of the upcoming JDBC driver.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-17T17:54:49.801+0000",
                    "updated": "2021-08-17T17:54:49.801+0000",
                    "started": "2021-08-17T17:54:49.801+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638784",
                    "issueId": "13381560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/638821",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906#discussion_r690626507\n\n\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlClient.java\n##########\n@@ -0,0 +1,567 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.CallStatus;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.SyncPutListener;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.StringValue;\n+\n+/**\n+ * Flight client with Flight SQL semantics.\n+ */\n+public class FlightSqlClient {\n+  private final FlightClient client;\n+\n+  public FlightSqlClient(final FlightClient client) {\n+    this.client = Objects.requireNonNull(client, \"Client cannot be null!\");\n+  }\n+\n+  /**\n+   * Execute a query on the server.\n+   *\n+   * @param query   The query to execute.\n+   * @param options RPC-layer hints for this call.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo execute(final String query, final CallOption... options) {\n+    final CommandStatementQuery.Builder builder = CommandStatementQuery.newBuilder();\n+    builder.setQuery(query);\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor, options);\n+  }\n+\n+  /**\n+   * Execute an update query on the server.\n+   *\n+   * @param query   The query to execute.\n+   * @param options RPC-layer hints for this call.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public long executeUpdate(final String query, final CallOption... options) {\n+    final CommandStatementUpdate.Builder builder = CommandStatementUpdate.newBuilder();\n+    builder.setQuery(query);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    final SyncPutListener putListener = new SyncPutListener();\n+    client.startPut(descriptor, VectorSchemaRoot.of(), putListener, options);\n+\n+    try {\n+      final PutResult read = putListener.read();\n+      try (final ArrowBuf metadata = read.getApplicationMetadata()) {\n+        final DoPutUpdateResult doPutUpdateResult = DoPutUpdateResult.parseFrom(metadata.nioBuffer());\n+        return doPutUpdateResult.getRecordCount();\n+      }\n+    } catch (final InterruptedException | ExecutionException e) {\n+      throw CallStatus.CANCELLED.withCause(e).toRuntimeException();\n+    } catch (final InvalidProtocolBufferException e) {\n+      throw CallStatus.INVALID_ARGUMENT.withCause(e).toRuntimeException();\n\nReview comment:\n       nit: this seems more like `INTERNAL` since the server sent the wrong/an invalid Protobuf\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: int32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Ragne [500-1000)\n+   * Range [0-100000) is reserved for defaults. Custom options should start at 100000.\n+   *\n+   * 1. Server Information [0-500): Provides basic information about the Flight SQL Server.\n+   *\n+   * The name of the Flight SQL Server.\n+   * 0 = FLIGHT_SQL_SERVER_NAME\n+   *\n+   * The native version of the Flight SQL Server.\n+   * 1 = FLIGHT_SQL_SERVER_VERSION\n+   *\n+   * The Arrow format version of the Flight SQL Server.\n+   * 2 = FLIGHT_SQL_SERVER_ARROW_VERSION\n+   *\n+   * Indicates whether the Flight SQL Server is read only.\n+   * 3 = FLIGHT_SQL_SERVER_READ_ONLY\n+   *\n+   * 2. SQL Syntax Information [500-1000): provides information about SQL syntax supported by the Flight SQL Server.\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of catalogs.\n+   * In a SQL environment, a catalog is a collection of schemas.\n+   * 500 = SQL_DDL_CATALOG\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of schemas.\n+   * In a SQL environment, a catalog is a collection of tables, views, indexes etc.\n+   * 501 = SQL_DDL_SCHEMA\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of tables.\n+   * In a SQL environment, a table is a collection of rows of information. Each row of information\n+   * may have one or more columns of data.\n+   * 502 = SQL_DDL_TABLE\n+   *\n+   * Indicates the case sensitivity of catalog, table and schema names.\n+   * 503 = SQL_IDENTIFIER_CASE\n+   *\n+   * Indicates the supported character(s) used to surround a delimited identifier.\n+   * 504 = SQL_IDENTIFIER_QUOTE_CHAR\n+   *\n+   * Indicates case sensitivity of quoted identifiers.\n+   * 505 = SQL_QUOTED_IDENTIFIER_CASE\n+   *\n+   * If omitted, then all metadata will be retrieved.\n+   * Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must\n+   * at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved.\n+   * If additional metadata is included, the metadata IDs should start from 10,000.\n+   */\n+  repeated uint32 info = 1;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of catalogs on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name.\n+ */\n+message CommandGetCatalogs {\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of schemas on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, then schema_name.\n+ */\n+message CommandGetSchemas {\n+  /*\n+   * Specifies the Catalog to search for schemas.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, the pattern will not be used to narrow the search.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of tables, and optionally their schemas, on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  table_type: utf8,\n+ *  table_schema: bytes\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, then table_type.\n+ */\n+message CommandGetTables {\n+  /*\n+   * Specifies the Catalog to search for the tables.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, all schemas matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+\n+  /*\n+   * Specifies a filter pattern for tables to search for.\n+   * When no table_name_filter_pattern is provided, all tables matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue table_name_filter_pattern = 3;\n+\n+  // Specifies a filter of table types which must match.\n+  repeated string table_types = 4;\n+\n+  // Specifies if the schema should be returned for found tables.\n+  bool include_schema = 5;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of table types on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  table_type: utf8\n+ * >\n+ * The returned data should be ordered by table_type.\n+ */\n+message CommandGetTableTypes {\n+}\n+\n+/*\n+ * Represents a request to retrieve the primary keys of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  column_name: utf8,\n+ *  key_sequence: int,\n+ *  key_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n\nReview comment:\n       Do we want to order by column_name?\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlProducer.java\n##########\n@@ -0,0 +1,720 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.ActionType;\n+import org.apache.arrow.flight.CallStatus;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightProducer;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementUpdate;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.UnionMode;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.ArrowType.Union;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+\n+/**\n+ * API to Implement an Arrow Flight SQL producer.\n+ */\n+public interface FlightSqlProducer extends FlightProducer, AutoCloseable {\n+  /**\n+   * Depending on the provided command, method either:\n+   * 1. Return information about a SQL query, or\n+   * 2. Return information about a prepared statement. In this case, parameters binding is allowed.\n+   *\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return information about the given SQL query, or the given prepared statement.\n+   */\n+  @Override\n+  default FlightInfo getFlightInfo(CallContext context, FlightDescriptor descriptor) {\n+    final Any command = FlightSqlUtils.parseOrThrow(descriptor.getCommand());\n+\n+    if (command.is(CommandStatementQuery.class)) {\n+      return getFlightInfoStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandStatementQuery.class), context, descriptor);\n+    } else if (command.is(CommandPreparedStatementQuery.class)) {\n+      return getFlightInfoPreparedStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandPreparedStatementQuery.class), context, descriptor);\n+    } else if (command.is(CommandGetCatalogs.class)) {\n+      return getFlightInfoCatalogs(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetCatalogs.class), context, descriptor);\n+    } else if (command.is(CommandGetSchemas.class)) {\n+      return getFlightInfoSchemas(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetSchemas.class), context, descriptor);\n+    } else if (command.is(CommandGetTables.class)) {\n+      return getFlightInfoTables(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetTables.class), context, descriptor);\n+    } else if (command.is(CommandGetTableTypes.class)) {\n+      return getFlightInfoTableTypes(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetTableTypes.class), context, descriptor);\n+    } else if (command.is(CommandGetSqlInfo.class)) {\n+      return getFlightInfoSqlInfo(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetSqlInfo.class), context, descriptor);\n+    } else if (command.is(CommandGetPrimaryKeys.class)) {\n+      return getFlightInfoPrimaryKeys(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetPrimaryKeys.class), context, descriptor);\n+    } else if (command.is(CommandGetExportedKeys.class)) {\n+      return getFlightInfoExportedKeys(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetExportedKeys.class), context, descriptor);\n+    } else if (command.is(CommandGetImportedKeys.class)) {\n+      return getFlightInfoImportedKeys(\n+          FlightSqlUtils.unpackOrThrow(command, CommandGetImportedKeys.class), context, descriptor);\n+    }\n+\n+    throw CallStatus.INVALID_ARGUMENT.withDescription(\"The defined request is invalid.\").toRuntimeException();\n+  }\n+\n+  /**\n+   * Returns the schema of the result produced by the SQL query.\n+   *\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return the result set schema.\n+   */\n+  @Override\n+  default SchemaResult getSchema(CallContext context, FlightDescriptor descriptor) {\n+    final Any command = FlightSqlUtils.parseOrThrow(descriptor.getCommand());\n+\n+    if (command.is(CommandStatementQuery.class)) {\n+      return getSchemaStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandStatementQuery.class), context, descriptor);\n+    } else if (command.is(CommandGetCatalogs.class)) {\n+      return getSchemaCatalogs();\n+    } else if (command.is(CommandGetSchemas.class)) {\n+      return getSchemaSchemas();\n+    } else if (command.is(CommandGetTables.class)) {\n+      return getSchemaTables();\n+    } else if (command.is(CommandGetTableTypes.class)) {\n+      return getSchemaTableTypes();\n+    } else if (command.is(CommandGetSqlInfo.class)) {\n+      return getSchemaSqlInfo();\n+    } else if (command.is(CommandGetPrimaryKeys.class)) {\n+      return getSchemaPrimaryKeys();\n+    } else if (command.is(CommandGetExportedKeys.class)) {\n+      return getSchemaForImportedAndExportedKeys();\n+    } else if (command.is(CommandGetImportedKeys.class)) {\n+      return getSchemaForImportedAndExportedKeys();\n+    }\n+\n+    throw CallStatus.INVALID_ARGUMENT.withDescription(\"Invalid command provided.\").toRuntimeException();\n+  }\n+\n+  /**\n+   * Depending on the provided command, method either:\n+   * 1. Return data for a stream produced by executing the provided SQL query, or\n+   * 2. Return data for a prepared statement. In this case, parameters binding is allowed.\n+   *\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  @Override\n+  default void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+    final Any command;\n+\n+    try {\n+      command = Any.parseFrom(ticket.getBytes());\n+    } catch (InvalidProtocolBufferException e) {\n+      listener.error(e);\n+      return;\n+    }\n+\n+    if (command.is(CommandStatementQuery.class)) {\n+      getStreamStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandStatementQuery.class), context, ticket, listener);\n+    } else if (command.is(CommandPreparedStatementQuery.class)) {\n+      getStreamPreparedStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandPreparedStatementQuery.class), context, ticket, listener);\n+    } else if (command.is(CommandGetCatalogs.class)) {\n+      getStreamCatalogs(context, ticket, listener);\n+    } else if (command.is(CommandGetSchemas.class)) {\n+      getStreamSchemas(FlightSqlUtils.unpackOrThrow(command, CommandGetSchemas.class), context, ticket, listener);\n+    } else if (command.is(CommandGetTables.class)) {\n+      getStreamTables(FlightSqlUtils.unpackOrThrow(command, CommandGetTables.class), context, ticket, listener);\n+    } else if (command.is(CommandGetTableTypes.class)) {\n+      getStreamTableTypes(context, ticket, listener);\n+    } else if (command.is(CommandGetSqlInfo.class)) {\n+      getStreamSqlInfo(FlightSqlUtils.unpackOrThrow(command, CommandGetSqlInfo.class), context, ticket, listener);\n+    } else if (command.is(CommandGetPrimaryKeys.class)) {\n+      getStreamPrimaryKeys(FlightSqlUtils.unpackOrThrow(command, CommandGetPrimaryKeys.class),\n+          context, ticket, listener);\n+    } else if (command.is(CommandGetExportedKeys.class)) {\n+      getStreamExportedKeys(FlightSqlUtils.unpackOrThrow(command, CommandGetExportedKeys.class),\n+          context, ticket, listener);\n+    } else if (command.is(CommandGetImportedKeys.class)) {\n+      getStreamImportedKeys(FlightSqlUtils.unpackOrThrow(command, CommandGetImportedKeys.class),\n+          context, ticket, listener);\n+    } else {\n+      throw CallStatus.INVALID_ARGUMENT.withDescription(\"The defined request is invalid.\").toRuntimeException();\n+    }\n+  }\n+\n+  /**\n+   * Depending on the provided command, method either:\n+   * 1. Execute provided SQL query as an update statement, or\n+   * 2. Execute provided update SQL query prepared statement. In this case, parameters binding\n+   * is allowed, or\n+   * 3. Binds parameters to the provided prepared statement.\n+   *\n+   * @param context      Per-call context.\n+   * @param flightStream The data stream being uploaded.\n+   * @param ackStream    The data stream listener for update result acknowledgement.\n+   * @return a Runnable to process the stream.\n+   */\n+  @Override\n+  default Runnable acceptPut(CallContext context, FlightStream flightStream, StreamListener<PutResult> ackStream) {\n+    final Any command = FlightSqlUtils.parseOrThrow(flightStream.getDescriptor().getCommand());\n+\n+    if (command.is(CommandStatementUpdate.class)) {\n+      return acceptPutStatement(\n+          FlightSqlUtils.unpackOrThrow(command, CommandStatementUpdate.class),\n+          context, flightStream, ackStream);\n+    } else if (command.is(CommandPreparedStatementUpdate.class)) {\n+      return acceptPutPreparedStatementUpdate(\n+          FlightSqlUtils.unpackOrThrow(command, CommandPreparedStatementUpdate.class),\n+          context, flightStream, ackStream);\n+    } else if (command.is(CommandPreparedStatementQuery.class)) {\n+      return acceptPutPreparedStatementQuery(\n+          FlightSqlUtils.unpackOrThrow(command, CommandPreparedStatementQuery.class),\n+          context, flightStream, ackStream);\n+    }\n+\n+    throw CallStatus.INVALID_ARGUMENT.withDescription(\"The defined request is invalid.\").toRuntimeException();\n+  }\n+\n+  /**\n+   * Lists all available Flight SQL actions.\n+   *\n+   * @param context  Per-call context.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  @Override\n+  default void listActions(CallContext context, StreamListener<ActionType> listener) {\n+    FlightSqlUtils.FLIGHT_SQL_ACTIONS.forEach(listener::onNext);\n+    listener.onCompleted();\n+  }\n+\n+  /**\n+   * Performs the requested Flight SQL action.\n+   *\n+   * @param context  Per-call context.\n+   * @param action   Client-supplied parameters.\n+   * @param listener A stream of responses.\n+   */\n+  @Override\n+  default void doAction(CallContext context, Action action, StreamListener<Result> listener) {\n+    final String actionType = action.getType();\n+    if (actionType.equals(FlightSqlUtils.FLIGHT_SQL_CREATEPREPAREDSTATEMENT.getType())) {\n+      final ActionCreatePreparedStatementRequest request = FlightSqlUtils.unpackAndParseOrThrow(action.getBody(),\n+          ActionCreatePreparedStatementRequest.class);\n+      createPreparedStatement(request, context, listener);\n+    } else if (actionType.equals(FlightSqlUtils.FLIGHT_SQL_CLOSEPREPAREDSTATEMENT.getType())) {\n+      final ActionClosePreparedStatementRequest request = FlightSqlUtils.unpackAndParseOrThrow(action.getBody(),\n+          ActionClosePreparedStatementRequest.class);\n+      closePreparedStatement(request, context, listener);\n+    }\n+\n+    throw CallStatus.INVALID_ARGUMENT.withDescription(\"Invalid action provided.\").toRuntimeException();\n+  }\n+\n+  /**\n+   * Creates a prepared statement on the server and returns a handle and metadata for in a\n+   * {@link ActionCreatePreparedStatementResult} object in a {@link Result}\n+   * object.\n+   *\n+   * @param request  The sql command to generate the prepared statement.\n+   * @param context  Per-call context.\n+   * @param listener A stream of responses.\n+   */\n+  void createPreparedStatement(ActionCreatePreparedStatementRequest request, CallContext context,\n+                               StreamListener<Result> listener);\n+\n+  /**\n+   * Closes a prepared statement on the server. No result is expected.\n+   *\n+   * @param request  The sql command to generate the prepared statement.\n+   * @param context  Per-call context.\n+   * @param listener A stream of responses.\n+   */\n+  void closePreparedStatement(ActionClosePreparedStatementRequest request, CallContext context,\n+                              StreamListener<Result> listener);\n+\n+  /**\n+   * Gets information about a particular SQL query based data stream.\n+   *\n+   * @param command    The sql command to generate the data stream.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoStatement(CommandStatementQuery command, CallContext context,\n+                                    FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets information about a particular prepared statement data stream.\n+   *\n+   * @param command    The prepared statement to generate the data stream.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoPreparedStatement(CommandPreparedStatementQuery command,\n+                                            CallContext context, FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about a particular SQL query based data stream.\n+   *\n+   * @param command    The sql command to generate the data stream.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Schema for the stream.\n+   */\n+  SchemaResult getSchemaStatement(CommandStatementQuery command, CallContext context,\n+                                  FlightDescriptor descriptor);\n+\n+  /**\n+   * Returns data for a SQL query based data stream.\n+   *\n+   * @param command  The sql command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamStatement(CommandStatementQuery command, CallContext context, Ticket ticket,\n+                          ServerStreamListener listener);\n+\n+  /**\n+   * Returns data for a particular prepared statement query instance.\n+   *\n+   * @param command  The prepared statement to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamPreparedStatement(CommandPreparedStatementQuery command, CallContext context,\n+                                  Ticket ticket, ServerStreamListener listener);\n+\n+  /**\n+   * Accepts uploaded data for a particular SQL query based data stream.\n+   * <p>`PutResult`s must be in the form of a {@link DoPutUpdateResult}.\n+   *\n+   * @param command      The sql command to generate the data stream.\n+   * @param context      Per-call context.\n+   * @param flightStream The data stream being uploaded.\n+   * @param ackStream    The result data stream.\n+   * @return A runnable to process the stream.\n+   */\n+  Runnable acceptPutStatement(CommandStatementUpdate command, CallContext context,\n+                              FlightStream flightStream, StreamListener<PutResult> ackStream);\n+\n+  /**\n+   * Accepts uploaded data for a particular prepared statement data stream.\n+   * <p>`PutResult`s must be in the form of a {@link DoPutUpdateResult}.\n+   *\n+   * @param command      The prepared statement to generate the data stream.\n+   * @param context      Per-call context.\n+   * @param flightStream The data stream being uploaded.\n+   * @param ackStream    The result data stream.\n+   * @return A runnable to process the stream.\n+   */\n+  Runnable acceptPutPreparedStatementUpdate(CommandPreparedStatementUpdate command,\n+                                            CallContext context, FlightStream flightStream,\n+                                            StreamListener<PutResult> ackStream);\n+\n+  /**\n+   * Accepts uploaded parameter values for a particular prepared statement query.\n+   *\n+   * @param command      The prepared statement the parameter values will bind to.\n+   * @param context      Per-call context.\n+   * @param flightStream The data stream being uploaded.\n+   * @param ackStream    The result data stream.\n+   * @return A runnable to process the stream.\n+   */\n+  Runnable acceptPutPreparedStatementQuery(CommandPreparedStatementQuery command,\n+                                           CallContext context, FlightStream flightStream,\n+                                           StreamListener<PutResult> ackStream);\n+\n+  /**\n+   * Returns the SQL Info of the server by returning a\n+   * {@link CommandGetSqlInfo} in a {@link Result}.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoSqlInfo(CommandGetSqlInfo request, CallContext context,\n+                                  FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get SQL info data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaSqlInfo() {\n+    return new SchemaResult(Schemas.GET_SQL_INFO_SCHEMA);\n+  }\n+\n+  /**\n+   * Returns data for SQL info based data stream.\n+   *\n+   * @param command  The command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamSqlInfo(CommandGetSqlInfo command, CallContext context, Ticket ticket,\n+                        ServerStreamListener listener);\n+\n+  /**\n+   * Returns the available catalogs by returning a stream of\n+   * {@link CommandGetCatalogs} objects in {@link Result} objects.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoCatalogs(CommandGetCatalogs request, CallContext context,\n+                                   FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get catalogs data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaCatalogs() {\n+    return new SchemaResult(Schemas.GET_CATALOGS_SCHEMA);\n+  }\n+\n+  /**\n+   * Returns data for catalogs based data stream.\n+   *\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamCatalogs(CallContext context, Ticket ticket,\n+                         ServerStreamListener listener);\n+\n+  /**\n+   * Returns the available schemas by returning a stream of\n+   * {@link CommandGetSchemas} objects in {@link Result} objects.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoSchemas(CommandGetSchemas request, CallContext context,\n+                                  FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get schemas data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaSchemas() {\n+    return new SchemaResult(Schemas.GET_SCHEMAS_SCHEMA);\n+  }\n+\n+  /**\n+   * Returns data for schemas based data stream.\n+   *\n+   * @param command  The command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamSchemas(CommandGetSchemas command, CallContext context, Ticket ticket,\n+                        ServerStreamListener listener);\n+\n+  /**\n+   * Returns the available tables by returning a stream of\n+   * {@link CommandGetTables} objects in {@link Result} objects.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoTables(CommandGetTables request, CallContext context,\n+                                 FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get tables data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaTables() {\n+    return new SchemaResult(Schemas.GET_TABLES_SCHEMA);\n+  }\n+\n+  /**\n+   * Returns data for tables based data stream.\n+   *\n+   * @param command  The command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamTables(CommandGetTables command, CallContext context, Ticket ticket,\n+                       ServerStreamListener listener);\n+\n+  /**\n+   * Returns the available table types by returning a stream of\n+   * {@link CommandGetTableTypes} objects in {@link Result} objects.\n+   *\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoTableTypes(CommandGetTableTypes request, CallContext context,\n+                                     FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get table types data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaTableTypes() {\n+    return new SchemaResult(Schemas.GET_TABLE_TYPES_SCHEMA);\n+  }\n+\n+  /**\n+   * Returns data for table types based data stream.\n+   *\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamTableTypes(CallContext context, Ticket ticket, ServerStreamListener listener);\n+\n+  /**\n+   * Returns the available primary keys by returning a stream of\n+   * {@link CommandGetPrimaryKeys} objects in {@link Result} objects.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoPrimaryKeys(CommandGetPrimaryKeys request, CallContext context,\n+                                      FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get primary keys data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaPrimaryKeys() {\n+    final List<Field> fields = Arrays.asList(\n+        Field.nullable(\"catalog_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"schema_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"table_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"column_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"key_sequence\", MinorType.INT.getType()),\n+        Field.nullable(\"key_name\", MinorType.VARCHAR.getType()));\n+\n+    return new SchemaResult(new Schema(fields));\n+  }\n+\n+  /**\n+   * Returns data for primary keys based data stream.\n+   *\n+   * @param command  The command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamPrimaryKeys(CommandGetPrimaryKeys command, CallContext context, Ticket ticket,\n+                            ServerStreamListener listener);\n+\n+  /**\n+   * Retrieves a description of the foreign key columns that reference the given table's primary key columns\n+   * {@link CommandGetExportedKeys} objects in {@link Result} objects.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoExportedKeys(CommandGetExportedKeys request, CallContext context,\n+                                       FlightDescriptor descriptor);\n+\n+  /**\n+   * Retrieves a description of the primary key columns that are referenced by given table's foreign key columns\n+   * {@link CommandGetImportedKeys} objects in {@link Result} objects.\n+   *\n+   * @param request    request filter parameters.\n+   * @param context    Per-call context.\n+   * @param descriptor The descriptor identifying the data stream.\n+   * @return Metadata about the stream.\n+   */\n+  FlightInfo getFlightInfoImportedKeys(CommandGetImportedKeys request, CallContext context,\n+                                       FlightDescriptor descriptor);\n+\n+  /**\n+   * Gets schema about the get imported and exported keys data stream.\n+   *\n+   * @return Schema for the stream.\n+   */\n+  default SchemaResult getSchemaForImportedAndExportedKeys() {\n+    return new SchemaResult(Schemas.GET_IMPORTED_AND_EXPORTED_KEYS_SCHEMA);\n+  }\n+\n+  /**\n+   * Returns data for foreign keys based data stream.\n+   *\n+   * @param command  The command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamExportedKeys(CommandGetExportedKeys command, CallContext context, Ticket ticket,\n+                             ServerStreamListener listener);\n+\n+  /**\n+   * Returns data for foreign keys based data stream.\n+   *\n+   * @param command  The command to generate the data stream.\n+   * @param context  Per-call context.\n+   * @param ticket   The application-defined ticket identifying this stream.\n+   * @param listener An interface for sending data back to the client.\n+   */\n+  void getStreamImportedKeys(CommandGetImportedKeys command, CallContext context, Ticket ticket,\n+                             ServerStreamListener listener);\n+\n+  /**\n+   * Default schema templates for the {@link FlightSqlProducer}.\n+   */\n+  final class Schemas {\n+    public static final Schema GET_TABLES_SCHEMA = new Schema(Arrays.asList(\n+        Field.nullable(\"catalog_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"schema_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"table_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"table_type\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"table_schema\", MinorType.VARBINARY.getType())));\n+    public static final Schema GET_TABLES_SCHEMA_NO_SCHEMA = new Schema(Arrays.asList(\n+        Field.nullable(\"catalog_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"schema_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"table_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"table_type\", MinorType.VARCHAR.getType())));\n+    public static final Schema GET_CATALOGS_SCHEMA = new Schema(\n+        Collections.singletonList(new Field(\"catalog_name\", FieldType.nullable(MinorType.VARCHAR.getType()), null)));\n+    public static final Schema GET_TABLE_TYPES_SCHEMA =\n+        new Schema(Collections.singletonList(Field.nullable(\"table_type\", MinorType.VARCHAR.getType())));\n+    public static final Schema GET_SCHEMAS_SCHEMA = new Schema(\n+        Arrays.asList(Field.nullable(\"catalog_name\", MinorType.VARCHAR.getType()),\n+            Field.nullable(\"schema_name\", MinorType.VARCHAR.getType())));\n+    public static final Schema GET_IMPORTED_AND_EXPORTED_KEYS_SCHEMA = new Schema(Arrays.asList(\n+        Field.nullable(\"pk_catalog_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"pk_schema_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"pk_table_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"pk_column_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"fk_catalog_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"fk_schema_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"fk_table_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"fk_column_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"key_sequence\", MinorType.INT.getType()),\n+        Field.nullable(\"fk_key_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"pk_key_name\", MinorType.VARCHAR.getType()),\n+        Field.nullable(\"update_rule\", new ArrowType.Int(8, false)),\n+        Field.nullable(\"delete_rule\", new ArrowType.Int(8, false))));\n+    public static final Schema GET_SQL_INFO_SCHEMA =\n+        new Schema(Arrays.asList(\n+            Field.nullable(\"info_name\", new ArrowType.Int(32, false)),\n+            new Field(\"value\",\n+                // dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+                new FieldType(true, new Union(UnionMode.Dense, new int[] {0, 1, 2, 3}), /*dictionary=*/null),\n+                Arrays.asList(\n+                    Field.nullable(\"string_value\", MinorType.VARCHAR.getType()),\n+                    Field.nullable(\"int_value\", MinorType.INT.getType()),\n+                    Field.nullable(\"bigint_value\", MinorType.BIGINT.getType()),\n+                    Field.nullable(\"int32_bitmask\", MinorType.INT.getType())))));\n+\n+    private Schemas() {\n+      // Prevent instantiation.\n+    }\n+  }\n+\n+  /**\n+   * Reserved options for the SQL command `GetSqlInfo` used by {@link FlightSqlProducer}.\n+   */\n+  final class SqlInfo {\n+    public static final int FLIGHT_SQL_SERVER_NAME = 0;\n+    public static final int FLIGHT_SQL_SERVER_VERSION = 1;\n+    public static final int FLIGHT_SQL_SERVER_ARROW_VERSION = 2;\n+    public static final int FLIGHT_SQL_SERVER_READ_ONLY = 3;\n+    public static final int SQL_DDL_CATALOG = 500;\n+    public static final int SQL_DDL_SCHEMA = 501;\n+    public static final int SQL_DDL_TABLE = 502;\n+    public static final int SQL_IDENTIFIER_CASE = 503;\n+    public static final int SQL_IDENTIFIER_QUOTE_CHAR = 504;\n+    public static final int SQL_QUOTED_IDENTIFIER_CASE = 505;\n+  }\n+\n+  /**\n+   * Update/delete rules for {@link FlightSqlProducer#getStreamImportedKeys} and\n+   * {@link FlightSqlProducer#getStreamExportedKeys}.\n+   */\n+  final class UpdateDeleteRules {\n\nReview comment:\n       If I'm not mistaken, this isn't used anywhere?\r\n   \r\n   If it is to be used, might it make more sense as an enum? (If it's to appear in an API anywhere.)\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,449 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+import \"google/protobuf/descriptor.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: uint32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  option (experimental) = true;\n+\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Range [500-1000)\n+   * Range [0-100000) is reserved for defaults. Custom options should start at 100000.\n+   *\n+   * 1. Server Information [0-500): Provides basic information about the Flight SQL Server.\n+   *\n+   * The name of the Flight SQL Server.\n+   * 0 = FLIGHT_SQL_SERVER_NAME\n+   *\n+   * The native version of the Flight SQL Server.\n+   * 1 = FLIGHT_SQL_SERVER_VERSION\n+   *\n+   * The Arrow format version of the Flight SQL Server.\n+   * 2 = FLIGHT_SQL_SERVER_ARROW_VERSION\n+   *\n+   * Indicates whether the Flight SQL Server is read only.\n+   * 3 = FLIGHT_SQL_SERVER_READ_ONLY\n+   *\n+   * 2. SQL Syntax Information [500-1000): provides information about SQL syntax supported by the Flight SQL Server.\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of catalogs.\n+   * In a SQL environment, a catalog is a collection of schemas.\n+   * 500 = SQL_DDL_CATALOG\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of schemas.\n+   * In a SQL environment, a catalog is a collection of tables, views, indexes etc.\n+   * 501 = SQL_DDL_SCHEMA\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of tables.\n+   * In a SQL environment, a table is a collection of rows of information. Each row of information\n+   * may have one or more columns of data.\n+   * 502 = SQL_DDL_TABLE\n+   *\n+   * Indicates the case sensitivity of catalog, table and schema names.\n+   * 503 = SQL_IDENTIFIER_CASE\n+   *\n+   * Indicates the supported character(s) used to surround a delimited identifier.\n+   * 504 = SQL_IDENTIFIER_QUOTE_CHAR\n+   *\n+   * Indicates case sensitivity of quoted identifiers.\n+   * 505 = SQL_QUOTED_IDENTIFIER_CASE\n+   *\n+   * If omitted, then all metadata will be retrieved.\n+   * Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must\n+   * at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved for future use.\n+   * If additional metadata is included, the metadata IDs should start from 10,000.\n+   */\n+  repeated uint32 info = 1;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of catalogs on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name.\n+ */\n+message CommandGetCatalogs {\n+  option (experimental) = true;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of schemas on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, then schema_name.\n+ */\n+message CommandGetSchemas {\n+  option (experimental) = true;\n+\n+  /*\n+   * Specifies the Catalog to search for schemas.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, the pattern will not be used to narrow the search.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of tables, and optionally their schemas, on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  table_type: utf8,\n+ *  table_schema: bytes (schema of the table as described in Schema.fbs::Schema, it is serialized as an IPC message.)\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, then table_type.\n+ */\n+message CommandGetTables {\n+  option (experimental) = true;\n+\n+  /*\n+   * Specifies the Catalog to search for the tables.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, all schemas matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+\n+  /*\n+   * Specifies a filter pattern for tables to search for.\n+   * When no table_name_filter_pattern is provided, all tables matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue table_name_filter_pattern = 3;\n+\n+  // Specifies a filter of table types which must match.\n+  repeated string table_types = 4;\n+\n+  // Specifies if the schema should be returned for found tables.\n+  bool include_schema = 5;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of table types on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  table_type: utf8\n+ * >\n+ * The returned data should be ordered by table_type.\n+ */\n+message CommandGetTableTypes {\n+  option (experimental) = true;\n+}\n+\n+/*\n+ * Represents a request to retrieve the primary keys of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  column_name: utf8,\n+ *  key_name: utf8\n+ *  key_sequence: int,\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n+ */\n+message CommandGetPrimaryKeys {\n+  option (experimental) = true;\n+\n+  // Specifies the catalog to search for the table.\n+  google.protobuf.StringValue catalog = 1;\n+\n+  // Specifies the schema to search for the table.\n+  google.protobuf.StringValue schema = 2;\n+\n+  // Specifies the table to get the primary keys for.\n+  google.protobuf.StringValue table = 3;\n+}\n+\n+/*\n+ * Represents a request to retrieve a description of the foreign key columns that reference the given table's\n+ * primary key columns (the foreign keys exported by a table) of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  pk_catalog_name: utf8,\n+ *  pk_schema_name: utf8,\n+ *  pk_table_name: utf8,\n+ *  pk_column_name: utf8,\n+ *  fk_catalog_name: utf8,\n+ *  fk_schema_name: utf8,\n+ *  fk_table_name: utf8,\n+ *  fk_column_name: utf8,\n+ *  key_sequence: int,\n+ *  fk_key_name: utf8,\n+ *  pk_key_name: utf8,\n+ *  update_rule: uint1,\n+ *  delete_rule: uint1\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n\nReview comment:\n       Which catalog_name, which schema_name, etc.?\n\n##########\nFile path: java/flight/flight-sql/src/test/java/org/apache/arrow/flight/TestFlightSql.java\n##########\n@@ -0,0 +1,653 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.isNull;\n+import static org.apache.arrow.util.AutoCloseables.close;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.Reader;\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+import java.util.stream.IntStream;\n+\n+import org.apache.arrow.flight.sql.FlightSqlClient;\n+import org.apache.arrow.flight.sql.FlightSqlClient.PreparedStatement;\n+import org.apache.arrow.flight.sql.FlightSqlExample;\n+import org.apache.arrow.flight.sql.FlightSqlProducer;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.complex.DenseUnionVector;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.apache.arrow.vector.util.Text;\n+import org.hamcrest.Matcher;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ErrorCollector;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Test direct usage of Flight SQL workflows.\n+ */\n+public class TestFlightSql {\n\nReview comment:\n       Got it, thanks.\n\n##########\nFile path: java/flight/flight-sql/src/main/java/org/apache/arrow/flight/sql/FlightSqlClient.java\n##########\n@@ -0,0 +1,567 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.sql;\n+\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionClosePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementRequest;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetCatalogs;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetExportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetImportedKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetPrimaryKeys;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSchemas;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetSqlInfo;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTableTypes;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandGetTables;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementQuery;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.CommandStatementUpdate;\n+import static org.apache.arrow.flight.sql.impl.FlightSql.DoPutUpdateResult;\n+\n+import java.nio.ByteBuffer;\n+import java.sql.SQLException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+import org.apache.arrow.flight.Action;\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.CallStatus;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.SyncPutListener;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.impl.FlightSql.ActionCreatePreparedStatementResult;\n+import org.apache.arrow.flight.sql.impl.FlightSql.CommandPreparedStatementQuery;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.Any;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.StringValue;\n+\n+/**\n+ * Flight client with Flight SQL semantics.\n+ */\n+public class FlightSqlClient {\n+  private final FlightClient client;\n+\n+  public FlightSqlClient(final FlightClient client) {\n+    this.client = Objects.requireNonNull(client, \"Client cannot be null!\");\n+  }\n+\n+  /**\n+   * Execute a query on the server.\n+   *\n+   * @param query   The query to execute.\n+   * @param options RPC-layer hints for this call.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo execute(final String query, final CallOption... options) {\n+    final CommandStatementQuery.Builder builder = CommandStatementQuery.newBuilder();\n+    builder.setQuery(query);\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor, options);\n+  }\n+\n+  /**\n+   * Execute an update query on the server.\n+   *\n+   * @param query   The query to execute.\n+   * @param options RPC-layer hints for this call.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public long executeUpdate(final String query, final CallOption... options) {\n+    final CommandStatementUpdate.Builder builder = CommandStatementUpdate.newBuilder();\n+    builder.setQuery(query);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    final SyncPutListener putListener = new SyncPutListener();\n+    client.startPut(descriptor, VectorSchemaRoot.of(), putListener, options);\n+\n+    try {\n+      final PutResult read = putListener.read();\n+      try (final ArrowBuf metadata = read.getApplicationMetadata()) {\n+        final DoPutUpdateResult doPutUpdateResult = DoPutUpdateResult.parseFrom(metadata.nioBuffer());\n+        return doPutUpdateResult.getRecordCount();\n+      }\n+    } catch (final InterruptedException | ExecutionException e) {\n+      throw CallStatus.CANCELLED.withCause(e).toRuntimeException();\n+    } catch (final InvalidProtocolBufferException e) {\n+      throw CallStatus.INVALID_ARGUMENT.withCause(e).toRuntimeException();\n+    }\n+  }\n+\n+  /**\n+   * Request a list of catalogs.\n+   *\n+   * @param options RPC-layer hints for this call.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getCatalogs(final CallOption... options) {\n+    final CommandGetCatalogs.Builder builder = CommandGetCatalogs.newBuilder();\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor, options);\n+  }\n+\n+  /**\n+   * Request a list of schemas.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @param options             RPC-layer hints for this call.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSchemas(final String catalog, final String schemaFilterPattern, final CallOption... options) {\n+    final CommandGetSchemas.Builder builder = CommandGetSchemas.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor, options);\n+  }\n+\n+  /**\n+   * Get schema for a stream.\n+   *\n+   * @param descriptor The descriptor for the stream.\n+   * @param options    RPC-layer hints for this call.\n+   */\n+  public SchemaResult getSchema(FlightDescriptor descriptor, CallOption... options) {\n+    return client.getSchema(descriptor, options);\n+  }\n+\n+  /**\n+   * Retrieve a stream from the server.\n+   *\n+   * @param ticket  The ticket granting access to the data stream.\n+   * @param options RPC-layer hints for this call.\n+   */\n+  public FlightStream getStream(Ticket ticket, CallOption... options) {\n+    return client.getStream(ticket, options);\n+  }\n+\n+  /**\n+   * Request a set of Flight SQL metadata.\n+   *\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSqlInfo(final int... info) {\n+    return getSqlInfo(info, new CallOption[0]);\n+  }\n+\n+  /**\n+   * Request a set of Flight SQL metadata.\n+   *\n+   * @param info    The set of metadata to retrieve. None to retrieve all metadata.\n+   * @param options RPC-layer hints for this call.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSqlInfo(final int[] info, final CallOption... options) {\n+    return getSqlInfo(Arrays.stream(info).boxed().collect(Collectors.toList()), options);\n+  }\n+\n+  /**\n+   * Request a set of Flight SQL metadata.\n+   *\n+   * @param info    The set of metadata to retrieve. None to retrieve all metadata.\n+   * @param options RPC-layer hints for this call.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getSqlInfo(final List<Integer> info, final CallOption... options) {\n+    final CommandGetSqlInfo.Builder builder = CommandGetSqlInfo.newBuilder();\n+    builder.addAllInfo(info);\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor, options);\n+  }\n+\n+  /**\n+   * Request a list of tables.\n+   *\n+   * @param catalog             The catalog.\n+   * @param schemaFilterPattern The schema filter pattern.\n+   * @param tableFilterPattern  The table filter pattern.\n+   * @param tableTypes          The table types to include.\n+   * @param includeSchema       True to include the schema upon return, false to not include the schema.\n+   * @param options             RPC-layer hints for this call.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getTables(final String catalog, final String schemaFilterPattern,\n+                              final String tableFilterPattern, final List<String> tableTypes,\n+                              final boolean includeSchema, final CallOption... options) {\n+    final CommandGetTables.Builder builder = CommandGetTables.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schemaFilterPattern != null) {\n+      builder.setSchemaFilterPattern(StringValue.newBuilder().setValue(schemaFilterPattern).build());\n+    }\n+\n+    if (tableFilterPattern != null) {\n+      builder.setTableNameFilterPattern(StringValue.newBuilder().setValue(tableFilterPattern).build());\n+    }\n+\n+    if (tableTypes != null) {\n+      builder.addAllTableTypes(tableTypes);\n+    }\n+    builder.setIncludeSchema(includeSchema);\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor, options);\n+  }\n+\n+  /**\n+   * Request the primary keys for a table.\n+   *\n+   * @param catalog The catalog.\n+   * @param schema  The schema.\n+   * @param table   The table.\n+   * @param options RPC-layer hints for this call.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getPrimaryKeys(final String catalog, final String schema,\n+                                   final String table, final CallOption... options) {\n+    final CommandGetPrimaryKeys.Builder builder = CommandGetPrimaryKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    if (table != null) {\n+      builder.setTable(StringValue.newBuilder().setValue(table).build());\n+    }\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor, options);\n+  }\n+\n+  /**\n+   * Retrieves a description about the foreign key columns that reference the primary key columns of the given table.\n+   *\n+   * @param catalog The foreign key table catalog.\n+   * @param schema  The foreign key table schema.\n+   * @param table   The foreign key table. Cannot be null.\n+   * @param options RPC-layer hints for this call.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getExportedKeys(String catalog, String schema, String table, final CallOption... options) {\n+    Objects.requireNonNull(table, \"Table cannot be null.\");\n+\n+    final CommandGetExportedKeys.Builder builder = CommandGetExportedKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    Objects.requireNonNull(table);\n+    builder.setTable(table).build();\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor, options);\n+  }\n+\n+  /**\n+   * Retrieves the foreign key columns for the given table.\n+   *\n+   * @param catalog The primary key table catalog.\n+   * @param schema  The primary key table schema.\n+   * @param table   The primary key table. Cannot be null.\n+   * @param options RPC-layer hints for this call.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getImportedKeys(final String catalog, final String schema, final String table,\n+                                    final CallOption... options) {\n+    Objects.requireNonNull(table, \"Table cannot be null.\");\n+\n+    final CommandGetImportedKeys.Builder builder = CommandGetImportedKeys.newBuilder();\n+\n+    if (catalog != null) {\n+      builder.setCatalog(StringValue.newBuilder().setValue(catalog).build());\n+    }\n+\n+    if (schema != null) {\n+      builder.setSchema(StringValue.newBuilder().setValue(schema).build());\n+    }\n+\n+    Objects.requireNonNull(table);\n+    builder.setTable(table).build();\n+\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor, options);\n+  }\n+\n+  /**\n+   * Request a list of table types.\n+   *\n+   * @param options RPC-layer hints for this call.\n+   * @return a FlightInfo object representing the stream(s) to fetch.\n+   */\n+  public FlightInfo getTableTypes(final CallOption... options) {\n+    final CommandGetTableTypes.Builder builder = CommandGetTableTypes.newBuilder();\n+    final FlightDescriptor descriptor = FlightDescriptor.command(Any.pack(builder.build()).toByteArray());\n+    return client.getInfo(descriptor, options);\n+  }\n+\n+  /**\n+   * Create a prepared statement on the server.\n+   *\n+   * @param query   The query to prepare.\n+   * @param options RPC-layer hints for this call.\n+   * @return The representation of the prepared statement which exists on the server.\n+   */\n+  public PreparedStatement prepare(final String query, final CallOption... options) {\n+    return new PreparedStatement(client, query, options);\n+  }\n+\n+  /**\n+   * Helper class to encapsulate Flight SQL prepared statement logic.\n+   */\n+  public static class PreparedStatement implements AutoCloseable {\n+    private final FlightClient client;\n+    private final ActionCreatePreparedStatementResult preparedStatementResult;\n+    private final AtomicLong invocationCount;\n+    private VectorSchemaRoot parameterBindingRoot;\n+    private boolean isClosed;\n+    private Schema resultSetSchema;\n+    private Schema parameterSchema;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param client  The client. PreparedStatement does not maintain this resource.\n+     * @param sql     The query.\n+     * @param options RPC-layer hints for this call.\n+     */\n+    public PreparedStatement(final FlightClient client, final String sql, final CallOption... options) {\n+      this.client = client;\n+      final Action action = new Action(\n+          FlightSqlUtils.FLIGHT_SQL_CREATEPREPAREDSTATEMENT.getType(),\n+          Any.pack(ActionCreatePreparedStatementRequest\n+                  .newBuilder()\n+                  .setQuery(sql)\n+                  .build())\n+              .toByteArray());\n+      final Iterator<Result> preparedStatementResults = client.doAction(action, options);\n+\n+      preparedStatementResult = FlightSqlUtils.unpackAndParseOrThrow(\n+          preparedStatementResults.next().getBody(),\n+          ActionCreatePreparedStatementResult.class);\n+\n+      invocationCount = new AtomicLong(0);\n+      isClosed = false;\n+    }\n+\n+    /**\n+     * Set the {@link #parameterBindingRoot} containing the parameter binding from a {@link PreparedStatement}\n+     * operation.\n+     *\n+     * @param parameterBindingRoot a {@code VectorSchemaRoot} object containing the values to be used in the\n+     *                             {@code PreparedStatement} setters.\n+     */\n+    public void setParameters(final VectorSchemaRoot parameterBindingRoot) {\n+      if (this.parameterBindingRoot != null) {\n+        if (this.parameterBindingRoot.equals(parameterBindingRoot)) {\n+          return;\n+        }\n+        this.parameterBindingRoot.close();\n+      }\n+      this.parameterBindingRoot =\n+          Objects.requireNonNull(parameterBindingRoot, \"Parameter binding root cannot be null!\");\n+    }\n+\n+    /**\n+     * Empty the {@link #parameterBindingRoot}, which contains the parameter binding from\n+     * a {@link PreparedStatement} operation.\n+     */\n+    public void clearParameters() {\n+      if (parameterBindingRoot != null) {\n+        parameterBindingRoot.close();\n+      }\n+    }\n+\n+    /**\n+     * Returns the Schema of the resultset.\n+     *\n+     * @return the Schema of the resultset.\n+     */\n+    public Schema getResultSetSchema() {\n+      if (resultSetSchema == null) {\n+        final ByteString bytes = preparedStatementResult.getDatasetSchema();\n+        if (bytes.isEmpty()) {\n+          return new Schema(Collections.emptyList());\n+        }\n+        resultSetSchema = Schema.deserialize(bytes.asReadOnlyByteBuffer());\n+      }\n+      return resultSetSchema;\n+    }\n+\n+    /**\n+     * Returns the Schema of the parameters.\n+     *\n+     * @return the Schema of the parameters.\n+     */\n+    public Schema getParameterSchema() {\n+      if (parameterSchema == null) {\n+        final ByteString bytes = preparedStatementResult.getParameterSchema();\n+        if (bytes.isEmpty()) {\n+          return new Schema(Collections.emptyList());\n+        }\n+        parameterSchema = Schema.deserialize(bytes.asReadOnlyByteBuffer());\n+      }\n+      return parameterSchema;\n+    }\n+\n+    /**\n+     * Executes the prepared statement query on the server.\n+     *\n+     * @param options RPC-layer hints for this call.\n+     * @return a FlightInfo object representing the stream(s) to fetch.\n+     */\n+    public FlightInfo execute(final CallOption... options) throws SQLException {\n+      checkOpen();\n+\n+      final FlightDescriptor descriptor = FlightDescriptor\n+          .command(Any.pack(CommandPreparedStatementQuery.newBuilder()\n+                  .setClientExecutionHandle(\n+                      ByteString.copyFrom(ByteBuffer.allocate(Long.BYTES).putLong(invocationCount.getAndIncrement())))\n+                  .setPreparedStatementHandle(preparedStatementResult.getPreparedStatementHandle())\n+                  .build())\n+              .toByteArray());\n+\n+      if (parameterBindingRoot != null && parameterBindingRoot.getRowCount() > 0) {\n+        final SyncPutListener putListener = new SyncPutListener();\n+\n+        FlightClient.ClientStreamListener listener =\n+            client.startPut(descriptor, parameterBindingRoot, putListener, options);\n+\n+        listener.putNext();\n+        listener.completed();\n+      }\n+\n+      return client.getInfo(descriptor, options);\n+    }\n+\n+    /**\n+     * Checks whether this client is open.\n+     *\n+     * @throws IllegalStateException if client is closed.\n+     */\n+    protected final void checkOpen() {\n+      Preconditions.checkState(!isClosed, \"Statement closed\");\n+    }\n+\n+    /**\n+     * Executes the prepared statement update on the server.\n+     *\n+     * @param options RPC-layer hints for this call.\n+     */\n\nReview comment:\n       ```suggestion\r\n        * @return the count of updated records\r\n        */\r\n   ```\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,449 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+import \"google/protobuf/descriptor.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: uint32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  option (experimental) = true;\n+\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Range [500-1000)\n+   * Range [0-100000) is reserved for defaults. Custom options should start at 100000.\n+   *\n+   * 1. Server Information [0-500): Provides basic information about the Flight SQL Server.\n+   *\n+   * The name of the Flight SQL Server.\n+   * 0 = FLIGHT_SQL_SERVER_NAME\n+   *\n+   * The native version of the Flight SQL Server.\n+   * 1 = FLIGHT_SQL_SERVER_VERSION\n+   *\n+   * The Arrow format version of the Flight SQL Server.\n+   * 2 = FLIGHT_SQL_SERVER_ARROW_VERSION\n+   *\n+   * Indicates whether the Flight SQL Server is read only.\n+   * 3 = FLIGHT_SQL_SERVER_READ_ONLY\n+   *\n+   * 2. SQL Syntax Information [500-1000): provides information about SQL syntax supported by the Flight SQL Server.\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of catalogs.\n+   * In a SQL environment, a catalog is a collection of schemas.\n+   * 500 = SQL_DDL_CATALOG\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of schemas.\n+   * In a SQL environment, a catalog is a collection of tables, views, indexes etc.\n+   * 501 = SQL_DDL_SCHEMA\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of tables.\n+   * In a SQL environment, a table is a collection of rows of information. Each row of information\n+   * may have one or more columns of data.\n+   * 502 = SQL_DDL_TABLE\n+   *\n+   * Indicates the case sensitivity of catalog, table and schema names.\n+   * 503 = SQL_IDENTIFIER_CASE\n+   *\n+   * Indicates the supported character(s) used to surround a delimited identifier.\n+   * 504 = SQL_IDENTIFIER_QUOTE_CHAR\n+   *\n+   * Indicates case sensitivity of quoted identifiers.\n+   * 505 = SQL_QUOTED_IDENTIFIER_CASE\n+   *\n+   * If omitted, then all metadata will be retrieved.\n+   * Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must\n+   * at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved for future use.\n+   * If additional metadata is included, the metadata IDs should start from 10,000.\n+   */\n+  repeated uint32 info = 1;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of catalogs on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name.\n+ */\n+message CommandGetCatalogs {\n+  option (experimental) = true;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of schemas on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, then schema_name.\n+ */\n+message CommandGetSchemas {\n+  option (experimental) = true;\n+\n+  /*\n+   * Specifies the Catalog to search for schemas.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, the pattern will not be used to narrow the search.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of tables, and optionally their schemas, on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  table_type: utf8,\n+ *  table_schema: bytes (schema of the table as described in Schema.fbs::Schema, it is serialized as an IPC message.)\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, then table_type.\n+ */\n+message CommandGetTables {\n+  option (experimental) = true;\n+\n+  /*\n+   * Specifies the Catalog to search for the tables.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, all schemas matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+\n+  /*\n+   * Specifies a filter pattern for tables to search for.\n+   * When no table_name_filter_pattern is provided, all tables matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue table_name_filter_pattern = 3;\n+\n+  // Specifies a filter of table types which must match.\n+  repeated string table_types = 4;\n+\n+  // Specifies if the schema should be returned for found tables.\n+  bool include_schema = 5;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of table types on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  table_type: utf8\n+ * >\n+ * The returned data should be ordered by table_type.\n+ */\n+message CommandGetTableTypes {\n+  option (experimental) = true;\n+}\n+\n+/*\n+ * Represents a request to retrieve the primary keys of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  column_name: utf8,\n+ *  key_name: utf8\n+ *  key_sequence: int,\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n+ */\n+message CommandGetPrimaryKeys {\n+  option (experimental) = true;\n+\n+  // Specifies the catalog to search for the table.\n+  google.protobuf.StringValue catalog = 1;\n+\n+  // Specifies the schema to search for the table.\n+  google.protobuf.StringValue schema = 2;\n+\n+  // Specifies the table to get the primary keys for.\n+  google.protobuf.StringValue table = 3;\n+}\n+\n+/*\n+ * Represents a request to retrieve a description of the foreign key columns that reference the given table's\n+ * primary key columns (the foreign keys exported by a table) of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  pk_catalog_name: utf8,\n+ *  pk_schema_name: utf8,\n+ *  pk_table_name: utf8,\n+ *  pk_column_name: utf8,\n+ *  fk_catalog_name: utf8,\n+ *  fk_schema_name: utf8,\n+ *  fk_table_name: utf8,\n+ *  fk_column_name: utf8,\n+ *  key_sequence: int,\n+ *  fk_key_name: utf8,\n+ *  pk_key_name: utf8,\n+ *  update_rule: uint1,\n+ *  delete_rule: uint1\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n\nReview comment:\n       Ditto the question above about whether we should order by all of the fields (except the _rule ones I suppose)?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-17T18:56:09.467+0000",
                    "updated": "2021-08-17T18:56:09.467+0000",
                    "started": "2021-08-17T18:56:09.466+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638821",
                    "issueId": "13381560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/638839",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kylepbit commented on a change in pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906#discussion_r690651489\n\n\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: int32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Ragne [500-1000)\n+   * Range [0-100000) is reserved for defaults. Custom options should start at 100000.\n+   *\n+   * 1. Server Information [0-500): Provides basic information about the Flight SQL Server.\n+   *\n+   * The name of the Flight SQL Server.\n+   * 0 = FLIGHT_SQL_SERVER_NAME\n+   *\n+   * The native version of the Flight SQL Server.\n+   * 1 = FLIGHT_SQL_SERVER_VERSION\n+   *\n+   * The Arrow format version of the Flight SQL Server.\n+   * 2 = FLIGHT_SQL_SERVER_ARROW_VERSION\n+   *\n+   * Indicates whether the Flight SQL Server is read only.\n+   * 3 = FLIGHT_SQL_SERVER_READ_ONLY\n+   *\n+   * 2. SQL Syntax Information [500-1000): provides information about SQL syntax supported by the Flight SQL Server.\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of catalogs.\n+   * In a SQL environment, a catalog is a collection of schemas.\n+   * 500 = SQL_DDL_CATALOG\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of schemas.\n+   * In a SQL environment, a catalog is a collection of tables, views, indexes etc.\n+   * 501 = SQL_DDL_SCHEMA\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of tables.\n+   * In a SQL environment, a table is a collection of rows of information. Each row of information\n+   * may have one or more columns of data.\n+   * 502 = SQL_DDL_TABLE\n+   *\n+   * Indicates the case sensitivity of catalog, table and schema names.\n+   * 503 = SQL_IDENTIFIER_CASE\n+   *\n+   * Indicates the supported character(s) used to surround a delimited identifier.\n+   * 504 = SQL_IDENTIFIER_QUOTE_CHAR\n+   *\n+   * Indicates case sensitivity of quoted identifiers.\n+   * 505 = SQL_QUOTED_IDENTIFIER_CASE\n+   *\n+   * If omitted, then all metadata will be retrieved.\n+   * Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must\n+   * at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved.\n+   * If additional metadata is included, the metadata IDs should start from 10,000.\n+   */\n+  repeated uint32 info = 1;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of catalogs on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name.\n+ */\n+message CommandGetCatalogs {\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of schemas on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, then schema_name.\n+ */\n+message CommandGetSchemas {\n+  /*\n+   * Specifies the Catalog to search for schemas.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, the pattern will not be used to narrow the search.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of tables, and optionally their schemas, on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  table_type: utf8,\n+ *  table_schema: bytes\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, then table_type.\n+ */\n+message CommandGetTables {\n+  /*\n+   * Specifies the Catalog to search for the tables.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, all schemas matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+\n+  /*\n+   * Specifies a filter pattern for tables to search for.\n+   * When no table_name_filter_pattern is provided, all tables matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue table_name_filter_pattern = 3;\n+\n+  // Specifies a filter of table types which must match.\n+  repeated string table_types = 4;\n+\n+  // Specifies if the schema should be returned for found tables.\n+  bool include_schema = 5;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of table types on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  table_type: utf8\n+ * >\n+ * The returned data should be ordered by table_type.\n+ */\n+message CommandGetTableTypes {\n+}\n+\n+/*\n+ * Represents a request to retrieve the primary keys of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  column_name: utf8,\n+ *  key_sequence: int,\n+ *  key_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n\nReview comment:\n       No - the (key_name, key_sequence) pair is unique, so ordering by column_name would be redundant.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-17T19:14:11.000+0000",
                    "updated": "2021-08-17T19:14:11.000+0000",
                    "started": "2021-08-17T19:14:11.000+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638839",
                    "issueId": "13381560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/638840",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kylepbit commented on a change in pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906#discussion_r690651729\n\n\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: int32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Ragne [500-1000)\n+   * Range [0-100000) is reserved for defaults. Custom options should start at 100000.\n+   *\n+   * 1. Server Information [0-500): Provides basic information about the Flight SQL Server.\n+   *\n+   * The name of the Flight SQL Server.\n+   * 0 = FLIGHT_SQL_SERVER_NAME\n+   *\n+   * The native version of the Flight SQL Server.\n+   * 1 = FLIGHT_SQL_SERVER_VERSION\n+   *\n+   * The Arrow format version of the Flight SQL Server.\n+   * 2 = FLIGHT_SQL_SERVER_ARROW_VERSION\n+   *\n+   * Indicates whether the Flight SQL Server is read only.\n+   * 3 = FLIGHT_SQL_SERVER_READ_ONLY\n+   *\n+   * 2. SQL Syntax Information [500-1000): provides information about SQL syntax supported by the Flight SQL Server.\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of catalogs.\n+   * In a SQL environment, a catalog is a collection of schemas.\n+   * 500 = SQL_DDL_CATALOG\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of schemas.\n+   * In a SQL environment, a catalog is a collection of tables, views, indexes etc.\n+   * 501 = SQL_DDL_SCHEMA\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of tables.\n+   * In a SQL environment, a table is a collection of rows of information. Each row of information\n+   * may have one or more columns of data.\n+   * 502 = SQL_DDL_TABLE\n+   *\n+   * Indicates the case sensitivity of catalog, table and schema names.\n+   * 503 = SQL_IDENTIFIER_CASE\n+   *\n+   * Indicates the supported character(s) used to surround a delimited identifier.\n+   * 504 = SQL_IDENTIFIER_QUOTE_CHAR\n+   *\n+   * Indicates case sensitivity of quoted identifiers.\n+   * 505 = SQL_QUOTED_IDENTIFIER_CASE\n+   *\n+   * If omitted, then all metadata will be retrieved.\n+   * Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must\n+   * at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved.\n+   * If additional metadata is included, the metadata IDs should start from 10,000.\n+   */\n+  repeated uint32 info = 1;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of catalogs on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name.\n+ */\n+message CommandGetCatalogs {\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of schemas on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, then schema_name.\n+ */\n+message CommandGetSchemas {\n+  /*\n+   * Specifies the Catalog to search for schemas.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, the pattern will not be used to narrow the search.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of tables, and optionally their schemas, on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  table_type: utf8,\n+ *  table_schema: bytes\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, then table_type.\n+ */\n+message CommandGetTables {\n+  /*\n+   * Specifies the Catalog to search for the tables.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, all schemas matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+\n+  /*\n+   * Specifies a filter pattern for tables to search for.\n+   * When no table_name_filter_pattern is provided, all tables matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue table_name_filter_pattern = 3;\n+\n+  // Specifies a filter of table types which must match.\n+  repeated string table_types = 4;\n+\n+  // Specifies if the schema should be returned for found tables.\n+  bool include_schema = 5;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of table types on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  table_type: utf8\n+ * >\n+ * The returned data should be ordered by table_type.\n+ */\n+message CommandGetTableTypes {\n+}\n+\n+/*\n+ * Represents a request to retrieve the primary keys of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  column_name: utf8,\n+ *  key_sequence: int,\n\nReview comment:\n       We should switch the key_name / key_sequence ordering here.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-17T19:14:34.712+0000",
                    "updated": "2021-08-17T19:14:34.712+0000",
                    "started": "2021-08-17T19:14:34.711+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638840",
                    "issueId": "13381560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/worklog/638844",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kylepbit commented on a change in pull request #10906:\nURL: https://github.com/apache/arrow/pull/10906#discussion_r690657645\n\n\n\n##########\nFile path: format/FlightSql.proto\n##########\n@@ -0,0 +1,449 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+syntax = \"proto3\";\n+import \"google/protobuf/wrappers.proto\";\n+import \"google/protobuf/descriptor.proto\";\n+\n+option java_package = \"org.apache.arrow.flight.sql.impl\";\n+package arrow.flight.protocol.sql;\n+\n+/*\n+ * Represents a metadata request. Used in the command member of FlightDescriptor\n+ * for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  info_name: uint32,\n+ *  value: dense_union<string_value: string, int_value: int32, bigint_value: int64, int32_bitmask: int32>\n+ * >\n+ * where there is one row per requested piece of metadata information.\n+ */\n+message CommandGetSqlInfo {\n+  option (experimental) = true;\n+\n+  /*\n+   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide\n+   * Flight SQL clients with basic, SQL syntax and SQL functions related information.\n+   * More information types can be added in future releases.\n+   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.\n+   *\n+   * // TODO: Flesh out the available set of metadata below.\n+   *\n+   * Initially, Flight SQL will support the following information types:\n+   * - Server Information - Range [0-500)\n+   * - Syntax Information - Range [500-1000)\n+   * Range [0-100000) is reserved for defaults. Custom options should start at 100000.\n+   *\n+   * 1. Server Information [0-500): Provides basic information about the Flight SQL Server.\n+   *\n+   * The name of the Flight SQL Server.\n+   * 0 = FLIGHT_SQL_SERVER_NAME\n+   *\n+   * The native version of the Flight SQL Server.\n+   * 1 = FLIGHT_SQL_SERVER_VERSION\n+   *\n+   * The Arrow format version of the Flight SQL Server.\n+   * 2 = FLIGHT_SQL_SERVER_ARROW_VERSION\n+   *\n+   * Indicates whether the Flight SQL Server is read only.\n+   * 3 = FLIGHT_SQL_SERVER_READ_ONLY\n+   *\n+   * 2. SQL Syntax Information [500-1000): provides information about SQL syntax supported by the Flight SQL Server.\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of catalogs.\n+   * In a SQL environment, a catalog is a collection of schemas.\n+   * 500 = SQL_DDL_CATALOG\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of schemas.\n+   * In a SQL environment, a catalog is a collection of tables, views, indexes etc.\n+   * 501 = SQL_DDL_SCHEMA\n+   *\n+   * Indicates whether the Flight SQL Server supports CREATE and DROP of tables.\n+   * In a SQL environment, a table is a collection of rows of information. Each row of information\n+   * may have one or more columns of data.\n+   * 502 = SQL_DDL_TABLE\n+   *\n+   * Indicates the case sensitivity of catalog, table and schema names.\n+   * 503 = SQL_IDENTIFIER_CASE\n+   *\n+   * Indicates the supported character(s) used to surround a delimited identifier.\n+   * 504 = SQL_IDENTIFIER_QUOTE_CHAR\n+   *\n+   * Indicates case sensitivity of quoted identifiers.\n+   * 505 = SQL_QUOTED_IDENTIFIER_CASE\n+   *\n+   * If omitted, then all metadata will be retrieved.\n+   * Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must\n+   * at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved for future use.\n+   * If additional metadata is included, the metadata IDs should start from 10,000.\n+   */\n+  repeated uint32 info = 1;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of catalogs on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name.\n+ */\n+message CommandGetCatalogs {\n+  option (experimental) = true;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of schemas on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8\n+ * >\n+ * The returned data should be ordered by catalog_name, then schema_name.\n+ */\n+message CommandGetSchemas {\n+  option (experimental) = true;\n+\n+  /*\n+   * Specifies the Catalog to search for schemas.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, the pattern will not be used to narrow the search.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of tables, and optionally their schemas, on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  table_type: utf8,\n+ *  table_schema: bytes (schema of the table as described in Schema.fbs::Schema, it is serialized as an IPC message.)\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, then table_type.\n+ */\n+message CommandGetTables {\n+  option (experimental) = true;\n+\n+  /*\n+   * Specifies the Catalog to search for the tables.\n+   * If omitted, then all catalogs are searched.\n+   */\n+  google.protobuf.StringValue catalog = 1;\n+\n+  /*\n+   * Specifies a filter pattern for schemas to search for.\n+   * When no schema_filter_pattern is provided, all schemas matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue schema_filter_pattern = 2;\n+\n+  /*\n+   * Specifies a filter pattern for tables to search for.\n+   * When no table_name_filter_pattern is provided, all tables matching other filters are searched.\n+   * In the pattern string, two special characters can be used to denote matching rules:\n+   *    - \"%\" means to match any substring with 0 or more characters.\n+   *    - \"_\" means to match any one character.\n+   */\n+  google.protobuf.StringValue table_name_filter_pattern = 3;\n+\n+  // Specifies a filter of table types which must match.\n+  repeated string table_types = 4;\n+\n+  // Specifies if the schema should be returned for found tables.\n+  bool include_schema = 5;\n+}\n+\n+/*\n+ * Represents a request to retrieve the list of table types on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  table_type: utf8\n+ * >\n+ * The returned data should be ordered by table_type.\n+ */\n+message CommandGetTableTypes {\n+  option (experimental) = true;\n+}\n+\n+/*\n+ * Represents a request to retrieve the primary keys of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  catalog_name: utf8,\n+ *  schema_name: utf8,\n+ *  table_name: utf8,\n+ *  column_name: utf8,\n+ *  key_name: utf8\n+ *  key_sequence: int,\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n+ */\n+message CommandGetPrimaryKeys {\n+  option (experimental) = true;\n+\n+  // Specifies the catalog to search for the table.\n+  google.protobuf.StringValue catalog = 1;\n+\n+  // Specifies the schema to search for the table.\n+  google.protobuf.StringValue schema = 2;\n+\n+  // Specifies the table to get the primary keys for.\n+  google.protobuf.StringValue table = 3;\n+}\n+\n+/*\n+ * Represents a request to retrieve a description of the foreign key columns that reference the given table's\n+ * primary key columns (the foreign keys exported by a table) of a table on a Flight SQL enabled backend.\n+ * Used in the command member of FlightDescriptor for the following RPC calls:\n+ *  - GetSchema: return the schema of the query.\n+ *  - GetFlightInfo: execute the catalog metadata request.\n+ *\n+ * The returned schema will be:\n+ * <\n+ *  pk_catalog_name: utf8,\n+ *  pk_schema_name: utf8,\n+ *  pk_table_name: utf8,\n+ *  pk_column_name: utf8,\n+ *  fk_catalog_name: utf8,\n+ *  fk_schema_name: utf8,\n+ *  fk_table_name: utf8,\n+ *  fk_column_name: utf8,\n+ *  key_sequence: int,\n+ *  fk_key_name: utf8,\n+ *  pk_key_name: utf8,\n+ *  update_rule: uint1,\n+ *  delete_rule: uint1\n+ * >\n+ * The returned data should be ordered by catalog_name, schema_name, table_name, key_name, then key_sequence.\n\nReview comment:\n       Should be by the fk_ variants.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-17T19:23:46.151+0000",
                    "updated": "2021-08-17T19:23:46.151+0000",
                    "started": "2021-08-17T19:23:46.151+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638844",
                    "issueId": "13381560"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/3",
            "id": "3",
            "description": "A task that needs to be done.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21148&avatarType=issuetype",
            "name": "Task",
            "subtask": false,
            "avatarId": 21148
        },
        "timespent": 73800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@28c34410[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7fb25852[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@488253a1[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@259ff22b[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@734c03ee[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@1227842b[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@48e2d295[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@12b67f08[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1765dc3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@2fde971a[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@71f69e0e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@5019e107[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 73800,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Dec 23 19:20:59 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-12-23T19:20:59.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12922/watchers",
            "watchCount": 4,
            "isWatching": false
        },
        "created": "2021-06-01T22:05:31.000+0000",
        "updated": "2022-09-13T16:52:11.000+0000",
        "timeoriginalestimate": null,
        "description": "This task is to create stubbed APIs for a Flight SQL client, server and sample application.\r\n * Contain TODOs referencing\u00a0implementation Jira tasks.\r\n * Should also be accompanied by Javadocs describing behaviour of the methods/APIs.\r\n * TODO: breakdown poc PR ....\r\n\r\n\u00a0\r\n\r\n*Acceptance Criteria*\r\n * TODO",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "20.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 73800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Java][FlightSQL] Create stubbed APIs for Flight SQL",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/comment/17378166",
                    "id": "17378166",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kylep",
                        "name": "kylep",
                        "key": "kylep",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Kyle Porter",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Work is being progressed here:\u00a0https://github.com/apache/arrow/pull/9368",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kylep",
                        "name": "kylep",
                        "key": "kylep",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Kyle Porter",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2021-07-09T16:43:05.423+0000",
                    "updated": "2021-07-09T16:43:05.423+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/comment/17396858",
                    "id": "17396858",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kylep",
                        "name": "kylep",
                        "key": "kylep",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Kyle Porter",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Work has now moved to\u00a0https://github.com/apache/arrow/pull/10906.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kylep",
                        "name": "kylep",
                        "key": "kylep",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Kyle Porter",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2021-08-10T19:48:45.840+0000",
                    "updated": "2021-08-10T19:48:45.840+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381560/comment/17464762",
                    "id": "17464762",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 12013\r\n[https://github.com/apache/arrow/pull/12013]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-12-23T19:20:59.460+0000",
                    "updated": "2021-12-23T19:20:59.460+0000"
                }
            ],
            "maxResults": 3,
            "total": 3,
            "startAt": 0
        },
        "customfield_12311820": "0|z0rkbk:",
        "customfield_12314139": null
    }
}