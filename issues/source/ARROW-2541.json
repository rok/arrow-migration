{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13157288",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13157288",
    "key": "ARROW-2541",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12342562",
                "id": "12342562",
                "description": "",
                "name": "0.10.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-08-06"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=pcmoritz",
            "name": "pcmoritz",
            "key": "pcmoritz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Philipp Moritz",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12332956",
                "id": "12332956",
                "name": "C++ - Plasma"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=pcmoritz",
            "name": "pcmoritz",
            "key": "pcmoritz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Philipp Moritz",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=pcmoritz",
            "name": "pcmoritz",
            "key": "pcmoritz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Philipp Moritz",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 1200,
            "total": 1200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 1200,
            "total": 1200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2541/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 2,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13157288/worklog/98583",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pcmoritz opened a new pull request #2001: ARROW-2541: [Plasma] Replace macros with constexpr\nURL: https://github.com/apache/arrow/pull/2001\n \n \n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-05-04T20:29:31.559+0000",
                    "updated": "2018-05-04T20:29:31.559+0000",
                    "started": "2018-05-04T20:29:31.558+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "98583",
                    "issueId": "13157288"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13157288/worklog/98695",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy closed pull request #2001: ARROW-2541: [Plasma] Replace macros with constexpr\nURL: https://github.com/apache/arrow/pull/2001\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/cpp/apidoc/tutorials/plasma.md b/cpp/apidoc/tutorials/plasma.md\nindex 8d54a10215..5a0a2ba5bd 100644\n--- a/cpp/apidoc/tutorials/plasma.md\n+++ b/cpp/apidoc/tutorials/plasma.md\n@@ -80,7 +80,7 @@ using namespace plasma;\n int main(int argc, char** argv) {\n   // Start up and connect a Plasma client.\n   PlasmaClient client;\n-  ARROW_CHECK_OK(client.Connect(\"/tmp/plasma\", \"\", PLASMA_DEFAULT_RELEASE_DELAY));\n+  ARROW_CHECK_OK(client.Connect(\"/tmp/plasma\", \"\"));\n   // Disconnect the Plasma client.\n   ARROW_CHECK_OK(client.Disconnect());\n }\n@@ -218,7 +218,7 @@ using namespace plasma;\n int main(int argc, char** argv) {\n   // Start up and connect a Plasma client.\n   PlasmaClient client;\n-  ARROW_CHECK_OK(client.Connect(\"/tmp/plasma\", \"\", PLASMA_DEFAULT_RELEASE_DELAY));\n+  ARROW_CHECK_OK(client.Connect(\"/tmp/plasma\", \"\"));\n   // Create an object with a fixed ObjectID.\n   ObjectID object_id = ObjectID::from_binary(\"00000000000000000000\");\n   int64_t data_size = 1000;\n@@ -323,7 +323,7 @@ using namespace plasma;\n int main(int argc, char** argv) {\n   // Start up and connect a Plasma client.\n   PlasmaClient client;\n-  ARROW_CHECK_OK(client.Connect(\"/tmp/plasma\", \"\", PLASMA_DEFAULT_RELEASE_DELAY));\n+  ARROW_CHECK_OK(client.Connect(\"/tmp/plasma\", \"\"));\n   ObjectID object_id = ObjectID::from_binary(\"00000000000000000000\");\n   ObjectBuffer object_buffer;\n   ARROW_CHECK_OK(client.Get(&object_id, 1, -1, &object_buffer));\n@@ -411,7 +411,7 @@ using namespace plasma;\n int main(int argc, char** argv) {\n   // Start up and connect a Plasma client.\n   PlasmaClient client;\n-  ARROW_CHECK_OK(client.Connect(\"/tmp/plasma\", \"\", PLASMA_DEFAULT_RELEASE_DELAY));\n+  ARROW_CHECK_OK(client.Connect(\"/tmp/plasma\", \"\"));\n \n   int fd;\n   ARROW_CHECK_OK(client.Subscribe(&fd));\ndiff --git a/cpp/src/plasma/client.cc b/cpp/src/plasma/client.cc\nindex b4ee0983f1..a332686a9c 100644\n--- a/cpp/src/plasma/client.cc\n+++ b/cpp/src/plasma/client.cc\n@@ -703,8 +703,8 @@ bool PlasmaClient::Impl::compute_object_hash_parallel(XXH64_state_t* hash_state,\n   const int num_threads = kThreadPoolSize;\n   uint64_t threadhash[num_threads + 1];\n   const uint64_t data_address = reinterpret_cast<uint64_t>(data);\n-  const uint64_t num_blocks = nbytes / BLOCK_SIZE;\n-  const uint64_t chunk_size = (num_blocks / num_threads) * BLOCK_SIZE;\n+  const uint64_t num_blocks = nbytes / kBlockSize;\n+  const uint64_t chunk_size = (num_blocks / num_threads) * kBlockSize;\n   const uint64_t right_address = data_address + chunk_size * num_threads;\n   const uint64_t suffix = (data_address + nbytes) - right_address;\n   // Now the data layout is | k * num_threads * block_size | suffix | ==\ndiff --git a/cpp/src/plasma/client.h b/cpp/src/plasma/client.h\nindex 4221997406..4e1ff4abb8 100644\n--- a/cpp/src/plasma/client.h\n+++ b/cpp/src/plasma/client.h\n@@ -34,7 +34,14 @@ using arrow::Status;\n \n namespace plasma {\n \n-#define PLASMA_DEFAULT_RELEASE_DELAY 64\n+ARROW_DEPRECATED(\"PLASMA_DEFAULT_RELEASE_DELAY is deprecated\")\n+constexpr int64_t kDeprecatedPlasmaDefaultReleaseDelay = 64;\n+#define PLASMA_DEFAULT_RELEASE_DELAY kDeprecatedPlasmaDefaultReleaseDelay;\n+\n+/// We keep a queue of unreleased objects cached in the client until we start\n+/// sending release requests to the store. This is to avoid frequently mapping\n+/// and unmapping objects and evicting data from processor caches.\n+constexpr int64_t kPlasmaDefaultReleaseDelay = 64;\n \n /// Object buffer data structure.\n struct ObjectBuffer {\n@@ -64,8 +71,8 @@ class ARROW_EXPORT PlasmaClient {\n   /// \\param num_retries number of attempts to connect to IPC socket, default 50\n   /// \\return The return status.\n   Status Connect(const std::string& store_socket_name,\n-                 const std::string& manager_socket_name, int release_delay,\n-                 int num_retries = -1);\n+                 const std::string& manager_socket_name,\n+                 int release_delay = kPlasmaDefaultReleaseDelay, int num_retries = -1);\n \n   /// Create an object in the Plasma Store. Any metadata for this object must be\n   /// be passed in when the object is created.\ndiff --git a/cpp/src/plasma/format/plasma.fbs b/cpp/src/plasma/format/plasma.fbs\nindex 0258cdff33..6a58fb0d58 100644\n--- a/cpp/src/plasma/format/plasma.fbs\n+++ b/cpp/src/plasma/format/plasma.fbs\n@@ -18,8 +18,10 @@\n // Plasma protocol specification\n \n enum MessageType:int {\n+  // Message that gets send when a client hangs up.\n+  PlasmaDisconnectClient = 0,\n   // Create a new object.\n-  PlasmaCreateRequest = 1,\n+  PlasmaCreateRequest,\n   PlasmaCreateReply,\n   PlasmaAbortRequest,\n   PlasmaAbortReply,\ndiff --git a/cpp/src/plasma/io.cc b/cpp/src/plasma/io.cc\nindex 4142bf9b4a..aefd297376 100644\n--- a/cpp/src/plasma/io.cc\n+++ b/cpp/src/plasma/io.cc\n@@ -24,12 +24,14 @@\n #include \"arrow/status.h\"\n \n #include \"plasma/common.h\"\n+#include \"plasma/plasma_generated.h\"\n \n using arrow::Status;\n \n-/* Number of times we try connecting to a socket. */\n-#define NUM_CONNECT_ATTEMPTS 50\n-#define CONNECT_TIMEOUT_MS 100\n+/// Number of times we try connecting to a socket.\n+constexpr int64_t kNumConnectAttempts = 50;\n+/// Time to wait between connection attempts to a socket.\n+constexpr int64_t kConnectTimeoutMs = 100;\n \n namespace plasma {\n \n@@ -38,8 +40,8 @@ Status WriteBytes(int fd, uint8_t* cursor, size_t length) {\n   size_t bytesleft = length;\n   size_t offset = 0;\n   while (bytesleft > 0) {\n-    /* While we haven't written the whole message, write to the file descriptor,\n-     * advance the cursor, and decrease the amount left to write. */\n+    // While we haven't written the whole message, write to the file descriptor,\n+    // advance the cursor, and decrease the amount left to write.\n     nbytes = write(fd, cursor + offset, bytesleft);\n     if (nbytes < 0) {\n       if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {\n@@ -58,7 +60,7 @@ Status WriteBytes(int fd, uint8_t* cursor, size_t length) {\n }\n \n Status WriteMessage(int fd, int64_t type, int64_t length, uint8_t* bytes) {\n-  int64_t version = PLASMA_PROTOCOL_VERSION;\n+  int64_t version = kPlasmaProtocolVersion;\n   RETURN_NOT_OK(WriteBytes(fd, reinterpret_cast<uint8_t*>(&version), sizeof(version)));\n   RETURN_NOT_OK(WriteBytes(fd, reinterpret_cast<uint8_t*>(&type), sizeof(type)));\n   RETURN_NOT_OK(WriteBytes(fd, reinterpret_cast<uint8_t*>(&length), sizeof(length)));\n@@ -67,7 +69,7 @@ Status WriteMessage(int fd, int64_t type, int64_t length, uint8_t* bytes) {\n \n Status ReadBytes(int fd, uint8_t* cursor, size_t length) {\n   ssize_t nbytes = 0;\n-  /* Termination condition: EOF or read 'length' bytes total. */\n+  // Termination condition: EOF or read 'length' bytes total.\n   size_t bytesleft = length;\n   size_t offset = 0;\n   while (bytesleft > 0) {\n@@ -91,20 +93,21 @@ Status ReadBytes(int fd, uint8_t* cursor, size_t length) {\n Status ReadMessage(int fd, int64_t* type, std::vector<uint8_t>* buffer) {\n   int64_t version;\n   RETURN_NOT_OK_ELSE(ReadBytes(fd, reinterpret_cast<uint8_t*>(&version), sizeof(version)),\n-                     *type = DISCONNECT_CLIENT);\n-  ARROW_CHECK(version == PLASMA_PROTOCOL_VERSION) << \"version = \" << version;\n+                     *type = MessageType_PlasmaDisconnectClient);\n+  ARROW_CHECK(version == kPlasmaProtocolVersion) << \"version = \" << version;\n   RETURN_NOT_OK_ELSE(ReadBytes(fd, reinterpret_cast<uint8_t*>(type), sizeof(*type)),\n-                     *type = DISCONNECT_CLIENT);\n+                     *type = MessageType_PlasmaDisconnectClient);\n   int64_t length_temp;\n   RETURN_NOT_OK_ELSE(\n       ReadBytes(fd, reinterpret_cast<uint8_t*>(&length_temp), sizeof(length_temp)),\n-      *type = DISCONNECT_CLIENT);\n+      *type = MessageType_PlasmaDisconnectClient);\n   // The length must be read as an int64_t, but it should be used as a size_t.\n   size_t length = static_cast<size_t>(length_temp);\n   if (length > buffer->size()) {\n     buffer->resize(length);\n   }\n-  RETURN_NOT_OK_ELSE(ReadBytes(fd, buffer->data(), length), *type = DISCONNECT_CLIENT);\n+  RETURN_NOT_OK_ELSE(ReadBytes(fd, buffer->data(), length),\n+                     *type = MessageType_PlasmaDisconnectClient);\n   return Status::OK();\n }\n \n@@ -115,7 +118,7 @@ int bind_ipc_sock(const std::string& pathname, bool shall_listen) {\n     ARROW_LOG(ERROR) << \"socket() failed for pathname \" << pathname;\n     return -1;\n   }\n-  /* Tell the system to allow the port to be reused. */\n+  // Tell the system to allow the port to be reused.\n   int on = 1;\n   if (setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<char*>(&on),\n                  sizeof(on)) < 0) {\n@@ -150,23 +153,23 @@ int bind_ipc_sock(const std::string& pathname, bool shall_listen) {\n \n Status ConnectIpcSocketRetry(const std::string& pathname, int num_retries,\n                              int64_t timeout, int* fd) {\n-  /* Pick the default values if the user did not specify. */\n+  // Pick the default values if the user did not specify.\n   if (num_retries < 0) {\n-    num_retries = NUM_CONNECT_ATTEMPTS;\n+    num_retries = kNumConnectAttempts;\n   }\n   if (timeout < 0) {\n-    timeout = CONNECT_TIMEOUT_MS;\n+    timeout = kConnectTimeoutMs;\n   }\n   *fd = connect_ipc_sock(pathname);\n   while (*fd < 0 && num_retries > 0) {\n     ARROW_LOG(ERROR) << \"Connection to IPC socket failed for pathname \" << pathname\n                      << \", retrying \" << num_retries << \" more times\";\n-    /* Sleep for timeout milliseconds. */\n+    // Sleep for timeout milliseconds.\n     usleep(static_cast<int>(timeout * 1000));\n     *fd = connect_ipc_sock(pathname);\n     --num_retries;\n   }\n-  /* If we could not connect to the socket, exit. */\n+  // If we could not connect to the socket, exit.\n   if (*fd == -1) {\n     std::stringstream ss;\n     ss << \"Could not connect to socket \" << pathname;\n@@ -215,7 +218,7 @@ std::unique_ptr<uint8_t[]> read_message_async(int sock) {\n   int64_t size;\n   Status s = ReadBytes(sock, reinterpret_cast<uint8_t*>(&size), sizeof(int64_t));\n   if (!s.ok()) {\n-    /* The other side has closed the socket. */\n+    // The other side has closed the socket.\n     ARROW_LOG(DEBUG) << \"Socket has been closed, or some other error has occurred.\";\n     close(sock);\n     return NULL;\n@@ -223,7 +226,7 @@ std::unique_ptr<uint8_t[]> read_message_async(int sock) {\n   auto message = std::unique_ptr<uint8_t[]>(new uint8_t[size]);\n   s = ReadBytes(sock, message.get(), size);\n   if (!s.ok()) {\n-    /* The other side has closed the socket. */\n+    // The other side has closed the socket.\n     ARROW_LOG(DEBUG) << \"Socket has been closed, or some other error has occurred.\";\n     close(sock);\n     return NULL;\ndiff --git a/cpp/src/plasma/io.h b/cpp/src/plasma/io.h\nindex 8869c9b8cb..f0d57c04e6 100644\n--- a/cpp/src/plasma/io.h\n+++ b/cpp/src/plasma/io.h\n@@ -30,13 +30,12 @@\n #include \"arrow/status.h\"\n #include \"plasma/compat.h\"\n \n+namespace plasma {\n+\n // TODO(pcm): Replace our own custom message header (message type,\n // message length, plasma protocol verion) with one that is serialized\n // using flatbuffers.\n-#define PLASMA_PROTOCOL_VERSION 0x0000000000000000\n-#define DISCONNECT_CLIENT 0\n-\n-namespace plasma {\n+constexpr int64_t kPlasmaProtocolVersion = 0x0000000000000000;\n \n using arrow::Status;\n \ndiff --git a/cpp/src/plasma/plasma.h b/cpp/src/plasma/plasma.h\nindex 4b4064c5b2..a1d6e99a6a 100644\n--- a/cpp/src/plasma/plasma.h\n+++ b/cpp/src/plasma/plasma.h\n@@ -36,6 +36,7 @@\n \n #include \"arrow/status.h\"\n #include \"arrow/util/logging.h\"\n+#include \"arrow/util/macros.h\"\n #include \"plasma/common.h\"\n #include \"plasma/common_generated.h\"\n \n@@ -65,7 +66,7 @@ namespace plasma {\n   } while (0);\n \n /// Allocation granularity used in plasma for object allocation.\n-#define BLOCK_SIZE 64\n+constexpr int64_t kBlockSize = 64;\n \n struct Client;\n \ndiff --git a/cpp/src/plasma/store.cc b/cpp/src/plasma/store.cc\nindex 2caa3cb65d..c06ad6ab1c 100644\n--- a/cpp/src/plasma/store.cc\n+++ b/cpp/src/plasma/store.cc\n@@ -170,7 +170,7 @@ int PlasmaStore::create_object(const ObjectID& object_id, int64_t data_size,\n     // 64-byte aligned, but in practice it often will be.\n     if (device_num == 0) {\n       pointer =\n-          reinterpret_cast<uint8_t*>(dlmemalign(BLOCK_SIZE, data_size + metadata_size));\n+          reinterpret_cast<uint8_t*>(dlmemalign(kBlockSize, data_size + metadata_size));\n       if (pointer == NULL) {\n         // Tell the eviction policy how much space we need to create this object.\n         std::vector<ObjectID> objects_to_evict;\n@@ -741,7 +741,7 @@ Status PlasmaStore::process_message(Client* client) {\n       HANDLE_SIGPIPE(SendConnectReply(client->fd, store_info_.memory_capacity),\n                      client->fd);\n     } break;\n-    case DISCONNECT_CLIENT:\n+    case MessageType_PlasmaDisconnectClient:\n       ARROW_LOG(DEBUG) << \"Disconnecting client on fd \" << client->fd;\n       disconnect_client(client->fd);\n       break;\n@@ -768,7 +768,7 @@ class PlasmaStoreRunner {\n     // achieve that by mallocing and freeing a single large amount of space.\n     // that maximum allowed size up front.\n     if (use_one_memory_mapped_file) {\n-      void* pointer = plasma::dlmemalign(BLOCK_SIZE, system_memory);\n+      void* pointer = plasma::dlmemalign(kBlockSize, system_memory);\n       ARROW_CHECK(pointer != NULL);\n       plasma::dlfree(pointer);\n     }\ndiff --git a/cpp/src/plasma/test/client_tests.cc b/cpp/src/plasma/test/client_tests.cc\nindex dad7688ba5..53743cad2d 100644\n--- a/cpp/src/plasma/test/client_tests.cc\n+++ b/cpp/src/plasma/test/client_tests.cc\n@@ -59,10 +59,8 @@ class TestPlasmaStore : public ::testing::Test {\n                                  \"/plasma_store -m 1000000000 -s /tmp/store\" +\n                                  store_index + \" 1> /dev/null 2> /dev/null &\";\n     system(plasma_command.c_str());\n-    ARROW_CHECK_OK(\n-        client_.Connect(\"/tmp/store\" + store_index, \"\", PLASMA_DEFAULT_RELEASE_DELAY));\n-    ARROW_CHECK_OK(\n-        client2_.Connect(\"/tmp/store\" + store_index, \"\", PLASMA_DEFAULT_RELEASE_DELAY));\n+    ARROW_CHECK_OK(client_.Connect(\"/tmp/store\" + store_index, \"\"));\n+    ARROW_CHECK_OK(client2_.Connect(\"/tmp/store\" + store_index, \"\"));\n   }\n   virtual void TearDown() {\n     ARROW_CHECK_OK(client_.Disconnect());\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-05-05T08:38:06.978+0000",
                    "updated": "2018-05-05T08:38:06.978+0000",
                    "started": "2018-05-05T08:38:06.978+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "98695",
                    "issueId": "13157288"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 1200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@6bfc42df[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@76024980[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@48bdc0eb[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@2c97de35[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1c2b9dfe[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@2905257e[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@f99022d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@1ded139d[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5d69b9b3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@5d4749b5[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1a08a05a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@6f0c397d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 1200,
        "customfield_12312520": null,
        "customfield_12312521": "Sat May 05 08:38:02 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-05-05T08:38:02.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2541/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2018-05-04T20:23:58.000+0000",
        "updated": "2018-07-27T15:24:30.000+0000",
        "timeoriginalestimate": null,
        "description": "There are still a lot of macros being used as constants in the plasma codebase. This should be cleaned up and replaced with constexpr (deprecating them where appropriate).",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 1200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Plasma] Clean up macro usage",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13157288/comment/16464706",
                    "id": "16464706",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "body": "Issue resolved by pull request 2001\n[https://github.com/apache/arrow/pull/2001]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "created": "2018-05-05T08:38:02.181+0000",
                    "updated": "2018-05-05T08:38:02.181+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|i3td6n:",
        "customfield_12314139": null
    }
}