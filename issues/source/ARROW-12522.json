{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13374724",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374724",
    "key": "ARROW-12522",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349983",
                "id": "12349983",
                "description": "",
                "name": "5.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-07-28"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 7800,
            "total": 7800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 7800,
            "total": 7800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12522/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 13,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374724/worklog/588110",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm opened a new pull request #10145:\nURL: https://github.com/apache/arrow/pull/10145\n\n\n   This was split out of ARROW-11883 since it may also be useful to test with ARROW-11772.\r\n   \r\n   This adds a method to get a Future<> from a ReadRangeCache so it can be easily used in an async context. Also, it adds a config flag to make the cache not perform readahead so that readahead can be handled at a different layer of the stack. \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-23T19:59:15.103+0000",
                    "updated": "2021-04-23T19:59:15.103+0000",
                    "started": "2021-04-23T19:59:15.103+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "588110",
                    "issueId": "13374724"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374724/worklog/588111",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10145:\nURL: https://github.com/apache/arrow/pull/10145#issuecomment-825887612\n\n\n   https://issues.apache.org/jira/browse/ARROW-12522\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-23T19:59:38.739+0000",
                    "updated": "2021-04-23T19:59:38.739+0000",
                    "started": "2021-04-23T19:59:38.738+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "588111",
                    "issueId": "13374724"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374724/worklog/589276",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10145:\nURL: https://github.com/apache/arrow/pull/10145#issuecomment-826905445\n\n\n   CC @westonpace if you'd like to take a look.\r\n   \r\n   There's an example of it being used to adapt the IPC reader here: https://github.com/lidavidm/arrow/commit/24f3bb10e61c9571cf3d96b54c5eddbfa9cad3a9#diff-e992169684aea9845ac776ada4cbb2b5dc711b49e5a3fbc6046c92299e1aefceR1380-R1412\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-26T15:00:21.257+0000",
                    "updated": "2021-04-26T15:00:21.257+0000",
                    "started": "2021-04-26T15:00:21.257+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "589276",
                    "issueId": "13374724"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374724/worklog/589879",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10145:\nURL: https://github.com/apache/arrow/pull/10145#discussion_r621391543\n\n\n\n##########\nFile path: cpp/src/arrow/io/caching.cc\n##########\n@@ -149,12 +174,111 @@ struct ReadRangeCache::Impl {\n     } else {\n       entries = std::move(new_entries);\n     }\n+    // Prefetch immediately, regardless of executor availability, if possible\n+    return file->WillNeed(ranges);\n+  }\n+\n+  virtual Result<std::shared_ptr<Buffer>> Read(ReadRange range) {\n+    if (range.length == 0) {\n+      static const uint8_t byte = 0;\n+      return std::make_shared<Buffer>(&byte, 0);\n+    }\n+\n+    const auto it = std::lower_bound(\n+        entries.begin(), entries.end(), range,\n+        [](const RangeCacheEntry& entry, const ReadRange& range) {\n+          return entry.range.offset + entry.range.length < range.offset + range.length;\n+        });\n+    if (it != entries.end() && it->range.Contains(range)) {\n+      auto fut = MaybeRead(&*it);\n+      ARROW_ASSIGN_OR_RAISE(auto buf, fut.result());\n+      return SliceBuffer(std::move(buf), range.offset - it->range.offset, range.length);\n+    }\n+    return Status::Invalid(\"ReadRangeCache did not find matching cache entry\");\n+  }\n+\n+  virtual Future<> Wait() {\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n+      futures.emplace_back(MaybeRead(&entry));\n+    }\n+    return AllComplete(futures);\n+  }\n+\n+  virtual Future<> WaitFor(std::vector<ReadRange> ranges) {\n+    auto end = std::remove_if(ranges.begin(), ranges.end(),\n+                              [](const ReadRange& range) { return range.length == 0; });\n+    ranges.resize(end - ranges.begin());\n+    // Sort in reverse position order\n+    std::sort(ranges.begin(), ranges.end(),\n+              [](const ReadRange& a, const ReadRange& b) { return a.offset > b.offset; });\n+\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n+      bool include = false;\n+      while (!ranges.empty()) {\n+        const auto& next = ranges.back();\n+        if (next.offset >= entry.range.offset &&\n+            next.offset + next.length <= entry.range.offset + entry.range.length) {\n+          include = true;\n+          ranges.pop_back();\n+        } else {\n+          break;\n+        }\n+      }\n+      if (include) futures.emplace_back(MaybeRead(&entry));\n+      if (ranges.empty()) break;\n+    }\n+    if (!ranges.empty()) {\n+      return Status::Invalid(\"Given ranges were not previously requested for caching\");\n+    }\n+    return AllComplete(futures);\n+  }\n+};\n+\n+// Don't read ranges when they're first added. Instead, wait until they're requested\n+// (either through Read or WaitFor).\n+struct ReadRangeCache::LazyImpl : public ReadRangeCache::Impl {\n+  // Protect against concurrent modification of entries[i]->future\n+  std::mutex entry_mutex;\n+\n+  virtual ~LazyImpl() = default;\n+\n+  Future<std::shared_ptr<Buffer>> MaybeRead(RangeCacheEntry* entry) override {\n+    if (!entry->future.is_valid()) {\n+      entry->future = file->ReadAsync(ctx, entry->range.offset, entry->range.length);\n+    }\n+    return entry->future;\n+  }\n+\n+  RangeCacheEntry Cache(const ReadRange& range) override {\n+    return {range, Future<std::shared_ptr<Buffer>>()};\n\nReview comment:\n       What fills this future?\n\n##########\nFile path: cpp/src/arrow/io/caching.cc\n##########\n@@ -149,12 +174,111 @@ struct ReadRangeCache::Impl {\n     } else {\n       entries = std::move(new_entries);\n     }\n+    // Prefetch immediately, regardless of executor availability, if possible\n+    return file->WillNeed(ranges);\n+  }\n+\n+  virtual Result<std::shared_ptr<Buffer>> Read(ReadRange range) {\n+    if (range.length == 0) {\n+      static const uint8_t byte = 0;\n+      return std::make_shared<Buffer>(&byte, 0);\n+    }\n+\n+    const auto it = std::lower_bound(\n+        entries.begin(), entries.end(), range,\n+        [](const RangeCacheEntry& entry, const ReadRange& range) {\n+          return entry.range.offset + entry.range.length < range.offset + range.length;\n+        });\n+    if (it != entries.end() && it->range.Contains(range)) {\n+      auto fut = MaybeRead(&*it);\n+      ARROW_ASSIGN_OR_RAISE(auto buf, fut.result());\n+      return SliceBuffer(std::move(buf), range.offset - it->range.offset, range.length);\n+    }\n+    return Status::Invalid(\"ReadRangeCache did not find matching cache entry\");\n+  }\n+\n+  virtual Future<> Wait() {\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n+      futures.emplace_back(MaybeRead(&entry));\n+    }\n+    return AllComplete(futures);\n+  }\n+\n+  virtual Future<> WaitFor(std::vector<ReadRange> ranges) {\n+    auto end = std::remove_if(ranges.begin(), ranges.end(),\n+                              [](const ReadRange& range) { return range.length == 0; });\n+    ranges.resize(end - ranges.begin());\n+    // Sort in reverse position order\n+    std::sort(ranges.begin(), ranges.end(),\n+              [](const ReadRange& a, const ReadRange& b) { return a.offset > b.offset; });\n+\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n+      bool include = false;\n+      while (!ranges.empty()) {\n+        const auto& next = ranges.back();\n+        if (next.offset >= entry.range.offset &&\n+            next.offset + next.length <= entry.range.offset + entry.range.length) {\n+          include = true;\n+          ranges.pop_back();\n\nReview comment:\n       Is there no case where a range will span two entries?\n\n##########\nFile path: cpp/src/arrow/io/caching.cc\n##########\n@@ -149,12 +174,111 @@ struct ReadRangeCache::Impl {\n     } else {\n       entries = std::move(new_entries);\n     }\n+    // Prefetch immediately, regardless of executor availability, if possible\n+    return file->WillNeed(ranges);\n+  }\n+\n+  virtual Result<std::shared_ptr<Buffer>> Read(ReadRange range) {\n+    if (range.length == 0) {\n+      static const uint8_t byte = 0;\n+      return std::make_shared<Buffer>(&byte, 0);\n+    }\n+\n+    const auto it = std::lower_bound(\n+        entries.begin(), entries.end(), range,\n+        [](const RangeCacheEntry& entry, const ReadRange& range) {\n+          return entry.range.offset + entry.range.length < range.offset + range.length;\n+        });\n+    if (it != entries.end() && it->range.Contains(range)) {\n+      auto fut = MaybeRead(&*it);\n+      ARROW_ASSIGN_OR_RAISE(auto buf, fut.result());\n+      return SliceBuffer(std::move(buf), range.offset - it->range.offset, range.length);\n+    }\n+    return Status::Invalid(\"ReadRangeCache did not find matching cache entry\");\n+  }\n+\n+  virtual Future<> Wait() {\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n+      futures.emplace_back(MaybeRead(&entry));\n+    }\n+    return AllComplete(futures);\n+  }\n+\n+  virtual Future<> WaitFor(std::vector<ReadRange> ranges) {\n+    auto end = std::remove_if(ranges.begin(), ranges.end(),\n+                              [](const ReadRange& range) { return range.length == 0; });\n+    ranges.resize(end - ranges.begin());\n+    // Sort in reverse position order\n+    std::sort(ranges.begin(), ranges.end(),\n+              [](const ReadRange& a, const ReadRange& b) { return a.offset > b.offset; });\n+\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n+      bool include = false;\n+      while (!ranges.empty()) {\n+        const auto& next = ranges.back();\n+        if (next.offset >= entry.range.offset &&\n+            next.offset + next.length <= entry.range.offset + entry.range.length) {\n+          include = true;\n+          ranges.pop_back();\n+        } else {\n+          break;\n+        }\n+      }\n+      if (include) futures.emplace_back(MaybeRead(&entry));\n+      if (ranges.empty()) break;\n+    }\n+    if (!ranges.empty()) {\n+      return Status::Invalid(\"Given ranges were not previously requested for caching\");\n+    }\n+    return AllComplete(futures);\n+  }\n+};\n+\n+// Don't read ranges when they're first added. Instead, wait until they're requested\n+// (either through Read or WaitFor).\n+struct ReadRangeCache::LazyImpl : public ReadRangeCache::Impl {\n+  // Protect against concurrent modification of entries[i]->future\n+  std::mutex entry_mutex;\n+\n+  virtual ~LazyImpl() = default;\n+\n+  Future<std::shared_ptr<Buffer>> MaybeRead(RangeCacheEntry* entry) override {\n+    if (!entry->future.is_valid()) {\n+      entry->future = file->ReadAsync(ctx, entry->range.offset, entry->range.length);\n+    }\n+    return entry->future;\n+  }\n+\n+  RangeCacheEntry Cache(const ReadRange& range) override {\n+    return {range, Future<std::shared_ptr<Buffer>>()};\n+  }\n+\n+  Status Cache(std::vector<ReadRange> ranges) override {\n+    std::unique_lock<std::mutex> guard(entry_mutex);\n+    return ReadRangeCache::Impl::Cache(std::move(ranges));\n\nReview comment:\n       The current `file->ReadAsync` has some leeway in it which allows the method to be synchronous if needed.  If that is the case this could end up holding onto the lock for a while.  Actually, it looks like you have guards on the `Wait`/`WaitFor` method as well so perhaps this isn't intended to be consumed by multiple threads?\r\n   \r\n   Could you maybe add a short comment explaining how you expect this class to be used (e.g. first a thread does a bunch of cache calls and then a bunch of read calls?  Or maybe there are multiple threads calling cache or read?)\n\n##########\nFile path: cpp/src/arrow/io/caching.cc\n##########\n@@ -149,12 +174,111 @@ struct ReadRangeCache::Impl {\n     } else {\n       entries = std::move(new_entries);\n     }\n+    // Prefetch immediately, regardless of executor availability, if possible\n+    return file->WillNeed(ranges);\n+  }\n+\n+  virtual Result<std::shared_ptr<Buffer>> Read(ReadRange range) {\n+    if (range.length == 0) {\n+      static const uint8_t byte = 0;\n+      return std::make_shared<Buffer>(&byte, 0);\n+    }\n+\n+    const auto it = std::lower_bound(\n+        entries.begin(), entries.end(), range,\n+        [](const RangeCacheEntry& entry, const ReadRange& range) {\n+          return entry.range.offset + entry.range.length < range.offset + range.length;\n+        });\n+    if (it != entries.end() && it->range.Contains(range)) {\n+      auto fut = MaybeRead(&*it);\n+      ARROW_ASSIGN_OR_RAISE(auto buf, fut.result());\n+      return SliceBuffer(std::move(buf), range.offset - it->range.offset, range.length);\n+    }\n+    return Status::Invalid(\"ReadRangeCache did not find matching cache entry\");\n+  }\n+\n+  virtual Future<> Wait() {\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n+      futures.emplace_back(MaybeRead(&entry));\n+    }\n+    return AllComplete(futures);\n+  }\n+\n+  virtual Future<> WaitFor(std::vector<ReadRange> ranges) {\n+    auto end = std::remove_if(ranges.begin(), ranges.end(),\n+                              [](const ReadRange& range) { return range.length == 0; });\n+    ranges.resize(end - ranges.begin());\n+    // Sort in reverse position order\n+    std::sort(ranges.begin(), ranges.end(),\n+              [](const ReadRange& a, const ReadRange& b) { return a.offset > b.offset; });\n+\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n+      bool include = false;\n+      while (!ranges.empty()) {\n+        const auto& next = ranges.back();\n+        if (next.offset >= entry.range.offset &&\n+            next.offset + next.length <= entry.range.offset + entry.range.length) {\n+          include = true;\n+          ranges.pop_back();\n+        } else {\n+          break;\n+        }\n+      }\n+      if (include) futures.emplace_back(MaybeRead(&entry));\n+      if (ranges.empty()) break;\n+    }\n+    if (!ranges.empty()) {\n+      return Status::Invalid(\"Given ranges were not previously requested for caching\");\n+    }\n+    return AllComplete(futures);\n+  }\n+};\n+\n+// Don't read ranges when they're first added. Instead, wait until they're requested\n+// (either through Read or WaitFor).\n+struct ReadRangeCache::LazyImpl : public ReadRangeCache::Impl {\n+  // Protect against concurrent modification of entries[i]->future\n+  std::mutex entry_mutex;\n+\n+  virtual ~LazyImpl() = default;\n+\n+  Future<std::shared_ptr<Buffer>> MaybeRead(RangeCacheEntry* entry) override {\n+    if (!entry->future.is_valid()) {\n+      entry->future = file->ReadAsync(ctx, entry->range.offset, entry->range.length);\n+    }\n+    return entry->future;\n+  }\n+\n+  RangeCacheEntry Cache(const ReadRange& range) override {\n+    return {range, Future<std::shared_ptr<Buffer>>()};\n+  }\n+\n+  Status Cache(std::vector<ReadRange> ranges) override {\n+    std::unique_lock<std::mutex> guard(entry_mutex);\n+    return ReadRangeCache::Impl::Cache(std::move(ranges));\n\nReview comment:\n       Adding to this, could you create a simple test case around whatever type of multithreading you expect to guard against with these mutexes?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-27T17:05:03.618+0000",
                    "updated": "2021-04-27T17:05:03.618+0000",
                    "started": "2021-04-27T17:05:03.618+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "589879",
                    "issueId": "13374724"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374724/worklog/589901",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10145:\nURL: https://github.com/apache/arrow/pull/10145#issuecomment-827784250\n\n\n   > I wonder if, given a bunch of small record batches, we might sometimes want to coalesce across record batches. I think the current design preempts that. Although I think there would be more challenges than just this tool to tackle that problem.\r\n   \r\n   So overall, the use pattern for this class is:\r\n   \r\n   1. `Cache()` all byte ranges you expect to read in the future, in the granularity that you expect to read them. So you'd call `Cache` for every record batch (IPC), or for every column chunk (Parquet).\r\n   2. `WaitFor()` the ranges that you need. For IPC, this would again be one record batch; for Parquet, this would be one row group's worth of column chunks.\r\n   3. `Read` the ranges that you need.\r\n   \r\n   Since all the byte ranges are given up front, you do get coalescing across record batches/column chunks.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-27T17:32:54.830+0000",
                    "updated": "2021-04-27T17:32:54.830+0000",
                    "started": "2021-04-27T17:32:54.829+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "589901",
                    "issueId": "13374724"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374724/worklog/589904",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm edited a comment on pull request #10145:\nURL: https://github.com/apache/arrow/pull/10145#issuecomment-827784250\n\n\n   > I wonder if, given a bunch of small record batches, we might sometimes want to coalesce across record batches. I think the current design preempts that. Although I think there would be more challenges than just this tool to tackle that problem.\r\n   \r\n   So overall, the use pattern for this class is:\r\n   \r\n   1. `Cache()` all byte ranges you expect to read in the future, in the granularity that you expect to read them. So you'd call `Cache` for every record batch (IPC), or for every column chunk (Parquet).\r\n   2. `WaitFor()` the ranges that you need. For IPC, this would again be one record batch; for Parquet, this would be one row group's worth of column chunks. This can be done in parallel/reentrantly and is why we need the lock in the lazy variant.\r\n   3. `Read` the ranges that you need.\r\n   \r\n   Since all the byte ranges are given up front, you do get coalescing across record batches/column chunks.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-27T17:35:33.876+0000",
                    "updated": "2021-04-27T17:35:33.876+0000",
                    "started": "2021-04-27T17:35:33.876+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "589904",
                    "issueId": "13374724"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374724/worklog/589907",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10145:\nURL: https://github.com/apache/arrow/pull/10145#discussion_r621443904\n\n\n\n##########\nFile path: cpp/src/arrow/io/caching.cc\n##########\n@@ -149,12 +174,111 @@ struct ReadRangeCache::Impl {\n     } else {\n       entries = std::move(new_entries);\n     }\n+    // Prefetch immediately, regardless of executor availability, if possible\n+    return file->WillNeed(ranges);\n+  }\n+\n+  virtual Result<std::shared_ptr<Buffer>> Read(ReadRange range) {\n+    if (range.length == 0) {\n+      static const uint8_t byte = 0;\n+      return std::make_shared<Buffer>(&byte, 0);\n+    }\n+\n+    const auto it = std::lower_bound(\n+        entries.begin(), entries.end(), range,\n+        [](const RangeCacheEntry& entry, const ReadRange& range) {\n+          return entry.range.offset + entry.range.length < range.offset + range.length;\n+        });\n+    if (it != entries.end() && it->range.Contains(range)) {\n+      auto fut = MaybeRead(&*it);\n+      ARROW_ASSIGN_OR_RAISE(auto buf, fut.result());\n+      return SliceBuffer(std::move(buf), range.offset - it->range.offset, range.length);\n+    }\n+    return Status::Invalid(\"ReadRangeCache did not find matching cache entry\");\n+  }\n+\n+  virtual Future<> Wait() {\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n+      futures.emplace_back(MaybeRead(&entry));\n+    }\n+    return AllComplete(futures);\n+  }\n+\n+  virtual Future<> WaitFor(std::vector<ReadRange> ranges) {\n+    auto end = std::remove_if(ranges.begin(), ranges.end(),\n+                              [](const ReadRange& range) { return range.length == 0; });\n+    ranges.resize(end - ranges.begin());\n+    // Sort in reverse position order\n+    std::sort(ranges.begin(), ranges.end(),\n+              [](const ReadRange& a, const ReadRange& b) { return a.offset > b.offset; });\n+\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n+      bool include = false;\n+      while (!ranges.empty()) {\n+        const auto& next = ranges.back();\n+        if (next.offset >= entry.range.offset &&\n+            next.offset + next.length <= entry.range.offset + entry.range.length) {\n+          include = true;\n+          ranges.pop_back();\n\nReview comment:\n       You are expected to give the ranges up front in the granularity that you expect to read them, so no. In principle it could be supported and in principle if we wanted to _split_ large ranges to take advantage of I/O parallelism we'd have to do that.\n\n##########\nFile path: cpp/src/arrow/io/caching.cc\n##########\n@@ -149,12 +174,111 @@ struct ReadRangeCache::Impl {\n     } else {\n       entries = std::move(new_entries);\n     }\n+    // Prefetch immediately, regardless of executor availability, if possible\n+    return file->WillNeed(ranges);\n+  }\n+\n+  virtual Result<std::shared_ptr<Buffer>> Read(ReadRange range) {\n+    if (range.length == 0) {\n+      static const uint8_t byte = 0;\n+      return std::make_shared<Buffer>(&byte, 0);\n+    }\n+\n+    const auto it = std::lower_bound(\n+        entries.begin(), entries.end(), range,\n+        [](const RangeCacheEntry& entry, const ReadRange& range) {\n+          return entry.range.offset + entry.range.length < range.offset + range.length;\n+        });\n+    if (it != entries.end() && it->range.Contains(range)) {\n+      auto fut = MaybeRead(&*it);\n+      ARROW_ASSIGN_OR_RAISE(auto buf, fut.result());\n+      return SliceBuffer(std::move(buf), range.offset - it->range.offset, range.length);\n+    }\n+    return Status::Invalid(\"ReadRangeCache did not find matching cache entry\");\n+  }\n+\n+  virtual Future<> Wait() {\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n+      futures.emplace_back(MaybeRead(&entry));\n+    }\n+    return AllComplete(futures);\n+  }\n+\n+  virtual Future<> WaitFor(std::vector<ReadRange> ranges) {\n+    auto end = std::remove_if(ranges.begin(), ranges.end(),\n+                              [](const ReadRange& range) { return range.length == 0; });\n+    ranges.resize(end - ranges.begin());\n+    // Sort in reverse position order\n+    std::sort(ranges.begin(), ranges.end(),\n+              [](const ReadRange& a, const ReadRange& b) { return a.offset > b.offset; });\n+\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n+      bool include = false;\n+      while (!ranges.empty()) {\n+        const auto& next = ranges.back();\n+        if (next.offset >= entry.range.offset &&\n+            next.offset + next.length <= entry.range.offset + entry.range.length) {\n+          include = true;\n+          ranges.pop_back();\n+        } else {\n+          break;\n+        }\n+      }\n+      if (include) futures.emplace_back(MaybeRead(&entry));\n+      if (ranges.empty()) break;\n+    }\n+    if (!ranges.empty()) {\n+      return Status::Invalid(\"Given ranges were not previously requested for caching\");\n+    }\n+    return AllComplete(futures);\n+  }\n+};\n+\n+// Don't read ranges when they're first added. Instead, wait until they're requested\n+// (either through Read or WaitFor).\n+struct ReadRangeCache::LazyImpl : public ReadRangeCache::Impl {\n+  // Protect against concurrent modification of entries[i]->future\n+  std::mutex entry_mutex;\n+\n+  virtual ~LazyImpl() = default;\n+\n+  Future<std::shared_ptr<Buffer>> MaybeRead(RangeCacheEntry* entry) override {\n+    if (!entry->future.is_valid()) {\n+      entry->future = file->ReadAsync(ctx, entry->range.offset, entry->range.length);\n+    }\n+    return entry->future;\n+  }\n+\n+  RangeCacheEntry Cache(const ReadRange& range) override {\n+    return {range, Future<std::shared_ptr<Buffer>>()};\n+  }\n+\n+  Status Cache(std::vector<ReadRange> ranges) override {\n+    std::unique_lock<std::mutex> guard(entry_mutex);\n+    return ReadRangeCache::Impl::Cache(std::move(ranges));\n\nReview comment:\n       Hmm. I feel that if ReadAsync is synchronous, that's because it's also very fast (e.g. in-memory copy), in which case it's not a concern. I'll document the usage pattern and both variants.\n\n##########\nFile path: cpp/src/arrow/io/caching.cc\n##########\n@@ -149,12 +174,111 @@ struct ReadRangeCache::Impl {\n     } else {\n       entries = std::move(new_entries);\n     }\n+    // Prefetch immediately, regardless of executor availability, if possible\n+    return file->WillNeed(ranges);\n+  }\n+\n+  virtual Result<std::shared_ptr<Buffer>> Read(ReadRange range) {\n+    if (range.length == 0) {\n+      static const uint8_t byte = 0;\n+      return std::make_shared<Buffer>(&byte, 0);\n+    }\n+\n+    const auto it = std::lower_bound(\n+        entries.begin(), entries.end(), range,\n+        [](const RangeCacheEntry& entry, const ReadRange& range) {\n+          return entry.range.offset + entry.range.length < range.offset + range.length;\n+        });\n+    if (it != entries.end() && it->range.Contains(range)) {\n+      auto fut = MaybeRead(&*it);\n+      ARROW_ASSIGN_OR_RAISE(auto buf, fut.result());\n+      return SliceBuffer(std::move(buf), range.offset - it->range.offset, range.length);\n+    }\n+    return Status::Invalid(\"ReadRangeCache did not find matching cache entry\");\n+  }\n+\n+  virtual Future<> Wait() {\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n+      futures.emplace_back(MaybeRead(&entry));\n+    }\n+    return AllComplete(futures);\n+  }\n+\n+  virtual Future<> WaitFor(std::vector<ReadRange> ranges) {\n+    auto end = std::remove_if(ranges.begin(), ranges.end(),\n+                              [](const ReadRange& range) { return range.length == 0; });\n+    ranges.resize(end - ranges.begin());\n+    // Sort in reverse position order\n+    std::sort(ranges.begin(), ranges.end(),\n+              [](const ReadRange& a, const ReadRange& b) { return a.offset > b.offset; });\n+\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n+      bool include = false;\n+      while (!ranges.empty()) {\n+        const auto& next = ranges.back();\n+        if (next.offset >= entry.range.offset &&\n+            next.offset + next.length <= entry.range.offset + entry.range.length) {\n+          include = true;\n+          ranges.pop_back();\n+        } else {\n+          break;\n+        }\n+      }\n+      if (include) futures.emplace_back(MaybeRead(&entry));\n+      if (ranges.empty()) break;\n+    }\n+    if (!ranges.empty()) {\n+      return Status::Invalid(\"Given ranges were not previously requested for caching\");\n+    }\n+    return AllComplete(futures);\n+  }\n+};\n+\n+// Don't read ranges when they're first added. Instead, wait until they're requested\n+// (either through Read or WaitFor).\n+struct ReadRangeCache::LazyImpl : public ReadRangeCache::Impl {\n+  // Protect against concurrent modification of entries[i]->future\n+  std::mutex entry_mutex;\n+\n+  virtual ~LazyImpl() = default;\n+\n+  Future<std::shared_ptr<Buffer>> MaybeRead(RangeCacheEntry* entry) override {\n+    if (!entry->future.is_valid()) {\n+      entry->future = file->ReadAsync(ctx, entry->range.offset, entry->range.length);\n+    }\n+    return entry->future;\n+  }\n+\n+  RangeCacheEntry Cache(const ReadRange& range) override {\n+    return {range, Future<std::shared_ptr<Buffer>>()};\n\nReview comment:\n       It's a little unclear, my bad - what'll happen is the user calls `Cache(vector<Range>)`, which coalesces the ranges and calls `Cache(Range)` for each coalesced range to make a cache entry. I'll rename the functions and clarify inline.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-27T17:39:24.421+0000",
                    "updated": "2021-04-27T17:39:24.421+0000",
                    "started": "2021-04-27T17:39:24.420+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "589907",
                    "issueId": "13374724"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374724/worklog/589909",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10145:\nURL: https://github.com/apache/arrow/pull/10145#discussion_r621453153\n\n\n\n##########\nFile path: cpp/src/arrow/io/caching.cc\n##########\n@@ -149,12 +174,111 @@ struct ReadRangeCache::Impl {\n     } else {\n       entries = std::move(new_entries);\n     }\n+    // Prefetch immediately, regardless of executor availability, if possible\n+    return file->WillNeed(ranges);\n+  }\n+\n+  virtual Result<std::shared_ptr<Buffer>> Read(ReadRange range) {\n+    if (range.length == 0) {\n+      static const uint8_t byte = 0;\n+      return std::make_shared<Buffer>(&byte, 0);\n+    }\n+\n+    const auto it = std::lower_bound(\n+        entries.begin(), entries.end(), range,\n+        [](const RangeCacheEntry& entry, const ReadRange& range) {\n+          return entry.range.offset + entry.range.length < range.offset + range.length;\n+        });\n+    if (it != entries.end() && it->range.Contains(range)) {\n+      auto fut = MaybeRead(&*it);\n+      ARROW_ASSIGN_OR_RAISE(auto buf, fut.result());\n+      return SliceBuffer(std::move(buf), range.offset - it->range.offset, range.length);\n+    }\n+    return Status::Invalid(\"ReadRangeCache did not find matching cache entry\");\n+  }\n+\n+  virtual Future<> Wait() {\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n+      futures.emplace_back(MaybeRead(&entry));\n+    }\n+    return AllComplete(futures);\n+  }\n+\n+  virtual Future<> WaitFor(std::vector<ReadRange> ranges) {\n+    auto end = std::remove_if(ranges.begin(), ranges.end(),\n+                              [](const ReadRange& range) { return range.length == 0; });\n+    ranges.resize(end - ranges.begin());\n+    // Sort in reverse position order\n+    std::sort(ranges.begin(), ranges.end(),\n+              [](const ReadRange& a, const ReadRange& b) { return a.offset > b.offset; });\n+\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n+      bool include = false;\n+      while (!ranges.empty()) {\n+        const auto& next = ranges.back();\n+        if (next.offset >= entry.range.offset &&\n+            next.offset + next.length <= entry.range.offset + entry.range.length) {\n+          include = true;\n+          ranges.pop_back();\n+        } else {\n+          break;\n+        }\n+      }\n+      if (include) futures.emplace_back(MaybeRead(&entry));\n+      if (ranges.empty()) break;\n+    }\n+    if (!ranges.empty()) {\n+      return Status::Invalid(\"Given ranges were not previously requested for caching\");\n+    }\n+    return AllComplete(futures);\n+  }\n+};\n+\n+// Don't read ranges when they're first added. Instead, wait until they're requested\n+// (either through Read or WaitFor).\n+struct ReadRangeCache::LazyImpl : public ReadRangeCache::Impl {\n+  // Protect against concurrent modification of entries[i]->future\n+  std::mutex entry_mutex;\n+\n+  virtual ~LazyImpl() = default;\n+\n+  Future<std::shared_ptr<Buffer>> MaybeRead(RangeCacheEntry* entry) override {\n+    if (!entry->future.is_valid()) {\n+      entry->future = file->ReadAsync(ctx, entry->range.offset, entry->range.length);\n+    }\n+    return entry->future;\n+  }\n+\n+  RangeCacheEntry Cache(const ReadRange& range) override {\n+    return {range, Future<std::shared_ptr<Buffer>>()};\n+  }\n+\n+  Status Cache(std::vector<ReadRange> ranges) override {\n+    std::unique_lock<std::mutex> guard(entry_mutex);\n+    return ReadRangeCache::Impl::Cache(std::move(ranges));\n\nReview comment:\n       Or put another way, (when `lazy == true`) this 'passes through' the synchronicity of ReadAsync (an oxymoron if there ever was one), which is the intent.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-27T17:48:11.361+0000",
                    "updated": "2021-04-27T17:48:11.361+0000",
                    "started": "2021-04-27T17:48:11.360+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "589909",
                    "issueId": "13374724"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374724/worklog/590208",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10145:\nURL: https://github.com/apache/arrow/pull/10145#discussion_r621949530\n\n\n\n##########\nFile path: cpp/src/arrow/io/caching.cc\n##########\n@@ -149,12 +177,117 @@ struct ReadRangeCache::Impl {\n     } else {\n       entries = std::move(new_entries);\n     }\n+    // Prefetch immediately, regardless of executor availability, if possible\n+    return file->WillNeed(ranges);\n+  }\n+\n+  // Read the given range from the cache, blocking if needed. Cannot read a range\n+  // that spans cache entries.\n+  virtual Result<std::shared_ptr<Buffer>> Read(ReadRange range) {\n+    if (range.length == 0) {\n+      static const uint8_t byte = 0;\n+      return std::make_shared<Buffer>(&byte, 0);\n+    }\n+\n+    const auto it = std::lower_bound(\n+        entries.begin(), entries.end(), range,\n+        [](const RangeCacheEntry& entry, const ReadRange& range) {\n+          return entry.range.offset + entry.range.length < range.offset + range.length;\n+        });\n+    if (it != entries.end() && it->range.Contains(range)) {\n+      auto fut = MaybeRead(&*it);\n+      ARROW_ASSIGN_OR_RAISE(auto buf, fut.result());\n+      return SliceBuffer(std::move(buf), range.offset - it->range.offset, range.length);\n+    }\n+    return Status::Invalid(\"ReadRangeCache did not find matching cache entry\");\n+  }\n+\n+  virtual Future<> Wait() {\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n+      futures.emplace_back(MaybeRead(&entry));\n+    }\n+    return AllComplete(futures);\n+  }\n+\n+  // Return a Future that completes when the given ranges have been read.\n+  virtual Future<> WaitFor(std::vector<ReadRange> ranges) {\n+    auto end = std::remove_if(ranges.begin(), ranges.end(),\n+                              [](const ReadRange& range) { return range.length == 0; });\n+    ranges.resize(end - ranges.begin());\n+    // Sort in reverse position order\n+    std::sort(ranges.begin(), ranges.end(),\n+              [](const ReadRange& a, const ReadRange& b) { return a.offset > b.offset; });\n+\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n\nReview comment:\n       This algorithm looks a bit unexpected to me. Basically, you're iterating all known entries in the hope that they might match a requested range? It will be a bit costly if the number of entries is much larger than the number of requested ranges, since you may iterate all entries.\r\n   \r\n   Why not do the converse? For each requested range, try to find it in the existing entries. It is doable using bisection (see `Read` above), and you shouldn't need to sort the requested ranges.\n\n##########\nFile path: cpp/src/arrow/io/memory_test.cc\n##########\n@@ -692,10 +694,24 @@ TEST(CoalesceReadRanges, Basics) {\n         {{110, 21}, {140, 100}, {240, 31}});\n }\n \n+class CountingBufferReader : public BufferReader {\n+ public:\n+  using BufferReader::BufferReader;\n+  Future<std::shared_ptr<Buffer>> ReadAsync(const IOContext& context, int64_t position,\n+                                            int64_t nbytes) override {\n+    read_count_++;\n+    return BufferReader::ReadAsync(context, position, nbytes);\n+  }\n+  int64_t read_count() const { return read_count_; }\n+\n+ private:\n+  int64_t read_count_ = 0;\n+};\n+\n TEST(RangeReadCache, Basics) {\n   std::string data = \"abcdefghijklmnopqrstuvwxyz\";\n \n-  auto file = std::make_shared<BufferReader>(Buffer(data));\n+  auto file = std::make_shared<CountingBufferReader>(Buffer(data));\n\nReview comment:\n       Should you test both lazy and non-lazy versions here?\n\n##########\nFile path: cpp/src/arrow/io/caching.cc\n##########\n@@ -139,8 +147,28 @@ struct ReadRangeCache::Impl {\n   // Ordered by offset (so as to find a matching region by binary search)\n   std::vector<RangeCacheEntry> entries;\n \n-  // Add new entries, themselves ordered by offset\n-  void AddEntries(std::vector<RangeCacheEntry> new_entries) {\n+  virtual ~Impl() = default;\n+\n+  // Get the future corresponding to a range\n+  virtual Future<std::shared_ptr<Buffer>> MaybeRead(RangeCacheEntry* entry) {\n+    return entry->future;\n+  }\n+\n+  // Make a cache entry for a range\n+  virtual RangeCacheEntry MakeCacheEntry(const ReadRange& range) {\n\nReview comment:\n       You may make this `std::vector<RangeCacheEntry> MakeCacheEntries(const std::vector<ReadRange>&)` instead and you will issue one virtual call instead of N.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-28T08:50:06.285+0000",
                    "updated": "2021-04-28T08:50:06.285+0000",
                    "started": "2021-04-28T08:50:06.285+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "590208",
                    "issueId": "13374724"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374724/worklog/590356",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10145:\nURL: https://github.com/apache/arrow/pull/10145#discussion_r622145095\n\n\n\n##########\nFile path: cpp/src/arrow/io/caching.cc\n##########\n@@ -149,12 +177,117 @@ struct ReadRangeCache::Impl {\n     } else {\n       entries = std::move(new_entries);\n     }\n+    // Prefetch immediately, regardless of executor availability, if possible\n+    return file->WillNeed(ranges);\n+  }\n+\n+  // Read the given range from the cache, blocking if needed. Cannot read a range\n+  // that spans cache entries.\n+  virtual Result<std::shared_ptr<Buffer>> Read(ReadRange range) {\n+    if (range.length == 0) {\n+      static const uint8_t byte = 0;\n+      return std::make_shared<Buffer>(&byte, 0);\n+    }\n+\n+    const auto it = std::lower_bound(\n+        entries.begin(), entries.end(), range,\n+        [](const RangeCacheEntry& entry, const ReadRange& range) {\n+          return entry.range.offset + entry.range.length < range.offset + range.length;\n+        });\n+    if (it != entries.end() && it->range.Contains(range)) {\n+      auto fut = MaybeRead(&*it);\n+      ARROW_ASSIGN_OR_RAISE(auto buf, fut.result());\n+      return SliceBuffer(std::move(buf), range.offset - it->range.offset, range.length);\n+    }\n+    return Status::Invalid(\"ReadRangeCache did not find matching cache entry\");\n+  }\n+\n+  virtual Future<> Wait() {\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n+      futures.emplace_back(MaybeRead(&entry));\n+    }\n+    return AllComplete(futures);\n+  }\n+\n+  // Return a Future that completes when the given ranges have been read.\n+  virtual Future<> WaitFor(std::vector<ReadRange> ranges) {\n+    auto end = std::remove_if(ranges.begin(), ranges.end(),\n+                              [](const ReadRange& range) { return range.length == 0; });\n+    ranges.resize(end - ranges.begin());\n+    // Sort in reverse position order\n+    std::sort(ranges.begin(), ranges.end(),\n+              [](const ReadRange& a, const ReadRange& b) { return a.offset > b.offset; });\n+\n+    std::vector<Future<>> futures;\n+    for (auto& entry : entries) {\n\nReview comment:\n       Thanks, I've changed the implementation. This is definitely better (avoids a sort and since # ranges is likely << # entries, it's ~O(log(# entries)) instead of ~O(# entries)).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-28T12:48:51.046+0000",
                    "updated": "2021-04-28T12:48:51.046+0000",
                    "started": "2021-04-28T12:48:51.046+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "590356",
                    "issueId": "13374724"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374724/worklog/590371",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10145:\nURL: https://github.com/apache/arrow/pull/10145#issuecomment-828432437\n\n\n   Ah, I should backport a fix from https://github.com/apache/arrow/pull/10074/commits/ba7ba9e522bdb211cfdf731bac2d83ae493d24a3 as well. (The coalescer didn't handle completely-overlapping ranges which the Parquet reader can generate when reading a 0-row file.)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-28T12:56:14.106+0000",
                    "updated": "2021-04-28T12:56:14.106+0000",
                    "started": "2021-04-28T12:56:14.105+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "590371",
                    "issueId": "13374724"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374724/worklog/590997",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10145:\nURL: https://github.com/apache/arrow/pull/10145#issuecomment-829250661\n\n\n   This should be ready again; I've incorporated the feedback + added a fix for ranges that are completely identical (which the Parquet reader can generate if there's 0 rows).\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-29T13:44:58.759+0000",
                    "updated": "2021-04-29T13:44:58.759+0000",
                    "started": "2021-04-29T13:44:58.759+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "590997",
                    "issueId": "13374724"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374724/worklog/592774",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou closed pull request #10145:\nURL: https://github.com/apache/arrow/pull/10145\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-04T14:43:23.726+0000",
                    "updated": "2021-05-04T14:43:23.726+0000",
                    "started": "2021-05-04T14:43:23.725+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "592774",
                    "issueId": "13374724"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 7800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@2865a525[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1201c776[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@de9a5a8[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@11cfe914[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5ac51d48[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@51c6db41[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1142f034[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@7fab3c41[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@d7641a1[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@6a0d9f9d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6cc811b8[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4aa77154[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 7800,
        "customfield_12312520": null,
        "customfield_12312521": "Tue May 04 14:43:09 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-05-04T14:43:09.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12522/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-04-23T19:55:36.000+0000",
        "updated": "2021-05-04T14:43:24.000+0000",
        "timeoriginalestimate": null,
        "description": "Currently ReadRangeCache performs both readahead and coalescing. Also, it exposes primarily a blocking API. Two improvements would be useful for implementing async-generator versions of file readers:\r\n * A method to get a Future<> for a set of read ranges, so that you can asynchronously wait for ranges to be read instead of attempting to read and getting blocked\r\n * A way to make the cache not perform readahead, so that data is fetched only when requested. (Then, consumers could handle readahead by making multiple requests to the cache.)\r\n\r\nThe cache would still act as an actual cache and would still coalesce. (A further improvement might be to allow discarding cache entries. For the purpose of getting AsyncGenerator<RecordBatch>, we don't need a range more than once, so the cache is just wasting memory.)\r\n\r\nThis makes it straightforward to adapt synchronous readers into asynchronous ones so long as you know the read ranges up front; you can then cache all the ranges, call WaitFor<>, then hand the buffer to the existing synchronous reader.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 7800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Implement asynchronous/\"lazy\" variants of ReadRangeCache",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374724/comment/17339046",
                    "id": "17339046",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 10145\n[https://github.com/apache/arrow/pull/10145]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-05-04T14:43:09.475+0000",
                    "updated": "2021-05-04T14:43:09.475+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0qe8o:",
        "customfield_12314139": null
    }
}