{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13100187",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187",
    "key": "ARROW-1474",
    "fields": {
        "parent": {
            "id": "13099860",
            "key": "ARROW-1463",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860",
            "fields": {
                "summary": "[JAVA] Restructure ValueVector hierarchy to minimize compile-time generated code",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                    "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                    "name": "Resolved",
                    "id": "5",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                    "id": "4",
                    "description": "An improvement or enhancement to an existing feature or task.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                    "name": "Improvement",
                    "subtask": false,
                    "avatarId": 21140
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12341352",
                "id": "12341352",
                "name": "0.8.0",
                "archived": false,
                "released": true,
                "releaseDate": "2017-12-18"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": null,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=siddteotia",
            "name": "siddteotia",
            "key": "siddteotia",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=siddteotia&avatarId=32343",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=siddteotia&avatarId=32343",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=siddteotia&avatarId=32343",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=siddteotia&avatarId=32343"
            },
            "displayName": "Siddharth Teotia",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328933",
                "id": "12328933",
                "name": "Java"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": null,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
            "name": "jnadeau",
            "key": "jnadeau",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Jacques Nadeau",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
            "name": "jnadeau",
            "key": "jnadeau",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Jacques Nadeau",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1474/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 0,
            "worklogs": []
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": null,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@403379f3[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4b747ca8[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@11bf0bb4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@79c6a417[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5c92fbbf[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@567fa07f[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3f74f3af[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@735e0e4a[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@385a5c9d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@130d6fb1[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@b7c1ff4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@8536c8f[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": null,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Oct 24 00:42:48 UTC 2017",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2017-10-24T00:42:48.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1474/watchers",
            "watchCount": 4,
            "isWatching": false
        },
        "created": "2017-09-06T15:35:11.000+0000",
        "updated": "2019-06-03T12:51:17.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {},
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[JAVA] ValueVector hierarchy (Implementation Phase 2)",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16204754",
                    "id": "16204754",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=siddteotia",
                        "name": "siddteotia",
                        "key": "siddteotia",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=siddteotia&avatarId=32343",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=siddteotia&avatarId=32343",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=siddteotia&avatarId=32343",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=siddteotia&avatarId=32343"
                        },
                        "displayName": "Siddharth Teotia",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "A patch with implementation for other scalar types is in progress along with creating their legacy counterparts (mutator/accessor based)\r\n\r\n* NullableBigIntVector\r\n* NullableFloat4Vector\r\n* NullableFloat8Vector\r\n* NullableUInt1Vector\r\n* NullableUInt2Vector\r\n* NullableUInt4Vector\r\n* NullableUInt8Vector\r\n* Nullable <all date types> vector\r\n\r\n\r\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=siddteotia",
                        "name": "siddteotia",
                        "key": "siddteotia",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=siddteotia&avatarId=32343",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=siddteotia&avatarId=32343",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=siddteotia&avatarId=32343",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=siddteotia&avatarId=32343"
                        },
                        "displayName": "Siddharth Teotia",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-14T17:35:53.140+0000",
                    "updated": "2017-10-14T17:35:53.140+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16205531",
                    "id": "16205531",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "GitHub user siddharthteotia opened a pull request:\n\n    https://github.com/apache/arrow/pull/1203\n\n    ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\n\n    Implementation of majority of scalar types:\r\n    \r\n    Few timestamp types and Nullable Var Binary are in progress along with ListVector, MapVector, FixedSizeListVector\r\n    \r\n    cc @jacques-n , @BryanCutler , @icexelloss \n\nYou can merge this pull request into a Git repository by running:\n\n    $ git pull https://github.com/siddharthteotia/arrow ARROW-1474\n\nAlternatively you can review and apply these changes as the patch at:\n\n    https://github.com/apache/arrow/pull/1203.patch\n\nTo close this pull request, make a commit to your master/trunk branch\nwith (at least) the following in the commit message:\n\n    This closes #1203\n    \n----\ncommit edf9acca66e9001ee2673e3973d27dc172d33713\nAuthor: siddharth <siddharth@dremio.com>\nDate:   2017-10-16T07:39:30Z\n\n    ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\n\n----\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-16T07:47:53.336+0000",
                    "updated": "2017-10-16T07:47:53.336+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16206849",
                    "id": "16206849",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user siddharthteotia commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    @BryanCutler,\r\n    \r\n    I have addressed most of your general comments. Few points on remaining comments\r\n    \r\n    **(1) Regarding Logger** - I had added this as a TODO in my previous patch. The thing is that we really don't log much. We only log in the base class during realloc and alloc functions where there is a chance of catching memory related exceptions. So I have been contemplating if we really need logging. It's more of an unnecessary heap overhead.\r\n    \r\n    The reason I initialize the specific logger in each subclass is because when the super class methods dump out log messages we can see which exact vector type the messages correspond to.\r\n    \r\n    But again, since we barely log messages, I think we are better off not having any logging at all. You can take a look at BaseNullableFixedWidthVector and see what you think. Can we afford no logging?\r\n    \r\n    https://github.com/apache/arrow/commit/60a2ebdfc9164d2405f9656030dedfbf789997b5#diff-dddca025d8d6792d8776d3c59ce508f7R270 \r\n    \r\n    (2) **Regarding FieldReader** -- I think you are right. When we are working with a vector type, we have enough information available to create the reader on demand as opposed to carrying the FieldReader object inside each vector. Is this what you were suggesting? \r\n    \r\n    However, we may have to see the impact of changes. This is definitely doable but we will have to refactor code in map, list and union vectors where when they read nested scalar vectors, they can no longer make a call to getReader().\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-17T00:53:15.860+0000",
                    "updated": "2017-10-17T00:53:15.860+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16207144",
                    "id": "16207144",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user siddharthteotia commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    All scalar types refactored and new implementation is ready -- builds fine. Corresponding Legacy vectors are also ready.\r\n    Testing has issues w.r.t mutator/accessor in LIST, MAP, UNION. Next step is to refactor them.\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-17T07:59:31.771+0000",
                    "updated": "2017-10-17T07:59:31.771+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16208252",
                    "id": "16208252",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user icexelloss commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    Thanks @siddharthteotia. I went through the change and left a few comments.\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-17T20:11:02.821+0000",
                    "updated": "2017-10-17T20:11:02.821+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16208258",
                    "id": "16208258",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user jacques-n commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    @BryanCutler and @siddharthteotia , the reason the vector holders a reference to ArrowReader is that there are several cases where you don't want to constantly be recreating the reader and at the time, this was the easiest place to maintain it. Not sure if this still the case but it is something that should be reviewed before removing.\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-17T20:16:28.418+0000",
                    "updated": "2017-10-17T20:16:28.418+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16208553",
                    "id": "16208553",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user BryanCutler commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    @siddharthteotia , regarding the logger can you specific vector logs by moving to the base class and initializing the logger with the class name as a string, e.g. `getLogger(this.getClass().getSimpleName());`?\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-17T23:00:54.138+0000",
                    "updated": "2017-10-17T23:00:54.138+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16208649",
                    "id": "16208649",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user siddharthteotia commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    Thanks for the thorough review @jacques-n , @BryanCutler , @icexelloss , @wesm . I am in the process of addressing comments as we are reaching consensus. Meanwhile, I am trying to prioritize stability of tests. \r\n    \r\n    Right now we have 2 related failures in ComplexWriter, Promotable Writer and lots of failures in TestJsonFile since getFieldInnerVectors is no longer applicable. I am addressing the former ones as of now.\r\n    \r\n    The recent commit has refactored complex types -- LIST, FIXED SIZE LIST, MAP, UNION along with corresponding Legacy types and code changes in the callers to make things work.\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-18T00:35:12.355+0000",
                    "updated": "2017-10-18T00:35:12.355+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16208669",
                    "id": "16208669",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user jacques-n commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    @BryanCutler, for the logger we discussed that internally (@siddharthteotia and I) and should have posted the thoughts here. Basically, the downside is additional heap bloat since each instance has to hold a reference to the logger (as opposed to be a constant). We thought it wasn't worth the cost.\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-18T01:01:40.784+0000",
                    "updated": "2017-10-18T01:01:40.784+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16209937",
                    "id": "16209937",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user icexelloss commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    @siddharthteotia I also found the new files are 3-space indented. The current files are 2-space indented. Please fix the indentation?\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-18T20:07:29.155+0000",
                    "updated": "2017-10-18T20:07:29.155+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16210018",
                    "id": "16210018",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user wesm commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    Is this style issue being checked in Travis CI?\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-18T20:57:28.226+0000",
                    "updated": "2017-10-18T20:57:28.226+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16210108",
                    "id": "16210108",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user icexelloss commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    Probably not. I fixed some checkstyles warning  but not all of them:\r\n    https://github.com/apache/arrow/pull/930#issuecomment-319492008\r\n    \r\n    So we cannot failure the build for checkstyles yet.\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-18T21:54:10.732+0000",
                    "updated": "2017-10-18T21:54:10.732+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16210356",
                    "id": "16210356",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user wesm commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    I opened https://issues.apache.org/jira/browse/ARROW-1688. We must keep our code clean\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-19T00:08:52.487+0000",
                    "updated": "2017-10-19T00:08:52.487+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16210834",
                    "id": "16210834",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user siddharthteotia commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    @jacques-n , @BryanCutler , @icexelloss \r\n    \r\n    - Addressed issues in JsonFileReader and JsonFileWriter. Quite some work was needed here because getFieldInnerVectors is not applicable anymore. I have introduced static methods in vectors as helper routines for reading from and writing into JSON.\r\n    \r\n    - Removed logger from all vectors.\r\n    \r\n    - Addressed failures in tests. Down to one failure now.\r\n    \r\n    Remaining:\r\n    \r\n    - I haven't yet removed the inner vectors from List. Will do that tomorrow.\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-19T10:16:15.003+0000",
                    "updated": "2017-10-19T10:16:15.003+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16211394",
                    "id": "16211394",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user BryanCutler commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    I looked at JSONfile reader/writer and looks good from what I can tell so far, just some minor style comments\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-19T17:28:43.144+0000",
                    "updated": "2017-10-19T17:28:43.144+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16211945",
                    "id": "16211945",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user siddharthteotia commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    The latest commit addresses some recent review comments and removes the inner vectors from LIST. I guess we are left with Implementing Timestamp vectors as suggested above -- https://github.com/apache/arrow/pull/1203#discussion_r145286430\r\n    I will get going with it unless there are other specific concerns (modulo indentation etc)\r\n\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-19T23:57:12.351+0000",
                    "updated": "2017-10-19T23:57:12.351+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16211987",
                    "id": "16211987",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user siddharthteotia commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    All tests run clean with latest commit.\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-20T00:41:17.910+0000",
                    "updated": "2017-10-20T00:41:17.910+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16212131",
                    "id": "16212131",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user icexelloss commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    Thanks @siddharthteotia. I will find some time to review this tomorrow.\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-20T04:14:33.234+0000",
                    "updated": "2017-10-20T04:14:33.234+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16213062",
                    "id": "16213062",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user siddharthteotia commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    @jacques-n , @BryanCutler , @icexelloss \r\n    \r\n    The latest commit addresses the changes suggested w.r.t timestamp vector hierarchy. The concrete timestamp classes now have only holder specific methods. \r\n    \r\n    Adjusted license headers for consistency.\r\n    \r\n    All tests run clean.\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-20T19:01:09.653+0000",
                    "updated": "2017-10-20T19:01:09.653+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16213214",
                    "id": "16213214",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user icexelloss commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    @siddharthteotia I went through the change and left some comments. I haven't  read all your reply yet but I will do it later. (Have to go now)\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-20T20:55:27.366+0000",
                    "updated": "2017-10-20T20:55:27.366+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214126",
                    "id": "16214126",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user siddharthteotia commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    @jacques-n , @BryanCutler , @icexelloss \r\n    \r\n    - All code changes done. \r\n    \r\n    - Tests run clean with latest commit (note all commits are now squashed)\r\n    \r\n    I will review the code tonight primarily for adding JavaDocs, comments and any review comments that we haven't got a closure on.\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-21T23:07:52.681+0000",
                    "updated": "2017-10-21T23:07:52.681+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214128",
                    "id": "16214128",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Github user siddharthteotia commented on the issue:\n\n    https://github.com/apache/arrow/pull/1203\n  \n    I have added some new tests too but will file follow-up JIRAs to improve our test suite going forward.\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-21T23:11:15.806+0000",
                    "updated": "2017-10-21T23:11:15.806+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214525",
                    "id": "16214525",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#discussion_r146154778\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/BaseRepeatedValueVector.java\n ##########\n @@ -187,54 +227,58 @@ protected void replaceDataVector(FieldVector v) {\n     vector = v;\n   }\n \n-  public abstract class BaseRepeatedAccessor extends BaseValueVector.BaseAccessor implements RepeatedAccessor {\n \n-    @Override\n-    public int getValueCount() {\n-      return Math.max(offsets.getAccessor().getValueCount() - 1, 0);\n-    }\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n \n-    @Override\n-    public int getInnerValueCount() {\n-      return vector.getAccessor().getValueCount();\n-    }\n+  /* returns the value count for inner data vector for this list vector */\n+  public int getInnerValueCount() {\n+    return vector.getValueCount();\n+  }\n \n-    @Override\n-    public int getInnerValueCountAt(int index) {\n-      return offsets.getAccessor().get(index + 1) - offsets.getAccessor().get(index);\n-    }\n \n-    @Override\n-    public boolean isNull(int index) {\n-      return false;\n-    }\n+  /* returns the value count for inner data vector at a particular index */\n+  public int getInnerValueCountAt(int index) {\n+    return offsetBuffer.getInt((index + 1) * OFFSET_WIDTH) -\n+            offsetBuffer.getInt(index * OFFSET_WIDTH);\n+  }\n \n-    @Override\n-    public boolean isEmpty(int index) {\n-      return false;\n-    }\n+  public boolean isNull(int index) {\n+    return false;\n   }\n \n-  public abstract class BaseRepeatedMutator extends BaseValueVector.BaseMutator implements RepeatedMutator {\n+  public boolean isEmpty(int index) {\n+    return false;\n+  }\n \n-    @Override\n-    public int startNewValue(int index) {\n-      while (offsets.getValueCapacity() <= index) {\n-        offsets.reAlloc();\n-      }\n-      int offset = offsets.getAccessor().get(index);\n-      offsets.getMutator().setSafe(index + 1, offset);\n-      setValueCount(index + 1);\n-      return offset;\n+  public int startNewValue(int index) {\n+    while (index >= getOffsetBufferValueCapacity()) {\n+      reallocOffsetBuffer();\n     }\n+    int offset = offsetBuffer.getInt(index * OFFSET_WIDTH);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, offset);\n+    setValueCount(index + 1);\n+    return offset;\n+  }\n \n-    @Override\n-    public void setValueCount(int valueCount) {\n-      // TODO: populate offset end points\n-      offsets.getMutator().setValueCount(valueCount == 0 ? 0 : valueCount + 1);\n-      final int childValueCount = valueCount == 0 ? 0 : offsets.getAccessor().get(valueCount);\n-      vector.getMutator().setValueCount(childValueCount);\n+  public void setValueCount(int valueCount) {\n+    // TODO: populate offset end points\n \n Review comment:\n   Can we maybe remove it then?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T02:05:52.213+0000",
                    "updated": "2017-10-23T02:05:52.213+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214526",
                    "id": "16214526",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#discussion_r146154853\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\n ##########\n @@ -55,14 +58,12 @@ public static ListVector empty(String name, BufferAllocator allocator) {\n     return new ListVector(name, allocator, FieldType.nullable(ArrowType.List.INSTANCE), null);\n   }\n \n-  final UInt4Vector offsets;\n-  final BitVector bits;\n-  private final List<BufferBacked> innerVectors;\n-  private Mutator mutator = new Mutator();\n-  private Accessor accessor = new Accessor();\n+  private ArrowBuf validityBuffer;\n \n Review comment:\n   Ok. This is fine.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T02:07:09.099+0000",
                    "updated": "2017-10-23T02:07:09.099+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214527",
                    "id": "16214527",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#discussion_r146154884\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\n ##########\n @@ -55,14 +58,12 @@ public static ListVector empty(String name, BufferAllocator allocator) {\n     return new ListVector(name, allocator, FieldType.nullable(ArrowType.List.INSTANCE), null);\n   }\n \n-  final UInt4Vector offsets;\n-  final BitVector bits;\n-  private final List<BufferBacked> innerVectors;\n-  private Mutator mutator = new Mutator();\n-  private Accessor accessor = new Accessor();\n+  private ArrowBuf validityBuffer;\n   private UnionListReader reader;\n   private CallBack callBack;\n   private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+  private int lastSet;\n \n Review comment:\n   Ok this is fine.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T02:07:46.403+0000",
                    "updated": "2017-10-23T02:07:46.403+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214535",
                    "id": "16214535",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#discussion_r146155339\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/NullableMapVector.java\n ##########\n @@ -60,9 +60,6 @@ public static NullableMapVector empty(String name, BufferAllocator allocator) {\n \n   private final List<BufferBacked> innerVectors;\n \n-  private final Accessor accessor;\n-  private final Mutator mutator;\n-\n   // deprecated, use FieldType or static constructor instead\n   @Deprecated\n   public NullableMapVector(String name, BufferAllocator allocator, CallBack callBack) {\n \n Review comment:\n   track in ARROW-1710\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T02:15:12.045+0000",
                    "updated": "2017-10-23T02:15:12.045+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214539",
                    "id": "16214539",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#discussion_r146155849\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BitVectorHelper.java\n ##########\n @@ -19,24 +19,25 @@\n package org.apache.arrow.vector;\n \n import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n \n-class BitVectorHelper {\n+public class BitVectorHelper {\n \n Review comment:\n   I see. In that case, maybe add doc in this class that this is internally API?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T02:23:10.456+0000",
                    "updated": "2017-10-23T02:23:10.456+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214542",
                    "id": "16214542",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#discussion_r146156320\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseValueVector.java\n ##########\n @@ -137,10 +136,19 @@ protected ArrowBuf releaseBuffer(ArrowBuf buffer) {\n     return buffer;\n   }\n \n+  @Override\n   public int getValueCount() { return 0; }\n \n+  @Override\n   public void setValueCount(int valueCount) { }\n \n+  @Override\n   public Object getObject(int index) { return null; }\n+\n+  @Override\n+  public int getNullCount() { return 0; }\n \n Review comment:\n   How about have them throw `UnsupportedOperationException`?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T02:30:14.344+0000",
                    "updated": "2017-10-23T02:30:14.344+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214543",
                    "id": "16214543",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#discussion_r146156364\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseValueVector.java\n ##########\n @@ -137,10 +136,19 @@ protected ArrowBuf releaseBuffer(ArrowBuf buffer) {\n     return buffer;\n   }\n \n+  @Override\n   public int getValueCount() { return 0; }\n \n+  @Override\n   public void setValueCount(int valueCount) { }\n \n+  @Override\n   public Object getObject(int index) { return null; }\n+\n+  @Override\n+  public int getNullCount() { return 0; }\n \n Review comment:\n   I am concerned these methods would be confusing to user, so we have to keep them, I think we should make it clear these function won't work and shouldn't be called at all.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T02:31:00.459+0000",
                    "updated": "2017-10-23T02:31:00.459+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214545",
                    "id": "16214545",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#discussion_r146156364\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseValueVector.java\n ##########\n @@ -137,10 +136,19 @@ protected ArrowBuf releaseBuffer(ArrowBuf buffer) {\n     return buffer;\n   }\n \n+  @Override\n   public int getValueCount() { return 0; }\n \n+  @Override\n   public void setValueCount(int valueCount) { }\n \n+  @Override\n   public Object getObject(int index) { return null; }\n+\n+  @Override\n+  public int getNullCount() { return 0; }\n \n Review comment:\n   I am concerned these methods would be confusing to user, so if we have to keep them, I think we should make it clear these function won't work and shouldn't be called at all.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T02:31:08.399+0000",
                    "updated": "2017-10-23T02:31:08.399+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214546",
                    "id": "16214546",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#discussion_r146156364\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseValueVector.java\n ##########\n @@ -137,10 +136,19 @@ protected ArrowBuf releaseBuffer(ArrowBuf buffer) {\n     return buffer;\n   }\n \n+  @Override\n   public int getValueCount() { return 0; }\n \n+  @Override\n   public void setValueCount(int valueCount) { }\n \n+  @Override\n   public Object getObject(int index) { return null; }\n+\n+  @Override\n+  public int getNullCount() { return 0; }\n \n Review comment:\n   I am concerned these methods would be confusing to user, so if we have to keep them, I think we should make it clear these function won't work and shouldn't be called at all. Maybe have a noisy deprecation warning or sth.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T02:31:49.825+0000",
                    "updated": "2017-10-23T02:31:49.825+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214555",
                    "id": "16214555",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#discussion_r146157276\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n ##########\n @@ -761,4 +741,57 @@ protected final void handleSafe(int index, int dataLength) {\n          reallocValueBuffer();\n       }\n    }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                helper methods currently                        *\n+    *                used by JsonFileReader and                      *\n+    *                JsonFileWriter                                  *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   public static ArrowBuf setSafeJsonHelper(ArrowBuf data, ArrowBuf offset,\n+                                            BufferAllocator allocator, int index, byte[] value,\n+                                            int valueCount) {\n+      if (data == null) {\n+         data = allocator.buffer(INITIAL_BYTE_COUNT);\n+      }\n+      final int currentBufferCapacity = data.capacity();\n+      final int currentStartOffset = offset.getInt(index * OFFSET_WIDTH);\n+      while (currentBufferCapacity < currentStartOffset + value.length) {\n+         final ArrowBuf newBuf = allocator.buffer(currentBufferCapacity * 2);\n+         newBuf.setBytes(0, data, 0, currentBufferCapacity);\n+         data.release();\n+         data = newBuf;\n+      }\n+      data.setBytes(currentStartOffset, value, 0, value.length);\n+      if (index == (valueCount - 1)) {\n+         data.writerIndex(offset.getInt(valueCount * OFFSET_WIDTH));\n+      }\n+      return data;\n+   }\n+\n+   public static byte[] get(final ArrowBuf data, final ArrowBuf offset, int index) {\n \n Review comment:\n   Sorry, I really don't like having these functions as a part of the vector API just for the JSON reader. I am not sure what's the best way to do this though - Can you please explain why do we need these methods? The original JSON reader/writer use these - \r\n   https://github.com/apache/arrow/blob/master/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileReader.java#L344\r\n   \r\n   https://github.com/apache/arrow/blob/master/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileWriter.java#L240\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T02:43:25.410+0000",
                    "updated": "2017-10-23T02:43:25.410+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214561",
                    "id": "16214561",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#discussion_r146157560\n \n \n\n ##########\n File path: java/vector/src/main/codegen/templates/UnionVector.java\n ##########\n @@ -550,15 +532,5 @@ public void setType(int index, MinorType type) {\n     }\n \n     @Override\n-    public void reset() { }\n-\n-    @Override\n-    public void generateTestData(int values) { }\n-  }\n-\n-  public int getValueCount() { return 0; }\n-\n-  public void setValueCount(int valueCount) { }\n-\n-  public Object getObject(int index) { return null; }\n+    public int getNullCount() { return 0; }\n \n Review comment:\n   Should this be `UnsupportedOperationException`?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T02:48:13.817+0000",
                    "updated": "2017-10-23T02:48:13.817+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214562",
                    "id": "16214562",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#discussion_r146157591\n \n \n\n ##########\n File path: java/vector/src/main/codegen/templates/UnionVector.java\n ##########\n @@ -363,12 +361,12 @@ public void copyValueSafe(int from, int to) {\n \n   @Override\n   public Accessor getAccessor() {\n \n Review comment:\n   Sorry the link is not valid any more, can you paste a new link?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T02:48:44.636+0000",
                    "updated": "2017-10-23T02:48:44.636+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214563",
                    "id": "16214563",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#discussion_r146157662\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\n ##########\n @@ -129,14 +152,70 @@ public UnionListWriter getWriter() {\n \n   @Override\n   public void allocateNew() throws OutOfMemoryException {\n-    super.allocateNewSafe();\n-    bits.allocateNewSafe();\n+   if (!allocateNewSafe()) {\n+     throw new OutOfMemoryException(\"Failure while allocating memory\");\n+   }\n+  }\n+\n+  public boolean allocateNewSafe() {\n+    boolean success = false;\n+    try {\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      /* allocate offset and data buffer */\n+      success = super.allocateNewSafe();\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n \n Review comment:\n   Ok this is fine.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T02:49:44.074+0000",
                    "updated": "2017-10-23T02:49:44.074+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214571",
                    "id": "16214571",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#issuecomment-338536671\n \n \n   A few high level comments:\r\n   * There are a few functions that seems to be placeholder for the interface - for instance `getNullCount`  that only returns 0. I suppose these functions are not going to be removed in 0.8? If that's the case, I think we should make it clear to the user that these functions will not work and shouldn't be called. Having bogus implementation could be confusing to user.\r\n   \r\n   * API added in vectors classes that are for json reader/writer. I think those shouldn't be a part of the public API. Also I am not sure why we need to make such changes, maybe @siddharthteotia can help clarify?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T03:09:17.208+0000",
                    "updated": "2017-10-23T03:09:17.208+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214572",
                    "id": "16214572",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#issuecomment-338536838\n \n \n   @siddharthteotia For future reference, I usually prefer not to squash commit during PR - this makes it hard to track incremental changes. We can squash commit when merging.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T03:11:01.087+0000",
                    "updated": "2017-10-23T03:11:01.087+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214856",
                    "id": "16214856",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#issuecomment-338598989\n \n \n   **W.r.t introduction of some static interfaces for JsonFileWriter/Reader**\r\n   \r\n   The introduction of couple of static interfaces is not absolutely necessary. They are written for better readability in JsonFileReader's gigantic switch block when it parses Json and writes to the vector (and its inner vectors). Since now we no longer have inner vectors, we obviously couldn't leverage the same code. The JsonFileReader had to be changed to specifically write to different buffers (TYPE, VALIDITY, OFFSET, DATA) for a particular vector. Also it has to allocate the buffer and appropriately set writer index before calling loadFieldBuffers. This is something that was needed for every case in switch block here. Once I did this, the code looked pretty messy and ugly. So I moved all the logic private to vectors and made them as part of static interfaces.\r\n   \r\n   On the other hand, in JsonFileWriter we were reading from vector (and its inner vectors) and writing out Json data. Again, since there are no inner vectors, all operation had to be transformed to work at the buffer level -- for writing the contents of each inner buffer. Also, the old code of JsonFileWriter stated a TODO that it was not handling each type. The new code handles all types.\r\n   \r\n   If the general preference is to not introduce static interfaces in vector APIs, I am fine with removing them and moving all logic into JSon code itself. The javadocs already indicate that external use of these APIs is not recommended.\r\n   \r\n   **W.r.t introduction of some new APIs in ValueVector**\r\n   \r\n   Note that top level interface is still ValueVector even though hierarchy underneath has changed. So there are still non-nullable vectors extending ValueVector, implementing mutator/accessor interfaces etc.\r\n   \r\n   So I introduced APIs like getNullCount(), getValueCount(), setValueCount(), getObject() for the new nullable vectors. Once we remove non-nullable vectors and remove mutator/accessor from ValueVector, we can get rid of these APIs too. \r\n   \r\n   User is free to call such methods on vectors since internally they delegate the call to corresponding mutator/accessor operation for non-nullable vectors and for nullable vectors we already have the new implementation. For legacy vectors, it doesn't really matter since each operation is just a pass-through to new code.\r\n   \r\n   Each vector (nullable or non-nullable) has a concrete implementation of all such interfaces prescribed by ValueVector. Correctness is not affected anywhere. We should be able to do the simple cleanup once we remove non-nullable vectors. If we are not planning to remove non-nullable vectors then we should just remove mutator/accessor interfaces from them and expose all the get/set APIs directly just like we have done for other nullable and complex vectors.\r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T09:20:13.205+0000",
                    "updated": "2017-10-23T09:20:13.205+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214859",
                    "id": "16214859",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#discussion_r146209120\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/BaseRepeatedValueVector.java\n ##########\n @@ -187,54 +227,58 @@ protected void replaceDataVector(FieldVector v) {\n     vector = v;\n   }\n \n-  public abstract class BaseRepeatedAccessor extends BaseValueVector.BaseAccessor implements RepeatedAccessor {\n \n-    @Override\n-    public int getValueCount() {\n-      return Math.max(offsets.getAccessor().getValueCount() - 1, 0);\n-    }\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n \n-    @Override\n-    public int getInnerValueCount() {\n-      return vector.getAccessor().getValueCount();\n-    }\n+  /* returns the value count for inner data vector for this list vector */\n+  public int getInnerValueCount() {\n+    return vector.getValueCount();\n+  }\n \n-    @Override\n-    public int getInnerValueCountAt(int index) {\n-      return offsets.getAccessor().get(index + 1) - offsets.getAccessor().get(index);\n-    }\n \n-    @Override\n-    public boolean isNull(int index) {\n-      return false;\n-    }\n+  /* returns the value count for inner data vector at a particular index */\n+  public int getInnerValueCountAt(int index) {\n+    return offsetBuffer.getInt((index + 1) * OFFSET_WIDTH) -\n+            offsetBuffer.getInt(index * OFFSET_WIDTH);\n+  }\n \n-    @Override\n-    public boolean isEmpty(int index) {\n-      return false;\n-    }\n+  public boolean isNull(int index) {\n+    return false;\n   }\n \n-  public abstract class BaseRepeatedMutator extends BaseValueVector.BaseMutator implements RepeatedMutator {\n+  public boolean isEmpty(int index) {\n+    return false;\n+  }\n \n-    @Override\n-    public int startNewValue(int index) {\n-      while (offsets.getValueCapacity() <= index) {\n-        offsets.reAlloc();\n-      }\n-      int offset = offsets.getAccessor().get(index);\n-      offsets.getMutator().setSafe(index + 1, offset);\n-      setValueCount(index + 1);\n-      return offset;\n+  public int startNewValue(int index) {\n+    while (index >= getOffsetBufferValueCapacity()) {\n+      reallocOffsetBuffer();\n     }\n+    int offset = offsetBuffer.getInt(index * OFFSET_WIDTH);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, offset);\n+    setValueCount(index + 1);\n+    return offset;\n+  }\n \n-    @Override\n-    public void setValueCount(int valueCount) {\n-      // TODO: populate offset end points\n-      offsets.getMutator().setValueCount(valueCount == 0 ? 0 : valueCount + 1);\n-      final int childValueCount = valueCount == 0 ? 0 : offsets.getAccessor().get(valueCount);\n-      vector.getMutator().setValueCount(childValueCount);\n+  public void setValueCount(int valueCount) {\n+    // TODO: populate offset end points\n \n Review comment:\n   Done.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T09:22:03.599+0000",
                    "updated": "2017-10-23T09:22:03.599+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214860",
                    "id": "16214860",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#issuecomment-338599706\n \n \n   Looking into Travis CI failures -- build (with tests) runs clean locally \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T09:23:00.894+0000",
                    "updated": "2017-10-23T09:23:00.894+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214895",
                    "id": "16214895",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#issuecomment-338598989\n \n \n   **W.r.t introduction of some static interfaces for JsonFileWriter/Reader**\r\n   \r\n   The introduction of couple of static interfaces is not absolutely necessary. They are written for better readability in JsonFileReader's gigantic switch block when it parses Json and writes to the vector (and its inner vectors). Since now we no longer have inner vectors, we obviously couldn't leverage the same code. The JsonFileReader had to be changed to specifically write to different buffers (TYPE, VALIDITY, OFFSET, DATA) for a particular vector. Also it has to allocate the buffer and appropriately set writer index before calling loadFieldBuffers. This is something that was needed for every case in switch block here. Once I did this, the code looked pretty messy and ugly. So I moved all the logic private to vectors and made them as part of static interfaces.\r\n   \r\n   On the other hand, in JsonFileWriter we were reading from vector (and its inner vectors) and writing out Json data. Again, since there are no inner vectors, all operation had to be transformed to work at the buffer level -- for writing the contents of each inner buffer. Also, the old code of JsonFileWriter stated a TODO that it was not handling each type. The new code handles all types.\r\n   \r\n   If the general preference is to not introduce static interfaces in vector APIs, I am fine with removing them and moving all logic into JSon code itself. The javadocs already indicate that external use of these APIs is not recommended.\r\n   \r\n   **W.r.t introduction of some new APIs in ValueVector**\r\n   \r\n   Note that top level interface is still ValueVector even though hierarchy underneath has changed. So there are still non-nullable vectors extending ValueVector, implementing mutator/accessor interfaces etc.\r\n   \r\n   So I introduced APIs like getNullCount(), getValueCount(), setValueCount(), getObject() for the new nullable vectors. Once we remove non-nullable vectors and remove mutator/accessor from ValueVector, we can get rid of these APIs too. \r\n   \r\n   User is free to call such methods on vectors since internally they delegate the call to corresponding mutator/accessor operation for non-nullable vectors and for nullable vectors we already have the new implementation. For legacy vectors, it doesn't really matter since each operation is just a pass-through to new code.\r\n   \r\n   Each vector (nullable or non-nullable) has a concrete implementation of all such interfaces prescribed by ValueVector. Correctness is not affected anywhere. We should be able to do the simple cleanup once we remove non-nullable vectors. If we are not planning to remove non-nullable vectors then we should just remove mutator/accessor interfaces from them and expose all the get/set APIs directly just like we have done for other nullable and complex vectors. That will also allow us to do simple cleanup.\r\n   \r\n   Whatever we decide to do with non-nullable scalar vectors, we should do soon to make the entire java Vector code under ValueVector hierarchy consistent.\r\n   \r\n   Right now the nullable scalars and complex types are consistent -- none of them have inner vectors and none of them support mutator/accessor based access. Either we should do the same thing with non nullable vectors or remove them all together. The latter is preferable.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T09:49:08.574+0000",
                    "updated": "2017-10-23T09:49:08.574+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16214901",
                    "id": "16214901",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#issuecomment-338598989\n \n \n   **W.r.t introduction of some static interfaces for JsonFileWriter/Reader**\r\n   \r\n   The introduction of couple of static interfaces is not absolutely necessary. They are written for better readability in JsonFileReader's gigantic switch block when it parses Json and writes to the vector (and its inner vectors). Since now we no longer have inner vectors, we obviously couldn't leverage the same code. The JsonFileReader had to be changed to specifically write to different buffers (TYPE, VALIDITY, OFFSET, DATA) for a particular vector. Also it has to allocate the buffer and appropriately set writer index before calling loadFieldBuffers. This is something that was needed for every case in switch block here. Once I did this, the code looked pretty messy and ugly. So I moved all the logic private to vectors and made them as part of static interfaces.\r\n   \r\n   On the other hand, in JsonFileWriter we were reading from vector (and its inner vectors) and writing out Json data. Again, since there are no inner vectors, all operation had to be transformed to work at the buffer level -- for writing the contents of each inner buffer. Also, the old code of JsonFileWriter stated a TODO that it was not handling each type. The new code handles all types.\r\n   \r\n   If the general preference is to not introduce static interfaces in vector APIs, I am fine with removing them and moving all logic into JSon code itself. The javadocs already indicate that external use of these APIs is not recommended.\r\n   \r\n   **W.r.t introduction of some new APIs in ValueVector**\r\n   \r\n   Note that top level interface is still ValueVector even though hierarchy underneath has changed. So there are still non-nullable vectors extending ValueVector, implementing mutator/accessor interfaces etc.\r\n   \r\n   So I introduced APIs like getNullCount(), getValueCount(), setValueCount(), getObject() for the new nullable vectors. Once we remove non-nullable vectors and expose mutator/accessor functions as direct get/set in ValueVector, we can get rid of these APIs too. \r\n   \r\n   User is free to call such methods on vectors since internally they delegate the call to corresponding mutator/accessor operation for non-nullable vectors and for nullable vectors we already have the new implementation. For legacy vectors, it doesn't really matter since each operation is just a pass-through to new code.\r\n   \r\n   There aren't any placeholder interfaces anywhere. Each vector (nullable or non-nullable) has a concrete implementation of all such interfaces as prescribed by ValueVector. Correctness is not affected anywhere. We should be able to do the simple cleanup once we remove non-nullable vectors. If we are not planning to remove non-nullable vectors then we should just remove mutator/accessor from them and expose all the get/set APIs directly just like we have done for other nullable and complex vectors. That will also allow us to do simple cleanup.\r\n   \r\n   Whatever we decide to do with non-nullable scalar vectors, we should do soon to make the entire java Vector code under ValueVector hierarchy consistent.\r\n   \r\n   Right now the nullable scalars and complex types are consistent -- none of them have inner vectors and none of them support mutator/accessor based access. Either we should do the same thing with non nullable vectors or remove them all together. The latter is preferable.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T09:55:28.722+0000",
                    "updated": "2017-10-23T09:55:28.722+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16215120",
                    "id": "16215120",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#issuecomment-338656053\n \n \n   > For future reference, I usually prefer not to squash commit during PR - this makes it hard to track incremental changes. We can squash commit when merging.\r\n   \r\n   We're really running into a weakness of GitHub code reviews. My understanding is that Dremio uses Gerrit for code reviews (like Kudu, Impala, and lots of Google projects) and so the squashing is a key part of the Gerrit workflow. But it works pretty poorly for GitHub, where having a string of new commits is better (although the GitHub UI is terrible for reviewing incremental diffs)\r\n   \r\n   I would really like to have the option of doing large Arrow code reviews on Gerrit. It can be a bit challenging to do (because Gerrit can fall out of sync) unless you have 100% of your reviews hosted on there, and Gerrit is quite a bit of process for some users. I hope that we find a way to do this in the future.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T13:19:41.370+0000",
                    "updated": "2017-10-23T13:19:41.370+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16215268",
                    "id": "16215268",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#issuecomment-338690930\n \n \n   @siddharthteotia , thanks for the explanation.\r\n   \r\n   **W.r.t introduction of some static interfaces for JsonFileWriter/Reader**\r\n   I see, so the reason is inner vectors are removed and therefore the json reader/writer doesn't work anymore.\r\n   \r\n   In that case, I am sort of OK with leaving these methods as public static but document clearly those methods are not part of public API and should not be used (IMHO \"not recommended\" is not strong enough, I would probably say \"shouldn't\") and refactor that later, before or after 0.8 release.\r\n   \r\n   What do other people think?\r\n   \r\n   **W.r.t introduction of some new APIs in ValueVector**\r\n   \r\n   > So I introduced APIs like getNullCount(), getValueCount(), setValueCount(), getObject() for the new nullable vectors. Once we remove non-nullable vectors and expose mutator/accessor functions as direct get/set in ValueVector, we can get rid of these APIs too.\r\n   \r\n   > User is free to call such methods on vectors\r\n   @siddharthteotia, let me see if I understand this correctly:\r\n   \r\n   getNullCount(), getValueCount(), setValueCount(), getObject() are a part of the new vector API and we will keep them going forward.\r\n   \r\n   I think I saw a version of the BaseValueVector that these methods are returning bogus values, it seems to be correct row. I probably just saw a wip version. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T15:09:36.195+0000",
                    "updated": "2017-10-23T15:09:36.195+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16215269",
                    "id": "16215269",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#issuecomment-338690930\n \n \n   @siddharthteotia , thanks for the explanation.\r\n   \r\n   **W.r.t introduction of some static interfaces for JsonFileWriter/Reader**\r\n   I see, so the reason is inner vectors are removed and therefore the json reader/writer doesn't work anymore.\r\n   \r\n   In that case, I am sort of OK with leaving these methods as public static but document clearly those methods are not part of public API and should not be used (IMHO \"not recommended\" is not strong enough, I would probably say \"shouldn't\") and refactor that later, before or after 0.8 release.\r\n   \r\n   What do other people think?\r\n   \r\n   **W.r.t introduction of some new APIs in ValueVector**\r\n   \r\n   > So I introduced APIs like getNullCount(), getValueCount(), setValueCount(), getObject() for the new nullable vectors. Once we remove non-nullable vectors and expose mutator/accessor functions as direct get/set in ValueVector, we can get rid of these APIs too.\r\n   \r\n   > User is free to call such methods on vectors\r\n   \r\n   @siddharthteotia, let me see if I understand this correctly:\r\n   \r\n   getNullCount(), getValueCount(), setValueCount(), getObject() are a part of the new vector API and we will keep them going forward.\r\n   \r\n   I think I saw a version of the BaseValueVector that these methods are returning bogus values, it seems to be correct row. I probably just saw a wip version. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T15:09:49.756+0000",
                    "updated": "2017-10-23T15:09:49.756+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16215273",
                    "id": "16215273",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#issuecomment-338690930\n \n \n   @siddharthteotia , thanks for the explanation.\r\n   \r\n   **W.r.t introduction of some static interfaces for JsonFileWriter/Reader**\r\n   I see, so the reason is inner vectors are removed and therefore the json reader/writer doesn't work anymore.\r\n   \r\n   In that case, I am sort of OK with leaving these methods as public static but document clearly those methods are not part of public API and should not be used (IMHO \"not recommended\" is not strong enough, I would probably say \"shouldn't\") and refactor that later, before or after 0.8 release.\r\n   \r\n   What do other people think?\r\n   \r\n   **W.r.t introduction of some new APIs in ValueVector**\r\n   \r\n   > So I introduced APIs like getNullCount(), getValueCount(), setValueCount(), getObject() for the new nullable vectors. Once we remove non-nullable vectors and expose mutator/accessor functions as direct get/set in ValueVector, we can get rid of these APIs too.\r\n   \r\n   > User is free to call such methods on vectors\r\n   \r\n   @siddharthteotia, let me see if I understand this correctly:\r\n   \r\n   getNullCount(), getValueCount(), setValueCount(), getObject() are a part of the new vector API and we will keep them going forward.\r\n   \r\n   I think I saw a version of the BaseValueVector that these methods are returning bogus values and got confused. It seems to be correct row. I probably just saw a wip version. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T15:10:26.001+0000",
                    "updated": "2017-10-23T15:10:26.001+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16215800",
                    "id": "16215800",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#discussion_r146388114\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseValueVector.java\n ##########\n @@ -137,10 +136,19 @@ protected ArrowBuf releaseBuffer(ArrowBuf buffer) {\n     return buffer;\n   }\n \n+  @Override\n   public int getValueCount() { return 0; }\n \n+  @Override\n   public void setValueCount(int valueCount) { }\n \n+  @Override\n   public Object getObject(int index) { return null; }\n+\n+  @Override\n+  public int getNullCount() { return 0; }\n \n Review comment:\n   This is resolved.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T20:43:32.742+0000",
                    "updated": "2017-10-23T20:43:32.742+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16215802",
                    "id": "16215802",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#discussion_r146388341\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n ##########\n @@ -761,4 +741,57 @@ protected final void handleSafe(int index, int dataLength) {\n          reallocValueBuffer();\n       }\n    }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                helper methods currently                        *\n+    *                used by JsonFileReader and                      *\n+    *                JsonFileWriter                                  *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   public static ArrowBuf setSafeJsonHelper(ArrowBuf data, ArrowBuf offset,\n+                                            BufferAllocator allocator, int index, byte[] value,\n+                                            int valueCount) {\n+      if (data == null) {\n+         data = allocator.buffer(INITIAL_BYTE_COUNT);\n+      }\n+      final int currentBufferCapacity = data.capacity();\n+      final int currentStartOffset = offset.getInt(index * OFFSET_WIDTH);\n+      while (currentBufferCapacity < currentStartOffset + value.length) {\n+         final ArrowBuf newBuf = allocator.buffer(currentBufferCapacity * 2);\n+         newBuf.setBytes(0, data, 0, currentBufferCapacity);\n+         data.release();\n+         data = newBuf;\n+      }\n+      data.setBytes(currentStartOffset, value, 0, value.length);\n+      if (index == (valueCount - 1)) {\n+         data.writerIndex(offset.getInt(valueCount * OFFSET_WIDTH));\n+      }\n+      return data;\n+   }\n+\n+   public static byte[] get(final ArrowBuf data, final ArrowBuf offset, int index) {\n \n Review comment:\n   This is discussed https://github.com/apache/arrow/pull/1203#issuecomment-338690930\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T20:44:24.659+0000",
                    "updated": "2017-10-23T20:44:24.659+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16215803",
                    "id": "16215803",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#discussion_r146388575\n \n \n\n ##########\n File path: java/vector/src/main/codegen/templates/UnionVector.java\n ##########\n @@ -550,15 +532,5 @@ public void setType(int index, MinorType type) {\n     }\n \n     @Override\n-    public void reset() { }\n-\n-    @Override\n-    public void generateTestData(int values) { }\n-  }\n-\n-  public int getValueCount() { return 0; }\n-\n-  public void setValueCount(int valueCount) { }\n-\n-  public Object getObject(int index) { return null; }\n+    public int getNullCount() { return 0; }\n \n Review comment:\n   This is resolved.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T20:45:17.068+0000",
                    "updated": "2017-10-23T20:45:17.068+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16215842",
                    "id": "16215842",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#issuecomment-338797396\n \n \n   @jacques-n , @BryanCutler , @icexelloss \r\n   \r\n   The latest commit has good javadocs for each and every new function in all vector types. \r\n   \r\n   How do you feel about merging this patch to java-vector-refactor branch? I believe merging into master will require proper formal sign off.\r\n   \r\n   We are going to kickstart testing these in Dremio after cherry-picking these two patches from java-vector-refactor branch and making the necessary code changes. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T21:09:06.112+0000",
                    "updated": "2017-10-23T21:09:06.112+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16215861",
                    "id": "16215861",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#issuecomment-338797396\n \n \n   @jacques-n , @BryanCutler , @icexelloss \r\n   \r\n   The latest commit has good javadocs for each and every new function in all vector types. \r\n   \r\n   How do you feel about merging this patch to java-vector-refactor branch? I believe merging into master will require proper formal sign off.\r\n   \r\n   We are going to kickstart testing these in Dremio after cherry-picking these two patches from java-vector-refactor branch and making the necessary code changes. \r\n   \r\n   cc @wesm \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T21:16:38.350+0000",
                    "updated": "2017-10-23T21:16:38.350+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16215902",
                    "id": "16215902",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1203: ARROW-1474:[WIP] Java Vector Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#issuecomment-338806312\n \n \n   I'm on board with merging to the refactor branch whenever you all agree\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T21:46:07.922+0000",
                    "updated": "2017-10-23T21:46:07.922+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16215961",
                    "id": "16215961",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "jacques-n commented on issue #1203: ARROW-1474: [JAVA] Java ValueVector hierarchy Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#issuecomment-338815078\n \n \n   I'm onboard with merge. We can still continue to address comments post merge as necessary. Big patches and github don't mix...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T22:26:59.674+0000",
                    "updated": "2017-10-23T22:26:59.674+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16215985",
                    "id": "16215985",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1203: ARROW-1474: [JAVA] Java ValueVector hierarchy Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#issuecomment-338818215\n \n \n   Thanks @siddharthteotia , I agree to merge to refactor branch and continue there.  This is getting a little to big to focus on any one change.\r\n   \r\n   **W.r.t introduction of some static interfaces for JsonFileWriter/Reader**\r\n   \r\n   I don't really like having these static `set` methods in the vector public apis if they shouldn't be used outside of JSON reader/writer, but lets continue this discussion after merging this\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T22:43:48.633+0000",
                    "updated": "2017-10-23T22:43:48.633+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16215995",
                    "id": "16215995",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1203: ARROW-1474: [JAVA] Java ValueVector hierarchy Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#issuecomment-338819484\n \n \n   I agree we can merge this. I will open Jiras to track major unresolved discussion .\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-23T22:51:03.266+0000",
                    "updated": "2017-10-23T22:51:03.266+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16216142",
                    "id": "16216142",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1203: ARROW-1474: [JAVA] Java ValueVector hierarchy Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203#issuecomment-338836892\n \n \n   Merged in https://github.com/apache/arrow/commit/612b9708658ece27b1ba12ee92a997652beb007b, thanks @siddharthteotia and everyone for reviewing!\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-24T00:42:25.247+0000",
                    "updated": "2017-10-24T00:42:25.247+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16216143",
                    "id": "16216143",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm closed pull request #1203: ARROW-1474: [JAVA] Java ValueVector hierarchy Refactor (Implementation Phase 2)\nURL: https://github.com/apache/arrow/pull/1203\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/java/tools/src/test/java/org/apache/arrow/tools/ArrowFileTestFixtures.java b/java/tools/src/test/java/org/apache/arrow/tools/ArrowFileTestFixtures.java\nindex 6d9a6c132..c56a5a330 100644\n--- a/java/tools/src/test/java/org/apache/arrow/tools/ArrowFileTestFixtures.java\n+++ b/java/tools/src/test/java/org/apache/arrow/tools/ArrowFileTestFixtures.java\n@@ -78,8 +78,8 @@ static void validateOutput(File testOutFile, BufferAllocator allocator) throws E\n   static void validateContent(int count, VectorSchemaRoot root) {\n     Assert.assertEquals(count, root.getRowCount());\n     for (int i = 0; i < count; i++) {\n-      Assert.assertEquals(i, root.getVector(\"int\").getAccessor().getObject(i));\n-      Assert.assertEquals(Long.valueOf(i), root.getVector(\"bigInt\").getAccessor().getObject(i));\n+      Assert.assertEquals(i, root.getVector(\"int\").getObject(i));\n+      Assert.assertEquals(Long.valueOf(i), root.getVector(\"bigInt\").getObject(i));\n     }\n   }\n \ndiff --git a/java/tools/src/test/java/org/apache/arrow/tools/EchoServerTest.java b/java/tools/src/test/java/org/apache/arrow/tools/EchoServerTest.java\nindex 467965aff..db7eb54e6 100644\n--- a/java/tools/src/test/java/org/apache/arrow/tools/EchoServerTest.java\n+++ b/java/tools/src/test/java/org/apache/arrow/tools/EchoServerTest.java\n@@ -104,10 +104,10 @@ private void testEchoServer(int serverPort,\n       for (int i = 0; i < batches; i++) {\n         vector.allocateNew(16);\n         for (int j = 0; j < 8; j++) {\n-          vector.getMutator().set(j, j + i);\n-          vector.getMutator().set(j + 8, 0, (byte) (j + i));\n+          vector.set(j, j + i);\n+          vector.set(j + 8, 0, (byte) (j + i));\n         }\n-        vector.getMutator().setValueCount(16);\n+        vector.setValueCount(16);\n         root.setRowCount(16);\n         writer.writeBatch();\n       }\n@@ -120,10 +120,10 @@ private void testEchoServer(int serverPort,\n       for (int i = 0; i < batches; i++) {\n         Assert.assertTrue(reader.loadNextBatch());\n         assertEquals(16, reader.getVectorSchemaRoot().getRowCount());\n-        assertEquals(16, readVector.getAccessor().getValueCount());\n+        assertEquals(16, readVector.getValueCount());\n         for (int j = 0; j < 8; j++) {\n-          assertEquals(j + i, readVector.getAccessor().get(j));\n-          assertTrue(readVector.getAccessor().isNull(j + 8));\n+          assertEquals(j + i, readVector.get(j));\n+          assertTrue(readVector.isNull(j + 8));\n         }\n       }\n       Assert.assertFalse(reader.loadNextBatch());\n@@ -169,20 +169,18 @@ public void testFlatDictionary() throws IOException {\n                  FieldType.nullable(VARCHAR.getType()),\n                  allocator)) {\n       writeVector.allocateNewSafe();\n-      NullableIntVector.Mutator mutator = writeVector.getMutator();\n-      mutator.set(0, 0);\n-      mutator.set(1, 1);\n-      mutator.set(3, 2);\n-      mutator.set(4, 1);\n-      mutator.set(5, 2);\n-      mutator.setValueCount(6);\n+      writeVector.set(0, 0);\n+      writeVector.set(1, 1);\n+      writeVector.set(3, 2);\n+      writeVector.set(4, 1);\n+      writeVector.set(5, 2);\n+      writeVector.setValueCount(6);\n \n       writeDictionaryVector.allocateNewSafe();\n-      NullableVarCharVector.Mutator dictionaryMutator = writeDictionaryVector.getMutator();\n-      dictionaryMutator.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n-      dictionaryMutator.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n-      dictionaryMutator.set(2, \"baz\".getBytes(StandardCharsets.UTF_8));\n-      dictionaryMutator.setValueCount(3);\n+      writeDictionaryVector.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n+      writeDictionaryVector.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n+      writeDictionaryVector.set(2, \"baz\".getBytes(StandardCharsets.UTF_8));\n+      writeDictionaryVector.setValueCount(3);\n \n       List<Field> fields = ImmutableList.of(writeVector.getField());\n       List<FieldVector> vectors = ImmutableList.of((FieldVector) writeVector);\n@@ -210,23 +208,21 @@ public void testFlatDictionary() throws IOException {\n         Assert.assertNotNull(readEncoding);\n         Assert.assertEquals(1L, readEncoding.getId());\n \n-        FieldVector.Accessor accessor = readVector.getAccessor();\n-        Assert.assertEquals(6, accessor.getValueCount());\n-        Assert.assertEquals(0, accessor.getObject(0));\n-        Assert.assertEquals(1, accessor.getObject(1));\n-        Assert.assertEquals(null, accessor.getObject(2));\n-        Assert.assertEquals(2, accessor.getObject(3));\n-        Assert.assertEquals(1, accessor.getObject(4));\n-        Assert.assertEquals(2, accessor.getObject(5));\n+        Assert.assertEquals(6, readVector.getValueCount());\n+        Assert.assertEquals(0, readVector.getObject(0));\n+        Assert.assertEquals(1, readVector.getObject(1));\n+        Assert.assertEquals(null, readVector.getObject(2));\n+        Assert.assertEquals(2, readVector.getObject(3));\n+        Assert.assertEquals(1, readVector.getObject(4));\n+        Assert.assertEquals(2, readVector.getObject(5));\n \n         Dictionary dictionary = reader.lookup(1L);\n         Assert.assertNotNull(dictionary);\n-        NullableVarCharVector.Accessor dictionaryAccessor = ((NullableVarCharVector) dictionary\n-            .getVector()).getAccessor();\n-        Assert.assertEquals(3, dictionaryAccessor.getValueCount());\n-        Assert.assertEquals(new Text(\"foo\"), dictionaryAccessor.getObject(0));\n-        Assert.assertEquals(new Text(\"bar\"), dictionaryAccessor.getObject(1));\n-        Assert.assertEquals(new Text(\"baz\"), dictionaryAccessor.getObject(2));\n+        NullableVarCharVector dictionaryVector = ((NullableVarCharVector) dictionary.getVector());\n+        Assert.assertEquals(3, dictionaryVector.getValueCount());\n+        Assert.assertEquals(new Text(\"foo\"), dictionaryVector.getObject(0));\n+        Assert.assertEquals(new Text(\"bar\"), dictionaryVector.getObject(1));\n+        Assert.assertEquals(new Text(\"baz\"), dictionaryVector.getObject(2));\n       }\n     }\n   }\n@@ -243,9 +239,9 @@ public void testNestedDictionary() throws IOException {\n       // [['foo', 'bar'], ['foo'], ['bar']] -> [[0, 1], [0], [1]]\n \n       writeDictionaryVector.allocateNew();\n-      writeDictionaryVector.getMutator().set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n-      writeDictionaryVector.getMutator().set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n-      writeDictionaryVector.getMutator().setValueCount(2);\n+      writeDictionaryVector.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n+      writeDictionaryVector.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n+      writeDictionaryVector.setValueCount(2);\n \n       writeVector.addOrGetVector(new FieldType(true, MinorType.INT.getType(), writeEncoding, null));\n       writeVector.allocateNew();\n@@ -297,19 +293,17 @@ public void testNestedDictionary() throws IOException {\n         Assert.assertEquals(2L, encoding.getId());\n         Assert.assertEquals(new Int(32, true), encoding.getIndexType());\n \n-        ListVector.Accessor accessor = readVector.getAccessor();\n-        Assert.assertEquals(3, accessor.getValueCount());\n-        Assert.assertEquals(Arrays.asList(0, 1), accessor.getObject(0));\n-        Assert.assertEquals(Arrays.asList(0), accessor.getObject(1));\n-        Assert.assertEquals(Arrays.asList(1), accessor.getObject(2));\n+        Assert.assertEquals(3, readVector.getValueCount());\n+        Assert.assertEquals(Arrays.asList(0, 1), readVector.getObject(0));\n+        Assert.assertEquals(Arrays.asList(0), readVector.getObject(1));\n+        Assert.assertEquals(Arrays.asList(1), readVector.getObject(2));\n \n         Dictionary readDictionary = reader.lookup(2L);\n         Assert.assertNotNull(readDictionary);\n-        NullableVarCharVector.Accessor dictionaryAccessor = ((NullableVarCharVector)\n-            readDictionary.getVector()).getAccessor();\n-        Assert.assertEquals(2, dictionaryAccessor.getValueCount());\n-        Assert.assertEquals(new Text(\"foo\"), dictionaryAccessor.getObject(0));\n-        Assert.assertEquals(new Text(\"bar\"), dictionaryAccessor.getObject(1));\n+        NullableVarCharVector dictionaryVector = ((NullableVarCharVector) readDictionary.getVector());\n+        Assert.assertEquals(2, dictionaryVector.getValueCount());\n+        Assert.assertEquals(new Text(\"foo\"), dictionaryVector.getObject(0));\n+        Assert.assertEquals(new Text(\"bar\"), dictionaryVector.getObject(1));\n       }\n     }\n   }\ndiff --git a/java/vector/src/main/codegen/templates/ComplexReaders.java b/java/vector/src/main/codegen/templates/ComplexReaders.java\nindex 791064905..60347a2fc 100644\n--- a/java/vector/src/main/codegen/templates/ComplexReaders.java\n+++ b/java/vector/src/main/codegen/templates/ComplexReaders.java\n@@ -70,11 +70,7 @@ public Field getField(){\n   \n   public boolean isSet(){\n     <#if nullMode == \"Nullable\">\n-      <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n-        return !vector.getAccessor().isNull(idx());\n-      <#else>\n         return !vector.isNull(idx());\n-      </#if>\n     <#else>\n     return true;\n     </#if>\n@@ -97,19 +93,11 @@ public void read(${minor.class?cap_first}Holder h){\n   </#if>\n \n   public void read(Nullable${minor.class?cap_first}Holder h){\n-    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n-      vector.getAccessor().get(idx(), h);\n-    <#else>\n-      vector.get(idx(), h);\n-    </#if>\n+    vector.get(idx(), h);\n   }\n   \n   public ${friendlyType} read${safeType}(){\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-      return vector.getObject(idx());\n-    <#else>\n-      return vector.getAccessor().getObject(idx());\n-    </#if>\n+    return vector.getObject(idx());\n   }\n \n   <#if minor.class == \"TimeStampSec\" ||\n@@ -118,7 +106,7 @@ public void read(Nullable${minor.class?cap_first}Holder h){\n        minor.class == \"TimeStampNano\">\n   @Override\n   public ${minor.boxedType} read${minor.boxedType}(){\n-    return vector.getAccessor().get(idx());\n+    return vector.get(idx());\n   }\n   </#if>\n   \n@@ -127,11 +115,7 @@ public void copyValue(FieldWriter w){\n   }\n   \n   public Object readObject(){\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-      return (Object)vector.getObject(idx());\n-    <#else>\n-      return vector.getAccessor().getObject(idx());\n-    </#if>\n+    return (Object)vector.getObject(idx());\n   }\n }\n </#if>\ndiff --git a/java/vector/src/main/codegen/templates/ComplexWriters.java b/java/vector/src/main/codegen/templates/ComplexWriters.java\nindex 77f6594a0..406bbb39c 100644\n--- a/java/vector/src/main/codegen/templates/ComplexWriters.java\n+++ b/java/vector/src/main/codegen/templates/ComplexWriters.java\n@@ -39,16 +39,9 @@\n @SuppressWarnings(\"unused\")\n public class ${eName}WriterImpl extends AbstractFieldWriter {\n \n-  <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n-    private final Nullable${name}Vector.Mutator mutator;\n-  </#if>\n-\n   final Nullable${name}Vector vector;\n \n   public ${eName}WriterImpl(Nullable${name}Vector vector) {\n-    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n-      this.mutator = vector.getMutator();\n-    </#if>\n     this.vector = vector;\n   }\n \n@@ -108,51 +101,31 @@ public void setPosition(int idx) {\n   <#else>\n \n   public void write(${minor.class}Holder h) {\n-    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n-      mutator.setSafe(idx(), h);\n-      vector.getMutator().setValueCount(idx()+1);\n-    <#else>\n-        vector.setSafe(idx(), h);\n-        vector.setValueCount(idx()+1);\n-    </#if>\n+    vector.setSafe(idx(), h);\n+    vector.setValueCount(idx()+1);\n   }\n \n   public void write(Nullable${minor.class}Holder h) {\n-    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n-      mutator.setSafe(idx(), h);\n-      vector.getMutator().setValueCount(idx()+1);\n-    <#else>\n-      vector.setSafe(idx(), h);\n-      vector.setValueCount(idx()+1);\n-    </#if>\n+    vector.setSafe(idx(), h);\n+    vector.setValueCount(idx()+1);\n   }\n \n   public void write${minor.class}(<#list fields as field>${field.type} ${field.name}<#if field_has_next>, </#if></#list>) {\n-    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n-      mutator.setSafe(idx()<#if mode == \"Nullable\">, 1</#if><#list fields as field><#if field.include!true >, ${field.name}</#if></#list>);\n-      vector.getMutator().setValueCount(idx()+1);\n-    <#else>\n-      vector.setSafe(idx()<#if mode == \"Nullable\">, 1</#if><#list fields as field><#if field.include!true >, ${field.name}</#if></#list>);\n-      vector.setValueCount(idx()+1);\n-    </#if>\n+    vector.setSafe(idx()<#if mode == \"Nullable\">, 1</#if><#list fields as field><#if field.include!true >, ${field.name}</#if></#list>);\n+    vector.setValueCount(idx()+1);\n   }\n-  <#if minor.class == \"Decimal\">\n \n+  <#if minor.class == \"Decimal\">\n   public void write${minor.class}(${friendlyType} value) {\n-    mutator.setSafe(idx(), value);\n-    vector.getMutator().setValueCount(idx()+1);\n+    vector.setSafe(idx(), value);\n+    vector.setValueCount(idx()+1);\n   }\n   </#if>\n-  <#if mode == \"Nullable\">\n \n+  <#if mode == \"Nullable\">\n   public void writeNull() {\n-    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n-        mutator.setNull(idx());\n-        vector.getMutator().setValueCount(idx()+1);\n-    <#else>\n-        vector.setNull(idx());\n-        vector.setValueCount(idx()+1);\n-    </#if>\n+    vector.setNull(idx());\n+    vector.setValueCount(idx()+1);\n   }\n   </#if>\n   </#if>\ndiff --git a/java/vector/src/main/codegen/templates/LegacyUnionVector.java b/java/vector/src/main/codegen/templates/LegacyUnionVector.java\nnew file mode 100644\nindex 000000000..b9cb6dfdc\n--- /dev/null\n+++ b/java/vector/src/main/codegen/templates/LegacyUnionVector.java\n@@ -0,0 +1,356 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/LegacyUnionVector.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+        package org.apache.arrow.vector.complex;\n+\n+<#include \"/@includes/vv_imports.ftl\" />\n+        import com.google.common.collect.ImmutableList;\n+        import java.util.ArrayList;\n+        import java.util.Collections;\n+        import java.util.Iterator;\n+        import org.apache.arrow.vector.BaseDataValueVector;\n+        import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+        import org.apache.arrow.vector.util.CallBack;\n+        import org.apache.arrow.vector.schema.ArrowFieldNode;\n+\n+        import static org.apache.arrow.vector.types.UnionMode.Sparse;\n+\n+\n+\n+/*\n+ * This class is generated using freemarker and the ${.template_name} template.\n+ */\n+@SuppressWarnings(\"unused\")\n+\n+\n+/**\n+ * A vector which can hold values of different types. It does so by using a MapVector which contains a vector for each\n+ * primitive type that is stored. MapVector is used in order to take advantage of its serialization/deserialization methods,\n+ * as well as the addOrGet method.\n+ *\n+ * For performance reasons, UnionVector stores a cached reference to each subtype vector, to avoid having to do the map lookup\n+ * each time the vector is accessed.\n+ * Source code generated using FreeMarker template ${.template_name}\n+ */\n+public class LegacyUnionVector implements FieldVector {\n+\n+   private Accessor accessor = new Accessor();\n+   private Mutator mutator = new Mutator();\n+   private final UnionVector unionVector;\n+\n+   public LegacyUnionVector(String name, BufferAllocator allocator, CallBack callBack) {\n+     unionVector = new UnionVector(name, allocator, callBack);\n+   }\n+\n+   public BufferAllocator getAllocator() {\n+      return unionVector.getAllocator();\n+   }\n+\n+   @Override\n+   public MinorType getMinorType() {\n+      return MinorType.UNION;\n+   }\n+\n+   @Override\n+   public void initializeChildrenFromFields(List<Field> children) {\n+      unionVector.initializeChildrenFromFields(children);\n+   }\n+\n+   @Override\n+   public List<FieldVector> getChildrenFromFields() {\n+      return unionVector.getChildrenFromFields();\n+   }\n+\n+   @Override\n+   public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+      unionVector.loadFieldBuffers(fieldNode, ownBuffers);\n+   }\n+\n+   @Override\n+   public List<ArrowBuf> getFieldBuffers() {\n+      return unionVector.getFieldBuffers();\n+   }\n+\n+   @Override\n+   public List<BufferBacked> getFieldInnerVectors() {\n+      return unionVector.getFieldInnerVectors();\n+   }\n+\n+   @Override\n+   public long getValidityBufferAddress() {\n+      return unionVector.getValidityBufferAddress();\n+   }\n+\n+   @Override\n+   public long getDataBufferAddress() {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   @Override\n+   public long getOffsetBufferAddress() {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   @Override\n+   public ArrowBuf getValidityBuffer() {\n+      return unionVector.getValidityBuffer();\n+   }\n+\n+   @Override\n+   public ArrowBuf getDataBuffer() { throw new UnsupportedOperationException(); }\n+\n+   @Override\n+   public ArrowBuf getOffsetBuffer() { throw new UnsupportedOperationException(); }\n+\n+   public NullableMapVector getMap() {\n+      return unionVector.getMap();\n+   }\n+  <#list vv.types as type>\n+    <#list type.minor as minor>\n+      <#assign name = minor.class?cap_first />\n+      <#assign fields = minor.fields!type.fields />\n+      <#assign uncappedName = name?uncap_first/>\n+      <#assign lowerCaseName = name?lower_case/>\n+      <#if !minor.typeParams?? >\n+\n+   private Nullable${name}Vector ${uncappedName}Vector;\n+\n+   public Nullable${name}Vector get${name}Vector() {\n+      return unionVector.get${name}Vector();\n+   }\n+      </#if>\n+    </#list>\n+  </#list>\n+\n+   public ListVector getList() {\n+      return unionVector.getList();\n+   }\n+\n+   public int getTypeValue(int index) {\n+      return unionVector.getTypeValue(index);\n+   }\n+\n+   @Override\n+   public void allocateNew() throws OutOfMemoryException {\n+     unionVector.allocateNew();\n+   }\n+\n+   @Override\n+   public boolean allocateNewSafe() {\n+     return unionVector.allocateNewSafe();\n+   }\n+\n+   @Override\n+   public void reAlloc() {\n+      unionVector.reAlloc();\n+   }\n+\n+   @Override\n+   public void setInitialCapacity(int numRecords) {\n+   }\n+\n+   @Override\n+   public int getValueCapacity() {\n+      return unionVector.getValueCapacity();\n+   }\n+\n+   @Override\n+   public void close() {\n+     unionVector.close();\n+   }\n+\n+   @Override\n+   public void clear() {\n+      unionVector.clear();\n+   }\n+\n+   @Override\n+   public Field getField() {\n+      return unionVector.getField();\n+   }\n+\n+   @Override\n+   public TransferPair getTransferPair(BufferAllocator allocator) {\n+      return unionVector.getTransferPair(allocator);\n+   }\n+\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+      return unionVector.getTransferPair(ref, allocator);\n+   }\n+\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+      return unionVector.getTransferPair(ref, allocator, callBack);\n+   }\n+\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector target) {\n+      return unionVector.makeTransferPair(((LegacyUnionVector)target).unionVector);\n+   }\n+\n+   public void copyFrom(int inIndex, int outIndex, UnionVector from) {\n+      unionVector.copyFrom(inIndex, outIndex, from);\n+   }\n+\n+   public void copyFromSafe(int inIndex, int outIndex, UnionVector from) {\n+      unionVector.copyFromSafe(inIndex, outIndex, from);\n+   }\n+\n+   public FieldVector addVector(FieldVector v) {\n+     return unionVector.addVector(v);\n+   }\n+\n+   @Override\n+   public Accessor getAccessor() {\n+      return accessor;\n+   }\n+\n+   @Override\n+   public Mutator getMutator() {\n+      return mutator;\n+   }\n+\n+   @Override\n+   public FieldReader getReader() {\n+      return unionVector.getReader();\n+   }\n+\n+   public FieldWriter getWriter() {\n+      return unionVector.getWriter();\n+   }\n+\n+   @Override\n+   public int getBufferSize() {\n+      return unionVector.getBufferSize();\n+   }\n+\n+   @Override\n+   public int getBufferSizeFor(final int valueCount) {\n+     return unionVector.getBufferSizeFor(valueCount);\n+   }\n+\n+   @Override\n+   public ArrowBuf[] getBuffers(boolean clear) {\n+     return unionVector.getBuffers(clear);\n+   }\n+\n+   @Override\n+   public Iterator<ValueVector> iterator() {\n+      return unionVector.iterator();\n+   }\n+\n+   public class Accessor extends BaseValueVector.BaseAccessor {\n+\n+      @Override\n+      public Object getObject(int index) {\n+        return unionVector.getObject(index);\n+      }\n+\n+      public byte[] get(int index) {\n+         return unionVector.get(index);\n+      }\n+\n+      public void get(int index, ComplexHolder holder) {\n+      }\n+\n+      public void get(int index, UnionHolder holder) {\n+         unionVector.get(index, holder);\n+      }\n+\n+      public int getNullCount() {\n+         return unionVector.getNullCount();\n+      }\n+\n+      @Override\n+      public int getValueCount() {\n+         return unionVector.getValueCount();\n+      }\n+\n+      @Override\n+      public boolean isNull(int index) {\n+         return unionVector.isNull(index);\n+      }\n+\n+      public int isSet(int index) {\n+         return unionVector.isSet(index);\n+      }\n+   }\n+\n+   public class Mutator extends BaseValueVector.BaseMutator {\n+\n+      UnionWriter writer;\n+\n+      @Override\n+      public void setValueCount(int valueCount) {\n+         unionVector.setValueCount(valueCount);\n+      }\n+\n+      public void setSafe(int index, UnionHolder holder) {\n+        unionVector.setSafe(index, holder);\n+      }\n+    <#list vv.types as type>\n+      <#list type.minor as minor>\n+        <#assign name = minor.class?cap_first />\n+        <#assign fields = minor.fields!type.fields />\n+        <#assign uncappedName = name?uncap_first/>\n+        <#if !minor.typeParams?? >\n+      public void setSafe(int index, Nullable${name}Holder holder) {\n+         unionVector.setSafe(index, holder);\n+      }\n+\n+        </#if>\n+      </#list>\n+    </#list>\n+\n+      public void setType(int index, MinorType type) {\n+         unionVector.setType(index, type);\n+      }\n+\n+      @Override\n+      public void reset() { }\n+\n+      @Override\n+      public void generateTestData(int values) { }\n+   }\n+\n+   @Override\n+   @Deprecated\n+   public int getValueCount() { return getAccessor().getValueCount(); }\n+\n+   @Override\n+   @Deprecated\n+   public void setValueCount(int valueCount) { getMutator().setValueCount(valueCount);}\n+\n+   @Override\n+   @Deprecated\n+   public Object getObject(int index) { return getAccessor().getObject(index); }\n+\n+   @Override\n+   @Deprecated\n+   public int getNullCount() { return getAccessor().getNullCount(); }\n+\n+   @Override\n+   @Deprecated\n+   public boolean isNull(int index) { return getAccessor().isNull(index); }\n+}\ndiff --git a/java/vector/src/main/codegen/templates/MapWriters.java b/java/vector/src/main/codegen/templates/MapWriters.java\nindex b89f91457..6afd508e6 100644\n--- a/java/vector/src/main/codegen/templates/MapWriters.java\n+++ b/java/vector/src/main/codegen/templates/MapWriters.java\n@@ -184,7 +184,7 @@ public ListWriter list(String name) {\n   }\n \n   public void setValueCount(int count) {\n-    container.getMutator().setValueCount(count);\n+    container.setValueCount(count);\n   }\n \n   @Override\n@@ -199,7 +199,7 @@ public void setPosition(int index) {\n   public void start() {\n     <#if mode == \"Single\">\n     <#else>\n-    container.getMutator().setIndexDefined(idx());\n+    container.setIndexDefined(idx());\n     </#if>\n   }\n \ndiff --git a/java/vector/src/main/codegen/templates/NullableValueVectors.java b/java/vector/src/main/codegen/templates/NullableValueVectors.java\nindex 5d1f5a33b..8e5b10b64 100644\n--- a/java/vector/src/main/codegen/templates/NullableValueVectors.java\n+++ b/java/vector/src/main/codegen/templates/NullableValueVectors.java\n@@ -19,14 +19,8 @@\n <#list vv.types as type>\n <#list type.minor as minor>\n \n-<#if minor.class == \"Int\" || minor.class == \"VarChar\">\n <#assign className = \"LegacyNullable${minor.class}Vector\" />\n <#assign valuesName = \"Nullable${minor.class}Vector\" />\n-<#else>\n-<#assign className = \"Nullable${minor.class}Vector\" />\n-<#assign valuesName = \"${minor.class}Vector\" />\n-</#if>\n-\n <#assign friendlyType = (minor.friendlyType!minor.boxedType!type.boxedType) />\n \n <@pp.changeOutputFile name=\"/org/apache/arrow/vector/${className}.java\" />\n@@ -50,35 +44,21 @@\n  * NB: this class is automatically generated from ${.template_name} and ValueVectorTypes.tdd using FreeMarker.\n  */\n @SuppressWarnings(\"unused\")\n-<#if minor.class == \"Int\" || minor.class == \"VarChar\">\n @Deprecated\n-</#if>\n public final class ${className} extends BaseValueVector implements <#if type.major == \"VarLen\">VariableWidth<#else>FixedWidth</#if>Vector, FieldVector {\n   private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(${className}.class);\n \n protected final static byte[] emptyByteArray = new byte[]{};\n \n-  <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n-  private final FieldReader reader = new ${minor.class}ReaderImpl(${className}.this);\n-  </#if>\n-\n   private final String bitsField = \"$bits$\";\n   private final String valuesField = \"$values$\";\n \n-  <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n-  private final Field field;\n-  </#if>\n-\n   final BitVector bits = new BitVector(bitsField, allocator);\n   final ${valuesName} values;\n \n   private final Mutator mutator;\n   private final Accessor accessor;\n \n-  <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n-  private final List<BufferBacked> innerVectors;\n-  </#if>\n-\n   <#if minor.typeParams??>\n     <#assign typeParams = minor.typeParams?reverse>\n     <#list typeParams as typeParam>\n@@ -122,33 +102,12 @@\n     </#if>\n     this.mutator = new Mutator();\n     this.accessor = new Accessor();\n-    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n-    this.field = new Field(name, fieldType, null);\n-    innerVectors = Collections.unmodifiableList(Arrays.<BufferBacked>asList(\n-        bits,\n-        <#if type.major = \"VarLen\">\n-        values.offsetVector,\n-        </#if>\n-        values\n-    ));\n-    </#if>\n   }\n \n-  <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n-  /* not needed for new vectors */\n-  public BitVector getValidityVector() {\n-    return bits;\n-  }\n-  </#if>\n-\n   @Override\n   public List<BufferBacked> getFieldInnerVectors() {\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.getFieldInnerVectors();\n-    <#else>\n-        return innerVectors;\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    return values.getFieldInnerVectors();\n   }\n \n   @Override\n@@ -165,123 +124,61 @@ public void initializeChildrenFromFields(List<Field> children) {\n \n   @Override\n   public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        values.loadFieldBuffers(fieldNode, ownBuffers);\n-    <#else>\n-    <#if type.major = \"VarLen\">\n-    // variable width values: truncate offset vector buffer to size (#1)\n-    org.apache.arrow.vector.BaseDataValueVector.truncateBufferBasedOnSize(ownBuffers, 1,\n-        values.offsetVector.getBufferSizeFor(\n-        fieldNode.getLength() == 0? 0 : fieldNode.getLength() + 1));\n-    mutator.lastSet = fieldNode.getLength() - 1;\n-    <#else>\n-    // fixed width values truncate value vector to size (#1)\n-    org.apache.arrow.vector.BaseDataValueVector.truncateBufferBasedOnSize(ownBuffers, 1, values.getBufferSizeFor(fieldNode.getLength()));\n-    </#if>\n-    org.apache.arrow.vector.BaseDataValueVector.load(fieldNode, getFieldInnerVectors(), ownBuffers);\n-    bits.valueCount = fieldNode.getLength();\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    values.loadFieldBuffers(fieldNode, ownBuffers);\n   }\n \n   public List<ArrowBuf> getFieldBuffers() {\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.getFieldBuffers();\n-    <#else>\n-        return org.apache.arrow.vector.BaseDataValueVector.unload(getFieldInnerVectors());\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    return values.getFieldBuffers();\n   }\n \n   @Override\n   public Field getField() {\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.getField();\n-    <#else>\n-      return field;\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    return values.getField();\n   }\n \n   @Override\n   public MinorType getMinorType() {\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.getMinorType();\n-    <#else>\n-        return MinorType.${minor.class?upper_case};\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    return values.getMinorType();\n   }\n \n   @Override\n   public FieldReader getReader(){\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.getReader();\n-    <#else>\n-        return reader;\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    return values.getReader();\n   }\n \n   @Override\n   public int getValueCapacity(){\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.getValueCapacity();\n-    <#else>\n-        return Math.min(bits.getValueCapacity(), values.getValueCapacity());\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    return values.getValueCapacity();\n   }\n \n   @Override\n   public ArrowBuf[] getBuffers(boolean clear) {\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.getBuffers(clear);\n-    <#else>\n-    final ArrowBuf[] buffers = ObjectArrays.concat(bits.getBuffers(false), values.getBuffers(false), ArrowBuf.class);\n-    if (clear) {\n-      for (final ArrowBuf buffer:buffers) {\n-        buffer.retain(1);\n-      }\n-      clear();\n-    }\n-    return buffers;\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    return values.getBuffers(clear);\n   }\n \n   @Override\n   public void close() {\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        values.close();\n-    <#else>\n-        bits.close();\n-        values.close();\n-        super.close();\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    values.close();\n   }\n \n   @Override\n   public void clear() {\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        values.clear();\n-    <#else>\n-        bits.clear();\n-        values.clear();\n-        super.clear();\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    values.clear();\n   }\n \n   @Override\n   public int getBufferSize(){\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.getBufferSize();\n-    <#else>\n-        return values.getBufferSize() + bits.getBufferSize();\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    return values.getBufferSize();\n   }\n \n   @Override\n@@ -289,14 +186,8 @@ public int getBufferSizeFor(final int valueCount) {\n     if (valueCount == 0) {\n       return 0;\n     }\n-\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.getBufferSizeFor(valueCount);\n-    <#else>\n-        return values.getBufferSizeFor(valueCount)\n-          + bits.getBufferSizeFor(valueCount);\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    return values.getBufferSizeFor(valueCount);\n   }\n \n   public ArrowBuf getBuffer() {\n@@ -309,93 +200,38 @@ public ArrowBuf getBuffer() {\n \n   @Override\n   public void setInitialCapacity(int numRecords) {\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        values.setInitialCapacity(numRecords);\n-    <#else>\n-        bits.setInitialCapacity(numRecords);\n-        values.setInitialCapacity(numRecords);\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    values.setInitialCapacity(numRecords);\n   }\n \n   @Override\n   public void allocateNew() {\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        values.allocateNew();\n-    <#else>\n-    if(!allocateNewSafe()){\n-      throw new OutOfMemoryException(\"Failure while allocating buffer.\");\n-    }\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    values.allocateNew();\n   }\n \n   @Override\n   public boolean allocateNewSafe() {\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.allocateNewSafe();\n-    <#else>\n-    /* Boolean to keep track if all the memory allocations were successful\n-     * Used in the case of composite vectors when we need to allocate multiple\n-     * buffers for multiple vectors. If one of the allocations failed we need to\n-     * clear all the memory that we allocated\n-     */\n-    boolean success = false;\n-    try {\n-      success = values.allocateNewSafe() && bits.allocateNewSafe();\n-    } finally {\n-      if (!success) {\n-        clear();\n-      }\n-    }\n-    bits.zeroVector();\n-    mutator.reset();\n-    accessor.reset();\n-    return success;\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    return values.allocateNewSafe();\n   }\n \n   @Override\n   public void reAlloc() {\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        values.reAlloc();\n-    <#else>\n-        bits.reAlloc();\n-        values.reAlloc();\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    values.reAlloc();\n   }\n \n   public void reset() {\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        values.reset();\n-    <#else>\n-    bits.zeroVector();\n-    mutator.reset();\n-    accessor.reset();\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    values.reset();\n   }\n \n   <#if type.major == \"VarLen\">\n   @Override\n   public void allocateNew(int totalBytes, int valueCount) {\n-    <#if minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        values.allocateNew(totalBytes, valueCount);\n-    <#else>\n-    try {\n-      values.allocateNew(totalBytes, valueCount);\n-      bits.allocateNew(valueCount);\n-    } catch(RuntimeException e) {\n-      clear();\n-      throw e;\n-    }\n-    bits.zeroVector();\n-    mutator.reset();\n-    accessor.reset();\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    values.allocateNew(totalBytes, valueCount);\n   }\n \n   @Override\n@@ -411,21 +247,8 @@ public int getCurrentSizeInBytes(){\n   <#else>\n   @Override\n   public void allocateNew(int valueCount) {\n-    <#if minor.class == \"Int\">\n-        /* DELEGATE TO NEW VECTOR */\n-        values.allocateNew(valueCount);\n-    <#else>\n-    try {\n-      values.allocateNew(valueCount);\n-      bits.allocateNew(valueCount);\n-    } catch(OutOfMemoryException e) {\n-      clear();\n-      throw e;\n-    }\n-    bits.zeroVector();\n-    mutator.reset();\n-    accessor.reset();\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    values.allocateNew(valueCount);\n   }\n \n   /**\n@@ -433,13 +256,8 @@ public void allocateNew(int valueCount) {\n    */\n   @Override\n   public void zeroVector() {\n-    <#if minor.class == \"Int\">\n-        /* DELEGATE TO NEW VECTOR */\n-        values.zeroVector();\n-    <#else>\n-        bits.zeroVector();\n-        values.zeroVector();\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    values.zeroVector();\n   }\n   </#if>\n \n@@ -447,53 +265,36 @@ public void zeroVector() {\n \n   @Override\n   public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.getTransferPair(ref, allocator, callBack);\n-    <#else>\n-        return getTransferPair(ref, allocator);\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    return values.getTransferPair(ref, allocator, callBack);\n   }\n \n \n \n   @Override\n   public TransferPair getTransferPair(BufferAllocator allocator){\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.getTransferPair(allocator);\n-    <#else>\n-        return new TransferImpl(name, allocator);\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    return values.getTransferPair(allocator);\n   }\n \n \n \n   @Override\n   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.getTransferPair(ref, allocator);\n-    <#else>\n-        return new TransferImpl(ref, allocator);\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    return values.getTransferPair(ref, allocator);\n   }\n \n \n \n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.makeTransferPair(to);\n-    <#else>\n-        return new TransferImpl((${className}) to);\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    return values.makeTransferPair(to);\n   }\n \n \n \n-  <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n   public void transferTo(${valuesName} target) {\n     /* DELEGATE TO NEW VECTOR */\n     <#if type.major == \"VarLen\">\n@@ -512,61 +313,6 @@ public void splitAndTransferTo(int startIndex, int length, ${valuesName} target)\n     </#if>\n   }\n \n-  <#else>\n-  public void transferTo(${className} target){\n-    bits.transferTo(target.bits);\n-    values.transferTo(target.values);\n-    <#if type.major == \"VarLen\">\n-    target.mutator.lastSet = mutator.lastSet;\n-    </#if>\n-    clear();\n-  }\n-\n-  public void splitAndTransferTo(int startIndex, int length, ${className} target) {\n-    bits.splitAndTransferTo(startIndex, length, target.bits);\n-    values.splitAndTransferTo(startIndex, length, target.values);\n-    <#if type.major == \"VarLen\">\n-    target.mutator.lastSet = length - 1;\n-    </#if>\n-  }\n-  </#if>\n-\n-\n-\n-  <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n-  private class TransferImpl implements TransferPair {\n-    ${className} to;\n-\n-    public TransferImpl(String ref, BufferAllocator allocator){\n-      to = new ${className}(ref, field.getFieldType(), allocator);\n-    }\n-\n-    public TransferImpl(${className} to){\n-      this.to = to;\n-    }\n-\n-    @Override\n-    public ${className} getTo(){\n-      return to;\n-    }\n-\n-    @Override\n-    public void transfer(){\n-      transferTo(to);\n-    }\n-\n-    @Override\n-    public void splitAndTransfer(int startIndex, int length) {\n-      splitAndTransferTo(startIndex, length, to);\n-    }\n-\n-    @Override\n-    public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, ${className}.this);\n-    }\n-  }\n-  </#if>\n-\n \n \n   @Override\n@@ -580,8 +326,6 @@ public Mutator getMutator(){\n   }\n \n \n-\n-  <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n   public void copyFrom(int fromIndex, int thisIndex, ${valuesName} from) {\n     /* DELEGATE TO NEW VECTOR */\n     values.copyFrom(fromIndex, thisIndex, from);\n@@ -591,107 +335,43 @@ public void copyFromSafe(int fromIndex, int thisIndex, ${valuesName} from) {\n     /* DELEGATE TO NEW VECTOR */\n     values.copyFromSafe(fromIndex, thisIndex, from);\n   }\n-  <#else>\n-  public void copyFrom(int fromIndex, int thisIndex, ${className} from) {\n-    final Accessor fromAccessor = from.getAccessor();\n-    if (!fromAccessor.isNull(fromIndex)) {\n-      mutator.set(thisIndex, fromAccessor.get(fromIndex));\n-    }\n-    <#if type.major == \"VarLen\">mutator.lastSet = thisIndex;</#if>\n-  }\n-\n-  public void copyFromSafe(int fromIndex, int thisIndex, ${valuesName} from){\n-    <#if type.major == \"VarLen\">\n-    mutator.fillEmpties(thisIndex);\n-    </#if>\n-    values.copyFromSafe(fromIndex, thisIndex, from);\n-    bits.getMutator().setSafeToOne(thisIndex);\n-    <#if type.major == \"VarLen\">mutator.lastSet = thisIndex;</#if>\n-  }\n-\n-  public void copyFromSafe(int fromIndex, int thisIndex, ${className} from){\n-    <#if type.major == \"VarLen\">\n-    mutator.fillEmpties(thisIndex);\n-    </#if>\n-    bits.copyFromSafe(fromIndex, thisIndex, from.bits);\n-    values.copyFromSafe(fromIndex, thisIndex, from.values);\n-    <#if type.major == \"VarLen\">mutator.lastSet = thisIndex;</#if>\n-  }\n-  </#if>\n \n   @Override\n   public long getValidityBufferAddress() {\n-    /* address of the databuffer associated with the bitVector */\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.getValidityBufferAddress();\n-    <#else>\n-        return (bits.getDataBuffer().memoryAddress());\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    return values.getValidityBufferAddress();\n   }\n \n   @Override\n   public long getDataBufferAddress() {\n-    /* address of the dataBuffer associated with the valueVector */\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-          /* DELEGATE TO NEW VECTOR */\n-          return values.getDataBufferAddress();\n-    <#else>\n-          return (bits.getDataBuffer().memoryAddress());\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    return values.getDataBufferAddress();\n   }\n \n   @Override\n   public long getOffsetBufferAddress() {\n-    /* address of the dataBuffer associated with the offsetVector\n-     * this operation is not supported for fixed-width vector types.\n-     */\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-          /* DELEGATE TO NEW VECTOR */\n-          return values.getOffsetBufferAddress();\n-    <#else>\n-        <#if type.major != \"VarLen\">\n-          throw new UnsupportedOperationException();\n-        <#else>\n-          return (values.getOffsetAddr());\n-        </#if>\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    return values.getOffsetBufferAddress();\n   }\n \n   @Override\n   public ArrowBuf getValidityBuffer() {\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-          /* DELEGATE TO NEW VECTOR */\n-          return values.getValidityBuffer();\n-    <#else>\n-          return (bits.getDataBuffer());\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    return values.getValidityBuffer();\n   }\n \n   @Override\n   public ArrowBuf getDataBuffer() {\n-    /* dataBuffer associated with the valueVector */\n     return (values.getDataBuffer());\n   }\n \n   @Override\n   public ArrowBuf getOffsetBuffer() {\n-    /* dataBuffer associated with the offsetVector of the valueVector */\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.getOffsetBuffer();\n-    <#else>\n-        <#if type.major != \"VarLen\">\n-          throw new UnsupportedOperationException();\n-        <#else>\n-          return (values.getOffsetBuffer());\n-        </#if>\n-    </#if>\n+    /* DELEGATE TO NEW VECTOR */\n+    return values.getOffsetBuffer();\n   }\n \n   public final class Accessor extends BaseDataValueVector.BaseAccessor <#if type.major = \"VarLen\">implements VariableWidthVector.VariableWidthAccessor</#if> {\n-    final BitVector.Accessor bAccessor = bits.getAccessor();\n-    final ${valuesName}.Accessor vAccessor = values.getAccessor();\n \n     /**\n      * Get the element at the specified position.\n@@ -699,119 +379,67 @@ public ArrowBuf getOffsetBuffer() {\n      * @param  index   position of the value\n      * @return value of the element, if not null\n      */\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-      public <#if type.major == \"VarLen\">byte[]<#else>${minor.javaType!type.javaType}</#if> get(int index) {\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.get(index);\n-      }\n-    <#else>\n-\n-      public <#if type.major == \"VarLen\">byte[]<#else>${minor.javaType!type.javaType}</#if> get(int index) {\n-        if (isNull(index)) {\n-          throw new IllegalStateException(\"Can't get a null value\");\n-        }\n-        return vAccessor.get(index);\n-      }\n-    </#if>\n+    public <#if type.major == \"VarLen\">byte[]<#else>${minor.javaType!type.javaType}</#if> get(int index) {\n+      /* DELEGATE TO NEW VECTOR */\n+      return values.get(index);\n+    }\n \n     @Override\n     public boolean isNull(int index) {\n-      <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.isNull(index);\n-      <#else>\n-        return isSet(index) == 0;\n-      </#if>\n+      /* DELEGATE TO NEW VECTOR */\n+      return values.isNull(index);\n     }\n \n     public int isSet(int index){\n-      <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.isSet(index);\n-      <#else>\n-        return bAccessor.get(index);\n-      </#if>\n+      /* DELEGATE TO NEW VECTOR */\n+      return values.isSet(index);\n     }\n \n     <#if type.major == \"VarLen\">\n     public long getStartEnd(int index){\n-      <#if minor.class == \"VarChar\">\n         /* DELEGATE TO NEW VECTOR */\n         return values.getStartEnd(index);\n-      <#else>\n-        return vAccessor.getStartEnd(index);\n-      </#if>\n     }\n \n     @Override\n     public int getValueLength(int index) {\n-      <#if minor.class == \"VarChar\">\n         /* DELEGATE TO NEW VECTOR */\n         return values.getValueLength(index);\n-      <#else>\n-        return values.getAccessor().getValueLength(index);\n-      </#if>\n     }\n     </#if>\n \n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n     public void get(int index, Nullable${minor.class}Holder holder){\n         /* DELEGATE TO NEW VECTOR */\n         values.get(index, holder);\n     }\n-    <#else>\n-    public void get(int index, Nullable${minor.class}Holder holder){\n-      vAccessor.get(index, holder);\n-      holder.isSet = bAccessor.get(index);\n-    }\n-    </#if>\n \n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n     @Override\n     public ${friendlyType} getObject(int index) {\n       /* DELEGATE TO NEW VECTOR */\n       return values.getObject(index);\n     }\n-    <#else>\n-    @Override\n-    public ${friendlyType} getObject(int index) {\n-      if (isNull(index)) {\n-          return null;\n-      }else{\n-        return vAccessor.getObject(index);\n-      }\n-    }\n-    </#if>\n \n     <#if minor.class == \"IntervalYear\" || minor.class == \"IntervalDay\">\n     public StringBuilder getAsStringBuilder(int index) {\n-      if (isNull(index)) {\n-          return null;\n-      }else{\n-        return vAccessor.getAsStringBuilder(index);\n-      }\n+       /* DELEGATE TO NEW VECTOR */\n+       return values.getAsStringBuilder(index);\n     }\n     </#if>\n \n     @Override\n     public int getValueCount(){\n-      <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-        /* DELEGATE TO NEW VECTOR */\n-        return values.getValueCount();\n-      <#else>\n-        return bits.getAccessor().getValueCount();\n-      </#if>\n+      /* DELEGATE TO NEW VECTOR */\n+      return values.getValueCount();\n     }\n \n-    public void reset(){}\n+    public void reset() { }\n   }\n \n   public final class Mutator extends BaseDataValueVector.BaseMutator implements NullableVectorDefinitionSetter<#if type.major = \"VarLen\">, VariableWidthVector.VariableWidthMutator</#if> {\n     private int setCount;\n     <#if type.major = \"VarLen\"> private int lastSet = -1;</#if>\n \n-    private Mutator(){\n-    }\n+    private Mutator() { }\n \n     public ${valuesName} getVectorWithValues() {\n       return values;\n@@ -819,12 +447,9 @@ private Mutator(){\n \n \n     @Override\n-    public void setIndexDefined(int index){\n-      <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+    public void setIndexDefined(int index) {\n+      /* DELEGATE TO NEW VECTOR */\n       values.setIndexDefined(index);\n-      <#else>\n-      bits.getMutator().setToOne(index);\n-      </#if>\n     }\n \n \n@@ -835,32 +460,14 @@ public void setIndexDefined(int index){\n      * @param index   position of the bit to set\n      * @param value   array of bytes (or int if smaller than 4 bytes) to write\n      */\n-\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n     public void set(int index, <#if type.major == \"VarLen\">byte[]<#elseif (type.width < 4)>int<#else>${minor.javaType!type.javaType}</#if> value) {\n        /* DELEGATE TO NEW VECTOR */\n        values.set(index, value);\n     }\n-    <#else>\n-    public void set(int index, <#if type.major == \"VarLen\">byte[]<#elseif (type.width < 4)>int<#else>${minor.javaType!type.javaType}</#if> value) {\n-      setCount++;\n-      final ${valuesName}.Mutator valuesMutator = values.getMutator();\n-      final BitVector.Mutator bitsMutator = bits.getMutator();\n-      <#if type.major == \"VarLen\">\n-      for (int i = lastSet + 1; i < index; i++) {\n-        valuesMutator.set(i, emptyByteArray);\n-      }\n-      </#if>\n-      bitsMutator.setToOne(index);\n-      valuesMutator.set(index, value);\n-      <#if type.major == \"VarLen\">lastSet = index;</#if>\n-    }\n-    </#if>\n \n \n \n     <#if type.major == \"VarLen\">\n-    <#if minor.class == \"VarChar\">\n     public void fillEmpties(int index) {\n       /* DELEGATE TO NEW VECTOR */\n       values.fillEmpties(index);\n@@ -871,203 +478,55 @@ public void setValueLengthSafe(int index, int length) {\n       /* DELEGATE TO NEW VECTOR */\n       values.setValueLengthSafe(index, length);\n     }\n-\n-    <#else>\n-    public void fillEmpties(int index){\n-      final ${valuesName}.Mutator valuesMutator = values.getMutator();\n-      for (int i = lastSet + 1; i < index; i++) {\n-        valuesMutator.setSafe(i, emptyByteArray);\n-      }\n-      while(index > bits.getValueCapacity()) {\n-        bits.reAlloc();\n-      }\n-      lastSet = index - 1;\n-    }\n-\n-    @Override\n-    public void setValueLengthSafe(int index, int length) {\n-      values.getMutator().setValueLengthSafe(index, length);\n-      lastSet = index;\n-    }\n-    </#if>\n     </#if>\n \n \n-\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n     public void setSafe(int index, byte[] value, int start, int length) {\n        /* DELEGATE TO NEW VECTOR */\n       values.setSafe(index, value, start, length);\n     }\n-    <#else>\n-    public void setSafe(int index, byte[] value, int start, int length) {\n-      <#if type.major != \"VarLen\">\n-      throw new UnsupportedOperationException();\n-      <#else>\n-      fillEmpties(index);\n-\n-      bits.getMutator().setSafeToOne(index);\n-      values.getMutator().setSafe(index, value, start, length);\n-      setCount++;\n-      <#if type.major == \"VarLen\">lastSet = index;</#if>\n-      </#if>\n-    }\n-    </#if>\n \n \n-\n-    <#if minor.class == \"VarChar\">\n     public void setSafe(int index, ByteBuffer value, int start, int length) {\n        /* DELEGATE TO NEW VECTOR */\n        values.setSafe(index, value, start, length);\n     }\n-    <#else>\n-    public void setSafe(int index, ByteBuffer value, int start, int length) {\n-      <#if type.major != \"VarLen\">\n-      throw new UnsupportedOperationException();\n-      <#else>\n-      fillEmpties(index);\n-\n-      bits.getMutator().setSafeToOne(index);\n-      values.getMutator().setSafe(index, value, start, length);\n-      setCount++;\n-      <#if type.major == \"VarLen\">lastSet = index;</#if>\n-      </#if>\n-    }\n-    </#if>\n-\n \n \n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n     public void setNull(int index) {\n        /* DELEGATE TO NEW VECTOR */\n        values.setNull(index);\n     }\n-    <#else>\n-    public void setNull(int index){\n-      bits.getMutator().setSafe(index, 0);\n-    }\n-    </#if>\n-\n-\n-\n-    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n-    /* these methods are probably not needed */\n-    public void setSkipNull(int index, ${minor.class}Holder holder){\n-      values.getMutator().set(index, holder);\n-    }\n-\n-    public void setSkipNull(int index, Nullable${minor.class}Holder holder){\n-      values.getMutator().set(index, holder);\n-    }\n-    </#if>\n \n \n-\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n     public void set(int index, Nullable${minor.class}Holder holder) {\n       /* DELEGATE TO NEW VECTOR */\n       values.set(index, holder);\n     }\n-    <#else>\n-    public void set(int index, Nullable${minor.class}Holder holder) {\n-      final ${valuesName}.Mutator valuesMutator = values.getMutator();\n-      <#if type.major == \"VarLen\">\n-      for (int i = lastSet + 1; i < index; i++) {\n-        valuesMutator.set(i, emptyByteArray);\n-      }\n-      </#if>\n-      bits.getMutator().set(index, holder.isSet);\n-      valuesMutator.set(index, holder);\n-      <#if type.major == \"VarLen\">lastSet = index;</#if>\n-    }\n-    </#if>\n \n \n-\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n     public void set(int index, ${minor.class}Holder holder) {\n         /* DELEGATE TO NEW VECTOR */\n         values.set(index, holder);\n     }\n-    <#else>\n-    public void set(int index, ${minor.class}Holder holder) {\n-      final ${valuesName}.Mutator valuesMutator = values.getMutator();\n-      <#if type.major == \"VarLen\">\n-      for (int i = lastSet + 1; i < index; i++) {\n-        valuesMutator.set(i, emptyByteArray);\n-      }\n-      </#if>\n-      bits.getMutator().setToOne(index);\n-      valuesMutator.set(index, holder);\n-      <#if type.major == \"VarLen\">lastSet = index;</#if>\n-    }\n-    </#if>\n-\n \n \n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n     public boolean isSafe(int outIndex) {\n        /* DELEGATE TO NEW VECTOR */\n        return values.isSafe(outIndex);\n     }\n-    <#else>\n-    public boolean isSafe(int outIndex) {\n-      return outIndex < ${className}.this.getValueCapacity();\n-    }\n-    </#if>\n-\n \n \n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n-    <#if minor.class == \"Int\">\n-    public void set(int index, int isSet, int valueField) {\n-      /* DELEGATE TO NEW VECTOR */\n-      values.set(index, isSet, valueField);\n-    }\n-    public void setSafe(int index, int isSet, int valueField) {\n-      /* DELEGATE TO NEW VECTOR */\n-      values.setSafe(index, isSet, valueField);\n-    }\n-    </#if>\n-    <#if minor.class == \"VarChar\">\n-    public void set(int index, int isSet, int startField, int endField, ArrowBuf bufferField ) {\n-      /* DELEGATE TO NEW VECTOR */\n-      values.set(index, isSet, startField, endField, bufferField);\n-    }\n-    public void setSafe(int index, int isSet, int startField, int endField, ArrowBuf bufferField ) {\n-        /* DELEGATE TO NEW VECTOR */\n-        values.setSafe(index, isSet, startField, endField, bufferField);\n-    }\n-    </#if>\n-    <#else>\n     <#assign fields = minor.fields!type.fields />\n     public void set(int index, int isSet<#list fields as field>, ${field.type} ${field.name}Field</#list> ){\n-      final ${valuesName}.Mutator valuesMutator = values.getMutator();\n-      <#if type.major == \"VarLen\">\n-      for (int i = lastSet + 1; i < index; i++) {\n-        valuesMutator.set(i, emptyByteArray);\n-      }\n-      </#if>\n-      bits.getMutator().set(index, isSet);\n-      valuesMutator.set(index<#list fields as field><#if field.include!true >, ${field.name}Field</#if></#list>);\n-      <#if type.major == \"VarLen\">lastSet = index;</#if>\n+      values.set(index, isSet<#list fields as field><#if field.include!true >, ${field.name}Field</#if></#list>);\n     }\n \n     public void setSafe(int index, int isSet<#list fields as field><#if field.include!true >, ${field.type} ${field.name}Field</#if></#list> ) {\n-      <#if type.major == \"VarLen\">\n-      fillEmpties(index);\n-      </#if>\n-      bits.getMutator().setSafe(index, isSet);\n-      values.getMutator().setSafe(index<#list fields as field><#if field.include!true >, ${field.name}Field</#if></#list>);\n-      setCount++;\n-      <#if type.major == \"VarLen\">lastSet = index;</#if>\n+      values.setSafe(index, isSet<#list fields as field><#if field.include!true >, ${field.name}Field</#if></#list>);\n     }\n-    </#if>\n \n \n-\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n     public void setSafe(int index, Nullable${minor.class}Holder value) {\n       /* DELEGATE TO NEW VECTOR */\n       values.setSafe(index, value);\n@@ -1077,40 +536,12 @@ public void setSafe(int index, ${minor.class}Holder value) {\n       /* DELEGATE TO NEW VECTOR */\n       values.setSafe(index, value);\n     }\n-    <#else>\n-    public void setSafe(int index, Nullable${minor.class}Holder value) {\n-      <#if type.major == \"VarLen\">\n-      fillEmpties(index);\n-      </#if>\n-      bits.getMutator().setSafe(index, value.isSet);\n-      values.getMutator().setSafe(index, value);\n-      setCount++;\n-      <#if type.major == \"VarLen\">lastSet = index;</#if>\n-    }\n-\n-    public void setSafe(int index, ${minor.class}Holder value) {\n-      <#if type.major == \"VarLen\">\n-      fillEmpties(index);\n-      </#if>\n-      bits.getMutator().setSafeToOne(index);\n-      values.getMutator().setSafe(index, value);\n-      setCount++;\n-      <#if type.major == \"VarLen\">lastSet = index;</#if>\n-    }\n-    </#if>\n-\n \n \n     <#if !(type.major == \"VarLen\" || minor.class == \"IntervalDay\")>\n     public void setSafe(int index, ${minor.javaType!type.javaType} value) {\n-      <#if minor.class == \"Int\">\n-        /* DELEGATE TO NEW VECTOR */\n-        values.setSafe(index, value);\n-      <#else>\n-      bits.getMutator().setSafeToOne(index);\n-      values.getMutator().setSafe(index, value);\n-      setCount++;\n-      </#if>\n+      /* DELEGATE TO NEW VECTOR */\n+      values.setSafe(index, value);\n     }\n     </#if>\n \n@@ -1118,93 +549,45 @@ public void setSafe(int index, ${minor.javaType!type.javaType} value) {\n \n     <#if minor.class == \"Decimal\">\n     public void set(int index, ${friendlyType} value) {\n-      bits.getMutator().setToOne(index);\n-      values.getMutator().set(index, value);\n+      /* DELEGATE TO NEW VECTOR */\n+      values.set(index, value);\n     }\n \n     public void setSafe(int index, ${friendlyType} value) {\n-      bits.getMutator().setSafeToOne(index);\n-      values.getMutator().setSafe(index, value);\n-      setCount++;\n+      /* DELEGATE TO NEW VECTOR */\n+      values.setSafe(index, value);\n     }\n     </#if>\n \n \n-\n-    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n     @Override\n     public void setValueCount(int valueCount) {\n       /* DELEGATE TO NEW VECTOR */\n       values.setValueCount(valueCount);\n     }\n-    <#else>\n-    @Override\n-    public void setValueCount(int valueCount) {\n-      assert valueCount >= 0;\n-      <#if type.major == \"VarLen\">\n-      fillEmpties(valueCount);\n-      </#if>\n-      values.getMutator().setValueCount(valueCount);\n-      bits.getMutator().setValueCount(valueCount);\n-    }\n-    </#if>\n-\n \n \n-    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n     /* THIS METHOD IS PROBABLY NOT NEEDED FOR NEW VECTORS */\n     @Override\n-    public void generateTestData(int valueCount){\n-      bits.getMutator().generateTestDataAlt(valueCount);\n-      values.getMutator().generateTestData(valueCount);\n-      <#if type.major = \"VarLen\">lastSet = valueCount;</#if>\n-      setValueCount(valueCount);\n-    }\n-    </#if>\n+    public void generateTestData(int valueCount) { }\n \n \n-\n-    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n     /* MUTATOR RESET IS NOT NEEDED FOR NEW VECTORS */\n     @Override\n-    public void reset(){\n-      setCount = 0;\n-      <#if type.major = \"VarLen\">lastSet = -1;</#if>\n-    }\n-    </#if>\n-\n+    public void reset() { }\n \n \n-    <#if minor.class == \"VarChar\">\n+    <#if type.major == \"VarLen\">\n     public void setLastSet(int value) {\n       /* DELEGATE TO NEW VECTOR */\n       values.setLastSet(value);\n     }\n-    <#else>\n-    public void setLastSet(int value) {\n-      <#if type.major = \"VarLen\">\n-        lastSet = value;\n-      <#else>\n-        throw new UnsupportedOperationException();\n-      </#if>\n-    }\n-    </#if>\n \n \n-\n-    <#if minor.class == \"VarChar\">\n     public int getLastSet() {\n       /* DELEGATE TO NEW VECTOR */\n       return values.getLastSet();\n     }\n-    <#else>\n-    public int getLastSet() {\n-      <#if type.major != \"VarLen\">\n-        throw new UnsupportedOperationException();\n-      <#else>\n-        return lastSet;\n-      </#if>\n-    }\n     </#if>\n   }\n }\ndiff --git a/java/vector/src/main/codegen/templates/UnionListWriter.java b/java/vector/src/main/codegen/templates/UnionListWriter.java\nindex 9fe41d0d9..8ac23fe46 100644\n--- a/java/vector/src/main/codegen/templates/UnionListWriter.java\n+++ b/java/vector/src/main/codegen/templates/UnionListWriter.java\n@@ -36,11 +36,11 @@\n public class UnionListWriter extends AbstractFieldWriter {\n \n   private ListVector vector;\n-  private UInt4Vector offsets;\n   private PromotableWriter writer;\n   private boolean inMap = false;\n   private String mapName;\n   private int lastIndex = 0;\n+  private static final int OFFSET_WIDTH = 4;\n \n   public UnionListWriter(ListVector vector) {\n     this(vector, NullableMapWriterFactory.getNullableMapWriterFactoryInstance());\n@@ -49,7 +49,6 @@ public UnionListWriter(ListVector vector) {\n   public UnionListWriter(ListVector vector, NullableMapWriterFactory nullableMapWriterFactory) {\n     this.vector = vector;\n     this.writer = new PromotableWriter(vector.getDataVector(), vector, nullableMapWriterFactory);\n-    this.offsets = vector.getOffsetVector();\n   }\n \n   public UnionListWriter(ListVector vector, AbstractFieldWriter parent) {\n@@ -72,7 +71,7 @@ public Field getField() {\n   }\n \n   public void setValueCount(int count) {\n-    vector.getMutator().setValueCount(count);\n+    vector.setValueCount(count);\n   }\n \n   @Override\n@@ -133,13 +132,13 @@ public MapWriter map(String name) {\n \n   @Override\n   public void startList() {\n-    vector.getMutator().startNewValue(idx());\n-    writer.setPosition(offsets.getAccessor().get(idx() + 1));\n+    vector.startNewValue(idx());\n+    writer.setPosition(vector.getOffsetBuffer().getInt((idx() + 1) * OFFSET_WIDTH));\n   }\n \n   @Override\n   public void endList() {\n-    offsets.getMutator().set(idx() + 1, writer.idx());\n+    vector.getOffsetBuffer().setInt((idx() + 1) * OFFSET_WIDTH, writer.idx());\n     setPosition(idx() + 1);\n   }\n \ndiff --git a/java/vector/src/main/codegen/templates/UnionVector.java b/java/vector/src/main/codegen/templates/UnionVector.java\nindex 3c7ed0190..3da383fe6 100644\n--- a/java/vector/src/main/codegen/templates/UnionVector.java\n+++ b/java/vector/src/main/codegen/templates/UnionVector.java\n@@ -25,6 +25,7 @@\n \n <#include \"/@includes/vv_imports.ftl\" />\n import com.google.common.collect.ImmutableList;\n+import io.netty.buffer.ArrowBuf;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Iterator;\n@@ -32,6 +33,9 @@\n import org.apache.arrow.vector.complex.impl.ComplexCopier;\n import org.apache.arrow.vector.util.CallBack;\n import org.apache.arrow.vector.schema.ArrowFieldNode;\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n \n import static org.apache.arrow.vector.types.UnionMode.Sparse;\n \n@@ -56,12 +60,10 @@\n \n   private String name;\n   private BufferAllocator allocator;\n-  private Accessor accessor = new Accessor();\n-  private Mutator mutator = new Mutator();\n   int valueCount;\n \n   MapVector internalMap;\n-  UInt1Vector typeVector;\n+  ArrowBuf typeBuffer;\n \n   private NullableMapVector mapVector;\n   private ListVector listVector;\n@@ -71,16 +73,17 @@\n   private int singleType = 0;\n   private ValueVector singleVector;\n \n+  private static final byte TYPE_WIDTH = 1;\n   private final CallBack callBack;\n-  private final List<BufferBacked> innerVectors;\n+  private int typeBufferAllocationSizeInBytes;\n \n   public UnionVector(String name, BufferAllocator allocator, CallBack callBack) {\n     this.name = name;\n     this.allocator = allocator;\n     this.internalMap = new MapVector(\"internal\", allocator, new FieldType(false, ArrowType.Struct.INSTANCE, null, null), callBack);\n-    this.typeVector = new UInt1Vector(\"types\", allocator);\n+    this.typeBuffer = allocator.getEmpty();\n     this.callBack = callBack;\n-    this.innerVectors = Collections.unmodifiableList(Arrays.<BufferBacked>asList(typeVector));\n+    this.typeBufferAllocationSizeInBytes = BaseValueVector.INITIAL_VALUE_ALLOCATION * TYPE_WIDTH;\n   }\n \n   public BufferAllocator getAllocator() {\n@@ -104,20 +107,33 @@ public void initializeChildrenFromFields(List<Field> children) {\n \n   @Override\n   public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n-    // truncate types vector buffer to size (#0)\n-    org.apache.arrow.vector.BaseDataValueVector.truncateBufferBasedOnSize(ownBuffers, 0, typeVector.getBufferSizeFor(fieldNode.getLength()));\n-    BaseDataValueVector.load(fieldNode, getFieldInnerVectors(), ownBuffers);\n+    if (ownBuffers.size() != 1) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 1 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf buffer = ownBuffers.get(0);\n+    typeBuffer.release();\n+    typeBuffer = buffer.retain(allocator);\n+    typeBufferAllocationSizeInBytes = typeBuffer.capacity();\n     this.valueCount = fieldNode.getLength();\n   }\n \n   @Override\n   public List<ArrowBuf> getFieldBuffers() {\n-    return BaseDataValueVector.unload(getFieldInnerVectors());\n+    List<ArrowBuf> result = new ArrayList<>(1);\n+\n+    typeBuffer.readerIndex(0);\n+    typeBuffer.writerIndex(valueCount * TYPE_WIDTH);\n+\n+    result.add(typeBuffer);\n+\n+    return result;\n   }\n \n   @Override\n+  @Deprecated\n   public List<BufferBacked> getFieldInnerVectors() {\n-     return this.innerVectors;\n+     throw new UnsupportedOperationException(\"There are no inner vectors. Use geFieldBuffers\");\n   }\n \n   private String fieldName(MinorType type) {\n@@ -134,7 +150,7 @@ private FieldType fieldType(MinorType type) {\n \n   @Override\n   public long getValidityBufferAddress() {\n-    return typeVector.getDataBuffer().memoryAddress();\n+    return typeBuffer.memoryAddress();\n   }\n \n   @Override\n@@ -148,7 +164,7 @@ public long getOffsetBufferAddress() {\n   }\n \n   @Override\n-  public ArrowBuf getValidityBuffer() { return typeVector.getDataBuffer(); }\n+  public ArrowBuf getValidityBuffer() { return typeBuffer; }\n \n   @Override\n   public ArrowBuf getDataBuffer() { throw new UnsupportedOperationException(); }\n@@ -211,47 +227,76 @@ public ListVector getList() {\n   }\n \n   public int getTypeValue(int index) {\n-    return typeVector.getAccessor().get(index);\n-  }\n-\n-  public UInt1Vector getTypeVector() {\n-    return typeVector;\n+    return typeBuffer.getByte(index * TYPE_WIDTH);\n   }\n \n   @Override\n   public void allocateNew() throws OutOfMemoryException {\n     internalMap.allocateNew();\n-    typeVector.allocateNew();\n-    if (typeVector != null) {\n-      typeVector.zeroVector();\n+    try {\n+      allocateTypeBuffer();\n+    } catch (Exception e) {\n+      clear();\n+      throw e;\n     }\n   }\n \n   @Override\n   public boolean allocateNewSafe() {\n     boolean safe = internalMap.allocateNewSafe();\n-    safe = safe && typeVector.allocateNewSafe();\n-    if (safe) {\n-      if (typeVector != null) {\n-        typeVector.zeroVector();\n-      }\n+    if (!safe) { return false; }\n+    try {\n+      allocateTypeBuffer();\n+    } catch (Exception e) {\n+      clear();\n+      return  false;\n     }\n-    return safe;\n+\n+    return true;\n+  }\n+\n+  private void allocateTypeBuffer() {\n+    typeBuffer = allocator.buffer(typeBufferAllocationSizeInBytes);\n+    typeBuffer.readerIndex(0);\n+    typeBuffer.setZero(0, typeBuffer.capacity());\n   }\n \n   @Override\n   public void reAlloc() {\n     internalMap.reAlloc();\n-    typeVector.reAlloc();\n+    reallocTypeBuffer();\n   }\n \n-  @Override\n-  public void setInitialCapacity(int numRecords) {\n+  private void reallocTypeBuffer() {\n+    final int currentBufferCapacity = typeBuffer.capacity();\n+    long baseSize  = typeBufferAllocationSizeInBytes;\n+\n+    if (baseSize < (long)currentBufferCapacity) {\n+      baseSize = (long)currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > BaseValueVector.MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int)newAllocationSize);\n+    newBuf.setBytes(0, typeBuffer, 0, currentBufferCapacity);\n+    final int halfNewCapacity = newBuf.capacity() / 2;\n+    newBuf.setZero(halfNewCapacity, halfNewCapacity);\n+    typeBuffer.release(1);\n+    typeBuffer = newBuf;\n+    typeBufferAllocationSizeInBytes = (int)newAllocationSize;\n   }\n \n   @Override\n+  public void setInitialCapacity(int numRecords) { }\n+\n+  @Override\n   public int getValueCapacity() {\n-    return Math.min(typeVector.getValueCapacity(), internalMap.getValueCapacity());\n+    return Math.min(getTypeBufferValueCapacity(), internalMap.getValueCapacity());\n   }\n \n   @Override\n@@ -261,7 +306,9 @@ public void close() {\n \n   @Override\n   public void clear() {\n-    typeVector.clear();\n+    valueCount = 0;\n+    typeBuffer.release();\n+    typeBuffer = allocator.getEmpty();\n     internalMap.clear();\n   }\n \n@@ -300,7 +347,7 @@ public TransferPair makeTransferPair(ValueVector target) {\n   public void copyFrom(int inIndex, int outIndex, UnionVector from) {\n     from.getReader().setPosition(inIndex);\n     getWriter().setPosition(outIndex);\n-    ComplexCopier.copy(from.reader, mutator.writer);\n+    ComplexCopier.copy(from.reader, writer);\n   }\n \n   public void copyFromSafe(int inIndex, int outIndex, UnionVector from) {\n@@ -321,33 +368,34 @@ public FieldVector addVector(FieldVector v) {\n \n   private class TransferImpl implements TransferPair {\n     private final TransferPair internalMapVectorTransferPair;\n-    private final TransferPair typeVectorTransferPair;\n     private final UnionVector to;\n \n     public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n       to = new UnionVector(name, allocator, callBack);\n       internalMapVectorTransferPair = internalMap.makeTransferPair(to.internalMap);\n-      typeVectorTransferPair = typeVector.makeTransferPair(to.typeVector);\n     }\n \n     public TransferImpl(UnionVector to) {\n       this.to = to;\n       internalMapVectorTransferPair = internalMap.makeTransferPair(to.internalMap);\n-      typeVectorTransferPair = typeVector.makeTransferPair(to.typeVector);\n     }\n \n     @Override\n     public void transfer() {\n+      to.clear();\n+      to.typeBuffer = typeBuffer.transferOwnership(to.allocator).buffer;\n       internalMapVectorTransferPair.transfer();\n-      typeVectorTransferPair.transfer();\n       to.valueCount = valueCount;\n     }\n \n     @Override\n     public void splitAndTransfer(int startIndex, int length) {\n+      to.clear();\n       internalMapVectorTransferPair.splitAndTransfer(startIndex, length);\n-      typeVectorTransferPair.splitAndTransfer(startIndex, length);\n-      to.getMutator().setValueCount(length);\n+      final int startPoint = startIndex * TYPE_WIDTH;\n+      final int sliceLength = length * TYPE_WIDTH;\n+      to.typeBuffer = typeBuffer.slice(startPoint, sliceLength).transferOwnership(to.allocator).buffer;\n+      to.setValueCount(length);\n     }\n \n     @Override\n@@ -362,13 +410,15 @@ public void copyValueSafe(int from, int to) {\n   }\n \n   @Override\n+  @Deprecated\n   public Accessor getAccessor() {\n-    return accessor;\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from UNION\");\n   }\n \n   @Override\n+  @Deprecated\n   public Mutator getMutator() {\n-    return mutator;\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing to UNION\");\n   }\n \n   @Override\n@@ -380,15 +430,17 @@ public FieldReader getReader() {\n   }\n \n   public FieldWriter getWriter() {\n-    if (mutator.writer == null) {\n-      mutator.writer = new UnionWriter(this);\n+    if (writer == null) {\n+      writer = new UnionWriter(this);\n     }\n-    return mutator.writer;\n+    return writer;\n   }\n \n   @Override\n   public int getBufferSize() {\n-    return typeVector.getBufferSize() + internalMap.getBufferSize();\n+    if (valueCount == 0) { return 0; }\n+\n+    return (valueCount * TYPE_WIDTH) + internalMap.getBufferSize();\n   }\n \n   @Override\n@@ -402,13 +454,13 @@ public int getBufferSizeFor(final int valueCount) {\n       bufferSize += v.getBufferSizeFor(valueCount);\n     }\n \n-    return (int) bufferSize;\n+    return (int) bufferSize + (valueCount * TYPE_WIDTH);\n   }\n \n   @Override\n   public ArrowBuf[] getBuffers(boolean clear) {\n     ImmutableList.Builder<ArrowBuf> builder = ImmutableList.builder();\n-    builder.add(typeVector.getBuffers(clear));\n+    builder.add(typeBuffer);\n     builder.add(internalMap.getBuffers(clear));\n     List<ArrowBuf> list = builder.build();\n     return list.toArray(new ArrowBuf[list.size()]);\n@@ -417,15 +469,12 @@ public int getBufferSizeFor(final int valueCount) {\n   @Override\n   public Iterator<ValueVector> iterator() {\n     List<ValueVector> vectors = Lists.newArrayList(internalMap.iterator());\n-    vectors.add(typeVector);\n     return vectors.iterator();\n   }\n \n-  public class Accessor extends BaseValueVector.BaseAccessor {\n \n-    @Override\n     public Object getObject(int index) {\n-      int type = typeVector.getAccessor().get(index);\n+      int type = typeBuffer.getByte(index * TYPE_WIDTH);\n       switch (MinorType.values()[type]) {\n       case NULL:\n         return null;\n@@ -436,18 +485,14 @@ public Object getObject(int index) {\n           <#assign uncappedName = name?uncap_first/>\n           <#if !minor.typeParams?? >\n       case ${name?upper_case}:\n-        <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n-          return get${name}Vector().getAccessor().getObject(index);\n-        <#else>\n           return get${name}Vector().getObject(index);\n-        </#if>\n           </#if>\n         </#list>\n       </#list>\n       case MAP:\n-        return getMap().getAccessor().getObject(index);\n+        return getMap().getObject(index);\n       case LIST:\n-        return getList().getAccessor().getObject(index);\n+        return getList().getObject(index);\n       default:\n         throw new UnsupportedOperationException(\"Cannot support type: \" + MinorType.values()[type]);\n       }\n@@ -466,30 +511,37 @@ public void get(int index, UnionHolder holder) {\n       holder.reader = reader;\n     }\n \n-    @Override\n     public int getValueCount() {\n       return valueCount;\n     }\n \n-    @Override\n     public boolean isNull(int index) {\n-      return typeVector.getAccessor().get(index) == 0;\n+      return (typeBuffer.getByte(index * TYPE_WIDTH) == 0);\n+    }\n+\n+    @Override\n+    public int getNullCount() {\n+      int nullCount = 0;\n+      for (int i = 0; i < getValueCount(); i++) {\n+        if (isNull(i)) {\n+          nullCount++;\n+        }\n+      }\n+      return nullCount;\n     }\n \n     public int isSet(int index) {\n       return isNull(index) ? 0 : 1;\n     }\n-  }\n-\n-  public class Mutator extends BaseValueVector.BaseMutator {\n \n     UnionWriter writer;\n \n-    @Override\n     public void setValueCount(int valueCount) {\n-      UnionVector.this.valueCount = valueCount;\n-      typeVector.getMutator().setValueCount(valueCount);\n-      internalMap.getMutator().setValueCount(valueCount);\n+      this.valueCount = valueCount;\n+      while (valueCount > getTypeBufferValueCapacity()) {\n+        reallocTypeBuffer();\n+      }\n+      internalMap.setValueCount(valueCount);\n     }\n \n     public void setSafe(int index, UnionHolder holder) {\n@@ -534,11 +586,7 @@ public void setSafe(int index, UnionHolder holder) {\n         <#if !minor.typeParams?? >\n     public void setSafe(int index, Nullable${name}Holder holder) {\n       setType(index, MinorType.${name?upper_case});\n-      <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n-        get${name}Vector().getMutator().setSafe(index, holder);\n-      <#else>\n-        get${name}Vector().setSafe(index, holder);\n-      </#if>\n+      get${name}Vector().setSafe(index, holder);\n     }\n \n         </#if>\n@@ -546,19 +594,13 @@ public void setSafe(int index, Nullable${name}Holder holder) {\n     </#list>\n \n     public void setType(int index, MinorType type) {\n-      typeVector.getMutator().setSafe(index, (byte) type.ordinal());\n+      while (index >= getTypeBufferValueCapacity()) {\n+        reallocTypeBuffer();\n+      }\n+      typeBuffer.setByte(index * TYPE_WIDTH , (byte) type.ordinal());\n     }\n \n-    @Override\n-    public void reset() { }\n-\n-    @Override\n-    public void generateTestData(int values) { }\n-  }\n-\n-  public int getValueCount() { return 0; }\n-\n-  public void setValueCount(int valueCount) { }\n-\n-  public Object getObject(int index) { return null; }\n+    private int getTypeBufferValueCapacity() {\n+      return (int) ((typeBuffer.capacity() * 1.0) / TYPE_WIDTH);\n+    }\n }\ndiff --git a/java/vector/src/main/codegen/templates/UnionWriter.java b/java/vector/src/main/codegen/templates/UnionWriter.java\nindex f892bac91..526708a4c 100644\n--- a/java/vector/src/main/codegen/templates/UnionWriter.java\n+++ b/java/vector/src/main/codegen/templates/UnionWriter.java\n@@ -62,7 +62,7 @@ public void setPosition(int index) {\n \n   @Override\n   public void start() {\n-    data.getMutator().setType(idx(), MinorType.MAP);\n+    data.setType(idx(), MinorType.MAP);\n     getMapWriter().start();\n   }\n \n@@ -74,7 +74,7 @@ public void end() {\n   @Override\n   public void startList() {\n     getListWriter().startList();\n-    data.getMutator().setType(idx(), MinorType.LIST);\n+    data.setType(idx(), MinorType.LIST);\n   }\n \n   @Override\n@@ -92,7 +92,7 @@ private MapWriter getMapWriter() {\n   }\n \n   public MapWriter asMap() {\n-    data.getMutator().setType(idx(), MinorType.MAP);\n+    data.setType(idx(), MinorType.MAP);\n     return getMapWriter();\n   }\n \n@@ -106,7 +106,7 @@ private ListWriter getListWriter() {\n   }\n \n   public ListWriter asList() {\n-    data.getMutator().setType(idx(), MinorType.LIST);\n+    data.setType(idx(), MinorType.LIST);\n     return getListWriter();\n   }\n \n@@ -150,19 +150,19 @@ BaseWriter getWriter(MinorType minorType) {\n   }\n \n   public ${name}Writer as${name}() {\n-    data.getMutator().setType(idx(), MinorType.${name?upper_case});\n+    data.setType(idx(), MinorType.${name?upper_case});\n     return get${name}Writer();\n   }\n \n   @Override\n   public void write(${name}Holder holder) {\n-    data.getMutator().setType(idx(), MinorType.${name?upper_case});\n+    data.setType(idx(), MinorType.${name?upper_case});\n     get${name}Writer().setPosition(idx());\n     get${name}Writer().write${name}(<#list fields as field>holder.${field.name}<#if field_has_next>, </#if></#list>);\n   }\n \n   public void write${minor.class}(<#list fields as field>${field.type} ${field.name}<#if field_has_next>, </#if></#list>) {\n-    data.getMutator().setType(idx(), MinorType.${name?upper_case});\n+    data.setType(idx(), MinorType.${name?upper_case});\n     get${name}Writer().setPosition(idx());\n     get${name}Writer().write${name}(<#list fields as field>${field.name}<#if field_has_next>, </#if></#list>);\n   }\n@@ -175,28 +175,28 @@ public void writeNull() {\n \n   @Override\n   public MapWriter map() {\n-    data.getMutator().setType(idx(), MinorType.LIST);\n+    data.setType(idx(), MinorType.LIST);\n     getListWriter().setPosition(idx());\n     return getListWriter().map();\n   }\n \n   @Override\n   public ListWriter list() {\n-    data.getMutator().setType(idx(), MinorType.LIST);\n+    data.setType(idx(), MinorType.LIST);\n     getListWriter().setPosition(idx());\n     return getListWriter().list();\n   }\n \n   @Override\n   public ListWriter list(String name) {\n-    data.getMutator().setType(idx(), MinorType.MAP);\n+    data.setType(idx(), MinorType.MAP);\n     getMapWriter().setPosition(idx());\n     return getMapWriter().list(name);\n   }\n \n   @Override\n   public MapWriter map(String name) {\n-    data.getMutator().setType(idx(), MinorType.MAP);\n+    data.setType(idx(), MinorType.MAP);\n     getMapWriter().setPosition(idx());\n     return getMapWriter().map(name);\n   }\n@@ -209,14 +209,14 @@ public MapWriter map(String name) {\n   <#if !minor.typeParams?? >\n   @Override\n   public ${capName}Writer ${lowerName}(String name) {\n-    data.getMutator().setType(idx(), MinorType.MAP);\n+    data.setType(idx(), MinorType.MAP);\n     getMapWriter().setPosition(idx());\n     return getMapWriter().${lowerName}(name);\n   }\n \n   @Override\n   public ${capName}Writer ${lowerName}() {\n-    data.getMutator().setType(idx(), MinorType.LIST);\n+    data.setType(idx(), MinorType.LIST);\n     getListWriter().setPosition(idx());\n     return getListWriter().${lowerName}();\n   }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java b/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java\nindex c5f781000..83dc409a7 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java\n@@ -35,12 +35,17 @@\n import org.apache.arrow.vector.util.OversizedAllocationException;\n import org.apache.arrow.vector.util.TransferPair;\n \n+/**\n+ * BaseNullableFixedWidthVector provides an abstract interface for\n+ * implementing vectors of fixed width values. The vectors are nullable\n+ * implying that zero or more elements in the vector could be NULL.\n+ */\n public abstract class BaseNullableFixedWidthVector extends BaseValueVector\n         implements FixedWidthVector, FieldVector {\n    private final byte typeWidth;\n \n-   private int valueAllocationSizeInBytes;\n-   private int validityAllocationSizeInBytes;\n+   protected int valueAllocationSizeInBytes;\n+   protected int validityAllocationSizeInBytes;\n \n    protected final Field field;\n    private int allocationMonitor;\n@@ -52,23 +57,21 @@ public BaseNullableFixedWidthVector(final String name, final BufferAllocator all\n                                        FieldType fieldType, final byte typeWidth) {\n       super(name, allocator);\n       this.typeWidth = typeWidth;\n-      valueAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * typeWidth;\n-      validityAllocationSizeInBytes = getSizeFromCount(INITIAL_VALUE_ALLOCATION);\n       field = new Field(name, fieldType, null);\n       valueCount = 0;\n       allocationMonitor = 0;\n       validityBuffer = allocator.getEmpty();\n       valueBuffer = allocator.getEmpty();\n+      if (typeWidth > 0) {\n+         valueAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * typeWidth;\n+         validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+      } else {\n+         /* specialized handling for NullableBitVector */\n+         valueAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+         validityAllocationSizeInBytes = valueAllocationSizeInBytes;\n+      }\n    }\n \n-   /* TODO:\n-    * Determine how writerIndex and readerIndex need to be used. Right now we\n-    * are setting the writerIndex and readerIndex in the call to getFieldBuffers\n-    * using the valueCount -- this assumes that the caller of getFieldBuffers\n-    * on the vector has already invoked setValueCount.\n-    *\n-    * Do we need to set them during vector transfer and splitAndTransfer?\n-    */\n \n    /* TODO:\n     *\n@@ -84,57 +87,91 @@ public BaseNullableFixedWidthVector(final String name, final BufferAllocator all\n     * abstracted out to top level base class.\n     *\n     * Right now BaseValueVector is the top level base class for other\n-    * vector types in ValueVector hierarchy and those vectors have not\n-    * yet been refactored so moving things to the top class as of now\n-    * is not a good idea.\n+    * vector types in ValueVector hierarchy (non-nullable) and those\n+    * vectors have not yet been refactored/removed so moving things to\n+    * the top class as of now is not a good idea.\n     */\n \n-   /* TODO:\n-    * See if we need logger -- unnecessary object probably\n-    */\n-\n-   protected abstract org.slf4j.Logger getLogger();\n \n    @Override\n+   @Deprecated\n    public Mutator getMutator() {\n-      throw new  UnsupportedOperationException(\"Mutator is not needed to write into vector\");\n+      throw new UnsupportedOperationException(\"Mutator is not supported for writing to vector\");\n    }\n \n    @Override\n+   @Deprecated\n    public Accessor getAccessor() {\n-      throw new UnsupportedOperationException(\"Accessor is not needed to read from vector\");\n+      throw new UnsupportedOperationException(\"Accessor is not supported for reading from vector\");\n    }\n \n+   /**\n+    * Get the memory address of buffer that manages the validity\n+    * (NULL or NON-NULL nature) of elements in the vector.\n+    * @return starting address of the buffer\n+    */\n    @Override\n    public long getValidityBufferAddress() {\n       return (validityBuffer.memoryAddress());\n    }\n \n+   /**\n+    * Get the memory address of buffer that stores the data for elements\n+    * in the vector.\n+    * @return starting address of the buffer\n+    */\n    @Override\n    public long getDataBufferAddress() {\n       return (valueBuffer.memoryAddress());\n    }\n \n+   /**\n+    * Get the memory address of buffer that stores the offsets for elements\n+    * in the vector. This operation is not supported for fixed-width vectors.\n+    * @return starting address of the buffer\n+    * @throws UnsupportedOperationException for fixed width vectors\n+    */\n    @Override\n    public long getOffsetBufferAddress() {\n       throw new UnsupportedOperationException(\"not supported for fixed-width vectors\");\n    }\n \n+   /**\n+    * Get buffer that manages the validity (NULL or NON-NULL nature) of\n+    * elements in the vector. Consider it as a buffer for internal bit vector\n+    * data structure.\n+    * @return buffer\n+    */\n    @Override\n    public ArrowBuf getValidityBuffer() {\n       return validityBuffer;\n    }\n \n+   /**\n+    * Get the buffer that stores the data for elements in the vector.\n+    * @return buffer\n+    */\n    @Override\n    public ArrowBuf getDataBuffer() {\n       return valueBuffer;\n    }\n \n+   /**\n+    * buffer that stores the offsets for elements\n+    * in the vector. This operation is not supported for fixed-width vectors.\n+    * @return buffer\n+    * @throws UnsupportedOperationException for fixed width vectors\n+    */\n    @Override\n    public ArrowBuf getOffsetBuffer() {\n       throw new UnsupportedOperationException(\"not supported for fixed-width vectors\");\n    }\n \n+   /**\n+    * Sets the desired value capacity for the vector. This function doesn't\n+    * allocate any memory for the vector.\n+    * @param valueCount desired number of elements in the vector\n+    */\n    @Override\n    public void setInitialCapacity(int valueCount) {\n       final long size = (long)valueCount * typeWidth;\n@@ -142,52 +179,65 @@ public void setInitialCapacity(int valueCount) {\n          throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n       }\n       valueAllocationSizeInBytes = (int)size;\n-      validityAllocationSizeInBytes = getSizeFromCount(valueCount);\n+      validityAllocationSizeInBytes = getValidityBufferSizeFromCount(valueCount);\n    }\n \n+   /**\n+    * Get the current value capacity for the vector\n+    * @return number of elements that vector can hold.\n+    */\n    @Override\n    public int getValueCapacity(){\n       return Math.min(getValueBufferValueCapacity(), getValidityBufferValueCapacity());\n    }\n \n-   /* for test purposes */\n    private int getValueBufferValueCapacity() {\n       return (int)((valueBuffer.capacity() * 1.0)/typeWidth);\n    }\n \n-   /* for test purposes */\n    private int getValidityBufferValueCapacity() {\n       return (int)(validityBuffer.capacity() * 8L);\n    }\n \n-   /* number of bytes for the validity buffer for the given valueCount */\n-   protected int getSizeFromCount(int valueCount) {\n-      return (int) Math.ceil(valueCount / 8.0);\n-   }\n-\n+   /**\n+    * zero out the vector and the data in associated buffers.\n+    */\n    @Override\n    public void zeroVector() {\n       initValidityBuffer();\n       initValueBuffer();\n    }\n \n+   /* zero out the validity buffer */\n    private void initValidityBuffer() {\n       validityBuffer.setZero(0, validityBuffer.capacity());\n    }\n \n+   /* zero out the data buffer */\n    private void initValueBuffer() {\n       valueBuffer.setZero(0, valueBuffer.capacity());\n    }\n \n+   /**\n+    * Reset the vector to initial state. Same as {@link #zeroVector()}.\n+    * Note that this method doesn't release any memory.\n+    */\n    public void reset() {\n       zeroVector();\n    }\n \n+   /**\n+    * Close the vector and release the associated buffers.\n+    */\n    @Override\n    public void close() { clear(); }\n \n+   /**\n+    * Same as {@link #close()}\n+    */\n    @Override\n    public void clear() {\n+      valueCount = 0;\n       validityBuffer = releaseBuffer(validityBuffer);\n       valueBuffer = releaseBuffer(valueBuffer);\n    }\n@@ -208,6 +258,9 @@ protected void decrementAllocationMonitor() {\n       allocationMonitor--;\n    }\n \n+   /**\n+    * Same as {@link #allocateNewSafe()}.\n+    */\n    @Override\n    public void allocateNew() {\n       if(!allocateNewSafe()){\n@@ -215,6 +268,15 @@ public void allocateNew() {\n       }\n    }\n \n+   /**\n+    * Allocate memory for the vector. We internally use a default value count\n+    * of 4096 to allocate memory for at least these many elements in the\n+    * vector. See {@link #allocateNew(int)} for allocating memory for specific\n+    * number of elements in the vector.\n+    *\n+    * @return false if memory allocation fails, true otherwise.\n+    */\n+   @Override\n    public boolean allocateNewSafe() {\n       long curAllocationSizeValue = valueAllocationSizeInBytes;\n       long curAllocationSizeValidity = validityAllocationSizeInBytes;\n@@ -229,8 +291,7 @@ public boolean allocateNewSafe() {\n       try{\n          allocateBytes(curAllocationSizeValue, curAllocationSizeValidity);\n       } catch (Exception e) {\n-         getLogger().error(\"ERROR: Failure in allocateNewSafe\");\n-         getLogger().error(e.getMessage());\n+         e.printStackTrace();\n          clear();\n          return false;\n       }\n@@ -238,9 +299,20 @@ public boolean allocateNewSafe() {\n       return true;\n    }\n \n+   /**\n+    * Allocate memory for the vector to support storing at least the provided number of\n+    * elements in the vector. This method must be called prior to using the ValueVector.\n+    *\n+    * @param valueCount the desired number of elements in the vector\n+    * @throws org.apache.arrow.memory.OutOfMemoryException\n+    */\n    public void allocateNew(int valueCount) {\n       long valueBufferSize = valueCount * typeWidth;\n-      long validityBufferSize = getSizeFromCount(valueCount);\n+      long validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+      if (typeWidth == 0) {\n+         /* specialized handling for NullableBitVector */\n+         valueBufferSize = validityBufferSize;\n+      }\n \n       if (allocationMonitor > 10) {\n          /* step down the default memory allocation since we have observed\n@@ -266,8 +338,7 @@ public void allocateNew(int valueCount) {\n       try {\n          allocateBytes(valueBufferSize, validityBufferSize);\n       } catch(Exception e) {\n-         getLogger().error(\"ERROR: Failure in allocateNew\");\n-         getLogger().error(e.getMessage());\n+         e.printStackTrace();\n          clear();\n          throw e;\n       }\n@@ -294,8 +365,8 @@ private void allocateBytes(final long valueBufferSize, final long validityBuffer\n       initValidityBuffer();\n    }\n \n-   /*\n-    * during splitAndTransfer, if we splitting from a random position within a byte,\n+   /**\n+    * During splitAndTransfer, if we splitting from a random position within a byte,\n     * we can't just slice the source buffer so we have to explicitly allocate the\n     * validityBuffer of the target vector. This is unlike the databuffer which we can\n     * always slice for the target vector.\n@@ -307,23 +378,49 @@ private void allocateValidityBuffer(final int validityBufferSize) {\n       initValidityBuffer();\n    }\n \n+   /**\n+    * Get the potential buffer size for a particular number of records.\n+    * @param count desired number of elements in the vector\n+    * @return estimated size of underlying buffers if the vector holds\n+    *         a given number of elements\n+    */\n    @Override\n    public int getBufferSizeFor(final int count) {\n       if (count == 0) { return 0; }\n-      return (count * typeWidth) + getSizeFromCount(count);\n+      return (count * typeWidth) + getValidityBufferSizeFromCount(count);\n    }\n \n+   /**\n+    * Get the size (number of bytes) of underlying buffers used by this\n+    * vector\n+    * @return size of underlying buffers.\n+    */\n    @Override\n    public int getBufferSize() {\n       if (valueCount == 0) { return 0; }\n-      return (valueCount * typeWidth) + getSizeFromCount(valueCount);\n+      return (valueCount * typeWidth) + getValidityBufferSizeFromCount(valueCount);\n    }\n \n+   /**\n+    * Get information about how this field is materialized.\n+    * @return the field corresponding to this vector\n+    */\n    @Override\n    public Field getField() {\n       return field;\n    }\n \n+   /**\n+    * Return the underlying buffers associated with this vector. Note that this doesn't\n+    * impact the reference counts for this buffer so it only should be used for in-context\n+    * access. Also note that this buffer changes regularly thus\n+    * external classes shouldn't hold a reference to it (unless they change it).\n+    *\n+    * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+    *              but the returned array will be the only reference to them\n+    * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+    *         vector instance.\n+    */\n    @Override\n    public ArrowBuf[] getBuffers(boolean clear) {\n       final ArrowBuf[] buffers = new ArrowBuf[2];\n@@ -338,12 +435,20 @@ public Field getField() {\n       return buffers;\n    }\n \n+   /**\n+    * Resize the vector to increase the capacity. The internal behavior is to\n+    * double the current value capacity.\n+    */\n    @Override\n    public void reAlloc() {\n       valueBuffer = reallocBufferHelper(valueBuffer, true);\n       validityBuffer = reallocBufferHelper(validityBuffer, false);\n    }\n \n+   /**\n+    * Helper method for reallocating a particular internal buffer\n+    * Returns the new buffer.\n+    */\n    private ArrowBuf reallocBufferHelper(ArrowBuf buffer, final boolean dataBuffer) {\n       final int currentBufferCapacity = buffer.capacity();\n       long baseSize  = (dataBuffer ? valueAllocationSizeInBytes\n@@ -360,10 +465,6 @@ private ArrowBuf reallocBufferHelper(ArrowBuf buffer, final boolean dataBuffer)\n          throw new OversizedAllocationException(\"Unable to expand the buffer\");\n       }\n \n-      getLogger().debug(\"Reallocating vector [{}]. # of bytes: [{}] -> [{}]\",\n-              name, (dataBuffer ? valueAllocationSizeInBytes : validityAllocationSizeInBytes),\n-              newAllocationSize);\n-\n       final ArrowBuf newBuf = allocator.buffer((int)newAllocationSize);\n       newBuf.setBytes(0, buffer, 0, currentBufferCapacity);\n       final int halfNewCapacity = newBuf.capacity() / 2;\n@@ -381,8 +482,17 @@ private ArrowBuf reallocBufferHelper(ArrowBuf buffer, final boolean dataBuffer)\n    }\n \n    @Override\n-   public List<BufferBacked> getFieldInnerVectors() { throw new UnsupportedOperationException(); }\n+   @Deprecated\n+   public List<BufferBacked> getFieldInnerVectors() {\n+      throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+   }\n \n+   /**\n+    * Initialize the children in schema for this Field. This operation is a\n+    * NO-OP for scalar types since they don't have any children.\n+    * @param children the schema\n+    * @throws IllegalArgumentException if children is a non-empty list for scalar types.\n+    */\n    @Override\n    public void initializeChildrenFromFields(List<Field> children) {\n       if (!children.isEmpty()) {\n@@ -390,11 +500,23 @@ public void initializeChildrenFromFields(List<Field> children) {\n       }\n    }\n \n+   /**\n+    * Get the inner child vectors.\n+    * @return list of child vectors for complex types, empty list for scalar vector\n+    * types\n+    */\n    @Override\n    public List<FieldVector> getChildrenFromFields() {\n       return Collections.emptyList();\n    }\n \n+   /**\n+    * Load the buffers of this vector with provided source buffers.\n+    * The caller manages the source buffers and populates them before invoking\n+    * this method.\n+    * @param fieldNode  the fieldNode indicating the value count\n+    * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+    */\n    @Override\n    public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n       if (ownBuffers.size() != 2) {\n@@ -415,13 +537,22 @@ public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers\n       validityAllocationSizeInBytes = validityBuffer.capacity();\n    }\n \n+   /**\n+    * Get the buffers belonging to this vector\n+    * @return the inner buffers.\n+    */\n    public List<ArrowBuf> getFieldBuffers() {\n       List<ArrowBuf> result = new ArrayList<>(2);\n \n       validityBuffer.readerIndex(0);\n-      validityBuffer.writerIndex(getSizeFromCount(valueCount));\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n       valueBuffer.readerIndex(0);\n-      valueBuffer.writerIndex(valueCount * typeWidth);\n+      if (typeWidth == 0) {\n+         /* specialized handling for NullableBitVector */\n+         valueBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      } else {\n+         valueBuffer.writerIndex(valueCount * typeWidth);\n+      }\n \n       result.add(validityBuffer);\n       result.add(valueBuffer);\n@@ -429,18 +560,42 @@ public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers\n       return result;\n    }\n \n+   /**\n+    * Construct a transfer pair of this vector and another vector of same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @param callBack\n+    * @return TransferPair\n+    */\n    @Override\n    public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n       return getTransferPair(ref, allocator);\n    }\n \n+   /**\n+    * Construct a transfer pair of this vector and another vector of same type.\n+    * @param allocator allocator for the target vector\n+    * @return TransferPair\n+    */\n    @Override\n    public TransferPair getTransferPair(BufferAllocator allocator){\n       return getTransferPair(name, allocator);\n    }\n \n+   /**\n+    * Construct a transfer pair of this vector and another vector of same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return TransferPair\n+    */\n    public abstract TransferPair getTransferPair(String ref, BufferAllocator allocator);\n \n+   /**\n+    * Transfer this vector'data to another vector. The memory associated\n+    * with this vector is transferred to the allocator of target vector\n+    * for accounting and management purposes.\n+    * @param target destination vector for transfer\n+    */\n    public void transferTo(BaseNullableFixedWidthVector target){\n       compareTypes(target, \"transferTo\");\n       target.clear();\n@@ -450,6 +605,13 @@ public void transferTo(BaseNullableFixedWidthVector target){\n       clear();\n    }\n \n+   /**\n+    * Slice this vector at desired index and length and transfer the\n+    * corresponding data to the target vector.\n+    * @param startIndex start position of the split in source vector.\n+    * @param length length of the split.\n+    * @param target destination vector\n+    */\n    public void splitAndTransferTo(int startIndex, int length,\n                                   BaseNullableFixedWidthVector target) {\n       compareTypes(target, \"splitAndTransferTo\");\n@@ -459,6 +621,9 @@ public void splitAndTransferTo(int startIndex, int length,\n       target.setValueCount(length);\n    }\n \n+   /**\n+    * Data buffer can always be split and transferred using slicing.\n+    */\n    private void splitAndTransferValueBuffer(int startIndex, int length,\n                                             BaseNullableFixedWidthVector target) {\n       final int startPoint = startIndex * typeWidth;\n@@ -466,17 +631,21 @@ private void splitAndTransferValueBuffer(int startIndex, int length,\n       target.valueBuffer = valueBuffer.slice(startPoint, sliceLength).transferOwnership(target.allocator).buffer;\n    }\n \n+   /**\n+    * Validity buffer has multiple cases of split and transfer depending on\n+    * the starting position of the source index.\n+    */\n    private void splitAndTransferValidityBuffer(int startIndex, int length,\n                                                BaseNullableFixedWidthVector target) {\n       assert startIndex + length <= valueCount;\n       int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n       int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n-      int byteSizeTarget = getSizeFromCount(length);\n+      int byteSizeTarget = getValidityBufferSizeFromCount(length);\n       int offset = startIndex % 8;\n \n       if (length > 0) {\n          if (offset == 0) {\n-            // slice\n+            /* slice */\n             if (target.validityBuffer != null) {\n                target.validityBuffer.release();\n             }\n@@ -493,8 +662,10 @@ private void splitAndTransferValidityBuffer(int startIndex, int length,\n             target.allocateValidityBuffer(byteSizeTarget);\n \n             for (int i = 0; i < byteSizeTarget - 1; i++) {\n-               byte b1 = getBitsFromCurrentByte(this.validityBuffer, firstByteSource + i, offset);\n-               byte b2 = getBitsFromNextByte(this.validityBuffer, firstByteSource + i + 1, offset);\n+               byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n+                       firstByteSource + i, offset);\n+               byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer,\n+                       firstByteSource + i + 1, offset);\n \n                target.validityBuffer.setByte(i, (b1 + b2));\n             }\n@@ -509,15 +680,15 @@ private void splitAndTransferValidityBuffer(int startIndex, int length,\n              * by shifting data from the current byte.\n              */\n             if((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n-               byte b1 = getBitsFromCurrentByte(this.validityBuffer,\n+               byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n                        firstByteSource + byteSizeTarget - 1, offset);\n-               byte b2 = getBitsFromNextByte(this.validityBuffer,\n+               byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer,\n                        firstByteSource + byteSizeTarget, offset);\n \n                target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n             }\n             else {\n-               byte b1 = getBitsFromCurrentByte(this.validityBuffer,\n+               byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n                        firstByteSource + byteSizeTarget - 1, offset);\n                target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n             }\n@@ -525,14 +696,6 @@ private void splitAndTransferValidityBuffer(int startIndex, int length,\n       }\n    }\n \n-   private static byte getBitsFromCurrentByte(ArrowBuf data, int index, int offset) {\n-      return (byte)((data.getByte(index) & 0xFF) >>> offset);\n-   }\n-\n-   private static byte getBitsFromNextByte(ArrowBuf data, int index, int offset) {\n-      return (byte)((data.getByte(index) << (8 - offset)));\n-   }\n-\n \n    /******************************************************************\n     *                                                                *\n@@ -547,27 +710,9 @@ private static byte getBitsFromNextByte(ArrowBuf data, int index, int offset) {\n     * @return the number of null elements.\n     */\n    public int getNullCount() {\n-      int count = 0;\n-      final int sizeInBytes = getSizeFromCount(valueCount);\n-\n-      for (int i = 0; i < sizeInBytes; ++i) {\n-         final byte byteValue = validityBuffer.getByte(i);\n-         /* Java uses two's complement binary representation, hence 11111111_b which is -1\n-          * when converted to Int will have 32bits set to 1. Masking the MSB and then\n-          * adding it back solves the issue.\n-          */\n-         count += Integer.bitCount(byteValue & 0x7F) - (byteValue >> 7);\n-      }\n-      int nullCount = (sizeInBytes * 8) - count;\n-      /* if the valueCount is not a multiple of 8,\n-       * the bits on the right were counted as null bits.\n-       */\n-      int remainder = valueCount % 8;\n-      nullCount -= remainder == 0 ? 0 : 8 - remainder;\n-      return nullCount;\n+      return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n    }\n \n-\n    /**\n     * Get the value count of vector. This will always be zero unless\n     * {@link #setValueCount(int)} has been called prior to calling this.\n@@ -578,7 +723,6 @@ public int getValueCount(){\n       return valueCount;\n    }\n \n-\n    /**\n     * Set value count for the vector.\n     *\n@@ -625,7 +769,6 @@ public void setValueCount(int valueCount) {\n       }\n    }\n \n-\n    /**\n     * Check if the given index is within the current value capacity\n     * of the vector\n@@ -637,7 +780,6 @@ public boolean isSafe(int index) {\n       return index < getValueCapacity();\n    }\n \n-\n    /**\n     * Check if element at given index is null.\n     *\n@@ -648,7 +790,6 @@ public boolean isNull(int index) {\n       return (isSet(index) == 0);\n    }\n \n-\n    /**\n     * Same as {@link #isNull(int)}.\n     *\n@@ -662,6 +803,11 @@ public int isSet(int index) {\n       return Long.bitCount(b & (1L << bitIndex));\n    }\n \n+   /**\n+    * Mark the particular position in the vector as non-null.\n+    *\n+    * @param index position of the element.\n+    */\n    public void setIndexDefined(int index) {\n       handleSafe(index);\n       BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n@@ -691,7 +837,6 @@ public void setSafe(int index, ByteBuffer value, int start, int length) {\n     ******************************************************************/\n \n \n-\n    protected void handleSafe(int index) {\n       while (index >= getValueCapacity()) {\n          decrementAllocationMonitor();\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java b/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\nindex a79709da4..6587cde63 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n@@ -45,7 +45,7 @@\n    private int offsetAllocationSizeInBytes;\n \n    /* protected members */\n-   protected static final int OFFSET_WIDTH = 4; /* 4 byte unsigned int to track offsets */\n+   public static final int OFFSET_WIDTH = 4; /* 4 byte unsigned int to track offsets */\n    protected static final byte[] emptyByteArray = new byte[]{};\n    protected ArrowBuf validityBuffer;\n    protected ArrowBuf valueBuffer;\n@@ -59,7 +59,7 @@ public BaseNullableVariableWidthVector(final String name, final BufferAllocator\n                                           FieldType fieldType) {\n       super(name, allocator);\n       valueAllocationSizeInBytes = INITIAL_BYTE_COUNT;\n-      validityAllocationSizeInBytes = getSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+      validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n       offsetAllocationSizeInBytes = (INITIAL_VALUE_ALLOCATION) * OFFSET_WIDTH;\n       field = new Field(name, fieldType, null);\n       valueCount = 0;\n@@ -70,21 +70,12 @@ public BaseNullableVariableWidthVector(final String name, final BufferAllocator\n       cleared = false;\n    }\n \n-  /* TODO:\n-    * Determine how writerIndex and readerIndex need to be used. Right now we\n-    * are setting the writerIndex and readerIndex in the call to getFieldBuffers\n-    * using the valueCount -- this assumes that the caller of getFieldBuffers\n-    * on the vector has already invoked setValueCount.\n-    *\n-    * Do we need to set them during vector transfer and splitAndTransfer?\n-    */\n-\n    /* TODO:\n     *\n     * see if getNullCount() can be made faster -- O(1)\n     */\n \n-   /* TODO:\n+  /* TODO:\n     * Once the entire hierarchy has been refactored, move common functions\n     * like getNullCount(), splitAndTransferValidityBuffer to top level\n     * base class BaseValueVector.\n@@ -93,59 +84,89 @@ public BaseNullableVariableWidthVector(final String name, final BufferAllocator\n     * abstracted out to top level base class.\n     *\n     * Right now BaseValueVector is the top level base class for other\n-    * vector types in ValueVector hierarchy and those vectors have not\n-    * yet been refactored so moving things to the top class as of now\n-    * is not a good idea.\n-    */\n-\n-   /* TODO:\n-    * See if we need logger -- unnecessary object probably\n+    * vector types in ValueVector hierarchy (non-nullable) and those\n+    * vectors have not yet been refactored/removed so moving things to\n+    * the top class as of now is not a good idea.\n     */\n \n-   /* TODO:\n-    * Implement getBufferSize(), getCurrentSizeInBytes().\n-    */\n-\n-   protected abstract org.slf4j.Logger getLogger();\n \n+   @Override\n+   @Deprecated\n    public VariableWidthMutator getMutator() {\n-      throw new  UnsupportedOperationException(\"Mutator is not needed to write into vector\");\n+      throw new  UnsupportedOperationException(\"Mutator is not supported for writing into vector\");\n    }\n \n+   @Override\n+   @Deprecated\n    public VariableWidthAccessor getAccessor() {\n-      throw new UnsupportedOperationException(\"Accessor is not needed to read from vector\");\n+      throw new UnsupportedOperationException(\"Accessor is not supported for reading from vector\");\n    }\n \n+   /**\n+    * Get buffer that manages the validity (NULL or NON-NULL nature) of\n+    * elements in the vector. Consider it as a buffer for internal bit vector\n+    * data structure.\n+    * @return buffer\n+    */\n    @Override\n    public ArrowBuf getValidityBuffer() {\n       return validityBuffer;\n    }\n \n+   /**\n+    * Get the buffer that stores the data for elements in the vector.\n+    * @return buffer\n+    */\n    @Override\n    public ArrowBuf getDataBuffer() {\n       return valueBuffer;\n    }\n \n+   /**\n+    * buffer that stores the offsets for elements\n+    * in the vector. This operation is not supported for fixed-width vectors.\n+    * @return buffer\n+    */\n    @Override\n    public ArrowBuf getOffsetBuffer() {\n       return offsetBuffer;\n    }\n \n+   /**\n+    * Get the memory address of buffer that stores the offsets for elements\n+    * in the vector.\n+    * @return starting address of the buffer\n+    */\n    @Override\n    public long getOffsetBufferAddress() {\n       return offsetBuffer.memoryAddress();\n    }\n \n+   /**\n+    * Get the memory address of buffer that manages the validity\n+    * (NULL or NON-NULL nature) of elements in the vector.\n+    * @return starting address of the buffer\n+    */\n    @Override\n    public long getValidityBufferAddress() {\n       return validityBuffer.memoryAddress();\n    }\n \n+   /**\n+    * Get the memory address of buffer that stores the data for elements\n+    * in the vector.\n+    * @return starting address of the buffer\n+    */\n    @Override\n    public long getDataBufferAddress() {\n       return valueBuffer.memoryAddress();\n    }\n \n+   /**\n+    * Sets the desired value capacity for the vector. This function doesn't\n+    * allocate any memory for the vector.\n+    * @param valueCount desired number of elements in the vector\n+    */\n    @Override\n    public void setInitialCapacity(int valueCount) {\n       final long size = (long)valueCount * DEFAULT_RECORD_BYTE_COUNT;\n@@ -153,57 +174,69 @@ public void setInitialCapacity(int valueCount) {\n          throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n       }\n       valueAllocationSizeInBytes = (int)size;\n-      validityAllocationSizeInBytes = getSizeFromCount(valueCount);\n+      validityAllocationSizeInBytes = getValidityBufferSizeFromCount(valueCount);\n       /* to track the end offset of last data element in vector, we need\n        * an additional slot in offset buffer.\n        */\n       offsetAllocationSizeInBytes = (valueCount + 1) * OFFSET_WIDTH;\n    }\n \n+   /**\n+    * Get the current value capacity for the vector\n+    * @return number of elements that vector can hold.\n+    */\n    @Override\n    public int getValueCapacity(){\n       final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n       return Math.min(offsetValueCapacity, getValidityBufferValueCapacity());\n    }\n \n-   /* for test purposes */\n    private int getValidityBufferValueCapacity() {\n       return (int)(validityBuffer.capacity() * 8L);\n    }\n \n-   /* for test purposes */\n    private int getOffsetBufferValueCapacity() {\n       return (int)((offsetBuffer.capacity() * 1.0)/OFFSET_WIDTH);\n    }\n \n-   /* number of bytes for the validity buffer for a given valueCount */\n-   protected int getSizeFromCount(int valueCount) {\n-      return (int) Math.ceil(valueCount / 8.0);\n-   }\n-\n+   /**\n+    * zero out the vector and the data in associated buffers.\n+    */\n    public void zeroVector() {\n       initValidityBuffer();\n       initOffsetBuffer();\n    }\n \n+   /* zero out the validity buffer */\n    private void initValidityBuffer() {\n       validityBuffer.setZero(0, validityBuffer.capacity());\n    }\n \n+   /* zero out the offset buffer */\n    private void initOffsetBuffer() {\n       offsetBuffer.setZero(0, offsetBuffer.capacity());\n    }\n \n+   /**\n+    * Reset the vector to initial state. Same as {@link #zeroVector()}.\n+    * Note that this method doesn't release any memory.\n+    */\n    public void reset() {\n       zeroVector();\n       lastSet = -1;\n    }\n \n+   /**\n+    * Close the vector and release the associated buffers.\n+    */\n    @Override\n    public void close() {\n       clear();\n    }\n \n+   /**\n+    * Same as {@link #close()}\n+    */\n    @Override\n    public void clear() {\n       validityBuffer = releaseBuffer(validityBuffer);\n@@ -215,8 +248,17 @@ public void clear() {\n    }\n \n    @Override\n-   public List<BufferBacked> getFieldInnerVectors() { throw new UnsupportedOperationException(); }\n+   @Deprecated\n+   public List<BufferBacked> getFieldInnerVectors() {\n+      throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+   }\n \n+   /**\n+    * Initialize the children in schema for this Field. This operation is a\n+    * NO-OP for scalar types since they don't have any children.\n+    * @param children the schema\n+    * @throws IllegalArgumentException if children is a non-empty list for scalar types.\n+    */\n    @Override\n    public void initializeChildrenFromFields(List<Field> children) {\n       if (!children.isEmpty()) {\n@@ -224,11 +266,24 @@ public void initializeChildrenFromFields(List<Field> children) {\n       }\n    }\n \n+   /**\n+    * Get the inner child vectors.\n+    * @return list of child vectors for complex types, empty list for scalar vector\n+    * types\n+    */\n    @Override\n    public List<FieldVector> getChildrenFromFields() {\n       return Collections.emptyList();\n    }\n \n+\n+   /**\n+    * Load the buffers of this vector with provided source buffers.\n+    * The caller manages the source buffers and populates them before invoking\n+    * this method.\n+    * @param fieldNode  the fieldNode indicating the value count\n+    * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+    */\n    @Override\n    public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n       ArrowBuf bitBuffer = ownBuffers.get(0);\n@@ -246,11 +301,15 @@ public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers\n       valueCount = fieldNode.getLength();\n    }\n \n+   /**\n+    * Get the buffers belonging to this vector\n+    * @return the inner buffers.\n+    */\n    public List<ArrowBuf> getFieldBuffers() {\n       List<ArrowBuf> result = new ArrayList<>(3);\n       final int lastDataOffset = getstartOffset(valueCount);\n       validityBuffer.readerIndex(0);\n-      validityBuffer.writerIndex(getSizeFromCount(valueCount));\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n       offsetBuffer.readerIndex(0);\n       offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n       valueBuffer.readerIndex(0);\n@@ -263,6 +322,9 @@ public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers\n       return result;\n    }\n \n+   /**\n+    * Same as {@link #allocateNewSafe()}.\n+    */\n    @Override\n    public void allocateNew() {\n       if(!allocateNewSafe()){\n@@ -270,6 +332,14 @@ public void allocateNew() {\n       }\n    }\n \n+   /**\n+    * Allocate memory for the vector. We internally use a default value count\n+    * of 4096 to allocate memory for at least these many elements in the\n+    * vector. See {@link #allocateNew(int, int)} for allocating memory for specific\n+    * number of elements in the vector.\n+    *\n+    * @return false if memory allocation fails, true otherwise.\n+    */\n    @Override\n    public boolean allocateNewSafe() {\n       long curAllocationSizeValue = valueAllocationSizeInBytes;\n@@ -287,8 +357,7 @@ public boolean allocateNewSafe() {\n       try {\n          allocateBytes(curAllocationSizeValue, curAllocationSizeValidity, curAllocationSizeOffset);\n       } catch (Exception e) {\n-         getLogger().error(\"ERROR: Failure in allocateNewSafe\");\n-         getLogger().error(e.getMessage());\n+         e.printStackTrace();\n          clear();\n          return false;\n       }\n@@ -296,11 +365,19 @@ public boolean allocateNewSafe() {\n       return true;\n    }\n \n+   /**\n+    * Allocate memory for the vector to support storing at least the provided number of\n+    * elements in the vector. This method must be called prior to using the ValueVector.\n+    *\n+    * @param totalBytes desired total memory capacity\n+    * @param valueCount the desired number of elements in the vector\n+    * @throws org.apache.arrow.memory.OutOfMemoryException\n+    */\n    @Override\n    public void allocateNew(int totalBytes, int valueCount) {\n       assert totalBytes >= 0;\n       final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n-      final int validityBufferSize = getSizeFromCount(valueCount);\n+      final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n \n       if (totalBytes > MAX_ALLOCATION_SIZE ||\n               offsetBufferSize > MAX_ALLOCATION_SIZE) {\n@@ -313,12 +390,12 @@ public void allocateNew(int totalBytes, int valueCount) {\n       try {\n          allocateBytes(totalBytes, validityBufferSize, offsetBufferSize);\n       } catch (Exception e) {\n-         getLogger().error(\"ERROR: Failure in allocateNewSafe\");\n-         getLogger().error(e.getMessage());\n+         e.printStackTrace();\n          clear();\n       }\n    }\n \n+   /* allocate the inner buffers */\n    private void allocateBytes(final long valueBufferSize, final long validityBufferSize,\n                               final long offsetBufferSize) {\n       /* allocate data buffer */\n@@ -330,6 +407,7 @@ private void allocateBytes(final long valueBufferSize, final long validityBuffer\n       allocateOffsetBuffer(offsetBufferSize);\n    }\n \n+   /* allocate offset buffer */\n    private void allocateOffsetBuffer(final long size) {\n       final int curSize = (int)size;\n       offsetBuffer = allocator.buffer(curSize);\n@@ -338,6 +416,7 @@ private void allocateOffsetBuffer(final long size) {\n       initOffsetBuffer();\n    }\n \n+   /* allocate validity buffer */\n    private void allocateValidityBuffer(final long size) {\n       final int curSize = (int)size;\n       validityBuffer = allocator.buffer(curSize);\n@@ -346,6 +425,10 @@ private void allocateValidityBuffer(final long size) {\n       initValidityBuffer();\n    }\n \n+   /**\n+    * Resize the vector to increase the capacity. The internal behavior is to\n+    * double the current value capacity.\n+    */\n    public void reAlloc() {\n       reallocValueBuffer();\n       reallocValidityAndOffsetBuffers();\n@@ -378,10 +461,7 @@ protected void reallocValidityAndOffsetBuffers() {\n       validityBuffer = reallocBufferHelper(validityBuffer, false);\n    }\n \n-   /* need to refactor this to keep the logic in an single place and make callers\n-    * more intelligent. see handleSafe() for more comments on realloc\n-    */\n-\n+   /* helper method to realloc a particular buffer. returns the allocated buffer */\n    private ArrowBuf reallocBufferHelper(ArrowBuf buffer, final boolean offsetBuffer) {\n       final int currentBufferCapacity = buffer.capacity();\n       long baseSize  = (offsetBuffer ? offsetAllocationSizeInBytes\n@@ -398,10 +478,6 @@ private ArrowBuf reallocBufferHelper(ArrowBuf buffer, final boolean offsetBuffer\n          throw new OversizedAllocationException(\"Unable to expand the buffer\");\n       }\n \n-      getLogger().debug(\"Reallocating vector [{}]. # of bytes: [{}] -> [{}]\",\n-              name, (offsetBuffer ? offsetAllocationSizeInBytes : validityAllocationSizeInBytes),\n-              newAllocationSize);\n-\n       final ArrowBuf newBuf = allocator.buffer((int)newAllocationSize);\n       newBuf.setBytes(0, buffer, 0, currentBufferCapacity);\n       final int halfNewCapacity = newBuf.capacity() / 2;\n@@ -418,6 +494,10 @@ private ArrowBuf reallocBufferHelper(ArrowBuf buffer, final boolean offsetBuffer\n       return buffer;\n    }\n \n+   /**\n+    * Get the size (number of bytes) of underlying data buffer.\n+    * @return\n+    */\n    @Override\n    public int getByteCapacity(){\n       return valueBuffer.capacity();\n@@ -429,30 +509,55 @@ public int getCurrentSizeInBytes(){\n       return 0;\n    }\n \n+   /**\n+    * Get the size (number of bytes) of underlying buffers used by this\n+    * vector\n+    * @return size of underlying buffers.\n+    */\n    @Override\n    public int getBufferSize() {\n-      /* TODO */\n-      return 0;\n+      return getBufferSizeFor(this.valueCount);\n    }\n \n+   /**\n+    * Get the potential buffer size for a particular number of records.\n+    * @param valueCount desired number of elements in the vector\n+    * @return estimated size of underlying buffers if the vector holds\n+    *         a given number of elements\n+    */\n    @Override\n    public int getBufferSizeFor(final int valueCount) {\n       if (valueCount == 0) {\n          return 0;\n       }\n \n-      final int validityBufferSize = getSizeFromCount(valueCount);\n+      final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n       final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n       /* get the end offset for this valueCount */\n       final int dataBufferSize = offsetBuffer.getInt(valueCount * OFFSET_WIDTH);\n       return validityBufferSize + offsetBufferSize + dataBufferSize;\n    }\n \n+   /**\n+    * Get information about how this field is materialized.\n+    * @return the field corresponding to this vector\n+    */\n    @Override\n    public Field getField() {\n       return field;\n    }\n \n+   /**\n+    * Return the underlying buffers associated with this vector. Note that this doesn't\n+    * impact the reference counts for this buffer so it only should be used for in-context\n+    * access. Also note that this buffer changes regularly thus\n+    * external classes shouldn't hold a reference to it (unless they change it).\n+    *\n+    * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+    *              but the returned array will be the only reference to them\n+    * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+    *         vector instance.\n+    */\n    @Override\n    public ArrowBuf[] getBuffers(boolean clear) {\n       final ArrowBuf[] buffers = new ArrowBuf[3];\n@@ -468,18 +573,42 @@ public Field getField() {\n       return buffers;\n    }\n \n+   /**\n+    * Construct a transfer pair of this vector and another vector of same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @param callBack\n+    * @return TransferPair\n+    */\n    @Override\n    public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n       return getTransferPair(ref, allocator);\n    }\n \n+   /**\n+    * Construct a transfer pair of this vector and another vector of same type.\n+    * @param allocator allocator for the target vector\n+    * @return TransferPair\n+    */\n    @Override\n    public TransferPair getTransferPair(BufferAllocator allocator){\n       return getTransferPair(name, allocator);\n    }\n \n+   /**\n+    * Construct a transfer pair of this vector and another vector of same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return TransferPair\n+    */\n    public abstract TransferPair getTransferPair(String ref, BufferAllocator allocator);\n \n+   /**\n+    * Transfer this vector'data to another vector. The memory associated\n+    * with this vector is transferred to the allocator of target vector\n+    * for accounting and management purposes.\n+    * @param target destination vector for transfer\n+    */\n    public void transferTo(BaseNullableVariableWidthVector target){\n       compareTypes(target, \"transferTo\");\n       target.clear();\n@@ -491,6 +620,13 @@ public void transferTo(BaseNullableVariableWidthVector target){\n       clear();\n    }\n \n+   /**\n+    * Slice this vector at desired index and length and transfer the\n+    * corresponding data to the target vector.\n+    * @param startIndex start position of the split in source vector.\n+    * @param length length of the split.\n+    * @param target destination vector\n+    */\n    public void splitAndTransferTo(int startIndex, int length,\n                                   BaseNullableVariableWidthVector target) {\n       compareTypes(target, \"splitAndTransferTo\");\n@@ -502,7 +638,12 @@ public void splitAndTransferTo(int startIndex, int length,\n    }\n \n    /*\n-    * transfer the offsets along with data\n+    * Transfer the offsets along with data. Unlike the data buffer, we cannot simply\n+    * slice the offset buffer for split and transfer. The reason is that offsets\n+    * in the target vector have to be adjusted and made relative to the staring\n+    * offset in source vector from the start index of split. This is why, we\n+    * need to explicitly allocate the offset buffer and set the adjusted offsets\n+    * in the target vector.\n     */\n    private void splitAndTransferOffsetBuffer(int startIndex, int length, BaseNullableVariableWidthVector target) {\n       final int start = offsetBuffer.getInt(startIndex * OFFSET_WIDTH);\n@@ -517,14 +658,14 @@ private void splitAndTransferOffsetBuffer(int startIndex, int length, BaseNullab\n    }\n \n    /*\n-    * transfer the validity.\n+    * Transfer the validity.\n     */\n    private void splitAndTransferValidityBuffer(int startIndex, int length,\n                                                BaseNullableVariableWidthVector target) {\n       assert startIndex + length <= valueCount;\n       int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n       int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n-      int byteSizeTarget = getSizeFromCount(length);\n+      int byteSizeTarget = getValidityBufferSizeFromCount(length);\n       int offset = startIndex % 8;\n \n       if (length > 0) {\n@@ -546,8 +687,8 @@ private void splitAndTransferValidityBuffer(int startIndex, int length,\n             target.allocateValidityBuffer(byteSizeTarget);\n \n             for (int i = 0; i < byteSizeTarget - 1; i++) {\n-               byte b1 = getBitsFromCurrentByte(this.validityBuffer, firstByteSource + i, offset);\n-               byte b2 = getBitsFromNextByte(this.validityBuffer, firstByteSource + i + 1, offset);\n+               byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer, firstByteSource + i, offset);\n+               byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer, firstByteSource + i + 1, offset);\n \n                target.validityBuffer.setByte(i, (b1 + b2));\n             }\n@@ -562,15 +703,15 @@ private void splitAndTransferValidityBuffer(int startIndex, int length,\n              * by shifting data from the current byte.\n              */\n             if((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n-               byte b1 = getBitsFromCurrentByte(this.validityBuffer,\n+               byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n                        firstByteSource + byteSizeTarget - 1, offset);\n-               byte b2 = getBitsFromNextByte(this.validityBuffer,\n+               byte b2 = BitVectorHelper.getBitsFromNextByte(this.validityBuffer,\n                        firstByteSource + byteSizeTarget, offset);\n \n                target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n             }\n             else {\n-               byte b1 = getBitsFromCurrentByte(this.validityBuffer,\n+               byte b1 = BitVectorHelper.getBitsFromCurrentByte(this.validityBuffer,\n                        firstByteSource + byteSizeTarget - 1, offset);\n                target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n             }\n@@ -578,14 +719,6 @@ private void splitAndTransferValidityBuffer(int startIndex, int length,\n       }\n    }\n \n-   private static byte getBitsFromCurrentByte(ArrowBuf data, int index, int offset) {\n-      return (byte)((data.getByte(index) & 0xFF) >>> offset);\n-   }\n-\n-   private static byte getBitsFromNextByte(ArrowBuf data, int index, int offset) {\n-      return (byte)((data.getByte(index) << (8 - offset)));\n-   }\n-\n \n    /******************************************************************\n     *                                                                *\n@@ -600,24 +733,7 @@ private static byte getBitsFromNextByte(ArrowBuf data, int index, int offset) {\n     * @return the number of null elements.\n     */\n    public int getNullCount() {\n-      int count = 0;\n-      final int sizeInBytes = getSizeFromCount(valueCount);\n-\n-      for (int i = 0; i < sizeInBytes; ++i) {\n-         final byte byteValue = validityBuffer.getByte(i);\n-         /* Java uses two's complement binary representation, hence 11111111_b which is -1\n-          * when converted to Int will have 32bits set to 1. Masking the MSB and then\n-          * adding it back solves the issue.\n-          */\n-         count += Integer.bitCount(byteValue & 0x7F) - (byteValue >> 7);\n-      }\n-      int nullCount = (sizeInBytes * 8) - count;\n-      /* if the valueCount is not a multiple of 8,\n-       * the bits on the right were counted as null bits.\n-       */\n-      int remainder = valueCount % 8;\n-      nullCount -= remainder == 0 ? 0 : 8 - remainder;\n-      return nullCount;\n+      return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n    }\n \n    /**\n@@ -679,24 +795,55 @@ public void setValueCount(int valueCount) {\n       lastSet = valueCount - 1;\n    }\n \n+   /**\n+    * Create holes in the vector upto the given index (exclusive).\n+    * Holes will be created from the current last set position in\n+    * the vector.\n+    *\n+    * @param index target index\n+    */\n    public void fillEmpties(int index) {\n       handleSafe(index, emptyByteArray.length);\n       fillHoles(index);\n       lastSet = index - 1;\n    }\n \n+   /**\n+    * Set the index of last non-null element in the vector.\n+    * It is important to call this method with appropriate value\n+    * before calling {@link #setValueCount(int)}.\n+    *\n+    * @param value desired index of last non-null element.\n+    */\n    public void setLastSet(int value) {\n       lastSet = value;\n    }\n \n+   /**\n+    * Get the index of last non-null element in the vector.\n+    *\n+    * @return index of the last non-null element\n+    */\n    public int getLastSet() {\n       return lastSet;\n    }\n \n+   /**\n+    * Get the starting position (offset) in the data stream for a given\n+    * element in the vector.\n+    *\n+    * @param index position of the element in the vector\n+    * @return starting offset for the element\n+    */\n    public long getStartEnd(int index) {\n       return (long)offsetBuffer.getInt(index * OFFSET_WIDTH);\n    }\n \n+   /**\n+    * Mark the particular position in the vector as non-null.\n+    *\n+    * @param index position of the element.\n+    */\n    public void setIndexDefined(int index) {\n       handleSafe(index, 0);\n       BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n@@ -761,4 +908,97 @@ protected final void handleSafe(int index, int dataLength) {\n          reallocValueBuffer();\n       }\n    }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                helper methods currently                        *\n+    *                used by JsonFileReader and                      *\n+    *                JsonFileWriter                                  *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Method used by Json Reader to explicitly set the data of the variable\n+    * width vector elements. The method takes care of allocating the memory\n+    * for the vector if caller hasn't done so.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param data ArrowBuf for storing variable width elements in the vector\n+    * @param offset offset of the element\n+    * @param allocator memory allocator\n+    * @param index position of the element in the vector\n+    * @param value array of bytes for the element\n+    * @param valueCount number of elements in the vector\n+    * @return buffer holding the variable width data.\n+    */\n+   public static ArrowBuf set(ArrowBuf data, ArrowBuf offset,\n+                              BufferAllocator allocator, int index, byte[] value,\n+                              int valueCount) {\n+      if (data == null) {\n+         data = allocator.buffer(INITIAL_BYTE_COUNT);\n+      }\n+      final int currentBufferCapacity = data.capacity();\n+      final int currentStartOffset = offset.getInt(index * OFFSET_WIDTH);\n+      while (currentBufferCapacity < currentStartOffset + value.length) {\n+         final ArrowBuf newBuf = allocator.buffer(currentBufferCapacity * 2);\n+         newBuf.setBytes(0, data, 0, currentBufferCapacity);\n+         data.release();\n+         data = newBuf;\n+      }\n+      data.setBytes(currentStartOffset, value, 0, value.length);\n+      if (index == (valueCount - 1)) {\n+         data.writerIndex(offset.getInt(valueCount * OFFSET_WIDTH));\n+      }\n+      return data;\n+   }\n+\n+   /**\n+    * Method used by Json Writer to read a variable width element from\n+    * the variable width vector and write to Json.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param data buffer storing the variable width vector elements\n+    * @param offset buffer storing the offsets of variable width vector elements\n+    * @param index position of the element in the vector\n+    * @return array of bytes\n+    */\n+   public static byte[] get(final ArrowBuf data, final ArrowBuf offset, int index) {\n+      final int currentStartOffset = offset.getInt(index * OFFSET_WIDTH);\n+      final int dataLength =\n+              offset.getInt((index + 1) * OFFSET_WIDTH) - currentStartOffset;\n+      final byte[] result = new byte[dataLength];\n+      data.getBytes(currentStartOffset, result, 0, dataLength);\n+      return result;\n+   }\n+\n+   /**\n+    * Method used by Json Reader to explicitly set the offsets of the variable\n+    * width vector data. The method takes care of allocating the memory for\n+    * offsets if the caller hasn't done so.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer ArrowBuf to store offsets for variable width elements\n+    * @param allocator memory allocator\n+    * @param valueCount number of elements\n+    * @param index position of the element\n+    * @param value offset of the element\n+    * @return buffer holding the offsets\n+    */\n+   public static ArrowBuf set(ArrowBuf buffer, BufferAllocator allocator,\n+                              int valueCount, int index, int value) {\n+      if (buffer == null) {\n+         buffer = allocator.buffer(valueCount * OFFSET_WIDTH);\n+      }\n+      buffer.setInt(index * OFFSET_WIDTH, value);\n+      if (index == (valueCount - 1)) {\n+         buffer.writerIndex(valueCount * OFFSET_WIDTH);\n+      }\n+\n+      return buffer;\n+   }\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BaseValueVector.java b/java/vector/src/main/java/org/apache/arrow/vector/BaseValueVector.java\nindex 1db962464..1b9678268 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/BaseValueVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BaseValueVector.java\n@@ -56,7 +56,6 @@ public String toString() {\n \n   @Override\n   public void clear() {\n-    getMutator().reset();\n   }\n \n   @Override\n@@ -137,10 +136,36 @@ protected ArrowBuf releaseBuffer(ArrowBuf buffer) {\n     return buffer;\n   }\n \n-  public int getValueCount() { return 0; }\n+  @Override\n+  public int getValueCount() {\n+    return getAccessor().getValueCount();\n+  }\n+\n+  @Override\n+  public void setValueCount(int valueCount) {\n+    getMutator().setValueCount(valueCount);\n+  }\n+\n+  @Override\n+\n+  public Object getObject(int index) {\n+    return getAccessor().getObject(index);\n+  }\n+\n+  @Override\n+\n+  public int getNullCount() {\n+    return getAccessor().getNullCount();\n+  }\n \n-  public void setValueCount(int valueCount) { }\n+  @Override\n+  public boolean isNull(int index) {\n+    return getAccessor().isNull(index);\n+  }\n \n-  public Object getObject(int index) { return null; }\n+  /* number of bytes for the validity buffer for the given valueCount */\n+  protected static int getValidityBufferSizeFromCount(final int valueCount) {\n+    return (int) Math.ceil(valueCount / 8.0);\n+  }\n }\n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BitVectorHelper.java b/java/vector/src/main/java/org/apache/arrow/vector/BitVectorHelper.java\nindex 2439bd26e..69325b5ea 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/BitVectorHelper.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BitVectorHelper.java\n@@ -19,24 +19,35 @@\n package org.apache.arrow.vector;\n \n import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n \n-class BitVectorHelper {\n+/**\n+ * Helper class for performing generic operations on a bit vector buffer.\n+ * External use of this class is not recommended.\n+ */\n+public class BitVectorHelper {\n \n    /**\n     * Get the index of byte corresponding to bit index in validity buffer\n     */\n-   protected static int byteIndex(int absoluteBitIndex) {\n+   public static int byteIndex(int absoluteBitIndex) {\n       return absoluteBitIndex >> 3;\n    }\n \n    /**\n     * Get the relative index of bit within the byte in validity buffer\n     */\n-   private static int bitIndex(int absoluteBitIndex) {\n+   public static int bitIndex(int absoluteBitIndex) {\n       return absoluteBitIndex & 7;\n    }\n \n-   protected static void setValidityBitToOne(ArrowBuf validityBuffer, int index) {\n+   /**\n+    * Set the bit at provided index to 1.\n+    *\n+    * @param validityBuffer\n+    * @param index\n+    */\n+   public static void setValidityBitToOne(ArrowBuf validityBuffer, int index) {\n       final int byteIndex = byteIndex(index);\n       final int bitIndex = bitIndex(index);\n       byte currentByte = validityBuffer.getByte(byteIndex);\n@@ -45,7 +56,14 @@ protected static void setValidityBitToOne(ArrowBuf validityBuffer, int index) {\n       validityBuffer.setByte(byteIndex, currentByte);\n    }\n \n-   protected static void setValidityBit(ArrowBuf validityBuffer, int index, int value) {\n+   /**\n+    * Set the bit at a given index to provided value (1 or 0)\n+    *\n+    * @param validityBuffer\n+    * @param index\n+    * @param value\n+    */\n+   public static void setValidityBit(ArrowBuf validityBuffer, int index, int value) {\n       final int byteIndex = byteIndex(index);\n       final int bitIndex = bitIndex(index);\n       byte currentByte = validityBuffer.getByte(byteIndex);\n@@ -57,4 +75,91 @@ protected static void setValidityBit(ArrowBuf validityBuffer, int index, int val\n       }\n       validityBuffer.setByte(byteIndex, currentByte);\n    }\n+\n+   /**\n+    * Set the bit at a given index to provided value (1 or 0). Internally\n+    * takes care of allocating the buffer if the caller didn't do so.\n+    *\n+    * @param validityBuffer\n+    * @param allocator\n+    * @param valueCount\n+    * @param index\n+    * @param value\n+    * @return ArrowBuf\n+    */\n+   public static ArrowBuf setValidityBit(ArrowBuf validityBuffer, BufferAllocator allocator,\n+                                         int valueCount, int index, int value) {\n+      if (validityBuffer == null) {\n+         validityBuffer = allocator.buffer(getValidityBufferSize(valueCount));\n+      }\n+      setValidityBit(validityBuffer, index, value);\n+      if (index == (valueCount - 1)) {\n+         validityBuffer.writerIndex(getValidityBufferSize(valueCount));\n+      }\n+\n+      return validityBuffer;\n+   }\n+\n+   /**\n+    * Check if a bit at a given index is set or not.\n+    *\n+    * @param buffer\n+    * @param index\n+    * @return 1 if bit is set, 0 otherwise.\n+    */\n+   public static int get(final ArrowBuf buffer, int index) {\n+      final int byteIndex = index >> 3;\n+      final byte b = buffer.getByte(byteIndex);\n+      final int bitIndex = index & 7;\n+      return Long.bitCount(b & (1L << bitIndex));\n+   }\n+\n+   /**\n+    * Compute the size of validity buffer required to manage a given number\n+    * of elements in a vector.\n+    *\n+    * @param valueCount\n+    * @return buffer size\n+    */\n+   public static int getValidityBufferSize(int valueCount) {\n+      return ((int) Math.ceil(valueCount / 8.0));\n+   }\n+\n+   /**\n+    * Given a validity buffer, find the number of bits that are not set.\n+    * This is used to compute the number of null elements in a nullable vector.\n+    *\n+    * @param validityBuffer\n+    * @param valueCount\n+    * @return number of bits not set.\n+    */\n+   public static int getNullCount(final ArrowBuf validityBuffer, final int valueCount) {\n+      if (valueCount == 0) { return 0; }\n+      int count = 0;\n+      final int sizeInBytes = getValidityBufferSize(valueCount);\n+\n+      for (int i = 0; i < sizeInBytes; ++i) {\n+         final byte byteValue = validityBuffer.getByte(i);\n+         /* Java uses two's complement binary representation, hence 11111111_b which is -1\n+          * when converted to Int will have 32bits set to 1. Masking the MSB and then\n+          * adding it back solves the issue.\n+          */\n+         count += Integer.bitCount(byteValue & 0x7F) - (byteValue >> 7);\n+      }\n+      int nullCount = (sizeInBytes * 8) - count;\n+      /* if the valueCount is not a multiple of 8,\n+       * the bits on the right were counted as null bits.\n+       */\n+      int remainder = valueCount % 8;\n+      nullCount -= remainder == 0 ? 0 : 8 - remainder;\n+      return nullCount;\n+   }\n+\n+   public static byte getBitsFromCurrentByte(final ArrowBuf data, final int index, final int offset) {\n+      return (byte)((data.getByte(index) & 0xFF) >>> offset);\n+   }\n+\n+   public static byte getBitsFromNextByte(ArrowBuf data, int index, int offset) {\n+      return (byte)((data.getByte(index) << (8 - offset)));\n+   }\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableBigIntVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableBigIntVector.java\nnew file mode 100644\nindex 000000000..ee40d708c\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableBigIntVector.java\n@@ -0,0 +1,403 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.BigIntReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.BigIntHolder;\n+import org.apache.arrow.vector.holders.NullableBigIntHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableBigIntVector implements a fixed width vector (8 bytes) of\n+ * integer values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableBigIntVector extends BaseNullableFixedWidthVector {\n+   private static final byte TYPE_WIDTH = 8;\n+   private final FieldReader reader;\n+\n+   /**\n+    * Instantiate a NullableBigIntVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableBigIntVector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.BIGINT.getType()),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableBigIntVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableBigIntVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+      reader = new BigIntReaderImpl(NullableBigIntVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.BIGINT;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public long get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return valueBuffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableBigIntHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Long getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return get(index);\n+      }\n+   }\n+\n+   /**\n+    * Copy a cell value from a particular index in source vector to a particular\n+    * position in this vector\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFrom(int fromIndex, int thisIndex, NullableBigIntVector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #copyFrom(int, int, NullableBigIntVector)} except that\n+    * it handles the case when the capacity of the vector needs to be expanded\n+    * before copy.\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableBigIntVector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   private void setValue(int index, long value) {\n+      valueBuffer.setLong(index * TYPE_WIDTH, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, long value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableBigIntHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, BigIntHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, long)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, long value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableBigIntHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableBigIntHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, BigIntHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, BigIntHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   /**\n+    * Store the given value at a particular position in the vector. isSet indicates\n+    * whether the value is NULL or not.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void set(int index, int isSet, long value) {\n+      if (isSet > 0) {\n+         set(index, value);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int, long)} except that it handles the case\n+    * when index is greater than or equal to current value capacity of the\n+    * vector.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void setSafe(int index, int isSet, long value) {\n+      handleSafe(index);\n+      set(index, isSet, value);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          helper routines currently                             *\n+    *          used in JsonFileReader and JsonFileWriter             *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Given a data buffer, this method sets the element value at a particular\n+    * position. Reallocates the buffer if needed.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param allocator allocator\n+    * @param valueCount number of elements in the vector\n+    * @param index position of the new element\n+    * @param value element value\n+    * @return data buffer\n+    */\n+   public static ArrowBuf set(ArrowBuf buffer, BufferAllocator allocator,\n+                              int valueCount, int index, long value) {\n+      if (buffer == null) {\n+         buffer = allocator.buffer(valueCount * TYPE_WIDTH);\n+      }\n+      buffer.setLong(index * TYPE_WIDTH, value);\n+      if (index == (valueCount - 1)) {\n+         buffer.writerIndex(valueCount * TYPE_WIDTH);\n+      }\n+\n+      return buffer;\n+   }\n+\n+   /**\n+    * Given a data buffer, get the value stored at a particular position\n+    * in the vector.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param index position of the element.\n+    * @return value stored at the index.\n+    */\n+   public static long get(final ArrowBuf buffer, final int index) {\n+      return buffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableBigIntVector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableBigIntVector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableBigIntVector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableBigIntVector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableBigIntVector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableBigIntVector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableBitVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableBitVector.java\nnew file mode 100644\nindex 000000000..eceaa61b5\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableBitVector.java\n@@ -0,0 +1,502 @@\n+/*******************************************************************************\n+\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ ******************************************************************************/\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.BitReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.BitHolder;\n+import org.apache.arrow.vector.holders.NullableBitHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * NullableBitVector implements a fixed width (1 bit) vector of\n+ * boolean values which could be null. Each value in the vector corresponds\n+ * to a single bit in the underlying data stream backing the vector.\n+ */\n+public class NullableBitVector extends BaseNullableFixedWidthVector {\n+   private final FieldReader reader;\n+\n+   /**\n+    * Instantiate a NullableBitVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableBitVector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.BIT.getType()),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableBitVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableBitVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, (byte)0);\n+      reader = new BitReaderImpl(NullableBitVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.BIT;\n+   }\n+\n+   /**\n+    * Sets the desired value capacity for the vector. This function doesn't\n+    * allocate any memory for the vector.\n+    * @param valueCount desired number of elements in the vector\n+    */\n+   @Override\n+   public void setInitialCapacity(int valueCount) {\n+      final int size = getValidityBufferSizeFromCount(valueCount);\n+      if (size > MAX_ALLOCATION_SIZE) {\n+         throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+      }\n+      valueAllocationSizeInBytes = size;\n+      validityAllocationSizeInBytes = size;\n+   }\n+\n+   /**\n+    * Get the current value capacity for the vector\n+    * @return number of elements that vector can hold.\n+    */\n+   @Override\n+   public int getValueCapacity(){\n+      return (int)(validityBuffer.capacity() * 8L);\n+   }\n+\n+   /**\n+    * Get the potential buffer size for a particular number of records.\n+    * @param count desired number of elements in the vector\n+    * @return estimated size of underlying buffers if the vector holds\n+    *         a given number of elements\n+    */\n+   @Override\n+   public int getBufferSizeFor(final int count) {\n+      if (count == 0) { return 0; }\n+      return 2 * getValidityBufferSizeFromCount(count);\n+   }\n+\n+   /**\n+    * Get the size (number of bytes) of underlying buffers used by this\n+    * vector\n+    * @return size of underlying buffers.\n+    */\n+   @Override\n+   public int getBufferSize() {\n+     return getBufferSizeFor(valueCount);\n+   }\n+\n+   /**\n+    * Slice this vector at desired index and length and transfer the\n+    * corresponding data to the target vector.\n+    * @param startIndex start position of the split in source vector.\n+    * @param length length of the split.\n+    * @param target destination vector\n+    */\n+   public void splitAndTransferTo(int startIndex, int length,\n+                                  BaseNullableFixedWidthVector target) {\n+      compareTypes(target, \"splitAndTransferTo\");\n+      target.clear();\n+      target.validityBuffer = splitAndTransferBuffer(startIndex, length, target,\n+                                 validityBuffer, target.validityBuffer);\n+      target.valueBuffer = splitAndTransferBuffer(startIndex, length, target,\n+                                 valueBuffer, target.valueBuffer);\n+\n+      target.setValueCount(length);\n+   }\n+\n+   private ArrowBuf splitAndTransferBuffer(int startIndex, int length,\n+                                           BaseNullableFixedWidthVector target,\n+                                           ArrowBuf sourceBuffer, ArrowBuf destBuffer) {\n+      assert startIndex + length <= valueCount;\n+      int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+      int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+      int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+      int offset = startIndex % 8;\n+\n+      if (length > 0) {\n+         if (offset == 0) {\n+            /* slice */\n+            if (destBuffer != null) {\n+               destBuffer.release();\n+            }\n+            destBuffer = destBuffer.slice(firstByteSource, byteSizeTarget);\n+            destBuffer.retain(1);\n+         }\n+         else {\n+            /* Copy data\n+             * When the first bit starts from the middle of a byte (offset != 0),\n+             * copy data from src BitVector.\n+             * Each byte in the target is composed by a part in i-th byte,\n+             * another part in (i+1)-th byte.\n+             */\n+            destBuffer = allocator.buffer(byteSizeTarget);\n+            destBuffer.readerIndex(0);\n+            destBuffer.setZero(0, destBuffer.capacity());\n+\n+            for (int i = 0; i < byteSizeTarget - 1; i++) {\n+               byte b1 = BitVectorHelper.getBitsFromCurrentByte(sourceBuffer, firstByteSource + i, offset);\n+               byte b2 = BitVectorHelper.getBitsFromNextByte(sourceBuffer, firstByteSource + i + 1, offset);\n+\n+               destBuffer.setByte(i, (b1 + b2));\n+            }\n+\n+            /* Copying the last piece is done in the following manner:\n+             * if the source vector has 1 or more bytes remaining, we copy\n+             * the last piece as a byte formed by shifting data\n+             * from the current byte and the next byte.\n+             *\n+             * if the source vector has no more bytes remaining\n+             * (we are at the last byte), we copy the last piece as a byte\n+             * by shifting data from the current byte.\n+             */\n+            if((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+               byte b1 = BitVectorHelper.getBitsFromCurrentByte(sourceBuffer,\n+                       firstByteSource + byteSizeTarget - 1, offset);\n+               byte b2 = BitVectorHelper.getBitsFromNextByte(sourceBuffer,\n+                       firstByteSource + byteSizeTarget, offset);\n+\n+               destBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+            }\n+            else {\n+               byte b1 = BitVectorHelper.getBitsFromCurrentByte(sourceBuffer,\n+                       firstByteSource + byteSizeTarget - 1, offset);\n+               destBuffer.setByte(byteSizeTarget - 1, b1);\n+            }\n+         }\n+      }\n+\n+      return destBuffer;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+   private int getBit(int index) {\n+      final int byteIndex = index >> 3;\n+      final byte b = valueBuffer.getByte(byteIndex);\n+      final int bitIndex = index & 7;\n+      return Long.bitCount(b & (1L << bitIndex));\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public int get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return getBit(index);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableBitHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = getBit(index);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Boolean getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return new Boolean (getBit(index) != 0);\n+      }\n+   }\n+\n+   /**\n+    * Copy a cell value from a particular index in source vector to a particular\n+    * position in this vector\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFrom(int fromIndex, int thisIndex, NullableBitVector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #copyFrom(int, int, NullableBitVector)} except that\n+    * it handles the case when the capacity of the vector needs to be expanded\n+    * before copy.\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableBitVector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, int value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      if (value != 0) {\n+         BitVectorHelper.setValidityBitToOne(valueBuffer, index);\n+      } else {\n+         BitVectorHelper.setValidityBit(valueBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableBitHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         if (holder.value != 0) {\n+            BitVectorHelper.setValidityBitToOne(valueBuffer, index);\n+         } else {\n+            BitVectorHelper.setValidityBit(valueBuffer, index, 0);\n+         }\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, BitHolder holder) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      if (holder.value != 0) {\n+         BitVectorHelper.setValidityBitToOne(valueBuffer, index);\n+      } else {\n+         BitVectorHelper.setValidityBit(valueBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, int value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableBitHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableBitHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, BitHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, BitHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   /**\n+    * Store the given value at a particular position in the vector. isSet indicates\n+    * whether the value is NULL or not.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void set(int index, int isSet, int value) {\n+      if (isSet > 0) {\n+         set(index, value);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int, int)} except that it handles the case\n+    * when index is greater than or equal to current value capacity of the\n+    * vector.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void setSafe(int index, int isSet, int value) {\n+      handleSafe(index);\n+      set(index, isSet, value);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableBitVector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableBitVector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableBitVector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableBitVector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableBitVector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableBitVector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableDateDayVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableDateDayVector.java\nnew file mode 100644\nindex 000000000..949287eca\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableDateDayVector.java\n@@ -0,0 +1,404 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.DateDayReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.DateDayHolder;\n+import org.apache.arrow.vector.holders.NullableDateDayHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.slf4j.Logger;\n+\n+/**\n+ * NullableDateDayVector implements a fixed width (4 bytes) vector of\n+ * date values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableDateDayVector extends BaseNullableFixedWidthVector {\n+   private static final byte TYPE_WIDTH = 4;\n+   private final FieldReader reader;\n+\n+   /**\n+    * Instantiate a NullableDateDayVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableDateDayVector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.DATEDAY.getType()),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableDateDayVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableDateDayVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+      reader = new DateDayReaderImpl(NullableDateDayVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.DATEDAY;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public int get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return valueBuffer.getInt(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableDateDayHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getInt(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Integer getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return get(index);\n+      }\n+   }\n+\n+   /**\n+    * Copy a cell value from a particular index in source vector to a particular\n+    * position in this vector\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFrom(int fromIndex, int thisIndex, NullableDateDayVector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #copyFrom(int, int, NullableDateDayVector)} except that\n+    * it handles the case when the capacity of the vector needs to be expanded\n+    * before copy.\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableDateDayVector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   private void setValue(int index, int value) {\n+      valueBuffer.setInt(index * TYPE_WIDTH, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, int value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableDateDayHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, DateDayHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, int value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableDateDayHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableDateDayHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, DateDayHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, DateDayHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   /**\n+    * Store the given value at a particular position in the vector. isSet indicates\n+    * whether the value is NULL or not.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void set(int index, int isSet, int value) {\n+      if (isSet > 0) {\n+         set(index, value);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int, int)} except that it handles the case\n+    * when index is greater than or equal to current value capacity of the\n+    * vector.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void setSafe(int index, int isSet, int value) {\n+      handleSafe(index);\n+      set(index, isSet, value);\n+   }\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          helper routines currently                             *\n+    *          used in JsonFileReader                                *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Given a data buffer, this method sets the element value at a particular\n+    * position. Reallocates the buffer if needed.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param allocator allocator\n+    * @param valueCount number of elements in the vector\n+    * @param index position of the new element\n+    * @param value element value\n+    * @return data buffer\n+    */\n+   public static ArrowBuf set(ArrowBuf buffer, BufferAllocator allocator,\n+                              int valueCount, int index, int value) {\n+      if (buffer == null) {\n+         buffer = allocator.buffer(valueCount * TYPE_WIDTH);\n+      }\n+      buffer.setInt(index * TYPE_WIDTH, value);\n+      if (index == (valueCount - 1)) {\n+         buffer.writerIndex(valueCount * TYPE_WIDTH);\n+      }\n+\n+      return buffer;\n+   }\n+\n+   /**\n+    * Given a data buffer, get the value stored at a particular position\n+    * in the vector.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param index position of the element.\n+    * @return value stored at the index.\n+    */\n+   public static int get(final ArrowBuf buffer, final int index) {\n+      return buffer.getInt(index * TYPE_WIDTH);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableDateDayVector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableDateDayVector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableDateDayVector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableDateDayVector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableDateDayVector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableDateDayVector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableDateMilliVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableDateMilliVector.java\nnew file mode 100644\nindex 000000000..a0bdccede\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableDateMilliVector.java\n@@ -0,0 +1,408 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.DateMilliReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.DateMilliHolder;\n+import org.apache.arrow.vector.holders.NullableDateMilliHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.joda.time.LocalDateTime;\n+import org.joda.time.LocalDateTimes;\n+import org.slf4j.Logger;\n+\n+/**\n+ * NullableDateMilliVector implements a fixed width vector (8 bytes) of\n+ * date values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableDateMilliVector extends BaseNullableFixedWidthVector {\n+   private static final byte TYPE_WIDTH = 8;\n+   private final FieldReader reader;\n+\n+   /**\n+    * Instantiate a NullableDateMilliVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableDateMilliVector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.DATEMILLI.getType()),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableDateMilliVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableDateMilliVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+      reader = new DateMilliReaderImpl(NullableDateMilliVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.DATEMILLI;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public long get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return valueBuffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableDateMilliHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public LocalDateTime getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         final long millis = get(index);\n+         final LocalDateTime localDateTime = new org.joda.time.LocalDateTime(millis, org.joda.time.DateTimeZone.UTC);\n+         return localDateTime;\n+      }\n+   }\n+\n+   /**\n+    * Copy a cell value from a particular index in source vector to a particular\n+    * position in this vector\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFrom(int fromIndex, int thisIndex, NullableDateMilliVector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #copyFrom(int, int, NullableDateMilliVector)} except that\n+    * it handles the case when the capacity of the vector needs to be expanded\n+    * before copy.\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableDateMilliVector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   private void setValue(int index, long value) {\n+      valueBuffer.setLong(index * TYPE_WIDTH, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, long value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableDateMilliHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, DateMilliHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, long)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, long value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableDateMilliHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableDateMilliHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, DateMilliHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, DateMilliHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   /**\n+    * Store the given value at a particular position in the vector. isSet indicates\n+    * whether the value is NULL or not.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void set(int index, int isSet, long value) {\n+      if (isSet > 0) {\n+         set(index, value);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int, long)} except that it handles the case\n+    * when index is greater than or equal to current value capacity of the\n+    * vector.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void setSafe(int index, int isSet, long value) {\n+      handleSafe(index);\n+      set(index, isSet, value);\n+   }\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          helper routines currently                             *\n+    *          used in JsonFileReader                                *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Given a data buffer, this method sets the element value at a particular\n+    * position. Reallocates the buffer if needed.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param allocator allocator\n+    * @param valueCount number of elements in the vector\n+    * @param index position of the new element\n+    * @param value element value\n+    * @return data buffer\n+    */\n+   public static ArrowBuf set(ArrowBuf buffer, BufferAllocator allocator,\n+                              int valueCount, int index, long value) {\n+      if (buffer == null) {\n+         buffer = allocator.buffer(valueCount * TYPE_WIDTH);\n+      }\n+      buffer.setLong(index * TYPE_WIDTH, value);\n+      if (index == (valueCount - 1)) {\n+         buffer.writerIndex(valueCount * TYPE_WIDTH);\n+      }\n+\n+      return buffer;\n+   }\n+\n+   /**\n+    * Given a data buffer, get the value stored at a particular position\n+    * in the vector.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param index position of the element.\n+    * @return value stored at the index.\n+    */\n+   public static long get(final ArrowBuf buffer, final int index) {\n+      return buffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableDateMilliVector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableDateMilliVector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableDateMilliVector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableDateMilliVector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableDateMilliVector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableDateMilliVector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableDecimalVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableDecimalVector.java\nnew file mode 100644\nindex 000000000..8320f9083\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableDecimalVector.java\n@@ -0,0 +1,454 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.DecimalReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.DecimalHolder;\n+import org.apache.arrow.vector.holders.NullableDecimalHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.DecimalUtility;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * NullableDecimalVector implements a fixed width vector (16 bytes) of\n+ * decimal values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableDecimalVector extends BaseNullableFixedWidthVector {\n+   private static final byte TYPE_WIDTH = 16;\n+   private final FieldReader reader;\n+\n+   private final int precision;\n+   private final int scale;\n+\n+   /**\n+    * Instantiate a NullableDecimalVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableDecimalVector(String name, BufferAllocator allocator,\n+                                int precision, int scale) {\n+      this(name, FieldType.nullable(new org.apache.arrow.vector.types.pojo.ArrowType.Decimal(precision, scale)),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableDecimalVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableDecimalVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+      org.apache.arrow.vector.types.pojo.ArrowType.Decimal arrowType = (org.apache.arrow.vector.types.pojo.ArrowType.Decimal)fieldType.getType();\n+      reader = new DecimalReaderImpl(NullableDecimalVector.this);\n+      this.precision = arrowType.getPrecision();\n+      this.scale = arrowType.getScale();\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.DECIMAL;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public ArrowBuf get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return valueBuffer.slice(index * TYPE_WIDTH, TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableDecimalHolder holder) {\n+      if (isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.buffer = valueBuffer;\n+      holder.precision = precision;\n+      holder.scale = scale;\n+      holder.start = index * TYPE_WIDTH;\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public BigDecimal getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return DecimalUtility.getBigDecimalFromArrowBuf(valueBuffer, index, scale);\n+      }\n+   }\n+\n+   /**\n+    * Copy a cell value from a particular index in source vector to a particular\n+    * position in this vector\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFrom(int fromIndex, int thisIndex, NullableDecimalVector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         from.valueBuffer.getBytes(fromIndex * TYPE_WIDTH, valueBuffer,\n+                 thisIndex * TYPE_WIDTH, TYPE_WIDTH);\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #copyFrom(int, int, NullableDecimalVector)} except that\n+    * it handles the case when the capacity of the vector needs to be expanded\n+    * before copy.\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableDecimalVector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index    position of element\n+    * @param buffer   ArrowBuf containing decimal value.\n+    */\n+   public void set(int index, ArrowBuf buffer) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      valueBuffer.setBytes(index * TYPE_WIDTH, buffer, 0, TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index    position of element\n+    * @param start    start index of data in the buffer\n+    * @param buffer   ArrowBuf containing decimal value.\n+    */\n+   public void set(int index, int start, ArrowBuf buffer) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      valueBuffer.setBytes(index * TYPE_WIDTH, buffer, start, TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   BigDecimal containing decimal value.\n+    */\n+   public void set(int index, BigDecimal value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      DecimalUtility.checkPrecisionAndScale(value, precision, scale);\n+      DecimalUtility.writeBigDecimalToArrowBuf(value, valueBuffer, index);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableDecimalHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         valueBuffer.setBytes(index * TYPE_WIDTH, holder.buffer, holder.start, TYPE_WIDTH);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, DecimalHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      valueBuffer.setBytes(index * TYPE_WIDTH, holder.buffer, holder.start, TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, ArrowBuf)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param buffer  ArrowBuf containing decimal value.\n+    */\n+   public void setSafe(int index, ArrowBuf buffer) {\n+      handleSafe(index);\n+      set(index, buffer);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int, ArrowBuf)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index    position of element\n+    * @param start    start index of data in the buffer\n+    * @param buffer   ArrowBuf containing decimal value.\n+    */\n+   public void setSafe(int index, int start, ArrowBuf buffer) {\n+      handleSafe(index);\n+      set(index, start, buffer);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, BigDecimal)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   BigDecimal containing decimal value.\n+    */\n+   public void setSafe(int index, BigDecimal value){\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableDecimalHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableDecimalHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, DecimalHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, DecimalHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   /**\n+    * Store the given value at a particular position in the vector. isSet indicates\n+    * whether the value is NULL or not.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param start start position of the value in the buffer\n+    * @param buffer buffer containing the value to be stored in the vector\n+    */\n+   public void set(int index, int isSet, int start, ArrowBuf buffer) {\n+      if (isSet > 0) {\n+         set(index, start, buffer);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #setSafe(int, int, int, ArrowBuf)} except that it handles\n+    * the case when the position of new value is beyond the current value\n+    * capacity of the vector.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param start start position of the value in the buffer\n+    * @param buffer buffer containing the value to be stored in the vector\n+    */\n+   public void setSafe(int index, int isSet, int start, ArrowBuf buffer) {\n+      handleSafe(index);\n+      set(index, isSet, start, buffer);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          helper routines currently                             *\n+    *          used in JsonFileReader                                *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Given a data buffer, this method sets the element value at a particular\n+    * position. Reallocates the buffer if needed.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param allocator allocator\n+    * @param valueCount number of elements in the vector\n+    * @param index position of the new element\n+    * @param value element value as array of bytes\n+    * @return data buffer\n+    */\n+   public static ArrowBuf set(ArrowBuf buffer, BufferAllocator allocator,\n+                              int valueCount, int index, byte[] value) {\n+      if (buffer == null) {\n+         buffer = allocator.buffer(valueCount * TYPE_WIDTH);\n+      }\n+      DecimalUtility.writeByteArrayToArrowBuf(value, buffer, index);\n+      if (index == (valueCount - 1)) {\n+         buffer.writerIndex(valueCount * TYPE_WIDTH);\n+      }\n+\n+      return buffer;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableDecimalVector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableDecimalVector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableDecimalVector(ref, allocator, NullableDecimalVector.this.precision,\n+                 NullableDecimalVector.this.scale);\n+      }\n+\n+      public TransferImpl(NullableDecimalVector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableDecimalVector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableDecimalVector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableFloat4Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableFloat4Vector.java\nnew file mode 100644\nindex 000000000..5b28065c4\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableFloat4Vector.java\n@@ -0,0 +1,404 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.Float4ReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.Float4Holder;\n+import org.apache.arrow.vector.holders.NullableFloat4Holder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableFloat4Vector implements a fixed width vector (4 bytes) of\n+ * float values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableFloat4Vector extends BaseNullableFixedWidthVector {\n+   private static final byte TYPE_WIDTH = 4;\n+   private final FieldReader reader;\n+\n+   /**\n+    * Instantiate a NullableFloat4Vector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableFloat4Vector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.FLOAT4.getType()),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableFloat4Vector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableFloat4Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+      reader = new Float4ReaderImpl(NullableFloat4Vector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.FLOAT4;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public float get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return valueBuffer.getFloat(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableFloat4Holder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getFloat(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Float getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return get(index);\n+      }\n+   }\n+\n+   /**\n+    * Copy a cell value from a particular index in source vector to a particular\n+    * position in this vector\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFrom(int fromIndex, int thisIndex, NullableFloat4Vector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #copyFrom(int, int, NullableFloat4Vector)} except that\n+    * it handles the case when the capacity of the vector needs to be expanded\n+    * before copy.\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableFloat4Vector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   private void setValue(int index, float value) {\n+      valueBuffer.setFloat(index * TYPE_WIDTH, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, float value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableFloat4Holder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, Float4Holder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, float)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, float value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableFloat4Holder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableFloat4Holder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, Float4Holder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, Float4Holder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   /**\n+    * Store the given value at a particular position in the vector. isSet indicates\n+    * whether the value is NULL or not.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void set(int index, int isSet, float value) {\n+      if (isSet > 0) {\n+         set(index, value);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int, float)} except that it handles the case\n+    * when index is greater than or equal to current value capacity of the\n+    * vector.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void setSafe(int index, int isSet, float value) {\n+      handleSafe(index);\n+      set(index, isSet, value);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          helper routines currently                             *\n+    *          used in JsonFileReader and JsonFileWriter             *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Given a data buffer, this method sets the element value at a particular\n+    * position. Reallocates the buffer if needed.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param allocator allocator\n+    * @param valueCount number of elements in the vector\n+    * @param index position of the new element\n+    * @param value element value\n+    * @return data buffer\n+    */\n+   public static ArrowBuf set(ArrowBuf buffer, BufferAllocator allocator,\n+                              int valueCount, int index, float value) {\n+      if (buffer == null) {\n+         buffer = allocator.buffer(valueCount * TYPE_WIDTH);\n+      }\n+      buffer.setFloat(index * TYPE_WIDTH, value);\n+      if (index == (valueCount - 1)) {\n+         buffer.writerIndex(valueCount * TYPE_WIDTH);\n+      }\n+\n+      return buffer;\n+   }\n+\n+   /**\n+    * Given a data buffer, get the value stored at a particular position\n+    * in the vector.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param index position of the element.\n+    * @return value stored at the index.\n+    */\n+   public static float get(final ArrowBuf buffer, final int index) {\n+      return buffer.getFloat(index * TYPE_WIDTH);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableFloat4Vector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableFloat4Vector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableFloat4Vector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableFloat4Vector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableFloat4Vector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableFloat4Vector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableFloat8Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableFloat8Vector.java\nnew file mode 100644\nindex 000000000..624abf2f2\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableFloat8Vector.java\n@@ -0,0 +1,404 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.Float8ReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.Float8Holder;\n+import org.apache.arrow.vector.holders.NullableFloat8Holder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableFloat8Vector implements a fixed width vector (8 bytes) of\n+ * double values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableFloat8Vector extends BaseNullableFixedWidthVector {\n+   private static final byte TYPE_WIDTH = 8;\n+   private final FieldReader reader;\n+\n+   /**\n+    * Instantiate a NullableFloat8Vector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableFloat8Vector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.FLOAT8.getType()),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableFloat8Vector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableFloat8Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+      reader = new Float8ReaderImpl(NullableFloat8Vector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.FLOAT8;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public double get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return valueBuffer.getDouble(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableFloat8Holder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getDouble(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Double getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return get(index);\n+      }\n+   }\n+\n+   /**\n+    * Copy a cell value from a particular index in source vector to a particular\n+    * position in this vector\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFrom(int fromIndex, int thisIndex, NullableFloat8Vector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #copyFrom(int, int, NullableFloat8Vector)} except that\n+    * it handles the case when the capacity of the vector needs to be expanded\n+    * before copy.\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableFloat8Vector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   private void setValue(int index, double value) {\n+      valueBuffer.setDouble(index * TYPE_WIDTH, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, double value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableFloat8Holder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, Float8Holder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, double)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, double value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableFloat8Holder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableFloat8Holder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, Float8Holder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, Float8Holder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   /**\n+    * Store the given value at a particular position in the vector. isSet indicates\n+    * whether the value is NULL or not.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void set(int index, int isSet, double value) {\n+      if (isSet > 0) {\n+         set(index, value);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int, double)} except that it handles the case\n+    * when index is greater than or equal to current value capacity of the\n+    * vector.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void setSafe(int index, int isSet, double value) {\n+      handleSafe(index);\n+      set(index, isSet, value);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          helper routines currently                             *\n+    *          used in JsonFileReader and JsonFileWriter             *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Given a data buffer, this method sets the element value at a particular\n+    * position. Reallocates the buffer if needed.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param allocator allocator\n+    * @param valueCount number of elements in the vector\n+    * @param index position of the new element\n+    * @param value element value\n+    * @return data buffer\n+    */\n+   public static ArrowBuf set(ArrowBuf buffer, BufferAllocator allocator,\n+                              int valueCount, int index, double value) {\n+      if (buffer == null) {\n+         buffer = allocator.buffer(valueCount * TYPE_WIDTH);\n+      }\n+      buffer.setDouble(index * TYPE_WIDTH, value);\n+      if (index == (valueCount - 1)) {\n+         buffer.writerIndex(valueCount * TYPE_WIDTH);\n+      }\n+\n+      return buffer;\n+   }\n+\n+   /**\n+    * Given a data buffer, get the value stored at a particular position\n+    * in the vector.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param index position of the element.\n+    * @return value stored at the index.\n+    */\n+   public static double get(final ArrowBuf buffer, final int index) {\n+      return buffer.getDouble(index * TYPE_WIDTH);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableFloat8Vector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableFloat8Vector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableFloat8Vector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableFloat8Vector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableFloat8Vector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableFloat8Vector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableIntVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableIntVector.java\nindex 26b19fa7b..6311daf4f 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableIntVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableIntVector.java\n@@ -1,5 +1,4 @@\n-/*******************************************************************************\n-\n+/**\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n@@ -15,10 +14,11 @@\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n- ******************************************************************************/\n+ */\n \n package org.apache.arrow.vector;\n \n+import io.netty.buffer.ArrowBuf;\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.complex.impl.IntReaderImpl;\n import org.apache.arrow.vector.complex.reader.FieldReader;\n@@ -27,39 +27,53 @@\n import org.apache.arrow.vector.types.Types;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n-import org.slf4j.Logger;\n \n /**\n- * NullableIntVector implements a fixed width vector of values which could\n- * be null. A validity buffer (bit vector) is maintained to track which\n- * elements in the vector are null.\n+ * NullableIntVector implements a fixed width (4 bytes) vector of\n+ * integer values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n  */\n public class NullableIntVector extends BaseNullableFixedWidthVector {\n-   private static final org.slf4j.Logger logger =\n-           org.slf4j.LoggerFactory.getLogger(NullableIntVector.class);\n    private static final byte TYPE_WIDTH = 4;\n    private final FieldReader reader;\n \n+   /**\n+    * Instantiate a NullableIntVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n    public NullableIntVector(String name, BufferAllocator allocator) {\n       this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.INT.getType()),\n               allocator);\n    }\n \n+   /**\n+    * Instantiate a NullableIntVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n    public NullableIntVector(String name, FieldType fieldType, BufferAllocator allocator) {\n       super(name, allocator, fieldType, TYPE_WIDTH);\n       reader = new IntReaderImpl(NullableIntVector.this);\n    }\n \n-   @Override\n-   protected org.slf4j.Logger getLogger() {\n-      return logger;\n-   }\n-\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n    @Override\n    public FieldReader getReader(){\n       return reader;\n    }\n \n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n    @Override\n    public Types.MinorType getMinorType() {\n       return Types.MinorType.INT;\n@@ -116,12 +130,27 @@ public Integer getObject(int index) {\n       }\n    }\n \n+   /**\n+    * Copy a cell value from a particular index in source vector to a particular\n+    * position in this vector\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n    public void copyFrom(int fromIndex, int thisIndex, NullableIntVector from) {\n       if (from.isSet(fromIndex) != 0) {\n          set(thisIndex, from.get(fromIndex));\n       }\n    }\n \n+   /**\n+    * Same as {@link #copyFrom(int, int, NullableIntVector)} except that\n+    * it handles the case when the capacity of the vector needs to be expanded\n+    * before copy.\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n    public void copyFromSafe(int fromIndex, int thisIndex, NullableIntVector from) {\n       handleSafe(thisIndex);\n       copyFrom(fromIndex, thisIndex, from);\n@@ -234,17 +263,80 @@ public void setNull(int index){\n       BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n    }\n \n-   public void set(int index, int isSet, int valueField ) {\n+   /**\n+    * Store the given value at a particular position in the vector. isSet indicates\n+    * whether the value is NULL or not.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void set(int index, int isSet, int value) {\n       if (isSet > 0) {\n-         set(index, valueField);\n+         set(index, value);\n       } else {\n          BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n       }\n    }\n \n-   public void setSafe(int index, int isSet, int valueField ) {\n+   /**\n+    * Same as {@link #set(int, int, int)} except that it handles the case\n+    * when index is greater than or equal to current value capacity of the\n+    * vector.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void setSafe(int index, int isSet, int value) {\n       handleSafe(index);\n-      set(index, isSet, valueField);\n+      set(index, isSet, value);\n+   }\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          helper routines currently                             *\n+    *          used in JsonFileReader and JsonFileWriter             *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Given a data buffer, this method sets the element value at a particular\n+    * position. Reallocates the buffer if needed.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param allocator allocator\n+    * @param valueCount number of elements in the vector\n+    * @param index position of the new element\n+    * @param value element value\n+    * @return data buffer\n+    */\n+   public static ArrowBuf set(ArrowBuf buffer, BufferAllocator allocator,\n+                              int valueCount, int index, int value) {\n+      if (buffer == null) {\n+         buffer = allocator.buffer(valueCount * TYPE_WIDTH);\n+      }\n+      buffer.setInt(index * TYPE_WIDTH, value);\n+      if (index == (valueCount - 1)) {\n+         buffer.writerIndex(valueCount * TYPE_WIDTH);\n+      }\n+\n+      return buffer;\n+   }\n+\n+   /**\n+    * Given a data buffer, get the value stored at a particular position\n+    * in the vector.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param index position of the element.\n+    * @return value stored at the index.\n+    */\n+   public static int get(final ArrowBuf buffer, final int index) {\n+      return buffer.getInt(index * TYPE_WIDTH);\n    }\n \n \n@@ -255,11 +347,23 @@ public void setSafe(int index, int isSet, int valueField ) {\n     ******************************************************************/\n \n \n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n    @Override\n    public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n       return new TransferImpl(ref, allocator);\n    }\n \n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n    @Override\n    public TransferPair makeTransferPair(ValueVector to) {\n       return new TransferImpl((NullableIntVector)to);\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableIntervalDayVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableIntervalDayVector.java\nnew file mode 100644\nindex 000000000..174b722b0\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableIntervalDayVector.java\n@@ -0,0 +1,429 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.IntervalDayReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.IntervalDayHolder;\n+import org.apache.arrow.vector.holders.NullableIntervalDayHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.joda.time.Period;\n+\n+/**\n+ * NullableIntervalDayVector implements a fixed width vector (8 bytes) of\n+ * interval (days and milliseconds) values which could be null.\n+ * A validity buffer (bit vector) is maintained to track which elements in the\n+ * vector are null.\n+ */\n+public class NullableIntervalDayVector extends BaseNullableFixedWidthVector {\n+   private static final byte TYPE_WIDTH = 8;\n+   private static final byte MILLISECOND_OFFSET = 4;\n+   private final FieldReader reader;\n+\n+   /**\n+    * Instantiate a NullableIntervalDayVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableIntervalDayVector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.INTERVALDAY.getType()),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableIntervalDayVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableIntervalDayVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+      reader = new IntervalDayReaderImpl(NullableIntervalDayVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.INTERVALDAY;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public ArrowBuf get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         return null;\n+      }\n+      return valueBuffer.slice(index * TYPE_WIDTH, TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableIntervalDayHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      final int startIndex = index * TYPE_WIDTH;\n+      holder.isSet = 1;\n+      holder.days = valueBuffer.getInt(startIndex);\n+      holder.milliseconds = valueBuffer.getInt(startIndex + MILLISECOND_OFFSET);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Period getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         final int startIndex = index * TYPE_WIDTH;\n+         final int days = valueBuffer.getInt(startIndex);\n+         final int milliseconds = valueBuffer.getInt(startIndex + MILLISECOND_OFFSET);\n+         final Period p = new Period();\n+         return p.plusDays(days).plusMillis(milliseconds);\n+      }\n+   }\n+\n+   /**\n+    * Get the Interval value at a given index as a {@link StringBuilder} object\n+    * @param index position of the element\n+    * @return String Builder object with Interval value as\n+    *         [days, hours, minutes, seconds, millis]\n+    */\n+   public StringBuilder getAsStringBuilder(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      }else{\n+         return getAsStringBuilderHelper(index);\n+      }\n+   }\n+\n+   private StringBuilder getAsStringBuilderHelper(int index) {\n+      final int startIndex = index * TYPE_WIDTH;\n+\n+      final int  days = valueBuffer.getInt(startIndex);\n+      int millis = valueBuffer.getInt(startIndex + MILLISECOND_OFFSET);\n+\n+      final int hours = millis / (org.apache.arrow.vector.util.DateUtility.hoursToMillis);\n+      millis = millis % (org.apache.arrow.vector.util.DateUtility.hoursToMillis);\n+\n+      final int minutes = millis / (org.apache.arrow.vector.util.DateUtility.minutesToMillis);\n+      millis = millis % (org.apache.arrow.vector.util.DateUtility.minutesToMillis);\n+\n+      final int seconds = millis / (org.apache.arrow.vector.util.DateUtility.secondsToMillis);\n+      millis = millis % (org.apache.arrow.vector.util.DateUtility.secondsToMillis);\n+\n+      final String dayString = (Math.abs(days) == 1) ? \" day \" : \" days \";\n+\n+      return(new StringBuilder().\n+              append(days).append(dayString).\n+              append(hours).append(\":\").\n+              append(minutes).append(\":\").\n+              append(seconds).append(\".\").\n+              append(millis));\n+   }\n+\n+   /**\n+    * Copy a cell value from a particular index in source vector to a particular\n+    * position in this vector\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFrom(int fromIndex, int thisIndex, NullableIntervalDayVector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, thisIndex);\n+         from.valueBuffer.getBytes(fromIndex * TYPE_WIDTH, this.valueBuffer,\n+                 thisIndex * TYPE_WIDTH, TYPE_WIDTH);\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #copyFrom(int, int, NullableIntervalDayVector)} except that\n+    * it handles the case when the capacity of the vector needs to be expanded\n+    * before copy.\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableIntervalDayVector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, ArrowBuf value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      valueBuffer.setBytes(index * TYPE_WIDTH, value, 0, TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index          position of element\n+    * @param days           days for the interval\n+    * @param milliseconds   milliseconds for the interval\n+    */\n+   public void set(int index, int days, int milliseconds){\n+      final int offsetIndex = index * TYPE_WIDTH;\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      valueBuffer.setInt(offsetIndex, days);\n+      valueBuffer.setInt((offsetIndex + MILLISECOND_OFFSET), milliseconds);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableIntervalDayHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         set(index, holder.days, holder.milliseconds);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, IntervalDayHolder holder){\n+      set(index, holder.days, holder.milliseconds);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, ArrowBuf)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, ArrowBuf value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int, int)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index          position of element\n+    * @param days           days for the interval\n+    * @param milliseconds   milliseconds for the interval\n+    */\n+   public void setSafe(int index, int days, int milliseconds) {\n+      handleSafe(index);\n+      set(index, days, milliseconds);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableIntervalDayHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableIntervalDayHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, IntervalDayHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, IntervalDayHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   /**\n+    * Store the given value at a particular position in the vector. isSet indicates\n+    * whether the value is NULL or not.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param days days component of interval\n+    * @param milliseconds millisecond component of interval\n+    */\n+   public void set(int index, int isSet, int days, int milliseconds) {\n+      if (isSet > 0) {\n+         set(index, days, milliseconds);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int, int, int)} except that it handles the case\n+    * when index is greater than or equal to current value capacity of the\n+    * vector.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param days days component of interval\n+    * @param milliseconds millisecond component of interval\n+    */\n+   public void setSafe(int index, int isSet, int days, int milliseconds) {\n+      handleSafe(index);\n+      set(index, isSet, days, milliseconds);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableIntervalDayVector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableIntervalDayVector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableIntervalDayVector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableIntervalDayVector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableIntervalDayVector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableIntervalDayVector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableIntervalYearVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableIntervalYearVector.java\nnew file mode 100644\nindex 000000000..303286d0e\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableIntervalYearVector.java\n@@ -0,0 +1,387 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.IntervalYearReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.IntervalYearHolder;\n+import org.apache.arrow.vector.holders.NullableIntervalYearHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.joda.time.Period;\n+\n+/**\n+ * NullableIntervalYearVector implements a fixed width (4 bytes) vector of\n+ * interval (years and months) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableIntervalYearVector extends BaseNullableFixedWidthVector {\n+   private static final byte TYPE_WIDTH = 4;\n+   private final FieldReader reader;\n+\n+   /**\n+    * Instantiate a NullableIntervalYearVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableIntervalYearVector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.INTERVALYEAR.getType()),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableIntervalYearVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableIntervalYearVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+      reader = new IntervalYearReaderImpl(NullableIntervalYearVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.INTERVALYEAR;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public int get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return valueBuffer.getInt(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableIntervalYearHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getInt(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Period getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         final int interval = get(index);\n+         final int years  = (interval / org.apache.arrow.vector.util.DateUtility.yearsToMonths);\n+         final int months = (interval % org.apache.arrow.vector.util.DateUtility.yearsToMonths);\n+         final Period p = new Period();\n+         return p.plusYears(years).plusMonths(months);\n+      }\n+   }\n+\n+   /**\n+    * Get the Interval value at a given index as a {@link StringBuilder} object\n+    * @param index position of the element\n+    * @return String Builder object with Interval value as\n+    *         [years, months]\n+    */\n+   public StringBuilder getAsStringBuilder(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      }else{\n+         return getAsStringBuilderHelper(index);\n+      }\n+   }\n+\n+   private StringBuilder getAsStringBuilderHelper(int index) {\n+      int value  = valueBuffer.getInt(index * TYPE_WIDTH);\n+\n+      final int years  = (value / org.apache.arrow.vector.util.DateUtility.yearsToMonths);\n+      final int months = (value % org.apache.arrow.vector.util.DateUtility.yearsToMonths);\n+\n+      final String yearString = (Math.abs(years) == 1) ? \" year \" : \" years \";\n+      final String monthString = (Math.abs(months) == 1) ? \" month \" : \" months \";\n+\n+      return(new StringBuilder().\n+              append(years).append(yearString).\n+              append(months).append(monthString));\n+   }\n+\n+   /**\n+    * Copy a cell value from a particular index in source vector to a particular\n+    * position in this vector\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFrom(int fromIndex, int thisIndex, NullableIntervalYearVector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #copyFrom(int, int, NullableIntervalYearVector)} except that\n+    * it handles the case when the capacity of the vector needs to be expanded\n+    * before copy.\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableIntervalYearVector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   private void setValue(int index, int value) {\n+      valueBuffer.setInt(index * TYPE_WIDTH, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, int value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableIntervalYearHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, IntervalYearHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, int value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableIntervalYearHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableIntervalYearHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, IntervalYearHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, IntervalYearHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   /**\n+    * Store the given value at a particular position in the vector. isSet indicates\n+    * whether the value is NULL or not.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void set(int index, int isSet, int value) {\n+      if (isSet > 0) {\n+         set(index, value);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int, int)} except that it handles the case\n+    * when index is greater than or equal to current value capacity of the\n+    * vector.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void setSafe(int index, int isSet, int value) {\n+      handleSafe(index);\n+      set(index, isSet, value);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableIntervalYearVector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableIntervalYearVector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableIntervalYearVector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableIntervalYearVector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableIntervalYearVector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableIntervalYearVector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableSmallIntVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableSmallIntVector.java\nnew file mode 100644\nindex 000000000..c45a8d5f5\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableSmallIntVector.java\n@@ -0,0 +1,431 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.SmallIntReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.SmallIntHolder;\n+import org.apache.arrow.vector.holders.NullableSmallIntHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableSmallIntVector implements a fixed width (2 bytes) vector of\n+ * short values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableSmallIntVector extends BaseNullableFixedWidthVector {\n+   private static final byte TYPE_WIDTH = 2;\n+   private final FieldReader reader;\n+\n+   /**\n+    * Instantiate a NullableSmallIntVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableSmallIntVector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.SMALLINT.getType()),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableSmallIntVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableSmallIntVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+      reader = new SmallIntReaderImpl(NullableSmallIntVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.SMALLINT;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public short get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return valueBuffer.getShort(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableSmallIntHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getShort(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Short getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return get(index);\n+      }\n+   }\n+\n+   /**\n+    * Copy a cell value from a particular index in source vector to a particular\n+    * position in this vector\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFrom(int fromIndex, int thisIndex, NullableSmallIntVector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #copyFrom(int, int, NullableSmallIntVector)} except that\n+    * it handles the case when the capacity of the vector needs to be expanded\n+    * before copy.\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableSmallIntVector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   private void setValue(int index, int value) {\n+      valueBuffer.setShort(index * TYPE_WIDTH, value);\n+   }\n+\n+   private void setValue(int index, short value) {\n+      valueBuffer.setShort(index * TYPE_WIDTH, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, int value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, short value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableSmallIntHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, SmallIntHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, int value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, short)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, short value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableSmallIntHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableSmallIntHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, SmallIntHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, SmallIntHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   /**\n+    * Store the given value at a particular position in the vector. isSet indicates\n+    * whether the value is NULL or not.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void set(int index, int isSet, short value) {\n+      if (isSet > 0) {\n+         set(index, value);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int, short)} except that it handles the case\n+    * when index is greater than or equal to current value capacity of the\n+    * vector.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void setSafe(int index, int isSet, short value) {\n+      handleSafe(index);\n+      set(index, isSet, value);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          helper routines currently                             *\n+    *          used in JsonFileReader and JsonFileWriter             *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Given a data buffer, this method sets the element value at a particular\n+    * position. Reallocates the buffer if needed.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param allocator allocator\n+    * @param valueCount number of elements in the vector\n+    * @param index position of the new element\n+    * @param value element value\n+    * @return data buffer\n+    */\n+   public static ArrowBuf set(ArrowBuf buffer, BufferAllocator allocator,\n+                              int valueCount, int index, short value) {\n+      if (buffer == null) {\n+         buffer = allocator.buffer(valueCount * TYPE_WIDTH);\n+      }\n+      buffer.setShort(index * TYPE_WIDTH, value);\n+      if (index == (valueCount - 1)) {\n+         buffer.writerIndex(valueCount * TYPE_WIDTH);\n+      }\n+\n+      return buffer;\n+   }\n+\n+   /**\n+    * Given a data buffer, get the value stored at a particular position\n+    * in the vector.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param index position of the element.\n+    * @return value stored at the index.\n+    */\n+   public static short get(final ArrowBuf buffer, final int index) {\n+      return buffer.getShort(index * TYPE_WIDTH);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableSmallIntVector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableSmallIntVector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableSmallIntVector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableSmallIntVector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableSmallIntVector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableSmallIntVector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeMicroVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeMicroVector.java\nnew file mode 100644\nindex 000000000..454a4ac41\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeMicroVector.java\n@@ -0,0 +1,404 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeMicroReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeMicroHolder;\n+import org.apache.arrow.vector.holders.NullableTimeMicroHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.slf4j.Logger;\n+\n+/**\n+ * NullableTimeMicroVector implements a fixed width vector (8 bytes) of\n+ * time (microsecond resolution) values which could be null.\n+ * A validity buffer (bit vector) is maintained to track which elements in the\n+ * vector are null.\n+ */\n+public class NullableTimeMicroVector extends BaseNullableFixedWidthVector {\n+   private static final byte TYPE_WIDTH = 8;\n+   private final FieldReader reader;\n+\n+   /**\n+    * Instantiate a NullableTimeMicroVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeMicroVector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.TIMEMICRO.getType()),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableTimeMicroVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeMicroVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+      reader = new TimeMicroReaderImpl(NullableTimeMicroVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.TIMEMICRO;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public long get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return valueBuffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableTimeMicroHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Long getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return get(index);\n+      }\n+   }\n+\n+   /**\n+    * Copy a cell value from a particular index in source vector to a particular\n+    * position in this vector\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFrom(int fromIndex, int thisIndex, NullableTimeMicroVector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #copyFrom(int, int, NullableTimeMicroVector)} except that\n+    * it handles the case when the capacity of the vector needs to be expanded\n+    * before copy.\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableTimeMicroVector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   private void setValue(int index, long value) {\n+      valueBuffer.setLong(index * TYPE_WIDTH, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, long value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableTimeMicroHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, TimeMicroHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, long)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, long value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableTimeMicroHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableTimeMicroHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, TimeMicroHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, TimeMicroHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   /**\n+    * Store the given value at a particular position in the vector. isSet indicates\n+    * whether the value is NULL or not.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void set(int index, int isSet, long value) {\n+      if (isSet > 0) {\n+         set(index, value);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int, long)} except that it handles the case\n+    * when index is greater than or equal to current value capacity of the\n+    * vector.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void setSafe(int index, int isSet, long value) {\n+      handleSafe(index);\n+      set(index, isSet, value);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          helper routines currently                             *\n+    *          used in JsonFileReader and JsonFileWriter             *\n+    *                                                                *\n+    ******************************************************************/\n+\n+   /**\n+    * Given a data buffer, this method sets the element value at a particular\n+    * position. Reallocates the buffer if needed.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param allocator allocator\n+    * @param valueCount number of elements in the vector\n+    * @param index position of the new element\n+    * @param value element value\n+    * @return data buffer\n+    */\n+   public static ArrowBuf set(ArrowBuf buffer, BufferAllocator allocator,\n+                              int valueCount, int index, long value) {\n+      if (buffer == null) {\n+         buffer = allocator.buffer(valueCount * TYPE_WIDTH);\n+      }\n+      buffer.setLong(index * TYPE_WIDTH, value);\n+      if (index == (valueCount - 1)) {\n+         buffer.writerIndex(valueCount * TYPE_WIDTH);\n+      }\n+\n+      return buffer;\n+   }\n+\n+   /**\n+    * Given a data buffer, get the value stored at a particular position\n+    * in the vector.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param index position of the element.\n+    * @return value stored at the index.\n+    */\n+   public static long get(final ArrowBuf buffer, int index) {\n+      return buffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableTimeMicroVector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableTimeMicroVector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableTimeMicroVector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableTimeMicroVector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableTimeMicroVector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableTimeMicroVector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeMilliVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeMilliVector.java\nnew file mode 100644\nindex 000000000..8540d1692\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeMilliVector.java\n@@ -0,0 +1,405 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeMilliReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeMilliHolder;\n+import org.apache.arrow.vector.holders.NullableTimeMilliHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.joda.time.LocalDateTime;\n+import org.slf4j.Logger;\n+\n+/**\n+ * NullableTimeMilliVector implements a fixed width (4 bytes) vector of\n+ * time (millisecond resolution) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeMilliVector extends BaseNullableFixedWidthVector {\n+   private static final byte TYPE_WIDTH = 4;\n+   private final FieldReader reader;\n+\n+   /**\n+    * Instantiate a NullableTimeMilliVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeMilliVector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.TIMEMILLI.getType()),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableTimeMilliVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeMilliVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+      reader = new TimeMilliReaderImpl(NullableTimeMilliVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.TIMEMILLI;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public int get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return valueBuffer.getInt(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableTimeMilliHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getInt(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public LocalDateTime getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      }\n+      org.joda.time.LocalDateTime ldt = new org.joda.time.LocalDateTime(get(index),\n+              org.joda.time.DateTimeZone.UTC);\n+      return ldt;\n+   }\n+\n+   /**\n+    * Copy a cell value from a particular index in source vector to a particular\n+    * position in this vector\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFrom(int fromIndex, int thisIndex, NullableTimeMilliVector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #copyFrom(int, int, NullableTimeMilliVector)} except that\n+    * it handles the case when the capacity of the vector needs to be expanded\n+    * before copy.\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableTimeMilliVector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   private void setValue(int index, int value) {\n+      valueBuffer.setInt(index * TYPE_WIDTH, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, int value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableTimeMilliHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, TimeMilliHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, int value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableTimeMilliHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableTimeMilliHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, TimeMilliHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, TimeMilliHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   /**\n+    * Store the given value at a particular position in the vector. isSet indicates\n+    * whether the value is NULL or not.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void set(int index, int isSet, int value) {\n+      if (isSet > 0) {\n+         set(index, value);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int, int)} except that it handles the case\n+    * when index is greater than or equal to current value capacity of the\n+    * vector.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void setSafe(int index, int isSet, int value) {\n+      handleSafe(index);\n+      set(index, isSet, value);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          helper routines currently                             *\n+    *          used in JsonFileReader and JsonFileWriter             *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Given a data buffer, this method sets the element value at a particular\n+    * position. Reallocates the buffer if needed.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param allocator allocator\n+    * @param valueCount number of elements in the vector\n+    * @param index position of the new element\n+    * @param value element value\n+    * @return data buffer\n+    */\n+   public static ArrowBuf set(ArrowBuf buffer, BufferAllocator allocator,\n+                              int valueCount, int index, int value) {\n+      if (buffer == null) {\n+         buffer = allocator.buffer(valueCount * TYPE_WIDTH);\n+      }\n+      buffer.setInt(index * TYPE_WIDTH, value);\n+      if (index == (valueCount - 1)) {\n+         buffer.writerIndex(valueCount * TYPE_WIDTH);\n+      }\n+\n+      return buffer;\n+   }\n+\n+   /**\n+    * Given a data buffer, get the value stored at a particular position\n+    * in the vector.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param index position of the element.\n+    * @return value stored at the index.\n+    */\n+   public static int get(final ArrowBuf buffer, final int index) {\n+      return buffer.getInt(index * TYPE_WIDTH);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableTimeMilliVector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableTimeMilliVector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableTimeMilliVector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableTimeMilliVector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableTimeMilliVector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableTimeMilliVector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeNanoVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeNanoVector.java\nnew file mode 100644\nindex 000000000..015226da2\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeNanoVector.java\n@@ -0,0 +1,402 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeNanoReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeNanoHolder;\n+import org.apache.arrow.vector.holders.NullableTimeNanoHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableTimeNanoVector implements a fixed width vector (8 bytes) of\n+ * time (nanosecond resolution) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeNanoVector extends BaseNullableFixedWidthVector {\n+   private static final byte TYPE_WIDTH = 8;\n+   private final FieldReader reader;\n+\n+   /**\n+    * Instantiate a NullableTimeNanoVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeNanoVector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.TIMENANO.getType()),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableTimeNanoVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeNanoVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+      reader = new TimeNanoReaderImpl(NullableTimeNanoVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.TIMENANO;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public long get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return valueBuffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableTimeNanoHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Long getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return get(index);\n+      }\n+   }\n+\n+   /**\n+    * Copy a cell value from a particular index in source vector to a particular\n+    * position in this vector\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFrom(int fromIndex, int thisIndex, NullableTimeNanoVector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #copyFrom(int, int, NullableTimeNanoVector)} except that\n+    * it handles the case when the capacity of the vector needs to be expanded\n+    * before copy.\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableTimeNanoVector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   private void setValue(int index, long value) {\n+      valueBuffer.setLong(index * TYPE_WIDTH, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, long value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableTimeNanoHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, TimeNanoHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, long)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, long value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableTimeNanoHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableTimeNanoHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, TimeNanoHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, TimeNanoHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   /**\n+    * Store the given value at a particular position in the vector. isSet indicates\n+    * whether the value is NULL or not.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void set(int index, int isSet, long value) {\n+      if (isSet > 0) {\n+         set(index, value);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int, long)} except that it handles the case\n+    * when index is greater than or equal to current value capacity of the\n+    * vector.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void setSafe(int index, int isSet, long value) {\n+      handleSafe(index);\n+      set(index, isSet, value);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          helper routines currently                             *\n+    *          used in JsonFileReader and JsonFileWriter             *\n+    *                                                                *\n+    ******************************************************************/\n+\n+   /**\n+    * Given a data buffer, this method sets the element value at a particular\n+    * position. Reallocates the buffer if needed.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param allocator allocator\n+    * @param valueCount number of elements in the vector\n+    * @param index position of the new element\n+    * @param value element value\n+    * @return data buffer\n+    */\n+   public static ArrowBuf set(ArrowBuf buffer, BufferAllocator allocator,\n+                              int valueCount, int index, long value) {\n+      if (buffer == null) {\n+         buffer = allocator.buffer(valueCount * TYPE_WIDTH);\n+      }\n+      buffer.setLong(index * TYPE_WIDTH, value);\n+      if (index == (valueCount - 1)) {\n+         buffer.writerIndex(valueCount * TYPE_WIDTH);\n+      }\n+\n+      return buffer;\n+   }\n+\n+   /**\n+    * Given a data buffer, get the value stored at a particular position\n+    * in the vector.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param index position of the element.\n+    * @return value stored at the index.\n+    */\n+   public static long get(final ArrowBuf buffer,final int index) {\n+      return buffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableTimeNanoVector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableTimeNanoVector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableTimeNanoVector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableTimeNanoVector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableTimeNanoVector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableTimeNanoVector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeSecVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeSecVector.java\nnew file mode 100644\nindex 000000000..2b2375e92\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeSecVector.java\n@@ -0,0 +1,403 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeSecReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeSecHolder;\n+import org.apache.arrow.vector.holders.NullableTimeSecHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableTimeSecVector implements a fixed width (4 bytes) vector of\n+ * time (seconds resolution) values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeSecVector extends BaseNullableFixedWidthVector {\n+   private static final byte TYPE_WIDTH = 4;\n+   private final FieldReader reader;\n+\n+   /**\n+    * Instantiate a NullableTimeSecVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeSecVector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.TIMESEC.getType()),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableTimeSecVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeSecVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+      reader = new TimeSecReaderImpl(NullableTimeSecVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.TIMESEC;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public int get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return valueBuffer.getInt(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableTimeSecHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getInt(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Integer getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return get(index);\n+      }\n+   }\n+\n+   /**\n+    * Copy a cell value from a particular index in source vector to a particular\n+    * position in this vector\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFrom(int fromIndex, int thisIndex, NullableTimeSecVector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #copyFrom(int, int, NullableTimeSecVector)} except that\n+    * it handles the case when the capacity of the vector needs to be expanded\n+    * before copy.\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableTimeSecVector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   private void setValue(int index, int value) {\n+      valueBuffer.setInt(index * TYPE_WIDTH, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, int value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableTimeSecHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, TimeSecHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, int value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableTimeSecHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableTimeSecHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, TimeSecHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, TimeSecHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   /**\n+    * Store the given value at a particular position in the vector. isSet indicates\n+    * whether the value is NULL or not.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void set(int index, int isSet, int value) {\n+      if (isSet > 0) {\n+         set(index, value);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int, int)} except that it handles the case\n+    * when index is greater than or equal to current value capacity of the\n+    * vector.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void setSafe(int index, int isSet, int value) {\n+      handleSafe(index);\n+      set(index, isSet, value);\n+   }\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          helper routines currently                             *\n+    *          used in JsonFileReader and JsonFileWriter             *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Given a data buffer, this method sets the element value at a particular\n+    * position. Reallocates the buffer if needed.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param allocator allocator\n+    * @param valueCount number of elements in the vector\n+    * @param index position of the new element\n+    * @param value element value\n+    * @return data buffer\n+    */\n+   public static ArrowBuf set(ArrowBuf buffer, BufferAllocator allocator,\n+                              int valueCount, int index, int value) {\n+      if (buffer == null) {\n+         buffer = allocator.buffer(valueCount * TYPE_WIDTH);\n+      }\n+      buffer.setInt(index * TYPE_WIDTH, value);\n+      if (index == (valueCount - 1)) {\n+         buffer.writerIndex(valueCount * TYPE_WIDTH);\n+      }\n+\n+      return buffer;\n+   }\n+\n+   /**\n+    * Given a data buffer, get the value stored at a particular position\n+    * in the vector.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param index position of the element.\n+    * @return value stored at the index.\n+    */\n+   public static int get(final ArrowBuf buffer, final int index) {\n+      return buffer.getInt(index * TYPE_WIDTH);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableTimeSecVector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableTimeSecVector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableTimeSecVector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableTimeSecVector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableTimeSecVector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableTimeSecVector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMicroTZVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMicroTZVector.java\nnew file mode 100644\nindex 000000000..0d25eff4e\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMicroTZVector.java\n@@ -0,0 +1,219 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeStampMicroTZReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeStampMicroTZHolder;\n+import org.apache.arrow.vector.holders.NullableTimeStampMicroTZHolder;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableTimeStampMicroTZVector implements a fixed width vector (8 bytes) of\n+ * timestamp (microsecond resolution) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeStampMicroTZVector extends NullableTimeStampVector {\n+   private final FieldReader reader;\n+   private final String timeZone;\n+\n+   /**\n+    * Instantiate a NullableTimeStampMicroTZVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeStampMicroTZVector(String name, BufferAllocator allocator, String timeZone) {\n+      this(name, FieldType.nullable(new org.apache.arrow.vector.types.pojo.ArrowType.Timestamp(TimeUnit.MICROSECOND, timeZone)),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableTimeStampMicroTZVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeStampMicroTZVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, fieldType, allocator);\n+      org.apache.arrow.vector.types.pojo.ArrowType.Timestamp arrowType = (org.apache.arrow.vector.types.pojo.ArrowType.Timestamp)fieldType.getType();\n+      timeZone = arrowType.getTimezone();\n+      reader = new TimeStampMicroTZReaderImpl(NullableTimeStampMicroTZVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.TIMESTAMPMICROTZ;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableTimeStampMicroTZHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Long getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return get(index);\n+      }\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableTimeStampMicroTZHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, TimeStampMicroTZHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableTimeStampMicroTZHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableTimeStampMicroTZHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, TimeStampMicroTZHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, TimeStampMicroTZHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+      NullableTimeStampMicroTZVector to = new NullableTimeStampMicroTZVector(ref,\n+              field.getFieldType(), allocator);\n+      return new TransferImpl(to);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableTimeStampMicroTZVector)to);\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMicroVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMicroVector.java\nnew file mode 100644\nindex 000000000..41f7a1112\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMicroVector.java\n@@ -0,0 +1,220 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeStampMicroReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeStampMicroHolder;\n+import org.apache.arrow.vector.holders.NullableTimeStampMicroHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.joda.time.LocalDateTime;\n+\n+/**\n+ * NullableTimeStampMicroVector implements a fixed width vector (8 bytes) of\n+ * timestamp (microsecond resolution) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeStampMicroVector extends NullableTimeStampVector {\n+   private final FieldReader reader;\n+\n+   /**\n+    * Instantiate a NullableTimeStampMicroVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeStampMicroVector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.TIMESTAMPMICRO.getType()),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableTimeStampMicroVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeStampMicroVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, fieldType, allocator);\n+      reader = new TimeStampMicroReaderImpl(NullableTimeStampMicroVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.TIMESTAMPMICRO;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableTimeStampMicroHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public LocalDateTime getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         /* value is truncated when converting microseconds to milliseconds in order to use DateTime type */\n+         final long micros = get(index);\n+         final long millis = java.util.concurrent.TimeUnit.MICROSECONDS.toMillis(micros);\n+         final org.joda.time.LocalDateTime localDateTime = new org.joda.time.LocalDateTime(millis, org.joda.time.DateTimeZone.UTC);\n+         return localDateTime;\n+      }\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableTimeStampMicroHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, TimeStampMicroHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableTimeStampMicroHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableTimeStampMicroHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, TimeStampMicroHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, TimeStampMicroHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+      NullableTimeStampMicroVector to = new NullableTimeStampMicroVector(ref,\n+              field.getFieldType(), allocator);\n+      return new TransferImpl(to);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableTimeStampMicroVector )to);\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMilliTZVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMilliTZVector.java\nnew file mode 100644\nindex 000000000..6376b085e\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMilliTZVector.java\n@@ -0,0 +1,218 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeStampMilliTZReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeStampMilliTZHolder;\n+import org.apache.arrow.vector.holders.NullableTimeStampMilliTZHolder;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableTimeStampMilliTZVector implements a fixed width vector (8 bytes) of\n+ * timestamp (millisecond resolution) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeStampMilliTZVector extends NullableTimeStampVector {\n+   private final FieldReader reader;\n+   private final String timeZone;\n+\n+   /**\n+    * Instantiate a NullableTimeStampMilliTZVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeStampMilliTZVector(String name, BufferAllocator allocator, String timeZone) {\n+      this(name, FieldType.nullable(new org.apache.arrow.vector.types.pojo.ArrowType.Timestamp(TimeUnit.MILLISECOND, timeZone)),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableTimeStampMilliTZVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeStampMilliTZVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, fieldType, allocator);\n+      org.apache.arrow.vector.types.pojo.ArrowType.Timestamp arrowType = (org.apache.arrow.vector.types.pojo.ArrowType.Timestamp)fieldType.getType();\n+      timeZone = arrowType.getTimezone();\n+      reader = new TimeStampMilliTZReaderImpl(NullableTimeStampMilliTZVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.TIMESTAMPMILLITZ;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableTimeStampMilliTZHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Long getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return get(index);\n+      }\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableTimeStampMilliTZHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, TimeStampMilliTZHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableTimeStampMilliTZHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableTimeStampMilliTZHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, TimeStampMilliTZHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, TimeStampMilliTZHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+      NullableTimeStampMilliTZVector to = new NullableTimeStampMilliTZVector(ref,\n+              field.getFieldType(), allocator);\n+      return new TransferImpl(to);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableTimeStampMilliTZVector)to);\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMilliVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMilliVector.java\nnew file mode 100644\nindex 000000000..ff581d2ea\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMilliVector.java\n@@ -0,0 +1,218 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeStampMilliReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeStampMilliHolder;\n+import org.apache.arrow.vector.holders.NullableTimeStampMilliHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.joda.time.LocalDateTime;\n+\n+/**\n+ * NullableTimeStampMilliVector implements a fixed width vector (8 bytes) of\n+ * timestamp (millisecond resolution) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeStampMilliVector extends NullableTimeStampVector {\n+   private final FieldReader reader;\n+\n+   /**\n+    * Instantiate a NullableTimeStampMilliVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeStampMilliVector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.TIMESTAMPMILLI.getType()),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableTimeStampMilliVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeStampMilliVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, fieldType, allocator);\n+      reader = new TimeStampMilliReaderImpl(NullableTimeStampMilliVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.TIMESTAMPMILLI;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableTimeStampMilliHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public LocalDateTime getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         final long millis = get(index);\n+         final org.joda.time.LocalDateTime localDateTime = new org.joda.time.LocalDateTime(millis, org.joda.time.DateTimeZone.UTC);\n+         return localDateTime;\n+      }\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableTimeStampMilliHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, TimeStampMilliHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableTimeStampMilliHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableTimeStampMilliHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, TimeStampMilliHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, TimeStampMilliHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+      NullableTimeStampMilliVector to = new NullableTimeStampMilliVector(ref,\n+              field.getFieldType(), allocator);\n+      return new TransferImpl(to);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableTimeStampMilliVector)to);\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampNanoTZVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampNanoTZVector.java\nnew file mode 100644\nindex 000000000..6c4445d50\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampNanoTZVector.java\n@@ -0,0 +1,219 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeStampNanoTZReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeStampNanoTZHolder;\n+import org.apache.arrow.vector.holders.NullableTimeStampNanoTZHolder;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableTimeStampNanoTZVector implements a fixed width vector (8 bytes) of\n+ * timestamp (nanosecond resolution) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeStampNanoTZVector extends NullableTimeStampVector {\n+   private final FieldReader reader;\n+   private final String timeZone;\n+\n+   /**\n+    * Instantiate a NullableTimeStampNanoTZVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeStampNanoTZVector(String name, BufferAllocator allocator, String timeZone) {\n+      this(name, FieldType.nullable(new org.apache.arrow.vector.types.pojo.ArrowType.Timestamp(TimeUnit.NANOSECOND, timeZone)),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableTimeStampNanoTZVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeStampNanoTZVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, fieldType, allocator);\n+      org.apache.arrow.vector.types.pojo.ArrowType.Timestamp arrowType = (org.apache.arrow.vector.types.pojo.ArrowType.Timestamp)fieldType.getType();\n+      timeZone = arrowType.getTimezone();\n+      reader = new TimeStampNanoTZReaderImpl(NullableTimeStampNanoTZVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.TIMESTAMPNANOTZ;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableTimeStampNanoTZHolder holder) {\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Long getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return get(index);\n+      }\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableTimeStampNanoTZHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, TimeStampNanoTZHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableTimeStampNanoTZHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableTimeStampNanoTZHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, TimeStampNanoTZHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, TimeStampNanoTZHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+      NullableTimeStampNanoTZVector to = new NullableTimeStampNanoTZVector(ref,\n+              field.getFieldType(), allocator);\n+      return new TransferImpl(to);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableTimeStampNanoTZVector)to);\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampNanoVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampNanoVector.java\nnew file mode 100644\nindex 000000000..096913ebf\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampNanoVector.java\n@@ -0,0 +1,219 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeStampNanoReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeStampNanoHolder;\n+import org.apache.arrow.vector.holders.NullableTimeStampNanoHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.joda.time.LocalDateTime;\n+\n+/**\n+ * NullableTimeStampNanoVector implements a fixed width vector (8 bytes) of\n+ * timestamp (nanosecond resolution) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeStampNanoVector extends NullableTimeStampVector {\n+   private final FieldReader reader;\n+\n+   /**\n+    * Instantiate a NullableTimeStampNanoVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeStampNanoVector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.TIMESTAMPNANO.getType()),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableTimeStampNanoVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeStampNanoVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, fieldType, allocator);\n+      reader = new TimeStampNanoReaderImpl(NullableTimeStampNanoVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.TIMESTAMPNANO;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableTimeStampNanoHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public LocalDateTime getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         final long nanos = get(index);\n+         final long millis = java.util.concurrent.TimeUnit.NANOSECONDS.toMillis(nanos);\n+         final org.joda.time.LocalDateTime localDateTime = new org.joda.time.LocalDateTime(millis, org.joda.time.DateTimeZone.UTC);\n+         return localDateTime;\n+      }\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableTimeStampNanoHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, TimeStampNanoHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableTimeStampNanoHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableTimeStampNanoHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, TimeStampNanoHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, TimeStampNanoHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+      NullableTimeStampNanoVector to = new NullableTimeStampNanoVector(ref,\n+              field.getFieldType(), allocator);\n+      return new TransferImpl(to);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableTimeStampNanoVector)to);\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampSecTZVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampSecTZVector.java\nnew file mode 100644\nindex 000000000..8e5ba72ae\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampSecTZVector.java\n@@ -0,0 +1,217 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeStampSecTZReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeStampSecTZHolder;\n+import org.apache.arrow.vector.holders.NullableTimeStampSecTZHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableTimeStampSecTZVector implements a fixed width vector (8 bytes) of\n+ * timestamp (seconds resolution) values which could be null. A validity buffer\n+ * (bit vector) is maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeStampSecTZVector extends NullableTimeStampVector {\n+   private final FieldReader reader;\n+   private final String timeZone;\n+\n+   /**\n+    * Instantiate a NullableTimeStampSecTZVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeStampSecTZVector(String name, BufferAllocator allocator, String timeZone) {\n+      this(name, FieldType.nullable(new org.apache.arrow.vector.types.pojo.ArrowType.Timestamp(org.apache.arrow.vector.types.TimeUnit.SECOND, timeZone)),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableTimeStampSecTZVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeStampSecTZVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, fieldType, allocator);\n+      org.apache.arrow.vector.types.pojo.ArrowType.Timestamp arrowType = (org.apache.arrow.vector.types.pojo.ArrowType.Timestamp)fieldType.getType();\n+      timeZone = arrowType.getTimezone();\n+      reader = new TimeStampSecTZReaderImpl(NullableTimeStampSecTZVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.TIMESTAMPSECTZ;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableTimeStampSecTZHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Long getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return get(index);\n+      }\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableTimeStampSecTZHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, TimeStampSecTZHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableTimeStampSecTZHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableTimeStampSecTZHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, TimeStampSecTZHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, TimeStampSecTZHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+      NullableTimeStampSecTZVector to = new NullableTimeStampSecTZVector(ref,\n+              field.getFieldType(), allocator);\n+      return new TransferImpl(to);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableTimeStampSecTZVector)to);\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampSecVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampSecVector.java\nnew file mode 100644\nindex 000000000..bc800e0e4\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampSecVector.java\n@@ -0,0 +1,219 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TimeStampSecReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TimeStampSecHolder;\n+import org.apache.arrow.vector.holders.NullableTimeStampSecHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.joda.time.LocalDateTime;\n+\n+/**\n+ * NullableTimeStampSecVector implements a fixed width vector (8 bytes) of\n+ * timestamp (seconds resolution) values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableTimeStampSecVector extends NullableTimeStampVector {\n+   private final FieldReader reader;\n+\n+   /**\n+    * Instantiate a NullableTimeStampSecVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeStampSecVector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.TIMESTAMPSEC.getType()),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableTimeStampSecVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeStampSecVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, fieldType, allocator);\n+      reader = new TimeStampSecReaderImpl(NullableTimeStampSecVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader() {\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.TIMESTAMPSEC;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableTimeStampSecHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public LocalDateTime getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         final long secs = get(index);\n+         final long millis = java.util.concurrent.TimeUnit.SECONDS.toMillis(secs);\n+         final org.joda.time.LocalDateTime localDateTime = new org.joda.time.LocalDateTime(millis, org.joda.time.DateTimeZone.UTC);\n+         return localDateTime;\n+      }\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableTimeStampSecHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, TimeStampSecHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableTimeStampSecHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableTimeStampSecHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, TimeStampSecHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, TimeStampSecHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+      NullableTimeStampSecVector to = new NullableTimeStampSecVector(ref,\n+              field.getFieldType(), allocator);\n+      return new TransferImpl(to);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableTimeStampSecVector)to);\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampVector.java\nnew file mode 100644\nindex 000000000..b2a58bd45\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampVector.java\n@@ -0,0 +1,253 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableTimeStampVector is an abstract interface for fixed width vector (8 bytes)\n+ * of timestamp values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public abstract class NullableTimeStampVector extends BaseNullableFixedWidthVector {\n+   protected static final byte TYPE_WIDTH = 8;\n+\n+   /**\n+    * Instantiate a NullableTimeStampVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTimeStampVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public long get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return valueBuffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Copy a cell value from a particular index in source vector to a particular\n+    * position in this vector\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFrom(int fromIndex, int thisIndex, NullableTimeStampVector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #copyFromSafe(int, int, NullableTimeStampVector)} except that\n+    * it handles the case when the capacity of the vector needs to be expanded\n+    * before copy.\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableTimeStampVector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   protected void setValue(int index, long value) {\n+      valueBuffer.setLong(index * TYPE_WIDTH, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, long value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, long)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, long value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   /**\n+    * Store the given value at a particular position in the vector. isSet indicates\n+    * whether the value is NULL or not.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void set(int index, int isSet, long value) {\n+      if (isSet > 0) {\n+         set(index, value);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int, long)} except that it handles the case\n+    * when index is greater than or equal to current value capacity of the\n+    * vector.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void setSafe(int index, int isSet, long value) {\n+      handleSafe(index);\n+      set(index, isSet, value);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          helper routines currently                             *\n+    *          used in JsonFileReader and                            *\n+    *          JsonFileWriter                                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Given a data buffer, this method sets the element value at a particular\n+    * position. Reallocates the buffer if needed.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param allocator allocator\n+    * @param valueCount number of elements in the vector\n+    * @param index position of the new element\n+    * @param value element value\n+    * @return data buffer\n+    */\n+   public static ArrowBuf set(ArrowBuf buffer, BufferAllocator allocator,\n+                              int valueCount, int index, long value) {\n+      if (buffer == null) {\n+         buffer = allocator.buffer(valueCount * TYPE_WIDTH);\n+      }\n+      buffer.setLong(index * TYPE_WIDTH, value);\n+      if (index == (valueCount - 1)) {\n+         buffer.writerIndex(valueCount * TYPE_WIDTH);\n+      }\n+\n+      return buffer;\n+   }\n+\n+   /**\n+    * Given a data buffer, get the value stored at a particular position\n+    * in the vector.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param index position of the element.\n+    * @return value stored at the index.\n+    */\n+   public static long get(final ArrowBuf buffer, final int index) {\n+      return buffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   public class TransferImpl implements TransferPair {\n+      NullableTimeStampVector to;\n+\n+      public TransferImpl(NullableTimeStampVector to) {\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableTimeStampVector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer() {\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableTimeStampVector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTinyIntVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableTinyIntVector.java\nnew file mode 100644\nindex 000000000..15100530d\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableTinyIntVector.java\n@@ -0,0 +1,432 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.TinyIntReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.TinyIntHolder;\n+import org.apache.arrow.vector.holders.NullableTinyIntHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableTinyIntVector implements a fixed width (1 bytes) vector of\n+ * byte values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableTinyIntVector extends BaseNullableFixedWidthVector {\n+   public static final byte TYPE_WIDTH = 1;\n+   private final FieldReader reader;\n+\n+   /**\n+    * Instantiate a NullableTinyIntVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTinyIntVector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.TINYINT.getType()),\n+              allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableTinyIntVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableTinyIntVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+      reader = new TinyIntReaderImpl(NullableTinyIntVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.TINYINT;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public byte get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return valueBuffer.getByte(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableTinyIntHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getByte(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Byte getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return get(index);\n+      }\n+   }\n+\n+   /**\n+    * Copy a cell value from a particular index in source vector to a particular\n+    * position in this vector\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFrom(int fromIndex, int thisIndex, NullableTinyIntVector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #copyFrom(int, int, NullableTinyIntVector)} except that\n+    * it handles the case when the capacity of the vector needs to be expanded\n+    * before copy.\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableTinyIntVector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+   private void setValue(int index, int value) {\n+      valueBuffer.setByte(index * TYPE_WIDTH, value);\n+   }\n+\n+   private void setValue(int index, byte value) {\n+      valueBuffer.setByte(index * TYPE_WIDTH, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, int value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, byte value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableTinyIntHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, TinyIntHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, int value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, byte)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, byte value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableTinyIntHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableTinyIntHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, TinyIntHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, TinyIntHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   /**\n+    * Store the given value at a particular position in the vector. isSet indicates\n+    * whether the value is NULL or not.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void set(int index, int isSet, byte value) {\n+      if (isSet > 0) {\n+         set(index, value);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int, byte)} except that it handles the case\n+    * when index is greater than or equal to current value capacity of the\n+    * vector.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param value element value\n+    */\n+   public void setSafe(int index, int isSet, byte value) {\n+      handleSafe(index);\n+      set(index, isSet, value);\n+   }\n+\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          helper routines currently                             *\n+    *          used in JsonFileReader and JsonFileWriter             *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Given a data buffer, this method sets the element value at a particular\n+    * position. Reallocates the buffer if needed.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param allocator allocator\n+    * @param valueCount number of elements in the vector\n+    * @param index position of the new element\n+    * @param value element value\n+    * @return data buffer\n+    */\n+   public static ArrowBuf set(ArrowBuf buffer, BufferAllocator allocator,\n+                              int valueCount, int index, byte value) {\n+      if (buffer == null) {\n+         buffer = allocator.buffer(valueCount * TYPE_WIDTH);\n+      }\n+      buffer.setByte(index * TYPE_WIDTH, value);\n+      if (index == (valueCount - 1)) {\n+         buffer.writerIndex(valueCount * TYPE_WIDTH);\n+      }\n+\n+      return buffer;\n+   }\n+\n+   /**\n+    * Given a data buffer, get the value stored at a particular position\n+    * in the vector.\n+    *\n+    * This method should not be used externally.\n+    *\n+    * @param buffer data buffer\n+    * @param index position of the element.\n+    * @return value stored at the index.\n+    */\n+   public static byte get(final ArrowBuf buffer, final int index) {\n+      return buffer.getByte(index * TYPE_WIDTH);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableTinyIntVector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableTinyIntVector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableTinyIntVector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableTinyIntVector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableTinyIntVector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableTinyIntVector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt1Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt1Vector.java\nnew file mode 100644\nindex 000000000..4d20f800b\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt1Vector.java\n@@ -0,0 +1,318 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.UInt1ReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.UInt1Holder;\n+import org.apache.arrow.vector.holders.NullableUInt1Holder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * NullableUInt1Vector implements a fixed width (1 bytes) vector of\n+ * integer values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableUInt1Vector extends BaseNullableFixedWidthVector {\n+   private static final byte TYPE_WIDTH = 1;\n+   private final FieldReader reader;\n+\n+   public NullableUInt1Vector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.UINT1.getType()),\n+              allocator);\n+   }\n+\n+   public NullableUInt1Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+      reader = new UInt1ReaderImpl(NullableUInt1Vector.this);\n+   }\n+\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.UINT1;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public byte get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return valueBuffer.getByte(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableUInt1Holder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getByte(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Byte getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return get(index);\n+      }\n+   }\n+\n+   public void copyFrom(int fromIndex, int thisIndex, NullableUInt1Vector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+      }\n+   }\n+\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableUInt1Vector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   private void setValue(int index, int value) {\n+      valueBuffer.setByte(index * TYPE_WIDTH, value);\n+   }\n+\n+   private void setValue(int index, byte value) {\n+      valueBuffer.setByte(index * TYPE_WIDTH, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, int value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, byte value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableUInt1Holder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, UInt1Holder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, int value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, byte)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, byte value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableUInt1Holder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableUInt1Holder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, UInt1Holder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, UInt1Holder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   public void set(int index, int isSet, byte value) {\n+      if (isSet > 0) {\n+         set(index, value);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   public void setSafe(int index, int isSet, byte value) {\n+      handleSafe(index);\n+      set(index, isSet, value);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableUInt1Vector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableUInt1Vector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableUInt1Vector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableUInt1Vector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableUInt1Vector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableUInt1Vector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt2Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt2Vector.java\nnew file mode 100644\nindex 000000000..b140b9f5c\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt2Vector.java\n@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.UInt2ReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.UInt2Holder;\n+import org.apache.arrow.vector.holders.NullableUInt2Holder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.slf4j.Logger;\n+\n+/**\n+ * NullableUInt2Vector implements a fixed width (2 bytes) vector of\n+ * integer values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableUInt2Vector extends BaseNullableFixedWidthVector {\n+   private static final byte TYPE_WIDTH = 2;\n+   private final FieldReader reader;\n+\n+   public NullableUInt2Vector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.UINT2.getType()),\n+              allocator);\n+   }\n+\n+   public NullableUInt2Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+      reader = new UInt2ReaderImpl(NullableUInt2Vector.this);\n+   }\n+\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.UINT2;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public char get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return valueBuffer.getChar(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableUInt2Holder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getChar(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Character getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return get(index);\n+      }\n+   }\n+\n+   public void copyFrom(int fromIndex, int thisIndex, NullableUInt2Vector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+      }\n+   }\n+\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableUInt2Vector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   private void setValue(int index, int value) {\n+      valueBuffer.setChar(index * TYPE_WIDTH, value);\n+   }\n+\n+   private void setValue(int index, char value) {\n+      valueBuffer.setChar(index * TYPE_WIDTH, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, int value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, char value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableUInt2Holder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, UInt2Holder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, int value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, char)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, char value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableUInt2Holder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableUInt2Holder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, UInt2Holder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, UInt2Holder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   public void set(int index, int isSet, char value) {\n+      if (isSet > 0) {\n+         set(index, value);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   public void setSafe(int index, int isSet, char value) {\n+      handleSafe(index);\n+      set(index, isSet, value);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableUInt2Vector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableUInt2Vector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableUInt2Vector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableUInt2Vector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableUInt2Vector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableUInt2Vector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt4Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt4Vector.java\nnew file mode 100644\nindex 000000000..fc8cb6395\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt4Vector.java\n@@ -0,0 +1,291 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.UInt4ReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.UInt4Holder;\n+import org.apache.arrow.vector.holders.NullableUInt4Holder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.slf4j.Logger;\n+\n+/**\n+ * NullableUInt4Vector implements a fixed width (4 bytes) vector of\n+ * integer values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableUInt4Vector extends BaseNullableFixedWidthVector {\n+   private static final byte TYPE_WIDTH = 4;\n+   private final FieldReader reader;\n+\n+   public NullableUInt4Vector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.UINT4.getType()),\n+              allocator);\n+   }\n+\n+   public NullableUInt4Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+      reader = new UInt4ReaderImpl(NullableUInt4Vector.this);\n+   }\n+\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.UINT4;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public int get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return valueBuffer.getInt(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableUInt4Holder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getInt(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Integer getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return get(index);\n+      }\n+   }\n+\n+   public void copyFrom(int fromIndex, int thisIndex, NullableUInt4Vector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+      }\n+   }\n+\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableUInt4Vector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   private void setValue(int index, int value) {\n+      valueBuffer.setInt(index * TYPE_WIDTH, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, int value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableUInt4Holder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, UInt4Holder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, int value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableUInt4Holder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableUInt4Holder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, UInt4Holder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, UInt4Holder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   public void set(int index, int isSet, int value) {\n+      if (isSet > 0) {\n+         set(index, value);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   public void setSafe(int index, int isSet, int value) {\n+      handleSafe(index);\n+      set(index, isSet, value);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableUInt4Vector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableUInt4Vector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableUInt4Vector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableUInt4Vector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableUInt4Vector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableUInt4Vector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt8Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt8Vector.java\nnew file mode 100644\nindex 000000000..2110cf03b\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt8Vector.java\n@@ -0,0 +1,291 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.UInt8ReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.UInt8Holder;\n+import org.apache.arrow.vector.holders.NullableUInt8Holder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.slf4j.Logger;\n+\n+/**\n+ * NullableUInt8Vector implements a fixed width vector (8 bytes) of\n+ * integer values which could be null. A validity buffer (bit vector) is\n+ * maintained to track which elements in the vector are null.\n+ */\n+public class NullableUInt8Vector extends BaseNullableFixedWidthVector {\n+   private static final byte TYPE_WIDTH = 8;\n+   private final FieldReader reader;\n+\n+   public NullableUInt8Vector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.UINT8.getType()),\n+              allocator);\n+   }\n+\n+   public NullableUInt8Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+      reader = new UInt8ReaderImpl(NullableUInt8Vector.this);\n+   }\n+\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.UINT8;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public long get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return valueBuffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableUInt8Holder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getLong(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Long getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return get(index);\n+      }\n+   }\n+\n+   public void copyFrom(int fromIndex, int thisIndex, NullableUInt8Vector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+      }\n+   }\n+\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableUInt8Vector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   private void setValue(int index, long value) {\n+      valueBuffer.setLong(index * TYPE_WIDTH, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, long value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableUInt8Holder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, UInt8Holder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, long)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, long value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableUInt8Holder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableUInt8Holder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, UInt8Holder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, UInt8Holder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   public void set(int index, int isSet, long value) {\n+      if (isSet > 0) {\n+         set(index, value);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   public void setSafe(int index, int isSet, long value) {\n+      handleSafe(index);\n+      set(index, isSet, value);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableUInt8Vector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableUInt8Vector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableUInt8Vector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableUInt8Vector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableUInt8Vector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableUInt8Vector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableVarBinaryVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableVarBinaryVector.java\nnew file mode 100644\nindex 000000000..330e06710\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableVarBinaryVector.java\n@@ -0,0 +1,514 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.VarBinaryReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.VarBinaryHolder;\n+import org.apache.arrow.vector.holders.NullableVarBinaryHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * NullableVarBinaryVector implements a variable width vector of binary\n+ * values which could be NULL. A validity buffer (bit vector) is maintained\n+ * to track which elements in the vector are null.\n+ */\n+public class NullableVarBinaryVector extends BaseNullableVariableWidthVector {\n+   private final FieldReader reader;\n+\n+   /**\n+    * Instantiate a NullableVarBinaryVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableVarBinaryVector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(Types.MinorType.VARBINARY.getType()), allocator);\n+   }\n+\n+   /**\n+    * Instantiate a NullableVarBinaryVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n+   public NullableVarBinaryVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType);\n+      reader = new VarBinaryReaderImpl(NullableVarBinaryVector.this);\n+   }\n+\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.VARBINARY;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value getter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the variable length element at specified index as byte array.\n+    *\n+    * @param index   position of element to get\n+    * @return array of bytes for non-null element, null otherwise\n+    */\n+   public byte[] get(int index) {\n+      assert index >= 0;\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      final int startOffset = getstartOffset(index);\n+      final int dataLength =\n+              offsetBuffer.getInt((index + 1) * OFFSET_WIDTH) - startOffset;\n+      final byte[] result = new byte[dataLength];\n+      valueBuffer.getBytes(startOffset, result, 0, dataLength);\n+      return result;\n+   }\n+\n+   /**\n+    * Get the variable length element at specified index as Text.\n+    *\n+    * @param index   position of element to get\n+    * @return byte array for non-null element, null otherwise\n+    */\n+   public byte[] getObject(int index) {\n+      byte[] b;\n+      try {\n+         b = get(index);\n+      } catch (IllegalStateException e) {\n+         return null;\n+      }\n+      return b;\n+   }\n+\n+   /**\n+    * Get the variable length element at specified index as Text.\n+    *\n+    * @param index   position of element to get\n+    * @return greater than 0 length for non-null element, 0 otherwise\n+    */\n+   public int getValueLength(int index) {\n+      assert index >= 0;\n+      if(isSet(index) == 0) {\n+         return 0;\n+      }\n+      final int startOffset = getstartOffset(index);\n+      final int dataLength =\n+              offsetBuffer.getInt((index + 1) * OFFSET_WIDTH) - startOffset;\n+      return dataLength;\n+   }\n+\n+   /**\n+    * Get the variable length element at specified index and sets the state\n+    * in provided holder.\n+    *\n+    * @param index   position of element to get\n+    * @param holder  data holder to be populated by this function\n+    */\n+   public void get(int index, NullableVarBinaryHolder holder){\n+      assert index >= 0;\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      final int startOffset = getstartOffset(index);\n+      final int dataLength =\n+              offsetBuffer.getInt((index + 1) * OFFSET_WIDTH) - startOffset;\n+      holder.isSet = 1;\n+      holder.start = startOffset;\n+      holder.end = dataLength;\n+      holder.buffer = valueBuffer;\n+   }\n+\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Copy a cell value from a particular index in source vector to a particular\n+    * position in this vector\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFrom(int fromIndex, int thisIndex, NullableVarBinaryVector from) {\n+      fillHoles(thisIndex);\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+         lastSet = thisIndex;\n+      }\n+   }\n+\n+   /**\n+    * Same as {@link #copyFrom(int, int, NullableVarBinaryVector)} except that\n+    * it handles the case when the capacity of the vector needs to be expanded\n+    * before copy.\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableVarBinaryVector from) {\n+      fillEmpties(thisIndex);\n+      if (from.isSet(fromIndex) != 0) {\n+         setSafe(thisIndex, from.get(fromIndex));\n+         lastSet = thisIndex;\n+      }\n+   }\n+\n+\n+   /**\n+    * Set the variable length element at the specified index to the supplied\n+    * byte array. This is same as using {@link #set(int, byte[], int, int)}\n+    * with start as 0 and length as value.length\n+    *\n+    * @param index   position of the element to set\n+    * @param value   array of bytes to write\n+    */\n+   public void set(int index, byte[] value) {\n+      assert index >= 0;\n+      fillHoles(index);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setBytes(index, value, 0, value.length);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, byte[])} except that it handles the\n+    * case where index and length of new element are beyond the existing\n+    * capacity of the vector.\n+    *\n+    * @param index   position of the element to set\n+    * @param value   array of bytes to write\n+    */\n+   public void setSafe(int index, byte[] value) {\n+      assert index >= 0;\n+      fillEmpties(index);\n+      handleSafe(index, value.length);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setBytes(index, value, 0, value.length);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Set the variable length element at the specified index to the supplied\n+    * byte array.\n+    *\n+    * @param index   position of the element to set\n+    * @param value   array of bytes to write\n+    * @param start   start index in array of bytes\n+    * @param length  length of data in array of bytes\n+    */\n+   public void set(int index, byte[] value, int start, int length) {\n+      assert index >= 0;\n+      fillHoles(index);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setBytes(index, value, start, length);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, byte[], int, int)} except that it handles the\n+    * case where index and length of new element are beyond the existing\n+    * capacity of the vector.\n+    *\n+    * @param index   position of the element to set\n+    * @param value   array of bytes to write\n+    * @param start   start index in array of bytes\n+    * @param length  length of data in array of bytes\n+    */\n+   public void setSafe(int index, byte[] value, int start, int length) {\n+      assert index >= 0;\n+      fillEmpties(index);\n+      handleSafe(index, length);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setBytes(index, value, start, length);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Set the variable length element at the specified index to the\n+    * content in supplied ByteBuffer\n+    *\n+    * @param index   position of the element to set\n+    * @param value   ByteBuffer with data\n+    * @param start   start index in ByteBuffer\n+    * @param length  length of data in ByteBuffer\n+    */\n+   public void set(int index, ByteBuffer value, int start, int length) {\n+      assert index >= 0;\n+      fillHoles(index);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      final int startOffset = getstartOffset(index);\n+      offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + length);\n+      valueBuffer.setBytes(startOffset, value, start, length);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, ByteBuffer, int, int)} except that it handles the\n+    * case where index and length of new element are beyond the existing\n+    * capacity of the vector.\n+    *\n+    * @param index   position of the element to set\n+    * @param value   ByteBuffer with data\n+    * @param start   start index in ByteBuffer\n+    * @param length  length of data in ByteBuffer\n+    */\n+   public void setSafe(int index, ByteBuffer value, int start, int length) {\n+      assert index >= 0;\n+      fillEmpties(index);\n+      handleSafe(index, length);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      final int startOffset = getstartOffset(index);\n+      offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + length);\n+      valueBuffer.setBytes(startOffset, value, start, length);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Set the variable length element at the specified index to the data\n+    * buffer supplied in the holder\n+    *\n+    * @param index   position of the element to set\n+    * @param holder  holder that carries data buffer.\n+    */\n+   public void set(int index, VarBinaryHolder holder) {\n+      assert index >= 0;\n+      fillHoles(index);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      final int dataLength = holder.end - holder.start;\n+      final int startOffset = getstartOffset(index);\n+      offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + dataLength);\n+      valueBuffer.setBytes(startOffset, holder.buffer, holder.start, dataLength);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, VarBinaryHolder)} except that it handles the\n+    * case where index and length of new element are beyond the existing\n+    * capacity of the vector.\n+    *\n+    * @param index   position of the element to set\n+    * @param holder  holder that carries data buffer.\n+    */\n+   public void setSafe(int index, VarBinaryHolder holder) {\n+      assert index >= 0;\n+      final int dataLength = holder.end - holder.start;\n+      fillEmpties(index);\n+      handleSafe(index, dataLength);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      final int startOffset = getstartOffset(index);\n+      offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + dataLength);\n+      valueBuffer.setBytes(startOffset, holder.buffer, holder.start, dataLength);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Set the variable length element at the specified index to the data\n+    * buffer supplied in the holder\n+    *\n+    * @param index   position of the element to set\n+    * @param holder  holder that carries data buffer.\n+    */\n+   public void set(int index, NullableVarBinaryHolder holder) {\n+      assert index >= 0;\n+      fillHoles(index);\n+      BitVectorHelper.setValidityBit(validityBuffer, index, holder.isSet);\n+      final int dataLength = holder.end - holder.start;\n+      final int startOffset = getstartOffset(index);\n+      offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + dataLength);\n+      valueBuffer.setBytes(startOffset, holder.buffer, holder.start, dataLength);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableVarBinaryHolder)} except that it handles the\n+    * case where index and length of new element are beyond the existing\n+    * capacity of the vector.\n+    *\n+    * @param index   position of the element to set\n+    * @param holder  holder that carries data buffer.\n+    */\n+   public void setSafe(int index, NullableVarBinaryHolder holder) {\n+      assert index >= 0;\n+      final int dataLength = holder.end - holder.start;\n+      fillEmpties(index);\n+      handleSafe(index, dataLength);\n+      BitVectorHelper.setValidityBit(validityBuffer, index, holder.isSet);\n+      final int startOffset = getstartOffset(index);\n+      offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + dataLength);\n+      valueBuffer.setBytes(startOffset, holder.buffer, holder.start, dataLength);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Sets the value length for an element.\n+    *\n+    * @param index   position of the element to set\n+    * @param length  length of the element\n+    */\n+   public void setValueLengthSafe(int index, int length) {\n+      assert index >= 0;\n+      handleSafe(index, length);\n+      final int startOffset = getstartOffset(index);\n+      offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + length);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index, 0);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   /**\n+    * Store the given value at a particular position in the vector. isSet indicates\n+    * whether the value is NULL or not.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param start start position of data in buffer\n+    * @param end end position of data in buffer\n+    * @param buffer data buffer containing the variable width element to be stored\n+    *               in the vector\n+    */\n+   public void set(int index, int isSet, int start, int end, ArrowBuf buffer) {\n+      assert index >= 0;\n+      fillHoles(index);\n+      BitVectorHelper.setValidityBit(validityBuffer, index, isSet);\n+      final int startOffset = offsetBuffer.getInt(index * OFFSET_WIDTH);\n+      offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + end);\n+      final ArrowBuf bb = buffer.slice(start, end);\n+      valueBuffer.setBytes(startOffset, bb);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int, int, int, ArrowBuf)} except that it handles the case\n+    * when index is greater than or equal to current value capacity of the\n+    * vector.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param start start position of data in buffer\n+    * @param end end position of data in buffer\n+    * @param buffer data buffer containing the variable width element to be stored\n+    *               in the vector\n+    */\n+   public void setSafe(int index, int isSet, int start, int end, ArrowBuf buffer) {\n+      assert index >= 0;\n+      handleSafe(index, end);\n+      set(index, isSet, start, end, buffer);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableVarBinaryVector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableVarBinaryVector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableVarBinaryVector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableVarBinaryVector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableVarBinaryVector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableVarBinaryVector.this);\n+      }\n+   }\n+}\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableVarCharVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableVarCharVector.java\nindex b9021544b..0b03164f0 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableVarCharVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableVarCharVector.java\n@@ -1,5 +1,4 @@\n-/*******************************************************************************\n-\n+/**\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n@@ -15,7 +14,7 @@\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n- ******************************************************************************/\n+ */\n \n package org.apache.arrow.vector;\n \n@@ -32,30 +31,50 @@\n \n import java.nio.ByteBuffer;\n \n+/**\n+ * NullableVarCharVector implements a variable width vector of VARCHAR\n+ * values which could be NULL. A validity buffer (bit vector) is maintained\n+ * to track which elements in the vector are null.\n+ */\n public class NullableVarCharVector extends BaseNullableVariableWidthVector {\n-   private static final org.slf4j.Logger logger =\n-           org.slf4j.LoggerFactory.getLogger(NullableIntVector.class);\n    private final FieldReader reader;\n \n+   /**\n+    * Instantiate a NullableVarCharVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param allocator allocator for memory management.\n+    */\n    public NullableVarCharVector(String name, BufferAllocator allocator) {\n       this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.VARCHAR.getType()), allocator);\n    }\n \n+   /**\n+    * Instantiate a NullableVarCharVector. This doesn't allocate any memory for\n+    * the data in vector.\n+    * @param name name of the vector\n+    * @param fieldType type of Field materialized by this vector\n+    * @param allocator allocator for memory management.\n+    */\n    public NullableVarCharVector(String name, FieldType fieldType, BufferAllocator allocator) {\n       super(name, allocator, fieldType);\n       reader = new VarCharReaderImpl(NullableVarCharVector.this);\n    }\n \n-   @Override\n-   protected org.slf4j.Logger getLogger() {\n-      return logger;\n-   }\n-\n+   /**\n+    * Get a reader that supports reading values from this vector\n+    * @return Field Reader for this vector\n+    */\n    @Override\n    public FieldReader getReader(){\n       return reader;\n    }\n \n+   /**\n+    * Get minor type for this vector. The vector holds values belonging\n+    * to a particular type.\n+    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+    */\n    @Override\n    public Types.MinorType getMinorType() {\n       return Types.MinorType.VARCHAR;\n@@ -154,7 +173,13 @@ public void get(int index, NullableVarCharHolder holder){\n     ******************************************************************/\n \n \n-\n+   /**\n+    * Copy a cell value from a particular index in source vector to a particular\n+    * position in this vector\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n    public void copyFrom(int fromIndex, int thisIndex, NullableVarCharVector from) {\n       fillHoles(thisIndex);\n       if (from.isSet(fromIndex) != 0) {\n@@ -163,6 +188,14 @@ public void copyFrom(int fromIndex, int thisIndex, NullableVarCharVector from) {\n       }\n    }\n \n+   /**\n+    * Same as {@link #copyFrom(int, int, NullableVarCharVector)} except that\n+    * it handles the case when the capacity of the vector needs to be expanded\n+    * before copy.\n+    * @param fromIndex position to copy from in source vector\n+    * @param thisIndex position to copy to in this vector\n+    * @param from source vector\n+    */\n    public void copyFromSafe(int fromIndex, int thisIndex, NullableVarCharVector from) {\n       fillEmpties(thisIndex);\n       if (from.isSet(fromIndex) != 0) {\n@@ -383,21 +416,42 @@ public void setNull(int index){\n       BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n    }\n \n-   public void set(int index, int isSet, int startField, int endField, ArrowBuf bufferField ) {\n+   /**\n+    * Store the given value at a particular position in the vector. isSet indicates\n+    * whether the value is NULL or not.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param start start position of data in buffer\n+    * @param end end position of data in buffer\n+    * @param buffer data buffer containing the variable width element to be stored\n+    *               in the vector\n+    */\n+   public void set(int index, int isSet, int start, int end, ArrowBuf buffer) {\n       assert index >= 0;\n       fillHoles(index);\n       BitVectorHelper.setValidityBit(validityBuffer, index, isSet);\n       final int startOffset = offsetBuffer.getInt(index * OFFSET_WIDTH);\n-      offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + endField);\n-      final ArrowBuf bb = bufferField.slice(startField, endField);\n+      offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + end);\n+      final ArrowBuf bb = buffer.slice(start, end);\n       valueBuffer.setBytes(startOffset, bb);\n       lastSet = index;\n    }\n \n-   public void setSafe(int index, int isSet, int startField, int endField, ArrowBuf bufferField ) {\n+   /**\n+    * Same as {@link #set(int, int, int, int, ArrowBuf)} except that it handles the case\n+    * when index is greater than or equal to current value capacity of the\n+    * vector.\n+    * @param index position of the new value\n+    * @param isSet 0 for NULL value, 1 otherwise\n+    * @param start start position of data in buffer\n+    * @param end end position of data in buffer\n+    * @param buffer data buffer containing the variable width element to be stored\n+    *               in the vector\n+    */\n+   public void setSafe(int index, int isSet, int start, int end, ArrowBuf buffer) {\n       assert index >= 0;\n-      handleSafe(index, endField);\n-      set(index, isSet, startField, endField, bufferField);\n+      handleSafe(index, end);\n+      set(index, isSet, start, end, buffer);\n    }\n \n \n@@ -407,11 +461,23 @@ public void setSafe(int index, int isSet, int startField, int endField, ArrowBuf\n     *                                                                *\n     ******************************************************************/\n \n+   /**\n+    * Construct a TransferPair comprising of this and and a target vector of\n+    * the same type.\n+    * @param ref name of the target vector\n+    * @param allocator allocator for the target vector\n+    * @return {@link TransferPair}\n+    */\n    @Override\n    public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n       return new TransferImpl(ref, allocator);\n    }\n \n+   /**\n+    * Construct a TransferPair with a desired target vector of the same type.\n+    * @param to target vector\n+    * @return {@link TransferPair}\n+    */\n    @Override\n    public TransferPair makeTransferPair(ValueVector to) {\n       return new TransferImpl((NullableVarCharVector)to);\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/ValueVector.java b/java/vector/src/main/java/org/apache/arrow/vector/ValueVector.java\nindex e6048b4b5..dc74afaa2 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/ValueVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/ValueVector.java\n@@ -256,9 +256,17 @@\n    */\n   public ArrowBuf getOffsetBuffer();\n \n+  /* temporarily add these methods here until we remove other vectors\n+   * (non-nullable) which are under ValueVector hierarchy and still\n+   * use the mutator/accessor interfaces.\n+   */\n   public int getValueCount();\n \n   public void setValueCount(int valueCount);\n \n   public Object getObject(int index);\n+\n+  public int getNullCount();\n+\n+  public boolean isNull(int index);\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/VectorSchemaRoot.java b/java/vector/src/main/java/org/apache/arrow/vector/VectorSchemaRoot.java\nindex 0c8868cad..196393fb9 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/VectorSchemaRoot.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/VectorSchemaRoot.java\n@@ -38,7 +38,7 @@\n   private final Map<String, FieldVector> fieldVectorsMap = new HashMap<>();\n \n   public VectorSchemaRoot(FieldVector parent) {\n-    this(parent.getField().getChildren(), parent.getChildrenFromFields(), parent.getAccessor().getValueCount());\n+    this(parent.getField().getChildren(), parent.getChildrenFromFields(), parent.getValueCount());\n   }\n \n   public VectorSchemaRoot(List<Field> fields, List<FieldVector> fieldVectors, int rowCount) {\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/VectorUnloader.java b/java/vector/src/main/java/org/apache/arrow/vector/VectorUnloader.java\nindex 96243eb58..288afc6bb 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/VectorUnloader.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/VectorUnloader.java\n@@ -55,17 +55,7 @@ public ArrowRecordBatch getRecordBatch() {\n   }\n \n   private void appendNodes(FieldVector vector, List<ArrowFieldNode> nodes, List<ArrowBuf> buffers) {\n-    Accessor accessor = null;\n-    if (vector instanceof NullableIntVector) {\n-      nodes.add(new ArrowFieldNode(((NullableIntVector)vector).getValueCount(),\n-                includeNullCount ? ((NullableIntVector)vector).getNullCount() : -1));\n-    } else if (vector instanceof NullableVarCharVector) {\n-      nodes.add(new ArrowFieldNode(((NullableVarCharVector)vector).getValueCount(),\n-                includeNullCount ? ((NullableVarCharVector)vector).getNullCount() : -1));\n-    } else {\n-      accessor = vector.getAccessor();\n-      nodes.add(new ArrowFieldNode(accessor.getValueCount(), includeNullCount ? accessor.getNullCount() : -1));\n-    }\n+    nodes.add(new ArrowFieldNode(vector.getValueCount(), includeNullCount ? vector.getNullCount() : -1));\n     List<ArrowBuf> fieldBuffers = vector.getFieldBuffers();\n     List<ArrowVectorType> expectedBuffers = vector.getField().getTypeLayout().getVectorTypes();\n     if (fieldBuffers.size() != expectedBuffers.size()) {\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/ZeroVector.java b/java/vector/src/main/java/org/apache/arrow/vector/ZeroVector.java\nindex 804e00174..8a77065ca 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/ZeroVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/ZeroVector.java\n@@ -268,4 +268,10 @@ public void setValueCount(int valueCount) { }\n \n   @Override\n   public Object getObject(int index) { return null; }\n+\n+  @Override\n+  public int getNullCount() { return 0; }\n+\n+  @Override\n+  public boolean isNull(int index) { return false; }\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/AbstractMapVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/AbstractMapVector.java\nindex 26b0f9058..1b20b09d8 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/AbstractMapVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/AbstractMapVector.java\n@@ -141,8 +141,8 @@ public void reAlloc() {\n   }\n \n   private boolean nullFilled(ValueVector vector) {\n-    for (int r = 0; r < vector.getAccessor().getValueCount(); r++) {\n-      if (!vector.getAccessor().isNull(r)) {\n+    for (int r = 0; r < vector.getValueCount(); r++) {\n+      if (!vector.isNull(r)) {\n         return false;\n       }\n     }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/BaseRepeatedValueVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/BaseRepeatedValueVector.java\nindex 8e2877f89..3eab30a32 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/BaseRepeatedValueVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/BaseRepeatedValueVector.java\n@@ -21,6 +21,7 @@\n import java.util.Collections;\n import java.util.Iterator;\n \n+import org.apache.arrow.memory.BaseAllocator;\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.AddOrGetResult;\n import org.apache.arrow.vector.BaseValueVector;\n@@ -31,6 +32,7 @@\n import org.apache.arrow.vector.types.pojo.ArrowType.ArrowTypeID;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n \n import com.google.common.base.Preconditions;\n@@ -41,12 +43,14 @@\n public abstract class BaseRepeatedValueVector extends BaseValueVector implements RepeatedValueVector {\n \n   public final static FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n-  public final static String OFFSETS_VECTOR_NAME = \"$offsets$\";\n   public final static String DATA_VECTOR_NAME = \"$data$\";\n \n-  protected final UInt4Vector offsets;\n+  public final static byte OFFSET_WIDTH = 4;\n+  protected ArrowBuf offsetBuffer;\n   protected FieldVector vector;\n   protected final CallBack callBack;\n+  protected int valueCount;\n+  protected int offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n \n   protected BaseRepeatedValueVector(String name, BufferAllocator allocator, CallBack callBack) {\n     this(name, allocator, DEFAULT_DATA_VECTOR, callBack);\n@@ -54,42 +58,73 @@ protected BaseRepeatedValueVector(String name, BufferAllocator allocator, CallBa\n \n   protected BaseRepeatedValueVector(String name, BufferAllocator allocator, FieldVector vector, CallBack callBack) {\n     super(name, allocator);\n-    this.offsets = new UInt4Vector(OFFSETS_VECTOR_NAME, allocator);\n+    this.offsetBuffer = allocator.getEmpty();\n     this.vector = Preconditions.checkNotNull(vector, \"data vector cannot be null\");\n     this.callBack = callBack;\n+    this.valueCount = 0;\n   }\n \n   @Override\n   public boolean allocateNewSafe() {\n-    /* boolean to keep track if all the memory allocation were successful\n-     * Used in the case of composite vectors when we need to allocate multiple\n-     * buffers for multiple vectors. If one of the allocations failed we need to\n-     * clear all the memory that we allocated\n-     */\n-    boolean success = false;\n+    boolean dataAlloc = false;\n     try {\n-      if (!offsets.allocateNewSafe()) {\n-        return false;\n-      }\n-      success = vector.allocateNewSafe();\n-    } finally {\n-      if (!success) {\n+      allocateOffsetBuffer(offsetAllocationSizeInBytes);\n+      dataAlloc = vector.allocateNewSafe();\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      clear();\n+      return false;\n+    }\n+    finally {\n+      if (!dataAlloc) {\n         clear();\n       }\n     }\n-    offsets.zeroVector();\n-    return success;\n+    return dataAlloc;\n+  }\n+\n+  protected void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int)size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n   }\n \n   @Override\n   public void reAlloc() {\n-    offsets.reAlloc();\n+    reallocOffsetBuffer();\n     vector.reAlloc();\n   }\n \n+  protected void reallocOffsetBuffer() {\n+    final int currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize = offsetAllocationSizeInBytes;\n+\n+    if (baseSize < (long)currentBufferCapacity) {\n+      baseSize = (long)currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int)newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    final int halfNewCapacity = newBuf.capacity() / 2;\n+    newBuf.setZero(halfNewCapacity, halfNewCapacity);\n+    offsetBuffer.release(1);\n+    offsetBuffer = newBuf;\n+    offsetAllocationSizeInBytes = (int)newAllocationSize;\n+  }\n+\n   @Override\n+  @Deprecated\n   public UInt4Vector getOffsetVector() {\n-    return offsets;\n+    throw new UnsupportedOperationException(\"There is no inner offset vector\");\n   }\n \n   @Override\n@@ -99,25 +134,29 @@ public FieldVector getDataVector() {\n \n   @Override\n   public void setInitialCapacity(int numRecords) {\n-    offsets.setInitialCapacity(numRecords + 1);\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n     vector.setInitialCapacity(numRecords * RepeatedValueVector.DEFAULT_REPEAT_PER_RECORD);\n   }\n \n   @Override\n   public int getValueCapacity() {\n-    final int offsetValueCapacity = Math.max(offsets.getValueCapacity() - 1, 0);\n+    final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n     if (vector == DEFAULT_DATA_VECTOR) {\n       return offsetValueCapacity;\n     }\n     return Math.min(vector.getValueCapacity(), offsetValueCapacity);\n   }\n \n+  private int getOffsetBufferValueCapacity() {\n+    return (int)((offsetBuffer.capacity() * 1.0)/OFFSET_WIDTH);\n+  }\n+\n   @Override\n   public int getBufferSize() {\n-    if (getAccessor().getValueCount() == 0) {\n+    if (getValueCount() == 0) {\n       return 0;\n     }\n-    return offsets.getBufferSize() + vector.getBufferSize();\n+    return ((valueCount + 1) * OFFSET_WIDTH) + vector.getBufferSize();\n   }\n \n   @Override\n@@ -126,7 +165,7 @@ public int getBufferSizeFor(int valueCount) {\n       return 0;\n     }\n \n-    return offsets.getBufferSizeFor(valueCount + 1) + vector.getBufferSizeFor(valueCount);\n+    return ((valueCount + 1) * OFFSET_WIDTH) + vector.getBufferSizeFor(valueCount);\n   }\n \n   @Override\n@@ -136,14 +175,16 @@ public int getBufferSizeFor(int valueCount) {\n \n   @Override\n   public void clear() {\n-    offsets.clear();\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n     vector.clear();\n+    valueCount = 0;\n     super.clear();\n   }\n \n   @Override\n   public ArrowBuf[] getBuffers(boolean clear) {\n-    final ArrowBuf[] buffers = ObjectArrays.concat(offsets.getBuffers(false), vector.getBuffers(false), ArrowBuf.class);\n+    final ArrowBuf[] buffers = ObjectArrays.concat(new ArrowBuf[]{offsetBuffer},\n+            vector.getBuffers(false), ArrowBuf.class);\n     if (clear) {\n       for (ArrowBuf buffer : buffers) {\n         buffer.retain();\n@@ -187,54 +228,61 @@ protected void replaceDataVector(FieldVector v) {\n     vector = v;\n   }\n \n-  public abstract class BaseRepeatedAccessor extends BaseValueVector.BaseAccessor implements RepeatedAccessor {\n \n-    @Override\n-    public int getValueCount() {\n-      return Math.max(offsets.getAccessor().getValueCount() - 1, 0);\n-    }\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n \n-    @Override\n-    public int getInnerValueCount() {\n-      return vector.getAccessor().getValueCount();\n-    }\n+  /* returns the value count for inner data vector for this list vector */\n+  public int getInnerValueCount() {\n+    return vector.getValueCount();\n+  }\n \n-    @Override\n-    public int getInnerValueCountAt(int index) {\n-      return offsets.getAccessor().get(index + 1) - offsets.getAccessor().get(index);\n-    }\n \n-    @Override\n-    public boolean isNull(int index) {\n-      return false;\n-    }\n+  /* returns the value count for inner data vector at a particular index */\n+  public int getInnerValueCountAt(int index) {\n+    return offsetBuffer.getInt((index + 1) * OFFSET_WIDTH) -\n+            offsetBuffer.getInt(index * OFFSET_WIDTH);\n+  }\n \n-    @Override\n-    public boolean isEmpty(int index) {\n-      return false;\n-    }\n+  public boolean isNull(int index) {\n+    return false;\n   }\n \n-  public abstract class BaseRepeatedMutator extends BaseValueVector.BaseMutator implements RepeatedMutator {\n+  public boolean isEmpty(int index) {\n+    return false;\n+  }\n \n-    @Override\n-    public int startNewValue(int index) {\n-      while (offsets.getValueCapacity() <= index) {\n-        offsets.reAlloc();\n-      }\n-      int offset = offsets.getAccessor().get(index);\n-      offsets.getMutator().setSafe(index + 1, offset);\n-      setValueCount(index + 1);\n-      return offset;\n+  public int startNewValue(int index) {\n+    while (index >= getOffsetBufferValueCapacity()) {\n+      reallocOffsetBuffer();\n     }\n+    int offset = offsetBuffer.getInt(index * OFFSET_WIDTH);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, offset);\n+    setValueCount(index + 1);\n+    return offset;\n+  }\n \n-    @Override\n-    public void setValueCount(int valueCount) {\n-      // TODO: populate offset end points\n-      offsets.getMutator().setValueCount(valueCount == 0 ? 0 : valueCount + 1);\n-      final int childValueCount = valueCount == 0 ? 0 : offsets.getAccessor().get(valueCount);\n-      vector.getMutator().setValueCount(childValueCount);\n+  public void setValueCount(int valueCount) {\n+    this.valueCount = valueCount;\n+    while (valueCount > getOffsetBufferValueCapacity()) {\n+      reallocOffsetBuffer();\n     }\n+    final int childValueCount = valueCount == 0 ? 0 :\n+            offsetBuffer.getInt(valueCount * OFFSET_WIDTH);\n+    vector.setValueCount(childValueCount);\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public RepeatedAccessor getAccessor() {\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from LIST.\");\n   }\n \n+  @Override\n+  @Deprecated\n+  public RepeatedMutator getMutator() {\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing to LIST\");\n+  }\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/FixedSizeListVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/FixedSizeListVector.java\nindex e95442acf..bb091f68c 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/FixedSizeListVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/FixedSizeListVector.java\n@@ -22,16 +22,14 @@\n import static java.util.Collections.singletonList;\n import static org.apache.arrow.vector.complex.BaseRepeatedValueVector.DATA_VECTOR_NAME;\n \n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Objects;\n+import java.util.*;\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ObjectArrays;\n \n import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BaseAllocator;\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.memory.OutOfMemoryException;\n import org.apache.arrow.vector.*;\n@@ -42,10 +40,7 @@\n import org.apache.arrow.vector.types.pojo.DictionaryEncoding;\n import org.apache.arrow.vector.types.pojo.Field;\n import org.apache.arrow.vector.types.pojo.FieldType;\n-import org.apache.arrow.vector.util.CallBack;\n-import org.apache.arrow.vector.util.JsonStringArrayList;\n-import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n-import org.apache.arrow.vector.util.TransferPair;\n+import org.apache.arrow.vector.util.*;\n \n public class FixedSizeListVector extends BaseValueVector implements FieldVector, PromotableVector {\n \n@@ -55,15 +50,13 @@ public static FixedSizeListVector empty(String name, int size, BufferAllocator a\n   }\n \n   private FieldVector vector;\n-  private final BitVector bits;\n+  private ArrowBuf validityBuffer;\n   private final int listSize;\n   private final FieldType fieldType;\n-  private final List<BufferBacked> innerVectors;\n \n   private UnionFixedSizeListReader reader;\n-\n-  private Mutator mutator = new Mutator();\n-  private Accessor accessor = new Accessor();\n+  private int valueCount;\n+  private int validityAllocationSizeInBytes;\n \n   // deprecated, use FieldType or static constructor instead\n   @Deprecated\n@@ -80,13 +73,14 @@ public FixedSizeListVector(String name,\n                              FieldType fieldType,\n                              CallBack schemaChangeCallback) {\n     super(name, allocator);\n-    this.bits = new BitVector(\"$bits$\", allocator);\n+    this.validityBuffer = allocator.getEmpty();\n     this.vector = ZeroVector.INSTANCE;\n     this.fieldType = fieldType;\n     this.listSize = ((ArrowType.FixedSizeList) fieldType.getType()).getListSize();\n     Preconditions.checkArgument(listSize > 0, \"list size must be positive\");\n-    this.innerVectors = Collections.singletonList((BufferBacked) bits);\n     this.reader = new UnionFixedSizeListReader(this);\n+    this.valueCount = 0;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n   }\n \n   @Override\n@@ -124,27 +118,47 @@ public void initializeChildrenFromFields(List<Field> children) {\n \n   @Override\n   public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n-    BaseDataValueVector.load(fieldNode, innerVectors, ownBuffers);\n+    if (ownBuffers.size() != 1) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 1 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+\n+    validityBuffer.release();\n+    validityBuffer = bitBuffer.retain(allocator);\n+    valueCount = fieldNode.getLength();\n+\n+    validityAllocationSizeInBytes = validityBuffer.capacity();\n   }\n \n   @Override\n   public List<ArrowBuf> getFieldBuffers() {\n-    return BaseDataValueVector.unload(innerVectors);\n+    List<ArrowBuf> result = new ArrayList<>(1);\n+\n+    validityBuffer.readerIndex(0);\n+    validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+\n+    result.add(validityBuffer);\n+\n+    return result;\n   }\n \n   @Override\n+  @Deprecated\n   public List<BufferBacked> getFieldInnerVectors() {\n-    return innerVectors;\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n   }\n \n   @Override\n+  @Deprecated\n   public Accessor getAccessor() {\n-    return accessor;\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from vector\");\n   }\n \n   @Override\n+  @Deprecated\n   public Mutator getMutator() {\n-    return mutator;\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing to vector\");\n   }\n \n   @Override\n@@ -154,7 +168,9 @@ public UnionFixedSizeListReader getReader() {\n \n   @Override\n   public void allocateNew() throws OutOfMemoryException {\n-    allocateNewSafe();\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory\");\n+    }\n   }\n \n   @Override\n@@ -166,31 +182,63 @@ public boolean allocateNewSafe() {\n      */\n     boolean success = false;\n     try {\n-      success = bits.allocateNewSafe() && vector.allocateNewSafe();\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      success = vector.allocateNewSafe();\n     } finally {\n       if (!success) {\n         clear();\n+        return false;\n       }\n     }\n-    if (success) {\n-      bits.zeroVector();\n-    }\n-    return success;\n+\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int)size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n   }\n \n   @Override\n   public void reAlloc() {\n-    bits.reAlloc();\n+    reallocValidityBuffer();\n     vector.reAlloc();\n   }\n \n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = validityBuffer.capacity();\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long)currentBufferCapacity) {\n+      baseSize = (long)currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int)newAllocationSize);\n+    newBuf.setZero(0, newBuf.capacity());\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    validityBuffer.release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int)newAllocationSize;\n+  }\n+\n   public FieldVector getDataVector() {\n     return vector;\n   }\n \n   @Override\n   public void setInitialCapacity(int numRecords) {\n-    bits.setInitialCapacity(numRecords);\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n     vector.setInitialCapacity(numRecords * listSize);\n   }\n \n@@ -199,15 +247,15 @@ public int getValueCapacity() {\n     if (vector == ZeroVector.INSTANCE) {\n       return 0;\n     }\n-    return vector.getValueCapacity() / listSize;\n+    return Math.min(vector.getValueCapacity() / listSize, getValidityBufferValueCapacity());\n   }\n \n   @Override\n   public int getBufferSize() {\n-    if (accessor.getValueCount() == 0) {\n+    if (getValueCount() == 0) {\n       return 0;\n     }\n-    return bits.getBufferSize() + vector.getBufferSize();\n+    return getValidityBufferSizeFromCount(valueCount) + vector.getBufferSize();\n   }\n \n   @Override\n@@ -215,7 +263,8 @@ public int getBufferSizeFor(int valueCount) {\n     if (valueCount == 0) {\n       return 0;\n     }\n-    return bits.getBufferSizeFor(valueCount) + vector.getBufferSizeFor(valueCount * listSize);\n+    return getValidityBufferSizeFromCount(valueCount) +\n+            vector.getBufferSizeFor(valueCount * listSize);\n   }\n \n   @Override\n@@ -225,14 +274,15 @@ public int getBufferSizeFor(int valueCount) {\n \n   @Override\n   public void clear() {\n-    bits.clear();\n+    validityBuffer = releaseBuffer(validityBuffer);\n     vector.clear();\n+    valueCount = 0;\n     super.clear();\n   }\n \n   @Override\n   public ArrowBuf[] getBuffers(boolean clear) {\n-    final ArrowBuf[] buffers = ObjectArrays.concat(bits.getBuffers(false), vector.getBuffers(false), ArrowBuf.class);\n+    final ArrowBuf[] buffers = ObjectArrays.concat(new ArrowBuf[]{validityBuffer}, vector.getBuffers(false), ArrowBuf.class);\n     if (clear) {\n       for (ArrowBuf buffer : buffers) {\n         buffer.retain();\n@@ -288,7 +338,7 @@ public UnionVector promoteToUnion() {\n \n   @Override\n   public long getValidityBufferAddress() {\n-    return (bits.getDataBuffer().memoryAddress());\n+    return validityBuffer.memoryAddress();\n   }\n \n   @Override\n@@ -303,7 +353,7 @@ public long getOffsetBufferAddress() {\n \n   @Override\n   public ArrowBuf getValidityBuffer() {\n-    return (bits.getDataBuffer());\n+    return validityBuffer;\n   }\n \n   @Override\n@@ -316,62 +366,64 @@ public ArrowBuf getOffsetBuffer() {\n     throw new UnsupportedOperationException();\n   }\n \n-  public class Accessor extends BaseValueVector.BaseAccessor {\n-\n-    @Override\n-    public Object getObject(int index) {\n-      if (isNull(index)) {\n-        return null;\n-      }\n-      final List<Object> vals = new JsonStringArrayList<>(listSize);\n-      if (vector instanceof NullableIntVector || vector instanceof NullableVarCharVector) {\n-        for (int i = 0; i < listSize; i++) {\n-          vals.add(vector.getObject(index * listSize + i));\n-        }\n-      } else {\n-        final ValueVector.Accessor valuesAccessor = vector.getAccessor();\n-        for (int i = 0; i < listSize; i++) {\n-          vals.add(valuesAccessor.getObject(index * listSize + i));\n-        }\n-      }\n-      return vals;\n+  @Override\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n     }\n-\n-    @Override\n-    public boolean isNull(int index) {\n-      return bits.getAccessor().get(index) == 0;\n+    final List<Object> vals = new JsonStringArrayList<>(listSize);\n+    for (int i = 0; i < listSize; i++) {\n+      vals.add(vector.getObject(index * listSize + i));\n     }\n+    return vals;\n+  }\n \n-    @Override\n-    public int getNullCount() {\n-      return bits.getAccessor().getNullCount();\n-    }\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n \n-    @Override\n-    public int getValueCount() {\n-      return bits.getAccessor().getValueCount();\n-    }\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return Long.bitCount(b & (1L << bitIndex));\n   }\n \n-  public class Mutator extends BaseValueVector.BaseMutator {\n+  @Override\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n \n-    public void setNull(int index) {\n-      bits.getMutator().setSafe(index, 0);\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return (int)(validityBuffer.capacity() * 8L);\n+  }\n+\n+  public void setNull(int index) {\n+    while (index >= getValidityBufferValueCapacity()) {\n+      reallocValidityBuffer();\n     }\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n \n-    public void setNotNull(int index) {\n-      bits.getMutator().setSafe(index, 1);\n+  public void setNotNull(int index) {\n+    while (index >= getValidityBufferValueCapacity()) {\n+      reallocValidityBuffer();\n     }\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+  }\n \n-    @Override\n-    public void setValueCount(int valueCount) {\n-      bits.getMutator().setValueCount(valueCount);\n-      if (vector instanceof  NullableIntVector || vector instanceof NullableVarCharVector) {\n-        vector.setValueCount(valueCount * listSize);\n-      } else {\n-        vector.getMutator().setValueCount(valueCount * listSize);\n-      }\n+  @Override\n+  public void setValueCount(int valueCount) {\n+    this.valueCount = valueCount;\n+    while (valueCount > getValidityBufferValueCapacity()) {\n+      reallocValidityBuffer();\n     }\n+    vector.setValueCount(valueCount * listSize);\n   }\n \n   @Override\n@@ -392,7 +444,7 @@ public TransferPair makeTransferPair(ValueVector target) {\n   private class TransferImpl implements TransferPair {\n \n     FixedSizeListVector to;\n-    TransferPair pairs[] = new TransferPair[2];\n+    TransferPair dataPair;\n \n     public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n       this(new FixedSizeListVector(name, allocator, fieldType, callBack));\n@@ -401,19 +453,20 @@ public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n     public TransferImpl(FixedSizeListVector to) {\n       this.to = to;\n       to.addOrGetVector(vector.getField().getFieldType());\n-      pairs[0] = bits.makeTransferPair(to.bits);\n-      pairs[1] = vector.makeTransferPair(to.vector);\n+      dataPair = vector.makeTransferPair(to.vector);\n     }\n \n     @Override\n     public void transfer() {\n-      for (TransferPair pair : pairs) {\n-        pair.transfer();\n-      }\n+      to.clear();\n+      dataPair.transfer();\n+      to.validityBuffer = validityBuffer.transferOwnership(to.allocator).buffer;\n+      to.setValueCount(valueCount);\n     }\n \n     @Override\n     public void splitAndTransfer(int startIndex, int length) {\n+      to.clear();\n       to.allocateNew();\n       for (int i = 0; i < length; i++) {\n         copyValueSafe(startIndex + i, i);\n@@ -426,12 +479,15 @@ public ValueVector getTo() {\n     }\n \n     @Override\n-    public void copyValueSafe(int from, int to) {\n-      pairs[0].copyValueSafe(from, to);\n-      int fromOffset = from * listSize;\n-      int toOffset = to * listSize;\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      while (toIndex >= to.getValueCapacity()) {\n+        to.reAlloc();\n+      }\n+      BitVectorHelper.setValidityBit(to.validityBuffer, toIndex, isSet(fromIndex));\n+      int fromOffset = fromIndex * listSize;\n+      int toOffset = toIndex * listSize;\n       for (int i = 0; i < listSize; i++) {\n-        pairs[1].copyValueSafe(fromOffset + i, toOffset + i);\n+        dataPair.copyValueSafe(fromOffset + i, toOffset + i);\n       }\n     }\n   }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/LegacyBaseRepeatedValueVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/LegacyBaseRepeatedValueVector.java\nnew file mode 100644\nindex 000000000..435d3d8cc\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/LegacyBaseRepeatedValueVector.java\n@@ -0,0 +1,240 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.types.pojo.ArrowType.ArrowTypeID;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ObjectArrays;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+public abstract class LegacyBaseRepeatedValueVector extends BaseValueVector implements RepeatedValueVector {\n+\n+   public final static FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+   public final static String OFFSETS_VECTOR_NAME = \"$offsets$\";\n+   public final static String DATA_VECTOR_NAME = \"$data$\";\n+\n+   protected final UInt4Vector offsets;\n+   protected FieldVector vector;\n+   protected final CallBack callBack;\n+\n+   protected LegacyBaseRepeatedValueVector(String name, BufferAllocator allocator, CallBack callBack) {\n+      this(name, allocator, DEFAULT_DATA_VECTOR, callBack);\n+   }\n+\n+   protected LegacyBaseRepeatedValueVector(String name, BufferAllocator allocator, FieldVector vector, CallBack callBack) {\n+      super(name, allocator);\n+      this.offsets = new UInt4Vector(OFFSETS_VECTOR_NAME, allocator);\n+      this.vector = Preconditions.checkNotNull(vector, \"data vector cannot be null\");\n+      this.callBack = callBack;\n+   }\n+\n+   @Override\n+   public boolean allocateNewSafe() {\n+    /* boolean to keep track if all the memory allocation were successful\n+     * Used in the case of composite vectors when we need to allocate multiple\n+     * buffers for multiple vectors. If one of the allocations failed we need to\n+     * clear all the memory that we allocated\n+     */\n+      boolean success = false;\n+      try {\n+         if (!offsets.allocateNewSafe()) {\n+            return false;\n+         }\n+         success = vector.allocateNewSafe();\n+      } finally {\n+         if (!success) {\n+            clear();\n+         }\n+      }\n+      offsets.zeroVector();\n+      return success;\n+   }\n+\n+   @Override\n+   public void reAlloc() {\n+      offsets.reAlloc();\n+      vector.reAlloc();\n+   }\n+\n+   @Override\n+   public UInt4Vector getOffsetVector() {\n+      return offsets;\n+   }\n+\n+   @Override\n+   public FieldVector getDataVector() {\n+      return vector;\n+   }\n+\n+   @Override\n+   public void setInitialCapacity(int numRecords) {\n+      offsets.setInitialCapacity(numRecords + 1);\n+      vector.setInitialCapacity(numRecords * RepeatedValueVector.DEFAULT_REPEAT_PER_RECORD);\n+   }\n+\n+   @Override\n+   public int getValueCapacity() {\n+      final int offsetValueCapacity = Math.max(offsets.getValueCapacity() - 1, 0);\n+      if (vector == DEFAULT_DATA_VECTOR) {\n+         return offsetValueCapacity;\n+      }\n+      return Math.min(vector.getValueCapacity(), offsetValueCapacity);\n+   }\n+\n+   @Override\n+   public int getBufferSize() {\n+      if (getAccessor().getValueCount() == 0) {\n+         return 0;\n+      }\n+      return offsets.getBufferSize() + vector.getBufferSize();\n+   }\n+\n+   @Override\n+   public int getBufferSizeFor(int valueCount) {\n+      if (valueCount == 0) {\n+         return 0;\n+      }\n+\n+      return offsets.getBufferSizeFor(valueCount + 1) + vector.getBufferSizeFor(valueCount);\n+   }\n+\n+   @Override\n+   public Iterator<ValueVector> iterator() {\n+      return Collections.<ValueVector>singleton(getDataVector()).iterator();\n+   }\n+\n+   @Override\n+   public void clear() {\n+      offsets.clear();\n+      vector.clear();\n+      super.clear();\n+   }\n+\n+   @Override\n+   public ArrowBuf[] getBuffers(boolean clear) {\n+      final ArrowBuf[] buffers = ObjectArrays.concat(offsets.getBuffers(false), vector.getBuffers(false), ArrowBuf.class);\n+      if (clear) {\n+         for (ArrowBuf buffer : buffers) {\n+            buffer.retain();\n+         }\n+         clear();\n+      }\n+      return buffers;\n+   }\n+\n+   /**\n+    * @return 1 if inner vector is explicitly set via #addOrGetVector else 0\n+    */\n+   public int size() {\n+      return vector == DEFAULT_DATA_VECTOR ? 0 : 1;\n+   }\n+\n+   public <T extends ValueVector> AddOrGetResult<T> addOrGetVector(FieldType fieldType) {\n+      boolean created = false;\n+      if (vector instanceof ZeroVector) {\n+         vector = fieldType.createNewSingleVector(DATA_VECTOR_NAME, allocator, callBack);\n+         // returned vector must have the same field\n+         created = true;\n+         if (callBack != null &&\n+                 // not a schema change if changing from ZeroVector to ZeroVector\n+                 (fieldType.getType().getTypeID() != ArrowTypeID.Null)) {\n+            callBack.doWork();\n+         }\n+      }\n+\n+      if (vector.getField().getType().getTypeID() != fieldType.getType().getTypeID()) {\n+         final String msg = String.format(\"Inner vector type mismatch. Requested type: [%s], actual type: [%s]\",\n+                 fieldType.getType().getTypeID(), vector.getField().getType().getTypeID());\n+         throw new SchemaChangeRuntimeException(msg);\n+      }\n+\n+      return new AddOrGetResult<>((T) vector, created);\n+   }\n+\n+   protected void replaceDataVector(FieldVector v) {\n+      vector.clear();\n+      vector = v;\n+   }\n+\n+   public abstract class LegacyBaseRepeatedAccessor extends BaseValueVector.BaseAccessor implements RepeatedAccessor {\n+\n+      @Override\n+      public int getValueCount() {\n+         return Math.max(offsets.getAccessor().getValueCount() - 1, 0);\n+      }\n+\n+      @Override\n+      public int getInnerValueCount() {\n+         return vector.getAccessor().getValueCount();\n+      }\n+\n+      @Override\n+      public int getInnerValueCountAt(int index) {\n+         return offsets.getAccessor().get(index + 1) - offsets.getAccessor().get(index);\n+      }\n+\n+      @Override\n+      public boolean isNull(int index) {\n+         return false;\n+      }\n+\n+      @Override\n+      public boolean isEmpty(int index) {\n+         return false;\n+      }\n+   }\n+\n+   public abstract class LegacyBaseRepeatedMutator extends BaseValueVector.BaseMutator implements RepeatedMutator {\n+\n+      @Override\n+      public int startNewValue(int index) {\n+         while (offsets.getValueCapacity() <= index) {\n+            offsets.reAlloc();\n+         }\n+         int offset = offsets.getAccessor().get(index);\n+         offsets.getMutator().setSafe(index + 1, offset);\n+         setValueCount(index + 1);\n+         return offset;\n+      }\n+\n+      @Override\n+      public void setValueCount(int valueCount) {\n+         // TODO: populate offset end points\n+         offsets.getMutator().setValueCount(valueCount == 0 ? 0 : valueCount + 1);\n+         final int childValueCount = valueCount == 0 ? 0 : offsets.getAccessor().get(valueCount);\n+         vector.getMutator().setValueCount(childValueCount);\n+      }\n+   }\n+\n+}\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/LegacyFixedSizeListVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/LegacyFixedSizeListVector.java\nnew file mode 100644\nindex 000000000..0843907d9\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/LegacyFixedSizeListVector.java\n@@ -0,0 +1,298 @@\n+/*******************************************************************************\n+\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ ******************************************************************************/\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.vector.complex.BaseRepeatedValueVector.DATA_VECTOR_NAME;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ObjectArrays;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.impl.UnionFixedSizeListReader;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.DictionaryEncoding;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+public class LegacyFixedSizeListVector extends BaseValueVector implements FieldVector, PromotableVector {\n+\n+   public static LegacyFixedSizeListVector empty(String name, int size, BufferAllocator allocator) {\n+      FieldType fieldType = FieldType.nullable(new ArrowType.FixedSizeList(size));\n+      return new LegacyFixedSizeListVector(name, allocator, fieldType, null);\n+   }\n+\n+   private Mutator mutator = new Mutator();\n+   private Accessor accessor = new Accessor();\n+   /* delegate */\n+   private final FixedSizeListVector fixedSizeListVector;\n+\n+   // deprecated, use FieldType or static constructor instead\n+   @Deprecated\n+   public LegacyFixedSizeListVector(String name,\n+                              BufferAllocator allocator,\n+                              int listSize,\n+                              DictionaryEncoding dictionary,\n+                              CallBack schemaChangeCallback) {\n+      super(name, allocator);\n+      fixedSizeListVector = new FixedSizeListVector(name, allocator, listSize, dictionary, schemaChangeCallback);\n+   }\n+\n+   public LegacyFixedSizeListVector(String name,\n+                              BufferAllocator allocator,\n+                              FieldType fieldType,\n+                              CallBack schemaChangeCallback) {\n+      super(name, allocator);\n+      fixedSizeListVector = new FixedSizeListVector(name, allocator, fieldType, schemaChangeCallback);\n+   }\n+\n+   @Override\n+   public Field getField() {\n+      return fixedSizeListVector.getField();\n+   }\n+\n+   @Override\n+   public MinorType getMinorType() {\n+      return MinorType.FIXED_SIZE_LIST;\n+   }\n+\n+   public int getListSize() {\n+      return fixedSizeListVector.getListSize();\n+   }\n+\n+   @Override\n+   public void initializeChildrenFromFields(List<Field> children) {\n+      fixedSizeListVector.initializeChildrenFromFields(children);\n+   }\n+\n+   @Override\n+   public List<FieldVector> getChildrenFromFields() {\n+      return fixedSizeListVector.getChildrenFromFields();\n+   }\n+\n+   @Override\n+   public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+      fixedSizeListVector.loadFieldBuffers(fieldNode, ownBuffers);\n+   }\n+\n+   @Override\n+   public List<ArrowBuf> getFieldBuffers() {\n+      return fixedSizeListVector.getFieldBuffers();\n+   }\n+\n+   @Override\n+   public List<BufferBacked> getFieldInnerVectors() {\n+      return fixedSizeListVector.getFieldInnerVectors();\n+   }\n+\n+   @Override\n+   public Accessor getAccessor() {\n+      return accessor;\n+   }\n+\n+   @Override\n+   public Mutator getMutator() {\n+      return mutator;\n+   }\n+\n+   @Override\n+   public UnionFixedSizeListReader getReader() {\n+      return fixedSizeListVector.getReader();\n+   }\n+\n+   @Override\n+   public void allocateNew() throws OutOfMemoryException {\n+     fixedSizeListVector.allocateNew();\n+   }\n+\n+   @Override\n+   public boolean allocateNewSafe() {\n+    return fixedSizeListVector.allocateNewSafe();\n+   }\n+\n+   @Override\n+   public void reAlloc() {\n+      fixedSizeListVector.reAlloc();\n+   }\n+\n+   public FieldVector getDataVector() {\n+      return fixedSizeListVector.getDataVector();\n+   }\n+\n+   @Override\n+   public void setInitialCapacity(int numRecords) {\n+      fixedSizeListVector.setInitialCapacity(numRecords);\n+   }\n+\n+   @Override\n+   public int getValueCapacity() {\n+     return fixedSizeListVector.getValueCapacity();\n+   }\n+\n+   @Override\n+   public int getBufferSize() {\n+     return fixedSizeListVector.getBufferSize();\n+   }\n+\n+   @Override\n+   public int getBufferSizeFor(int valueCount) {\n+    return fixedSizeListVector.getBufferSizeFor(valueCount);\n+   }\n+\n+   @Override\n+   public Iterator<ValueVector> iterator() {\n+      return fixedSizeListVector.iterator();\n+   }\n+\n+   @Override\n+   public void clear() {\n+     fixedSizeListVector.clear();\n+   }\n+\n+   @Override\n+   public ArrowBuf[] getBuffers(boolean clear) {\n+      return fixedSizeListVector.getBuffers(clear);\n+   }\n+\n+   /**\n+    * @return 1 if inner vector is explicitly set via #addOrGetVector else 0\n+    */\n+   public int size() {\n+      return fixedSizeListVector.size();\n+   }\n+\n+   @Override\n+   @SuppressWarnings(\"unchecked\")\n+   public <T extends ValueVector> AddOrGetResult<T> addOrGetVector(FieldType type) {\n+      return fixedSizeListVector.addOrGetVector(type);\n+   }\n+\n+   public void copyFromSafe(int inIndex, int outIndex, FixedSizeListVector from) {\n+      fixedSizeListVector.copyFromSafe(inIndex, outIndex, from);\n+   }\n+\n+   public void copyFrom(int fromIndex, int thisIndex, FixedSizeListVector from) {\n+     fixedSizeListVector.copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+   @Override\n+   public UnionVector promoteToUnion() {\n+      return fixedSizeListVector.promoteToUnion();\n+   }\n+\n+   @Override\n+   public long getValidityBufferAddress() {\n+      return fixedSizeListVector.getValidityBufferAddress();\n+   }\n+\n+   @Override\n+   public long getDataBufferAddress() {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   @Override\n+   public long getOffsetBufferAddress() {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   @Override\n+   public ArrowBuf getValidityBuffer() {\n+      return fixedSizeListVector.getValidityBuffer();\n+   }\n+\n+   @Override\n+   public ArrowBuf getDataBuffer() {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   @Override\n+   public ArrowBuf getOffsetBuffer() {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   public class Accessor extends BaseValueVector.BaseAccessor {\n+\n+      @Override\n+      public Object getObject(int index) {\n+         return fixedSizeListVector.getObject(index);\n+      }\n+\n+      @Override\n+      public boolean isNull(int index) {\n+         return fixedSizeListVector.isNull(index);\n+      }\n+\n+      @Override\n+      public int getNullCount() {\n+         return fixedSizeListVector.getNullCount();\n+      }\n+\n+      @Override\n+      public int getValueCount() {\n+         return fixedSizeListVector.getValueCount();\n+      }\n+   }\n+\n+   public class Mutator extends BaseValueVector.BaseMutator {\n+\n+      public void setNull(int index) {\n+         fixedSizeListVector.setNull(index);\n+      }\n+\n+      public void setNotNull(int index) {\n+         fixedSizeListVector.setNotNull(index);\n+      }\n+\n+      @Override\n+      public void setValueCount(int valueCount) {\n+         fixedSizeListVector.setValueCount(valueCount);\n+      }\n+   }\n+\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+      return fixedSizeListVector.getTransferPair(ref, allocator);\n+   }\n+\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+      return fixedSizeListVector.getTransferPair(ref, allocator, callBack);\n+   }\n+\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector target) {\n+      return fixedSizeListVector.makeTransferPair(((LegacyFixedSizeListVector)target).fixedSizeListVector);\n+   }\n+}\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/LegacyListVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/LegacyListVector.java\nnew file mode 100644\nindex 000000000..732699ada\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/LegacyListVector.java\n@@ -0,0 +1,288 @@\n+/*******************************************************************************\n+\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ ******************************************************************************/\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static java.util.Collections.list;\n+import static java.util.Collections.singletonList;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ObjectArrays;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionListReader;\n+import org.apache.arrow.vector.complex.impl.UnionListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.complex.writer.FieldWriter;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.ArrowType.Null;\n+import org.apache.arrow.vector.types.pojo.DictionaryEncoding;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+public class LegacyListVector extends LegacyBaseRepeatedValueVector implements FieldVector, PromotableVector {\n+\n+   public static LegacyListVector empty(String name, BufferAllocator allocator) {\n+      return new LegacyListVector(name, allocator, FieldType.nullable(ArrowType.List.INSTANCE), null);\n+   }\n+\n+   private Mutator mutator = new Mutator();\n+   private Accessor accessor = new Accessor();\n+\n+   private final ListVector listVector;\n+\n+   // deprecated, use FieldType or static constructor instead\n+   @Deprecated\n+   public LegacyListVector(String name, BufferAllocator allocator, CallBack callBack) {\n+      super(name, allocator, callBack);\n+      listVector = new ListVector(name, allocator, callBack);\n+   }\n+\n+   // deprecated, use FieldType or static constructor instead\n+   @Deprecated\n+   public LegacyListVector(String name, BufferAllocator allocator, DictionaryEncoding dictionary, CallBack callBack) {\n+      super(name, allocator, callBack);\n+      listVector = new ListVector(name, allocator, dictionary, callBack);\n+   }\n+\n+   public LegacyListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+      super(name, allocator, callBack);\n+      listVector = new ListVector(name, allocator, fieldType, callBack);\n+   }\n+\n+   @Override\n+   public void initializeChildrenFromFields(List<Field> children) {\n+      listVector.initializeChildrenFromFields(children);\n+   }\n+\n+   @Override\n+   public List<FieldVector> getChildrenFromFields() {\n+      return listVector.getChildrenFromFields();\n+   }\n+\n+   @Override\n+   public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+      listVector.loadFieldBuffers(fieldNode, ownBuffers);\n+   }\n+\n+   @Override\n+   public List<ArrowBuf> getFieldBuffers() {\n+      return listVector.getFieldBuffers();\n+   }\n+\n+   @Override\n+   public List<BufferBacked> getFieldInnerVectors() {\n+      return listVector.getFieldInnerVectors();\n+   }\n+\n+   public UnionListWriter getWriter() {\n+      return listVector.getWriter();\n+   }\n+\n+   @Override\n+   public void allocateNew() throws OutOfMemoryException {\n+      listVector.allocateNew();\n+   }\n+\n+   @Override\n+   public void reAlloc() {\n+      listVector.reAlloc();\n+   }\n+\n+   public void copyFromSafe(int inIndex, int outIndex, ListVector from) {\n+      listVector.copyFrom(inIndex, outIndex, from);\n+   }\n+\n+   public void copyFrom(int inIndex, int outIndex, ListVector from) {\n+      listVector.copyFrom(inIndex, outIndex, from);\n+   }\n+\n+   @Override\n+   public FieldVector getDataVector() {\n+      return listVector.getDataVector();\n+   }\n+\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+      return listVector.getTransferPair(ref, allocator);\n+   }\n+\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+      return listVector.getTransferPair(ref, allocator, callBack);\n+   }\n+\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector target) {\n+      return listVector.makeTransferPair(((LegacyListVector)target).listVector);\n+   }\n+\n+   @Override\n+   public long getValidityBufferAddress() {\n+      return listVector.getValidityBufferAddress();\n+   }\n+\n+   @Override\n+   public long getDataBufferAddress() {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   @Override\n+   public long getOffsetBufferAddress() {\n+      return listVector.getOffsetBufferAddress();\n+   }\n+\n+   @Override\n+   public ArrowBuf getValidityBuffer() {\n+      return listVector.getValidityBuffer();\n+   }\n+\n+   @Override\n+   public ArrowBuf getDataBuffer() {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   @Override\n+   public ArrowBuf getOffsetBuffer() {\n+      return listVector.getOffsetBuffer();\n+   }\n+\n+   @Override\n+   public Accessor getAccessor() {\n+      return accessor;\n+   }\n+\n+   @Override\n+   public Mutator getMutator() {\n+      return mutator;\n+   }\n+\n+   @Override\n+   public UnionListReader getReader() {\n+      return listVector.getReader();\n+   }\n+\n+   @Override\n+   public boolean allocateNewSafe() {\n+      return listVector.allocateNewSafe();\n+   }\n+\n+   public <T extends ValueVector> AddOrGetResult<T> addOrGetVector(FieldType fieldType) {\n+      return listVector.addOrGetVector(fieldType);\n+   }\n+\n+   @Override\n+   public int getBufferSize() {\n+      return listVector.getBufferSize();\n+   }\n+\n+   @Override\n+   public Field getField() {\n+     return listVector.getField();\n+   }\n+\n+   @Override\n+   public MinorType getMinorType() {\n+      return MinorType.LIST;\n+   }\n+\n+   @Override\n+   public void clear() {\n+      listVector.clear();\n+   }\n+\n+   @Override\n+   public ArrowBuf[] getBuffers(boolean clear) {\n+     return listVector.getBuffers(clear);\n+   }\n+\n+   @Override\n+   public UnionVector promoteToUnion() {\n+     return listVector.promoteToUnion();\n+   }\n+\n+   private int lastSet = 0;\n+\n+   public class Accessor extends LegacyBaseRepeatedAccessor {\n+\n+      @Override\n+      public Object getObject(int index) {\n+        return listVector.getObject(index);\n+      }\n+\n+      @Override\n+      public boolean isNull(int index) {\n+         return listVector.isNull(index);\n+      }\n+\n+      @Override\n+      public int getNullCount() {\n+         return listVector.getNullCount();\n+      }\n+   }\n+\n+   public class Mutator extends LegacyBaseRepeatedMutator {\n+      public void setNotNull(int index) {\n+        listVector.setNotNull(index);\n+      }\n+\n+      @Override\n+      public int startNewValue(int index) {\n+         return listVector.startNewValue(index);\n+      }\n+\n+      /**\n+       * End the current value\n+       *\n+       * @param index index of the value to end\n+       * @param size  number of elements in the list that was written\n+       */\n+      public void endValue(int index, int size) {\n+         listVector.endValue(index, size);\n+      }\n+\n+      @Override\n+      public void setValueCount(int valueCount) {\n+        listVector.setValueCount(valueCount);\n+      }\n+\n+      public void setLastSet(int value) {\n+         listVector.setLastSet(value);\n+      }\n+\n+      public int getLastSet() {\n+         return listVector.getLastSet();\n+      }\n+   }\n+\n+}\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/LegacyMapVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/LegacyMapVector.java\nnew file mode 100644\nindex 000000000..77556ab77\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/LegacyMapVector.java\n@@ -0,0 +1,229 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Ordering;\n+import com.google.common.primitives.Ints;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.impl.SingleMapReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.ComplexHolder;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringHashMap;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+public class LegacyMapVector extends AbstractMapVector {\n+\n+   /* delegate */\n+   private final MapVector mapVector;\n+\n+   public static LegacyMapVector empty(String name, BufferAllocator allocator) {\n+      FieldType fieldType = new FieldType(false, ArrowType.Struct.INSTANCE, null, null);\n+      return new LegacyMapVector(name, allocator, fieldType, null);\n+   }\n+\n+   private final Accessor accessor = new Accessor();\n+   private final Mutator mutator = new Mutator();\n+\n+   @Deprecated\n+   public LegacyMapVector(String name, BufferAllocator allocator, CallBack callBack) {\n+      super(name, allocator, callBack);\n+      mapVector = new MapVector(name, allocator, new FieldType(false, ArrowType.Struct.INSTANCE, null, null), callBack);\n+   }\n+\n+   public LegacyMapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+      super(name, allocator, callBack);\n+      mapVector = new MapVector(name, allocator, fieldType, callBack);\n+   }\n+\n+   @Override\n+   public FieldReader getReader() {\n+      return mapVector.getReader();\n+   }\n+\n+   public void copyFromSafe(int fromIndex, int thisIndex, MapVector from) {\n+     mapVector.copyFromSafe(fromIndex, thisIndex, from);\n+   }\n+\n+   @Override\n+   protected boolean supportsDirectRead() {\n+      return true;\n+   }\n+\n+   public Iterator<String> fieldNameIterator() {\n+      return mapVector.fieldNameIterator();\n+   }\n+\n+   @Override\n+   public void setInitialCapacity(int numRecords) {\n+     mapVector.setInitialCapacity(numRecords);\n+   }\n+\n+   @Override\n+   public int getBufferSize() {\n+     return mapVector.getBufferSize();\n+   }\n+\n+   @Override\n+   public int getBufferSizeFor(final int valueCount) {\n+      return (int) mapVector.getBufferSizeFor(valueCount);\n+   }\n+\n+   @Override\n+   public ArrowBuf getValidityBuffer() {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   @Override\n+   public ArrowBuf getDataBuffer() {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   @Override\n+   public ArrowBuf getOffsetBuffer() {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   @Override\n+   public TransferPair getTransferPair(BufferAllocator allocator) {\n+      return getTransferPair(name, allocator, null);\n+   }\n+\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+      return mapVector.getTransferPair(ref, allocator, callBack);\n+   }\n+\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return mapVector.makeTransferPair(((LegacyMapVector)to).mapVector);\n+   }\n+\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+      return mapVector.getTransferPair(ref, allocator);\n+   }\n+\n+   @Override\n+   public int getValueCapacity() {\n+      return mapVector.getValueCapacity();\n+   }\n+\n+   @Override\n+   public Accessor getAccessor() {\n+      return accessor;\n+   }\n+\n+   @Override\n+   public Mutator getMutator() {\n+      return mutator;\n+   }\n+\n+   public class Accessor extends BaseValueVector.BaseAccessor {\n+\n+      @Override\n+      public Object getObject(int index) {\n+         return mapVector.getObject(index);\n+      }\n+\n+      public void get(int index, ComplexHolder holder) {\n+        mapVector.get(index, holder);\n+      }\n+\n+      @Override\n+      public int getValueCount() {\n+         return mapVector.getValueCount();\n+      }\n+   }\n+\n+   public ValueVector getVectorById(int id) {\n+      return mapVector.getVectorById(id);\n+   }\n+\n+   public class Mutator extends BaseValueVector.BaseMutator {\n+\n+      @Override\n+      public void setValueCount(int valueCount) {\n+        mapVector.setValueCount(valueCount);\n+      }\n+\n+      @Override\n+      public void reset() { }\n+\n+      @Override\n+      public void generateTestData(int values) { }\n+   }\n+\n+   @Override\n+   public void clear() {\n+     mapVector.clear();\n+   }\n+\n+   @Override\n+   public Field getField() {\n+     return mapVector.getField();\n+   }\n+\n+   @Override\n+   public MinorType getMinorType() {\n+      return MinorType.MAP;\n+   }\n+\n+   @Override\n+   public void close() {\n+      mapVector.close();\n+   }\n+\n+   public void initializeChildrenFromFields(List<Field> children) {\n+      mapVector.initializeChildrenFromFields(children);\n+   }\n+\n+   public List<FieldVector> getChildrenFromFields() {\n+      return mapVector.getChildren();\n+   }\n+\n+   public boolean isNull(int index) { return false; }\n+\n+   public int getNullCount() { return  0; }\n+\n+   public int getValueCount() { return 0; }\n+\n+   public void setValueCount(int valueCount) { }\n+\n+   public Object getObject(int index) { return null; }\n+}\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\nindex 258a46f55..7869c36ad 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\n@@ -22,14 +22,14 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n import static java.util.Collections.singletonList;\n \n-import java.util.Arrays;\n-import java.util.Collections;\n+import java.util.ArrayList;\n import java.util.List;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ObjectArrays;\n \n import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BaseAllocator;\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.memory.OutOfMemoryException;\n import org.apache.arrow.vector.*;\n@@ -47,6 +47,7 @@\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.CallBack;\n import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n import org.apache.arrow.vector.util.TransferPair;\n \n public class ListVector extends BaseRepeatedValueVector implements FieldVector, PromotableVector {\n@@ -55,14 +56,12 @@ public static ListVector empty(String name, BufferAllocator allocator) {\n     return new ListVector(name, allocator, FieldType.nullable(ArrowType.List.INSTANCE), null);\n   }\n \n-  final UInt4Vector offsets;\n-  final BitVector bits;\n-  private final List<BufferBacked> innerVectors;\n-  private Mutator mutator = new Mutator();\n-  private Accessor accessor = new Accessor();\n+  private ArrowBuf validityBuffer;\n   private UnionListReader reader;\n   private CallBack callBack;\n   private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+  private int lastSet;\n \n   // deprecated, use FieldType or static constructor instead\n   @Deprecated\n@@ -78,12 +77,12 @@ public ListVector(String name, BufferAllocator allocator, DictionaryEncoding dic\n \n   public ListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n     super(name, allocator, callBack);\n-    this.bits = new BitVector(\"$bits$\", allocator);\n-    this.offsets = getOffsetVector();\n-    this.innerVectors = Collections.unmodifiableList(Arrays.<BufferBacked>asList(bits, offsets));\n+    this.validityBuffer = allocator.getEmpty();\n     this.reader = new UnionListReader(this);\n     this.fieldType = checkNotNull(fieldType);\n     this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = 0;\n   }\n \n   @Override\n@@ -107,20 +106,43 @@ public void initializeChildrenFromFields(List<Field> children) {\n \n   @Override\n   public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n-    // variable width values: truncate offset vector buffer to size (#1)\n-    org.apache.arrow.vector.BaseDataValueVector.truncateBufferBasedOnSize(ownBuffers, 1, offsets.getBufferSizeFor(fieldNode.getLength() + 1));\n-    BaseDataValueVector.load(fieldNode, getFieldInnerVectors(), ownBuffers);\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+\n+    validityBuffer.release();\n+    validityBuffer = bitBuffer.retain(allocator);\n+    offsetBuffer.release();\n+    offsetBuffer = offBuffer.retain(allocator);\n+\n+    validityAllocationSizeInBytes = validityBuffer.capacity();\n+    offsetAllocationSizeInBytes = offsetBuffer.capacity();\n+\n     lastSet = fieldNode.getLength();\n+    valueCount = fieldNode.getLength();\n   }\n \n   @Override\n   public List<ArrowBuf> getFieldBuffers() {\n-    return BaseDataValueVector.unload(getFieldInnerVectors());\n+    List<ArrowBuf> result = new ArrayList<>(2);\n+    validityBuffer.readerIndex(0);\n+    validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+    offsetBuffer.readerIndex(0);\n+    offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n   }\n \n   @Override\n+  @Deprecated\n   public List<BufferBacked> getFieldInnerVectors() {\n-    return innerVectors;\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n   }\n \n   public UnionListWriter getWriter() {\n@@ -129,14 +151,70 @@ public UnionListWriter getWriter() {\n \n   @Override\n   public void allocateNew() throws OutOfMemoryException {\n-    super.allocateNewSafe();\n-    bits.allocateNewSafe();\n+   if (!allocateNewSafe()) {\n+     throw new OutOfMemoryException(\"Failure while allocating memory\");\n+   }\n+  }\n+\n+  public boolean allocateNewSafe() {\n+    boolean success = false;\n+    try {\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      /* allocate offset and data buffer */\n+      success = super.allocateNewSafe();\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int)size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n   }\n \n   @Override\n   public void reAlloc() {\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n+    /* reallocate the offset and data */\n     super.reAlloc();\n-    bits.reAlloc();\n+  }\n+\n+  private void reallocValidityAndOffsetBuffers() {\n+    reallocOffsetBuffer();\n+    reallocValidityBuffer();\n+  }\n+\n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = validityBuffer.capacity();\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long)currentBufferCapacity) {\n+      baseSize = (long)currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int)newAllocationSize);\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    final int halfNewCapacity = newBuf.capacity() / 2;\n+    newBuf.setZero(halfNewCapacity, halfNewCapacity);\n+    validityBuffer.release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int)newAllocationSize;\n   }\n \n   public void copyFromSafe(int inIndex, int outIndex, ListVector from) {\n@@ -173,7 +251,7 @@ public TransferPair makeTransferPair(ValueVector target) {\n \n   @Override\n   public long getValidityBufferAddress() {\n-    return (bits.getDataBuffer().memoryAddress());\n+    return (validityBuffer.memoryAddress());\n   }\n \n   @Override\n@@ -183,11 +261,11 @@ public long getDataBufferAddress() {\n \n   @Override\n   public long getOffsetBufferAddress() {\n-    return (offsets.getDataBuffer().memoryAddress());\n+    return (offsetBuffer.memoryAddress());\n   }\n \n   @Override\n-  public ArrowBuf getValidityBuffer() { return bits.getDataBuffer(); }\n+  public ArrowBuf getValidityBuffer() { return validityBuffer; }\n \n   @Override\n   public ArrowBuf getDataBuffer() {\n@@ -195,17 +273,13 @@ public ArrowBuf getDataBuffer() {\n   }\n \n   @Override\n-  public ArrowBuf getOffsetBuffer() { return offsets.getDataBuffer(); }\n+  public ArrowBuf getOffsetBuffer() { return offsetBuffer; }\n \n   private class TransferImpl implements TransferPair {\n \n     ListVector to;\n-    TransferPair bitsTransferPair;\n-    TransferPair offsetsTransferPair;\n     TransferPair dataTransferPair;\n \n-    TransferPair[] pairs;\n-\n     public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n       this(new ListVector(name, allocator, fieldType, callBack));\n     }\n@@ -213,39 +287,99 @@ public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n     public TransferImpl(ListVector to) {\n       this.to = to;\n       to.addOrGetVector(vector.getField().getFieldType());\n-      offsetsTransferPair = offsets.makeTransferPair(to.offsets);\n-      bitsTransferPair = bits.makeTransferPair(to.bits);\n       if (to.getDataVector() instanceof ZeroVector) {\n         to.addOrGetVector(vector.getField().getFieldType());\n       }\n       dataTransferPair = getDataVector().makeTransferPair(to.getDataVector());\n-      pairs = new TransferPair[] {bitsTransferPair, offsetsTransferPair, dataTransferPair};\n     }\n \n     @Override\n     public void transfer() {\n-      for (TransferPair pair : pairs) {\n-        pair.transfer();\n-      }\n+      dataTransferPair.transfer();\n+      to.validityBuffer = validityBuffer.transferOwnership(to.allocator).buffer;\n+      to.offsetBuffer = offsetBuffer.transferOwnership(to.allocator).buffer;\n       to.lastSet = lastSet;\n+      to.setValueCount(valueCount);\n     }\n \n     @Override\n     public void splitAndTransfer(int startIndex, int length) {\n-      UInt4Vector.Accessor offsetVectorAccessor = ListVector.this.offsets.getAccessor();\n-      final int startPoint = offsetVectorAccessor.get(startIndex);\n-      final int sliceLength = offsetVectorAccessor.get(startIndex + length) - startPoint;\n+      final int startPoint = offsetBuffer.getInt(startIndex * OFFSET_WIDTH);\n+      final int sliceLength = offsetBuffer.getInt((startIndex + length) * OFFSET_WIDTH) - startPoint;\n       to.clear();\n-      to.offsets.allocateNew(length + 1);\n-      offsetVectorAccessor = ListVector.this.offsets.getAccessor();\n-      final UInt4Vector.Mutator targetOffsetVectorMutator = to.offsets.getMutator();\n+      to.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+      /* splitAndTransfer offset buffer */\n       for (int i = 0; i < length + 1; i++) {\n-        targetOffsetVectorMutator.set(i, offsetVectorAccessor.get(startIndex + i) - startPoint);\n+        final int relativeOffset = offsetBuffer.getInt((startIndex + i) * OFFSET_WIDTH) - startPoint;\n+        to.offsetBuffer.setInt(i * OFFSET_WIDTH, relativeOffset);\n       }\n-      bitsTransferPair.splitAndTransfer(startIndex, length);\n+      /* splitAndTransfer validity buffer */\n+      splitAndTransferValidityBuffer(startIndex, length, to);\n+      /* splitAndTransfer data buffer */\n       dataTransferPair.splitAndTransfer(startPoint, sliceLength);\n       to.lastSet = length;\n-      to.mutator.setValueCount(length);\n+      to.setValueCount(length);\n+    }\n+\n+    /*\n+     * transfer the validity.\n+     */\n+    private void splitAndTransferValidityBuffer(int startIndex, int length, ListVector target) {\n+      assert startIndex + length <= valueCount;\n+      int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+      int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+      int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+      int offset = startIndex % 8;\n+\n+      if (length > 0) {\n+        if (offset == 0) {\n+          // slice\n+          if (target.validityBuffer != null) {\n+            target.validityBuffer.release();\n+          }\n+          target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+          target.validityBuffer.retain(1);\n+        }\n+        else {\n+          /* Copy data\n+           * When the first bit starts from the middle of a byte (offset != 0),\n+           * copy data from src BitVector.\n+           * Each byte in the target is composed by a part in i-th byte,\n+           * another part in (i+1)-th byte.\n+           */\n+          target.allocateValidityBuffer(byteSizeTarget);\n+\n+          for (int i = 0; i < byteSizeTarget - 1; i++) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n+\n+            target.validityBuffer.setByte(i, (b1 + b2));\n+          }\n+\n+          /* Copying the last piece is done in the following manner:\n+           * if the source vector has 1 or more bytes remaining, we copy\n+           * the last piece as a byte formed by shifting data\n+           * from the current byte and the next byte.\n+           *\n+           * if the source vector has no more bytes remaining\n+           * (we are at the last byte), we copy the last piece as a byte\n+           * by shifting data from the current byte.\n+           */\n+          if((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget, offset);\n+\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+          }\n+          else {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+          }\n+        }\n+      }\n     }\n \n     @Override\n@@ -260,46 +394,10 @@ public void copyValueSafe(int from, int to) {\n   }\n \n   @Override\n-  public Accessor getAccessor() {\n-    return accessor;\n-  }\n-\n-  @Override\n-  public Mutator getMutator() {\n-    return mutator;\n-  }\n-\n-  @Override\n   public UnionListReader getReader() {\n     return reader;\n   }\n \n-  @Override\n-  public boolean allocateNewSafe() {\n-    /* boolean to keep track if all the memory allocation were successful\n-     * Used in the case of composite vectors when we need to allocate multiple\n-     * buffers for multiple vectors. If one of the allocations failed we need to\n-     * clear all the memory that we allocated\n-     */\n-    boolean success = false;\n-    try {\n-      if (!offsets.allocateNewSafe()) {\n-        return false;\n-      }\n-      success = vector.allocateNewSafe();\n-      success = success && bits.allocateNewSafe();\n-    } finally {\n-      if (!success) {\n-        clear();\n-      }\n-    }\n-    if (success) {\n-      offsets.zeroVector();\n-      bits.zeroVector();\n-    }\n-    return success;\n-  }\n-\n   public <T extends ValueVector> AddOrGetResult<T> addOrGetVector(FieldType fieldType) {\n     AddOrGetResult<T> result = super.addOrGetVector(fieldType);\n     reader = new UnionListReader(this);\n@@ -308,10 +406,12 @@ public boolean allocateNewSafe() {\n \n   @Override\n   public int getBufferSize() {\n-    if (getAccessor().getValueCount() == 0) {\n+    if (getValueCount() == 0) {\n       return 0;\n     }\n-    return offsets.getBufferSize() + bits.getBufferSize() + vector.getBufferSize();\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    return offsetBufferSize + validityBufferSize + vector.getBufferSize();\n   }\n \n   @Override\n@@ -329,16 +429,14 @@ public MinorType getMinorType() {\n \n   @Override\n   public void clear() {\n-    offsets.clear();\n-    vector.clear();\n-    bits.clear();\n-    lastSet = 0;\n     super.clear();\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    lastSet = 0;\n   }\n \n   @Override\n   public ArrowBuf[] getBuffers(boolean clear) {\n-    final ArrowBuf[] buffers = ObjectArrays.concat(offsets.getBuffers(false), ObjectArrays.concat(bits.getBuffers(false),\n+    final ArrowBuf[] buffers = ObjectArrays.concat(new ArrowBuf[]{offsetBuffer}, ObjectArrays.concat(new ArrowBuf[] {validityBuffer},\n         vector.getBuffers(false), ArrowBuf.class), ArrowBuf.class);\n     if (clear) {\n       for (ArrowBuf buffer : buffers) {\n@@ -360,99 +458,97 @@ public UnionVector promoteToUnion() {\n     return vector;\n   }\n \n-  private int lastSet = 0;\n+  @Override\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    }\n+    final List<Object> vals = new JsonStringArrayList<>();\n+    final int start = offsetBuffer.getInt(index * OFFSET_WIDTH);\n+    final int end = offsetBuffer.getInt((index + 1) * OFFSET_WIDTH);\n+    final ValueVector vv = getDataVector();\n+    for (int i = start; i < end; i++) {\n+      vals.add(vv.getObject(i));\n+    }\n \n-  public class Accessor extends BaseRepeatedAccessor {\n+    return vals;\n+  }\n \n-    @Override\n-    public Object getObject(int index) {\n-      if (isNull(index)) {\n-        return null;\n-      }\n-      final List<Object> vals = new JsonStringArrayList<>();\n-      final UInt4Vector.Accessor offsetsAccessor = offsets.getAccessor();\n-      final int start = offsetsAccessor.get(index);\n-      final int end = offsetsAccessor.get(index + 1);\n-      final ValueVector vv = getDataVector();\n-      if (vv instanceof  NullableIntVector || vv instanceof NullableVarCharVector) {\n-        for (int i = start; i < end; i++) {\n-          vals.add(vv.getObject(i));\n-        }\n-      } else {\n-        final ValueVector.Accessor valuesAccessor = vv.getAccessor();\n-        for (int i = start; i < end; i++) {\n-          vals.add(valuesAccessor.getObject(i));\n-        }\n-      }\n+  @Override\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n \n-      return vals;\n-    }\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return Long.bitCount(b & (1L << bitIndex));\n+  }\n \n-    @Override\n-    public boolean isNull(int index) {\n-      return bits.getAccessor().get(index) == 0;\n-    }\n+  @Override\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n \n-    @Override\n-    public int getNullCount() {\n-      return bits.getAccessor().getNullCount();\n+  public void setNotNull(int index) {\n+    if (index >= getValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n     }\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    lastSet = index + 1;\n   }\n \n-  public class Mutator extends BaseRepeatedMutator {\n-    public void setNotNull(int index) {\n-      bits.getMutator().setSafe(index, 1);\n-      lastSet = index + 1;\n+  @Override\n+  public int startNewValue(int index) {\n+    if (index >= getValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n     }\n-\n-    @Override\n-    public int startNewValue(int index) {\n-      for (int i = lastSet; i <= index; i++) {\n-        offsets.getMutator().setSafe(i + 1, offsets.getAccessor().get(i));\n-      }\n-      setNotNull(index);\n-      lastSet = index + 1;\n-      return offsets.getAccessor().get(lastSet);\n+    for (int i = lastSet; i <= index; i++) {\n+      final int currentOffset = offsetBuffer.getInt(i * OFFSET_WIDTH);\n+      offsetBuffer.setInt((i + 1) * OFFSET_WIDTH, currentOffset);\n     }\n+    setNotNull(index);\n+    lastSet = index + 1;\n+    return offsetBuffer.getInt(lastSet * OFFSET_WIDTH);\n+  }\n \n-    /**\n-     * End the current value\n-     *\n-     * @param index index of the value to end\n-     * @param size  number of elements in the list that was written\n-     */\n-    public void endValue(int index, int size) {\n-      offsets.getMutator().set(index + 1, offsets.getAccessor().get(index + 1) + size);\n-    }\n+  /**\n+   * End the current value\n+   *\n+   * @param index index of the value to end\n+   * @param size  number of elements in the list that was written\n+   */\n+  public void endValue(int index, int size) {\n+    final int currentOffset = offsetBuffer.getInt((index + 1) * OFFSET_WIDTH);\n+    offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, currentOffset + size);\n+  }\n \n-    @Override\n-    public void setValueCount(int valueCount) {\n-      // TODO: populate offset end points\n-      if (valueCount == 0) {\n-        offsets.getMutator().setValueCount(0);\n-      } else {\n-        for (int i = lastSet; i < valueCount; i++) {\n-          offsets.getMutator().setSafe(i + 1, offsets.getAccessor().get(i));\n-        }\n-        offsets.getMutator().setValueCount(valueCount + 1);\n+  @Override\n+  public void setValueCount(int valueCount) {\n+    this.valueCount = valueCount;\n+    if (valueCount > 0) {\n+      while (valueCount > getValueCapacity()) {\n+        /* realloc the inner buffers if needed */\n+        reallocValidityAndOffsetBuffers();\n       }\n-      final int childValueCount = valueCount == 0 ? 0 : offsets.getAccessor().get(valueCount);\n-      if (vector instanceof NullableIntVector || vector instanceof NullableVarCharVector) {\n-        vector.setValueCount(childValueCount);\n-      } else {\n-        vector.getMutator().setValueCount(childValueCount);\n+      for (int i = lastSet; i < valueCount; i++) {\n+        /* fill the holes with offsets */\n+        final int currentOffset = offsetBuffer.getInt(i * OFFSET_WIDTH);\n+        offsetBuffer.setInt((i + 1) * OFFSET_WIDTH, currentOffset);\n       }\n-\n-      bits.getMutator().setValueCount(valueCount);\n-    }\n-\n-    public void setLastSet(int value) {\n-      lastSet = value;\n     }\n+    /* valueCount for the data vector is the current end offset */\n+    final int childValueCount = (valueCount == 0) ? 0 :\n+            offsetBuffer.getInt(valueCount * OFFSET_WIDTH);\n+    vector.setValueCount(childValueCount);\n+  }\n \n-    public int getLastSet() {\n-      return lastSet;\n-    }\n+  public void setLastSet(int value) {\n+    lastSet = value;\n   }\n \n+  public int getLastSet() {\n+    return lastSet;\n+  }\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\nindex 95efa6087..6089a6792 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n@@ -56,8 +56,6 @@ public static MapVector empty(String name, BufferAllocator allocator) {\n   }\n \n   private final SingleMapReaderImpl reader = new SingleMapReaderImpl(this);\n-  private final Accessor accessor = new Accessor();\n-  private final Mutator mutator = new Mutator();\n   protected final FieldType fieldType;\n   public int valueCount;\n \n@@ -70,6 +68,7 @@ public MapVector(String name, BufferAllocator allocator, CallBack callBack) {\n   public MapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n     super(name, allocator, callBack);\n     this.fieldType = checkNotNull(fieldType);\n+    this.valueCount = 0;\n   }\n \n   @Override\n@@ -230,7 +229,7 @@ public void splitAndTransfer(int startIndex, int length) {\n       for (TransferPair p : pairs) {\n         p.splitAndTransfer(startIndex, length);\n       }\n-      to.getMutator().setValueCount(length);\n+      to.setValueCount(length);\n     }\n   }\n \n@@ -255,76 +254,54 @@ public int compare(@Nullable ValueVector left, @Nullable ValueVector right) {\n \n   @Override\n   public Accessor getAccessor() {\n-    return accessor;\n+    throw new UnsupportedOperationException(\"accessor is not needed for MAP\");\n   }\n \n   @Override\n   public Mutator getMutator() {\n-    return mutator;\n+    throw new UnsupportedOperationException(\"mutator is not needed for MAP\");\n   }\n \n-  public class Accessor extends BaseValueVector.BaseAccessor {\n-\n-    @Override\n-    public Object getObject(int index) {\n-      Map<String, Object> vv = new JsonStringHashMap<>();\n-      for (String child : getChildFieldNames()) {\n-        ValueVector v = getChild(child);\n-        if (v instanceof  NullableVarCharVector || v instanceof  NullableIntVector) {\n-          if (v != null && index < v.getValueCount()) {\n-            Object value = v.getObject(index);\n-            if (value != null) {\n-              vv.put(child, value);\n-            }\n-          }\n-        } else {\n-          if (v != null && index < v.getAccessor().getValueCount()) {\n-            Object value = v.getAccessor().getObject(index);\n-            if (value != null) {\n-              vv.put(child, value);\n-            }\n-          }\n+  @Override\n+  public Object getObject(int index) {\n+    Map<String, Object> vv = new JsonStringHashMap<>();\n+    for (String child : getChildFieldNames()) {\n+      ValueVector v = getChild(child);\n+      if (v != null && index < v.getValueCount()) {\n+        Object value = v.getObject(index);\n+        if (value != null) {\n+          vv.put(child, value);\n         }\n       }\n-      return vv;\n     }\n+    return vv;\n+  }\n \n-    public void get(int index, ComplexHolder holder) {\n-      reader.setPosition(index);\n-      holder.reader = reader;\n-    }\n+  @Override\n+  public boolean isNull(int index) { return false; }\n+  @Override\n+  public int getNullCount() { return 0; }\n \n-    @Override\n-    public int getValueCount() {\n-      return valueCount;\n-    }\n+  public void get(int index, ComplexHolder holder) {\n+    reader.setPosition(index);\n+    holder.reader = reader;\n   }\n \n-  public ValueVector getVectorById(int id) {\n-    return getChildByOrdinal(id);\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n   }\n \n-  public class Mutator extends BaseValueVector.BaseMutator {\n-\n-    @Override\n-    public void setValueCount(int valueCount) {\n-      for (final ValueVector v : getChildren()) {\n-        if (v instanceof NullableIntVector || v instanceof NullableVarCharVector) {\n-          v.setValueCount(valueCount);\n-        } else {\n-          v.getMutator().setValueCount(valueCount);\n-        }\n-      }\n-      MapVector.this.valueCount = valueCount;\n-    }\n-\n-    @Override\n-    public void reset() {\n-    }\n+  public ValueVector getVectorById(int id) {\n+  return getChildByOrdinal(id);\n+}\n \n-    @Override\n-    public void generateTestData(int values) {\n+  @Override\n+  public void setValueCount(int valueCount) {\n+    for (final ValueVector v : getChildren()) {\n+      v.setValueCount(valueCount);\n     }\n+    MapVector.this.valueCount = valueCount;\n   }\n \n   @Override\n@@ -372,11 +349,4 @@ public void initializeChildrenFromFields(List<Field> children) {\n   public List<FieldVector> getChildrenFromFields() {\n     return getChildren();\n   }\n-\n-  public int getValueCount() { return 0; }\n-\n-  public void setValueCount(int valueCount) { }\n-\n-  public Object getObject(int index) { return null; }\n-\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/NullableMapVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/NullableMapVector.java\nindex 1c9d5aa26..a1478c5a7 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/NullableMapVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/NullableMapVector.java\n@@ -20,6 +20,7 @@\n \n import static com.google.common.base.Preconditions.checkNotNull;\n \n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n@@ -27,13 +28,9 @@\n import com.google.common.collect.ObjectArrays;\n \n import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BaseAllocator;\n import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.vector.BaseDataValueVector;\n-import org.apache.arrow.vector.BitVector;\n-import org.apache.arrow.vector.BufferBacked;\n-import org.apache.arrow.vector.FieldVector;\n-import org.apache.arrow.vector.NullableVectorDefinitionSetter;\n-import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.*;\n import org.apache.arrow.vector.complex.impl.NullableMapReaderImpl;\n import org.apache.arrow.vector.complex.impl.NullableMapWriter;\n import org.apache.arrow.vector.holders.ComplexHolder;\n@@ -44,6 +41,7 @@\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.types.pojo.Field;\n import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n import org.apache.arrow.vector.util.TransferPair;\n \n public class NullableMapVector extends MapVector implements FieldVector {\n@@ -56,12 +54,8 @@ public static NullableMapVector empty(String name, BufferAllocator allocator) {\n   private final NullableMapReaderImpl reader = new NullableMapReaderImpl(this);\n   private final NullableMapWriter writer = new NullableMapWriter(this);\n \n-  protected final BitVector bits;\n-\n-  private final List<BufferBacked> innerVectors;\n-\n-  private final Accessor accessor;\n-  private final Mutator mutator;\n+  private ArrowBuf validityBuffer;\n+  private int validityAllocationSizeInBytes;\n \n   // deprecated, use FieldType or static constructor instead\n   @Deprecated\n@@ -77,10 +71,8 @@ public NullableMapVector(String name, BufferAllocator allocator, DictionaryEncod\n \n   public NullableMapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n     super(name, checkNotNull(allocator), fieldType, callBack);\n-    this.bits = new BitVector(\"$bits$\", allocator);\n-    this.innerVectors = Collections.unmodifiableList(Arrays.<BufferBacked>asList(bits));\n-    this.accessor = new Accessor();\n-    this.mutator = new Mutator();\n+    this.validityBuffer = allocator.getEmpty();\n+    this.validityAllocationSizeInBytes = BitVectorHelper.getValidityBufferSize(BaseValueVector.INITIAL_VALUE_ALLOCATION);\n   }\n \n   @Override\n@@ -92,18 +84,33 @@ public Field getField() {\n \n   @Override\n   public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n-    BaseDataValueVector.load(fieldNode, getFieldInnerVectors(), ownBuffers);\n-    this.valueCount = fieldNode.getLength();\n+    if (ownBuffers.size() != 1) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 1 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+\n+    validityBuffer.release();\n+    validityBuffer = bitBuffer.retain(allocator);\n+    valueCount = fieldNode.getLength();\n+    validityAllocationSizeInBytes = validityBuffer.capacity();\n   }\n \n   @Override\n   public List<ArrowBuf> getFieldBuffers() {\n-    return BaseDataValueVector.unload(getFieldInnerVectors());\n+    List<ArrowBuf> result = new ArrayList<>(1);\n+\n+    validityBuffer.readerIndex(0);\n+    validityBuffer.writerIndex(BitVectorHelper.getValidityBufferSize(valueCount));\n+    result.add(validityBuffer);\n+\n+    return result;\n   }\n \n   @Override\n+  @Deprecated\n   public List<BufferBacked> getFieldInnerVectors() {\n-    return innerVectors;\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n   }\n \n   @Override\n@@ -146,49 +153,129 @@ protected NullableMapTransferPair(NullableMapVector from, NullableMapVector to,\n \n     @Override\n     public void transfer() {\n-      bits.transferTo(target.bits);\n+      target.clear();\n+      target.validityBuffer = validityBuffer.transferOwnership(target.allocator).buffer;\n       super.transfer();\n     }\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      target.bits.copyFromSafe(fromIndex, toIndex, bits);\n+      while (toIndex >= target.getValidityBufferValueCapacity()) {\n+        target.reallocValidityBuffer();\n+      }\n+      BitVectorHelper.setValidityBit(target.validityBuffer, toIndex, isSet(fromIndex));\n       super.copyValueSafe(fromIndex, toIndex);\n     }\n \n     @Override\n     public void splitAndTransfer(int startIndex, int length) {\n-      bits.splitAndTransferTo(startIndex, length, target.bits);\n+      target.clear();\n+      splitAndTransferValidityBuffer(startIndex, length, target);\n       super.splitAndTransfer(startIndex, length);\n     }\n   }\n \n+  /*\n+   * transfer the validity.\n+   */\n+  private void splitAndTransferValidityBuffer(int startIndex, int length, NullableMapVector target) {\n+    assert startIndex + length <= valueCount;\n+    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+    int byteSizeTarget = BitVectorHelper.getValidityBufferSize(length);\n+    int offset = startIndex % 8;\n+\n+    if (length > 0) {\n+      if (offset == 0) {\n+        // slice\n+        if (target.validityBuffer != null) {\n+          target.validityBuffer.release();\n+        }\n+        target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+        target.validityBuffer.retain(1);\n+      }\n+      else {\n+        /* Copy data\n+         * When the first bit starts from the middle of a byte (offset != 0),\n+         * copy data from src BitVector.\n+         * Each byte in the target is composed by a part in i-th byte,\n+         * another part in (i+1)-th byte.\n+         */\n+        target.allocateValidityBuffer(byteSizeTarget);\n+\n+        for (int i = 0; i < byteSizeTarget - 1; i++) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n+\n+          target.validityBuffer.setByte(i, (b1 + b2));\n+        }\n+\n+        /* Copying the last piece is done in the following manner:\n+         * if the source vector has 1 or more bytes remaining, we copy\n+         * the last piece as a byte formed by shifting data\n+         * from the current byte and the next byte.\n+         *\n+         * if the source vector has no more bytes remaining\n+         * (we are at the last byte), we copy the last piece as a byte\n+         * by shifting data from the current byte.\n+         */\n+        if((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n+                  firstByteSource + byteSizeTarget, offset);\n+\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+        }\n+        else {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+        }\n+      }\n+    }\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return (int)(validityBuffer.capacity() * 8L);\n+  }\n+\n   @Override\n   public int getValueCapacity() {\n-    return Math.min(bits.getValueCapacity(), super.getValueCapacity());\n+    return Math.min(getValidityBufferValueCapacity(),\n+            super.getValueCapacity());\n   }\n \n   @Override\n   public ArrowBuf[] getBuffers(boolean clear) {\n-    return ObjectArrays.concat(bits.getBuffers(clear), super.getBuffers(clear), ArrowBuf.class);\n+    if (clear) {\n+      validityBuffer.retain(1);\n+    }\n+    return ObjectArrays.concat(new ArrowBuf[]{validityBuffer}, super.getBuffers(clear), ArrowBuf.class);\n   }\n \n   @Override\n   public void close() {\n-    bits.close();\n+    clearValidityBuffer();\n     super.close();\n   }\n \n   @Override\n   public void clear() {\n-    bits.clear();\n+    clearValidityBuffer();\n     super.clear();\n   }\n \n+  private void clearValidityBuffer() {\n+    validityBuffer.release();\n+    validityBuffer = allocator.getEmpty();\n+  }\n \n   @Override\n   public int getBufferSize() {\n-    return super.getBufferSize() + bits.getBufferSize();\n+    if (valueCount == 0) { return 0; }\n+    return super.getBufferSize() +\n+            BitVectorHelper.getValidityBufferSize(valueCount);\n   }\n \n   @Override\n@@ -197,12 +284,12 @@ public int getBufferSizeFor(final int valueCount) {\n       return 0;\n     }\n     return super.getBufferSizeFor(valueCount)\n-        + bits.getBufferSizeFor(valueCount);\n+        + BitVectorHelper.getValidityBufferSize(valueCount);\n   }\n \n   @Override\n   public void setInitialCapacity(int numRecords) {\n-    bits.setInitialCapacity(numRecords);\n+    validityAllocationSizeInBytes = BitVectorHelper.getValidityBufferSize(numRecords);\n     super.setInitialCapacity(numRecords);\n   }\n \n@@ -215,25 +302,59 @@ public boolean allocateNewSafe() {\n      */\n     boolean success = false;\n     try {\n-      success = super.allocateNewSafe() && bits.allocateNewSafe();\n+      clearValidityBuffer();\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      success = super.allocateNewSafe();\n     } finally {\n       if (!success) {\n         clear();\n+        return false;\n       }\n     }\n-    bits.zeroVector();\n-    return success;\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int)size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n   }\n \n   @Override\n   public void reAlloc() {\n-    bits.reAlloc();\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n     super.reAlloc();\n   }\n \n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = validityBuffer.capacity();\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long)currentBufferCapacity) {\n+      baseSize = (long)currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > BaseValueVector.MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int)newAllocationSize);\n+    newBuf.setZero(0, newBuf.capacity());\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    validityBuffer.release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int)newAllocationSize;\n+  }\n+\n   @Override\n   public long getValidityBufferAddress() {\n-    return bits.getBuffer().memoryAddress();\n+    return validityBuffer.memoryAddress();\n   }\n \n   @Override\n@@ -248,7 +369,7 @@ public long getOffsetBufferAddress() {\n \n   @Override\n   public ArrowBuf getValidityBuffer() {\n-    return bits.getDataBuffer();\n+    return validityBuffer;\n   }\n \n   @Override\n@@ -261,82 +382,76 @@ public ArrowBuf getOffsetBuffer() {\n     throw new UnsupportedOperationException();\n   }\n \n-  public final class Accessor extends MapVector.Accessor {\n-    final BitVector.Accessor bAccessor = bits.getAccessor();\n-\n-    @Override\n-    public Object getObject(int index) {\n-      if (isNull(index)) {\n-        return null;\n-      } else {\n-        return super.getObject(index);\n-      }\n-    }\n-\n-    @Override\n-    public void get(int index, ComplexHolder holder) {\n-      holder.isSet = isSet(index);\n-      super.get(index, holder);\n-    }\n-\n-    @Override\n-    public int getNullCount() {\n-      return bits.getAccessor().getNullCount();\n-    }\n-\n-    @Override\n-    public boolean isNull(int index) {\n-      return isSet(index) == 0;\n-    }\n-\n-    public int isSet(int index) {\n-      return bAccessor.get(index);\n+  @Override\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return super.getObject(index);\n     }\n-\n   }\n \n-  public final class Mutator extends MapVector.Mutator implements NullableVectorDefinitionSetter {\n+  @Override\n+  public void get(int index, ComplexHolder holder) {\n+    holder.isSet = isSet(index);\n+    super.get(index, holder);\n+  }\n \n-    private Mutator() {\n-    }\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n \n-    @Override\n-    public void setIndexDefined(int index) {\n-      bits.getMutator().setSafe(index, 1);\n-    }\n+  public boolean isNull(int index) {\n+    return isSet(index) == 0;\n+  }\n \n-    public void setNull(int index) {\n-      bits.getMutator().setSafe(index, 0);\n-    }\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return Long.bitCount(b & (1L << bitIndex));\n+  }\n \n-    @Override\n-    public void setValueCount(int valueCount) {\n-      assert valueCount >= 0;\n-      super.setValueCount(valueCount);\n-      bits.getMutator().setValueCount(valueCount);\n+  public void setIndexDefined(int index) {\n+    while (index >= getValidityBufferValueCapacity()) {\n+      /* realloc the inner buffers if needed */\n+      reallocValidityBuffer();\n     }\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+  }\n \n-    @Override\n-    public void generateTestData(int valueCount) {\n-      super.generateTestData(valueCount);\n-      bits.getMutator().generateTestDataAlt(valueCount);\n+  public void setNull(int index) {\n+    while (index >= getValidityBufferValueCapacity()) {\n+      /* realloc the inner buffers if needed */\n+      reallocValidityBuffer();\n     }\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n \n-    @Override\n-    public void reset() {\n-      bits.getMutator().setValueCount(0);\n+  @Override\n+  public void setValueCount(int valueCount) {\n+    assert valueCount >= 0;\n+    while (valueCount > getValueCapacity()) {\n+      /* realloc the inner buffers if needed */\n+      reallocValidityBuffer();\n     }\n+    super.setValueCount(valueCount);\n+    this.valueCount = valueCount;\n+  }\n \n+  public void reset() {\n+    valueCount = 0;\n   }\n \n   @Override\n+  @Deprecated\n   public Accessor getAccessor() {\n-    return accessor;\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from Nullable MAP\");\n   }\n \n   @Override\n+  @Deprecated\n   public Mutator getMutator() {\n-    return mutator;\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing to Nullable MAP\");\n   }\n-\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapReaderImpl.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapReaderImpl.java\nindex 614c266ac..06b0f4d43 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapReaderImpl.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapReaderImpl.java\n@@ -52,6 +52,6 @@ public void copyAsField(String name, MapWriter writer) {\n \n   @Override\n   public boolean isSet() {\n-    return !nullableMapVector.getAccessor().isNull(idx());\n+    return !nullableMapVector.isNull(idx());\n   }\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/PromotableWriter.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/PromotableWriter.java\nindex 9722196ed..5bd439cac 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/PromotableWriter.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/PromotableWriter.java\n@@ -162,7 +162,7 @@ private FieldWriter promoteToUnion() {\n     writer = new UnionWriter(unionVector, nullableMapWriterFactory);\n     writer.setPosition(idx());\n     for (int i = 0; i <= idx(); i++) {\n-      unionVector.getMutator().setType(i, vector.getMinorType());\n+      unionVector.setType(i, vector.getMinorType());\n     }\n     vector = null;\n     state = State.UNION;\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/SingleMapReaderImpl.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/SingleMapReaderImpl.java\nindex 3ebd0cd7d..c77ca4e8f 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/SingleMapReaderImpl.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/SingleMapReaderImpl.java\n@@ -78,7 +78,7 @@ public void setPosition(int index) {\n \n   @Override\n   public Object readObject() {\n-    return vector.getAccessor().getObject(idx());\n+    return vector.getObject(idx());\n   }\n \n   @Override\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionFixedSizeListReader.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionFixedSizeListReader.java\nindex f3e9b8773..4ad2f6f5f 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionFixedSizeListReader.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionFixedSizeListReader.java\n@@ -46,7 +46,7 @@ public UnionFixedSizeListReader(FixedSizeListVector vector) {\n \n   @Override\n   public boolean isSet() {\n-    return !vector.getAccessor().isNull(idx());\n+    return !vector.isNull(idx());\n   }\n \n   @Override\n@@ -56,7 +56,7 @@ public FieldReader reader() {\n \n   @Override\n   public Object readObject() {\n-    return vector.getAccessor().getObject(idx());\n+    return vector.getObject(idx());\n   }\n \n   @Override\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionListReader.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionListReader.java\nindex b98c36d2b..6243a2833 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionListReader.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionListReader.java\n@@ -19,6 +19,7 @@\n \n package org.apache.arrow.vector.complex.impl;\n \n+import io.netty.buffer.ArrowBuf;\n import org.apache.arrow.vector.UInt4Vector;\n import org.apache.arrow.vector.ValueVector;\n import org.apache.arrow.vector.complex.ListVector;\n@@ -33,12 +34,11 @@\n \n   private ListVector vector;\n   private ValueVector data;\n-  private UInt4Vector offsets;\n+  private static final int OFFSET_WIDTH = 4;\n \n   public UnionListReader(ListVector vector) {\n     this.vector = vector;\n     this.data = vector.getDataVector();\n-    this.offsets = vector.getOffsetVector();\n   }\n \n   @Override\n@@ -48,7 +48,7 @@ public Field getField() {\n \n   @Override\n   public boolean isSet() {\n-    return !vector.getAccessor().isNull(idx());\n+    return !vector.isNull(idx());\n   }\n \n   private int currentOffset;\n@@ -57,8 +57,8 @@ public boolean isSet() {\n   @Override\n   public void setPosition(int index) {\n     super.setPosition(index);\n-    currentOffset = offsets.getAccessor().get(index) - 1;\n-    maxOffset = offsets.getAccessor().get(index + 1);\n+    currentOffset = vector.getOffsetBuffer().getInt(index * OFFSET_WIDTH) - 1;\n+    maxOffset = vector.getOffsetBuffer().getInt((index + 1) * OFFSET_WIDTH);\n   }\n \n   @Override\n@@ -68,7 +68,7 @@ public FieldReader reader() {\n \n   @Override\n   public Object readObject() {\n-    return vector.getAccessor().getObject(idx());\n+    return vector.getObject(idx());\n   }\n \n   @Override\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/dictionary/DictionaryEncoder.java b/java/vector/src/main/java/org/apache/arrow/vector/dictionary/DictionaryEncoder.java\nindex 3b7dc4a56..762a442c9 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/dictionary/DictionaryEncoder.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/dictionary/DictionaryEncoder.java\n@@ -47,11 +47,10 @@\n   public static ValueVector encode(ValueVector vector, Dictionary dictionary) {\n     validateType(vector.getMinorType());\n     // load dictionary values into a hashmap for lookup\n-    ValueVector.Accessor dictionaryAccessor = dictionary.getVector().getAccessor();\n-    Map<Object, Integer> lookUps = new HashMap<>(dictionaryAccessor.getValueCount());\n-    for (int i = 0; i < dictionaryAccessor.getValueCount(); i++) {\n+    Map<Object, Integer> lookUps = new HashMap<>(dictionary.getVector().getValueCount());\n+    for (int i = 0; i < dictionary.getVector().getValueCount(); i++) {\n       // for primitive array types we need a wrapper that implements equals and hashcode appropriately\n-      lookUps.put(dictionaryAccessor.getObject(i), i);\n+      lookUps.put(dictionary.getVector().getObject(i), i);\n     }\n \n     Field valueField = vector.getField();\n@@ -61,14 +60,13 @@ public static ValueVector encode(ValueVector vector, Dictionary dictionary) {\n \n     // vector to hold our indices (dictionary encoded values)\n     FieldVector indices = indexField.createVector(vector.getAllocator());\n-    ValueVector.Mutator mutator = indices.getMutator();\n \n     // use reflection to pull out the set method\n     // TODO implement a common interface for int vectors\n     Method setter = null;\n     for (Class<?> c : ImmutableList.of(int.class, long.class)) {\n       try {\n-        setter = mutator.getClass().getMethod(\"setSafe\", int.class, c);\n+        setter = indices.getClass().getMethod(\"setSafe\", int.class, c);\n         break;\n       } catch (NoSuchMethodException e) {\n         // ignore\n@@ -78,21 +76,20 @@ public static ValueVector encode(ValueVector vector, Dictionary dictionary) {\n       throw new IllegalArgumentException(\"Dictionary encoding does not have a valid int type:\" + indices.getClass());\n     }\n \n-    ValueVector.Accessor accessor = vector.getAccessor();\n-    int count = accessor.getValueCount();\n+    int count = vector.getValueCount();\n \n     indices.allocateNew();\n \n     try {\n       for (int i = 0; i < count; i++) {\n-        Object value = accessor.getObject(i);\n+        Object value = vector.getObject(i);\n         if (value != null) { // if it's null leave it null\n           // note: this may fail if value was not included in the dictionary\n           Object encoded = lookUps.get(value);\n           if (encoded == null) {\n             throw new IllegalArgumentException(\"Dictionary encoding not defined for value:\" + value);\n           }\n-          setter.invoke(mutator, i, encoded);\n+          setter.invoke(indices, i, encoded);\n         }\n       }\n     } catch (IllegalAccessException e) {\n@@ -101,7 +98,7 @@ public static ValueVector encode(ValueVector vector, Dictionary dictionary) {\n       throw new RuntimeException(\"InvocationTargetException invoking vector mutator set():\", e.getCause());\n     }\n \n-    mutator.setValueCount(count);\n+    indices.setValueCount(count);\n \n     return indices;\n   }\n@@ -114,15 +111,14 @@ public static ValueVector encode(ValueVector vector, Dictionary dictionary) {\n    * @return vector with values restored from dictionary\n    */\n   public static ValueVector decode(ValueVector indices, Dictionary dictionary) {\n-    ValueVector.Accessor accessor = indices.getAccessor();\n-    int count = accessor.getValueCount();\n+    int count = indices.getValueCount();\n     ValueVector dictionaryVector = dictionary.getVector();\n-    int dictionaryCount = dictionaryVector.getAccessor().getValueCount();\n+    int dictionaryCount = dictionaryVector.getValueCount();\n     // copy the dictionary values into the decoded vector\n     TransferPair transfer = dictionaryVector.getTransferPair(indices.getAllocator());\n     transfer.getTo().allocateNewSafe();\n     for (int i = 0; i < count; i++) {\n-      Object index = accessor.getObject(i);\n+      Object index = indices.getObject(i);\n       if (index != null) {\n         int indexAsInt = ((Number) index).intValue();\n         if (indexAsInt > dictionaryCount) {\n@@ -133,7 +129,7 @@ public static ValueVector decode(ValueVector indices, Dictionary dictionary) {\n     }\n     // TODO do we need to worry about the field?\n     ValueVector decoded = transfer.getTo();\n-    decoded.getMutator().setValueCount(count);\n+    decoded.setValueCount(count);\n     return decoded;\n   }\n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/file/ArrowWriter.java b/java/vector/src/main/java/org/apache/arrow/vector/file/ArrowWriter.java\nindex b35aba542..7dc10b5e6 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/file/ArrowWriter.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/file/ArrowWriter.java\n@@ -82,7 +82,7 @@ protected ArrowWriter(VectorSchemaRoot root, DictionaryProvider provider, Writab\n     for (long id : dictionaryIdsUsed) {\n       Dictionary dictionary = provider.lookup(id);\n       FieldVector vector = dictionary.getVector();\n-      int count = vector.getAccessor().getValueCount();\n+      int count = vector.getValueCount();\n       VectorSchemaRoot dictRoot = new VectorSchemaRoot(ImmutableList.of(vector.getField()), ImmutableList.of(vector), count);\n       VectorUnloader unloader = new VectorUnloader(dictRoot);\n       ArrowRecordBatch batch = unloader.getRecordBatch();\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileReader.java b/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileReader.java\nindex 27781f577..c6a82510e 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileReader.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileReader.java\n@@ -23,55 +23,22 @@\n import static com.fasterxml.jackson.core.JsonToken.START_ARRAY;\n import static com.fasterxml.jackson.core.JsonToken.START_OBJECT;\n import static java.nio.charset.StandardCharsets.UTF_8;\n-import static org.apache.arrow.vector.schema.ArrowVectorType.OFFSET;\n+import static org.apache.arrow.vector.schema.ArrowVectorType.*;\n \n import java.io.File;\n import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n+import java.util.*;\n \n import com.google.common.collect.ImmutableList;\n+import io.netty.buffer.ArrowBuf;\n import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.vector.BigIntVector;\n-import org.apache.arrow.vector.BitVector;\n-import org.apache.arrow.vector.BufferBacked;\n-import org.apache.arrow.vector.DateDayVector;\n-import org.apache.arrow.vector.DateMilliVector;\n-import org.apache.arrow.vector.DecimalVector;\n-import org.apache.arrow.vector.FieldVector;\n-import org.apache.arrow.vector.Float4Vector;\n-import org.apache.arrow.vector.Float8Vector;\n-import org.apache.arrow.vector.IntVector;\n-import org.apache.arrow.vector.NullableVarBinaryVector;\n-import org.apache.arrow.vector.NullableVarCharVector;\n-import org.apache.arrow.vector.SmallIntVector;\n-import org.apache.arrow.vector.TimeMicroVector;\n-import org.apache.arrow.vector.TimeMilliVector;\n-import org.apache.arrow.vector.TimeNanoVector;\n-import org.apache.arrow.vector.TimeSecVector;\n-import org.apache.arrow.vector.TimeStampMicroTZVector;\n-import org.apache.arrow.vector.TimeStampMicroVector;\n-import org.apache.arrow.vector.TimeStampMilliTZVector;\n-import org.apache.arrow.vector.TimeStampMilliVector;\n-import org.apache.arrow.vector.TimeStampNanoTZVector;\n-import org.apache.arrow.vector.TimeStampNanoVector;\n-import org.apache.arrow.vector.TimeStampSecTZVector;\n-import org.apache.arrow.vector.TimeStampSecVector;\n-import org.apache.arrow.vector.TinyIntVector;\n-import org.apache.arrow.vector.UInt1Vector;\n-import org.apache.arrow.vector.UInt2Vector;\n-import org.apache.arrow.vector.UInt4Vector;\n-import org.apache.arrow.vector.UInt8Vector;\n-import org.apache.arrow.vector.ValueVector;\n-import org.apache.arrow.vector.VarBinaryVector;\n-import org.apache.arrow.vector.VarCharVector;\n-import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.*;\n import org.apache.arrow.vector.complex.ListVector;\n import org.apache.arrow.vector.dictionary.Dictionary;\n import org.apache.arrow.vector.dictionary.DictionaryProvider;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n import org.apache.arrow.vector.schema.ArrowVectorType;\n+import org.apache.arrow.vector.types.Types;\n import org.apache.arrow.vector.types.pojo.Field;\n import org.apache.arrow.vector.types.pojo.Schema;\n import org.apache.arrow.vector.util.DecimalUtility;\n@@ -151,7 +118,7 @@ private void readDictionaryBatches() throws JsonParseException, IOException {\n       FieldVector vector = dict.getVector();\n       List<Field> fields = ImmutableList.of(vector.getField());\n       List<FieldVector> vectors = ImmutableList.of(vector);\n-      VectorSchemaRoot root = new VectorSchemaRoot(fields, vectors, vector.getAccessor().getValueCount());\n+      VectorSchemaRoot root = new VectorSchemaRoot(fields, vectors, vector.getValueCount());\n       read(root);\n \n       readToken(END_OBJECT);\n@@ -175,7 +142,7 @@ public boolean read(VectorSchemaRoot root) throws IOException {\n         {\n           for (Field field : root.getSchema().getFields()) {\n             FieldVector vector = root.getVector(field.getName());\n-            readVector(field, vector);\n+            readFromJsonIntoVector(field, vector);\n           }\n         }\n         readToken(END_ARRAY);\n@@ -202,7 +169,7 @@ public VectorSchemaRoot read() throws IOException {\n         {\n           for (Field field : schema.getFields()) {\n             FieldVector vector = recordBatch.getVector(field.getName());\n-            readVector(field, vector);\n+            readFromJsonIntoVector(field, vector);\n           }\n         }\n         readToken(END_ARRAY);\n@@ -216,16 +183,24 @@ public VectorSchemaRoot read() throws IOException {\n     }\n   }\n \n-  /**\n-   * TODO: A better way of implementing this function is to use `loadFieldBuffers` methods in\n-   * FieldVector to set the inner-vector data as done in `ArrowFileReader`.\n-   */\n-  private void readVector(Field field, FieldVector vector) throws JsonParseException, IOException {\n+  private void readFromJsonIntoVector(Field field, FieldVector vector) throws JsonParseException, IOException {\n     List<ArrowVectorType> vectorTypes = field.getTypeLayout().getVectorTypes();\n-    List<BufferBacked> fieldInnerVectors = vector.getFieldInnerVectors();\n-    if (vectorTypes.size() != fieldInnerVectors.size()) {\n-      throw new IllegalArgumentException(\"vector types and inner vectors are not the same size: \" + vectorTypes.size() + \" != \" + fieldInnerVectors.size());\n-    }\n+    ArrowBuf[] vectorBuffers = new ArrowBuf[vectorTypes.size()];\n+    /*\n+     * The order of inner buffers is :\n+     * Fixed width vector:\n+     *    -- validity buffer\n+     *    -- data buffer\n+     * Variable width vector:\n+     *    -- validity buffer\n+     *    -- offset buffer\n+     *    -- data buffer\n+     *\n+     * This is similar to what getFieldInnerVectors() used to give but now that we don't have\n+     * inner vectors anymore, we will work directly at the buffer level -- populate buffers\n+     * locally as we read from Json parser and do loadFieldBuffers on the vector followed by\n+     * releasing the local buffers.\n+     */\n     readToken(START_OBJECT);\n     {\n       // If currently reading dictionaries, field name is not important so don't check\n@@ -234,39 +209,41 @@ private void readVector(Field field, FieldVector vector) throws JsonParseExcepti\n         throw new IllegalArgumentException(\"Expected field \" + field.getName() + \" but got \" + name);\n       }\n \n-      // Initialize the vector with required capacity\n-      int count = readNextField(\"count\", Integer.class);\n-      vector.setInitialCapacity(count);\n-      vector.allocateNew();\n+      /* Initialize the vector with required capacity but don't allocate since we would\n+       * be doing loadFieldBuffers.\n+       */\n+      int valueCount = readNextField(\"count\", Integer.class);\n+      vector.setInitialCapacity(valueCount);\n \n-      // Read inner vectors\n       for (int v = 0; v < vectorTypes.size(); v++) {\n         ArrowVectorType vectorType = vectorTypes.get(v);\n-        ValueVector valueVector = (ValueVector) fieldInnerVectors.get(v);\n         nextFieldIs(vectorType.getName());\n         readToken(START_ARRAY);\n-        int innerVectorCount = vectorType.equals(OFFSET) ? count + 1 : count;\n-        for (int i = 0; i < innerVectorCount; i++) {\n+        int innerBufferValueCount = valueCount;\n+        if (vectorType.equals(OFFSET)) {\n+          /* offset buffer has 1 additional value capacity */\n+          innerBufferValueCount = valueCount + 1;\n+        }\n+        for (int i = 0; i < innerBufferValueCount; i++) {\n+          /* write data to the buffer */\n           parser.nextToken();\n-          setValueFromParser(valueVector, i);\n+          /* for variable width vectors, value count doesn't help pre-determining the capacity of\n+           * the underlying data buffer. So we need to pass down the offset buffer (which was already\n+           * populated in the previous iteration of this loop).\n+           */\n+          if (vectorType.equals(DATA) && (vector.getMinorType() == Types.MinorType.VARCHAR\n+                  || vector.getMinorType() == Types.MinorType.VARBINARY)) {\n+            vectorBuffers[v] = setValueFromParser(vectorType, vector, vectorBuffers[v],\n+                    vectorBuffers[v-1], i, innerBufferValueCount);\n+          } else {\n+            vectorBuffers[v] = setValueFromParser(vectorType, vector, vectorBuffers[v],\n+                    null, i, innerBufferValueCount);\n+          }\n         }\n         readToken(END_ARRAY);\n       }\n \n-      // Set lastSet before valueCount to prevent setValueCount from filling empty values\n-      switch (vector.getMinorType()) {\n-        case LIST:\n-          // ListVector starts lastSet from index 0, so lastSet value is always last index written + 1\n-          ((ListVector) vector).getMutator().setLastSet(count);\n-          break;\n-        case VARBINARY:\n-          ((NullableVarBinaryVector) vector).getMutator().setLastSet(count - 1);\n-          break;\n-        case VARCHAR:\n-          ((NullableVarCharVector) vector).setLastSet(count - 1);\n-          break;\n-      }\n-      vector.getMutator().setValueCount(count);\n+      vector.loadFieldBuffers(new ArrowFieldNode(valueCount, 0), Arrays.asList(vectorBuffers));\n \n       // read child vectors, if any\n       List<Field> fields = field.getChildren();\n@@ -280,12 +257,16 @@ private void readVector(Field field, FieldVector vector) throws JsonParseExcepti\n         for (int i = 0; i < fields.size(); i++) {\n           Field childField = fields.get(i);\n           FieldVector childVector = vectorChildren.get(i);\n-          readVector(childField, childVector);\n+          readFromJsonIntoVector(childField, childVector);\n         }\n         readToken(END_ARRAY);\n       }\n     }\n     readToken(END_OBJECT);\n+\n+    for (ArrowBuf buffer: vectorBuffers) {\n+      buffer.release();\n+    }\n   }\n \n   private byte[] decodeHexSafe(String hexString) throws IOException {\n@@ -296,98 +277,123 @@ private void readVector(Field field, FieldVector vector) throws JsonParseExcepti\n     }\n   }\n \n-  private void setValueFromParser(ValueVector valueVector, int i) throws IOException {\n-    switch (valueVector.getMinorType()) {\n-      case BIT:\n-        ((BitVector) valueVector).getMutator().set(i, parser.readValueAs(Boolean.class) ? 1 : 0);\n-        break;\n-      case TINYINT:\n-        ((TinyIntVector) valueVector).getMutator().set(i, parser.readValueAs(Integer.class));\n-        break;\n-      case SMALLINT:\n-        ((SmallIntVector) valueVector).getMutator().set(i, parser.readValueAs(Integer.class));\n-        break;\n-      case INT:\n-        ((IntVector) valueVector).getMutator().set(i, parser.readValueAs(Integer.class));\n-        break;\n-      case BIGINT:\n-        ((BigIntVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case UINT1:\n-        ((UInt1Vector) valueVector).getMutator().set(i, parser.readValueAs(Integer.class));\n-        break;\n-      case UINT2:\n-        ((UInt2Vector) valueVector).getMutator().set(i, parser.readValueAs(Integer.class));\n-        break;\n-      case UINT4:\n-        ((UInt4Vector) valueVector).getMutator().set(i, parser.readValueAs(Integer.class));\n-        break;\n-      case UINT8:\n-        ((UInt8Vector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case FLOAT4:\n-        ((Float4Vector) valueVector).getMutator().set(i, parser.readValueAs(Float.class));\n-        break;\n-      case FLOAT8:\n-        ((Float8Vector) valueVector).getMutator().set(i, parser.readValueAs(Double.class));\n-        break;\n-      case DECIMAL: {\n-          DecimalVector decimalVector = ((DecimalVector) valueVector);\n-          byte[] value = decodeHexSafe(parser.readValueAs(String.class));\n-          DecimalUtility.writeByteArrayToArrowBuf(value, decimalVector.getBuffer(), i);\n-        }\n-        break;\n-      case VARBINARY:\n-        ((VarBinaryVector) valueVector).getMutator().setSafe(i, decodeHexSafe(parser.readValueAs(String.class)));\n-        break;\n-      case VARCHAR:\n-        ((VarCharVector) valueVector).getMutator().setSafe(i, parser.readValueAs(String.class).getBytes(UTF_8));\n-        break;\n-      case DATEDAY:\n-        ((DateDayVector) valueVector).getMutator().set(i, parser.readValueAs(Integer.class));\n-        break;\n-      case DATEMILLI:\n-        ((DateMilliVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMESEC:\n-        ((TimeSecVector) valueVector).getMutator().set(i, parser.readValueAs(Integer.class));\n-        break;\n-      case TIMEMILLI:\n-        ((TimeMilliVector) valueVector).getMutator().set(i, parser.readValueAs(Integer.class));\n-        break;\n-      case TIMEMICRO:\n-        ((TimeMicroVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMENANO:\n-        ((TimeNanoVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMESTAMPSEC:\n-        ((TimeStampSecVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMESTAMPMILLI:\n-        ((TimeStampMilliVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMESTAMPMICRO:\n-        ((TimeStampMicroVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMESTAMPNANO:\n-        ((TimeStampNanoVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMESTAMPSECTZ:\n-        ((TimeStampSecTZVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMESTAMPMILLITZ:\n-        ((TimeStampMilliTZVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMESTAMPMICROTZ:\n-        ((TimeStampMicroTZVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      case TIMESTAMPNANOTZ:\n-        ((TimeStampNanoTZVector) valueVector).getMutator().set(i, parser.readValueAs(Long.class));\n-        break;\n-      default:\n-        throw new UnsupportedOperationException(\"minor type: \" + valueVector.getMinorType());\n+  private ArrowBuf setValueFromParser(ArrowVectorType bufferType, FieldVector vector,\n+                                      ArrowBuf buffer, ArrowBuf offsetBuffer, int index, int valueCount) throws IOException {\n+    if (bufferType.equals(TYPE)) {\n+      buffer = NullableTinyIntVector.set(buffer, allocator,\n+              valueCount, index, parser.readValueAs(Byte.class));\n+    } else if (bufferType.equals(OFFSET)) {\n+      buffer = BaseNullableVariableWidthVector.set(buffer, allocator,\n+              valueCount, index, parser.readValueAs(Integer.class));\n+    } else if (bufferType.equals(VALIDITY)) {\n+      buffer = BitVectorHelper.setValidityBit(buffer, allocator,\n+              valueCount, index, parser.readValueAs(Boolean.class) ? 1 : 0);\n+    } else if (bufferType.equals(DATA)) {\n+      switch (vector.getMinorType()) {\n+        case BIT:\n+          buffer = BitVectorHelper.setValidityBit(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Boolean.class) ? 1 : 0);\n+          break;\n+        case TINYINT:\n+          buffer = NullableTinyIntVector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Byte.class));\n+          break;\n+        case SMALLINT:\n+          buffer = NullableSmallIntVector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Short.class));\n+          break;\n+        case INT:\n+          buffer = NullableIntVector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Integer.class));\n+          break;\n+        case BIGINT:\n+          buffer = NullableBigIntVector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Long.class));\n+          break;\n+        case FLOAT4:\n+          buffer = NullableFloat4Vector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Float.class));\n+          break;\n+        case FLOAT8:\n+          buffer = NullableFloat8Vector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Double.class));\n+          break;\n+        case DECIMAL:\n+          buffer = NullableDecimalVector.set(buffer, allocator,\n+                  valueCount, index, decodeHexSafe(parser.readValueAs(String.class)));\n+          break;\n+        case VARBINARY:\n+          assert (offsetBuffer != null);\n+          buffer = BaseNullableVariableWidthVector.set(buffer, offsetBuffer, allocator, index,\n+                  decodeHexSafe(parser.readValueAs(String.class)), valueCount);\n+          break;\n+        case VARCHAR:\n+          assert (offsetBuffer != null);\n+          buffer = BaseNullableVariableWidthVector.set(buffer, offsetBuffer, allocator, index,\n+                  parser.readValueAs(String.class).getBytes(UTF_8), valueCount);\n+          break;\n+        case DATEDAY:\n+          buffer = NullableDateDayVector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Integer.class));\n+          break;\n+        case DATEMILLI:\n+          buffer = NullableDateMilliVector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Long.class));\n+          break;\n+        case TIMESEC:\n+          buffer = NullableTimeSecVector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Integer.class));\n+          break;\n+        case TIMEMILLI:\n+          buffer = NullableTimeMilliVector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Integer.class));\n+          break;\n+        case TIMEMICRO:\n+          buffer = NullableTimeMicroVector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Long.class));\n+          break;\n+        case TIMENANO:\n+          buffer = NullableTimeNanoVector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Long.class));\n+          break;\n+        case TIMESTAMPSEC:\n+          buffer = NullableTimeStampSecVector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Long.class));\n+          break;\n+        case TIMESTAMPMILLI:\n+          buffer = NullableTimeStampMilliVector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Long.class));\n+          break;\n+        case TIMESTAMPMICRO:\n+          buffer = NullableTimeStampMicroVector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Long.class));\n+          break;\n+        case TIMESTAMPNANO:\n+          buffer = NullableTimeStampNanoVector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Long.class));\n+          break;\n+        case TIMESTAMPSECTZ:\n+          buffer = NullableTimeStampSecTZVector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Long.class));\n+          break;\n+        case TIMESTAMPMILLITZ:\n+          buffer = NullableTimeStampMilliTZVector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Long.class));\n+          break;\n+        case TIMESTAMPMICROTZ:\n+          buffer = NullableTimeStampMicroTZVector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Long.class));\n+          break;\n+        case TIMESTAMPNANOTZ:\n+          buffer = NullableTimeStampNanoTZVector.set(buffer, allocator,\n+                  valueCount, index, parser.readValueAs(Long.class));\n+          break;\n+        default:\n+          throw new UnsupportedOperationException(\"minor type: \" + vector.getMinorType());\n+      }\n     }\n+\n+    return buffer;\n   }\n \n   @Override\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileWriter.java b/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileWriter.java\nindex 04e44379e..d3aa1770e 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileWriter.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileWriter.java\n@@ -18,6 +18,9 @@\n \n package org.apache.arrow.vector.file.json;\n \n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.apache.arrow.vector.schema.ArrowVectorType.*;\n+\n import java.io.File;\n import java.io.IOException;\n import java.util.ArrayList;\n@@ -27,27 +30,12 @@\n \n import com.google.common.collect.ImmutableList;\n import io.netty.buffer.ArrowBuf;\n-import org.apache.arrow.vector.BitVector;\n-import org.apache.arrow.vector.BufferBacked;\n-import org.apache.arrow.vector.DateDayVector;\n-import org.apache.arrow.vector.DateMilliVector;\n-import org.apache.arrow.vector.DecimalVector;\n-import org.apache.arrow.vector.FieldVector;\n-import org.apache.arrow.vector.TimeMicroVector;\n-import org.apache.arrow.vector.TimeMilliVector;\n-import org.apache.arrow.vector.TimeNanoVector;\n-import org.apache.arrow.vector.TimeSecVector;\n-import org.apache.arrow.vector.TimeStampMicroVector;\n-import org.apache.arrow.vector.TimeStampMilliVector;\n-import org.apache.arrow.vector.TimeStampNanoVector;\n-import org.apache.arrow.vector.TimeStampSecVector;\n-import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.*;\n import org.apache.arrow.vector.ValueVector.Accessor;\n-import org.apache.arrow.vector.VarBinaryVector;\n-import org.apache.arrow.vector.VectorSchemaRoot;\n import org.apache.arrow.vector.dictionary.Dictionary;\n import org.apache.arrow.vector.dictionary.DictionaryProvider;\n import org.apache.arrow.vector.schema.ArrowVectorType;\n+import org.apache.arrow.vector.types.Types;\n import org.apache.arrow.vector.types.pojo.Field;\n import org.apache.arrow.vector.types.pojo.Schema;\n \n@@ -133,7 +121,7 @@ private void writeDictionaryBatches(JsonGenerator generator, Set<Long> dictionar\n       FieldVector vector = dictionary.getVector();\n       List<Field> fields = ImmutableList.of(vector.getField());\n       List<FieldVector> vectors = ImmutableList.of(vector);\n-      VectorSchemaRoot root = new VectorSchemaRoot(fields, vectors, vector.getAccessor().getValueCount());\n+      VectorSchemaRoot root = new VectorSchemaRoot(fields, vectors, vector.getValueCount());\n       writeBatch(root);\n \n       generator.writeEndObject();\n@@ -155,31 +143,36 @@ private void writeBatch(VectorSchemaRoot recordBatch) throws IOException {\n       generator.writeArrayFieldStart(\"columns\");\n       for (Field field : recordBatch.getSchema().getFields()) {\n         FieldVector vector = recordBatch.getVector(field.getName());\n-        writeVector(field, vector);\n+        writeFromVectorIntoJson(field, vector);\n       }\n       generator.writeEndArray();\n     }\n     generator.writeEndObject();\n   }\n \n-  private void writeVector(Field field, FieldVector vector) throws IOException {\n+  private void writeFromVectorIntoJson(Field field, FieldVector vector) throws IOException {\n     List<ArrowVectorType> vectorTypes = field.getTypeLayout().getVectorTypes();\n-    List<BufferBacked> fieldInnerVectors = vector.getFieldInnerVectors();\n-    if (vectorTypes.size() != fieldInnerVectors.size()) {\n-      throw new IllegalArgumentException(\"vector types and inner vectors are not the same size: \" + vectorTypes.size() + \" != \" + fieldInnerVectors.size());\n+    List<ArrowBuf> vectorBuffers = vector.getFieldBuffers();\n+    if (vectorTypes.size() != vectorBuffers.size()) {\n+      throw new IllegalArgumentException(\"vector types and inner vector buffers are not the same size: \" + vectorTypes.size() + \" != \" + vectorBuffers.size());\n     }\n     generator.writeStartObject();\n     {\n       generator.writeObjectField(\"name\", field.getName());\n-      int valueCount = vector.getAccessor().getValueCount();\n+      int valueCount = vector.getValueCount();\n       generator.writeObjectField(\"count\", valueCount);\n       for (int v = 0; v < vectorTypes.size(); v++) {\n         ArrowVectorType vectorType = vectorTypes.get(v);\n-        BufferBacked innerVector = fieldInnerVectors.get(v);\n+        ArrowBuf vectorBuffer = vectorBuffers.get(v);\n         generator.writeArrayFieldStart(vectorType.getName());\n-        ValueVector valueVector = (ValueVector) innerVector;\n-        for (int i = 0; i < valueVector.getAccessor().getValueCount(); i++) {\n-          writeValueToGenerator(valueVector, i);\n+        final int bufferValueCount = (vectorType.equals(OFFSET)) ? valueCount + 1 : valueCount;\n+        for (int i = 0; i < bufferValueCount; i++) {\n+          if (vectorType.equals(DATA) && (vector.getMinorType() == Types.MinorType.VARCHAR ||\n+                  vector.getMinorType() == Types.MinorType.VARBINARY)) {\n+            writeValueToGenerator(vectorType, vectorBuffer, vectorBuffers.get(v-1), vector, i);\n+          } else {\n+            writeValueToGenerator(vectorType, vectorBuffer, null, vector, i);\n+          }\n         }\n         generator.writeEndArray();\n       }\n@@ -193,7 +186,7 @@ private void writeVector(Field field, FieldVector vector) throws IOException {\n         for (int i = 0; i < fields.size(); i++) {\n           Field childField = fields.get(i);\n           FieldVector childVector = children.get(i);\n-          writeVector(childField, childVector);\n+          writeFromVectorIntoJson(childField, childVector);\n         }\n         generator.writeEndArray();\n       }\n@@ -201,62 +194,99 @@ private void writeVector(Field field, FieldVector vector) throws IOException {\n     generator.writeEndObject();\n   }\n \n-  private void writeValueToGenerator(ValueVector valueVector, int i) throws IOException {\n-    switch (valueVector.getMinorType()) {\n-      case DATEDAY:\n-        generator.writeNumber(((DateDayVector) valueVector).getAccessor().get(i));\n-        break;\n-      case DATEMILLI:\n-        generator.writeNumber(((DateMilliVector) valueVector).getAccessor().get(i));\n-        break;\n-      case TIMESEC:\n-        generator.writeNumber(((TimeSecVector) valueVector).getAccessor().get(i));\n-        break;\n-      case TIMEMILLI:\n-        generator.writeNumber(((TimeMilliVector) valueVector).getAccessor().get(i));\n-        break;\n-      case TIMEMICRO:\n-        generator.writeNumber(((TimeMicroVector) valueVector).getAccessor().get(i));\n-        break;\n-      case TIMENANO:\n-        generator.writeNumber(((TimeNanoVector) valueVector).getAccessor().get(i));\n-        break;\n-      case TIMESTAMPSEC:\n-        generator.writeNumber(((TimeStampSecVector) valueVector).getAccessor().get(i));\n-        break;\n-      case TIMESTAMPMILLI:\n-        generator.writeNumber(((TimeStampMilliVector) valueVector).getAccessor().get(i));\n-        break;\n-      case TIMESTAMPMICRO:\n-        generator.writeNumber(((TimeStampMicroVector) valueVector).getAccessor().get(i));\n-        break;\n-      case TIMESTAMPNANO:\n-        generator.writeNumber(((TimeStampNanoVector) valueVector).getAccessor().get(i));\n-        break;\n-      case BIT:\n-        generator.writeNumber(((BitVector) valueVector).getAccessor().get(i));\n-        break;\n-      case VARBINARY: {\n-          String hexString = Hex.encodeHexString(((VarBinaryVector) valueVector).getAccessor().get(i));\n-          generator.writeString(hexString);\n+  private void writeValueToGenerator(ArrowVectorType bufferType, ArrowBuf buffer,\n+                                     ArrowBuf offsetBuffer, FieldVector vector, int index) throws IOException {\n+    if (bufferType.equals(TYPE)) {\n+      generator.writeNumber(buffer.getByte(index * NullableTinyIntVector.TYPE_WIDTH));\n+    } else if (bufferType.equals(OFFSET)) {\n+      generator.writeNumber(buffer.getInt(index * BaseNullableVariableWidthVector.OFFSET_WIDTH));\n+    } else if(bufferType.equals(VALIDITY)) {\n+      generator.writeNumber(vector.isNull(index) ? 0 : 1);\n+    } else if (bufferType.equals(DATA)) {\n+      switch (vector.getMinorType()) {\n+        case TINYINT:\n+          generator.writeNumber(NullableTinyIntVector.get(buffer, index));\n+          break;\n+        case SMALLINT:\n+          generator.writeNumber(NullableSmallIntVector.get(buffer, index));\n+          break;\n+        case INT:\n+          generator.writeNumber(NullableIntVector.get(buffer, index));\n+          break;\n+        case BIGINT:\n+          generator.writeNumber(NullableBigIntVector.get(buffer, index));\n+          break;\n+        case FLOAT4:\n+          generator.writeNumber(NullableFloat4Vector.get(buffer, index));\n+          break;\n+        case FLOAT8:\n+          generator.writeNumber(NullableFloat8Vector.get(buffer, index));\n+          break;\n+        case DATEDAY:\n+          generator.writeNumber(NullableDateDayVector.get(buffer, index));\n+          break;\n+        case DATEMILLI:\n+          generator.writeNumber(NullableDateMilliVector.get(buffer, index));\n+          break;\n+        case TIMESEC:\n+          generator.writeNumber(NullableTimeSecVector.get(buffer, index));\n+          break;\n+        case TIMEMILLI:\n+          generator.writeNumber(NullableTimeMilliVector.get(buffer, index));\n+          break;\n+        case TIMEMICRO:\n+          generator.writeNumber(NullableTimeMicroVector.get(buffer, index));\n+          break;\n+        case TIMENANO:\n+          generator.writeNumber(NullableTimeNanoVector.get(buffer, index));\n+          break;\n+        case TIMESTAMPSEC:\n+          generator.writeNumber(NullableTimeStampSecVector.get(buffer, index));\n+          break;\n+        case TIMESTAMPMILLI:\n+          generator.writeNumber(NullableTimeStampMilliVector.get(buffer, index));\n+          break;\n+        case TIMESTAMPMICRO:\n+          generator.writeNumber(NullableTimeStampMicroVector.get(buffer, index));\n+          break;\n+        case TIMESTAMPNANO:\n+          generator.writeNumber(NullableTimeStampNanoVector.get(buffer, index));\n+          break;\n+        case TIMESTAMPSECTZ:\n+          generator.writeNumber(NullableTimeStampSecTZVector.get(buffer, index));\n+          break;\n+        case TIMESTAMPMILLITZ:\n+          generator.writeNumber(NullableTimeStampMilliTZVector.get(buffer, index));\n+          break;\n+        case TIMESTAMPMICROTZ:\n+          generator.writeNumber(NullableTimeStampMicroTZVector.get(buffer, index));\n+          break;\n+        case TIMESTAMPNANOTZ:\n+          generator.writeNumber(NullableTimeStampNanoTZVector.get(buffer, index));\n+          break;\n+        case BIT:\n+          generator.writeNumber(BitVectorHelper.get(buffer, index));\n+          break;\n+        case VARBINARY: {\n+          assert offsetBuffer != null;\n+          String hexString = Hex.encodeHexString(BaseNullableVariableWidthVector.get(buffer, offsetBuffer, index));\n+          generator.writeObject(hexString);\n+          break;\n         }\n-        break;\n-      case DECIMAL: {\n-          ArrowBuf bytebuf = valueVector.getDataBuffer();\n-          String hexString = Hex.encodeHexString(DecimalUtility.getByteArrayFromArrowBuf(bytebuf, i));\n-          generator.writeString(hexString);\n+        case VARCHAR: {\n+          assert offsetBuffer != null;\n+          byte[] b = (BaseNullableVariableWidthVector.get(buffer, offsetBuffer, index));\n+          generator.writeString(new String(b, \"UTF-8\"));\n+          break;\n         }\n-        break;\n-      default:\n-        // TODO: each type\n-        Accessor accessor = valueVector.getAccessor();\n-        Object value = accessor.getObject(i);\n-        if (value instanceof Number || value instanceof Boolean) {\n-          generator.writeObject(value);\n-        } else {\n-          generator.writeObject(value.toString());\n+        case DECIMAL: {\n+          String hexString = Hex.encodeHexString(DecimalUtility.getByteArrayFromArrowBuf(buffer, index));\n+          generator.writeString(hexString);\n+          break;\n         }\n-        break;\n+        default:\n+          throw new UnsupportedOperationException(\"minor type: \" + vector.getMinorType());\n+      }\n     }\n   }\n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/util/Validator.java b/java/vector/src/main/java/org/apache/arrow/vector/util/Validator.java\nindex 5851bd5fa..c27e5e5c8 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/util/Validator.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/util/Validator.java\n@@ -114,13 +114,13 @@ public static void compareFieldVectors(FieldVector vector1, FieldVector vector2)\n     if (!field1.equals(vector2.getField())) {\n       throw new IllegalArgumentException(\"Different Fields:\\n\" + field1 + \"\\n!=\\n\" + vector2.getField());\n     }\n-    int valueCount = vector1.getAccessor().getValueCount();\n-    if (valueCount != vector2.getAccessor().getValueCount()) {\n-      throw new IllegalArgumentException(\"Different value count for field \" + field1 + \" : \" + valueCount + \" != \" + vector2.getAccessor().getValueCount());\n+    int valueCount = vector1.getValueCount();\n+    if (valueCount != vector2.getValueCount()) {\n+      throw new IllegalArgumentException(\"Different value count for field \" + field1 + \" : \" + valueCount + \" != \" + vector2.getValueCount());\n     }\n     for (int j = 0; j < valueCount; j++) {\n-      Object obj1 = vector1.getAccessor().getObject(j);\n-      Object obj2 = vector2.getAccessor().getObject(j);\n+      Object obj1 = vector1.getObject(j);\n+      Object obj2 = vector2.getObject(j);\n       if (!equals(field1.getType(), obj1, obj2)) {\n         throw new IllegalArgumentException(\n             \"Different values in column:\\n\" + field1 + \" at index \" + j + \": \" + obj1 + \" != \" + obj2);\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\nindex 17fcf05fc..ada341497 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n@@ -340,59 +340,56 @@ public void testReallocAfterVectorTransfer2() {\n       int valueCapacity = vector.getValueCapacity();\n       assertEquals(4096, valueCapacity);\n \n-      final NullableBitVector.Mutator mutator = vector.getMutator();\n-      final NullableBitVector.Accessor accessor = vector.getAccessor();\n-\n       for (int i = 0; i < valueCapacity; i++) {\n         if ((i & 1) == 1) {\n-          mutator.set(i, 1);\n+          vector.set(i, 1);\n         }\n       }\n \n       for (int i = 0; i < valueCapacity; i++) {\n         if ((i & 1) == 1) {\n-          assertFalse(\"unexpected cleared bit at index: \" + i, accessor.isNull(i));\n+          assertFalse(\"unexpected cleared bit at index: \" + i, vector.isNull(i));\n         }\n         else {\n-          assertTrue(\"unexpected set bit at index: \" + i, accessor.isNull(i));\n+          assertTrue(\"unexpected set bit at index: \" + i, vector.isNull(i));\n         }\n       }\n \n       /* trigger first realloc */\n-      mutator.setSafe(valueCapacity, 1, 1);\n+      vector.setSafe(valueCapacity, 1, 1);\n       assertEquals(valueCapacity * 2, vector.getValueCapacity());\n \n       for (int i = valueCapacity; i < valueCapacity*2; i++) {\n         if ((i & 1) == 1) {\n-          mutator.set(i, 1);\n+          vector.set(i, 1);\n         }\n       }\n \n       for (int i = 0; i < valueCapacity*2; i++) {\n         if (((i & 1) == 1) || (i == valueCapacity)) {\n-          assertFalse(\"unexpected cleared bit at index: \" + i, accessor.isNull(i));\n+          assertFalse(\"unexpected cleared bit at index: \" + i, vector.isNull(i));\n         }\n         else {\n-          assertTrue(\"unexpected set bit at index: \" + i, accessor.isNull(i));\n+          assertTrue(\"unexpected set bit at index: \" + i, vector.isNull(i));\n         }\n       }\n \n       /* trigger second realloc */\n-      mutator.setSafe(valueCapacity*2, 1, 1);\n+      vector.setSafe(valueCapacity*2, 1, 1);\n       assertEquals(valueCapacity * 4, vector.getValueCapacity());\n \n       for (int i = valueCapacity*2; i < valueCapacity*4; i++) {\n         if ((i & 1) == 1) {\n-          mutator.set(i, 1);\n+          vector.set(i, 1);\n         }\n       }\n \n       for (int i = 0; i < valueCapacity*4; i++) {\n         if (((i & 1) == 1) || (i == valueCapacity) || (i == valueCapacity*2)) {\n-          assertFalse(\"unexpected cleared bit at index: \" + i, accessor.isNull(i));\n+          assertFalse(\"unexpected cleared bit at index: \" + i, vector.isNull(i));\n         }\n         else {\n-          assertTrue(\"unexpected set bit at index: \" + i, accessor.isNull(i));\n+          assertTrue(\"unexpected set bit at index: \" + i, vector.isNull(i));\n         }\n       }\n \n@@ -400,26 +397,24 @@ public void testReallocAfterVectorTransfer2() {\n       TransferPair transferPair = vector.getTransferPair(allocator);\n       transferPair.transfer();\n       final NullableBitVector toVector = (NullableBitVector)transferPair.getTo();\n-      final NullableBitVector.Accessor toAccessor = toVector.getAccessor();\n-      final NullableBitVector.Mutator toMutator = toVector.getMutator();\n \n       assertEquals(valueCapacity * 4, toVector.getValueCapacity());\n \n       /* realloc the toVector */\n-      toMutator.setSafe(valueCapacity * 4, 1, 1);\n+      toVector.setSafe(valueCapacity * 4, 1, 1);\n \n       for (int i = 0; i < toVector.getValueCapacity(); i++) {\n         if (i <= valueCapacity * 4) {\n           if (((i & 1) == 1) || (i == valueCapacity) ||\n                   (i == valueCapacity*2) || (i == valueCapacity*4)) {\n-            assertFalse(\"unexpected cleared bit at index: \" + i, toAccessor.isNull(i));\n+            assertFalse(\"unexpected cleared bit at index: \" + i, toVector.isNull(i));\n           }\n           else {\n-            assertTrue(\"unexpected set bit at index: \" + i, toAccessor.isNull(i));\n+            assertTrue(\"unexpected set bit at index: \" + i, toVector.isNull(i));\n           }\n         }\n         else {\n-          assertTrue(\"unexpected set bit at index: \" + i, toAccessor.isNull(i));\n+          assertTrue(\"unexpected set bit at index: \" + i, toVector.isNull(i));\n         }\n       }\n \ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestDecimalVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestDecimalVector.java\nindex 56d229327..4d844d6d3 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestDecimalVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestDecimalVector.java\n@@ -71,14 +71,14 @@ public void testValuesWriteRead() {\n       for (int i = 0; i < intValues.length; i++) {\n         BigDecimal decimal = new BigDecimal(BigInteger.valueOf(intValues[i]), scale);\n         values[i] = decimal;\n-        decimalVector.getMutator().setSafe(i, decimal);\n+        decimalVector.setSafe(i, decimal);\n       }\n \n-      decimalVector.getMutator().setValueCount(intValues.length);\n+      decimalVector.setValueCount(intValues.length);\n \n       for (int i = 0; i < intValues.length; i++) {\n-        BigDecimal value = decimalVector.getAccessor().getObject(i);\n-        assertEquals(values[i], value);\n+        BigDecimal value = decimalVector.getObject(i);\n+        assertEquals(\"unexpected data at index: \" + i, values[i], value);\n       }\n     }\n   }\n@@ -92,7 +92,7 @@ public void testBigDecimalDifferentScaleAndPrecision() {\n       boolean hasError = false;\n       try {\n         BigDecimal decimal = new BigDecimal(BigInteger.valueOf(0), 3);\n-        decimalVector.getMutator().setSafe(0, decimal);\n+        decimalVector.setSafe(0, decimal);\n       } catch (UnsupportedOperationException ue) {\n         hasError = true;\n       } finally {\n@@ -103,7 +103,7 @@ public void testBigDecimalDifferentScaleAndPrecision() {\n       hasError = false;\n       try {\n         BigDecimal decimal = new BigDecimal(BigInteger.valueOf(12345), 2);\n-        decimalVector.getMutator().setSafe(0, decimal);\n+        decimalVector.setSafe(0, decimal);\n       } catch (UnsupportedOperationException ue) {\n         hasError = true;\n       } finally {\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestDictionaryVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestDictionaryVector.java\nindex 1185246f8..46a2bafa0 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestDictionaryVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestDictionaryVector.java\n@@ -135,9 +135,9 @@ public void testEncodeLargeVector() {\n         // now run through the decoder and verify we get the original back\n         try (ValueVector decoded = DictionaryEncoder.decode(encoded, dictionary)) {\n           assertEquals(vector.getClass(), decoded.getClass());\n-          assertEquals(vector.getAccessor().getValueCount(), decoded.getAccessor().getValueCount());\n+          assertEquals(vector.getValueCount(), decoded.getValueCount());\n           for (int i = 0; i < count; ++i) {\n-            assertEquals(vector.getAccessor().getObject(i), decoded.getAccessor().getObject(i));\n+            assertEquals(vector.getObject(i), decoded.getObject(i));\n           }\n         }\n       }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java\nindex 11cd62da5..efa141461 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java\n@@ -56,7 +56,7 @@ public void testIntType() {\n       vector.allocateNew();\n \n       for (int i = 0; i < 10; i++) {\n-        vector.getMutator().setNotNull(i);\n+        vector.setNotNull(i);\n         nested.set(i * 2, i);\n         nested.set(i * 2 + 1, i + 10);\n       }\n@@ -80,17 +80,16 @@ public void testIntType() {\n   public void testFloatTypeNullable() {\n     try (FixedSizeListVector vector = FixedSizeListVector.empty(\"list\", 2, allocator)) {\n       NullableFloat4Vector nested = (NullableFloat4Vector) vector.addOrGetVector(FieldType.nullable(MinorType.FLOAT4.getType())).getVector();\n-      NullableFloat4Vector.Mutator mutator = nested.getMutator();\n       vector.allocateNew();\n \n       for (int i = 0; i < 10; i++) {\n         if (i % 2 == 0) {\n-          vector.getMutator().setNotNull(i);\n-          mutator.set(i * 2, i + 0.1f);\n-          mutator.set(i * 2 + 1, i + 10.1f);\n+          vector.setNotNull(i);\n+          nested.set(i * 2, i + 0.1f);\n+          nested.set(i * 2 + 1, i + 10.1f);\n         }\n       }\n-      vector.getMutator().setValueCount(10);\n+      vector.setValueCount(10);\n \n       UnionFixedSizeListReader reader = vector.getReader();\n       for (int i = 0; i < 10; i++) {\n@@ -114,24 +113,22 @@ public void testFloatTypeNullable() {\n   @Test\n   public void testNestedInList() {\n     try (ListVector vector = ListVector.empty(\"list\", allocator)) {\n-      ListVector.Mutator mutator = vector.getMutator();\n       FixedSizeListVector tuples = (FixedSizeListVector) vector.addOrGetVector(FieldType.nullable(new ArrowType.FixedSizeList(2))).getVector();\n-      FixedSizeListVector.Mutator tupleMutator = tuples.getMutator();\n       NullableIntVector innerVector = (NullableIntVector) tuples.addOrGetVector(FieldType.nullable(MinorType.INT.getType())).getVector();\n       vector.allocateNew();\n \n       for (int i = 0; i < 10; i++) {\n         if (i % 2 == 0) {\n-          int position = mutator.startNewValue(i);\n+          int position = vector.startNewValue(i);\n           for (int j = 0; j < i % 7; j++) {\n-            tupleMutator.setNotNull(position + j);\n+            tuples.setNotNull(position + j);\n             innerVector.set((position + j) * 2, j);\n             innerVector.set((position + j) * 2 + 1, j + 1);\n           }\n-          mutator.endValue(i, i % 7);\n+          vector.endValue(i, i % 7);\n         }\n       }\n-      mutator.setValueCount(10);\n+      vector.setValueCount(10);\n \n       UnionListReader reader = vector.getReader();\n       for (int i = 0; i < 10; i++) {\n@@ -160,24 +157,24 @@ public void testTransferPair() {\n     try (FixedSizeListVector from = new FixedSizeListVector(\"from\", allocator, 2, null, null);\n          FixedSizeListVector to = new FixedSizeListVector(\"to\", allocator, 2, null, null)) {\n       NullableFloat4Vector nested = (NullableFloat4Vector) from.addOrGetVector(FieldType.nullable(MinorType.FLOAT4.getType())).getVector();\n-      NullableFloat4Vector.Mutator mutator = nested.getMutator();\n       from.allocateNew();\n \n       for (int i = 0; i < 10; i++) {\n         if (i % 2 == 0) {\n-          from.getMutator().setNotNull(i);\n-          mutator.set(i * 2, i + 0.1f);\n-          mutator.set(i * 2 + 1, i + 10.1f);\n+          from.setNotNull(i);\n+          nested.set(i * 2, i + 0.1f);\n+          nested.set(i * 2 + 1, i + 10.1f);\n         }\n       }\n-      from.getMutator().setValueCount(10);\n+      from.setValueCount(10);\n \n       TransferPair pair = from.makeTransferPair(to);\n \n       pair.copyValueSafe(0, 1);\n       pair.copyValueSafe(2, 2);\n       to.copyFromSafe(4, 3, from);\n-      to.getMutator().setValueCount(10);\n+\n+      to.setValueCount(10);\n \n       UnionFixedSizeListReader reader = to.getReader();\n \ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestListVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestListVector.java\nindex 1c9b57499..2e55ccc3e 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestListVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestListVector.java\n@@ -88,7 +88,7 @@ public void testCopyFrom() throws Exception {\n       for (int i = 0; i < 3; i++) {\n         outVector.copyFrom(i, i, inVector);\n       }\n-      outVector.getMutator().setValueCount(3);\n+      outVector.setValueCount(3);\n \n       // assert the output vector is correct\n       FieldReader reader = outVector.getReader();\n@@ -98,11 +98,9 @@ public void testCopyFrom() throws Exception {\n       reader.setPosition(2);\n       Assert.assertTrue(\"shouldn't be null\", reader.isSet());\n \n-      /* check the exact contents of vector */\n-      final ListVector.Accessor accessor = outVector.getAccessor();\n \n       /* index 0 */\n-      Object result = accessor.getObject(0);\n+      Object result = outVector.getObject(0);\n       ArrayList<Long> resultSet = (ArrayList<Long>) result;\n       assertEquals(3, resultSet.size());\n       assertEquals(new Long(1), (Long) resultSet.get(0));\n@@ -110,11 +108,11 @@ public void testCopyFrom() throws Exception {\n       assertEquals(new Long(3), (Long) resultSet.get(2));\n \n       /* index 1 */\n-      result = accessor.getObject(1);\n+      result = outVector.getObject(1);\n       assertNull(result);\n \n       /* index 2 */\n-      result = accessor.getObject(2);\n+      result = outVector.getObject(2);\n       resultSet = (ArrayList<Long>) result;\n       assertEquals(0, resultSet.size());\n     }\n@@ -131,46 +129,46 @@ public void testSetLastSetUsage() throws Exception {\n       /* allocate memory */\n       listVector.allocateNew();\n \n-      /* get inner vectors; bitVector and offsetVector */\n-      List<BufferBacked> innerVectors = listVector.getFieldInnerVectors();\n-      BitVector bitVector = (BitVector) innerVectors.get(0);\n-      UInt4Vector offsetVector = (UInt4Vector) innerVectors.get(1);\n+      /* get inner buffers; validityBuffer and offsetBuffer */\n+\n+      ArrowBuf validityBuffer = listVector.getValidityBuffer();\n+      ArrowBuf offsetBuffer = listVector.getOffsetBuffer();\n \n       /* get the underlying data vector -- NullableBigIntVector */\n       NullableBigIntVector dataVector = (NullableBigIntVector) listVector.getDataVector();\n \n       /* check current lastSet */\n-      assertEquals(Integer.toString(0), Integer.toString(listVector.getMutator().getLastSet()));\n+      assertEquals(Integer.toString(0), Integer.toString(listVector.getLastSet()));\n \n       int index = 0;\n       int offset = 0;\n \n-      /* write [10, 11, 12] to the list vector at index */\n-      bitVector.getMutator().setSafe(index, 1);\n-      dataVector.getMutator().setSafe(0, 1, 10);\n-      dataVector.getMutator().setSafe(1, 1, 11);\n-      dataVector.getMutator().setSafe(2, 1, 12);\n-      offsetVector.getMutator().setSafe(index + 1, 3);\n+      /* write [10, 11, 12] to the list vector at index 0 */\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      dataVector.setSafe(0, 1, 10);\n+      dataVector.setSafe(1, 1, 11);\n+      dataVector.setSafe(2, 1, 12);\n+      offsetBuffer.setInt((index + 1) * ListVector.OFFSET_WIDTH, 3);\n \n       index += 1;\n \n       /* write [13, 14] to the list vector at index 1 */\n-      bitVector.getMutator().setSafe(index, 1);\n-      dataVector.getMutator().setSafe(3, 1, 13);\n-      dataVector.getMutator().setSafe(4, 1, 14);\n-      offsetVector.getMutator().setSafe(index + 1, 5);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      dataVector.setSafe(3, 1, 13);\n+      dataVector.setSafe(4, 1, 14);\n+      offsetBuffer.setInt((index + 1) * ListVector.OFFSET_WIDTH, 5);\n \n       index += 1;\n \n       /* write [15, 16, 17] to the list vector at index 2 */\n-      bitVector.getMutator().setSafe(index, 1);\n-      dataVector.getMutator().setSafe(5, 1, 15);\n-      dataVector.getMutator().setSafe(6, 1, 16);\n-      dataVector.getMutator().setSafe(7, 1, 17);\n-      offsetVector.getMutator().setSafe(index + 1, 8);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      dataVector.setSafe(5, 1, 15);\n+      dataVector.setSafe(6, 1, 16);\n+      dataVector.setSafe(7, 1, 17);\n+      offsetBuffer.setInt((index + 1) * ListVector.OFFSET_WIDTH, 8);\n \n       /* check current lastSet */\n-      assertEquals(Integer.toString(0), Integer.toString(listVector.getMutator().getLastSet()));\n+      assertEquals(Integer.toString(0), Integer.toString(listVector.getLastSet()));\n \n       /* set lastset and arbitrary valuecount for list vector.\n        *\n@@ -211,54 +209,50 @@ public void testSetLastSetUsage() throws Exception {\n        *                [15, 16, 17]\n        *              }\n        */\n-      listVector.getMutator().setLastSet(3);\n-      listVector.getMutator().setValueCount(10);\n-\n-      /* check the vector output */\n-      final UInt4Vector.Accessor offsetAccessor = offsetVector.getAccessor();\n-      final ValueVector.Accessor valueAccessor = dataVector.getAccessor();\n+      listVector.setLastSet(3);\n+      listVector.setValueCount(10);\n \n       index = 0;\n-      offset = offsetAccessor.get(index);\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(0), Integer.toString(offset));\n \n-      Object actual = valueAccessor.getObject(offset);\n+      Object actual = dataVector.getObject(offset);\n       assertEquals(new Long(10), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(11), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(12), (Long) actual);\n \n       index++;\n-      offset = offsetAccessor.get(index);\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(3), Integer.toString(offset));\n \n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(13), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(14), (Long) actual);\n \n       index++;\n-      offset = offsetAccessor.get(index);\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(5), Integer.toString(offset));\n \n-      actual = valueAccessor.getObject(offsetAccessor.get(index));\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(15), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(16), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(17), (Long) actual);\n \n       index++;\n-      offset = offsetAccessor.get(index);\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(8), Integer.toString(offset));\n \n-      actual = valueAccessor.getObject(offsetAccessor.get(index));\n+      actual = dataVector.getObject(offset);\n       assertNull(actual);\n     }\n   }\n@@ -311,99 +305,97 @@ public void testSplitAndTransfer() throws Exception {\n       listWriter.bigInt().writeBigInt(23);\n       listWriter.endList();\n \n-      listVector.getMutator().setValueCount(5);\n+      listVector.setValueCount(5);\n \n-      assertEquals(5, listVector.getMutator().getLastSet());\n+      assertEquals(5, listVector.getLastSet());\n \n-      /* get offsetVector */\n-      UInt4Vector offsetVector = (UInt4Vector) listVector.getOffsetVector();\n+      /* get offset buffer */\n+      final ArrowBuf offsetBuffer = listVector.getOffsetBuffer();\n \n       /* get dataVector */\n       NullableBigIntVector dataVector = (NullableBigIntVector) listVector.getDataVector();\n \n       /* check the vector output */\n-      final UInt4Vector.Accessor offsetAccessor = offsetVector.getAccessor();\n-      final ValueVector.Accessor valueAccessor = dataVector.getAccessor();\n \n       int index = 0;\n       int offset = 0;\n       Object actual = null;\n \n       /* index 0 */\n-      assertFalse(listVector.getAccessor().isNull(index));\n-      offset = offsetAccessor.get(index);\n+      assertFalse(listVector.isNull(index));\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(0), Integer.toString(offset));\n \n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(10), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(11), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(12), (Long) actual);\n \n       /* index 1 */\n       index++;\n-      assertFalse(listVector.getAccessor().isNull(index));\n-      offset = offsetAccessor.get(index);\n+      assertFalse(listVector.isNull(index));\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(3), Integer.toString(offset));\n \n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(13), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(14), (Long) actual);\n \n       /* index 2 */\n       index++;\n-      assertFalse(listVector.getAccessor().isNull(index));\n-      offset = offsetAccessor.get(index);\n+      assertFalse(listVector.isNull(index));\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(5), Integer.toString(offset));\n \n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(15), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(16), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(17), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(18), (Long) actual);\n \n       /* index 3 */\n       index++;\n-      assertFalse(listVector.getAccessor().isNull(index));\n-      offset = offsetAccessor.get(index);\n+      assertFalse(listVector.isNull(index));\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(9), Integer.toString(offset));\n \n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(19), (Long) actual);\n \n       /* index 4 */\n       index++;\n-      assertFalse(listVector.getAccessor().isNull(index));\n-      offset = offsetAccessor.get(index);\n+      assertFalse(listVector.isNull(index));\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(10), Integer.toString(offset));\n \n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(20), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(21), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(22), (Long) actual);\n       offset++;\n-      actual = valueAccessor.getObject(offset);\n+      actual = dataVector.getObject(offset);\n       assertEquals(new Long(23), (Long) actual);\n \n       /* index 5 */\n       index++;\n-      assertTrue(listVector.getAccessor().isNull(index));\n-      offset = offsetAccessor.get(index);\n+      assertTrue(listVector.isNull(index));\n+      offset = offsetBuffer.getInt(index * ListVector.OFFSET_WIDTH);\n       assertEquals(Integer.toString(14), Integer.toString(offset));\n \n       /* do split and transfer */\n@@ -426,26 +418,26 @@ public void testSplitAndTransfer() throws Exception {\n           transferPair.splitAndTransfer(start, splitLength);\n \n           /* get offsetVector of toVector */\n-          UInt4Vector offsetVector1 = (UInt4Vector) toVector.getOffsetVector();\n-          UInt4Vector.Accessor offsetAccessor1 = offsetVector1.getAccessor();\n+          final ArrowBuf toOffsetBuffer = toVector.getOffsetBuffer();\n \n           /* get dataVector of toVector */\n           NullableBigIntVector dataVector1 = (NullableBigIntVector) toVector.getDataVector();\n-          NullableBigIntVector.Accessor valueAccessor1 = dataVector1.getAccessor();\n \n           for (int i = 0; i < splitLength; i++) {\n-            dataLength1 = offsetAccessor.get(start + i + 1) - offsetAccessor.get(start + i);\n-            dataLength2 = offsetAccessor1.get(i + 1) - offsetAccessor1.get(i);\n+            dataLength1 = offsetBuffer.getInt((start + i + 1) * ListVector.OFFSET_WIDTH) -\n+                    offsetBuffer.getInt((start + i) * ListVector.OFFSET_WIDTH);\n+            dataLength2 = toOffsetBuffer.getInt((i + 1) * ListVector.OFFSET_WIDTH)\n+                    - toOffsetBuffer.getInt(i * ListVector.OFFSET_WIDTH);\n \n             assertEquals(\"Different data lengths at index: \" + i + \" and start: \" + start,\n                     dataLength1, dataLength2);\n \n-            offset1 = offsetAccessor.get(start + i);\n-            offset2 = offsetAccessor1.get(i);\n+            offset1 = offsetBuffer.getInt((start + i) * ListVector.OFFSET_WIDTH);\n+            offset2 = toOffsetBuffer.getInt(i * ListVector.OFFSET_WIDTH);\n \n             for (int j = 0; j < dataLength1; j++) {\n               assertEquals(\"Different data at indexes: \" + offset1 + \" and \" + offset2,\n-                      valueAccessor.getObject(offset1), valueAccessor1.getObject(offset2));\n+                      dataVector.getObject(offset1), dataVector1.getObject(offset2));\n \n               offset1++;\n               offset2++;\n@@ -509,15 +501,14 @@ public void testNestedListVector() throws Exception {\n \n       listWriter.endList();\n \n-      assertEquals(2, listVector.getMutator().getLastSet());\n+      assertEquals(2, listVector.getLastSet());\n \n-      listVector.getMutator().setValueCount(2);\n+      listVector.setValueCount(2);\n \n-      final ListVector.Accessor accessor = listVector.getAccessor();\n-      assertEquals(2, accessor.getValueCount());\n+      assertEquals(2, listVector.getValueCount());\n \n       /* get listVector value at index 0 -- the value itself is a listvector */\n-      Object result = accessor.getObject(0);\n+      Object result = listVector.getObject(0);\n       ArrayList<ArrayList<Long>> resultSet = (ArrayList<ArrayList<Long>>) result;\n       ArrayList<Long> list;\n \n@@ -537,7 +528,7 @@ public void testNestedListVector() throws Exception {\n       assertEquals(new Long(175), list.get(3));\n \n        /* get listVector value at index 1 -- the value itself is a listvector */\n-      result = accessor.getObject(1);\n+      result = listVector.getObject(1);\n       resultSet = (ArrayList<ArrayList<Long>>) result;\n \n       assertEquals(3, resultSet.size());              /* 3 inner lists at index 1 */\n@@ -558,17 +549,16 @@ public void testNestedListVector() throws Exception {\n       assertEquals(new Long(35), list.get(2));\n \n       /* check underlying bitVector */\n-      assertFalse(accessor.isNull(0));\n-      assertFalse(accessor.isNull(1));\n+      assertFalse(listVector.isNull(0));\n+      assertFalse(listVector.isNull(1));\n \n-      /* check underlying offsetVector */\n-      UInt4Vector offsetVector = listVector.getOffsetVector();\n-      final UInt4Vector.Accessor offsetAccessor = offsetVector.getAccessor();\n+      /* check underlying offsets */\n+      final ArrowBuf offsetBuffer = listVector.getOffsetBuffer();\n \n       /* listVector has 2 lists at index 0 and 3 lists at index 1 */\n-      assertEquals(0, offsetAccessor.get(0));\n-      assertEquals(2, offsetAccessor.get(1));\n-      assertEquals(5, offsetAccessor.get(2));\n+      assertEquals(0, offsetBuffer.getInt(0 * ListVector.OFFSET_WIDTH));\n+      assertEquals(2, offsetBuffer.getInt(1 * ListVector.OFFSET_WIDTH));\n+      assertEquals(5, offsetBuffer.getInt(2 * ListVector.OFFSET_WIDTH));\n     }\n   }\n \n@@ -594,17 +584,15 @@ public void testGetBufferAddress() throws Exception {\n       listWriter.bigInt().writeBigInt(300);\n       listWriter.endList();\n \n-      final ListVector.Accessor accessor = listVector.getAccessor();\n-\n       /* check listVector contents */\n-      Object result = accessor.getObject(0);\n+      Object result = listVector.getObject(0);\n       ArrayList<Long> resultSet = (ArrayList<Long>) result;\n       assertEquals(3, resultSet.size());\n       assertEquals(new Long(50), resultSet.get(0));\n       assertEquals(new Long(100), resultSet.get(1));\n       assertEquals(new Long(200), resultSet.get(2));\n \n-      result = accessor.getObject(1);\n+      result = listVector.getObject(1);\n       resultSet = (ArrayList<Long>) result;\n       assertEquals(2, resultSet.size());\n       assertEquals(new Long(250), resultSet.get(0));\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestUnionVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestUnionVector.java\nindex 86f0bf337..ede4f9922 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestUnionVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestUnionVector.java\n@@ -64,26 +64,24 @@ public void testUnionVector() throws Exception {\n       unionVector.allocateNew();\n \n       // write some data\n-      final UnionVector.Mutator mutator = unionVector.getMutator();\n-      mutator.setType(0, Types.MinorType.UINT4);\n-      mutator.setSafe(0, uInt4Holder);\n-      mutator.setType(2, Types.MinorType.UINT4);\n-      mutator.setSafe(2, uInt4Holder);\n-      mutator.setValueCount(4);\n+      unionVector.setType(0, Types.MinorType.UINT4);\n+      unionVector.setSafe(0, uInt4Holder);\n+      unionVector.setType(2, Types.MinorType.UINT4);\n+      unionVector.setSafe(2, uInt4Holder);\n+      unionVector.setValueCount(4);\n \n       // check that what we wrote is correct\n-      final UnionVector.Accessor accessor = unionVector.getAccessor();\n-      assertEquals(4, accessor.getValueCount());\n+      assertEquals(4, unionVector.getValueCount());\n \n-      assertEquals(false, accessor.isNull(0));\n-      assertEquals(100, accessor.getObject(0));\n+      assertEquals(false, unionVector.isNull(0));\n+      assertEquals(100, unionVector.getObject(0));\n \n-      assertEquals(true, accessor.isNull(1));\n+      assertEquals(true, unionVector.isNull(1));\n \n-      assertEquals(false, accessor.isNull(2));\n-      assertEquals(100, accessor.getObject(2));\n+      assertEquals(false, unionVector.isNull(2));\n+      assertEquals(100, unionVector.getObject(2));\n \n-      assertEquals(true, accessor.isNull(3));\n+      assertEquals(true, unionVector.isNull(3));\n     }\n   }\n \n@@ -93,16 +91,15 @@ public void testTransfer() throws Exception {\n       srcVector.allocateNew();\n \n       // write some data\n-      final UnionVector.Mutator mutator = srcVector.getMutator();\n-      mutator.setType(0, MinorType.INT);\n-      mutator.setSafe(0, newIntHolder(5));\n-      mutator.setType(1, MinorType.BIT);\n-      mutator.setSafe(1, newBitHolder(false));\n-      mutator.setType(3, MinorType.INT);\n-      mutator.setSafe(3, newIntHolder(10));\n-      mutator.setType(5, MinorType.BIT);\n-      mutator.setSafe(5, newBitHolder(false));\n-      mutator.setValueCount(6);\n+      srcVector.setType(0, MinorType.INT);\n+      srcVector.setSafe(0, newIntHolder(5));\n+      srcVector.setType(1, MinorType.BIT);\n+      srcVector.setSafe(1, newBitHolder(false));\n+      srcVector.setType(3, MinorType.INT);\n+      srcVector.setSafe(3, newIntHolder(10));\n+      srcVector.setType(5, MinorType.BIT);\n+      srcVector.setSafe(5, newBitHolder(false));\n+      srcVector.setValueCount(6);\n \n       try (UnionVector destVector = new UnionVector(EMPTY_SCHEMA_PATH, allocator, null)) {\n         TransferPair pair = srcVector.makeTransferPair(destVector);\n@@ -116,9 +113,9 @@ public void testTransfer() throws Exception {\n         assertEquals(srcVector.getField(), destVector.getField());\n \n         // now check the values are transferred\n-        assertEquals(srcVector.getAccessor().getValueCount(), destVector.getAccessor().getValueCount());\n-        for (int i = 0; i < srcVector.getAccessor().getValueCount(); i++) {\n-          assertEquals(\"Different values at index \" + i, srcVector.getAccessor().get(i), destVector.getAccessor().get(i));\n+        assertEquals(srcVector.getValueCount(), destVector.getValueCount());\n+        for (int i = 0; i < srcVector.getValueCount(); i++) {\n+          assertEquals(\"Different values at index \" + i, srcVector.get(i), destVector.get(i));\n         }\n       }\n     }\n@@ -127,61 +124,58 @@ public void testTransfer() throws Exception {\n   @Test\n   public void testSplitAndTransfer() throws Exception {\n     try (UnionVector sourceVector = new UnionVector(EMPTY_SCHEMA_PATH, allocator, null)) {\n-      final UnionVector.Mutator sourceMutator = sourceVector.getMutator();\n-      final UnionVector.Accessor sourceAccessor = sourceVector.getAccessor();\n \n       sourceVector.allocateNew();\n \n       /* populate the UnionVector */\n-      sourceMutator.setType(0, MinorType.INT);\n-      sourceMutator.setSafe(0, newIntHolder(5));\n-      sourceMutator.setType(1, MinorType.INT);\n-      sourceMutator.setSafe(1, newIntHolder(10));\n-      sourceMutator.setType(2, MinorType.INT);\n-      sourceMutator.setSafe(2, newIntHolder(15));\n-      sourceMutator.setType(3, MinorType.INT);\n-      sourceMutator.setSafe(3, newIntHolder(20));\n-      sourceMutator.setType(4, MinorType.INT);\n-      sourceMutator.setSafe(4, newIntHolder(25));\n-      sourceMutator.setType(5, MinorType.INT);\n-      sourceMutator.setSafe(5, newIntHolder(30));\n-      sourceMutator.setType(6, MinorType.INT);\n-      sourceMutator.setSafe(6, newIntHolder(35));\n-      sourceMutator.setType(7, MinorType.INT);\n-      sourceMutator.setSafe(7, newIntHolder(40));\n-      sourceMutator.setType(8, MinorType.INT);\n-      sourceMutator.setSafe(8, newIntHolder(45));\n-      sourceMutator.setType(9, MinorType.INT);\n-      sourceMutator.setSafe(9, newIntHolder(50));\n-      sourceMutator.setValueCount(10);\n+      sourceVector.setType(0, MinorType.INT);\n+      sourceVector.setSafe(0, newIntHolder(5));\n+      sourceVector.setType(1, MinorType.INT);\n+      sourceVector.setSafe(1, newIntHolder(10));\n+      sourceVector.setType(2, MinorType.INT);\n+      sourceVector.setSafe(2, newIntHolder(15));\n+      sourceVector.setType(3, MinorType.INT);\n+      sourceVector.setSafe(3, newIntHolder(20));\n+      sourceVector.setType(4, MinorType.INT);\n+      sourceVector.setSafe(4, newIntHolder(25));\n+      sourceVector.setType(5, MinorType.INT);\n+      sourceVector.setSafe(5, newIntHolder(30));\n+      sourceVector.setType(6, MinorType.INT);\n+      sourceVector.setSafe(6, newIntHolder(35));\n+      sourceVector.setType(7, MinorType.INT);\n+      sourceVector.setSafe(7, newIntHolder(40));\n+      sourceVector.setType(8, MinorType.INT);\n+      sourceVector.setSafe(8, newIntHolder(45));\n+      sourceVector.setType(9, MinorType.INT);\n+      sourceVector.setSafe(9, newIntHolder(50));\n+      sourceVector.setValueCount(10);\n \n       /* check the vector output */\n-      assertEquals(10, sourceAccessor.getValueCount());\n-      assertEquals(false, sourceAccessor.isNull(0));\n-      assertEquals(5, sourceAccessor.getObject(0));\n-      assertEquals(false, sourceAccessor.isNull(1));\n-      assertEquals(10, sourceAccessor.getObject(1));\n-      assertEquals(false, sourceAccessor.isNull(2));\n-      assertEquals(15, sourceAccessor.getObject(2));\n-      assertEquals(false, sourceAccessor.isNull(3));\n-      assertEquals(20, sourceAccessor.getObject(3));\n-      assertEquals(false, sourceAccessor.isNull(4));\n-      assertEquals(25, sourceAccessor.getObject(4));\n-      assertEquals(false, sourceAccessor.isNull(5));\n-      assertEquals(30, sourceAccessor.getObject(5));\n-      assertEquals(false, sourceAccessor.isNull(6));\n-      assertEquals(35, sourceAccessor.getObject(6));\n-      assertEquals(false, sourceAccessor.isNull(7));\n-      assertEquals(40, sourceAccessor.getObject(7));\n-      assertEquals(false, sourceAccessor.isNull(8));\n-      assertEquals(45, sourceAccessor.getObject(8));\n-      assertEquals(false, sourceAccessor.isNull(9));\n-      assertEquals(50, sourceAccessor.getObject(9));\n+      assertEquals(10, sourceVector.getValueCount());\n+      assertEquals(false, sourceVector.isNull(0));\n+      assertEquals(5, sourceVector.getObject(0));\n+      assertEquals(false, sourceVector.isNull(1));\n+      assertEquals(10, sourceVector.getObject(1));\n+      assertEquals(false, sourceVector.isNull(2));\n+      assertEquals(15, sourceVector.getObject(2));\n+      assertEquals(false, sourceVector.isNull(3));\n+      assertEquals(20, sourceVector.getObject(3));\n+      assertEquals(false, sourceVector.isNull(4));\n+      assertEquals(25, sourceVector.getObject(4));\n+      assertEquals(false, sourceVector.isNull(5));\n+      assertEquals(30, sourceVector.getObject(5));\n+      assertEquals(false, sourceVector.isNull(6));\n+      assertEquals(35, sourceVector.getObject(6));\n+      assertEquals(false, sourceVector.isNull(7));\n+      assertEquals(40, sourceVector.getObject(7));\n+      assertEquals(false, sourceVector.isNull(8));\n+      assertEquals(45, sourceVector.getObject(8));\n+      assertEquals(false, sourceVector.isNull(9));\n+      assertEquals(50, sourceVector.getObject(9));\n \n       try (UnionVector toVector = new UnionVector(EMPTY_SCHEMA_PATH, allocator, null)) {\n \n         final TransferPair transferPair = sourceVector.makeTransferPair(toVector);\n-        final UnionVector.Accessor toAccessor = toVector.getAccessor();\n \n         final int[][] transferLengths = {{0, 3},\n             {3, 1},\n@@ -199,8 +193,8 @@ public void testSplitAndTransfer() throws Exception {\n \n           /* check the toVector output after doing the splitAndTransfer */\n           for (int i = 0; i < length; i++) {\n-            assertEquals(\"Different data at indexes: \" + (start + i) + \"and \" + i, sourceAccessor.getObject(start + i),\n-                toAccessor.getObject(i));\n+            assertEquals(\"Different data at indexes: \" + (start + i) + \"and \" + i, sourceVector.getObject(start + i),\n+                toVector.getObject(i));\n           }\n         }\n       }\n@@ -210,70 +204,67 @@ public void testSplitAndTransfer() throws Exception {\n   @Test\n   public void testSplitAndTransferWithMixedVectors() throws Exception {\n     try (UnionVector sourceVector = new UnionVector(EMPTY_SCHEMA_PATH, allocator, null)) {\n-      final UnionVector.Mutator sourceMutator = sourceVector.getMutator();\n-      final UnionVector.Accessor sourceAccessor = sourceVector.getAccessor();\n \n       sourceVector.allocateNew();\n \n       /* populate the UnionVector */\n-      sourceMutator.setType(0, MinorType.INT);\n-      sourceMutator.setSafe(0, newIntHolder(5));\n+      sourceVector.setType(0, MinorType.INT);\n+      sourceVector.setSafe(0, newIntHolder(5));\n \n-      sourceMutator.setType(1, MinorType.FLOAT4);\n-      sourceMutator.setSafe(1, newFloat4Holder(5.5f));\n+      sourceVector.setType(1, MinorType.FLOAT4);\n+      sourceVector.setSafe(1, newFloat4Holder(5.5f));\n \n-      sourceMutator.setType(2, MinorType.INT);\n-      sourceMutator.setSafe(2, newIntHolder(10));\n+      sourceVector.setType(2, MinorType.INT);\n+      sourceVector.setSafe(2, newIntHolder(10));\n \n-      sourceMutator.setType(3, MinorType.FLOAT4);\n-      sourceMutator.setSafe(3, newFloat4Holder(10.5f));\n+      sourceVector.setType(3, MinorType.FLOAT4);\n+      sourceVector.setSafe(3, newFloat4Holder(10.5f));\n \n-      sourceMutator.setType(4, MinorType.INT);\n-      sourceMutator.setSafe(4, newIntHolder(15));\n+      sourceVector.setType(4, MinorType.INT);\n+      sourceVector.setSafe(4, newIntHolder(15));\n \n-      sourceMutator.setType(5, MinorType.FLOAT4);\n-      sourceMutator.setSafe(5, newFloat4Holder(15.5f));\n+      sourceVector.setType(5, MinorType.FLOAT4);\n+      sourceVector.setSafe(5, newFloat4Holder(15.5f));\n \n-      sourceMutator.setType(6, MinorType.INT);\n-      sourceMutator.setSafe(6, newIntHolder(20));\n+      sourceVector.setType(6, MinorType.INT);\n+      sourceVector.setSafe(6, newIntHolder(20));\n \n-      sourceMutator.setType(7, MinorType.FLOAT4);\n-      sourceMutator.setSafe(7, newFloat4Holder(20.5f));\n+      sourceVector.setType(7, MinorType.FLOAT4);\n+      sourceVector.setSafe(7, newFloat4Holder(20.5f));\n \n-      sourceMutator.setType(8, MinorType.INT);\n-      sourceMutator.setSafe(8, newIntHolder(30));\n+      sourceVector.setType(8, MinorType.INT);\n+      sourceVector.setSafe(8, newIntHolder(30));\n \n-      sourceMutator.setType(9, MinorType.FLOAT4);\n-      sourceMutator.setSafe(9, newFloat4Holder(30.5f));\n-      sourceMutator.setValueCount(10);\n+      sourceVector.setType(9, MinorType.FLOAT4);\n+      sourceVector.setSafe(9, newFloat4Holder(30.5f));\n+      sourceVector.setValueCount(10);\n \n       /* check the vector output */\n-      assertEquals(10, sourceAccessor.getValueCount());\n-      assertEquals(false, sourceAccessor.isNull(0));\n-      assertEquals(5, sourceAccessor.getObject(0));\n-      assertEquals(false, sourceAccessor.isNull(1));\n-      assertEquals(5.5f, sourceAccessor.getObject(1));\n-      assertEquals(false, sourceAccessor.isNull(2));\n-      assertEquals(10, sourceAccessor.getObject(2));\n-      assertEquals(false, sourceAccessor.isNull(3));\n-      assertEquals(10.5f, sourceAccessor.getObject(3));\n-      assertEquals(false, sourceAccessor.isNull(4));\n-      assertEquals(15, sourceAccessor.getObject(4));\n-      assertEquals(false, sourceAccessor.isNull(5));\n-      assertEquals(15.5f, sourceAccessor.getObject(5));\n-      assertEquals(false, sourceAccessor.isNull(6));\n-      assertEquals(20, sourceAccessor.getObject(6));\n-      assertEquals(false, sourceAccessor.isNull(7));\n-      assertEquals(20.5f, sourceAccessor.getObject(7));\n-      assertEquals(false, sourceAccessor.isNull(8));\n-      assertEquals(30, sourceAccessor.getObject(8));\n-      assertEquals(false, sourceAccessor.isNull(9));\n-      assertEquals(30.5f, sourceAccessor.getObject(9));\n+      assertEquals(10, sourceVector.getValueCount());\n+      assertEquals(false, sourceVector.isNull(0));\n+      assertEquals(5, sourceVector.getObject(0));\n+      assertEquals(false, sourceVector.isNull(1));\n+      assertEquals(5.5f, sourceVector.getObject(1));\n+      assertEquals(false, sourceVector.isNull(2));\n+      assertEquals(10, sourceVector.getObject(2));\n+      assertEquals(false, sourceVector.isNull(3));\n+      assertEquals(10.5f, sourceVector.getObject(3));\n+      assertEquals(false, sourceVector.isNull(4));\n+      assertEquals(15, sourceVector.getObject(4));\n+      assertEquals(false, sourceVector.isNull(5));\n+      assertEquals(15.5f, sourceVector.getObject(5));\n+      assertEquals(false, sourceVector.isNull(6));\n+      assertEquals(20, sourceVector.getObject(6));\n+      assertEquals(false, sourceVector.isNull(7));\n+      assertEquals(20.5f, sourceVector.getObject(7));\n+      assertEquals(false, sourceVector.isNull(8));\n+      assertEquals(30, sourceVector.getObject(8));\n+      assertEquals(false, sourceVector.isNull(9));\n+      assertEquals(30.5f, sourceVector.getObject(9));\n \n       try (UnionVector toVector = new UnionVector(EMPTY_SCHEMA_PATH, allocator, null)) {\n \n         final TransferPair transferPair = sourceVector.makeTransferPair(toVector);\n-        final UnionVector.Accessor toAccessor = toVector.getAccessor();\n \n         final int[][] transferLengths = {{0, 2},\n             {2, 1},\n@@ -290,7 +281,7 @@ public void testSplitAndTransferWithMixedVectors() throws Exception {\n \n           /* check the toVector output after doing the splitAndTransfer */\n           for (int i = 0; i < length; i++) {\n-            assertEquals(\"Different values at index: \" + i, sourceAccessor.getObject(start + i), toAccessor.getObject(i));\n+            assertEquals(\"Different values at index: \" + i, sourceVector.getObject(start + i), toVector.getObject(i));\n           }\n         }\n       }\n@@ -300,37 +291,35 @@ public void testSplitAndTransferWithMixedVectors() throws Exception {\n   @Test\n   public void testGetBufferAddress() throws Exception {\n     try (UnionVector vector = new UnionVector(EMPTY_SCHEMA_PATH, allocator, null)) {\n-      final UnionVector.Mutator mutator = vector.getMutator();\n-      final UnionVector.Accessor accessor = vector.getAccessor();\n       boolean error = false;\n \n       vector.allocateNew();\n \n       /* populate the UnionVector */\n-      mutator.setType(0, MinorType.INT);\n-      mutator.setSafe(0, newIntHolder(5));\n+      vector.setType(0, MinorType.INT);\n+      vector.setSafe(0, newIntHolder(5));\n \n-      mutator.setType(1, MinorType.FLOAT4);\n-      mutator.setSafe(1, newFloat4Holder(5.5f));\n+      vector.setType(1, MinorType.FLOAT4);\n+      vector.setSafe(1, newFloat4Holder(5.5f));\n \n-      mutator.setType(2, MinorType.INT);\n-      mutator.setSafe(2, newIntHolder(10));\n+      vector.setType(2, MinorType.INT);\n+      vector.setSafe(2, newIntHolder(10));\n \n-      mutator.setType(3, MinorType.FLOAT4);\n-      mutator.setSafe(3, newFloat4Holder(10.5f));\n+      vector.setType(3, MinorType.FLOAT4);\n+      vector.setSafe(3, newFloat4Holder(10.5f));\n \n-      mutator.setValueCount(10);\n+      vector.setValueCount(10);\n \n       /* check the vector output */\n-      assertEquals(10, accessor.getValueCount());\n-      assertEquals(false, accessor.isNull(0));\n-      assertEquals(5, accessor.getObject(0));\n-      assertEquals(false, accessor.isNull(1));\n-      assertEquals(5.5f, accessor.getObject(1));\n-      assertEquals(false, accessor.isNull(2));\n-      assertEquals(10, accessor.getObject(2));\n-      assertEquals(false, accessor.isNull(3));\n-      assertEquals(10.5f, accessor.getObject(3));\n+      assertEquals(10, vector.getValueCount());\n+      assertEquals(false, vector.isNull(0));\n+      assertEquals(5, vector.getObject(0));\n+      assertEquals(false, vector.isNull(1));\n+      assertEquals(5.5f, vector.getObject(1));\n+      assertEquals(false, vector.isNull(2));\n+      assertEquals(10, vector.getObject(2));\n+      assertEquals(false, vector.isNull(3));\n+      assertEquals(10.5f, vector.getObject(3));\n \n       List<ArrowBuf> buffers = vector.getFieldBuffers();\n \ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestValueVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestValueVector.java\nindex b7f88c3ba..c7ee202f9 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestValueVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestValueVector.java\n@@ -487,8 +487,6 @@ public void testNullableFixedType1() {\n \n     // Create a new value vector for 1024 integers.\n     try (final NullableUInt4Vector vector = newVector(NullableUInt4Vector.class, EMPTY_SCHEMA_PATH, new ArrowType.Int(32, false), allocator);) {\n-      final NullableUInt4Vector.Mutator mutator = vector.getMutator();\n-      final NullableUInt4Vector.Accessor accessor = vector.getAccessor();\n       boolean error = false;\n       int initialCapacity = 1024;\n \n@@ -500,33 +498,33 @@ public void testNullableFixedType1() {\n       assertEquals(initialCapacity, vector.getValueCapacity());\n \n       // Put and set a few values\n-      mutator.set(0, 100);\n-      mutator.set(1, 101);\n-      mutator.set(100, 102);\n-      mutator.set(1022, 103);\n-      mutator.set(1023, 104);\n+      vector.set(0, 100);\n+      vector.set(1, 101);\n+      vector.set(100, 102);\n+      vector.set(1022, 103);\n+      vector.set(1023, 104);\n \n       /* check vector contents */\n-      assertEquals(100, accessor.get(0));\n-      assertEquals(101, accessor.get(1));\n-      assertEquals(102, accessor.get(100));\n-      assertEquals(103, accessor.get(1022));\n-      assertEquals(104, accessor.get(1023));\n+      assertEquals(100, vector.get(0));\n+      assertEquals(101, vector.get(1));\n+      assertEquals(102, vector.get(100));\n+      assertEquals(103, vector.get(1022));\n+      assertEquals(104, vector.get(1023));\n \n       int val = 0;\n \n       /* check unset bits/null values */\n       for (int i = 2, j = 101; i <= 99 || j <= 1021; i++, j++) {\n         if (i <= 99) {\n-          assertTrue(accessor.isNull(i));\n+          assertTrue(vector.isNull(i));\n         }\n         if(j <= 1021) {\n-          assertTrue(accessor.isNull(j));\n+          assertTrue(vector.isNull(j));\n         }\n       }\n \n       try {\n-        mutator.set(1024, 10000);\n+        vector.set(1024, 10000);\n       }\n       catch (IndexOutOfBoundsException ie) {\n         error = true;\n@@ -537,7 +535,7 @@ public void testNullableFixedType1() {\n       }\n \n       try {\n-        accessor.get(1024);\n+        vector.get(1024);\n       }\n       catch (IndexOutOfBoundsException ie) {\n         error = true;\n@@ -548,28 +546,28 @@ public void testNullableFixedType1() {\n       }\n \n       /* should trigger a realloc of the underlying bitvector and valuevector */\n-      mutator.setSafe(1024, 10000);\n+      vector.setSafe(1024, 10000);\n \n       /* check new capacity */\n       assertEquals(initialCapacity * 2, vector.getValueCapacity());\n \n       /* vector contents should still be intact after realloc */\n-      assertEquals(100, accessor.get(0));\n-      assertEquals(101, accessor.get(1));\n-      assertEquals(102, accessor.get(100));\n-      assertEquals(103, accessor.get(1022));\n-      assertEquals(104, accessor.get(1023));\n-      assertEquals(10000, accessor.get(1024));\n+      assertEquals(100, vector.get(0));\n+      assertEquals(101, vector.get(1));\n+      assertEquals(102, vector.get(100));\n+      assertEquals(103, vector.get(1022));\n+      assertEquals(104, vector.get(1023));\n+      assertEquals(10000, vector.get(1024));\n \n       val = 0;\n \n       /* check unset bits/null values */\n       for (int i = 2, j = 101; i < 99 || j < 1021; i++, j++) {\n         if (i <= 99) {\n-          assertTrue(accessor.isNull(i));\n+          assertTrue(vector.isNull(i));\n         }\n         if(j <= 1021) {\n-          assertTrue(accessor.isNull(j));\n+          assertTrue(vector.isNull(j));\n         }\n       }\n \n@@ -581,7 +579,7 @@ public void testNullableFixedType1() {\n \n       /* vector data should be zeroed out */\n       for(int i = 0; i < (initialCapacity * 2); i++) {\n-        assertTrue(\"non-null data not expected at index: \" + i, accessor.isNull(i));\n+        assertTrue(\"non-null data not expected at index: \" + i, vector.isNull(i));\n       }\n     }\n   }\n@@ -590,8 +588,6 @@ public void testNullableFixedType1() {\n   public void testNullableFixedType2() {\n     // Create a new value vector for 1024 integers\n     try (final NullableFloat4Vector vector = newVector(NullableFloat4Vector.class, EMPTY_SCHEMA_PATH, MinorType.FLOAT4, allocator);) {\n-      final NullableFloat4Vector.Mutator mutator = vector.getMutator();\n-      final NullableFloat4Vector.Accessor accessor = vector.getAccessor();\n       boolean error = false;\n       int initialCapacity = 16;\n \n@@ -603,17 +599,17 @@ public void testNullableFixedType2() {\n       assertEquals(initialCapacity, vector.getValueCapacity());\n \n       /* populate the vector */\n-      mutator.set(0, 100.5f);\n-      mutator.set(2, 201.5f);\n-      mutator.set(4, 300.3f);\n-      mutator.set(6, 423.8f);\n-      mutator.set(8, 555.6f);\n-      mutator.set(10, 66.6f);\n-      mutator.set(12, 78.8f);\n-      mutator.set(14, 89.5f);\n+      vector.set(0, 100.5f);\n+      vector.set(2, 201.5f);\n+      vector.set(4, 300.3f);\n+      vector.set(6, 423.8f);\n+      vector.set(8, 555.6f);\n+      vector.set(10, 66.6f);\n+      vector.set(12, 78.8f);\n+      vector.set(14, 89.5f);\n \n       try {\n-        mutator.set(16, 90.5f);\n+        vector.set(16, 90.5f);\n       }\n       catch (IndexOutOfBoundsException ie) {\n         error = true;\n@@ -624,25 +620,25 @@ public void testNullableFixedType2() {\n       }\n \n       /* check vector contents */\n-      assertEquals(100.5f, accessor.get(0), 0);\n-      assertTrue(accessor.isNull(1));\n-      assertEquals(201.5f, accessor.get(2), 0);\n-      assertTrue(accessor.isNull(3));\n-      assertEquals(300.3f, accessor.get(4), 0);\n-      assertTrue(accessor.isNull(5));\n-      assertEquals(423.8f, accessor.get(6), 0);\n-      assertTrue(accessor.isNull(7));\n-      assertEquals(555.6f, accessor.get(8), 0);\n-      assertTrue(accessor.isNull(9));\n-      assertEquals(66.6f, accessor.get(10), 0);\n-      assertTrue(accessor.isNull(11));\n-      assertEquals(78.8f, accessor.get(12), 0);\n-      assertTrue(accessor.isNull(13));\n-      assertEquals(89.5f, accessor.get(14), 0);\n-      assertTrue(accessor.isNull(15));\n+      assertEquals(100.5f, vector.get(0), 0);\n+      assertTrue(vector.isNull(1));\n+      assertEquals(201.5f, vector.get(2), 0);\n+      assertTrue(vector.isNull(3));\n+      assertEquals(300.3f, vector.get(4), 0);\n+      assertTrue(vector.isNull(5));\n+      assertEquals(423.8f, vector.get(6), 0);\n+      assertTrue(vector.isNull(7));\n+      assertEquals(555.6f, vector.get(8), 0);\n+      assertTrue(vector.isNull(9));\n+      assertEquals(66.6f, vector.get(10), 0);\n+      assertTrue(vector.isNull(11));\n+      assertEquals(78.8f, vector.get(12), 0);\n+      assertTrue(vector.isNull(13));\n+      assertEquals(89.5f, vector.get(14), 0);\n+      assertTrue(vector.isNull(15));\n \n       try {\n-        accessor.get(16);\n+        vector.get(16);\n       }\n       catch (IndexOutOfBoundsException ie) {\n         error = true;\n@@ -653,29 +649,28 @@ public void testNullableFixedType2() {\n       }\n \n       /* this should trigger a realloc() */\n-      mutator.setSafe(16, 90.5f);\n+      vector.setSafe(16, 90.5f);\n \n       /* underlying buffer should now be able to store double the number of values */\n       assertEquals(initialCapacity * 2, vector.getValueCapacity());\n \n       /* vector data should still be intact after realloc */\n-      assertEquals(100.5f, accessor.get(0), 0);\n-      assertTrue(accessor.isNull(1));\n-      assertEquals(201.5f, accessor.get(2), 0);\n-      assertTrue(accessor.isNull(3));\n-      assertEquals(300.3f, accessor.get(4), 0);\n-      assertTrue(accessor.isNull(5));\n-      assertEquals(423.8f, accessor.get(6), 0);\n-      assertTrue(accessor.isNull(7));\n-      assertEquals(555.6f, accessor.get(8), 0);\n-      assertTrue(accessor.isNull(9));\n-      assertEquals(66.6f, accessor.get(10), 0);\n-      assertTrue(accessor.isNull(11));\n-      assertEquals(78.8f, accessor.get(12), 0);\n-      assertTrue(accessor.isNull(13));\n-      assertEquals(89.5f, accessor.get(14), 0);\n-      assertTrue(accessor.isNull(15));\n-      assertEquals(90.5f, accessor.get(16), 0);\n+      assertEquals(100.5f, vector.get(0), 0);\n+      assertTrue(vector.isNull(1));\n+      assertEquals(201.5f, vector.get(2), 0);\n+      assertTrue(vector.isNull(3));\n+      assertEquals(300.3f, vector.get(4), 0);\n+      assertTrue(vector.isNull(5));\n+      assertEquals(423.8f, vector.get(6), 0);\n+      assertTrue(vector.isNull(7));\n+      assertEquals(555.6f, vector.get(8), 0);\n+      assertTrue(vector.isNull(9));\n+      assertEquals(66.6f, vector.get(10), 0);\n+      assertTrue(vector.isNull(11));\n+      assertEquals(78.8f, vector.get(12), 0);\n+      assertTrue(vector.isNull(13));\n+      assertEquals(89.5f, vector.get(14), 0);\n+      assertTrue(vector.isNull(15));\n \n       /* reset the vector */\n       vector.reset();\n@@ -685,7 +680,7 @@ public void testNullableFixedType2() {\n \n       /* vector data should be zeroed out */\n       for(int i = 0; i < (initialCapacity * 2); i++) {\n-        assertTrue(\"non-null data not expected at index: \" + i, accessor.isNull(i));\n+        assertTrue(\"non-null data not expected at index: \" + i, vector.isNull(i));\n       }\n     }\n   }\n@@ -928,32 +923,30 @@ public void testNullableVarType2() {\n \n     // Create a new value vector for 1024 integers.\n     try (final NullableVarBinaryVector vector = newNullableVarBinaryVector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final NullableVarBinaryVector.Mutator m = vector.getMutator();\n       vector.allocateNew(1024 * 10, 1024);\n \n-      m.set(0, STR1);\n-      m.set(1, STR2);\n-      m.set(2, STR3);\n-      m.setSafe(3, STR3, 1, STR3.length - 1);\n-      m.setSafe(4, STR3, 2, STR3.length - 2);\n+      vector.set(0, STR1);\n+      vector.set(1, STR2);\n+      vector.set(2, STR3);\n+      vector.setSafe(3, STR3, 1, STR3.length - 1);\n+      vector.setSafe(4, STR3, 2, STR3.length - 2);\n       ByteBuffer STR3ByteBuffer = ByteBuffer.wrap(STR3);\n-      m.setSafe(5, STR3ByteBuffer, 1, STR3.length - 1);\n-      m.setSafe(6, STR3ByteBuffer, 2, STR3.length - 2);\n+      vector.setSafe(5, STR3ByteBuffer, 1, STR3.length - 1);\n+      vector.setSafe(6, STR3ByteBuffer, 2, STR3.length - 2);\n \n       // Check the sample strings.\n-      final NullableVarBinaryVector.Accessor accessor = vector.getAccessor();\n-      assertArrayEquals(STR1, accessor.get(0));\n-      assertArrayEquals(STR2, accessor.get(1));\n-      assertArrayEquals(STR3, accessor.get(2));\n-      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), accessor.get(3));\n-      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), accessor.get(4));\n-      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), accessor.get(5));\n-      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), accessor.get(6));\n+      assertArrayEquals(STR1, vector.get(0));\n+      assertArrayEquals(STR2, vector.get(1));\n+      assertArrayEquals(STR3, vector.get(2));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), vector.get(3));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), vector.get(4));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), vector.get(5));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), vector.get(6));\n \n       // Ensure null value throws.\n       boolean b = false;\n       try {\n-        vector.getAccessor().get(7);\n+        vector.get(7);\n       } catch (IllegalStateException e) {\n         b = true;\n       } finally {\n@@ -1064,8 +1057,6 @@ public void testReallocAfterVectorTransfer1() {\n   @Test /* NullableFloat8Vector */\n   public void testReallocAfterVectorTransfer2() {\n     try (final NullableFloat8Vector vector = new NullableFloat8Vector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final NullableFloat8Vector.Mutator mutator = vector.getMutator();\n-      final NullableFloat8Vector.Accessor accessor = vector.getAccessor();\n       final int initialDefaultCapacity = 4096;\n       boolean error = false;\n \n@@ -1076,7 +1067,7 @@ public void testReallocAfterVectorTransfer2() {\n       double baseValue = 100.375;\n \n       for (int i = 0; i < initialDefaultCapacity; i++) {\n-        mutator.setSafe(i, baseValue + (double)i);\n+        vector.setSafe(i, baseValue + (double)i);\n       }\n \n       /* the above setSafe calls should not have triggered a realloc as\n@@ -1085,33 +1076,33 @@ public void testReallocAfterVectorTransfer2() {\n       assertEquals(initialDefaultCapacity, vector.getValueCapacity());\n \n       for (int i = 0; i < initialDefaultCapacity; i++) {\n-        double value = accessor.get(i);\n+        double value = vector.get(i);\n         assertEquals(baseValue + (double)i, value, 0);\n       }\n \n       /* this should trigger a realloc */\n-      mutator.setSafe(initialDefaultCapacity, baseValue + (double)initialDefaultCapacity);\n+      vector.setSafe(initialDefaultCapacity, baseValue + (double)initialDefaultCapacity);\n       assertEquals(initialDefaultCapacity * 2, vector.getValueCapacity());\n \n       for (int i = initialDefaultCapacity + 1; i < (initialDefaultCapacity * 2); i++) {\n-        mutator.setSafe(i, baseValue + (double)i);\n+        vector.setSafe(i, baseValue + (double)i);\n       }\n \n       for (int i = 0; i < (initialDefaultCapacity * 2); i++) {\n-        double value = accessor.get(i);\n+        double value = vector.get(i);\n         assertEquals(baseValue + (double)i, value, 0);\n       }\n \n       /* this should trigger a realloc */\n-      mutator.setSafe(initialDefaultCapacity * 2, baseValue + (double)(initialDefaultCapacity * 2));\n+      vector.setSafe(initialDefaultCapacity * 2, baseValue + (double)(initialDefaultCapacity * 2));\n       assertEquals(initialDefaultCapacity * 4, vector.getValueCapacity());\n \n       for (int i = (initialDefaultCapacity * 2) + 1; i < (initialDefaultCapacity * 4); i++) {\n-        mutator.setSafe(i, baseValue + (double)i);\n+        vector.setSafe(i, baseValue + (double)i);\n       }\n \n       for (int i = 0; i < (initialDefaultCapacity * 4); i++) {\n-        double value = accessor.get(i);\n+        double value = vector.get(i);\n         assertEquals(baseValue + (double)i, value, 0);\n       }\n \n@@ -1123,12 +1114,11 @@ public void testReallocAfterVectorTransfer2() {\n       transferPair.transfer();\n \n       NullableFloat8Vector toVector = (NullableFloat8Vector)transferPair.getTo();\n-      final NullableFloat8Vector.Accessor toAccessor = toVector.getAccessor();\n \n       /* check toVector contents before realloc */\n       for (int i = 0; i < (initialDefaultCapacity * 4); i++) {\n-        assertFalse(\"unexpected null value at index: \" + i, toAccessor.isNull(i));\n-        double value = toAccessor.get(i);\n+        assertFalse(\"unexpected null value at index: \" + i, toVector.isNull(i));\n+        double value = toVector.get(i);\n         assertEquals(\"unexpected value at index: \" + i, baseValue + (double)i, value, 0);\n       }\n \n@@ -1138,12 +1128,12 @@ public void testReallocAfterVectorTransfer2() {\n \n       for (int i = 0; i < (initialDefaultCapacity * 8); i++) {\n         if (i < (initialDefaultCapacity * 4)) {\n-          assertFalse(\"unexpected null value at index: \" + i, toAccessor.isNull(i));\n-          double value = toAccessor.get(i);\n+          assertFalse(\"unexpected null value at index: \" + i, toVector.isNull(i));\n+          double value = toVector.get(i);\n           assertEquals(\"unexpected value at index: \" + i, baseValue + (double)i, value, 0);\n         }\n         else {\n-          assertTrue(\"unexpected non-null value at index: \" + i, toAccessor.isNull(i));\n+          assertTrue(\"unexpected non-null value at index: \" + i, toVector.isNull(i));\n         }\n       }\n \n@@ -1351,32 +1341,30 @@ public void testReallocAfterVectorTransfer4() {\n   public void testReAllocNullableFixedWidthVector() {\n     // Create a new value vector for 1024 integers\n     try (final NullableFloat4Vector vector = newVector(NullableFloat4Vector.class, EMPTY_SCHEMA_PATH, MinorType.FLOAT4, allocator)) {\n-      final NullableFloat4Vector.Mutator m = vector.getMutator();\n       vector.allocateNew(1024);\n \n       assertEquals(1024, vector.getValueCapacity());\n \n       // Put values in indexes that fall within the initial allocation\n-      m.setSafe(0, 100.1f);\n-      m.setSafe(100, 102.3f);\n-      m.setSafe(1023, 104.5f);\n+      vector.setSafe(0, 100.1f);\n+      vector.setSafe(100, 102.3f);\n+      vector.setSafe(1023, 104.5f);\n \n       // Now try to put values in space that falls beyond the initial allocation\n-      m.setSafe(2000, 105.5f);\n+      vector.setSafe(2000, 105.5f);\n \n       // Check valueCapacity is more than initial allocation\n       assertEquals(1024 * 2, vector.getValueCapacity());\n \n-      final NullableFloat4Vector.Accessor accessor = vector.getAccessor();\n-      assertEquals(100.1f, accessor.get(0), 0);\n-      assertEquals(102.3f, accessor.get(100), 0);\n-      assertEquals(104.5f, accessor.get(1023), 0);\n-      assertEquals(105.5f, accessor.get(2000), 0);\n+      assertEquals(100.1f, vector.get(0), 0);\n+      assertEquals(102.3f, vector.get(100), 0);\n+      assertEquals(104.5f, vector.get(1023), 0);\n+      assertEquals(105.5f, vector.get(2000), 0);\n \n       // Set the valueCount to be more than valueCapacity of current allocation. This is possible for NullableValueVectors\n       // as we don't call setSafe for null values, but we do call setValueCount when all values are inserted into the\n       // vector\n-      m.setValueCount(vector.getValueCapacity() + 200);\n+      vector.setValueCount(vector.getValueCapacity() + 200);\n     }\n   }\n \ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java\nindex 531a46c27..293ffbfe1 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java\n@@ -28,6 +28,7 @@\n import org.apache.arrow.vector.complex.ListVector;\n import org.apache.arrow.vector.complex.NullableMapVector;\n import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.junit.After;\n import org.junit.Assert;\n@@ -115,7 +116,7 @@ public void testListType() {\n \n       vector.reAlloc();\n       assertEquals(2047, vector.getValueCapacity()); // note: size - 1\n-      assertEquals(0, vector.getOffsetVector().getAccessor().get(2014));\n+      assertEquals(0, vector.getOffsetBuffer().getInt(2014 * ListVector.OFFSET_WIDTH));\n     }\n   }\n \n@@ -138,7 +139,7 @@ public void testMapType() {\n \n       vector.reAlloc();\n       assertEquals(1024, vector.getValueCapacity());\n-      assertNull(vector.getAccessor().getObject(513));\n+      assertNull(vector.getObject(513));\n     }\n   }\n }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorUnloadLoad.java b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorUnloadLoad.java\nindex 0b7928dca..3853eecac 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorUnloadLoad.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorUnloadLoad.java\n@@ -199,8 +199,10 @@ public void testLoadValidityBuffer() throws IOException {\n     int count = 10;\n     ArrowBuf[] values = new ArrowBuf[4];\n     for (int i = 0; i < 4; i+=2) {\n-      ArrowBuf buf1 = allocator.buffer((int)Math.ceil(count / 8.0));\n+      ArrowBuf buf1 = allocator.buffer(BitVectorHelper.getValidityBufferSize(count));\n       ArrowBuf buf2 = allocator.buffer(count * 4); // integers\n+      buf1.setZero(0, buf1.capacity());\n+      buf2.setZero(0, buf2.capacity());\n       values[i] = buf1;\n       values[i+1] = buf2;\n       for (int j = 0; j < count; j++) {\n@@ -314,7 +316,7 @@ public void testUnloadLoadDuplicates() throws IOException {\n \n   public static VectorUnloader newVectorUnloader(FieldVector root) {\n     Schema schema = new Schema(root.getField().getChildren());\n-    int valueCount = root.getAccessor().getValueCount();\n+    int valueCount = root.getValueCount();\n     List<FieldVector> fields = root.getChildrenFromFields();\n     VectorSchemaRoot vsr = new VectorSchemaRoot(schema.getFields(), fields, valueCount);\n     return new VectorUnloader(vsr);\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/complex/impl/TestPromotableWriter.java b/java/vector/src/test/java/org/apache/arrow/vector/complex/impl/TestPromotableWriter.java\nindex 97efb7d5a..b0d6cf555 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/complex/impl/TestPromotableWriter.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/complex/impl/TestPromotableWriter.java\n@@ -80,24 +80,23 @@ public void testPromoteToUnion() throws Exception {\n \n       writer.end();\n \n-      container.getMutator().setValueCount(5);\n+      container.setValueCount(5);\n \n       final UnionVector uv = v.getChild(\"A\", UnionVector.class);\n-      final UnionVector.Accessor accessor = uv.getAccessor();\n \n-      assertFalse(\"0 shouldn't be null\", accessor.isNull(0));\n-      assertEquals(false, accessor.getObject(0));\n+      assertFalse(\"0 shouldn't be null\", uv.isNull(0));\n+      assertEquals(false, uv.getObject(0));\n \n-      assertFalse(\"1 shouldn't be null\", accessor.isNull(1));\n-      assertEquals(true, accessor.getObject(1));\n+      assertFalse(\"1 shouldn't be null\", uv.isNull(1));\n+      assertEquals(true, uv.getObject(1));\n \n-      assertFalse(\"2 shouldn't be null\", accessor.isNull(2));\n-      assertEquals(10, accessor.getObject(2));\n+      assertFalse(\"2 shouldn't be null\", uv.isNull(2));\n+      assertEquals(10, uv.getObject(2));\n \n-      assertTrue(\"3 should be null\", accessor.isNull(3));\n+      assertTrue(\"3 should be null\", uv.isNull(3));\n \n-      assertFalse(\"4 shouldn't be null\", accessor.isNull(4));\n-      assertEquals(100, accessor.getObject(4));\n+      assertFalse(\"4 shouldn't be null\", uv.isNull(4));\n+      assertEquals(100, uv.getObject(4));\n \n       container.clear();\n       container.allocateNew();\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/complex/writer/TestComplexWriter.java b/java/vector/src/test/java/org/apache/arrow/vector/complex/writer/TestComplexWriter.java\nindex 856d60724..52defdc2e 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/complex/writer/TestComplexWriter.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/complex/writer/TestComplexWriter.java\n@@ -456,7 +456,7 @@ public void simpleUnion() {\n         unionWriter.writeFloat4((float) i);\n       }\n     }\n-    vector.getMutator().setValueCount(COUNT);\n+    vector.setValueCount(COUNT);\n     UnionReader unionReader = new UnionReader(vector);\n     for (int i = 0; i < COUNT; i++) {\n       unionReader.setPosition(i);\n@@ -834,7 +834,7 @@ public void complexCopierWithList() {\n     TransferPair tp = mapVector.getTransferPair(allocator);\n     tp.splitAndTransfer(0, 1);\n     MapVector toMapVector = (MapVector) tp.getTo();\n-    JsonStringHashMap<?, ?> toMapValue = (JsonStringHashMap<?, ?>) toMapVector.getAccessor().getObject(0);\n+    JsonStringHashMap<?, ?> toMapValue = (JsonStringHashMap<?, ?>) toMapVector.getObject(0);\n     JsonStringArrayList<?> object = (JsonStringArrayList<?>) toMapValue.get(\"list\");\n     assertEquals(1, object.get(0));\n     assertEquals(2, object.get(1));\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/file/BaseFileTest.java b/java/vector/src/test/java/org/apache/arrow/vector/file/BaseFileTest.java\nindex 60009b0a4..874ba99e2 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/file/BaseFileTest.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/file/BaseFileTest.java\n@@ -97,14 +97,8 @@ public void tearDown() {\n \n   protected void validateContent(int count, VectorSchemaRoot root) {\n     for (int i = 0; i < count; i++) {\n-      FieldVector fv = root.getVector(\"int\");\n-      if (fv instanceof NullableIntVector) {\n-        Assert.assertEquals(i, fv.getObject(i));\n-        Assert.assertEquals(Integer.valueOf(i), fv.getObject(i));\n-      } else {\n-        Assert.assertEquals(i, fv.getAccessor().getObject(i));\n-        Assert.assertEquals(Long.valueOf(i), fv.getAccessor().getObject(i));\n-      }\n+      Assert.assertEquals(i, root.getVector(\"int\").getObject(i));\n+      Assert.assertEquals(Long.valueOf(i), root.getVector(\"bigInt\").getObject(i));\n     }\n   }\n \n@@ -146,10 +140,9 @@ protected void writeComplexData(int count, MapVector parent) {\n   public void printVectors(List<FieldVector> vectors) {\n     for (FieldVector vector : vectors) {\n       LOGGER.debug(vector.getField().getName());\n-      Accessor accessor = vector.getAccessor();\n-      int valueCount = accessor.getValueCount();\n+      int valueCount = vector.getValueCount();\n       for (int i = 0; i < valueCount; i++) {\n-        LOGGER.debug(String.valueOf(accessor.getObject(i)));\n+        LOGGER.debug(String.valueOf(vector.getObject(i)));\n       }\n     }\n   }\n@@ -159,14 +152,14 @@ protected void validateComplexContent(int count, VectorSchemaRoot root) {\n     printVectors(root.getFieldVectors());\n     for (int i = 0; i < count; i++) {\n \n-      Object intVal = root.getVector(\"int\").getAccessor().getObject(i);\n+      Object intVal = root.getVector(\"int\").getObject(i);\n       if (i % 5 != 3) {\n         Assert.assertEquals(i, intVal);\n       } else {\n         Assert.assertNull(intVal);\n       }\n-      Assert.assertEquals(Long.valueOf(i), root.getVector(\"bigInt\").getAccessor().getObject(i));\n-      Assert.assertEquals(i % 3, ((List<?>) root.getVector(\"list\").getAccessor().getObject(i)).size());\n+      Assert.assertEquals(Long.valueOf(i), root.getVector(\"bigInt\").getObject(i));\n+      Assert.assertEquals(i % 3, ((List<?>) root.getVector(\"list\").getObject(i)).size());\n       NullableTimeStampMilliHolder h = new NullableTimeStampMilliHolder();\n       FieldReader mapReader = root.getVector(\"map\").getReader();\n       mapReader.setPosition(i);\n@@ -209,15 +202,15 @@ protected void validateDateTimeContent(int count, VectorSchemaRoot root) {\n     Assert.assertEquals(count, root.getRowCount());\n     printVectors(root.getFieldVectors());\n     for (int i = 0; i < count; i++) {\n-      long dateVal = ((NullableDateMilliVector) root.getVector(\"date\")).getAccessor().get(i);\n+      long dateVal = ((NullableDateMilliVector) root.getVector(\"date\")).get(i);\n       LocalDateTime dt = makeDateTimeFromCount(i);\n       LocalDateTime dateExpected = dt.minusMillis(dt.getMillisOfDay());\n       Assert.assertEquals(DateUtility.toMillis(dateExpected), dateVal);\n-      long timeVal = ((NullableTimeMilliVector) root.getVector(\"time\")).getAccessor().get(i);\n+      long timeVal = ((NullableTimeMilliVector) root.getVector(\"time\")).get(i);\n       Assert.assertEquals(dt.getMillisOfDay(), timeVal);\n-      Object timestampMilliVal = root.getVector(\"timestamp-milli\").getAccessor().getObject(i);\n+      Object timestampMilliVal = root.getVector(\"timestamp-milli\").getObject(i);\n       Assert.assertEquals(dt, timestampMilliVal);\n-      Object timestampMilliTZVal = root.getVector(\"timestamp-milliTZ\").getAccessor().getObject(i);\n+      Object timestampMilliTZVal = root.getVector(\"timestamp-milliTZ\").getObject(i);\n       Assert.assertEquals(DateUtility.toMillis(dt), timestampMilliTZVal);\n     }\n   }\n@@ -282,7 +275,7 @@ protected VectorSchemaRoot writeFlatDictionaryData(BufferAllocator bufferAllocat\n     List<Field> fields = ImmutableList.of(encodedVector1A.getField(), encodedVector1B.getField(), encodedVector2.getField());\n     List<FieldVector> vectors = ImmutableList.of(encodedVector1A, encodedVector1B, encodedVector2);\n \n-    return new VectorSchemaRoot(fields, vectors, encodedVector1A.getAccessor().getValueCount());\n+    return new VectorSchemaRoot(fields, vectors, encodedVector1A.getValueCount());\n   }\n \n   protected void validateFlatDictionary(VectorSchemaRoot root, DictionaryProvider provider) {\n@@ -293,14 +286,13 @@ protected void validateFlatDictionary(VectorSchemaRoot root, DictionaryProvider\n     Assert.assertNotNull(encoding1A);\n     Assert.assertEquals(1L, encoding1A.getId());\n \n-    FieldVector.Accessor accessor = vector1A.getAccessor();\n-    Assert.assertEquals(6, accessor.getValueCount());\n-    Assert.assertEquals(0, accessor.getObject(0));\n-    Assert.assertEquals(1, accessor.getObject(1));\n-    Assert.assertEquals(null, accessor.getObject(2));\n-    Assert.assertEquals(2, accessor.getObject(3));\n-    Assert.assertEquals(1, accessor.getObject(4));\n-    Assert.assertEquals(2, accessor.getObject(5));\n+    Assert.assertEquals(6, vector1A.getValueCount());\n+    Assert.assertEquals(0, vector1A.getObject(0));\n+    Assert.assertEquals(1, vector1A.getObject(1));\n+    Assert.assertEquals(null, vector1A.getObject(2));\n+    Assert.assertEquals(2, vector1A.getObject(3));\n+    Assert.assertEquals(1, vector1A.getObject(4));\n+    Assert.assertEquals(2, vector1A.getObject(5));\n \n     FieldVector vector1B = root.getVector(\"varcharB\");\n     Assert.assertNotNull(vector1B);\n@@ -310,14 +302,13 @@ protected void validateFlatDictionary(VectorSchemaRoot root, DictionaryProvider\n     Assert.assertTrue(encoding1A.equals(encoding1B));\n     Assert.assertEquals(1L, encoding1B.getId());\n \n-    accessor = vector1B.getAccessor();\n-    Assert.assertEquals(6, accessor.getValueCount());\n-    Assert.assertEquals(2, accessor.getObject(0));\n-    Assert.assertEquals(1, accessor.getObject(1));\n-    Assert.assertEquals(2, accessor.getObject(2));\n-    Assert.assertEquals(null, accessor.getObject(3));\n-    Assert.assertEquals(1, accessor.getObject(4));\n-    Assert.assertEquals(0, accessor.getObject(5));\n+    Assert.assertEquals(6, vector1B.getValueCount());\n+    Assert.assertEquals(2, vector1B.getObject(0));\n+    Assert.assertEquals(1, vector1B.getObject(1));\n+    Assert.assertEquals(2, vector1B.getObject(2));\n+    Assert.assertEquals(null, vector1B.getObject(3));\n+    Assert.assertEquals(1, vector1B.getObject(4));\n+    Assert.assertEquals(0, vector1B.getObject(5));\n \n     FieldVector vector2 = root.getVector(\"sizes\");\n     Assert.assertNotNull(vector2);\n@@ -326,30 +317,29 @@ protected void validateFlatDictionary(VectorSchemaRoot root, DictionaryProvider\n     Assert.assertNotNull(encoding2);\n     Assert.assertEquals(2L, encoding2.getId());\n \n-    accessor = vector2.getAccessor();\n-    Assert.assertEquals(6, accessor.getValueCount());\n-    Assert.assertEquals(null, accessor.getObject(0));\n-    Assert.assertEquals(2, accessor.getObject(1));\n-    Assert.assertEquals(1, accessor.getObject(2));\n-    Assert.assertEquals(1, accessor.getObject(3));\n-    Assert.assertEquals(2, accessor.getObject(4));\n-    Assert.assertEquals(null, accessor.getObject(5));\n+    Assert.assertEquals(6, vector2.getValueCount());\n+    Assert.assertEquals(null, vector2.getObject(0));\n+    Assert.assertEquals(2, vector2.getObject(1));\n+    Assert.assertEquals(1, vector2.getObject(2));\n+    Assert.assertEquals(1, vector2.getObject(3));\n+    Assert.assertEquals(2, vector2.getObject(4));\n+    Assert.assertEquals(null, vector2.getObject(5));\n \n     Dictionary dictionary1 = provider.lookup(1L);\n     Assert.assertNotNull(dictionary1);\n-    NullableVarCharVector.Accessor dictionaryAccessor = ((NullableVarCharVector) dictionary1.getVector()).getAccessor();\n-    Assert.assertEquals(3, dictionaryAccessor.getValueCount());\n-    Assert.assertEquals(new Text(\"foo\"), dictionaryAccessor.getObject(0));\n-    Assert.assertEquals(new Text(\"bar\"), dictionaryAccessor.getObject(1));\n-    Assert.assertEquals(new Text(\"baz\"), dictionaryAccessor.getObject(2));\n+    NullableVarCharVector dictionaryVector = ((NullableVarCharVector) dictionary1.getVector());\n+    Assert.assertEquals(3, dictionaryVector.getValueCount());\n+    Assert.assertEquals(new Text(\"foo\"), dictionaryVector.getObject(0));\n+    Assert.assertEquals(new Text(\"bar\"), dictionaryVector.getObject(1));\n+    Assert.assertEquals(new Text(\"baz\"), dictionaryVector.getObject(2));\n \n     Dictionary dictionary2 = provider.lookup(2L);\n     Assert.assertNotNull(dictionary2);\n-    dictionaryAccessor = ((NullableVarCharVector) dictionary2.getVector()).getAccessor();\n-    Assert.assertEquals(3, dictionaryAccessor.getValueCount());\n-    Assert.assertEquals(new Text(\"micro\"), dictionaryAccessor.getObject(0));\n-    Assert.assertEquals(new Text(\"small\"), dictionaryAccessor.getObject(1));\n-    Assert.assertEquals(new Text(\"large\"), dictionaryAccessor.getObject(2));\n+    dictionaryVector = ((NullableVarCharVector) dictionary2.getVector());\n+    Assert.assertEquals(3, dictionaryVector.getValueCount());\n+    Assert.assertEquals(new Text(\"micro\"), dictionaryVector.getObject(0));\n+    Assert.assertEquals(new Text(\"small\"), dictionaryVector.getObject(1));\n+    Assert.assertEquals(new Text(\"large\"), dictionaryVector.getObject(2));\n   }\n \n   protected VectorSchemaRoot writeNestedDictionaryData(BufferAllocator bufferAllocator, DictionaryProvider.MapDictionaryProvider provider) {\n@@ -359,7 +349,7 @@ protected VectorSchemaRoot writeNestedDictionaryData(BufferAllocator bufferAlloc\n     dictionaryVector.allocateNewSafe();\n     dictionaryVector.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n     dictionaryVector.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n-    dictionaryVector.getMutator().setValueCount(2);\n+    dictionaryVector.setValueCount(2);\n \n     Dictionary dictionary = new Dictionary(dictionaryVector, new DictionaryEncoding(2L, false, null));\n     provider.put(dictionary);\n@@ -398,18 +388,17 @@ protected void validateNestedDictionary(VectorSchemaRoot root, DictionaryProvide\n     Assert.assertEquals(2L, encoding.getId());\n     Assert.assertEquals(new ArrowType.Int(32, true), encoding.getIndexType());\n \n-    FieldVector.Accessor accessor = vector.getAccessor();\n-    Assert.assertEquals(3, accessor.getValueCount());\n-    Assert.assertEquals(Arrays.asList(0, 1), accessor.getObject(0));\n-    Assert.assertEquals(Arrays.asList(0), accessor.getObject(1));\n-    Assert.assertEquals(Arrays.asList(1), accessor.getObject(2));\n+    Assert.assertEquals(3, vector.getValueCount());\n+    Assert.assertEquals(Arrays.asList(0, 1), vector.getObject(0));\n+    Assert.assertEquals(Arrays.asList(0), vector.getObject(1));\n+    Assert.assertEquals(Arrays.asList(1), vector.getObject(2));\n \n     Dictionary dictionary = provider.lookup(2L);\n     Assert.assertNotNull(dictionary);\n-    NullableVarCharVector.Accessor dictionaryAccessor = ((NullableVarCharVector) dictionary.getVector()).getAccessor();\n-    Assert.assertEquals(2, dictionaryAccessor.getValueCount());\n-    Assert.assertEquals(new Text(\"foo\"), dictionaryAccessor.getObject(0));\n-    Assert.assertEquals(new Text(\"bar\"), dictionaryAccessor.getObject(1));\n+    NullableVarCharVector dictionaryVector = ((NullableVarCharVector) dictionary.getVector());\n+    Assert.assertEquals(2, dictionaryVector.getValueCount());\n+    Assert.assertEquals(new Text(\"foo\"), dictionaryVector.getObject(0));\n+    Assert.assertEquals(new Text(\"bar\"), dictionaryVector.getObject(1));\n   }\n \n   protected VectorSchemaRoot writeDecimalData(BufferAllocator bufferAllocator) {\n@@ -423,14 +412,14 @@ protected VectorSchemaRoot writeDecimalData(BufferAllocator bufferAllocator) {\n     decimalVector3.allocateNew(count);\n \n     for (int i = 0; i < count; i++) {\n-      decimalVector1.getMutator().setSafe(i, new BigDecimal(BigInteger.valueOf(i), 3));\n-      decimalVector2.getMutator().setSafe(i, new BigDecimal(BigInteger.valueOf(i * (1 << 10)), 2));\n-      decimalVector3.getMutator().setSafe(i, new BigDecimal(BigInteger.valueOf(i * 1111111111111111L), 8));\n+      decimalVector1.setSafe(i, new BigDecimal(BigInteger.valueOf(i), 3));\n+      decimalVector2.setSafe(i, new BigDecimal(BigInteger.valueOf(i * (1 << 10)), 2));\n+      decimalVector3.setSafe(i, new BigDecimal(BigInteger.valueOf(i * 1111111111111111L), 8));\n     }\n \n-    decimalVector1.getMutator().setValueCount(count);\n-    decimalVector2.getMutator().setValueCount(count);\n-    decimalVector3.getMutator().setValueCount(count);\n+    decimalVector1.setValueCount(count);\n+    decimalVector2.setValueCount(count);\n+    decimalVector3.setValueCount(count);\n \n     List<Field> fields = ImmutableList.of(decimalVector1.getField(), decimalVector2.getField(), decimalVector3.getField());\n     List<FieldVector> vectors = ImmutableList.<FieldVector>of(decimalVector1, decimalVector2, decimalVector3);\n@@ -446,19 +435,19 @@ protected void validateDecimalData(VectorSchemaRoot root) {\n \n     for (int i = 0; i < count; i++) {\n       // Verify decimal 1 vector\n-      BigDecimal readValue = decimalVector1.getAccessor().getObject(i);\n+      BigDecimal readValue = decimalVector1.getObject(i);\n       ArrowType.Decimal type = (ArrowType.Decimal) decimalVector1.getField().getType();\n       BigDecimal genValue = new BigDecimal(BigInteger.valueOf(i), type.getScale());\n       Assert.assertEquals(genValue, readValue);\n \n       // Verify decimal 2 vector\n-      readValue = decimalVector2.getAccessor().getObject(i);\n+      readValue = decimalVector2.getObject(i);\n       type = (ArrowType.Decimal) decimalVector2.getField().getType();\n       genValue = new BigDecimal(BigInteger.valueOf(i * (1 << 10)), type.getScale());\n       Assert.assertEquals(genValue, readValue);\n \n       // Verify decimal 3 vector\n-      readValue = decimalVector3.getAccessor().getObject(i);\n+      readValue = decimalVector3.getObject(i);\n       type = (ArrowType.Decimal) decimalVector3.getField().getType();\n       genValue = new BigDecimal(BigInteger.valueOf(i * 1111111111111111L), type.getScale());\n       Assert.assertEquals(genValue, readValue);\n@@ -571,7 +560,7 @@ protected void validateVarBinary(int count, VectorSchemaRoot root) {\n     int numVarBinaryValues = 0;\n     for (int i = 0; i < count; i++) {\n       expectedArray[i] = (byte) i;\n-      Object obj = listVector.getAccessor().getObject(i);\n+      Object obj = listVector.getObject(i);\n       List<?> objList = (List) obj;\n       if (i % 3 == 0) {\n         Assert.assertTrue(objList.isEmpty());\n@@ -586,10 +575,10 @@ protected void validateVarBinary(int count, VectorSchemaRoot root) {\n     }\n \n     // ListVector lastSet should be the index of last value + 1\n-    Assert.assertEquals(listVector.getMutator().getLastSet(), count);\n+    Assert.assertEquals(listVector.getLastSet(), count);\n \n     // NullableVarBinaryVector lastSet should be the index of last value\n     NullableVarBinaryVector binaryVector = (NullableVarBinaryVector) listVector.getChildrenFromFields().get(0);\n-    Assert.assertEquals(binaryVector.getMutator().getLastSet(), numVarBinaryValues - 1);\n+    Assert.assertEquals(binaryVector.getLastSet(), numVarBinaryValues - 1);\n   }\n }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowFile.java b/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowFile.java\nindex feae08ea2..8559969a2 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowFile.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowFile.java\n@@ -317,11 +317,11 @@ public void testWriteReadTiny() throws IOException {\n \n     try (VectorSchemaRoot root = VectorSchemaRoot.create(MessageSerializerTest.testSchema(), allocator)) {\n       root.getFieldVectors().get(0).allocateNew();\n-      NullableTinyIntVector.Mutator mutator = (NullableTinyIntVector.Mutator) root.getFieldVectors().get(0).getMutator();\n+      NullableTinyIntVector vector = (NullableTinyIntVector) root.getFieldVectors().get(0);\n       for (int i = 0; i < 16; i++) {\n-        mutator.set(i, i < 8 ? 1 : 0, (byte) (i + 1));\n+        vector.set(i, i < 8 ? 1 : 0, (byte) (i + 1));\n       }\n-      mutator.setValueCount(16);\n+      vector.setValueCount(16);\n       root.setRowCount(16);\n \n       // write file\n@@ -368,9 +368,9 @@ private void validateTinyData(VectorSchemaRoot root) {\n     NullableTinyIntVector vector = (NullableTinyIntVector) root.getFieldVectors().get(0);\n     for (int i = 0; i < 16; i++) {\n       if (i < 8) {\n-        Assert.assertEquals((byte) (i + 1), vector.getAccessor().get(i));\n+        Assert.assertEquals((byte) (i + 1), vector.get(i));\n       } else {\n-        Assert.assertTrue(vector.getAccessor().isNull(i));\n+        Assert.assertTrue(vector.isNull(i));\n       }\n     }\n   }\n@@ -397,7 +397,7 @@ public void testWriteReadMetadata() throws IOException {\n     try (BufferAllocator originalVectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n          NullableMapVector vector = (NullableMapVector) field.createVector(originalVectorAllocator)) {\n       vector.allocateNewSafe();\n-      vector.getMutator().setValueCount(0);\n+      vector.setValueCount(0);\n \n       List<FieldVector> vectors = ImmutableList.<FieldVector>of(vector);\n       VectorSchemaRoot root = new VectorSchemaRoot(originalSchema, vectors, 0);\n@@ -578,13 +578,13 @@ public void testWriteReadFixedSizeList() throws IOException {\n       parent.allocateNew();\n \n       for (int i = 0; i < 10; i++) {\n-        tuples.getMutator().setNotNull(i);\n-        floats.getMutator().set(i * 2, i + 0.1f);\n-        floats.getMutator().set(i * 2 + 1, i + 10.1f);\n+        tuples.setNotNull(i);\n+        floats.set(i * 2, i + 0.1f);\n+        floats.set(i * 2 + 1, i + 10.1f);\n         ints.set(i, i);\n       }\n \n-      parent.getMutator().setValueCount(10);\n+      parent.setValueCount(10);\n       write(parent, file, stream);\n     }\n \n@@ -600,8 +600,8 @@ public void testWriteReadFixedSizeList() throws IOException {\n         arrowReader.loadRecordBatch(rbBlock);\n         Assert.assertEquals(count, root.getRowCount());\n         for (int i = 0; i < 10; i++) {\n-          Assert.assertEquals(Lists.newArrayList(i + 0.1f, i + 10.1f), root.getVector(\"float-pairs\").getAccessor().getObject(i));\n-          Assert.assertEquals(i, root.getVector(\"ints\").getAccessor().getObject(i));\n+          Assert.assertEquals(Lists.newArrayList(i + 0.1f, i + 10.1f), root.getVector(\"float-pairs\").getObject(i));\n+          Assert.assertEquals(i, root.getVector(\"ints\").getObject(i));\n         }\n       }\n     }\n@@ -616,8 +616,8 @@ public void testWriteReadFixedSizeList() throws IOException {\n       arrowReader.loadNextBatch();\n       Assert.assertEquals(count, root.getRowCount());\n       for (int i = 0; i < 10; i++) {\n-        Assert.assertEquals(Lists.newArrayList(i + 0.1f, i + 10.1f), root.getVector(\"float-pairs\").getAccessor().getObject(i));\n-        Assert.assertEquals(i, root.getVector(\"ints\").getAccessor().getObject(i));\n+        Assert.assertEquals(Lists.newArrayList(i + 0.1f, i + 10.1f), root.getVector(\"float-pairs\").getObject(i));\n+        Assert.assertEquals(i, root.getVector(\"ints\").getObject(i));\n       }\n     }\n   }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowStream.java b/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowStream.java\nindex e2efabef0..c7e34191a 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowStream.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowStream.java\n@@ -70,11 +70,11 @@ public void testReadWrite() throws IOException {\n       int numBatches = 1;\n \n       root.getFieldVectors().get(0).allocateNew();\n-      NullableTinyIntVector.Mutator mutator = (NullableTinyIntVector.Mutator) root.getFieldVectors().get(0).getMutator();\n+      NullableTinyIntVector vector = (NullableTinyIntVector)root.getFieldVectors().get(0);\n       for (int i = 0; i < 16; i++) {\n-        mutator.set(i, i < 8 ? 1 : 0, (byte) (i + 1));\n+        vector.set(i, i < 8 ? 1 : 0, (byte) (i + 1));\n       }\n-      mutator.setValueCount(16);\n+      vector.setValueCount(16);\n       root.setRowCount(16);\n \n       ByteArrayOutputStream out = new ByteArrayOutputStream();\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowStreamPipe.java b/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowStreamPipe.java\nindex a19c3795f..b989f95be 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowStreamPipe.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowStreamPipe.java\n@@ -62,13 +62,13 @@ public void run() {\n         writer.start();\n         for (int j = 0; j < numBatches; j++) {\n           root.getFieldVectors().get(0).allocateNew();\n-          NullableTinyIntVector.Mutator mutator = (NullableTinyIntVector.Mutator) root.getFieldVectors().get(0).getMutator();\n+          NullableTinyIntVector vector = (NullableTinyIntVector) root.getFieldVectors().get(0);\n           // Send a changing batch id first\n-          mutator.set(0, j);\n+          vector.set(0, j);\n           for (int i = 1; i < 16; i++) {\n-            mutator.set(i, i < 8 ? 1 : 0, (byte) (i + 1));\n+            vector.set(i, i < 8 ? 1 : 0, (byte) (i + 1));\n           }\n-          mutator.setValueCount(16);\n+          vector.setValueCount(16);\n           root.setRowCount(16);\n \n           writer.writeBatch();\n@@ -117,12 +117,12 @@ public boolean loadNextBatch() throws IOException {\n             VectorSchemaRoot root = getVectorSchemaRoot();\n             Assert.assertEquals(16, root.getRowCount());\n             NullableTinyIntVector vector = (NullableTinyIntVector) root.getFieldVectors().get(0);\n-            Assert.assertEquals((byte) (batchesRead - 1), vector.getAccessor().get(0));\n+            Assert.assertEquals((byte) (batchesRead - 1), vector.get(0));\n             for (int i = 1; i < 16; i++) {\n               if (i < 8) {\n-                Assert.assertEquals((byte) (i + 1), vector.getAccessor().get(i));\n+                Assert.assertEquals((byte) (i + 1), vector.get(i));\n               } else {\n-                Assert.assertTrue(vector.getAccessor().isNull(i));\n+                Assert.assertTrue(vector.isNull(i));\n               }\n             }\n           }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/file/json/TestJSONFile.java b/java/vector/src/test/java/org/apache/arrow/vector/file/json/TestJSONFile.java\nindex ee90d340d..5c4c48cd2 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/file/json/TestJSONFile.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/file/json/TestJSONFile.java\n@@ -280,7 +280,7 @@ public void testSetStructLength() throws IOException {\n       // initialize vectors\n       try (VectorSchemaRoot root = reader.read();) {\n         FieldVector vector = root.getVector(\"struct_nullable\");\n-        Assert.assertEquals(7, vector.getAccessor().getValueCount());\n+        Assert.assertEquals(7, vector.getValueCount());\n       }\n     }\n   }\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-10-24T00:42:26.686+0000",
                    "updated": "2017-10-24T00:42:26.686+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187/comment/16216145",
                    "id": "16216145",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Merged into java-vector-refactor branch https://github.com/apache/arrow/commit/612b9708658ece27b1ba12ee92a997652beb007b",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-10-24T00:42:48.906+0000",
                    "updated": "2017-10-24T00:42:48.906+0000"
                }
            ],
            "maxResults": 58,
            "total": 58,
            "startAt": 0
        },
        "customfield_12311820": "0|i3jpsf:",
        "customfield_12314139": null
    }
}