{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13359772",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13359772",
    "key": "ARROW-11710",
    "fields": {
        "parent": {
            "id": "13359357",
            "key": "ARROW-11689",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13359357",
            "fields": {
                "summary": "[Rust][DataFusion] Reduce copies in DataFusion LogicalPlan and Expr creation",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                    "description": "The issue is open and ready for the assignee to start work on it.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                    "name": "Open",
                    "id": "1",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                        "id": 2,
                        "key": "new",
                        "colorName": "blue-gray",
                        "name": "To Do"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                    "id": "2",
                    "description": "A new feature of the product, which has yet to be developed.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                    "name": "New Feature",
                    "subtask": false,
                    "avatarId": 21141
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12608985",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12608985",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13334586",
                    "key": "ARROW-10243",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13334586",
                    "fields": {
                        "summary": "[Rust] [Datafusion] Optimize literal expression evaluation",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
            "name": "alamb",
            "key": "alamb",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
            },
            "displayName": "Andrew Lamb",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12335005",
                "id": "12335005",
                "name": "Rust - DataFusion"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
            "name": "alamb",
            "key": "alamb",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
            },
            "displayName": "Andrew Lamb",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
            "name": "alamb",
            "key": "alamb",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
            },
            "displayName": "Andrew Lamb",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 6600,
            "total": 6600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 6600,
            "total": 6600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11710/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 11,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13359772/worklog/555766",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb opened a new pull request #9545:\nURL: https://github.com/apache/arrow/pull/9545\n\n\n   # Rationale:\r\n   This is part of a larger effort, described on [ARROW-11689](https://issues.apache.org/jira/browse/ARROW-11689). for making improvements to the DataFusion query optimizer easier to write and making it more efficient,. \r\n   \r\n   The idea is that by splitting out the expr traversal code from the code that does the actual rewriting, we will:\r\n   1. Reduce the amount repetitions in optimizer rules to make them easier to implement\r\n   2. Make the actual logic clearer as it is not intertwined in code needed to do recursion\r\n   2. Set the stage for a general `PlanRewriter` that doesn't have  to clone its input, and  can modify take their input by value and consume them.\r\n   \r\n   # Changes\r\n   This PR introduce a `ExpressionRewriter`, the mutable counterpart to `ExpressionVisitor` and demonstrates its usefulness by using it in the constant folding algorithm.\r\n   \r\n   Note this also reduces a bunch of copies in the constant folding algorithm. \r\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-22T12:00:59.121+0000",
                    "updated": "2021-02-22T12:00:59.121+0000",
                    "started": "2021-02-22T12:00:59.120+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "555766",
                    "issueId": "13359772"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13359772/worklog/555767",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #9545:\nURL: https://github.com/apache/arrow/pull/9545#issuecomment-783324993\n\n\n   https://issues.apache.org/jira/browse/ARROW-11710\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-22T12:01:12.644+0000",
                    "updated": "2021-02-22T12:01:12.644+0000",
                    "started": "2021-02-22T12:01:12.644+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "555767",
                    "issueId": "13359772"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13359772/worklog/555776",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #9545:\nURL: https://github.com/apache/arrow/pull/9545#discussion_r580214361\n\n\n\n##########\nFile path: rust/datafusion/src/optimizer/constant_folding.rs\n##########\n@@ -53,10 +53,13 @@ impl OptimizerRule for ConstantFolding {\n         // projected columns. With just the projected schema, it's not possible to infer types for\n         // expressions that references non-projected columns within the same project plan or its\n         // children plans.\n+        let mut rewriter = ConstantRewriter {\n\nReview comment:\n       FYI @houqp and @Dandandan  -- as discussed on https://github.com/apache/arrow/pull/9309#discussion_r564293129 here is a proposal of how to rewrite expressions directly without quite so much copying.\r\n   \r\n   It is part of my larger plan to make rewriting `LogicalPlans` easier too. \r\n   \r\n   Github kind of mangled the diff in this file, but the core change is that all code for recursing `Expr` trees that are not relevant to the constant folding is in `Expr::rewrite` now and no longer in this file\n\n##########\nFile path: rust/datafusion/src/optimizer/constant_folding.rs\n##########\n@@ -627,7 +554,7 @@ mod tests {\n \n         let expected = \"\\\n         Projection: #a\\\n-        \\n  Filter: NOT NOT #b\\\n+        \\n  Filter: #b\\\n\nReview comment:\n       This seems like an improvement to me `NOT NOT #b` is the same as `b` :) I suspect something was not quite right with the recursion previously\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-22T12:34:15.872+0000",
                    "updated": "2021-02-22T12:34:15.872+0000",
                    "started": "2021-02-22T12:34:15.872+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "555776",
                    "issueId": "13359772"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13359772/worklog/556220",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "houqp commented on a change in pull request #9545:\nURL: https://github.com/apache/arrow/pull/9545#discussion_r580824300\n\n\n\n##########\nFile path: rust/datafusion/src/optimizer/constant_folding.rs\n##########\n@@ -95,208 +97,122 @@ impl OptimizerRule for ConstantFolding {\n     }\n }\n \n-fn is_boolean_type(expr: &Expr, schemas: &[&DFSchemaRef]) -> bool {\n-    for schema in schemas {\n-        if let Ok(DataType::Boolean) = expr.get_type(schema) {\n-            return true;\n+struct ConstantRewriter<'a> {\n+    /// input schemas\n+    schemas: Vec<&'a DFSchemaRef>,\n+}\n+\n+impl<'a> ConstantRewriter<'a> {\n+    fn is_boolean_type(&self, expr: &Expr) -> bool {\n+        for schema in &self.schemas {\n+            if let Ok(DataType::Boolean) = expr.get_type(schema) {\n+                return true;\n+            }\n         }\n-    }\n \n-    false\n+        false\n+    }\n }\n \n-/// Recursively transverses the expression tree.\n-fn optimize_expr(e: &Expr, schemas: &[&DFSchemaRef]) -> Result<Expr> {\n-    Ok(match e {\n-        Expr::BinaryExpr { left, op, right } => {\n-            let left = optimize_expr(left, schemas)?;\n-            let right = optimize_expr(right, schemas)?;\n-            match op {\n-                Operator::Eq => match (&left, &right) {\n-                    (\n-                        Expr::Literal(ScalarValue::Boolean(l)),\n-                        Expr::Literal(ScalarValue::Boolean(r)),\n-                    ) => match (l, r) {\n-                        (Some(l), Some(r)) => {\n-                            Expr::Literal(ScalarValue::Boolean(Some(l == r)))\n-                        }\n-                        _ => Expr::Literal(ScalarValue::Boolean(None)),\n-                    },\n-                    (Expr::Literal(ScalarValue::Boolean(b)), _)\n-                        if is_boolean_type(&right, schemas) =>\n-                    {\n-                        match b {\n-                            Some(true) => right,\n-                            Some(false) => Expr::Not(Box::new(right)),\n-                            None => Expr::Literal(ScalarValue::Boolean(None)),\n+impl<'a> ExprRewriter for ConstantRewriter<'a> {\n+    /// rewrite the expression simplifying any constant expressions\n+    fn mutate(&mut self, expr: Expr) -> Result<Expr> {\n+        let new_expr = match expr {\n+            Expr::BinaryExpr { left, op, right } => {\n+                let left = left.rewrite(self)?;\n+                let right = right.rewrite(self)?;\n\nReview comment:\n       it looks like these manual rewrites are redundant because they should have been invoked during tree traversal before mutate was called.\n\n##########\nFile path: rust/datafusion/src/optimizer/constant_folding.rs\n##########\n@@ -627,7 +554,7 @@ mod tests {\n \n         let expected = \"\\\n         Projection: #a\\\n-        \\n  Filter: NOT NOT #b\\\n+        \\n  Filter: #b\\\n\nReview comment:\n       Yeah, my original implementation did the tree traversal wrong for not expr :P It was doing a preorder traversal, which requires a convergent loop to produce `#b` in this case. Nice catch.\n\n##########\nFile path: rust/datafusion/src/optimizer/constant_folding.rs\n##########\n@@ -95,208 +97,122 @@ impl OptimizerRule for ConstantFolding {\n     }\n }\n \n-fn is_boolean_type(expr: &Expr, schemas: &[&DFSchemaRef]) -> bool {\n-    for schema in schemas {\n-        if let Ok(DataType::Boolean) = expr.get_type(schema) {\n-            return true;\n+struct ConstantRewriter<'a> {\n+    /// input schemas\n+    schemas: Vec<&'a DFSchemaRef>,\n+}\n+\n+impl<'a> ConstantRewriter<'a> {\n+    fn is_boolean_type(&self, expr: &Expr) -> bool {\n+        for schema in &self.schemas {\n+            if let Ok(DataType::Boolean) = expr.get_type(schema) {\n+                return true;\n+            }\n         }\n-    }\n \n-    false\n+        false\n+    }\n }\n \n-/// Recursively transverses the expression tree.\n-fn optimize_expr(e: &Expr, schemas: &[&DFSchemaRef]) -> Result<Expr> {\n-    Ok(match e {\n-        Expr::BinaryExpr { left, op, right } => {\n-            let left = optimize_expr(left, schemas)?;\n-            let right = optimize_expr(right, schemas)?;\n-            match op {\n-                Operator::Eq => match (&left, &right) {\n-                    (\n-                        Expr::Literal(ScalarValue::Boolean(l)),\n-                        Expr::Literal(ScalarValue::Boolean(r)),\n-                    ) => match (l, r) {\n-                        (Some(l), Some(r)) => {\n-                            Expr::Literal(ScalarValue::Boolean(Some(l == r)))\n-                        }\n-                        _ => Expr::Literal(ScalarValue::Boolean(None)),\n-                    },\n-                    (Expr::Literal(ScalarValue::Boolean(b)), _)\n-                        if is_boolean_type(&right, schemas) =>\n-                    {\n-                        match b {\n-                            Some(true) => right,\n-                            Some(false) => Expr::Not(Box::new(right)),\n-                            None => Expr::Literal(ScalarValue::Boolean(None)),\n+impl<'a> ExprRewriter for ConstantRewriter<'a> {\n+    /// rewrite the expression simplifying any constant expressions\n+    fn mutate(&mut self, expr: Expr) -> Result<Expr> {\n+        let new_expr = match expr {\n+            Expr::BinaryExpr { left, op, right } => {\n+                let left = left.rewrite(self)?;\n+                let right = right.rewrite(self)?;\n+                match op {\n+                    Operator::Eq => match (&left, &right) {\n+                        (\n+                            Expr::Literal(ScalarValue::Boolean(l)),\n+                            Expr::Literal(ScalarValue::Boolean(r)),\n+                        ) => match (l, r) {\n+                            (Some(l), Some(r)) => {\n+                                Expr::Literal(ScalarValue::Boolean(Some(l == r)))\n+                            }\n+                            _ => Expr::Literal(ScalarValue::Boolean(None)),\n+                        },\n+                        (Expr::Literal(ScalarValue::Boolean(b)), _)\n+                            if self.is_boolean_type(&right) =>\n+                        {\n+                            match b {\n+                                Some(true) => right,\n+                                Some(false) => Expr::Not(Box::new(right)),\n+                                None => Expr::Literal(ScalarValue::Boolean(None)),\n+                            }\n                         }\n-                    }\n-                    (_, Expr::Literal(ScalarValue::Boolean(b)))\n-                        if is_boolean_type(&left, schemas) =>\n-                    {\n-                        match b {\n-                            Some(true) => left,\n-                            Some(false) => Expr::Not(Box::new(left)),\n-                            None => Expr::Literal(ScalarValue::Boolean(None)),\n+                        (_, Expr::Literal(ScalarValue::Boolean(b)))\n+                            if self.is_boolean_type(&left) =>\n+                        {\n+                            match b {\n+                                Some(true) => left,\n+                                Some(false) => Expr::Not(Box::new(left)),\n+                                None => Expr::Literal(ScalarValue::Boolean(None)),\n+                            }\n                         }\n-                    }\n-                    _ => Expr::BinaryExpr {\n-                        left: Box::new(left),\n-                        op: Operator::Eq,\n-                        right: Box::new(right),\n-                    },\n-                },\n-                Operator::NotEq => match (&left, &right) {\n-                    (\n-                        Expr::Literal(ScalarValue::Boolean(l)),\n-                        Expr::Literal(ScalarValue::Boolean(r)),\n-                    ) => match (l, r) {\n-                        (Some(l), Some(r)) => {\n-                            Expr::Literal(ScalarValue::Boolean(Some(l != r)))\n-                        }\n-                        _ => Expr::Literal(ScalarValue::Boolean(None)),\n+                        _ => Expr::BinaryExpr {\n+                            left: Box::new(left),\n+                            op: Operator::Eq,\n+                            right: Box::new(right),\n+                        },\n                     },\n-                    (Expr::Literal(ScalarValue::Boolean(b)), _)\n-                        if is_boolean_type(&right, schemas) =>\n-                    {\n-                        match b {\n-                            Some(true) => Expr::Not(Box::new(right)),\n-                            Some(false) => right,\n-                            None => Expr::Literal(ScalarValue::Boolean(None)),\n+                    Operator::NotEq => match (&left, &right) {\n+                        (\n+                            Expr::Literal(ScalarValue::Boolean(l)),\n+                            Expr::Literal(ScalarValue::Boolean(r)),\n+                        ) => match (l, r) {\n+                            (Some(l), Some(r)) => {\n+                                Expr::Literal(ScalarValue::Boolean(Some(l != r)))\n+                            }\n+                            _ => Expr::Literal(ScalarValue::Boolean(None)),\n+                        },\n+                        (Expr::Literal(ScalarValue::Boolean(b)), _)\n+                            if self.is_boolean_type(&right) =>\n+                        {\n+                            match b {\n+                                Some(true) => Expr::Not(Box::new(right)),\n+                                Some(false) => right,\n+                                None => Expr::Literal(ScalarValue::Boolean(None)),\n+                            }\n                         }\n-                    }\n-                    (_, Expr::Literal(ScalarValue::Boolean(b)))\n-                        if is_boolean_type(&left, schemas) =>\n-                    {\n-                        match b {\n-                            Some(true) => Expr::Not(Box::new(left)),\n-                            Some(false) => left,\n-                            None => Expr::Literal(ScalarValue::Boolean(None)),\n+                        (_, Expr::Literal(ScalarValue::Boolean(b)))\n+                            if self.is_boolean_type(&left) =>\n+                        {\n+                            match b {\n+                                Some(true) => Expr::Not(Box::new(left)),\n+                                Some(false) => left,\n+                                None => Expr::Literal(ScalarValue::Boolean(None)),\n+                            }\n                         }\n-                    }\n+                        _ => Expr::BinaryExpr {\n+                            left: Box::new(left),\n+                            op: Operator::NotEq,\n+                            right: Box::new(right),\n+                        },\n+                    },\n                     _ => Expr::BinaryExpr {\n                         left: Box::new(left),\n-                        op: Operator::NotEq,\n+                        op,\n                         right: Box::new(right),\n                     },\n-                },\n-                _ => Expr::BinaryExpr {\n-                    left: Box::new(left),\n-                    op: *op,\n-                    right: Box::new(right),\n-                },\n+                }\n             }\n-        }\n-        Expr::Not(expr) => match &**expr {\n-            Expr::Not(inner) => optimize_expr(&inner, schemas)?,\n-            _ => Expr::Not(Box::new(optimize_expr(&expr, schemas)?)),\n-        },\n-        Expr::Case {\n-            expr,\n-            when_then_expr,\n-            else_expr,\n-        } => {\n-            // recurse into CASE WHEN condition expressions\n-            Expr::Case {\n-                expr: match expr {\n-                    Some(e) => Some(Box::new(optimize_expr(e, schemas)?)),\n-                    None => None,\n-                },\n-                when_then_expr: when_then_expr\n-                    .iter()\n-                    .map(|(when, then)| {\n-                        Ok((\n-                            Box::new(optimize_expr(when, schemas)?),\n-                            Box::new(optimize_expr(then, schemas)?),\n-                        ))\n-                    })\n-                    .collect::<Result<_>>()?,\n-                else_expr: match else_expr {\n-                    Some(e) => Some(Box::new(optimize_expr(e, schemas)?)),\n-                    None => None,\n-                },\n+            Expr::Not(inner) => {\n+                // Not(Not(expr)) --> expr\n+                let inner = inner.rewrite(self)?;\n\nReview comment:\n       Same here, i think this rewrite is not needed.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-23T08:03:50.313+0000",
                    "updated": "2021-02-23T08:03:50.313+0000",
                    "started": "2021-02-23T08:03:50.313+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "556220",
                    "issueId": "13359772"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13359772/worklog/556222",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "houqp commented on a change in pull request #9545:\nURL: https://github.com/apache/arrow/pull/9545#discussion_r580832272\n\n\n\n##########\nFile path: rust/datafusion/src/optimizer/constant_folding.rs\n##########\n@@ -95,208 +97,122 @@ impl OptimizerRule for ConstantFolding {\n     }\n }\n \n-fn is_boolean_type(expr: &Expr, schemas: &[&DFSchemaRef]) -> bool {\n-    for schema in schemas {\n-        if let Ok(DataType::Boolean) = expr.get_type(schema) {\n-            return true;\n+struct ConstantRewriter<'a> {\n+    /// input schemas\n+    schemas: Vec<&'a DFSchemaRef>,\n+}\n+\n+impl<'a> ConstantRewriter<'a> {\n+    fn is_boolean_type(&self, expr: &Expr) -> bool {\n+        for schema in &self.schemas {\n+            if let Ok(DataType::Boolean) = expr.get_type(schema) {\n+                return true;\n+            }\n         }\n-    }\n \n-    false\n+        false\n+    }\n }\n \n-/// Recursively transverses the expression tree.\n-fn optimize_expr(e: &Expr, schemas: &[&DFSchemaRef]) -> Result<Expr> {\n-    Ok(match e {\n-        Expr::BinaryExpr { left, op, right } => {\n-            let left = optimize_expr(left, schemas)?;\n-            let right = optimize_expr(right, schemas)?;\n-            match op {\n-                Operator::Eq => match (&left, &right) {\n-                    (\n-                        Expr::Literal(ScalarValue::Boolean(l)),\n-                        Expr::Literal(ScalarValue::Boolean(r)),\n-                    ) => match (l, r) {\n-                        (Some(l), Some(r)) => {\n-                            Expr::Literal(ScalarValue::Boolean(Some(l == r)))\n-                        }\n-                        _ => Expr::Literal(ScalarValue::Boolean(None)),\n-                    },\n-                    (Expr::Literal(ScalarValue::Boolean(b)), _)\n-                        if is_boolean_type(&right, schemas) =>\n-                    {\n-                        match b {\n-                            Some(true) => right,\n-                            Some(false) => Expr::Not(Box::new(right)),\n-                            None => Expr::Literal(ScalarValue::Boolean(None)),\n+impl<'a> ExprRewriter for ConstantRewriter<'a> {\n+    /// rewrite the expression simplifying any constant expressions\n+    fn mutate(&mut self, expr: Expr) -> Result<Expr> {\n+        let new_expr = match expr {\n+            Expr::BinaryExpr { left, op, right } => {\n+                let left = left.rewrite(self)?;\n+                let right = right.rewrite(self)?;\n+                match op {\n+                    Operator::Eq => match (&left, &right) {\n+                        (\n+                            Expr::Literal(ScalarValue::Boolean(l)),\n+                            Expr::Literal(ScalarValue::Boolean(r)),\n+                        ) => match (l, r) {\n+                            (Some(l), Some(r)) => {\n+                                Expr::Literal(ScalarValue::Boolean(Some(l == r)))\n+                            }\n+                            _ => Expr::Literal(ScalarValue::Boolean(None)),\n+                        },\n+                        (Expr::Literal(ScalarValue::Boolean(b)), _)\n+                            if self.is_boolean_type(&right) =>\n+                        {\n+                            match b {\n+                                Some(true) => right,\n+                                Some(false) => Expr::Not(Box::new(right)),\n+                                None => Expr::Literal(ScalarValue::Boolean(None)),\n+                            }\n                         }\n-                    }\n-                    (_, Expr::Literal(ScalarValue::Boolean(b)))\n-                        if is_boolean_type(&left, schemas) =>\n-                    {\n-                        match b {\n-                            Some(true) => left,\n-                            Some(false) => Expr::Not(Box::new(left)),\n-                            None => Expr::Literal(ScalarValue::Boolean(None)),\n+                        (_, Expr::Literal(ScalarValue::Boolean(b)))\n+                            if self.is_boolean_type(&left) =>\n+                        {\n+                            match b {\n+                                Some(true) => left,\n+                                Some(false) => Expr::Not(Box::new(left)),\n+                                None => Expr::Literal(ScalarValue::Boolean(None)),\n+                            }\n                         }\n-                    }\n-                    _ => Expr::BinaryExpr {\n-                        left: Box::new(left),\n-                        op: Operator::Eq,\n-                        right: Box::new(right),\n-                    },\n-                },\n-                Operator::NotEq => match (&left, &right) {\n-                    (\n-                        Expr::Literal(ScalarValue::Boolean(l)),\n-                        Expr::Literal(ScalarValue::Boolean(r)),\n-                    ) => match (l, r) {\n-                        (Some(l), Some(r)) => {\n-                            Expr::Literal(ScalarValue::Boolean(Some(l != r)))\n-                        }\n-                        _ => Expr::Literal(ScalarValue::Boolean(None)),\n+                        _ => Expr::BinaryExpr {\n+                            left: Box::new(left),\n+                            op: Operator::Eq,\n+                            right: Box::new(right),\n+                        },\n                     },\n-                    (Expr::Literal(ScalarValue::Boolean(b)), _)\n-                        if is_boolean_type(&right, schemas) =>\n-                    {\n-                        match b {\n-                            Some(true) => Expr::Not(Box::new(right)),\n-                            Some(false) => right,\n-                            None => Expr::Literal(ScalarValue::Boolean(None)),\n+                    Operator::NotEq => match (&left, &right) {\n+                        (\n+                            Expr::Literal(ScalarValue::Boolean(l)),\n+                            Expr::Literal(ScalarValue::Boolean(r)),\n+                        ) => match (l, r) {\n+                            (Some(l), Some(r)) => {\n+                                Expr::Literal(ScalarValue::Boolean(Some(l != r)))\n+                            }\n+                            _ => Expr::Literal(ScalarValue::Boolean(None)),\n+                        },\n+                        (Expr::Literal(ScalarValue::Boolean(b)), _)\n+                            if self.is_boolean_type(&right) =>\n+                        {\n+                            match b {\n+                                Some(true) => Expr::Not(Box::new(right)),\n+                                Some(false) => right,\n+                                None => Expr::Literal(ScalarValue::Boolean(None)),\n+                            }\n                         }\n-                    }\n-                    (_, Expr::Literal(ScalarValue::Boolean(b)))\n-                        if is_boolean_type(&left, schemas) =>\n-                    {\n-                        match b {\n-                            Some(true) => Expr::Not(Box::new(left)),\n-                            Some(false) => left,\n-                            None => Expr::Literal(ScalarValue::Boolean(None)),\n+                        (_, Expr::Literal(ScalarValue::Boolean(b)))\n+                            if self.is_boolean_type(&left) =>\n+                        {\n+                            match b {\n+                                Some(true) => Expr::Not(Box::new(left)),\n+                                Some(false) => left,\n+                                None => Expr::Literal(ScalarValue::Boolean(None)),\n+                            }\n                         }\n-                    }\n+                        _ => Expr::BinaryExpr {\n+                            left: Box::new(left),\n+                            op: Operator::NotEq,\n+                            right: Box::new(right),\n+                        },\n+                    },\n                     _ => Expr::BinaryExpr {\n                         left: Box::new(left),\n-                        op: Operator::NotEq,\n+                        op,\n                         right: Box::new(right),\n                     },\n-                },\n-                _ => Expr::BinaryExpr {\n-                    left: Box::new(left),\n-                    op: *op,\n-                    right: Box::new(right),\n-                },\n+                }\n             }\n-        }\n-        Expr::Not(expr) => match &**expr {\n-            Expr::Not(inner) => optimize_expr(&inner, schemas)?,\n-            _ => Expr::Not(Box::new(optimize_expr(&expr, schemas)?)),\n-        },\n-        Expr::Case {\n-            expr,\n-            when_then_expr,\n-            else_expr,\n-        } => {\n-            // recurse into CASE WHEN condition expressions\n-            Expr::Case {\n-                expr: match expr {\n-                    Some(e) => Some(Box::new(optimize_expr(e, schemas)?)),\n-                    None => None,\n-                },\n-                when_then_expr: when_then_expr\n-                    .iter()\n-                    .map(|(when, then)| {\n-                        Ok((\n-                            Box::new(optimize_expr(when, schemas)?),\n-                            Box::new(optimize_expr(then, schemas)?),\n-                        ))\n-                    })\n-                    .collect::<Result<_>>()?,\n-                else_expr: match else_expr {\n-                    Some(e) => Some(Box::new(optimize_expr(e, schemas)?)),\n-                    None => None,\n-                },\n+            Expr::Not(inner) => {\n+                // Not(Not(expr)) --> expr\n+                let inner = inner.rewrite(self)?;\n+                if let Expr::Not(negated_inner) = inner {\n+                    *negated_inner\n+                } else {\n+                    Expr::Not(Box::new(inner))\n+                }\n             }\n-        }\n-        Expr::Alias(expr, name) => {\n-            Expr::Alias(Box::new(optimize_expr(expr, schemas)?), name.clone())\n-        }\n-        Expr::Negative(expr) => Expr::Negative(Box::new(optimize_expr(expr, schemas)?)),\n-        Expr::InList {\n-            expr,\n-            list,\n-            negated,\n-        } => Expr::InList {\n-            expr: Box::new(optimize_expr(expr, schemas)?),\n-            list: list\n-                .iter()\n-                .map(|e| optimize_expr(e, schemas))\n-                .collect::<Result<_>>()?,\n-            negated: *negated,\n-        },\n-        Expr::IsNotNull(expr) => Expr::IsNotNull(Box::new(optimize_expr(expr, schemas)?)),\n-        Expr::IsNull(expr) => Expr::IsNull(Box::new(optimize_expr(expr, schemas)?)),\n-        Expr::Cast { expr, data_type } => Expr::Cast {\n-            expr: Box::new(optimize_expr(expr, schemas)?),\n-            data_type: data_type.clone(),\n-        },\n-        Expr::Between {\n-            expr,\n-            negated,\n-            low,\n-            high,\n-        } => Expr::Between {\n-            expr: Box::new(optimize_expr(expr, schemas)?),\n-            negated: *negated,\n-            low: Box::new(optimize_expr(low, schemas)?),\n-            high: Box::new(optimize_expr(high, schemas)?),\n-        },\n-        Expr::ScalarFunction { fun, args } => Expr::ScalarFunction {\n-            fun: fun.clone(),\n-            args: args\n-                .iter()\n-                .map(|e| optimize_expr(e, schemas))\n-                .collect::<Result<_>>()?,\n-        },\n-        Expr::ScalarUDF { fun, args } => Expr::ScalarUDF {\n-            fun: fun.clone(),\n-            args: args\n-                .iter()\n-                .map(|e| optimize_expr(e, schemas))\n-                .collect::<Result<_>>()?,\n-        },\n-        Expr::AggregateFunction {\n-            fun,\n-            args,\n-            distinct,\n-        } => Expr::AggregateFunction {\n-            fun: fun.clone(),\n-            args: args\n-                .iter()\n-                .map(|e| optimize_expr(e, schemas))\n-                .collect::<Result<_>>()?,\n-            distinct: *distinct,\n-        },\n-        Expr::AggregateUDF { fun, args } => Expr::AggregateUDF {\n-            fun: fun.clone(),\n-            args: args\n-                .iter()\n-                .map(|e| optimize_expr(e, schemas))\n-                .collect::<Result<_>>()?,\n-        },\n-        Expr::Sort {\n-            expr,\n-            asc,\n-            nulls_first,\n-        } => Expr::Sort {\n-            expr: Box::new(optimize_expr(expr, schemas)?),\n-            asc: *asc,\n-            nulls_first: *nulls_first,\n-        },\n-        Expr::Column { .. }\n-        | Expr::ScalarVariable { .. }\n-        | Expr::Literal { .. }\n-        | Expr::Wildcard => e.clone(),\n\nReview comment:\n       minor, but I think we can use the pre_visit method to skip traversal for these expressions.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-23T08:05:06.576+0000",
                    "updated": "2021-02-23T08:05:06.576+0000",
                    "started": "2021-02-23T08:05:06.576+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "556222",
                    "issueId": "13359772"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13359772/worklog/556281",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #9545:\nURL: https://github.com/apache/arrow/pull/9545#discussion_r580953922\n\n\n\n##########\nFile path: rust/datafusion/src/optimizer/constant_folding.rs\n##########\n@@ -95,208 +97,122 @@ impl OptimizerRule for ConstantFolding {\n     }\n }\n \n-fn is_boolean_type(expr: &Expr, schemas: &[&DFSchemaRef]) -> bool {\n-    for schema in schemas {\n-        if let Ok(DataType::Boolean) = expr.get_type(schema) {\n-            return true;\n+struct ConstantRewriter<'a> {\n+    /// input schemas\n+    schemas: Vec<&'a DFSchemaRef>,\n+}\n+\n+impl<'a> ConstantRewriter<'a> {\n+    fn is_boolean_type(&self, expr: &Expr) -> bool {\n+        for schema in &self.schemas {\n+            if let Ok(DataType::Boolean) = expr.get_type(schema) {\n+                return true;\n+            }\n         }\n-    }\n \n-    false\n+        false\n+    }\n }\n \n-/// Recursively transverses the expression tree.\n-fn optimize_expr(e: &Expr, schemas: &[&DFSchemaRef]) -> Result<Expr> {\n-    Ok(match e {\n-        Expr::BinaryExpr { left, op, right } => {\n-            let left = optimize_expr(left, schemas)?;\n-            let right = optimize_expr(right, schemas)?;\n-            match op {\n-                Operator::Eq => match (&left, &right) {\n-                    (\n-                        Expr::Literal(ScalarValue::Boolean(l)),\n-                        Expr::Literal(ScalarValue::Boolean(r)),\n-                    ) => match (l, r) {\n-                        (Some(l), Some(r)) => {\n-                            Expr::Literal(ScalarValue::Boolean(Some(l == r)))\n-                        }\n-                        _ => Expr::Literal(ScalarValue::Boolean(None)),\n-                    },\n-                    (Expr::Literal(ScalarValue::Boolean(b)), _)\n-                        if is_boolean_type(&right, schemas) =>\n-                    {\n-                        match b {\n-                            Some(true) => right,\n-                            Some(false) => Expr::Not(Box::new(right)),\n-                            None => Expr::Literal(ScalarValue::Boolean(None)),\n+impl<'a> ExprRewriter for ConstantRewriter<'a> {\n+    /// rewrite the expression simplifying any constant expressions\n+    fn mutate(&mut self, expr: Expr) -> Result<Expr> {\n+        let new_expr = match expr {\n+            Expr::BinaryExpr { left, op, right } => {\n+                let left = left.rewrite(self)?;\n+                let right = right.rewrite(self)?;\n\nReview comment:\n       That is a great call -- I will try and remove them. \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-23T11:18:12.683+0000",
                    "updated": "2021-02-23T11:18:12.683+0000",
                    "started": "2021-02-23T11:18:12.682+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "556281",
                    "issueId": "13359772"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13359772/worklog/557587",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #9545:\nURL: https://github.com/apache/arrow/pull/9545#discussion_r582374615\n\n\n\n##########\nFile path: rust/datafusion/src/optimizer/constant_folding.rs\n##########\n@@ -95,208 +97,122 @@ impl OptimizerRule for ConstantFolding {\n     }\n }\n \n-fn is_boolean_type(expr: &Expr, schemas: &[&DFSchemaRef]) -> bool {\n-    for schema in schemas {\n-        if let Ok(DataType::Boolean) = expr.get_type(schema) {\n-            return true;\n+struct ConstantRewriter<'a> {\n+    /// input schemas\n+    schemas: Vec<&'a DFSchemaRef>,\n+}\n+\n+impl<'a> ConstantRewriter<'a> {\n+    fn is_boolean_type(&self, expr: &Expr) -> bool {\n+        for schema in &self.schemas {\n+            if let Ok(DataType::Boolean) = expr.get_type(schema) {\n+                return true;\n+            }\n         }\n-    }\n \n-    false\n+        false\n+    }\n }\n \n-/// Recursively transverses the expression tree.\n-fn optimize_expr(e: &Expr, schemas: &[&DFSchemaRef]) -> Result<Expr> {\n-    Ok(match e {\n-        Expr::BinaryExpr { left, op, right } => {\n-            let left = optimize_expr(left, schemas)?;\n-            let right = optimize_expr(right, schemas)?;\n-            match op {\n-                Operator::Eq => match (&left, &right) {\n-                    (\n-                        Expr::Literal(ScalarValue::Boolean(l)),\n-                        Expr::Literal(ScalarValue::Boolean(r)),\n-                    ) => match (l, r) {\n-                        (Some(l), Some(r)) => {\n-                            Expr::Literal(ScalarValue::Boolean(Some(l == r)))\n-                        }\n-                        _ => Expr::Literal(ScalarValue::Boolean(None)),\n-                    },\n-                    (Expr::Literal(ScalarValue::Boolean(b)), _)\n-                        if is_boolean_type(&right, schemas) =>\n-                    {\n-                        match b {\n-                            Some(true) => right,\n-                            Some(false) => Expr::Not(Box::new(right)),\n-                            None => Expr::Literal(ScalarValue::Boolean(None)),\n+impl<'a> ExprRewriter for ConstantRewriter<'a> {\n+    /// rewrite the expression simplifying any constant expressions\n+    fn mutate(&mut self, expr: Expr) -> Result<Expr> {\n+        let new_expr = match expr {\n+            Expr::BinaryExpr { left, op, right } => {\n+                let left = left.rewrite(self)?;\n+                let right = right.rewrite(self)?;\n+                match op {\n+                    Operator::Eq => match (&left, &right) {\n+                        (\n+                            Expr::Literal(ScalarValue::Boolean(l)),\n+                            Expr::Literal(ScalarValue::Boolean(r)),\n+                        ) => match (l, r) {\n+                            (Some(l), Some(r)) => {\n+                                Expr::Literal(ScalarValue::Boolean(Some(l == r)))\n+                            }\n+                            _ => Expr::Literal(ScalarValue::Boolean(None)),\n+                        },\n+                        (Expr::Literal(ScalarValue::Boolean(b)), _)\n+                            if self.is_boolean_type(&right) =>\n+                        {\n+                            match b {\n+                                Some(true) => right,\n+                                Some(false) => Expr::Not(Box::new(right)),\n+                                None => Expr::Literal(ScalarValue::Boolean(None)),\n+                            }\n                         }\n-                    }\n-                    (_, Expr::Literal(ScalarValue::Boolean(b)))\n-                        if is_boolean_type(&left, schemas) =>\n-                    {\n-                        match b {\n-                            Some(true) => left,\n-                            Some(false) => Expr::Not(Box::new(left)),\n-                            None => Expr::Literal(ScalarValue::Boolean(None)),\n+                        (_, Expr::Literal(ScalarValue::Boolean(b)))\n+                            if self.is_boolean_type(&left) =>\n+                        {\n+                            match b {\n+                                Some(true) => left,\n+                                Some(false) => Expr::Not(Box::new(left)),\n+                                None => Expr::Literal(ScalarValue::Boolean(None)),\n+                            }\n                         }\n-                    }\n-                    _ => Expr::BinaryExpr {\n-                        left: Box::new(left),\n-                        op: Operator::Eq,\n-                        right: Box::new(right),\n-                    },\n-                },\n-                Operator::NotEq => match (&left, &right) {\n-                    (\n-                        Expr::Literal(ScalarValue::Boolean(l)),\n-                        Expr::Literal(ScalarValue::Boolean(r)),\n-                    ) => match (l, r) {\n-                        (Some(l), Some(r)) => {\n-                            Expr::Literal(ScalarValue::Boolean(Some(l != r)))\n-                        }\n-                        _ => Expr::Literal(ScalarValue::Boolean(None)),\n+                        _ => Expr::BinaryExpr {\n+                            left: Box::new(left),\n+                            op: Operator::Eq,\n+                            right: Box::new(right),\n+                        },\n                     },\n-                    (Expr::Literal(ScalarValue::Boolean(b)), _)\n-                        if is_boolean_type(&right, schemas) =>\n-                    {\n-                        match b {\n-                            Some(true) => Expr::Not(Box::new(right)),\n-                            Some(false) => right,\n-                            None => Expr::Literal(ScalarValue::Boolean(None)),\n+                    Operator::NotEq => match (&left, &right) {\n+                        (\n+                            Expr::Literal(ScalarValue::Boolean(l)),\n+                            Expr::Literal(ScalarValue::Boolean(r)),\n+                        ) => match (l, r) {\n+                            (Some(l), Some(r)) => {\n+                                Expr::Literal(ScalarValue::Boolean(Some(l != r)))\n+                            }\n+                            _ => Expr::Literal(ScalarValue::Boolean(None)),\n+                        },\n+                        (Expr::Literal(ScalarValue::Boolean(b)), _)\n+                            if self.is_boolean_type(&right) =>\n+                        {\n+                            match b {\n+                                Some(true) => Expr::Not(Box::new(right)),\n+                                Some(false) => right,\n+                                None => Expr::Literal(ScalarValue::Boolean(None)),\n+                            }\n                         }\n-                    }\n-                    (_, Expr::Literal(ScalarValue::Boolean(b)))\n-                        if is_boolean_type(&left, schemas) =>\n-                    {\n-                        match b {\n-                            Some(true) => Expr::Not(Box::new(left)),\n-                            Some(false) => left,\n-                            None => Expr::Literal(ScalarValue::Boolean(None)),\n+                        (_, Expr::Literal(ScalarValue::Boolean(b)))\n+                            if self.is_boolean_type(&left) =>\n+                        {\n+                            match b {\n+                                Some(true) => Expr::Not(Box::new(left)),\n+                                Some(false) => left,\n+                                None => Expr::Literal(ScalarValue::Boolean(None)),\n+                            }\n                         }\n-                    }\n+                        _ => Expr::BinaryExpr {\n+                            left: Box::new(left),\n+                            op: Operator::NotEq,\n+                            right: Box::new(right),\n+                        },\n+                    },\n                     _ => Expr::BinaryExpr {\n                         left: Box::new(left),\n-                        op: Operator::NotEq,\n+                        op,\n                         right: Box::new(right),\n                     },\n-                },\n-                _ => Expr::BinaryExpr {\n-                    left: Box::new(left),\n-                    op: *op,\n-                    right: Box::new(right),\n-                },\n+                }\n             }\n-        }\n-        Expr::Not(expr) => match &**expr {\n-            Expr::Not(inner) => optimize_expr(&inner, schemas)?,\n-            _ => Expr::Not(Box::new(optimize_expr(&expr, schemas)?)),\n-        },\n-        Expr::Case {\n-            expr,\n-            when_then_expr,\n-            else_expr,\n-        } => {\n-            // recurse into CASE WHEN condition expressions\n-            Expr::Case {\n-                expr: match expr {\n-                    Some(e) => Some(Box::new(optimize_expr(e, schemas)?)),\n-                    None => None,\n-                },\n-                when_then_expr: when_then_expr\n-                    .iter()\n-                    .map(|(when, then)| {\n-                        Ok((\n-                            Box::new(optimize_expr(when, schemas)?),\n-                            Box::new(optimize_expr(then, schemas)?),\n-                        ))\n-                    })\n-                    .collect::<Result<_>>()?,\n-                else_expr: match else_expr {\n-                    Some(e) => Some(Box::new(optimize_expr(e, schemas)?)),\n-                    None => None,\n-                },\n+            Expr::Not(inner) => {\n+                // Not(Not(expr)) --> expr\n+                let inner = inner.rewrite(self)?;\n\nReview comment:\n       The code gets quite a bit cleaner with this improvement @houqp  - thank you for the suggestion\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-24T23:16:29.521+0000",
                    "updated": "2021-02-24T23:16:29.521+0000",
                    "started": "2021-02-24T23:16:29.521+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "557587",
                    "issueId": "13359772"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13359772/worklog/557589",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #9545:\nURL: https://github.com/apache/arrow/pull/9545#discussion_r582375499\n\n\n\n##########\nFile path: rust/datafusion/src/optimizer/constant_folding.rs\n##########\n@@ -95,208 +97,122 @@ impl OptimizerRule for ConstantFolding {\n     }\n }\n \n-fn is_boolean_type(expr: &Expr, schemas: &[&DFSchemaRef]) -> bool {\n-    for schema in schemas {\n-        if let Ok(DataType::Boolean) = expr.get_type(schema) {\n-            return true;\n+struct ConstantRewriter<'a> {\n+    /// input schemas\n+    schemas: Vec<&'a DFSchemaRef>,\n+}\n+\n+impl<'a> ConstantRewriter<'a> {\n+    fn is_boolean_type(&self, expr: &Expr) -> bool {\n+        for schema in &self.schemas {\n+            if let Ok(DataType::Boolean) = expr.get_type(schema) {\n+                return true;\n+            }\n         }\n-    }\n \n-    false\n+        false\n+    }\n }\n \n-/// Recursively transverses the expression tree.\n-fn optimize_expr(e: &Expr, schemas: &[&DFSchemaRef]) -> Result<Expr> {\n-    Ok(match e {\n-        Expr::BinaryExpr { left, op, right } => {\n-            let left = optimize_expr(left, schemas)?;\n-            let right = optimize_expr(right, schemas)?;\n-            match op {\n-                Operator::Eq => match (&left, &right) {\n-                    (\n-                        Expr::Literal(ScalarValue::Boolean(l)),\n-                        Expr::Literal(ScalarValue::Boolean(r)),\n-                    ) => match (l, r) {\n-                        (Some(l), Some(r)) => {\n-                            Expr::Literal(ScalarValue::Boolean(Some(l == r)))\n-                        }\n-                        _ => Expr::Literal(ScalarValue::Boolean(None)),\n-                    },\n-                    (Expr::Literal(ScalarValue::Boolean(b)), _)\n-                        if is_boolean_type(&right, schemas) =>\n-                    {\n-                        match b {\n-                            Some(true) => right,\n-                            Some(false) => Expr::Not(Box::new(right)),\n-                            None => Expr::Literal(ScalarValue::Boolean(None)),\n+impl<'a> ExprRewriter for ConstantRewriter<'a> {\n+    /// rewrite the expression simplifying any constant expressions\n+    fn mutate(&mut self, expr: Expr) -> Result<Expr> {\n+        let new_expr = match expr {\n+            Expr::BinaryExpr { left, op, right } => {\n+                let left = left.rewrite(self)?;\n+                let right = right.rewrite(self)?;\n+                match op {\n+                    Operator::Eq => match (&left, &right) {\n+                        (\n+                            Expr::Literal(ScalarValue::Boolean(l)),\n+                            Expr::Literal(ScalarValue::Boolean(r)),\n+                        ) => match (l, r) {\n+                            (Some(l), Some(r)) => {\n+                                Expr::Literal(ScalarValue::Boolean(Some(l == r)))\n+                            }\n+                            _ => Expr::Literal(ScalarValue::Boolean(None)),\n+                        },\n+                        (Expr::Literal(ScalarValue::Boolean(b)), _)\n+                            if self.is_boolean_type(&right) =>\n+                        {\n+                            match b {\n+                                Some(true) => right,\n+                                Some(false) => Expr::Not(Box::new(right)),\n+                                None => Expr::Literal(ScalarValue::Boolean(None)),\n+                            }\n                         }\n-                    }\n-                    (_, Expr::Literal(ScalarValue::Boolean(b)))\n-                        if is_boolean_type(&left, schemas) =>\n-                    {\n-                        match b {\n-                            Some(true) => left,\n-                            Some(false) => Expr::Not(Box::new(left)),\n-                            None => Expr::Literal(ScalarValue::Boolean(None)),\n+                        (_, Expr::Literal(ScalarValue::Boolean(b)))\n+                            if self.is_boolean_type(&left) =>\n+                        {\n+                            match b {\n+                                Some(true) => left,\n+                                Some(false) => Expr::Not(Box::new(left)),\n+                                None => Expr::Literal(ScalarValue::Boolean(None)),\n+                            }\n                         }\n-                    }\n-                    _ => Expr::BinaryExpr {\n-                        left: Box::new(left),\n-                        op: Operator::Eq,\n-                        right: Box::new(right),\n-                    },\n-                },\n-                Operator::NotEq => match (&left, &right) {\n-                    (\n-                        Expr::Literal(ScalarValue::Boolean(l)),\n-                        Expr::Literal(ScalarValue::Boolean(r)),\n-                    ) => match (l, r) {\n-                        (Some(l), Some(r)) => {\n-                            Expr::Literal(ScalarValue::Boolean(Some(l != r)))\n-                        }\n-                        _ => Expr::Literal(ScalarValue::Boolean(None)),\n+                        _ => Expr::BinaryExpr {\n+                            left: Box::new(left),\n+                            op: Operator::Eq,\n+                            right: Box::new(right),\n+                        },\n                     },\n-                    (Expr::Literal(ScalarValue::Boolean(b)), _)\n-                        if is_boolean_type(&right, schemas) =>\n-                    {\n-                        match b {\n-                            Some(true) => Expr::Not(Box::new(right)),\n-                            Some(false) => right,\n-                            None => Expr::Literal(ScalarValue::Boolean(None)),\n+                    Operator::NotEq => match (&left, &right) {\n+                        (\n+                            Expr::Literal(ScalarValue::Boolean(l)),\n+                            Expr::Literal(ScalarValue::Boolean(r)),\n+                        ) => match (l, r) {\n+                            (Some(l), Some(r)) => {\n+                                Expr::Literal(ScalarValue::Boolean(Some(l != r)))\n+                            }\n+                            _ => Expr::Literal(ScalarValue::Boolean(None)),\n+                        },\n+                        (Expr::Literal(ScalarValue::Boolean(b)), _)\n+                            if self.is_boolean_type(&right) =>\n+                        {\n+                            match b {\n+                                Some(true) => Expr::Not(Box::new(right)),\n+                                Some(false) => right,\n+                                None => Expr::Literal(ScalarValue::Boolean(None)),\n+                            }\n                         }\n-                    }\n-                    (_, Expr::Literal(ScalarValue::Boolean(b)))\n-                        if is_boolean_type(&left, schemas) =>\n-                    {\n-                        match b {\n-                            Some(true) => Expr::Not(Box::new(left)),\n-                            Some(false) => left,\n-                            None => Expr::Literal(ScalarValue::Boolean(None)),\n+                        (_, Expr::Literal(ScalarValue::Boolean(b)))\n+                            if self.is_boolean_type(&left) =>\n+                        {\n+                            match b {\n+                                Some(true) => Expr::Not(Box::new(left)),\n+                                Some(false) => left,\n+                                None => Expr::Literal(ScalarValue::Boolean(None)),\n+                            }\n                         }\n-                    }\n+                        _ => Expr::BinaryExpr {\n+                            left: Box::new(left),\n+                            op: Operator::NotEq,\n+                            right: Box::new(right),\n+                        },\n+                    },\n                     _ => Expr::BinaryExpr {\n                         left: Box::new(left),\n-                        op: Operator::NotEq,\n+                        op,\n                         right: Box::new(right),\n                     },\n-                },\n-                _ => Expr::BinaryExpr {\n-                    left: Box::new(left),\n-                    op: *op,\n-                    right: Box::new(right),\n-                },\n+                }\n             }\n-        }\n-        Expr::Not(expr) => match &**expr {\n-            Expr::Not(inner) => optimize_expr(&inner, schemas)?,\n-            _ => Expr::Not(Box::new(optimize_expr(&expr, schemas)?)),\n-        },\n-        Expr::Case {\n-            expr,\n-            when_then_expr,\n-            else_expr,\n-        } => {\n-            // recurse into CASE WHEN condition expressions\n-            Expr::Case {\n-                expr: match expr {\n-                    Some(e) => Some(Box::new(optimize_expr(e, schemas)?)),\n-                    None => None,\n-                },\n-                when_then_expr: when_then_expr\n-                    .iter()\n-                    .map(|(when, then)| {\n-                        Ok((\n-                            Box::new(optimize_expr(when, schemas)?),\n-                            Box::new(optimize_expr(then, schemas)?),\n-                        ))\n-                    })\n-                    .collect::<Result<_>>()?,\n-                else_expr: match else_expr {\n-                    Some(e) => Some(Box::new(optimize_expr(e, schemas)?)),\n-                    None => None,\n-                },\n+            Expr::Not(inner) => {\n+                // Not(Not(expr)) --> expr\n+                let inner = inner.rewrite(self)?;\n+                if let Expr::Not(negated_inner) = inner {\n+                    *negated_inner\n+                } else {\n+                    Expr::Not(Box::new(inner))\n+                }\n             }\n-        }\n-        Expr::Alias(expr, name) => {\n-            Expr::Alias(Box::new(optimize_expr(expr, schemas)?), name.clone())\n-        }\n-        Expr::Negative(expr) => Expr::Negative(Box::new(optimize_expr(expr, schemas)?)),\n-        Expr::InList {\n-            expr,\n-            list,\n-            negated,\n-        } => Expr::InList {\n-            expr: Box::new(optimize_expr(expr, schemas)?),\n-            list: list\n-                .iter()\n-                .map(|e| optimize_expr(e, schemas))\n-                .collect::<Result<_>>()?,\n-            negated: *negated,\n-        },\n-        Expr::IsNotNull(expr) => Expr::IsNotNull(Box::new(optimize_expr(expr, schemas)?)),\n-        Expr::IsNull(expr) => Expr::IsNull(Box::new(optimize_expr(expr, schemas)?)),\n-        Expr::Cast { expr, data_type } => Expr::Cast {\n-            expr: Box::new(optimize_expr(expr, schemas)?),\n-            data_type: data_type.clone(),\n-        },\n-        Expr::Between {\n-            expr,\n-            negated,\n-            low,\n-            high,\n-        } => Expr::Between {\n-            expr: Box::new(optimize_expr(expr, schemas)?),\n-            negated: *negated,\n-            low: Box::new(optimize_expr(low, schemas)?),\n-            high: Box::new(optimize_expr(high, schemas)?),\n-        },\n-        Expr::ScalarFunction { fun, args } => Expr::ScalarFunction {\n-            fun: fun.clone(),\n-            args: args\n-                .iter()\n-                .map(|e| optimize_expr(e, schemas))\n-                .collect::<Result<_>>()?,\n-        },\n-        Expr::ScalarUDF { fun, args } => Expr::ScalarUDF {\n-            fun: fun.clone(),\n-            args: args\n-                .iter()\n-                .map(|e| optimize_expr(e, schemas))\n-                .collect::<Result<_>>()?,\n-        },\n-        Expr::AggregateFunction {\n-            fun,\n-            args,\n-            distinct,\n-        } => Expr::AggregateFunction {\n-            fun: fun.clone(),\n-            args: args\n-                .iter()\n-                .map(|e| optimize_expr(e, schemas))\n-                .collect::<Result<_>>()?,\n-            distinct: *distinct,\n-        },\n-        Expr::AggregateUDF { fun, args } => Expr::AggregateUDF {\n-            fun: fun.clone(),\n-            args: args\n-                .iter()\n-                .map(|e| optimize_expr(e, schemas))\n-                .collect::<Result<_>>()?,\n-        },\n-        Expr::Sort {\n-            expr,\n-            asc,\n-            nulls_first,\n-        } => Expr::Sort {\n-            expr: Box::new(optimize_expr(expr, schemas)?),\n-            asc: *asc,\n-            nulls_first: *nulls_first,\n-        },\n-        Expr::Column { .. }\n-        | Expr::ScalarVariable { .. }\n-        | Expr::Literal { .. }\n-        | Expr::Wildcard => e.clone(),\n\nReview comment:\n       I thought about it and I could not convince myself that this change this would gain much -- we still have to `match` on the Expr type so it would just move the list of the variants into another function (in a separate `match`) which seems to obscure the logic a bit for me\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-24T23:18:26.151+0000",
                    "updated": "2021-02-24T23:18:26.151+0000",
                    "started": "2021-02-24T23:18:26.150+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "557589",
                    "issueId": "13359772"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13359772/worklog/557592",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #9545:\nURL: https://github.com/apache/arrow/pull/9545#discussion_r582377050\n\n\n\n##########\nFile path: rust/datafusion/src/optimizer/constant_folding.rs\n##########\n@@ -95,24 +97,29 @@ impl OptimizerRule for ConstantFolding {\n     }\n }\n \n-fn is_boolean_type(expr: &Expr, schemas: &[&DFSchemaRef]) -> bool {\n-    for schema in schemas {\n-        if let Ok(DataType::Boolean) = expr.get_type(schema) {\n-            return true;\n+struct ConstantRewriter<'a> {\n+    /// input schemas\n+    schemas: Vec<&'a DFSchemaRef>,\n+}\n+\n+impl<'a> ConstantRewriter<'a> {\n+    fn is_boolean_type(&self, expr: &Expr) -> bool {\n+        for schema in &self.schemas {\n+            if let Ok(DataType::Boolean) = expr.get_type(schema) {\n+                return true;\n+            }\n         }\n-    }\n \n-    false\n+        false\n+    }\n }\n \n-/// Recursively transverses the expression tree.\n-fn optimize_expr(e: &Expr, schemas: &[&DFSchemaRef]) -> Result<Expr> {\n-    Ok(match e {\n-        Expr::BinaryExpr { left, op, right } => {\n-            let left = optimize_expr(left, schemas)?;\n-            let right = optimize_expr(right, schemas)?;\n-            match op {\n-                Operator::Eq => match (&left, &right) {\n+impl<'a> ExprRewriter for ConstantRewriter<'a> {\n\nReview comment:\n       With some of @houqp 's comments, this rewrite pass is looking beautiful in my opinion -- it really looks like a rewrite rather than a reconstruction\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-24T23:22:05.797+0000",
                    "updated": "2021-02-24T23:22:05.797+0000",
                    "started": "2021-02-24T23:22:05.796+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "557592",
                    "issueId": "13359772"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13359772/worklog/557618",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "codecov-io commented on pull request #9545:\nURL: https://github.com/apache/arrow/pull/9545#issuecomment-785475100\n\n\n   # [Codecov](https://codecov.io/gh/apache/arrow/pull/9545?src=pr&el=h1) Report\n   > Merging [#9545](https://codecov.io/gh/apache/arrow/pull/9545?src=pr&el=desc) (67d35b7) into [master](https://codecov.io/gh/apache/arrow/commit/5bea62493d919dcb97ca0f22bcb7ebfc239cee25?el=desc) (5bea624) will **increase** coverage by `0.13%`.\n   > The diff coverage is `91.09%`.\n   \n   [![Impacted file tree graph](https://codecov.io/gh/apache/arrow/pull/9545/graphs/tree.svg?width=650&height=150&src=pr&token=LpTCFbqVT1)](https://codecov.io/gh/apache/arrow/pull/9545?src=pr&el=tree)\n   \n   ```diff\n   @@            Coverage Diff             @@\n   ##           master    #9545      +/-   ##\n   ==========================================\n   + Coverage   82.25%   82.39%   +0.13%     \n   ==========================================\n     Files         244      244              \n     Lines       55685    56216     +531     \n   ==========================================\n   + Hits        45806    46317     +511     \n   - Misses       9879     9899      +20     \n   ```\n   \n   \n   | [Impacted Files](https://codecov.io/gh/apache/arrow/pull/9545?src=pr&el=tree) | Coverage \u0394 | |\n   |---|---|---|\n   | [...ion-testing/src/bin/arrow-json-integration-test.rs](https://codecov.io/gh/apache/arrow/pull/9545/diff?src=pr&el=tree#diff-cnVzdC9pbnRlZ3JhdGlvbi10ZXN0aW5nL3NyYy9iaW4vYXJyb3ctanNvbi1pbnRlZ3JhdGlvbi10ZXN0LnJz) | `0.00% <0.00%> (\u00f8)` | |\n   | [rust/arrow/src/ipc/writer.rs](https://codecov.io/gh/apache/arrow/pull/9545/diff?src=pr&el=tree#diff-cnVzdC9hcnJvdy9zcmMvaXBjL3dyaXRlci5ycw==) | `87.23% <50.00%> (-0.59%)` | :arrow_down: |\n   | [...datafusion/src/physical\\_plan/string\\_expressions.rs](https://codecov.io/gh/apache/arrow/pull/9545/diff?src=pr&el=tree#diff-cnVzdC9kYXRhZnVzaW9uL3NyYy9waHlzaWNhbF9wbGFuL3N0cmluZ19leHByZXNzaW9ucy5ycw==) | `77.00% <82.23%> (+7.37%)` | :arrow_up: |\n   | [rust/datafusion/src/logical\\_plan/expr.rs](https://codecov.io/gh/apache/arrow/pull/9545/diff?src=pr&el=tree#diff-cnVzdC9kYXRhZnVzaW9uL3NyYy9sb2dpY2FsX3BsYW4vZXhwci5ycw==) | `83.07% <90.10%> (+1.94%)` | :arrow_up: |\n   | [rust/parquet/src/arrow/array\\_reader.rs](https://codecov.io/gh/apache/arrow/pull/9545/diff?src=pr&el=tree#diff-cnVzdC9wYXJxdWV0L3NyYy9hcnJvdy9hcnJheV9yZWFkZXIucnM=) | `77.61% <91.30%> (-0.02%)` | :arrow_down: |\n   | [rust/datafusion/src/physical\\_plan/functions.rs](https://codecov.io/gh/apache/arrow/pull/9545/diff?src=pr&el=tree#diff-cnVzdC9kYXRhZnVzaW9uL3NyYy9waHlzaWNhbF9wbGFuL2Z1bmN0aW9ucy5ycw==) | `85.52% <91.42%> (+11.69%)` | :arrow_up: |\n   | [rust/datafusion/src/optimizer/constant\\_folding.rs](https://codecov.io/gh/apache/arrow/pull/9545/diff?src=pr&el=tree#diff-cnVzdC9kYXRhZnVzaW9uL3NyYy9vcHRpbWl6ZXIvY29uc3RhbnRfZm9sZGluZy5ycw==) | `92.66% <94.11%> (-1.80%)` | :arrow_down: |\n   | [rust/datafusion/tests/sql.rs](https://codecov.io/gh/apache/arrow/pull/9545/diff?src=pr&el=tree#diff-cnVzdC9kYXRhZnVzaW9uL3Rlc3RzL3NxbC5ycw==) | `98.28% <100.00%> (+0.14%)` | :arrow_up: |\n   | [rust/parquet/src/arrow/arrow\\_reader.rs](https://codecov.io/gh/apache/arrow/pull/9545/diff?src=pr&el=tree#diff-cnVzdC9wYXJxdWV0L3NyYy9hcnJvdy9hcnJvd19yZWFkZXIucnM=) | `91.91% <100.00%> (+0.34%)` | :arrow_up: |\n   | [rust/parquet/src/schema/types.rs](https://codecov.io/gh/apache/arrow/pull/9545/diff?src=pr&el=tree#diff-cnVzdC9wYXJxdWV0L3NyYy9zY2hlbWEvdHlwZXMucnM=) | `89.54% <100.00%> (+0.02%)` | :arrow_up: |\n   | ... and [15 more](https://codecov.io/gh/apache/arrow/pull/9545/diff?src=pr&el=tree-more) | |\n   \n   ------\n   \n   [Continue to review full report at Codecov](https://codecov.io/gh/apache/arrow/pull/9545?src=pr&el=continue).\n   > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n   > `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n   > Powered by [Codecov](https://codecov.io/gh/apache/arrow/pull/9545?src=pr&el=footer). Last update [4beb514...67d35b7](https://codecov.io/gh/apache/arrow/pull/9545?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-25T00:04:13.060+0000",
                    "updated": "2021-02-25T00:04:13.060+0000",
                    "started": "2021-02-25T00:04:13.060+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "557618",
                    "issueId": "13359772"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13359772/worklog/558710",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb closed pull request #9545:\nURL: https://github.com/apache/arrow/pull/9545\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-26T19:53:57.947+0000",
                    "updated": "2021-02-26T19:53:57.947+0000",
                    "started": "2021-02-26T19:53:57.947+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "558710",
                    "issueId": "13359772"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 6600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@3116af43[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@551a9c1e[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@56559cf0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@572e0048[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2a0331dc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@126ca60a[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@68240aab[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@4faf7ba7[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7c112e5f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@b3a8b21[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4383a9bf[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@77c5802b[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 6600,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Feb 26 19:53:55 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-02-26T19:53:55.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11710/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-02-20T10:46:49.000+0000",
        "updated": "2021-02-26T19:53:58.000+0000",
        "timeoriginalestimate": null,
        "description": "\r\nThe idea is to\r\n1. Reduce the amount repetitions in optimizer rules to make them easier to implement\r\n\r\n2. Reduce the amount of repetition to make it easier to see the actual logic (rather than having it intertwined with the code needed to do recursion)\r\n\r\n2. Set the stage for a more general `PlanRewriter` that doesn't have  to clone its input, and  can modify take their input by value and consume them\r\n\r\nPlan is to make an ExprRewriter, the mutable counterpart to `ExpressionVisitor` and demonstrates its usefulness by rewriting several expression transformation rewrite passes using it.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 6600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust][DataFusion] Implement ExprRewriter to avoid tree traversal redundancy",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13359772/comment/17291900",
                    "id": "17291900",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
                        "name": "alamb",
                        "key": "alamb",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
                        },
                        "displayName": "Andrew Lamb",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 9545\n[https://github.com/apache/arrow/pull/9545]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
                        "name": "alamb",
                        "key": "alamb",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
                        },
                        "displayName": "Andrew Lamb",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-02-26T19:53:55.629+0000",
                    "updated": "2021-02-26T19:53:55.629+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0nvi8:",
        "customfield_12314139": null
    }
}