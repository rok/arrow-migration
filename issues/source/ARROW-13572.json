{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13393720",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720",
    "key": "ARROW-13572",
    "fields": {
        "parent": {
            "id": "13386957",
            "key": "ARROW-13233",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13386957",
            "fields": {
                "summary": "[C++] Support ORC in Arrow Dataset",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                    "description": "The issue is open and ready for the assignee to start work on it.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                    "name": "Open",
                    "id": "1",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                        "id": 2,
                        "key": "new",
                        "colorName": "blue-gray",
                        "name": "To Do"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                    "id": "2",
                    "description": "A new feature of the product, which has yet to be developed.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                    "name": "New Feature",
                    "subtask": false,
                    "avatarId": 21141
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350323",
                "id": "12350323",
                "description": "",
                "name": "6.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-10-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "orc",
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12620606",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12620606",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13386957",
                    "key": "ARROW-13233",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13386957",
                    "fields": {
                        "summary": "[C++] Support ORC in Arrow Dataset",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
            "name": "jorisvandenbossche",
            "key": "jorisvandenbossche",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Joris Van den Bossche",
            "active": true,
            "timeZone": "Europe/Brussels"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328936",
                "id": "12328936",
                "name": "Python"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rjzamora",
            "name": "rjzamora",
            "key": "rjzamora",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34055",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34055",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34055",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34055"
            },
            "displayName": "Rick Zamora",
            "active": true,
            "timeZone": "America/Chicago"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rjzamora",
            "name": "rjzamora",
            "key": "rjzamora",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34055",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34055",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34055",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34055"
            },
            "displayName": "Rick Zamora",
            "active": true,
            "timeZone": "America/Chicago"
        },
        "aggregateprogress": {
            "progress": 30600,
            "total": 30600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 30600,
            "total": 30600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13572/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 51,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/641247",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#issuecomment-904869751\n\n\n   https://issues.apache.org/jira/browse/ARROW-13572\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-24T18:19:19.141+0000",
                    "updated": "2021-08-24T18:19:19.141+0000",
                    "started": "2021-08-24T18:19:19.141+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "641247",
                    "issueId": "13393720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/641248",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#issuecomment-904871131\n\n\n   This is very much work-in-progress for now. It's a basic implementation of the sync ScanFile, while I should take a look at ScanBatchesAsync instead, it still needs to support ORC options to read specific columns only (for projection pushdown), to set the batch size, no writing support yet, still need to add C++ tests and more python tests, etc. \r\n   But the basics work: you can open and read an ORC dataset.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-24T18:21:33.769+0000",
                    "updated": "2021-08-24T18:21:33.769+0000",
                    "started": "2021-08-24T18:21:33.769+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "641248",
                    "issueId": "13393720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/641250",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#issuecomment-904872259\n\n\n   This also brings up the question for the Python/Cython side: how to do this when ORC is an optional feature and might not be built by the C++ library? Currently for the datasets cython code, we assume all formats (so also Parquet) are simply always available.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-24T18:23:08.677+0000",
                    "updated": "2021-08-24T18:23:08.677+0000",
                    "started": "2021-08-24T18:23:08.676+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "641250",
                    "issueId": "13393720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/642258",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#issuecomment-906282470\n\n\n   cc @rjzamora it's not yet a very efficient implementation (eg no column selection pushdown), but this should already be sufficient for testing / prototyping a dask reader interfacing with this. \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-26T10:25:21.135+0000",
                    "updated": "2021-08-26T10:25:21.135+0000",
                    "started": "2021-08-26T10:25:21.134+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "642258",
                    "issueId": "13393720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/642307",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#issuecomment-906362174\n\n\n   > This also brings up the question for the Python/Cython side: how to do this when ORC is an optional feature and might not be built by the C++ library? Currently for the datasets cython code, we assume all formats (so also Parquet) are simply always available.\r\n   \r\n   It would be a lot of refactoring, but you could imagine having a _dataset.pyx/pxd (with the pxd containing base classes/definitions), then a _dataset_orc.pyx, _dataset_parquet.pyx, etc. with setup.py configuring everything as appropriate (e.g. --with-dataset + --with-orc implying _dataset_orc.pyx should be built). FileFormat._wrap and Fragment._wrap would get trickier, though: \r\n   https://github.com/apache/arrow/blob/257d0aa936786c095b5560adb27bffaaccaed589/python/pyarrow/_dataset.pyx#L832-L848\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-26T12:26:26.729+0000",
                    "updated": "2021-08-26T12:26:26.729+0000",
                    "started": "2021-08-26T12:26:26.729+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "642307",
                    "issueId": "13393720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/642390",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#issuecomment-906486136\n\n\n   cc @pitrou \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-26T14:56:20.584+0000",
                    "updated": "2021-08-26T14:56:20.584+0000",
                    "started": "2021-08-26T14:56:20.584+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "642390",
                    "issueId": "13393720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/643444",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#discussion_r698437245\n\n\n\n##########\nFile path: python/pyarrow/tests/test_dataset.py\n##########\n@@ -2614,6 +2615,49 @@ def test_ipc_format(tempdir, dataset_reader):\n         assert result.equals(table)\n \n \n+@pytest.mark.orc\n+def test_orc_format(tempdir, dataset_reader):\n+    from pyarrow import orc\n+    table = pa.table({'a': pa.array([1, 2, 3], type=\"int8\"),\n+                      'b': pa.array([.1, .2, .3], type=\"float64\")})\n+\n+    path = str(tempdir / 'test.orc')\n+    orc.write_table(table, path)\n+\n+    dataset = ds.dataset(path, format=ds.OrcFileFormat())\n+    result = dataset_reader.to_table(dataset)\n\nReview comment:\n       Can you add `result.validate(full=True)` here and in other similar places?\n\n##########\nFile path: python/pyarrow/tests/test_dataset.py\n##########\n@@ -2614,6 +2615,49 @@ def test_ipc_format(tempdir, dataset_reader):\n         assert result.equals(table)\n \n \n+@pytest.mark.orc\n+def test_orc_format(tempdir, dataset_reader):\n+    from pyarrow import orc\n+    table = pa.table({'a': pa.array([1, 2, 3], type=\"int8\"),\n+                      'b': pa.array([.1, .2, .3], type=\"float64\")})\n+\n+    path = str(tempdir / 'test.orc')\n+    orc.write_table(table, path)\n+\n+    dataset = ds.dataset(path, format=ds.OrcFileFormat())\n+    result = dataset_reader.to_table(dataset)\n+    assert result.equals(table)\n+\n+    dataset = ds.dataset(path, format=\"orc\")\n+    result = dataset_reader.to_table(dataset)\n+    assert result.equals(table)\n+\n+    result = dataset_reader.to_table(dataset, columns=[\"b\"])\n+    assert result.equals(table.select([\"b\"]))\n+\n+    assert dataset_reader.count_rows(dataset) == 3\n+    assert dataset_reader.count_rows(dataset, filter=ds.field(\"a\") > 2) == 1\n+\n+\n+@pytest.mark.orc\n+def test_orc_scan_options(tempdir, dataset_reader):\n+    from pyarrow import orc\n+    table = pa.table({'a': pa.array([1, 2, 3], type=\"int8\"),\n+                      'b': pa.array([.1, .2, .3], type=\"float64\")})\n+\n+    path = str(tempdir / 'test.orc')\n+    orc.write_table(table, path)\n+\n+    dataset = ds.dataset(path, format=\"orc\")\n+    result = list(dataset_reader.to_batches(dataset))\n+    assert len(result) == 1\n+    assert result[0].num_rows == 3\n+    result = list(dataset_reader.to_batches(dataset, batch_size=2))\n+    assert len(result) == 2\n+    assert result[0].num_rows == 2\n+    assert result[1].num_rows == 1\n\nReview comment:\n       Can you also test the actual result values? \n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.h\n##########\n@@ -0,0 +1,79 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"arrow/adapters/orc/adapter.h\"\n\nReview comment:\n       I'm not sure this include is actually necessary here?\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n+    const FileSource& source,\n+    const std::shared_ptr<ScanOptions>& scan_options = nullptr) {\n+  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n+\n+  arrow::MemoryPool* pool;\n+  if (scan_options) {\n+    pool = scan_options->pool;\n+  } else {\n+    pool = default_memory_pool();\n+  }\n+\n+  std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader;\n+  auto status =\n+      arrow::adapters::orc::ORCFileReader::Open(std::move(input), pool, &reader);\n+  if (!status.ok()) {\n+    return status.WithMessage(\"Could not open ORC input source '\", source.path(),\n+                              \"': \", status.message());\n+  }\n+  return reader;\n+}\n+\n+/// \\brief A ScanTask backed by an ORC file.\n+class OrcScanTask : public ScanTask {\n+ public:\n+  OrcScanTask(std::shared_ptr<FileFragment> fragment,\n+              std::shared_ptr<ScanOptions> options)\n+      : ScanTask(std::move(options), fragment), source_(fragment->source()) {}\n+\n+  Result<RecordBatchIterator> Execute() override {\n+    ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source_));\n+    std::shared_ptr<arrow::RecordBatchReader> batch_reader;\n+    // TODO determine included fields from options_->MaterializedFields() to\n+    // optimize the column selection (see _column_index_lookup in python\n+    // orc.py for custom logic)\n+    // std::vector<int> included_fields;\n+    RETURN_NOT_OK(reader->NextStripeReader(options_->batch_size, &batch_reader));\n+\n+    auto batch_it = MakeIteratorFromReader(batch_reader);\n+    return batch_it;\n+  }\n+\n+ private:\n+  FileSource source_;\n+};\n+\n+Result<bool> OrcFileFormat::IsSupported(const FileSource& source) const {\n+  RETURN_NOT_OK(source.Open().status());\n+  return OpenReader(source).ok();\n+}\n+\n+Result<std::shared_ptr<Schema>> OrcFileFormat::Inspect(const FileSource& source) const {\n+  ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source));\n+  std::shared_ptr<Schema> schema;\n+  RETURN_NOT_OK(reader->ReadSchema(&schema));\n\nReview comment:\n       For the record, see also https://issues.apache.org/jira/browse/ARROW-13793\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n\nReview comment:\n       Can you put all private functions and classes inside the anonymous namespace? (that is, `namespace {`)\r\n   \r\n   The anonymous namespace is equivalent to `static` for functions, but also applies to classes, variables, etc.\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n+    const FileSource& source,\n+    const std::shared_ptr<ScanOptions>& scan_options = nullptr) {\n+  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n+\n+  arrow::MemoryPool* pool;\n+  if (scan_options) {\n+    pool = scan_options->pool;\n+  } else {\n+    pool = default_memory_pool();\n+  }\n+\n+  std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader;\n+  auto status =\n+      arrow::adapters::orc::ORCFileReader::Open(std::move(input), pool, &reader);\n+  if (!status.ok()) {\n+    return status.WithMessage(\"Could not open ORC input source '\", source.path(),\n+                              \"': \", status.message());\n+  }\n+  return reader;\n+}\n+\n+/// \\brief A ScanTask backed by an ORC file.\n+class OrcScanTask : public ScanTask {\n+ public:\n+  OrcScanTask(std::shared_ptr<FileFragment> fragment,\n+              std::shared_ptr<ScanOptions> options)\n+      : ScanTask(std::move(options), fragment), source_(fragment->source()) {}\n+\n+  Result<RecordBatchIterator> Execute() override {\n+    ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source_));\n+    std::shared_ptr<arrow::RecordBatchReader> batch_reader;\n+    // TODO determine included fields from options_->MaterializedFields() to\n\nReview comment:\n       Can you perhaps open a JIRA for this TODO?\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n+    const FileSource& source,\n+    const std::shared_ptr<ScanOptions>& scan_options = nullptr) {\n+  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n+\n+  arrow::MemoryPool* pool;\n+  if (scan_options) {\n+    pool = scan_options->pool;\n+  } else {\n+    pool = default_memory_pool();\n+  }\n+\n+  std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader;\n+  auto status =\n+      arrow::adapters::orc::ORCFileReader::Open(std::move(input), pool, &reader);\n+  if (!status.ok()) {\n+    return status.WithMessage(\"Could not open ORC input source '\", source.path(),\n+                              \"': \", status.message());\n+  }\n+  return reader;\n+}\n+\n+/// \\brief A ScanTask backed by an ORC file.\n+class OrcScanTask : public ScanTask {\n+ public:\n+  OrcScanTask(std::shared_ptr<FileFragment> fragment,\n+              std::shared_ptr<ScanOptions> options)\n+      : ScanTask(std::move(options), fragment), source_(fragment->source()) {}\n+\n+  Result<RecordBatchIterator> Execute() override {\n+    ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source_));\n+    std::shared_ptr<arrow::RecordBatchReader> batch_reader;\n+    // TODO determine included fields from options_->MaterializedFields() to\n+    // optimize the column selection (see _column_index_lookup in python\n+    // orc.py for custom logic)\n+    // std::vector<int> included_fields;\n+    RETURN_NOT_OK(reader->NextStripeReader(options_->batch_size, &batch_reader));\n+\n+    auto batch_it = MakeIteratorFromReader(batch_reader);\n+    return batch_it;\n+  }\n+\n+ private:\n+  FileSource source_;\n+};\n+\n+Result<bool> OrcFileFormat::IsSupported(const FileSource& source) const {\n+  RETURN_NOT_OK(source.Open().status());\n+  return OpenReader(source).ok();\n+}\n+\n+Result<std::shared_ptr<Schema>> OrcFileFormat::Inspect(const FileSource& source) const {\n+  ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source));\n+  std::shared_ptr<Schema> schema;\n+  RETURN_NOT_OK(reader->ReadSchema(&schema));\n+  return schema;\n+}\n+\n+Result<ScanTaskIterator> OrcFileFormat::ScanFile(\n+    const std::shared_ptr<ScanOptions>& options,\n+    const std::shared_ptr<FileFragment>& fragment) const {\n+  auto task = std::make_shared<OrcScanTask>(fragment, options);\n+\n+  return MakeVectorIterator<std::shared_ptr<ScanTask>>({std::move(task)});\n+}\n+\n+Future<util::optional<int64_t>> OrcFileFormat::CountRows(\n+    const std::shared_ptr<FileFragment>& file, compute::Expression predicate,\n+    const std::shared_ptr<ScanOptions>& options) {\n+  if (ExpressionHasFieldRefs(predicate)) {\n+    return Future<util::optional<int64_t>>::MakeFinished(util::nullopt);\n+  }\n+  auto self = internal::checked_pointer_cast<OrcFileFormat>(shared_from_this());\n+  return DeferNotOk(options->io_context.executor()->Submit(\n+      [self, file]() -> Result<util::optional<int64_t>> {\n+        ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(file->source()));\n+        return reader->NumberOfRows();\n+      }));\n+}\n+\n+// //\n+// // IpcFileWriter, IpcFileWriteOptions\n+// //\n+\n+std::shared_ptr<FileWriteOptions> OrcFileFormat::DefaultWriteOptions() {\n+  // TODO\n+  return NULLPTR;\n\nReview comment:\n       Can use `nullptr` in `.cc` files.\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n+    const FileSource& source,\n+    const std::shared_ptr<ScanOptions>& scan_options = nullptr) {\n+  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n+\n+  arrow::MemoryPool* pool;\n+  if (scan_options) {\n+    pool = scan_options->pool;\n+  } else {\n+    pool = default_memory_pool();\n+  }\n+\n+  std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader;\n+  auto status =\n+      arrow::adapters::orc::ORCFileReader::Open(std::move(input), pool, &reader);\n+  if (!status.ok()) {\n+    return status.WithMessage(\"Could not open ORC input source '\", source.path(),\n+                              \"': \", status.message());\n+  }\n+  return reader;\n+}\n+\n+/// \\brief A ScanTask backed by an ORC file.\n+class OrcScanTask : public ScanTask {\n+ public:\n+  OrcScanTask(std::shared_ptr<FileFragment> fragment,\n+              std::shared_ptr<ScanOptions> options)\n+      : ScanTask(std::move(options), fragment), source_(fragment->source()) {}\n+\n+  Result<RecordBatchIterator> Execute() override {\n+    ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source_));\n+    std::shared_ptr<arrow::RecordBatchReader> batch_reader;\n+    // TODO determine included fields from options_->MaterializedFields() to\n+    // optimize the column selection (see _column_index_lookup in python\n+    // orc.py for custom logic)\n+    // std::vector<int> included_fields;\n+    RETURN_NOT_OK(reader->NextStripeReader(options_->batch_size, &batch_reader));\n\nReview comment:\n       Hmm, IIUC, this will only read one stripe from the ORC file, but an ORC file may well have several stripes. @iajoiner is my interpretation correct?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-30T12:37:51.372+0000",
                    "updated": "2021-08-30T12:37:51.372+0000",
                    "started": "2021-08-30T12:37:51.371+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "643444",
                    "issueId": "13393720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/643531",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "iajoiner commented on pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#issuecomment-908449645\n\n\n   Sorry I just did a legal name change and have been too busy dealing with the bureaucracy to support this one. Yes I will answer the questions tonight or tomorrow.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-30T15:41:30.095+0000",
                    "updated": "2021-08-30T15:41:30.095+0000",
                    "started": "2021-08-30T15:41:30.095+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "643531",
                    "issueId": "13393720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/643545",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#discussion_r698611259\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.h\n##########\n@@ -0,0 +1,79 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"arrow/adapters/orc/adapter.h\"\n\nReview comment:\n       Moved it to the .cc file\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n+    const FileSource& source,\n+    const std::shared_ptr<ScanOptions>& scan_options = nullptr) {\n+  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n+\n+  arrow::MemoryPool* pool;\n+  if (scan_options) {\n+    pool = scan_options->pool;\n+  } else {\n+    pool = default_memory_pool();\n+  }\n+\n+  std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader;\n+  auto status =\n+      arrow::adapters::orc::ORCFileReader::Open(std::move(input), pool, &reader);\n+  if (!status.ok()) {\n+    return status.WithMessage(\"Could not open ORC input source '\", source.path(),\n+                              \"': \", status.message());\n+  }\n+  return reader;\n+}\n+\n+/// \\brief A ScanTask backed by an ORC file.\n+class OrcScanTask : public ScanTask {\n+ public:\n+  OrcScanTask(std::shared_ptr<FileFragment> fragment,\n+              std::shared_ptr<ScanOptions> options)\n+      : ScanTask(std::move(options), fragment), source_(fragment->source()) {}\n+\n+  Result<RecordBatchIterator> Execute() override {\n+    ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source_));\n+    std::shared_ptr<arrow::RecordBatchReader> batch_reader;\n+    // TODO determine included fields from options_->MaterializedFields() to\n+    // optimize the column selection (see _column_index_lookup in python\n+    // orc.py for custom logic)\n+    // std::vector<int> included_fields;\n+    RETURN_NOT_OK(reader->NextStripeReader(options_->batch_size, &batch_reader));\n+\n+    auto batch_it = MakeIteratorFromReader(batch_reader);\n+    return batch_it;\n+  }\n+\n+ private:\n+  FileSource source_;\n+};\n+\n+Result<bool> OrcFileFormat::IsSupported(const FileSource& source) const {\n+  RETURN_NOT_OK(source.Open().status());\n+  return OpenReader(source).ok();\n+}\n+\n+Result<std::shared_ptr<Schema>> OrcFileFormat::Inspect(const FileSource& source) const {\n+  ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source));\n+  std::shared_ptr<Schema> schema;\n+  RETURN_NOT_OK(reader->ReadSchema(&schema));\n\nReview comment:\n       Yes, I noticed the same while working on this. Thanks for opening the JIRA.\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n\nReview comment:\n       Done, only the OrcFileFormat methods are now in the public dataset namespace\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n+    const FileSource& source,\n+    const std::shared_ptr<ScanOptions>& scan_options = nullptr) {\n+  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n+\n+  arrow::MemoryPool* pool;\n+  if (scan_options) {\n+    pool = scan_options->pool;\n+  } else {\n+    pool = default_memory_pool();\n+  }\n+\n+  std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader;\n+  auto status =\n+      arrow::adapters::orc::ORCFileReader::Open(std::move(input), pool, &reader);\n+  if (!status.ok()) {\n+    return status.WithMessage(\"Could not open ORC input source '\", source.path(),\n+                              \"': \", status.message());\n+  }\n+  return reader;\n+}\n+\n+/// \\brief A ScanTask backed by an ORC file.\n+class OrcScanTask : public ScanTask {\n+ public:\n+  OrcScanTask(std::shared_ptr<FileFragment> fragment,\n+              std::shared_ptr<ScanOptions> options)\n+      : ScanTask(std::move(options), fragment), source_(fragment->source()) {}\n+\n+  Result<RecordBatchIterator> Execute() override {\n+    ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source_));\n+    std::shared_ptr<arrow::RecordBatchReader> batch_reader;\n+    // TODO determine included fields from options_->MaterializedFields() to\n+    // optimize the column selection (see _column_index_lookup in python\n+    // orc.py for custom logic)\n+    // std::vector<int> included_fields;\n+    RETURN_NOT_OK(reader->NextStripeReader(options_->batch_size, &batch_reader));\n\nReview comment:\n       Ah, I was assuming this would iteratively read the \"next\" stripe on each call of the iterator, but I might have misunderstood that. \r\n   \r\n   We also have https://issues.apache.org/jira/browse/ARROW-13571 to control the stripe size when writing, which will also make it easier to test this with small datasets.\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n+    const FileSource& source,\n+    const std::shared_ptr<ScanOptions>& scan_options = nullptr) {\n+  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n+\n+  arrow::MemoryPool* pool;\n+  if (scan_options) {\n+    pool = scan_options->pool;\n+  } else {\n+    pool = default_memory_pool();\n+  }\n+\n+  std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader;\n+  auto status =\n+      arrow::adapters::orc::ORCFileReader::Open(std::move(input), pool, &reader);\n+  if (!status.ok()) {\n+    return status.WithMessage(\"Could not open ORC input source '\", source.path(),\n+                              \"': \", status.message());\n+  }\n+  return reader;\n+}\n+\n+/// \\brief A ScanTask backed by an ORC file.\n+class OrcScanTask : public ScanTask {\n+ public:\n+  OrcScanTask(std::shared_ptr<FileFragment> fragment,\n+              std::shared_ptr<ScanOptions> options)\n+      : ScanTask(std::move(options), fragment), source_(fragment->source()) {}\n+\n+  Result<RecordBatchIterator> Execute() override {\n+    ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source_));\n+    std::shared_ptr<arrow::RecordBatchReader> batch_reader;\n+    // TODO determine included fields from options_->MaterializedFields() to\n\nReview comment:\n       Opened several follow-up JIRAs (including for this one) and made them sub-tasks of https://issues.apache.org/jira/browse/ARROW-13233, and added links to those to the TODO comments\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-30T16:29:47.783+0000",
                    "updated": "2021-08-30T16:29:47.783+0000",
                    "started": "2021-08-30T16:29:47.783+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "643545",
                    "issueId": "13393720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/643550",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#issuecomment-908493427\n\n\n   > Sorry I just did a legal name change and have been too busy dealing with the bureaucracy to support this one. Yes I will answer the questions tonight or tomorrow.\r\n   \r\n   No worries :-)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-30T16:32:21.713+0000",
                    "updated": "2021-08-30T16:32:21.713+0000",
                    "started": "2021-08-30T16:32:21.712+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "643550",
                    "issueId": "13393720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/643563",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#discussion_r698641947\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n+    const FileSource& source,\n+    const std::shared_ptr<ScanOptions>& scan_options = nullptr) {\n+  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n+\n+  arrow::MemoryPool* pool;\n+  if (scan_options) {\n+    pool = scan_options->pool;\n+  } else {\n+    pool = default_memory_pool();\n+  }\n+\n+  std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader;\n+  auto status =\n+      arrow::adapters::orc::ORCFileReader::Open(std::move(input), pool, &reader);\n+  if (!status.ok()) {\n+    return status.WithMessage(\"Could not open ORC input source '\", source.path(),\n+                              \"': \", status.message());\n+  }\n+  return reader;\n+}\n+\n+/// \\brief A ScanTask backed by an ORC file.\n+class OrcScanTask : public ScanTask {\n+ public:\n+  OrcScanTask(std::shared_ptr<FileFragment> fragment,\n+              std::shared_ptr<ScanOptions> options)\n+      : ScanTask(std::move(options), fragment), source_(fragment->source()) {}\n+\n+  Result<RecordBatchIterator> Execute() override {\n+    ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source_));\n+    std::shared_ptr<arrow::RecordBatchReader> batch_reader;\n+    // TODO determine included fields from options_->MaterializedFields() to\n+    // optimize the column selection (see _column_index_lookup in python\n+    // orc.py for custom logic)\n+    // std::vector<int> included_fields;\n+    RETURN_NOT_OK(reader->NextStripeReader(options_->batch_size, &batch_reader));\n\nReview comment:\n       OK, indeed, doing a quick test with writing a file with 10 million rows (so it has 2 stripes), and reading it back with the datasets API of this PR, it only reads around 8 million rows .. \r\n   So will have to look for a different way.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-30T16:43:37.001+0000",
                    "updated": "2021-08-30T16:43:37.001+0000",
                    "started": "2021-08-30T16:43:37.000+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "643563",
                    "issueId": "13393720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/643564",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#discussion_r698641947\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n+    const FileSource& source,\n+    const std::shared_ptr<ScanOptions>& scan_options = nullptr) {\n+  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n+\n+  arrow::MemoryPool* pool;\n+  if (scan_options) {\n+    pool = scan_options->pool;\n+  } else {\n+    pool = default_memory_pool();\n+  }\n+\n+  std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader;\n+  auto status =\n+      arrow::adapters::orc::ORCFileReader::Open(std::move(input), pool, &reader);\n+  if (!status.ok()) {\n+    return status.WithMessage(\"Could not open ORC input source '\", source.path(),\n+                              \"': \", status.message());\n+  }\n+  return reader;\n+}\n+\n+/// \\brief A ScanTask backed by an ORC file.\n+class OrcScanTask : public ScanTask {\n+ public:\n+  OrcScanTask(std::shared_ptr<FileFragment> fragment,\n+              std::shared_ptr<ScanOptions> options)\n+      : ScanTask(std::move(options), fragment), source_(fragment->source()) {}\n+\n+  Result<RecordBatchIterator> Execute() override {\n+    ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source_));\n+    std::shared_ptr<arrow::RecordBatchReader> batch_reader;\n+    // TODO determine included fields from options_->MaterializedFields() to\n+    // optimize the column selection (see _column_index_lookup in python\n+    // orc.py for custom logic)\n+    // std::vector<int> included_fields;\n+    RETURN_NOT_OK(reader->NextStripeReader(options_->batch_size, &batch_reader));\n\nReview comment:\n       OK, indeed, doing a quick test with writing a file with 10 million rows (so it has 2 stripes), and reading it back with the datasets API of this PR, it only reads around 8 million rows .. (so only the first stripe).\r\n   So will have to look for a different way.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-30T16:43:50.312+0000",
                    "updated": "2021-08-30T16:43:50.312+0000",
                    "started": "2021-08-30T16:43:50.312+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "643564",
                    "issueId": "13393720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/643905",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#discussion_r699062932\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n+    const FileSource& source,\n+    const std::shared_ptr<ScanOptions>& scan_options = nullptr) {\n+  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n+\n+  arrow::MemoryPool* pool;\n+  if (scan_options) {\n+    pool = scan_options->pool;\n+  } else {\n+    pool = default_memory_pool();\n+  }\n+\n+  std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader;\n+  auto status =\n+      arrow::adapters::orc::ORCFileReader::Open(std::move(input), pool, &reader);\n+  if (!status.ok()) {\n+    return status.WithMessage(\"Could not open ORC input source '\", source.path(),\n+                              \"': \", status.message());\n+  }\n+  return reader;\n+}\n+\n+/// \\brief A ScanTask backed by an ORC file.\n+class OrcScanTask : public ScanTask {\n+ public:\n+  OrcScanTask(std::shared_ptr<FileFragment> fragment,\n+              std::shared_ptr<ScanOptions> options)\n+      : ScanTask(std::move(options), fragment), source_(fragment->source()) {}\n+\n+  Result<RecordBatchIterator> Execute() override {\n+    ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source_));\n+    std::shared_ptr<arrow::RecordBatchReader> batch_reader;\n+    // TODO determine included fields from options_->MaterializedFields() to\n+    // optimize the column selection (see _column_index_lookup in python\n+    // orc.py for custom logic)\n+    // std::vector<int> included_fields;\n+    RETURN_NOT_OK(reader->NextStripeReader(options_->batch_size, &batch_reader));\n\nReview comment:\n       I pushed an update, and now manually iteratively read the next stripe with `ReadStripe` (I followed the approach of a ScanTaskIterator from file_ipc.cc)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-31T07:36:13.046+0000",
                    "updated": "2021-08-31T07:36:13.046+0000",
                    "started": "2021-08-31T07:36:13.045+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "643905",
                    "issueId": "13393720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/643910",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#discussion_r699062932\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n+    const FileSource& source,\n+    const std::shared_ptr<ScanOptions>& scan_options = nullptr) {\n+  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n+\n+  arrow::MemoryPool* pool;\n+  if (scan_options) {\n+    pool = scan_options->pool;\n+  } else {\n+    pool = default_memory_pool();\n+  }\n+\n+  std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader;\n+  auto status =\n+      arrow::adapters::orc::ORCFileReader::Open(std::move(input), pool, &reader);\n+  if (!status.ok()) {\n+    return status.WithMessage(\"Could not open ORC input source '\", source.path(),\n+                              \"': \", status.message());\n+  }\n+  return reader;\n+}\n+\n+/// \\brief A ScanTask backed by an ORC file.\n+class OrcScanTask : public ScanTask {\n+ public:\n+  OrcScanTask(std::shared_ptr<FileFragment> fragment,\n+              std::shared_ptr<ScanOptions> options)\n+      : ScanTask(std::move(options), fragment), source_(fragment->source()) {}\n+\n+  Result<RecordBatchIterator> Execute() override {\n+    ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source_));\n+    std::shared_ptr<arrow::RecordBatchReader> batch_reader;\n+    // TODO determine included fields from options_->MaterializedFields() to\n+    // optimize the column selection (see _column_index_lookup in python\n+    // orc.py for custom logic)\n+    // std::vector<int> included_fields;\n+    RETURN_NOT_OK(reader->NextStripeReader(options_->batch_size, &batch_reader));\n\nReview comment:\n       I pushed an update, and now manually iteratively read the next stripe with `ReadStripe` (I followed the approach of a ScanTaskIterator from file_ipc.cc). \r\n   (this doesn't support `batch_size` anymore, since ReadStripe always returns a single record batch, but that's something that can be improved later, I suppose)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-31T07:44:09.680+0000",
                    "updated": "2021-08-31T07:44:09.680+0000",
                    "started": "2021-08-31T07:44:09.680+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "643910",
                    "issueId": "13393720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/644030",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#discussion_r699307256\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,185 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/adapters/orc/adapter.h\"\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+namespace {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n+    const FileSource& source,\n+    const std::shared_ptr<ScanOptions>& scan_options = nullptr) {\n+  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n+\n+  arrow::MemoryPool* pool;\n+  if (scan_options) {\n+    pool = scan_options->pool;\n+  } else {\n+    pool = default_memory_pool();\n+  }\n+\n+  std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader;\n+  auto status =\n+      arrow::adapters::orc::ORCFileReader::Open(std::move(input), pool, &reader);\n+  if (!status.ok()) {\n+    return status.WithMessage(\"Could not open ORC input source '\", source.path(),\n+                              \"': \", status.message());\n+  }\n+  return reader;\n+}\n+\n+/// \\brief A ScanTask backed by an ORC file.\n+class OrcScanTask : public ScanTask {\n+ public:\n+  OrcScanTask(std::shared_ptr<FileFragment> fragment,\n+              std::shared_ptr<ScanOptions> options)\n+      : ScanTask(std::move(options), fragment), source_(fragment->source()) {}\n+\n+  Result<RecordBatchIterator> Execute() override {\n+    struct Impl {\n+      static Result<RecordBatchIterator> Make(const FileSource& source,\n+                                              const FileFormat& format,\n+                                              const ScanOptions& scan_options) {\n+        ARROW_ASSIGN_OR_RAISE(\n+            auto reader, OpenReader(source, std::make_shared<ScanOptions>(scan_options)));\n+        int num_stripes = reader->NumberOfStripes();\n+        return RecordBatchIterator(Impl{std::move(reader), 0, num_stripes});\n+      }\n+\n+      Result<std::shared_ptr<RecordBatch>> Next() {\n+        if (i_ == num_stripes_) {\n+          return nullptr;\n+        }\n+        std::shared_ptr<RecordBatch> batch;\n+        // TODO (https://issues.apache.org/jira/browse/ARROW-13797)\n+        // determine included fields from options_->MaterializedFields() to\n+        // optimize the column selection (see _column_index_lookup in python\n+        // orc.py for custom logic)\n+        // std::vector<int> included_fields;\n+        // TODO pass scan_options_->batch_size\n+        reader_->ReadStripe(i_++, &batch);\n\nReview comment:\n       The potential error return should not be ignored here.\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n\nReview comment:\n       Thanks. `static` has become redundant here now.\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,185 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/adapters/orc/adapter.h\"\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+namespace {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n+    const FileSource& source,\n+    const std::shared_ptr<ScanOptions>& scan_options = nullptr) {\n+  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n+\n+  arrow::MemoryPool* pool;\n+  if (scan_options) {\n+    pool = scan_options->pool;\n+  } else {\n+    pool = default_memory_pool();\n+  }\n+\n+  std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader;\n+  auto status =\n+      arrow::adapters::orc::ORCFileReader::Open(std::move(input), pool, &reader);\n+  if (!status.ok()) {\n+    return status.WithMessage(\"Could not open ORC input source '\", source.path(),\n+                              \"': \", status.message());\n+  }\n+  return reader;\n+}\n+\n+/// \\brief A ScanTask backed by an ORC file.\n+class OrcScanTask : public ScanTask {\n+ public:\n+  OrcScanTask(std::shared_ptr<FileFragment> fragment,\n+              std::shared_ptr<ScanOptions> options)\n+      : ScanTask(std::move(options), fragment), source_(fragment->source()) {}\n+\n+  Result<RecordBatchIterator> Execute() override {\n+    struct Impl {\n+      static Result<RecordBatchIterator> Make(const FileSource& source,\n+                                              const FileFormat& format,\n+                                              const ScanOptions& scan_options) {\n+        ARROW_ASSIGN_OR_RAISE(\n+            auto reader, OpenReader(source, std::make_shared<ScanOptions>(scan_options)));\n+        int num_stripes = reader->NumberOfStripes();\n+        return RecordBatchIterator(Impl{std::move(reader), 0, num_stripes});\n+      }\n+\n+      Result<std::shared_ptr<RecordBatch>> Next() {\n+        if (i_ == num_stripes_) {\n+          return nullptr;\n+        }\n+        std::shared_ptr<RecordBatch> batch;\n+        // TODO (https://issues.apache.org/jira/browse/ARROW-13797)\n+        // determine included fields from options_->MaterializedFields() to\n+        // optimize the column selection (see _column_index_lookup in python\n+        // orc.py for custom logic)\n+        // std::vector<int> included_fields;\n+        // TODO pass scan_options_->batch_size\n+        reader_->ReadStripe(i_++, &batch);\n+        return batch;\n+      }\n+\n+      std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader_;\n+      int i_;\n+      int num_stripes_;\n+    };\n+\n+    return Impl::Make(source_, *checked_pointer_cast<FileFragment>(fragment_)->format(),\n+                      *options_);\n+  }\n+\n+ private:\n+  FileSource source_;\n+};\n+\n+class OrcScanTaskIterator {\n+ public:\n+  static Result<ScanTaskIterator> Make(std::shared_ptr<ScanOptions> options,\n+                                       std::shared_ptr<FileFragment> fragment) {\n+    return ScanTaskIterator(OrcScanTaskIterator(std::move(options), std::move(fragment)));\n+  }\n+\n+  Result<std::shared_ptr<ScanTask>> Next() {\n+    if (once_) {\n+      // Iteration is done.\n+      return nullptr;\n+    }\n+\n+    once_ = true;\n+    return std::shared_ptr<ScanTask>(new OrcScanTask(fragment_, options_));\n+  }\n+\n+ private:\n+  OrcScanTaskIterator(std::shared_ptr<ScanOptions> options,\n+                      std::shared_ptr<FileFragment> fragment)\n+      : options_(std::move(options)), fragment_(std::move(fragment)) {}\n+\n+  bool once_ = false;\n+  std::shared_ptr<ScanOptions> options_;\n+  std::shared_ptr<FileFragment> fragment_;\n+};\n+\n+}  // namespace\n+\n+Result<bool> OrcFileFormat::IsSupported(const FileSource& source) const {\n+  RETURN_NOT_OK(source.Open().status());\n+  return OpenReader(source).ok();\n+}\n+\n+Result<std::shared_ptr<Schema>> OrcFileFormat::Inspect(const FileSource& source) const {\n+  ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source));\n+  std::shared_ptr<Schema> schema;\n+  RETURN_NOT_OK(reader->ReadSchema(&schema));\n+  return schema;\n+}\n+\n+Result<ScanTaskIterator> OrcFileFormat::ScanFile(\n+    const std::shared_ptr<ScanOptions>& options,\n+    const std::shared_ptr<FileFragment>& fragment) const {\n+  return OrcScanTaskIterator::Make(options, fragment);\n+}\n+\n+Future<util::optional<int64_t>> OrcFileFormat::CountRows(\n+    const std::shared_ptr<FileFragment>& file, compute::Expression predicate,\n+    const std::shared_ptr<ScanOptions>& options) {\n+  if (ExpressionHasFieldRefs(predicate)) {\n+    return Future<util::optional<int64_t>>::MakeFinished(util::nullopt);\n+  }\n+  auto self = checked_pointer_cast<OrcFileFormat>(shared_from_this());\n+  return DeferNotOk(options->io_context.executor()->Submit(\n+      [self, file]() -> Result<util::optional<int64_t>> {\n+        ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(file->source()));\n+        return reader->NumberOfRows();\n+      }));\n+}\n+\n+// //\n+// // IpcFileWriter, IpcFileWriteOptions\n+// //\n\nReview comment:\n       These comments seem outdated?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-31T13:18:26.047+0000",
                    "updated": "2021-08-31T13:18:26.047+0000",
                    "started": "2021-08-31T13:18:26.047+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "644030",
                    "issueId": "13393720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/644032",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#issuecomment-909230831\n\n\n   Hmm, unfortunately there are linker errors when building the Cython bindings with ORC disabled (see AppVeyor errors). Perhaps an optional `_dataset_orc` module will be needed.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-31T13:19:44.529+0000",
                    "updated": "2021-08-31T13:19:44.529+0000",
                    "started": "2021-08-31T13:19:44.529+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "644032",
                    "issueId": "13393720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/644039",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#issuecomment-909243149\n\n\n   > Hmm, unfortunately there are linker errors when building the Cython bindings with ORC disabled (see AppVeyor errors). Perhaps an optional `_dataset_orc` module will be needed.\r\n   \r\n   Yes, I know (see https://github.com/apache/arrow/pull/10991#issuecomment-904872259), but not fully sure how to this can be done in practice. @lidavidm described a possible way to do this above (https://github.com/apache/arrow/pull/10991#issuecomment-906362174), but do you have an idea how we could handle `FileFormat._wrap` and `Fragment._wrap`? I don't think with cython we can \"conditionally\" import symbols from another file? (that might need some of kind of register mechanism?)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-31T13:34:31.493+0000",
                    "updated": "2021-08-31T13:34:31.493+0000",
                    "started": "2021-08-31T13:34:31.493+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "644039",
                    "issueId": "13393720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/644224",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#issuecomment-909243149\n\n\n   > Hmm, unfortunately there are linker errors when building the Cython bindings with ORC disabled (see AppVeyor errors). Perhaps an optional `_dataset_orc` module will be needed.\r\n   \r\n   Yes, I know (see https://github.com/apache/arrow/pull/10991#issuecomment-904872259), but not fully sure how to this can be done in practice. @lidavidm described a possible way to do this above (https://github.com/apache/arrow/pull/10991#issuecomment-906362174), but do you have an idea how we could handle `FileFormat._wrap` and `Fragment._wrap`? I don't think with cython we can \"conditionally\" import symbols from another file? (that might need some of kind of register mechanism?)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-31T15:00:47.830+0000",
                    "updated": "2021-08-31T15:00:47.830+0000",
                    "started": "2021-08-31T15:00:47.829+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "644224",
                    "issueId": "13393720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/644239",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#issuecomment-908493427\n\n\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-31T15:02:17.560+0000",
                    "updated": "2021-08-31T15:02:17.560+0000",
                    "started": "2021-08-31T15:02:17.560+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "644239",
                    "issueId": "13393720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/worklog/644262",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10991:\nURL: https://github.com/apache/arrow/pull/10991#discussion_r698437245\n\n\n\n##########\nFile path: python/pyarrow/tests/test_dataset.py\n##########\n@@ -2614,6 +2615,49 @@ def test_ipc_format(tempdir, dataset_reader):\n         assert result.equals(table)\n \n \n+@pytest.mark.orc\n+def test_orc_format(tempdir, dataset_reader):\n+    from pyarrow import orc\n+    table = pa.table({'a': pa.array([1, 2, 3], type=\"int8\"),\n+                      'b': pa.array([.1, .2, .3], type=\"float64\")})\n+\n+    path = str(tempdir / 'test.orc')\n+    orc.write_table(table, path)\n+\n+    dataset = ds.dataset(path, format=ds.OrcFileFormat())\n+    result = dataset_reader.to_table(dataset)\n\nReview comment:\n       Can you add `result.validate(full=True)` here and in other similar places?\n\n##########\nFile path: python/pyarrow/tests/test_dataset.py\n##########\n@@ -2614,6 +2615,49 @@ def test_ipc_format(tempdir, dataset_reader):\n         assert result.equals(table)\n \n \n+@pytest.mark.orc\n+def test_orc_format(tempdir, dataset_reader):\n+    from pyarrow import orc\n+    table = pa.table({'a': pa.array([1, 2, 3], type=\"int8\"),\n+                      'b': pa.array([.1, .2, .3], type=\"float64\")})\n+\n+    path = str(tempdir / 'test.orc')\n+    orc.write_table(table, path)\n+\n+    dataset = ds.dataset(path, format=ds.OrcFileFormat())\n+    result = dataset_reader.to_table(dataset)\n+    assert result.equals(table)\n+\n+    dataset = ds.dataset(path, format=\"orc\")\n+    result = dataset_reader.to_table(dataset)\n+    assert result.equals(table)\n+\n+    result = dataset_reader.to_table(dataset, columns=[\"b\"])\n+    assert result.equals(table.select([\"b\"]))\n+\n+    assert dataset_reader.count_rows(dataset) == 3\n+    assert dataset_reader.count_rows(dataset, filter=ds.field(\"a\") > 2) == 1\n+\n+\n+@pytest.mark.orc\n+def test_orc_scan_options(tempdir, dataset_reader):\n+    from pyarrow import orc\n+    table = pa.table({'a': pa.array([1, 2, 3], type=\"int8\"),\n+                      'b': pa.array([.1, .2, .3], type=\"float64\")})\n+\n+    path = str(tempdir / 'test.orc')\n+    orc.write_table(table, path)\n+\n+    dataset = ds.dataset(path, format=\"orc\")\n+    result = list(dataset_reader.to_batches(dataset))\n+    assert len(result) == 1\n+    assert result[0].num_rows == 3\n+    result = list(dataset_reader.to_batches(dataset, batch_size=2))\n+    assert len(result) == 2\n+    assert result[0].num_rows == 2\n+    assert result[1].num_rows == 1\n\nReview comment:\n       Can you also test the actual result values? \n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.h\n##########\n@@ -0,0 +1,79 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"arrow/adapters/orc/adapter.h\"\n\nReview comment:\n       I'm not sure this include is actually necessary here?\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n+    const FileSource& source,\n+    const std::shared_ptr<ScanOptions>& scan_options = nullptr) {\n+  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n+\n+  arrow::MemoryPool* pool;\n+  if (scan_options) {\n+    pool = scan_options->pool;\n+  } else {\n+    pool = default_memory_pool();\n+  }\n+\n+  std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader;\n+  auto status =\n+      arrow::adapters::orc::ORCFileReader::Open(std::move(input), pool, &reader);\n+  if (!status.ok()) {\n+    return status.WithMessage(\"Could not open ORC input source '\", source.path(),\n+                              \"': \", status.message());\n+  }\n+  return reader;\n+}\n+\n+/// \\brief A ScanTask backed by an ORC file.\n+class OrcScanTask : public ScanTask {\n+ public:\n+  OrcScanTask(std::shared_ptr<FileFragment> fragment,\n+              std::shared_ptr<ScanOptions> options)\n+      : ScanTask(std::move(options), fragment), source_(fragment->source()) {}\n+\n+  Result<RecordBatchIterator> Execute() override {\n+    ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source_));\n+    std::shared_ptr<arrow::RecordBatchReader> batch_reader;\n+    // TODO determine included fields from options_->MaterializedFields() to\n+    // optimize the column selection (see _column_index_lookup in python\n+    // orc.py for custom logic)\n+    // std::vector<int> included_fields;\n+    RETURN_NOT_OK(reader->NextStripeReader(options_->batch_size, &batch_reader));\n+\n+    auto batch_it = MakeIteratorFromReader(batch_reader);\n+    return batch_it;\n+  }\n+\n+ private:\n+  FileSource source_;\n+};\n+\n+Result<bool> OrcFileFormat::IsSupported(const FileSource& source) const {\n+  RETURN_NOT_OK(source.Open().status());\n+  return OpenReader(source).ok();\n+}\n+\n+Result<std::shared_ptr<Schema>> OrcFileFormat::Inspect(const FileSource& source) const {\n+  ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source));\n+  std::shared_ptr<Schema> schema;\n+  RETURN_NOT_OK(reader->ReadSchema(&schema));\n\nReview comment:\n       For the record, see also https://issues.apache.org/jira/browse/ARROW-13793\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n\nReview comment:\n       Can you put all private functions and classes inside the anonymous namespace? (that is, `namespace {`)\r\n   \r\n   The anonymous namespace is equivalent to `static` for functions, but also applies to classes, variables, etc.\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n+    const FileSource& source,\n+    const std::shared_ptr<ScanOptions>& scan_options = nullptr) {\n+  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n+\n+  arrow::MemoryPool* pool;\n+  if (scan_options) {\n+    pool = scan_options->pool;\n+  } else {\n+    pool = default_memory_pool();\n+  }\n+\n+  std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader;\n+  auto status =\n+      arrow::adapters::orc::ORCFileReader::Open(std::move(input), pool, &reader);\n+  if (!status.ok()) {\n+    return status.WithMessage(\"Could not open ORC input source '\", source.path(),\n+                              \"': \", status.message());\n+  }\n+  return reader;\n+}\n+\n+/// \\brief A ScanTask backed by an ORC file.\n+class OrcScanTask : public ScanTask {\n+ public:\n+  OrcScanTask(std::shared_ptr<FileFragment> fragment,\n+              std::shared_ptr<ScanOptions> options)\n+      : ScanTask(std::move(options), fragment), source_(fragment->source()) {}\n+\n+  Result<RecordBatchIterator> Execute() override {\n+    ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source_));\n+    std::shared_ptr<arrow::RecordBatchReader> batch_reader;\n+    // TODO determine included fields from options_->MaterializedFields() to\n\nReview comment:\n       Can you perhaps open a JIRA for this TODO?\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n+    const FileSource& source,\n+    const std::shared_ptr<ScanOptions>& scan_options = nullptr) {\n+  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n+\n+  arrow::MemoryPool* pool;\n+  if (scan_options) {\n+    pool = scan_options->pool;\n+  } else {\n+    pool = default_memory_pool();\n+  }\n+\n+  std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader;\n+  auto status =\n+      arrow::adapters::orc::ORCFileReader::Open(std::move(input), pool, &reader);\n+  if (!status.ok()) {\n+    return status.WithMessage(\"Could not open ORC input source '\", source.path(),\n+                              \"': \", status.message());\n+  }\n+  return reader;\n+}\n+\n+/// \\brief A ScanTask backed by an ORC file.\n+class OrcScanTask : public ScanTask {\n+ public:\n+  OrcScanTask(std::shared_ptr<FileFragment> fragment,\n+              std::shared_ptr<ScanOptions> options)\n+      : ScanTask(std::move(options), fragment), source_(fragment->source()) {}\n+\n+  Result<RecordBatchIterator> Execute() override {\n+    ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source_));\n+    std::shared_ptr<arrow::RecordBatchReader> batch_reader;\n+    // TODO determine included fields from options_->MaterializedFields() to\n+    // optimize the column selection (see _column_index_lookup in python\n+    // orc.py for custom logic)\n+    // std::vector<int> included_fields;\n+    RETURN_NOT_OK(reader->NextStripeReader(options_->batch_size, &batch_reader));\n+\n+    auto batch_it = MakeIteratorFromReader(batch_reader);\n+    return batch_it;\n+  }\n+\n+ private:\n+  FileSource source_;\n+};\n+\n+Result<bool> OrcFileFormat::IsSupported(const FileSource& source) const {\n+  RETURN_NOT_OK(source.Open().status());\n+  return OpenReader(source).ok();\n+}\n+\n+Result<std::shared_ptr<Schema>> OrcFileFormat::Inspect(const FileSource& source) const {\n+  ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source));\n+  std::shared_ptr<Schema> schema;\n+  RETURN_NOT_OK(reader->ReadSchema(&schema));\n+  return schema;\n+}\n+\n+Result<ScanTaskIterator> OrcFileFormat::ScanFile(\n+    const std::shared_ptr<ScanOptions>& options,\n+    const std::shared_ptr<FileFragment>& fragment) const {\n+  auto task = std::make_shared<OrcScanTask>(fragment, options);\n+\n+  return MakeVectorIterator<std::shared_ptr<ScanTask>>({std::move(task)});\n+}\n+\n+Future<util::optional<int64_t>> OrcFileFormat::CountRows(\n+    const std::shared_ptr<FileFragment>& file, compute::Expression predicate,\n+    const std::shared_ptr<ScanOptions>& options) {\n+  if (ExpressionHasFieldRefs(predicate)) {\n+    return Future<util::optional<int64_t>>::MakeFinished(util::nullopt);\n+  }\n+  auto self = internal::checked_pointer_cast<OrcFileFormat>(shared_from_this());\n+  return DeferNotOk(options->io_context.executor()->Submit(\n+      [self, file]() -> Result<util::optional<int64_t>> {\n+        ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(file->source()));\n+        return reader->NumberOfRows();\n+      }));\n+}\n+\n+// //\n+// // IpcFileWriter, IpcFileWriteOptions\n+// //\n+\n+std::shared_ptr<FileWriteOptions> OrcFileFormat::DefaultWriteOptions() {\n+  // TODO\n+  return NULLPTR;\n\nReview comment:\n       Can use `nullptr` in `.cc` files.\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n+    const FileSource& source,\n+    const std::shared_ptr<ScanOptions>& scan_options = nullptr) {\n+  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n+\n+  arrow::MemoryPool* pool;\n+  if (scan_options) {\n+    pool = scan_options->pool;\n+  } else {\n+    pool = default_memory_pool();\n+  }\n+\n+  std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader;\n+  auto status =\n+      arrow::adapters::orc::ORCFileReader::Open(std::move(input), pool, &reader);\n+  if (!status.ok()) {\n+    return status.WithMessage(\"Could not open ORC input source '\", source.path(),\n+                              \"': \", status.message());\n+  }\n+  return reader;\n+}\n+\n+/// \\brief A ScanTask backed by an ORC file.\n+class OrcScanTask : public ScanTask {\n+ public:\n+  OrcScanTask(std::shared_ptr<FileFragment> fragment,\n+              std::shared_ptr<ScanOptions> options)\n+      : ScanTask(std::move(options), fragment), source_(fragment->source()) {}\n+\n+  Result<RecordBatchIterator> Execute() override {\n+    ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source_));\n+    std::shared_ptr<arrow::RecordBatchReader> batch_reader;\n+    // TODO determine included fields from options_->MaterializedFields() to\n+    // optimize the column selection (see _column_index_lookup in python\n+    // orc.py for custom logic)\n+    // std::vector<int> included_fields;\n+    RETURN_NOT_OK(reader->NextStripeReader(options_->batch_size, &batch_reader));\n\nReview comment:\n       Hmm, IIUC, this will only read one stripe from the ORC file, but an ORC file may well have several stripes. @iajoiner is my interpretation correct?\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,185 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/adapters/orc/adapter.h\"\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+namespace {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n+    const FileSource& source,\n+    const std::shared_ptr<ScanOptions>& scan_options = nullptr) {\n+  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n+\n+  arrow::MemoryPool* pool;\n+  if (scan_options) {\n+    pool = scan_options->pool;\n+  } else {\n+    pool = default_memory_pool();\n+  }\n+\n+  std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader;\n+  auto status =\n+      arrow::adapters::orc::ORCFileReader::Open(std::move(input), pool, &reader);\n+  if (!status.ok()) {\n+    return status.WithMessage(\"Could not open ORC input source '\", source.path(),\n+                              \"': \", status.message());\n+  }\n+  return reader;\n+}\n+\n+/// \\brief A ScanTask backed by an ORC file.\n+class OrcScanTask : public ScanTask {\n+ public:\n+  OrcScanTask(std::shared_ptr<FileFragment> fragment,\n+              std::shared_ptr<ScanOptions> options)\n+      : ScanTask(std::move(options), fragment), source_(fragment->source()) {}\n+\n+  Result<RecordBatchIterator> Execute() override {\n+    struct Impl {\n+      static Result<RecordBatchIterator> Make(const FileSource& source,\n+                                              const FileFormat& format,\n+                                              const ScanOptions& scan_options) {\n+        ARROW_ASSIGN_OR_RAISE(\n+            auto reader, OpenReader(source, std::make_shared<ScanOptions>(scan_options)));\n+        int num_stripes = reader->NumberOfStripes();\n+        return RecordBatchIterator(Impl{std::move(reader), 0, num_stripes});\n+      }\n+\n+      Result<std::shared_ptr<RecordBatch>> Next() {\n+        if (i_ == num_stripes_) {\n+          return nullptr;\n+        }\n+        std::shared_ptr<RecordBatch> batch;\n+        // TODO (https://issues.apache.org/jira/browse/ARROW-13797)\n+        // determine included fields from options_->MaterializedFields() to\n+        // optimize the column selection (see _column_index_lookup in python\n+        // orc.py for custom logic)\n+        // std::vector<int> included_fields;\n+        // TODO pass scan_options_->batch_size\n+        reader_->ReadStripe(i_++, &batch);\n\nReview comment:\n       The potential error return should not be ignored here.\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,132 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n\nReview comment:\n       Thanks. `static` has become redundant here now.\n\n##########\nFile path: cpp/src/arrow/dataset/file_orc.cc\n##########\n@@ -0,0 +1,185 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/file_orc.h\"\n+\n+#include <memory>\n+\n+#include \"arrow/adapters/orc/adapter.h\"\n+#include \"arrow/dataset/dataset_internal.h\"\n+#include \"arrow/dataset/file_base.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+namespace {\n+\n+static inline Result<std::unique_ptr<arrow::adapters::orc::ORCFileReader>> OpenReader(\n+    const FileSource& source,\n+    const std::shared_ptr<ScanOptions>& scan_options = nullptr) {\n+  ARROW_ASSIGN_OR_RAISE(auto input, source.Open());\n+\n+  arrow::MemoryPool* pool;\n+  if (scan_options) {\n+    pool = scan_options->pool;\n+  } else {\n+    pool = default_memory_pool();\n+  }\n+\n+  std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader;\n+  auto status =\n+      arrow::adapters::orc::ORCFileReader::Open(std::move(input), pool, &reader);\n+  if (!status.ok()) {\n+    return status.WithMessage(\"Could not open ORC input source '\", source.path(),\n+                              \"': \", status.message());\n+  }\n+  return reader;\n+}\n+\n+/// \\brief A ScanTask backed by an ORC file.\n+class OrcScanTask : public ScanTask {\n+ public:\n+  OrcScanTask(std::shared_ptr<FileFragment> fragment,\n+              std::shared_ptr<ScanOptions> options)\n+      : ScanTask(std::move(options), fragment), source_(fragment->source()) {}\n+\n+  Result<RecordBatchIterator> Execute() override {\n+    struct Impl {\n+      static Result<RecordBatchIterator> Make(const FileSource& source,\n+                                              const FileFormat& format,\n+                                              const ScanOptions& scan_options) {\n+        ARROW_ASSIGN_OR_RAISE(\n+            auto reader, OpenReader(source, std::make_shared<ScanOptions>(scan_options)));\n+        int num_stripes = reader->NumberOfStripes();\n+        return RecordBatchIterator(Impl{std::move(reader), 0, num_stripes});\n+      }\n+\n+      Result<std::shared_ptr<RecordBatch>> Next() {\n+        if (i_ == num_stripes_) {\n+          return nullptr;\n+        }\n+        std::shared_ptr<RecordBatch> batch;\n+        // TODO (https://issues.apache.org/jira/browse/ARROW-13797)\n+        // determine included fields from options_->MaterializedFields() to\n+        // optimize the column selection (see _column_index_lookup in python\n+        // orc.py for custom logic)\n+        // std::vector<int> included_fields;\n+        // TODO pass scan_options_->batch_size\n+        reader_->ReadStripe(i_++, &batch);\n+        return batch;\n+      }\n+\n+      std::unique_ptr<arrow::adapters::orc::ORCFileReader> reader_;\n+      int i_;\n+      int num_stripes_;\n+    };\n+\n+    return Impl::Make(source_, *checked_pointer_cast<FileFragment>(fragment_)->format(),\n+                      *options_);\n+  }\n+\n+ private:\n+  FileSource source_;\n+};\n+\n+class OrcScanTaskIterator {\n+ public:\n+  static Result<ScanTaskIterator> Make(std::shared_ptr<ScanOptions> options,\n+                                       std::shared_ptr<FileFragment> fragment) {\n+    return ScanTaskIterator(OrcScanTaskIterator(std::move(options), std::move(fragment)));\n+  }\n+\n+  Result<std::shared_ptr<ScanTask>> Next() {\n+    if (once_) {\n+      // Iteration is done.\n+      return nullptr;\n+    }\n+\n+    once_ = true;\n+    return std::shared_ptr<ScanTask>(new OrcScanTask(fragment_, options_));\n+  }\n+\n+ private:\n+  OrcScanTaskIterator(std::shared_ptr<ScanOptions> options,\n+                      std::shared_ptr<FileFragment> fragment)\n+      : options_(std::move(options)), fragment_(std::move(fragment)) {}\n+\n+  bool once_ = false;\n+  std::shared_ptr<ScanOptions> options_;\n+  std::shared_ptr<FileFragment> fragment_;\n+};\n+\n+}  // namespace\n+\n+Result<bool> OrcFileFormat::IsSupported(const FileSource& source) const {\n+  RETURN_NOT_OK(source.Open().status());\n+  return OpenReader(source).ok();\n+}\n+\n+Result<std::shared_ptr<Schema>> OrcFileFormat::Inspect(const FileSource& source) const {\n+  ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(source));\n+  std::shared_ptr<Schema> schema;\n+  RETURN_NOT_OK(reader->ReadSchema(&schema));\n+  return schema;\n+}\n+\n+Result<ScanTaskIterator> OrcFileFormat::ScanFile(\n+    const std::shared_ptr<ScanOptions>& options,\n+    const std::shared_ptr<FileFragment>& fragment) const {\n+  return OrcScanTaskIterator::Make(options, fragment);\n+}\n+\n+Future<util::optional<int64_t>> OrcFileFormat::CountRows(\n+    const std::shared_ptr<FileFragment>& file, compute::Expression predicate,\n+    const std::shared_ptr<ScanOptions>& options) {\n+  if (ExpressionHasFieldRefs(predicate)) {\n+    return Future<util::optional<int64_t>>::MakeFinished(util::nullopt);\n+  }\n+  auto self = checked_pointer_cast<OrcFileFormat>(shared_from_this());\n+  return DeferNotOk(options->io_context.executor()->Submit(\n+      [self, file]() -> Result<util::optional<int64_t>> {\n+        ARROW_ASSIGN_OR_RAISE(auto reader, OpenReader(file->source()));\n+        return reader->NumberOfRows();\n+      }));\n+}\n+\n+// //\n+// // IpcFileWriter, IpcFileWriteOptions\n+// //\n\nReview comment:\n       These comments seem outdated?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-31T15:04:34.477+0000",
                    "updated": "2021-08-31T15:04:34.477+0000",
                    "started": "2021-08-31T15:04:34.476+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "644262",
                    "issueId": "13393720"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 30600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@8bb3b8f[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@33e661b5[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2c4cd800[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@2ca7eff5[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4112b242[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@6b5930f8[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@211f794b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@3254e2da[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6680d670[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@447ce4a8[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1e73084d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@b247b6b[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 30600,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Sep 28 11:41:03 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-09-28T11:41:03.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13572/watchers",
            "watchCount": 4,
            "isWatching": false
        },
        "created": "2021-08-05T13:38:35.000+0000",
        "updated": "2022-02-06T09:06:49.000+0000",
        "timeoriginalestimate": null,
        "description": "There is significant interest in having directory-partitioned ORC support from users of Dask.\u00a0 Since Dask already leverages the pyarrow.datasets API for parquet-formatted data, having ORC support through the same pyarrow API would be extremely useful.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "8.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 30600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Python] Add basic ORC support to the pyarrow.datasets API",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393720/comment/17421336",
                    "id": "17421336",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "body": "Issue resolved by pull request 10991\n[https://github.com/apache/arrow/pull/10991]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "created": "2021-09-28T11:41:03.298+0000",
                    "updated": "2021-09-28T11:41:03.298+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0tn8w:",
        "customfield_12314139": null
    }
}