{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13214524",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524",
    "key": "ARROW-4511",
    "fields": {
        "parent": {
            "id": "13117429",
            "key": "ARROW-1789",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13117429",
            "fields": {
                "summary": "[Format] Consolidate specification documents and improve clarity for new implementation authors",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                    "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                    "name": "Resolved",
                    "id": "5",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                    "id": "4",
                    "description": "An improvement or enhancement to an existing feature or task.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                    "name": "Improvement",
                    "subtask": false,
                    "avatarId": 21140
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12345978",
                "id": "12345978",
                "description": "",
                "name": "0.15.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-10-05"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328932",
                "id": "12328932",
                "name": "Format"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 47400,
            "total": 47400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 47400,
            "total": 47400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-4511/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 160,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/301615",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202\n \n \n   I made an effort to de-cruft the Format documentation, improve outdated, redundant, or unnecessary language, and avoid copy-pasting of stuff from the Flatbuffers files. I expect that readers of this document will be able to refer to the Flatbuffers files themselves (as long as it's clear where to look).\r\n   \r\n   I also added a format/Versioning.rst which encodes the outcomes of our recent vote about how versions will be handled starting with 1.0.0. I am not sure where we'll write down the versions yet. \r\n   \r\n   I maintained links from the old pages (which are hidden from the main toctree) so that stale search engine results will still lead people to the right place.\r\n   \r\n   There's a bunch of JIRA issues connected to this. I assigned myself the ones that seemed relevant. \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T00:43:59.712+0000",
                    "updated": "2019-08-27T00:43:59.712+0000",
                    "started": "2019-08-27T00:43:59.711+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "301615",
                    "issueId": "13214524"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/301618",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "codecov-io commented on issue #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202#issuecomment-525095677\n \n \n   # [Codecov](https://codecov.io/gh/apache/arrow/pull/5202?src=pr&el=h1) Report\n   > Merging [#5202](https://codecov.io/gh/apache/arrow/pull/5202?src=pr&el=desc) into [master](https://codecov.io/gh/apache/arrow/commit/c9bd6d736cd77371bb9a31cfaa7d47580cc111ae?src=pr&el=desc) will **decrease** coverage by `22.37%`.\n   > The diff coverage is `n/a`.\n   \n   [![Impacted file tree graph](https://codecov.io/gh/apache/arrow/pull/5202/graphs/tree.svg?width=650&token=LpTCFbqVT1&height=150&src=pr)](https://codecov.io/gh/apache/arrow/pull/5202?src=pr&el=tree)\n   \n   ```diff\n   @@             Coverage Diff             @@\n   ##           master    #5202       +/-   ##\n   ===========================================\n   - Coverage   87.65%   65.27%   -22.38%     \n   ===========================================\n     Files        1025      497      -528     \n     Lines      146686    67390    -79296     \n     Branches     1437        0     -1437     \n   ===========================================\n   - Hits       128573    43989    -84584     \n   - Misses      17751    23401     +5650     \n   + Partials      362        0      -362\n   ```\n   \n   \n   | [Impacted Files](https://codecov.io/gh/apache/arrow/pull/5202?src=pr&el=tree) | Coverage \u0394 | |\n   |---|---|---|\n   | [cpp/src/arrow/util/memory.h](https://codecov.io/gh/apache/arrow/pull/5202/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy91dGlsL21lbW9yeS5o) | `0% <0%> (-100%)` | :arrow_down: |\n   | [cpp/src/gandiva/date\\_utils.h](https://codecov.io/gh/apache/arrow/pull/5202/diff?src=pr&el=tree#diff-Y3BwL3NyYy9nYW5kaXZhL2RhdGVfdXRpbHMuaA==) | `0% <0%> (-100%)` | :arrow_down: |\n   | [cpp/src/arrow/util/memory.cc](https://codecov.io/gh/apache/arrow/pull/5202/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy91dGlsL21lbW9yeS5jYw==) | `0% <0%> (-100%)` | :arrow_down: |\n   | [cpp/src/gandiva/decimal\\_type\\_util.h](https://codecov.io/gh/apache/arrow/pull/5202/diff?src=pr&el=tree#diff-Y3BwL3NyYy9nYW5kaXZhL2RlY2ltYWxfdHlwZV91dGlsLmg=) | `0% <0%> (-100%)` | :arrow_down: |\n   | [cpp/src/arrow/filesystem/util\\_internal.cc](https://codecov.io/gh/apache/arrow/pull/5202/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9maWxlc3lzdGVtL3V0aWxfaW50ZXJuYWwuY2M=) | `0% <0%> (-100%)` | :arrow_down: |\n   | [cpp/src/arrow/compute/logical\\_type.h](https://codecov.io/gh/apache/arrow/pull/5202/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9jb21wdXRlL2xvZ2ljYWxfdHlwZS5o) | `0% <0%> (-100%)` | :arrow_down: |\n   | [cpp/src/parquet/hasher.h](https://codecov.io/gh/apache/arrow/pull/5202/diff?src=pr&el=tree#diff-Y3BwL3NyYy9wYXJxdWV0L2hhc2hlci5o) | `0% <0%> (-100%)` | :arrow_down: |\n   | [cpp/src/gandiva/basic\\_decimal\\_scalar.h](https://codecov.io/gh/apache/arrow/pull/5202/diff?src=pr&el=tree#diff-Y3BwL3NyYy9nYW5kaXZhL2Jhc2ljX2RlY2ltYWxfc2NhbGFyLmg=) | `0% <0%> (-100%)` | :arrow_down: |\n   | [cpp/src/arrow/compute/kernels/boolean.cc](https://codecov.io/gh/apache/arrow/pull/5202/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9jb21wdXRlL2tlcm5lbHMvYm9vbGVhbi5jYw==) | `0% <0%> (-100%)` | :arrow_down: |\n   | [cpp/src/arrow/compute/operation.h](https://codecov.io/gh/apache/arrow/pull/5202/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9jb21wdXRlL29wZXJhdGlvbi5o) | `0% <0%> (-100%)` | :arrow_down: |\n   | ... and [773 more](https://codecov.io/gh/apache/arrow/pull/5202/diff?src=pr&el=tree-more) | |\n   \n   ------\n   \n   [Continue to review full report at Codecov](https://codecov.io/gh/apache/arrow/pull/5202?src=pr&el=continue).\n   > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n   > `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n   > Powered by [Codecov](https://codecov.io/gh/apache/arrow/pull/5202?src=pr&el=footer). Last update [c9bd6d7...7b20ccd](https://codecov.io/gh/apache/arrow/pull/5202?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T01:23:50.934+0000",
                    "updated": "2019-08-27T01:23:50.934+0000",
                    "started": "2019-08-27T01:23:50.934+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "301618",
                    "issueId": "13214524"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/302057",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202#discussion_r318104326\n \n \n\n ##########\n File path: docs/source/format/Columnar.rst\n ##########\n @@ -0,0 +1,1266 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. _format_columnar:\n+\n+*********************\n+Arrow Columnar Format\n+*********************\n+\n+The \"Arrow Columnar Format\" includes a language-agnostic in-memory\n+data structure specification, metadata serialization, and a protocol\n+for serialization and generic data transport.\n+\n+This document is intended to provide adequate detail to create a new\n+implementation of the columnar format without the aid of an existing\n+implementation. We utilize Google's `Flatbuffers`_ project for\n+metadata serialization, so it will be necessary to refer to the\n+project's `Flatbuffers protocol definition files <FlatbuffersFiles>`_\n+while reading this document.\n+\n+The columnar format has some key features:\n+\n+* Data adjacency for sequential access (scans)\n+* O(1) (constant-time) random access\n+* SIMD and vectorization-friendly\n+* Relocatable without \"pointer swizzling\", allowing for true zero-copy\n+  access in shared memory\n+\n+Some things to keep in mind:\n+\n+* Some data types can be mutated in-place in memory, but others\n+  cannot. The community has made deliberate trade-offs regarding\n+  in-place mutability to provide analytical performance and data\n+  locality guarantees\n+\n+Terminology\n+===========\n+\n+Since different projects have used different words to describe various\n+concepts, here is a small glossary to help disambiguate.\n+\n+* **Array** or **Vector**: a sequence of values with known length all\n+  having the same type. These terms are used interchangeably in\n+  different Arrow implementations, but we use \"array\" in this\n+  document.\n+* **Slot**: a single logical value in an array of some particular data type\n+* **Buffer** or **Contiguous memory region**: a sequential virtual\n+  address space with a given length. Any byte can be reached via a\n+  single pointer offset less than the region's length.\n+* **Physical Layout type**: The underlying memory layout for an array\n+  without taking into account any value semantics. For example, a\n+  32-bit signed integer array and 32-bit floating point array have the\n+  same layout type.\n+* **Logical type**: An application-facing semantic value type that is\n+  implemented using some physical layout type. For example, Decimal\n+  values are stored as 16 bytes in a fixed-size binary\n+  layout. Similarly, strings can be stored as ``List<1-byte>``. A\n+  timestamp may be stored as 64-bit fixed-size layout.\n+* **Nested** or **parametric type**: a data type whose full structure\n \n Review comment:\n   Hmm, some parametric types (such as timestamps) are not nested. I don't think the parametric nature of a type is very important for understanding, so perhaps drop it here?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T15:20:30.481+0000",
                    "updated": "2019-08-27T15:20:30.481+0000",
                    "started": "2019-08-27T15:20:30.481+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "302057",
                    "issueId": "13214524"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/302058",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202#discussion_r318104863\n \n \n\n ##########\n File path: docs/source/format/Columnar.rst\n ##########\n @@ -0,0 +1,1266 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. _format_columnar:\n+\n+*********************\n+Arrow Columnar Format\n+*********************\n+\n+The \"Arrow Columnar Format\" includes a language-agnostic in-memory\n+data structure specification, metadata serialization, and a protocol\n+for serialization and generic data transport.\n+\n+This document is intended to provide adequate detail to create a new\n+implementation of the columnar format without the aid of an existing\n+implementation. We utilize Google's `Flatbuffers`_ project for\n+metadata serialization, so it will be necessary to refer to the\n+project's `Flatbuffers protocol definition files <FlatbuffersFiles>`_\n+while reading this document.\n+\n+The columnar format has some key features:\n+\n+* Data adjacency for sequential access (scans)\n+* O(1) (constant-time) random access\n+* SIMD and vectorization-friendly\n+* Relocatable without \"pointer swizzling\", allowing for true zero-copy\n+  access in shared memory\n+\n+Some things to keep in mind:\n+\n+* Some data types can be mutated in-place in memory, but others\n+  cannot. The community has made deliberate trade-offs regarding\n+  in-place mutability to provide analytical performance and data\n+  locality guarantees\n+\n+Terminology\n+===========\n+\n+Since different projects have used different words to describe various\n+concepts, here is a small glossary to help disambiguate.\n+\n+* **Array** or **Vector**: a sequence of values with known length all\n+  having the same type. These terms are used interchangeably in\n+  different Arrow implementations, but we use \"array\" in this\n+  document.\n+* **Slot**: a single logical value in an array of some particular data type\n+* **Buffer** or **Contiguous memory region**: a sequential virtual\n+  address space with a given length. Any byte can be reached via a\n+  single pointer offset less than the region's length.\n+* **Physical Layout type**: The underlying memory layout for an array\n+  without taking into account any value semantics. For example, a\n+  32-bit signed integer array and 32-bit floating point array have the\n+  same layout type.\n+* **Logical type**: An application-facing semantic value type that is\n+  implemented using some physical layout type. For example, Decimal\n+  values are stored as 16 bytes in a fixed-size binary\n+  layout. Similarly, strings can be stored as ``List<1-byte>``. A\n+  timestamp may be stored as 64-bit fixed-size layout.\n+* **Nested** or **parametric type**: a data type whose full structure\n+  depends on one or more other child types. Two fully-specified nested\n+  types are equal if and only if their child types are equal. For\n+  example, ``List<U>`` is distinct from ``List<V>`` iff U and V are\n+  different types.\n+* **Parent** and **child arrays**: names to express relationships\n+  between physical value arrays in a nested type structure. For\n+  example, a ``List<T>``-type parent array has a T-type array as its\n+  child (see more on lists below).\n+* **Leaf node** or **leaf**: A primitive value array that may or may\n \n Review comment:\n   \"Primitive\" (array or type) is not defined. Is it the contrary of \"nested\"?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T15:20:31.244+0000",
                    "updated": "2019-08-27T15:20:31.244+0000",
                    "started": "2019-08-27T15:20:31.243+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "302058",
                    "issueId": "13214524"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/302059",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202#discussion_r318106689\n \n \n\n ##########\n File path: docs/source/format/Columnar.rst\n ##########\n @@ -0,0 +1,1266 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. _format_columnar:\n+\n+*********************\n+Arrow Columnar Format\n+*********************\n+\n+The \"Arrow Columnar Format\" includes a language-agnostic in-memory\n+data structure specification, metadata serialization, and a protocol\n+for serialization and generic data transport.\n+\n+This document is intended to provide adequate detail to create a new\n+implementation of the columnar format without the aid of an existing\n+implementation. We utilize Google's `Flatbuffers`_ project for\n+metadata serialization, so it will be necessary to refer to the\n+project's `Flatbuffers protocol definition files <FlatbuffersFiles>`_\n+while reading this document.\n+\n+The columnar format has some key features:\n+\n+* Data adjacency for sequential access (scans)\n+* O(1) (constant-time) random access\n+* SIMD and vectorization-friendly\n+* Relocatable without \"pointer swizzling\", allowing for true zero-copy\n+  access in shared memory\n+\n+Some things to keep in mind:\n+\n+* Some data types can be mutated in-place in memory, but others\n+  cannot. The community has made deliberate trade-offs regarding\n+  in-place mutability to provide analytical performance and data\n+  locality guarantees\n+\n+Terminology\n+===========\n+\n+Since different projects have used different words to describe various\n+concepts, here is a small glossary to help disambiguate.\n+\n+* **Array** or **Vector**: a sequence of values with known length all\n+  having the same type. These terms are used interchangeably in\n+  different Arrow implementations, but we use \"array\" in this\n+  document.\n+* **Slot**: a single logical value in an array of some particular data type\n+* **Buffer** or **Contiguous memory region**: a sequential virtual\n+  address space with a given length. Any byte can be reached via a\n+  single pointer offset less than the region's length.\n+* **Physical Layout type**: The underlying memory layout for an array\n+  without taking into account any value semantics. For example, a\n+  32-bit signed integer array and 32-bit floating point array have the\n+  same layout type.\n+* **Logical type**: An application-facing semantic value type that is\n+  implemented using some physical layout type. For example, Decimal\n+  values are stored as 16 bytes in a fixed-size binary\n+  layout. Similarly, strings can be stored as ``List<1-byte>``. A\n+  timestamp may be stored as 64-bit fixed-size layout.\n+* **Nested** or **parametric type**: a data type whose full structure\n+  depends on one or more other child types. Two fully-specified nested\n+  types are equal if and only if their child types are equal. For\n+  example, ``List<U>`` is distinct from ``List<V>`` iff U and V are\n+  different types.\n+* **Parent** and **child arrays**: names to express relationships\n+  between physical value arrays in a nested type structure. For\n+  example, a ``List<T>``-type parent array has a T-type array as its\n+  child (see more on lists below).\n+* **Leaf node** or **leaf**: A primitive value array that may or may\n+  not be a child array of some array with a nested type.\n+\n+Physical Memory Layout\n+======================\n+\n+Arrays are defined by a few pieces of metadata and data:\n+\n+* A logical data type\n+* A sequence of buffers\n+* A length as a 64-bit signed integer. Implementations are permitted\n+  to be limited to 32-bit lengths, see more on this below\n+* A null count as a 64-bit signed integer\n+* An optional **dictionary**, for dictionary-encoded arrays\n+\n \n Review comment:\n   I think it would be helpful to start by making it clear that the Arrow memory layout specification only applies to array _data_, not metadata. Implementations are free to represent metadata in memory in whichever form is convenient for them. Passing metadata from one implementation to another relies on Flatbuffers-based serialization (part of the Arrow IPC specification).\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T15:20:31.473+0000",
                    "updated": "2019-08-27T15:20:31.473+0000",
                    "started": "2019-08-27T15:20:31.472+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "302059",
                    "issueId": "13214524"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/302060",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202#discussion_r318107946\n \n \n\n ##########\n File path: docs/source/format/Columnar.rst\n ##########\n @@ -0,0 +1,1266 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. _format_columnar:\n+\n+*********************\n+Arrow Columnar Format\n+*********************\n+\n+The \"Arrow Columnar Format\" includes a language-agnostic in-memory\n+data structure specification, metadata serialization, and a protocol\n+for serialization and generic data transport.\n+\n+This document is intended to provide adequate detail to create a new\n+implementation of the columnar format without the aid of an existing\n+implementation. We utilize Google's `Flatbuffers`_ project for\n+metadata serialization, so it will be necessary to refer to the\n+project's `Flatbuffers protocol definition files <FlatbuffersFiles>`_\n+while reading this document.\n+\n+The columnar format has some key features:\n+\n+* Data adjacency for sequential access (scans)\n+* O(1) (constant-time) random access\n+* SIMD and vectorization-friendly\n+* Relocatable without \"pointer swizzling\", allowing for true zero-copy\n+  access in shared memory\n+\n+Some things to keep in mind:\n+\n+* Some data types can be mutated in-place in memory, but others\n+  cannot. The community has made deliberate trade-offs regarding\n+  in-place mutability to provide analytical performance and data\n+  locality guarantees\n+\n+Terminology\n+===========\n+\n+Since different projects have used different words to describe various\n+concepts, here is a small glossary to help disambiguate.\n+\n+* **Array** or **Vector**: a sequence of values with known length all\n+  having the same type. These terms are used interchangeably in\n+  different Arrow implementations, but we use \"array\" in this\n+  document.\n+* **Slot**: a single logical value in an array of some particular data type\n+* **Buffer** or **Contiguous memory region**: a sequential virtual\n+  address space with a given length. Any byte can be reached via a\n+  single pointer offset less than the region's length.\n+* **Physical Layout type**: The underlying memory layout for an array\n+  without taking into account any value semantics. For example, a\n+  32-bit signed integer array and 32-bit floating point array have the\n+  same layout type.\n+* **Logical type**: An application-facing semantic value type that is\n+  implemented using some physical layout type. For example, Decimal\n+  values are stored as 16 bytes in a fixed-size binary\n+  layout. Similarly, strings can be stored as ``List<1-byte>``. A\n+  timestamp may be stored as 64-bit fixed-size layout.\n+* **Nested** or **parametric type**: a data type whose full structure\n+  depends on one or more other child types. Two fully-specified nested\n+  types are equal if and only if their child types are equal. For\n+  example, ``List<U>`` is distinct from ``List<V>`` iff U and V are\n+  different types.\n+* **Parent** and **child arrays**: names to express relationships\n+  between physical value arrays in a nested type structure. For\n+  example, a ``List<T>``-type parent array has a T-type array as its\n+  child (see more on lists below).\n+* **Leaf node** or **leaf**: A primitive value array that may or may\n+  not be a child array of some array with a nested type.\n+\n+Physical Memory Layout\n+======================\n+\n+Arrays are defined by a few pieces of metadata and data:\n+\n+* A logical data type\n+* A sequence of buffers\n+* A length as a 64-bit signed integer. Implementations are permitted\n+  to be limited to 32-bit lengths, see more on this below\n+* A null count as a 64-bit signed integer\n+* An optional **dictionary**, for dictionary-encoded arrays\n+\n+Nested arrays additionally have a sequence of one or more sets of\n+these items, called the **child arrays**.\n+\n+Each logical data type has a well-defined physical layout. Here are\n+the different physical layouts defined by Arrow:\n+\n+* **Primitive (fixed-size)**: a sequence of values each having the\n+  same byte or bit width\n+* **Variable-size Binary**: a sequence of values each having a variable\n+  byte length. Two variants of this layout are supported using 32-bit\n+  and 64-bit length encoding.\n+* **Fixed-size List**: a nested layout each each value has the same\n+  number of elements taken from a child data type.\n+* **Variable-size List**: a nested layout type where each value is a\n+  variable-length sequence of values taken from a child data type. Two\n+  variants of this layout are supported using 32-bit and 64-bit length\n+  encoding.\n+* **Struct**: a nested layout type consisting of a collection of child\n+  **fields** each having the same length\n \n Review comment:\n   ... but possibly different types.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T15:20:31.695+0000",
                    "updated": "2019-08-27T15:20:31.695+0000",
                    "started": "2019-08-27T15:20:31.695+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "302060",
                    "issueId": "13214524"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/302061",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202#discussion_r318108157\n \n \n\n ##########\n File path: docs/source/format/Columnar.rst\n ##########\n @@ -0,0 +1,1266 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. _format_columnar:\n+\n+*********************\n+Arrow Columnar Format\n+*********************\n+\n+The \"Arrow Columnar Format\" includes a language-agnostic in-memory\n+data structure specification, metadata serialization, and a protocol\n+for serialization and generic data transport.\n+\n+This document is intended to provide adequate detail to create a new\n+implementation of the columnar format without the aid of an existing\n+implementation. We utilize Google's `Flatbuffers`_ project for\n+metadata serialization, so it will be necessary to refer to the\n+project's `Flatbuffers protocol definition files <FlatbuffersFiles>`_\n+while reading this document.\n+\n+The columnar format has some key features:\n+\n+* Data adjacency for sequential access (scans)\n+* O(1) (constant-time) random access\n+* SIMD and vectorization-friendly\n+* Relocatable without \"pointer swizzling\", allowing for true zero-copy\n+  access in shared memory\n+\n+Some things to keep in mind:\n+\n+* Some data types can be mutated in-place in memory, but others\n+  cannot. The community has made deliberate trade-offs regarding\n+  in-place mutability to provide analytical performance and data\n+  locality guarantees\n+\n+Terminology\n+===========\n+\n+Since different projects have used different words to describe various\n+concepts, here is a small glossary to help disambiguate.\n+\n+* **Array** or **Vector**: a sequence of values with known length all\n+  having the same type. These terms are used interchangeably in\n+  different Arrow implementations, but we use \"array\" in this\n+  document.\n+* **Slot**: a single logical value in an array of some particular data type\n+* **Buffer** or **Contiguous memory region**: a sequential virtual\n+  address space with a given length. Any byte can be reached via a\n+  single pointer offset less than the region's length.\n+* **Physical Layout type**: The underlying memory layout for an array\n+  without taking into account any value semantics. For example, a\n+  32-bit signed integer array and 32-bit floating point array have the\n+  same layout type.\n+* **Logical type**: An application-facing semantic value type that is\n+  implemented using some physical layout type. For example, Decimal\n+  values are stored as 16 bytes in a fixed-size binary\n+  layout. Similarly, strings can be stored as ``List<1-byte>``. A\n+  timestamp may be stored as 64-bit fixed-size layout.\n+* **Nested** or **parametric type**: a data type whose full structure\n+  depends on one or more other child types. Two fully-specified nested\n+  types are equal if and only if their child types are equal. For\n+  example, ``List<U>`` is distinct from ``List<V>`` iff U and V are\n+  different types.\n+* **Parent** and **child arrays**: names to express relationships\n+  between physical value arrays in a nested type structure. For\n+  example, a ``List<T>``-type parent array has a T-type array as its\n+  child (see more on lists below).\n+* **Leaf node** or **leaf**: A primitive value array that may or may\n+  not be a child array of some array with a nested type.\n+\n+Physical Memory Layout\n+======================\n+\n+Arrays are defined by a few pieces of metadata and data:\n+\n+* A logical data type\n+* A sequence of buffers\n+* A length as a 64-bit signed integer. Implementations are permitted\n+  to be limited to 32-bit lengths, see more on this below\n+* A null count as a 64-bit signed integer\n+* An optional **dictionary**, for dictionary-encoded arrays\n+\n+Nested arrays additionally have a sequence of one or more sets of\n+these items, called the **child arrays**.\n+\n+Each logical data type has a well-defined physical layout. Here are\n+the different physical layouts defined by Arrow:\n+\n+* **Primitive (fixed-size)**: a sequence of values each having the\n+  same byte or bit width\n+* **Variable-size Binary**: a sequence of values each having a variable\n+  byte length. Two variants of this layout are supported using 32-bit\n+  and 64-bit length encoding.\n+* **Fixed-size List**: a nested layout each each value has the same\n+  number of elements taken from a child data type.\n+* **Variable-size List**: a nested layout type where each value is a\n+  variable-length sequence of values taken from a child data type. Two\n+  variants of this layout are supported using 32-bit and 64-bit length\n+  encoding.\n+* **Struct**: a nested layout type consisting of a collection of child\n+  **fields** each having the same length\n+* **Sparse** and **Dense Union**: a nested layout type representing a\n+  sequence of values, each of which can have type chosen from a\n+  collection of child array types.\n+* **Null**: a sequence of all null values, having null logical type\n+\n+Buffer Alignment and Padding\n+----------------------------\n+\n+Implementations are recommended allocate memory on aligned (8- or\n \n Review comment:\n   \"recommended to\"?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T15:20:31.715+0000",
                    "updated": "2019-08-27T15:20:31.715+0000",
                    "started": "2019-08-27T15:20:31.715+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "302061",
                    "issueId": "13214524"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/302062",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202#discussion_r318110783\n \n \n\n ##########\n File path: docs/source/format/Columnar.rst\n ##########\n @@ -0,0 +1,1266 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. _format_columnar:\n+\n+*********************\n+Arrow Columnar Format\n+*********************\n+\n+The \"Arrow Columnar Format\" includes a language-agnostic in-memory\n+data structure specification, metadata serialization, and a protocol\n+for serialization and generic data transport.\n+\n+This document is intended to provide adequate detail to create a new\n+implementation of the columnar format without the aid of an existing\n+implementation. We utilize Google's `Flatbuffers`_ project for\n+metadata serialization, so it will be necessary to refer to the\n+project's `Flatbuffers protocol definition files <FlatbuffersFiles>`_\n+while reading this document.\n+\n+The columnar format has some key features:\n+\n+* Data adjacency for sequential access (scans)\n+* O(1) (constant-time) random access\n+* SIMD and vectorization-friendly\n+* Relocatable without \"pointer swizzling\", allowing for true zero-copy\n+  access in shared memory\n+\n+Some things to keep in mind:\n+\n+* Some data types can be mutated in-place in memory, but others\n+  cannot. The community has made deliberate trade-offs regarding\n+  in-place mutability to provide analytical performance and data\n+  locality guarantees\n+\n+Terminology\n+===========\n+\n+Since different projects have used different words to describe various\n+concepts, here is a small glossary to help disambiguate.\n+\n+* **Array** or **Vector**: a sequence of values with known length all\n+  having the same type. These terms are used interchangeably in\n+  different Arrow implementations, but we use \"array\" in this\n+  document.\n+* **Slot**: a single logical value in an array of some particular data type\n+* **Buffer** or **Contiguous memory region**: a sequential virtual\n+  address space with a given length. Any byte can be reached via a\n+  single pointer offset less than the region's length.\n+* **Physical Layout type**: The underlying memory layout for an array\n+  without taking into account any value semantics. For example, a\n+  32-bit signed integer array and 32-bit floating point array have the\n+  same layout type.\n+* **Logical type**: An application-facing semantic value type that is\n+  implemented using some physical layout type. For example, Decimal\n+  values are stored as 16 bytes in a fixed-size binary\n+  layout. Similarly, strings can be stored as ``List<1-byte>``. A\n+  timestamp may be stored as 64-bit fixed-size layout.\n+* **Nested** or **parametric type**: a data type whose full structure\n+  depends on one or more other child types. Two fully-specified nested\n+  types are equal if and only if their child types are equal. For\n+  example, ``List<U>`` is distinct from ``List<V>`` iff U and V are\n+  different types.\n+* **Parent** and **child arrays**: names to express relationships\n+  between physical value arrays in a nested type structure. For\n+  example, a ``List<T>``-type parent array has a T-type array as its\n+  child (see more on lists below).\n+* **Leaf node** or **leaf**: A primitive value array that may or may\n+  not be a child array of some array with a nested type.\n+\n+Physical Memory Layout\n+======================\n+\n+Arrays are defined by a few pieces of metadata and data:\n+\n+* A logical data type\n+* A sequence of buffers\n+* A length as a 64-bit signed integer. Implementations are permitted\n+  to be limited to 32-bit lengths, see more on this below\n+* A null count as a 64-bit signed integer\n+* An optional **dictionary**, for dictionary-encoded arrays\n+\n+Nested arrays additionally have a sequence of one or more sets of\n+these items, called the **child arrays**.\n+\n+Each logical data type has a well-defined physical layout. Here are\n+the different physical layouts defined by Arrow:\n+\n+* **Primitive (fixed-size)**: a sequence of values each having the\n+  same byte or bit width\n+* **Variable-size Binary**: a sequence of values each having a variable\n+  byte length. Two variants of this layout are supported using 32-bit\n+  and 64-bit length encoding.\n+* **Fixed-size List**: a nested layout each each value has the same\n+  number of elements taken from a child data type.\n+* **Variable-size List**: a nested layout type where each value is a\n+  variable-length sequence of values taken from a child data type. Two\n+  variants of this layout are supported using 32-bit and 64-bit length\n+  encoding.\n+* **Struct**: a nested layout type consisting of a collection of child\n+  **fields** each having the same length\n+* **Sparse** and **Dense Union**: a nested layout type representing a\n+  sequence of values, each of which can have type chosen from a\n+  collection of child array types.\n+* **Null**: a sequence of all null values, having null logical type\n+\n+Buffer Alignment and Padding\n+----------------------------\n+\n+Implementations are recommended allocate memory on aligned (8- or\n+64-byte boundaries) and pad (overallocate) to a length that is a\n+multiple of 8 or 64 bytes. When serializing Arrow data for\n+interprocess communication, these alignment and padding requirements\n+are enforced. If possible, we suggest that you prefer using 64-byte\n+alignment and padding. Unless otherwise noted, padded bytes do not\n+need to have a specific value.\n+\n+The alignment requirement follows best practices for optimized memory\n+access:\n+\n+* Elements in numeric arrays will be guaranteed to be retrieved via aligned access.\n+* On some architectures alignment can help limit partially used cache lines.\n+\n+The recommendation for 64 byte alignment comes from the `Intel\n+performance guide`_ that recommends alignment of memory to match SIMD\n+register width.  The specific padding length was chosen because it\n+matches the largest known SIMD instruction registers available as of\n+April 2016 (Intel AVX-512).\n \n Review comment:\n   ARM may not agree (https://www.linleygroup.com/mpr/article.php?id=11753). Though I don't think they have implemented the maximum width in hardware yet :-)\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T15:20:31.973+0000",
                    "updated": "2019-08-27T15:20:31.973+0000",
                    "started": "2019-08-27T15:20:31.972+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "302062",
                    "issueId": "13214524"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/302063",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202#discussion_r318114786\n \n \n\n ##########\n File path: docs/source/format/Columnar.rst\n ##########\n @@ -0,0 +1,1266 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. _format_columnar:\n+\n+*********************\n+Arrow Columnar Format\n+*********************\n+\n+The \"Arrow Columnar Format\" includes a language-agnostic in-memory\n+data structure specification, metadata serialization, and a protocol\n+for serialization and generic data transport.\n+\n+This document is intended to provide adequate detail to create a new\n+implementation of the columnar format without the aid of an existing\n+implementation. We utilize Google's `Flatbuffers`_ project for\n+metadata serialization, so it will be necessary to refer to the\n+project's `Flatbuffers protocol definition files <FlatbuffersFiles>`_\n+while reading this document.\n+\n+The columnar format has some key features:\n+\n+* Data adjacency for sequential access (scans)\n+* O(1) (constant-time) random access\n+* SIMD and vectorization-friendly\n+* Relocatable without \"pointer swizzling\", allowing for true zero-copy\n+  access in shared memory\n+\n+Some things to keep in mind:\n+\n+* Some data types can be mutated in-place in memory, but others\n+  cannot. The community has made deliberate trade-offs regarding\n+  in-place mutability to provide analytical performance and data\n+  locality guarantees\n+\n+Terminology\n+===========\n+\n+Since different projects have used different words to describe various\n+concepts, here is a small glossary to help disambiguate.\n+\n+* **Array** or **Vector**: a sequence of values with known length all\n+  having the same type. These terms are used interchangeably in\n+  different Arrow implementations, but we use \"array\" in this\n+  document.\n+* **Slot**: a single logical value in an array of some particular data type\n+* **Buffer** or **Contiguous memory region**: a sequential virtual\n+  address space with a given length. Any byte can be reached via a\n+  single pointer offset less than the region's length.\n+* **Physical Layout type**: The underlying memory layout for an array\n+  without taking into account any value semantics. For example, a\n+  32-bit signed integer array and 32-bit floating point array have the\n+  same layout type.\n+* **Logical type**: An application-facing semantic value type that is\n+  implemented using some physical layout type. For example, Decimal\n+  values are stored as 16 bytes in a fixed-size binary\n+  layout. Similarly, strings can be stored as ``List<1-byte>``. A\n+  timestamp may be stored as 64-bit fixed-size layout.\n+* **Nested** or **parametric type**: a data type whose full structure\n+  depends on one or more other child types. Two fully-specified nested\n+  types are equal if and only if their child types are equal. For\n+  example, ``List<U>`` is distinct from ``List<V>`` iff U and V are\n+  different types.\n+* **Parent** and **child arrays**: names to express relationships\n+  between physical value arrays in a nested type structure. For\n+  example, a ``List<T>``-type parent array has a T-type array as its\n+  child (see more on lists below).\n+* **Leaf node** or **leaf**: A primitive value array that may or may\n+  not be a child array of some array with a nested type.\n+\n+Physical Memory Layout\n+======================\n+\n+Arrays are defined by a few pieces of metadata and data:\n+\n+* A logical data type\n+* A sequence of buffers\n+* A length as a 64-bit signed integer. Implementations are permitted\n+  to be limited to 32-bit lengths, see more on this below\n+* A null count as a 64-bit signed integer\n+* An optional **dictionary**, for dictionary-encoded arrays\n+\n+Nested arrays additionally have a sequence of one or more sets of\n+these items, called the **child arrays**.\n+\n+Each logical data type has a well-defined physical layout. Here are\n+the different physical layouts defined by Arrow:\n+\n+* **Primitive (fixed-size)**: a sequence of values each having the\n+  same byte or bit width\n+* **Variable-size Binary**: a sequence of values each having a variable\n+  byte length. Two variants of this layout are supported using 32-bit\n+  and 64-bit length encoding.\n+* **Fixed-size List**: a nested layout each each value has the same\n+  number of elements taken from a child data type.\n+* **Variable-size List**: a nested layout type where each value is a\n+  variable-length sequence of values taken from a child data type. Two\n+  variants of this layout are supported using 32-bit and 64-bit length\n+  encoding.\n+* **Struct**: a nested layout type consisting of a collection of child\n+  **fields** each having the same length\n+* **Sparse** and **Dense Union**: a nested layout type representing a\n+  sequence of values, each of which can have type chosen from a\n+  collection of child array types.\n+* **Null**: a sequence of all null values, having null logical type\n+\n+Buffer Alignment and Padding\n+----------------------------\n+\n+Implementations are recommended allocate memory on aligned (8- or\n+64-byte boundaries) and pad (overallocate) to a length that is a\n+multiple of 8 or 64 bytes. When serializing Arrow data for\n+interprocess communication, these alignment and padding requirements\n+are enforced. If possible, we suggest that you prefer using 64-byte\n+alignment and padding. Unless otherwise noted, padded bytes do not\n+need to have a specific value.\n+\n+The alignment requirement follows best practices for optimized memory\n+access:\n+\n+* Elements in numeric arrays will be guaranteed to be retrieved via aligned access.\n+* On some architectures alignment can help limit partially used cache lines.\n+\n+The recommendation for 64 byte alignment comes from the `Intel\n+performance guide`_ that recommends alignment of memory to match SIMD\n+register width.  The specific padding length was chosen because it\n+matches the largest known SIMD instruction registers available as of\n+April 2016 (Intel AVX-512).\n+\n+The recommended padding of 64 bytes allows for using `SIMD`_\n+instructions consistently in loops without additional conditional\n+checks.  This should allow for simpler, efficient and CPU\n+cache-friendly code.  In other words, we can load the entire 64-byte\n+buffer into a 512-bit wide SIMD register and get data-level\n+parallelism on all the columnar values packed into the 64-byte\n+buffer. Guaranteed padding can also allow certain compilers to\n+generate more optimized code directly (e.g. One can safely use Intel's\n+``-qopt-assume-safe-padding``).\n+\n+Byte Order (`Endianness`_)\n+---------------------------\n+\n+The Arrow format is little endian by default.\n+\n+Serialized Schema metadata has an endianness field indicating\n+endianness of RecordBatches. Typically this is the endianness of the\n+system where the RecordBatch was generated. The main use case is\n+exchanging RecordBatches between systems with the same Endianness.  At\n+first we will return an error when trying to read a Schema with an\n+endianness that does not match the underlying system. The reference\n+implementation is focused on Little Endian and provides tests for\n+it. Eventually we may provide automatic conversion via byte swapping.\n+\n+Array lengths\n+-------------\n+\n+Array lengths are represented in the Arrow metadata as a 64-bit signed\n+integer. An implementation of Arrow is considered valid even if it only\n+supports lengths up to the maximum 32-bit signed integer, though. If using\n+Arrow in a multi-language environment, we recommend limiting lengths to\n+2 :sup:`31` - 1 elements or less. Larger data sets can be represented using\n+multiple array chunks.\n+\n+Null count\n+----------\n+\n+The number of null value slots is a property of the physical array and\n+considered part of the data structure. The null count is represented\n+in the Arrow metadata as a 64-bit signed integer, as it may be as\n+large as the array length.\n+\n+Validity bitmaps\n+----------------\n+\n+Any type can have null value slots, whether primitive or nested type.\n+\n+An array with nulls must have a contiguous memory buffer, known as the\n+validity (or \"null\") bitmap, large enough to have at least 1 bit for\n+each array slot.\n+\n+Whether any array slot is valid (non-null) is encoded in the respective bits of\n+this bitmap. A 1 (set bit) for index ``j`` indicates that the value is not null,\n+while a 0 (bit not set) indicates that it is null. Bitmaps are to be\n+initialized to be all unset at allocation time (this includes padding).::\n+\n+    is_valid[j] -> bitmap[j / 8] & (1 << (j % 8))\n+\n+We use `least-significant bit (LSB) numbering`_ (also known as\n+bit-endianness). This means that within a group of 8 bits, we read\n+right-to-left: ::\n+\n+    values = [0, 1, null, 2, null, 3]\n+\n+    bitmap\n+    j mod 8   7  6  5  4  3  2  1  0\n+              0  0  1  0  1  0  1  1\n+\n+Arrays having a 0 null count may choose to not allocate the null\n+bitmap. Implementations may choose to always allocate one anyway as a matter of\n+convenience, but this should be noted when memory is being shared.\n+\n+Nested type arrays have their own null bitmap and null count regardless of\n+the null count and null bits of their child arrays.\n+\n+Primitive\n+---------\n+\n+A primitive value array represents a fixed-length array of values each having\n+the same physical slot width typically measured in bytes, though the spec also\n+provides for bit-packed types (e.g. boolean values encoded in bits).\n+\n+Internally, the array contains a contiguous memory buffer whose total size is\n+equal to the slot width multiplied by the array length. For bit-packed types,\n \n Review comment:\n   equal or larger, no?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T15:20:31.996+0000",
                    "updated": "2019-08-27T15:20:31.996+0000",
                    "started": "2019-08-27T15:20:31.996+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "302063",
                    "issueId": "13214524"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/302064",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202#discussion_r318113356\n \n \n\n ##########\n File path: docs/source/format/Columnar.rst\n ##########\n @@ -0,0 +1,1266 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. _format_columnar:\n+\n+*********************\n+Arrow Columnar Format\n+*********************\n+\n+The \"Arrow Columnar Format\" includes a language-agnostic in-memory\n+data structure specification, metadata serialization, and a protocol\n+for serialization and generic data transport.\n+\n+This document is intended to provide adequate detail to create a new\n+implementation of the columnar format without the aid of an existing\n+implementation. We utilize Google's `Flatbuffers`_ project for\n+metadata serialization, so it will be necessary to refer to the\n+project's `Flatbuffers protocol definition files <FlatbuffersFiles>`_\n+while reading this document.\n+\n+The columnar format has some key features:\n+\n+* Data adjacency for sequential access (scans)\n+* O(1) (constant-time) random access\n+* SIMD and vectorization-friendly\n+* Relocatable without \"pointer swizzling\", allowing for true zero-copy\n+  access in shared memory\n+\n+Some things to keep in mind:\n+\n+* Some data types can be mutated in-place in memory, but others\n+  cannot. The community has made deliberate trade-offs regarding\n+  in-place mutability to provide analytical performance and data\n+  locality guarantees\n+\n+Terminology\n+===========\n+\n+Since different projects have used different words to describe various\n+concepts, here is a small glossary to help disambiguate.\n+\n+* **Array** or **Vector**: a sequence of values with known length all\n+  having the same type. These terms are used interchangeably in\n+  different Arrow implementations, but we use \"array\" in this\n+  document.\n+* **Slot**: a single logical value in an array of some particular data type\n+* **Buffer** or **Contiguous memory region**: a sequential virtual\n+  address space with a given length. Any byte can be reached via a\n+  single pointer offset less than the region's length.\n+* **Physical Layout type**: The underlying memory layout for an array\n+  without taking into account any value semantics. For example, a\n+  32-bit signed integer array and 32-bit floating point array have the\n+  same layout type.\n+* **Logical type**: An application-facing semantic value type that is\n+  implemented using some physical layout type. For example, Decimal\n+  values are stored as 16 bytes in a fixed-size binary\n+  layout. Similarly, strings can be stored as ``List<1-byte>``. A\n+  timestamp may be stored as 64-bit fixed-size layout.\n+* **Nested** or **parametric type**: a data type whose full structure\n+  depends on one or more other child types. Two fully-specified nested\n+  types are equal if and only if their child types are equal. For\n+  example, ``List<U>`` is distinct from ``List<V>`` iff U and V are\n+  different types.\n+* **Parent** and **child arrays**: names to express relationships\n+  between physical value arrays in a nested type structure. For\n+  example, a ``List<T>``-type parent array has a T-type array as its\n+  child (see more on lists below).\n+* **Leaf node** or **leaf**: A primitive value array that may or may\n+  not be a child array of some array with a nested type.\n+\n+Physical Memory Layout\n+======================\n+\n+Arrays are defined by a few pieces of metadata and data:\n+\n+* A logical data type\n+* A sequence of buffers\n+* A length as a 64-bit signed integer. Implementations are permitted\n+  to be limited to 32-bit lengths, see more on this below\n+* A null count as a 64-bit signed integer\n+* An optional **dictionary**, for dictionary-encoded arrays\n+\n+Nested arrays additionally have a sequence of one or more sets of\n+these items, called the **child arrays**.\n+\n+Each logical data type has a well-defined physical layout. Here are\n+the different physical layouts defined by Arrow:\n+\n+* **Primitive (fixed-size)**: a sequence of values each having the\n+  same byte or bit width\n+* **Variable-size Binary**: a sequence of values each having a variable\n+  byte length. Two variants of this layout are supported using 32-bit\n+  and 64-bit length encoding.\n+* **Fixed-size List**: a nested layout each each value has the same\n+  number of elements taken from a child data type.\n+* **Variable-size List**: a nested layout type where each value is a\n \n Review comment:\n   Seems like sometimes we're using \"layout\" and sometimes \"layout type\". It would be nice to be consistent. Varying terminology often impedes understanding.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T15:20:32.127+0000",
                    "updated": "2019-08-27T15:20:32.127+0000",
                    "started": "2019-08-27T15:20:32.127+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "302064",
                    "issueId": "13214524"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/302065",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202#discussion_r318117152\n \n \n\n ##########\n File path: docs/source/format/Columnar.rst\n ##########\n @@ -0,0 +1,1266 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. _format_columnar:\n+\n+*********************\n+Arrow Columnar Format\n+*********************\n+\n+The \"Arrow Columnar Format\" includes a language-agnostic in-memory\n+data structure specification, metadata serialization, and a protocol\n+for serialization and generic data transport.\n+\n+This document is intended to provide adequate detail to create a new\n+implementation of the columnar format without the aid of an existing\n+implementation. We utilize Google's `Flatbuffers`_ project for\n+metadata serialization, so it will be necessary to refer to the\n+project's `Flatbuffers protocol definition files <FlatbuffersFiles>`_\n+while reading this document.\n+\n+The columnar format has some key features:\n+\n+* Data adjacency for sequential access (scans)\n+* O(1) (constant-time) random access\n+* SIMD and vectorization-friendly\n+* Relocatable without \"pointer swizzling\", allowing for true zero-copy\n+  access in shared memory\n+\n+Some things to keep in mind:\n+\n+* Some data types can be mutated in-place in memory, but others\n+  cannot. The community has made deliberate trade-offs regarding\n+  in-place mutability to provide analytical performance and data\n+  locality guarantees\n+\n+Terminology\n+===========\n+\n+Since different projects have used different words to describe various\n+concepts, here is a small glossary to help disambiguate.\n+\n+* **Array** or **Vector**: a sequence of values with known length all\n+  having the same type. These terms are used interchangeably in\n+  different Arrow implementations, but we use \"array\" in this\n+  document.\n+* **Slot**: a single logical value in an array of some particular data type\n+* **Buffer** or **Contiguous memory region**: a sequential virtual\n+  address space with a given length. Any byte can be reached via a\n+  single pointer offset less than the region's length.\n+* **Physical Layout type**: The underlying memory layout for an array\n+  without taking into account any value semantics. For example, a\n+  32-bit signed integer array and 32-bit floating point array have the\n+  same layout type.\n+* **Logical type**: An application-facing semantic value type that is\n+  implemented using some physical layout type. For example, Decimal\n+  values are stored as 16 bytes in a fixed-size binary\n+  layout. Similarly, strings can be stored as ``List<1-byte>``. A\n+  timestamp may be stored as 64-bit fixed-size layout.\n+* **Nested** or **parametric type**: a data type whose full structure\n+  depends on one or more other child types. Two fully-specified nested\n+  types are equal if and only if their child types are equal. For\n+  example, ``List<U>`` is distinct from ``List<V>`` iff U and V are\n+  different types.\n+* **Parent** and **child arrays**: names to express relationships\n+  between physical value arrays in a nested type structure. For\n+  example, a ``List<T>``-type parent array has a T-type array as its\n+  child (see more on lists below).\n+* **Leaf node** or **leaf**: A primitive value array that may or may\n+  not be a child array of some array with a nested type.\n+\n+Physical Memory Layout\n+======================\n+\n+Arrays are defined by a few pieces of metadata and data:\n+\n+* A logical data type\n+* A sequence of buffers\n+* A length as a 64-bit signed integer. Implementations are permitted\n+  to be limited to 32-bit lengths, see more on this below\n+* A null count as a 64-bit signed integer\n+* An optional **dictionary**, for dictionary-encoded arrays\n+\n+Nested arrays additionally have a sequence of one or more sets of\n+these items, called the **child arrays**.\n+\n+Each logical data type has a well-defined physical layout. Here are\n+the different physical layouts defined by Arrow:\n+\n+* **Primitive (fixed-size)**: a sequence of values each having the\n+  same byte or bit width\n+* **Variable-size Binary**: a sequence of values each having a variable\n+  byte length. Two variants of this layout are supported using 32-bit\n+  and 64-bit length encoding.\n+* **Fixed-size List**: a nested layout each each value has the same\n+  number of elements taken from a child data type.\n+* **Variable-size List**: a nested layout type where each value is a\n+  variable-length sequence of values taken from a child data type. Two\n+  variants of this layout are supported using 32-bit and 64-bit length\n+  encoding.\n+* **Struct**: a nested layout type consisting of a collection of child\n+  **fields** each having the same length\n+* **Sparse** and **Dense Union**: a nested layout type representing a\n+  sequence of values, each of which can have type chosen from a\n+  collection of child array types.\n+* **Null**: a sequence of all null values, having null logical type\n+\n+Buffer Alignment and Padding\n+----------------------------\n+\n+Implementations are recommended allocate memory on aligned (8- or\n+64-byte boundaries) and pad (overallocate) to a length that is a\n+multiple of 8 or 64 bytes. When serializing Arrow data for\n+interprocess communication, these alignment and padding requirements\n+are enforced. If possible, we suggest that you prefer using 64-byte\n+alignment and padding. Unless otherwise noted, padded bytes do not\n+need to have a specific value.\n+\n+The alignment requirement follows best practices for optimized memory\n+access:\n+\n+* Elements in numeric arrays will be guaranteed to be retrieved via aligned access.\n+* On some architectures alignment can help limit partially used cache lines.\n+\n+The recommendation for 64 byte alignment comes from the `Intel\n+performance guide`_ that recommends alignment of memory to match SIMD\n+register width.  The specific padding length was chosen because it\n+matches the largest known SIMD instruction registers available as of\n+April 2016 (Intel AVX-512).\n+\n+The recommended padding of 64 bytes allows for using `SIMD`_\n+instructions consistently in loops without additional conditional\n+checks.  This should allow for simpler, efficient and CPU\n+cache-friendly code.  In other words, we can load the entire 64-byte\n+buffer into a 512-bit wide SIMD register and get data-level\n+parallelism on all the columnar values packed into the 64-byte\n+buffer. Guaranteed padding can also allow certain compilers to\n+generate more optimized code directly (e.g. One can safely use Intel's\n+``-qopt-assume-safe-padding``).\n+\n+Byte Order (`Endianness`_)\n+---------------------------\n+\n+The Arrow format is little endian by default.\n+\n+Serialized Schema metadata has an endianness field indicating\n+endianness of RecordBatches. Typically this is the endianness of the\n+system where the RecordBatch was generated. The main use case is\n+exchanging RecordBatches between systems with the same Endianness.  At\n+first we will return an error when trying to read a Schema with an\n+endianness that does not match the underlying system. The reference\n+implementation is focused on Little Endian and provides tests for\n+it. Eventually we may provide automatic conversion via byte swapping.\n+\n+Array lengths\n+-------------\n+\n+Array lengths are represented in the Arrow metadata as a 64-bit signed\n+integer. An implementation of Arrow is considered valid even if it only\n+supports lengths up to the maximum 32-bit signed integer, though. If using\n+Arrow in a multi-language environment, we recommend limiting lengths to\n+2 :sup:`31` - 1 elements or less. Larger data sets can be represented using\n+multiple array chunks.\n+\n+Null count\n+----------\n+\n+The number of null value slots is a property of the physical array and\n+considered part of the data structure. The null count is represented\n+in the Arrow metadata as a 64-bit signed integer, as it may be as\n+large as the array length.\n+\n+Validity bitmaps\n+----------------\n+\n+Any type can have null value slots, whether primitive or nested type.\n+\n+An array with nulls must have a contiguous memory buffer, known as the\n+validity (or \"null\") bitmap, large enough to have at least 1 bit for\n+each array slot.\n+\n+Whether any array slot is valid (non-null) is encoded in the respective bits of\n+this bitmap. A 1 (set bit) for index ``j`` indicates that the value is not null,\n+while a 0 (bit not set) indicates that it is null. Bitmaps are to be\n+initialized to be all unset at allocation time (this includes padding).::\n+\n+    is_valid[j] -> bitmap[j / 8] & (1 << (j % 8))\n+\n+We use `least-significant bit (LSB) numbering`_ (also known as\n+bit-endianness). This means that within a group of 8 bits, we read\n+right-to-left: ::\n+\n+    values = [0, 1, null, 2, null, 3]\n+\n+    bitmap\n+    j mod 8   7  6  5  4  3  2  1  0\n+              0  0  1  0  1  0  1  1\n+\n+Arrays having a 0 null count may choose to not allocate the null\n+bitmap. Implementations may choose to always allocate one anyway as a matter of\n+convenience, but this should be noted when memory is being shared.\n+\n+Nested type arrays have their own null bitmap and null count regardless of\n+the null count and null bits of their child arrays.\n+\n+Primitive\n+---------\n+\n+A primitive value array represents a fixed-length array of values each having\n+the same physical slot width typically measured in bytes, though the spec also\n+provides for bit-packed types (e.g. boolean values encoded in bits).\n+\n+Internally, the array contains a contiguous memory buffer whose total size is\n+equal to the slot width multiplied by the array length. For bit-packed types,\n+the size is rounded up to the nearest byte.\n+\n+The associated null bitmap is contiguously allocated (as described above) but\n+does not need to be adjacent in memory to the values buffer.\n+\n+**Example Layout: Int32 Array**\n+\n+For example a primitive array of int32s: ::\n+\n+    [1, null, 2, 4, 8]\n+\n+Would look like: ::\n+\n+    * Length: 5, Null count: 1\n+    * Null bitmap buffer:\n+\n+      |Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |-------------------------|-----------------------|\n+      | 00011101                | 0 (padding)           |\n+\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | unspecified | 2           | 4           | 8           | unspecified |\n+\n+**Example Layout: Non-null int32 Array**\n+\n+``[1, 2, 3, 4, 8]`` has two possible layouts: ::\n+\n+    * Length: 5, Null count: 0\n+    * Null bitmap buffer:\n+\n+      | Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |--------------------------|-----------------------|\n+      | 00011111                 | 0 (padding)           |\n+\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | bytes 12-15 | bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | 2           | 3           | 4           | 8           | unspecified |\n+\n+or with the bitmap elided: ::\n+\n+    * Length 5, Null count: 0\n+    * Null bitmap buffer: Not required\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | bytes 12-15 | bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | 2           | 3           | 4           | 8           | unspecified |\n+\n+Variable-size\n+-------------\n+\n+Each value in this layout type consists of 0 or more bytes. While\n+primitive arrays have a single values buffer, variable-size binary\n+have an **offsets** buffer and **data** buffer\n+\n+The offsets buffer contains `length + 1` signed integers (either\n+32-bit or 64-bit), which encode the start position of each element in\n \n Review comment:\n   \"either 32-bit or 64-bit, depending on the type\" perhaps? (to not give the illusion that offsets themselves are variable-sized)\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T15:20:32.329+0000",
                    "updated": "2019-08-27T15:20:32.329+0000",
                    "started": "2019-08-27T15:20:32.329+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "302065",
                    "issueId": "13214524"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/302066",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202#discussion_r318114515\n \n \n\n ##########\n File path: docs/source/format/Columnar.rst\n ##########\n @@ -0,0 +1,1266 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. _format_columnar:\n+\n+*********************\n+Arrow Columnar Format\n+*********************\n+\n+The \"Arrow Columnar Format\" includes a language-agnostic in-memory\n+data structure specification, metadata serialization, and a protocol\n+for serialization and generic data transport.\n+\n+This document is intended to provide adequate detail to create a new\n+implementation of the columnar format without the aid of an existing\n+implementation. We utilize Google's `Flatbuffers`_ project for\n+metadata serialization, so it will be necessary to refer to the\n+project's `Flatbuffers protocol definition files <FlatbuffersFiles>`_\n+while reading this document.\n+\n+The columnar format has some key features:\n+\n+* Data adjacency for sequential access (scans)\n+* O(1) (constant-time) random access\n+* SIMD and vectorization-friendly\n+* Relocatable without \"pointer swizzling\", allowing for true zero-copy\n+  access in shared memory\n+\n+Some things to keep in mind:\n+\n+* Some data types can be mutated in-place in memory, but others\n+  cannot. The community has made deliberate trade-offs regarding\n+  in-place mutability to provide analytical performance and data\n+  locality guarantees\n+\n+Terminology\n+===========\n+\n+Since different projects have used different words to describe various\n+concepts, here is a small glossary to help disambiguate.\n+\n+* **Array** or **Vector**: a sequence of values with known length all\n+  having the same type. These terms are used interchangeably in\n+  different Arrow implementations, but we use \"array\" in this\n+  document.\n+* **Slot**: a single logical value in an array of some particular data type\n+* **Buffer** or **Contiguous memory region**: a sequential virtual\n+  address space with a given length. Any byte can be reached via a\n+  single pointer offset less than the region's length.\n+* **Physical Layout type**: The underlying memory layout for an array\n+  without taking into account any value semantics. For example, a\n+  32-bit signed integer array and 32-bit floating point array have the\n+  same layout type.\n+* **Logical type**: An application-facing semantic value type that is\n+  implemented using some physical layout type. For example, Decimal\n+  values are stored as 16 bytes in a fixed-size binary\n+  layout. Similarly, strings can be stored as ``List<1-byte>``. A\n+  timestamp may be stored as 64-bit fixed-size layout.\n+* **Nested** or **parametric type**: a data type whose full structure\n+  depends on one or more other child types. Two fully-specified nested\n+  types are equal if and only if their child types are equal. For\n+  example, ``List<U>`` is distinct from ``List<V>`` iff U and V are\n+  different types.\n+* **Parent** and **child arrays**: names to express relationships\n+  between physical value arrays in a nested type structure. For\n+  example, a ``List<T>``-type parent array has a T-type array as its\n+  child (see more on lists below).\n+* **Leaf node** or **leaf**: A primitive value array that may or may\n+  not be a child array of some array with a nested type.\n+\n+Physical Memory Layout\n+======================\n+\n+Arrays are defined by a few pieces of metadata and data:\n+\n+* A logical data type\n+* A sequence of buffers\n+* A length as a 64-bit signed integer. Implementations are permitted\n+  to be limited to 32-bit lengths, see more on this below\n+* A null count as a 64-bit signed integer\n+* An optional **dictionary**, for dictionary-encoded arrays\n+\n+Nested arrays additionally have a sequence of one or more sets of\n+these items, called the **child arrays**.\n+\n+Each logical data type has a well-defined physical layout. Here are\n+the different physical layouts defined by Arrow:\n+\n+* **Primitive (fixed-size)**: a sequence of values each having the\n+  same byte or bit width\n+* **Variable-size Binary**: a sequence of values each having a variable\n+  byte length. Two variants of this layout are supported using 32-bit\n+  and 64-bit length encoding.\n+* **Fixed-size List**: a nested layout each each value has the same\n+  number of elements taken from a child data type.\n+* **Variable-size List**: a nested layout type where each value is a\n+  variable-length sequence of values taken from a child data type. Two\n+  variants of this layout are supported using 32-bit and 64-bit length\n+  encoding.\n+* **Struct**: a nested layout type consisting of a collection of child\n+  **fields** each having the same length\n+* **Sparse** and **Dense Union**: a nested layout type representing a\n+  sequence of values, each of which can have type chosen from a\n+  collection of child array types.\n+* **Null**: a sequence of all null values, having null logical type\n+\n+Buffer Alignment and Padding\n+----------------------------\n+\n+Implementations are recommended allocate memory on aligned (8- or\n+64-byte boundaries) and pad (overallocate) to a length that is a\n+multiple of 8 or 64 bytes. When serializing Arrow data for\n+interprocess communication, these alignment and padding requirements\n+are enforced. If possible, we suggest that you prefer using 64-byte\n+alignment and padding. Unless otherwise noted, padded bytes do not\n+need to have a specific value.\n+\n+The alignment requirement follows best practices for optimized memory\n+access:\n+\n+* Elements in numeric arrays will be guaranteed to be retrieved via aligned access.\n+* On some architectures alignment can help limit partially used cache lines.\n+\n+The recommendation for 64 byte alignment comes from the `Intel\n+performance guide`_ that recommends alignment of memory to match SIMD\n+register width.  The specific padding length was chosen because it\n+matches the largest known SIMD instruction registers available as of\n+April 2016 (Intel AVX-512).\n+\n+The recommended padding of 64 bytes allows for using `SIMD`_\n+instructions consistently in loops without additional conditional\n+checks.  This should allow for simpler, efficient and CPU\n+cache-friendly code.  In other words, we can load the entire 64-byte\n+buffer into a 512-bit wide SIMD register and get data-level\n+parallelism on all the columnar values packed into the 64-byte\n+buffer. Guaranteed padding can also allow certain compilers to\n+generate more optimized code directly (e.g. One can safely use Intel's\n+``-qopt-assume-safe-padding``).\n+\n+Byte Order (`Endianness`_)\n+---------------------------\n+\n+The Arrow format is little endian by default.\n+\n+Serialized Schema metadata has an endianness field indicating\n+endianness of RecordBatches. Typically this is the endianness of the\n+system where the RecordBatch was generated. The main use case is\n+exchanging RecordBatches between systems with the same Endianness.  At\n+first we will return an error when trying to read a Schema with an\n+endianness that does not match the underlying system. The reference\n+implementation is focused on Little Endian and provides tests for\n+it. Eventually we may provide automatic conversion via byte swapping.\n+\n+Array lengths\n+-------------\n+\n+Array lengths are represented in the Arrow metadata as a 64-bit signed\n+integer. An implementation of Arrow is considered valid even if it only\n+supports lengths up to the maximum 32-bit signed integer, though. If using\n+Arrow in a multi-language environment, we recommend limiting lengths to\n+2 :sup:`31` - 1 elements or less. Larger data sets can be represented using\n+multiple array chunks.\n+\n+Null count\n+----------\n+\n+The number of null value slots is a property of the physical array and\n+considered part of the data structure. The null count is represented\n+in the Arrow metadata as a 64-bit signed integer, as it may be as\n+large as the array length.\n+\n+Validity bitmaps\n+----------------\n+\n+Any type can have null value slots, whether primitive or nested type.\n+\n+An array with nulls must have a contiguous memory buffer, known as the\n+validity (or \"null\") bitmap, large enough to have at least 1 bit for\n+each array slot.\n+\n+Whether any array slot is valid (non-null) is encoded in the respective bits of\n+this bitmap. A 1 (set bit) for index ``j`` indicates that the value is not null,\n+while a 0 (bit not set) indicates that it is null. Bitmaps are to be\n+initialized to be all unset at allocation time (this includes padding).::\n+\n+    is_valid[j] -> bitmap[j / 8] & (1 << (j % 8))\n+\n+We use `least-significant bit (LSB) numbering`_ (also known as\n+bit-endianness). This means that within a group of 8 bits, we read\n+right-to-left: ::\n+\n+    values = [0, 1, null, 2, null, 3]\n+\n+    bitmap\n+    j mod 8   7  6  5  4  3  2  1  0\n+              0  0  1  0  1  0  1  1\n+\n+Arrays having a 0 null count may choose to not allocate the null\n+bitmap. Implementations may choose to always allocate one anyway as a matter of\n+convenience, but this should be noted when memory is being shared.\n+\n+Nested type arrays have their own null bitmap and null count regardless of\n+the null count and null bits of their child arrays.\n+\n+Primitive\n+---------\n+\n+A primitive value array represents a fixed-length array of values each having\n \n Review comment:\n   Is \"fixed-length\" important here?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T15:20:32.399+0000",
                    "updated": "2019-08-27T15:20:32.399+0000",
                    "started": "2019-08-27T15:20:32.398+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "302066",
                    "issueId": "13214524"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/302067",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202#discussion_r318119193\n \n \n\n ##########\n File path: docs/source/format/Columnar.rst\n ##########\n @@ -0,0 +1,1266 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. _format_columnar:\n+\n+*********************\n+Arrow Columnar Format\n+*********************\n+\n+The \"Arrow Columnar Format\" includes a language-agnostic in-memory\n+data structure specification, metadata serialization, and a protocol\n+for serialization and generic data transport.\n+\n+This document is intended to provide adequate detail to create a new\n+implementation of the columnar format without the aid of an existing\n+implementation. We utilize Google's `Flatbuffers`_ project for\n+metadata serialization, so it will be necessary to refer to the\n+project's `Flatbuffers protocol definition files <FlatbuffersFiles>`_\n+while reading this document.\n+\n+The columnar format has some key features:\n+\n+* Data adjacency for sequential access (scans)\n+* O(1) (constant-time) random access\n+* SIMD and vectorization-friendly\n+* Relocatable without \"pointer swizzling\", allowing for true zero-copy\n+  access in shared memory\n+\n+Some things to keep in mind:\n+\n+* Some data types can be mutated in-place in memory, but others\n+  cannot. The community has made deliberate trade-offs regarding\n+  in-place mutability to provide analytical performance and data\n+  locality guarantees\n+\n+Terminology\n+===========\n+\n+Since different projects have used different words to describe various\n+concepts, here is a small glossary to help disambiguate.\n+\n+* **Array** or **Vector**: a sequence of values with known length all\n+  having the same type. These terms are used interchangeably in\n+  different Arrow implementations, but we use \"array\" in this\n+  document.\n+* **Slot**: a single logical value in an array of some particular data type\n+* **Buffer** or **Contiguous memory region**: a sequential virtual\n+  address space with a given length. Any byte can be reached via a\n+  single pointer offset less than the region's length.\n+* **Physical Layout type**: The underlying memory layout for an array\n+  without taking into account any value semantics. For example, a\n+  32-bit signed integer array and 32-bit floating point array have the\n+  same layout type.\n+* **Logical type**: An application-facing semantic value type that is\n+  implemented using some physical layout type. For example, Decimal\n+  values are stored as 16 bytes in a fixed-size binary\n+  layout. Similarly, strings can be stored as ``List<1-byte>``. A\n+  timestamp may be stored as 64-bit fixed-size layout.\n+* **Nested** or **parametric type**: a data type whose full structure\n+  depends on one or more other child types. Two fully-specified nested\n+  types are equal if and only if their child types are equal. For\n+  example, ``List<U>`` is distinct from ``List<V>`` iff U and V are\n+  different types.\n+* **Parent** and **child arrays**: names to express relationships\n+  between physical value arrays in a nested type structure. For\n+  example, a ``List<T>``-type parent array has a T-type array as its\n+  child (see more on lists below).\n+* **Leaf node** or **leaf**: A primitive value array that may or may\n+  not be a child array of some array with a nested type.\n+\n+Physical Memory Layout\n+======================\n+\n+Arrays are defined by a few pieces of metadata and data:\n+\n+* A logical data type\n+* A sequence of buffers\n+* A length as a 64-bit signed integer. Implementations are permitted\n+  to be limited to 32-bit lengths, see more on this below\n+* A null count as a 64-bit signed integer\n+* An optional **dictionary**, for dictionary-encoded arrays\n+\n+Nested arrays additionally have a sequence of one or more sets of\n+these items, called the **child arrays**.\n+\n+Each logical data type has a well-defined physical layout. Here are\n+the different physical layouts defined by Arrow:\n+\n+* **Primitive (fixed-size)**: a sequence of values each having the\n+  same byte or bit width\n+* **Variable-size Binary**: a sequence of values each having a variable\n+  byte length. Two variants of this layout are supported using 32-bit\n+  and 64-bit length encoding.\n+* **Fixed-size List**: a nested layout each each value has the same\n+  number of elements taken from a child data type.\n+* **Variable-size List**: a nested layout type where each value is a\n+  variable-length sequence of values taken from a child data type. Two\n+  variants of this layout are supported using 32-bit and 64-bit length\n+  encoding.\n+* **Struct**: a nested layout type consisting of a collection of child\n+  **fields** each having the same length\n+* **Sparse** and **Dense Union**: a nested layout type representing a\n+  sequence of values, each of which can have type chosen from a\n+  collection of child array types.\n+* **Null**: a sequence of all null values, having null logical type\n+\n+Buffer Alignment and Padding\n+----------------------------\n+\n+Implementations are recommended allocate memory on aligned (8- or\n+64-byte boundaries) and pad (overallocate) to a length that is a\n+multiple of 8 or 64 bytes. When serializing Arrow data for\n+interprocess communication, these alignment and padding requirements\n+are enforced. If possible, we suggest that you prefer using 64-byte\n+alignment and padding. Unless otherwise noted, padded bytes do not\n+need to have a specific value.\n+\n+The alignment requirement follows best practices for optimized memory\n+access:\n+\n+* Elements in numeric arrays will be guaranteed to be retrieved via aligned access.\n+* On some architectures alignment can help limit partially used cache lines.\n+\n+The recommendation for 64 byte alignment comes from the `Intel\n+performance guide`_ that recommends alignment of memory to match SIMD\n+register width.  The specific padding length was chosen because it\n+matches the largest known SIMD instruction registers available as of\n+April 2016 (Intel AVX-512).\n+\n+The recommended padding of 64 bytes allows for using `SIMD`_\n+instructions consistently in loops without additional conditional\n+checks.  This should allow for simpler, efficient and CPU\n+cache-friendly code.  In other words, we can load the entire 64-byte\n+buffer into a 512-bit wide SIMD register and get data-level\n+parallelism on all the columnar values packed into the 64-byte\n+buffer. Guaranteed padding can also allow certain compilers to\n+generate more optimized code directly (e.g. One can safely use Intel's\n+``-qopt-assume-safe-padding``).\n+\n+Byte Order (`Endianness`_)\n+---------------------------\n+\n+The Arrow format is little endian by default.\n+\n+Serialized Schema metadata has an endianness field indicating\n+endianness of RecordBatches. Typically this is the endianness of the\n+system where the RecordBatch was generated. The main use case is\n+exchanging RecordBatches between systems with the same Endianness.  At\n+first we will return an error when trying to read a Schema with an\n+endianness that does not match the underlying system. The reference\n+implementation is focused on Little Endian and provides tests for\n+it. Eventually we may provide automatic conversion via byte swapping.\n+\n+Array lengths\n+-------------\n+\n+Array lengths are represented in the Arrow metadata as a 64-bit signed\n+integer. An implementation of Arrow is considered valid even if it only\n+supports lengths up to the maximum 32-bit signed integer, though. If using\n+Arrow in a multi-language environment, we recommend limiting lengths to\n+2 :sup:`31` - 1 elements or less. Larger data sets can be represented using\n+multiple array chunks.\n+\n+Null count\n+----------\n+\n+The number of null value slots is a property of the physical array and\n+considered part of the data structure. The null count is represented\n+in the Arrow metadata as a 64-bit signed integer, as it may be as\n+large as the array length.\n+\n+Validity bitmaps\n+----------------\n+\n+Any type can have null value slots, whether primitive or nested type.\n+\n+An array with nulls must have a contiguous memory buffer, known as the\n+validity (or \"null\") bitmap, large enough to have at least 1 bit for\n+each array slot.\n+\n+Whether any array slot is valid (non-null) is encoded in the respective bits of\n+this bitmap. A 1 (set bit) for index ``j`` indicates that the value is not null,\n+while a 0 (bit not set) indicates that it is null. Bitmaps are to be\n+initialized to be all unset at allocation time (this includes padding).::\n+\n+    is_valid[j] -> bitmap[j / 8] & (1 << (j % 8))\n+\n+We use `least-significant bit (LSB) numbering`_ (also known as\n+bit-endianness). This means that within a group of 8 bits, we read\n+right-to-left: ::\n+\n+    values = [0, 1, null, 2, null, 3]\n+\n+    bitmap\n+    j mod 8   7  6  5  4  3  2  1  0\n+              0  0  1  0  1  0  1  1\n+\n+Arrays having a 0 null count may choose to not allocate the null\n+bitmap. Implementations may choose to always allocate one anyway as a matter of\n+convenience, but this should be noted when memory is being shared.\n+\n+Nested type arrays have their own null bitmap and null count regardless of\n+the null count and null bits of their child arrays.\n+\n+Primitive\n+---------\n+\n+A primitive value array represents a fixed-length array of values each having\n+the same physical slot width typically measured in bytes, though the spec also\n+provides for bit-packed types (e.g. boolean values encoded in bits).\n+\n+Internally, the array contains a contiguous memory buffer whose total size is\n+equal to the slot width multiplied by the array length. For bit-packed types,\n+the size is rounded up to the nearest byte.\n+\n+The associated null bitmap is contiguously allocated (as described above) but\n+does not need to be adjacent in memory to the values buffer.\n+\n+**Example Layout: Int32 Array**\n+\n+For example a primitive array of int32s: ::\n+\n+    [1, null, 2, 4, 8]\n+\n+Would look like: ::\n+\n+    * Length: 5, Null count: 1\n+    * Null bitmap buffer:\n+\n+      |Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |-------------------------|-----------------------|\n+      | 00011101                | 0 (padding)           |\n+\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | unspecified | 2           | 4           | 8           | unspecified |\n+\n+**Example Layout: Non-null int32 Array**\n+\n+``[1, 2, 3, 4, 8]`` has two possible layouts: ::\n+\n+    * Length: 5, Null count: 0\n+    * Null bitmap buffer:\n+\n+      | Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |--------------------------|-----------------------|\n+      | 00011111                 | 0 (padding)           |\n+\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | bytes 12-15 | bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | 2           | 3           | 4           | 8           | unspecified |\n+\n+or with the bitmap elided: ::\n+\n+    * Length 5, Null count: 0\n+    * Null bitmap buffer: Not required\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | bytes 12-15 | bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | 2           | 3           | 4           | 8           | unspecified |\n+\n+Variable-size\n+-------------\n+\n+Each value in this layout type consists of 0 or more bytes. While\n+primitive arrays have a single values buffer, variable-size binary\n+have an **offsets** buffer and **data** buffer\n+\n+The offsets buffer contains `length + 1` signed integers (either\n+32-bit or 64-bit), which encode the start position of each element in\n+the data buffer. The length of the value in each slot is computed\n+using the first difference with the next element in the offsets\n+array. For example, the position and length of slot j is computed as:\n+\n+::\n+\n+    slot_position = offsets[j]\n+    slot_length = offsets[j + 1] - offsets[j]  // (for 0 <= j < length)\n+\n+Generally the first value in the offsets array is 0, and the last\n+element is the length of the values array.\n+\n+Variable-size List\n+------------------\n+\n+List is a nested type which is semantically similar to variable-size\n+binary. It is defined by two buffers: a validity bitmap and an offsets\n+buffer. The offsets are the same as in the variable-size binary case,\n+and both 32-bit and 64-bit signed integer offsets are\n+supported. Rather than referencing an additional data buffer, instead\n+these offsets reference a child array having any type.\n+\n+A list type is specified like ``List<T>``, where ``T`` is any type\n+(primitive or nested).\n+\n+**Example Layout: ``List<Char>`` Array**\n+\n+We illustrate ``List<Int8>``.\n+\n+For an array of length 4 with respective values: ::\n \n Review comment:\n   Should it be \"An array of length 4 with respective values (...) will have the following representation\"?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T15:20:32.764+0000",
                    "updated": "2019-08-27T15:20:32.764+0000",
                    "started": "2019-08-27T15:20:32.764+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "302067",
                    "issueId": "13214524"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/302068",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202#discussion_r318118899\n \n \n\n ##########\n File path: docs/source/format/Columnar.rst\n ##########\n @@ -0,0 +1,1266 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. _format_columnar:\n+\n+*********************\n+Arrow Columnar Format\n+*********************\n+\n+The \"Arrow Columnar Format\" includes a language-agnostic in-memory\n+data structure specification, metadata serialization, and a protocol\n+for serialization and generic data transport.\n+\n+This document is intended to provide adequate detail to create a new\n+implementation of the columnar format without the aid of an existing\n+implementation. We utilize Google's `Flatbuffers`_ project for\n+metadata serialization, so it will be necessary to refer to the\n+project's `Flatbuffers protocol definition files <FlatbuffersFiles>`_\n+while reading this document.\n+\n+The columnar format has some key features:\n+\n+* Data adjacency for sequential access (scans)\n+* O(1) (constant-time) random access\n+* SIMD and vectorization-friendly\n+* Relocatable without \"pointer swizzling\", allowing for true zero-copy\n+  access in shared memory\n+\n+Some things to keep in mind:\n+\n+* Some data types can be mutated in-place in memory, but others\n+  cannot. The community has made deliberate trade-offs regarding\n+  in-place mutability to provide analytical performance and data\n+  locality guarantees\n+\n+Terminology\n+===========\n+\n+Since different projects have used different words to describe various\n+concepts, here is a small glossary to help disambiguate.\n+\n+* **Array** or **Vector**: a sequence of values with known length all\n+  having the same type. These terms are used interchangeably in\n+  different Arrow implementations, but we use \"array\" in this\n+  document.\n+* **Slot**: a single logical value in an array of some particular data type\n+* **Buffer** or **Contiguous memory region**: a sequential virtual\n+  address space with a given length. Any byte can be reached via a\n+  single pointer offset less than the region's length.\n+* **Physical Layout type**: The underlying memory layout for an array\n+  without taking into account any value semantics. For example, a\n+  32-bit signed integer array and 32-bit floating point array have the\n+  same layout type.\n+* **Logical type**: An application-facing semantic value type that is\n+  implemented using some physical layout type. For example, Decimal\n+  values are stored as 16 bytes in a fixed-size binary\n+  layout. Similarly, strings can be stored as ``List<1-byte>``. A\n+  timestamp may be stored as 64-bit fixed-size layout.\n+* **Nested** or **parametric type**: a data type whose full structure\n+  depends on one or more other child types. Two fully-specified nested\n+  types are equal if and only if their child types are equal. For\n+  example, ``List<U>`` is distinct from ``List<V>`` iff U and V are\n+  different types.\n+* **Parent** and **child arrays**: names to express relationships\n+  between physical value arrays in a nested type structure. For\n+  example, a ``List<T>``-type parent array has a T-type array as its\n+  child (see more on lists below).\n+* **Leaf node** or **leaf**: A primitive value array that may or may\n+  not be a child array of some array with a nested type.\n+\n+Physical Memory Layout\n+======================\n+\n+Arrays are defined by a few pieces of metadata and data:\n+\n+* A logical data type\n+* A sequence of buffers\n+* A length as a 64-bit signed integer. Implementations are permitted\n+  to be limited to 32-bit lengths, see more on this below\n+* A null count as a 64-bit signed integer\n+* An optional **dictionary**, for dictionary-encoded arrays\n+\n+Nested arrays additionally have a sequence of one or more sets of\n+these items, called the **child arrays**.\n+\n+Each logical data type has a well-defined physical layout. Here are\n+the different physical layouts defined by Arrow:\n+\n+* **Primitive (fixed-size)**: a sequence of values each having the\n+  same byte or bit width\n+* **Variable-size Binary**: a sequence of values each having a variable\n+  byte length. Two variants of this layout are supported using 32-bit\n+  and 64-bit length encoding.\n+* **Fixed-size List**: a nested layout each each value has the same\n+  number of elements taken from a child data type.\n+* **Variable-size List**: a nested layout type where each value is a\n+  variable-length sequence of values taken from a child data type. Two\n+  variants of this layout are supported using 32-bit and 64-bit length\n+  encoding.\n+* **Struct**: a nested layout type consisting of a collection of child\n+  **fields** each having the same length\n+* **Sparse** and **Dense Union**: a nested layout type representing a\n+  sequence of values, each of which can have type chosen from a\n+  collection of child array types.\n+* **Null**: a sequence of all null values, having null logical type\n+\n+Buffer Alignment and Padding\n+----------------------------\n+\n+Implementations are recommended allocate memory on aligned (8- or\n+64-byte boundaries) and pad (overallocate) to a length that is a\n+multiple of 8 or 64 bytes. When serializing Arrow data for\n+interprocess communication, these alignment and padding requirements\n+are enforced. If possible, we suggest that you prefer using 64-byte\n+alignment and padding. Unless otherwise noted, padded bytes do not\n+need to have a specific value.\n+\n+The alignment requirement follows best practices for optimized memory\n+access:\n+\n+* Elements in numeric arrays will be guaranteed to be retrieved via aligned access.\n+* On some architectures alignment can help limit partially used cache lines.\n+\n+The recommendation for 64 byte alignment comes from the `Intel\n+performance guide`_ that recommends alignment of memory to match SIMD\n+register width.  The specific padding length was chosen because it\n+matches the largest known SIMD instruction registers available as of\n+April 2016 (Intel AVX-512).\n+\n+The recommended padding of 64 bytes allows for using `SIMD`_\n+instructions consistently in loops without additional conditional\n+checks.  This should allow for simpler, efficient and CPU\n+cache-friendly code.  In other words, we can load the entire 64-byte\n+buffer into a 512-bit wide SIMD register and get data-level\n+parallelism on all the columnar values packed into the 64-byte\n+buffer. Guaranteed padding can also allow certain compilers to\n+generate more optimized code directly (e.g. One can safely use Intel's\n+``-qopt-assume-safe-padding``).\n+\n+Byte Order (`Endianness`_)\n+---------------------------\n+\n+The Arrow format is little endian by default.\n+\n+Serialized Schema metadata has an endianness field indicating\n+endianness of RecordBatches. Typically this is the endianness of the\n+system where the RecordBatch was generated. The main use case is\n+exchanging RecordBatches between systems with the same Endianness.  At\n+first we will return an error when trying to read a Schema with an\n+endianness that does not match the underlying system. The reference\n+implementation is focused on Little Endian and provides tests for\n+it. Eventually we may provide automatic conversion via byte swapping.\n+\n+Array lengths\n+-------------\n+\n+Array lengths are represented in the Arrow metadata as a 64-bit signed\n+integer. An implementation of Arrow is considered valid even if it only\n+supports lengths up to the maximum 32-bit signed integer, though. If using\n+Arrow in a multi-language environment, we recommend limiting lengths to\n+2 :sup:`31` - 1 elements or less. Larger data sets can be represented using\n+multiple array chunks.\n+\n+Null count\n+----------\n+\n+The number of null value slots is a property of the physical array and\n+considered part of the data structure. The null count is represented\n+in the Arrow metadata as a 64-bit signed integer, as it may be as\n+large as the array length.\n+\n+Validity bitmaps\n+----------------\n+\n+Any type can have null value slots, whether primitive or nested type.\n+\n+An array with nulls must have a contiguous memory buffer, known as the\n+validity (or \"null\") bitmap, large enough to have at least 1 bit for\n+each array slot.\n+\n+Whether any array slot is valid (non-null) is encoded in the respective bits of\n+this bitmap. A 1 (set bit) for index ``j`` indicates that the value is not null,\n+while a 0 (bit not set) indicates that it is null. Bitmaps are to be\n+initialized to be all unset at allocation time (this includes padding).::\n+\n+    is_valid[j] -> bitmap[j / 8] & (1 << (j % 8))\n+\n+We use `least-significant bit (LSB) numbering`_ (also known as\n+bit-endianness). This means that within a group of 8 bits, we read\n+right-to-left: ::\n+\n+    values = [0, 1, null, 2, null, 3]\n+\n+    bitmap\n+    j mod 8   7  6  5  4  3  2  1  0\n+              0  0  1  0  1  0  1  1\n+\n+Arrays having a 0 null count may choose to not allocate the null\n+bitmap. Implementations may choose to always allocate one anyway as a matter of\n+convenience, but this should be noted when memory is being shared.\n+\n+Nested type arrays have their own null bitmap and null count regardless of\n+the null count and null bits of their child arrays.\n+\n+Primitive\n+---------\n+\n+A primitive value array represents a fixed-length array of values each having\n+the same physical slot width typically measured in bytes, though the spec also\n+provides for bit-packed types (e.g. boolean values encoded in bits).\n+\n+Internally, the array contains a contiguous memory buffer whose total size is\n+equal to the slot width multiplied by the array length. For bit-packed types,\n+the size is rounded up to the nearest byte.\n+\n+The associated null bitmap is contiguously allocated (as described above) but\n+does not need to be adjacent in memory to the values buffer.\n+\n+**Example Layout: Int32 Array**\n+\n+For example a primitive array of int32s: ::\n+\n+    [1, null, 2, 4, 8]\n+\n+Would look like: ::\n+\n+    * Length: 5, Null count: 1\n+    * Null bitmap buffer:\n+\n+      |Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |-------------------------|-----------------------|\n+      | 00011101                | 0 (padding)           |\n+\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | unspecified | 2           | 4           | 8           | unspecified |\n+\n+**Example Layout: Non-null int32 Array**\n+\n+``[1, 2, 3, 4, 8]`` has two possible layouts: ::\n+\n+    * Length: 5, Null count: 0\n+    * Null bitmap buffer:\n+\n+      | Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |--------------------------|-----------------------|\n+      | 00011111                 | 0 (padding)           |\n+\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | bytes 12-15 | bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | 2           | 3           | 4           | 8           | unspecified |\n+\n+or with the bitmap elided: ::\n+\n+    * Length 5, Null count: 0\n+    * Null bitmap buffer: Not required\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | bytes 12-15 | bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | 2           | 3           | 4           | 8           | unspecified |\n+\n+Variable-size\n+-------------\n+\n+Each value in this layout type consists of 0 or more bytes. While\n+primitive arrays have a single values buffer, variable-size binary\n+have an **offsets** buffer and **data** buffer\n+\n+The offsets buffer contains `length + 1` signed integers (either\n+32-bit or 64-bit), which encode the start position of each element in\n+the data buffer. The length of the value in each slot is computed\n+using the first difference with the next element in the offsets\n+array. For example, the position and length of slot j is computed as:\n+\n+::\n+\n+    slot_position = offsets[j]\n+    slot_length = offsets[j + 1] - offsets[j]  // (for 0 <= j < length)\n+\n+Generally the first value in the offsets array is 0, and the last\n+element is the length of the values array.\n+\n+Variable-size List\n+------------------\n+\n+List is a nested type which is semantically similar to variable-size\n+binary. It is defined by two buffers: a validity bitmap and an offsets\n+buffer. The offsets are the same as in the variable-size binary case,\n+and both 32-bit and 64-bit signed integer offsets are\n+supported. Rather than referencing an additional data buffer, instead\n+these offsets reference a child array having any type.\n+\n+A list type is specified like ``List<T>``, where ``T`` is any type\n \n Review comment:\n   Hmm... Perhaps we should also mention `LargeList` here, to make it clear that `List` always has 32-bit offsets?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T15:20:32.767+0000",
                    "updated": "2019-08-27T15:20:32.767+0000",
                    "started": "2019-08-27T15:20:32.767+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "302068",
                    "issueId": "13214524"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/302069",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202#discussion_r318117831\n \n \n\n ##########\n File path: docs/source/format/Columnar.rst\n ##########\n @@ -0,0 +1,1266 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. _format_columnar:\n+\n+*********************\n+Arrow Columnar Format\n+*********************\n+\n+The \"Arrow Columnar Format\" includes a language-agnostic in-memory\n+data structure specification, metadata serialization, and a protocol\n+for serialization and generic data transport.\n+\n+This document is intended to provide adequate detail to create a new\n+implementation of the columnar format without the aid of an existing\n+implementation. We utilize Google's `Flatbuffers`_ project for\n+metadata serialization, so it will be necessary to refer to the\n+project's `Flatbuffers protocol definition files <FlatbuffersFiles>`_\n+while reading this document.\n+\n+The columnar format has some key features:\n+\n+* Data adjacency for sequential access (scans)\n+* O(1) (constant-time) random access\n+* SIMD and vectorization-friendly\n+* Relocatable without \"pointer swizzling\", allowing for true zero-copy\n+  access in shared memory\n+\n+Some things to keep in mind:\n+\n+* Some data types can be mutated in-place in memory, but others\n+  cannot. The community has made deliberate trade-offs regarding\n+  in-place mutability to provide analytical performance and data\n+  locality guarantees\n+\n+Terminology\n+===========\n+\n+Since different projects have used different words to describe various\n+concepts, here is a small glossary to help disambiguate.\n+\n+* **Array** or **Vector**: a sequence of values with known length all\n+  having the same type. These terms are used interchangeably in\n+  different Arrow implementations, but we use \"array\" in this\n+  document.\n+* **Slot**: a single logical value in an array of some particular data type\n+* **Buffer** or **Contiguous memory region**: a sequential virtual\n+  address space with a given length. Any byte can be reached via a\n+  single pointer offset less than the region's length.\n+* **Physical Layout type**: The underlying memory layout for an array\n+  without taking into account any value semantics. For example, a\n+  32-bit signed integer array and 32-bit floating point array have the\n+  same layout type.\n+* **Logical type**: An application-facing semantic value type that is\n+  implemented using some physical layout type. For example, Decimal\n+  values are stored as 16 bytes in a fixed-size binary\n+  layout. Similarly, strings can be stored as ``List<1-byte>``. A\n+  timestamp may be stored as 64-bit fixed-size layout.\n+* **Nested** or **parametric type**: a data type whose full structure\n+  depends on one or more other child types. Two fully-specified nested\n+  types are equal if and only if their child types are equal. For\n+  example, ``List<U>`` is distinct from ``List<V>`` iff U and V are\n+  different types.\n+* **Parent** and **child arrays**: names to express relationships\n+  between physical value arrays in a nested type structure. For\n+  example, a ``List<T>``-type parent array has a T-type array as its\n+  child (see more on lists below).\n+* **Leaf node** or **leaf**: A primitive value array that may or may\n+  not be a child array of some array with a nested type.\n+\n+Physical Memory Layout\n+======================\n+\n+Arrays are defined by a few pieces of metadata and data:\n+\n+* A logical data type\n+* A sequence of buffers\n+* A length as a 64-bit signed integer. Implementations are permitted\n+  to be limited to 32-bit lengths, see more on this below\n+* A null count as a 64-bit signed integer\n+* An optional **dictionary**, for dictionary-encoded arrays\n+\n+Nested arrays additionally have a sequence of one or more sets of\n+these items, called the **child arrays**.\n+\n+Each logical data type has a well-defined physical layout. Here are\n+the different physical layouts defined by Arrow:\n+\n+* **Primitive (fixed-size)**: a sequence of values each having the\n+  same byte or bit width\n+* **Variable-size Binary**: a sequence of values each having a variable\n+  byte length. Two variants of this layout are supported using 32-bit\n+  and 64-bit length encoding.\n+* **Fixed-size List**: a nested layout each each value has the same\n+  number of elements taken from a child data type.\n+* **Variable-size List**: a nested layout type where each value is a\n+  variable-length sequence of values taken from a child data type. Two\n+  variants of this layout are supported using 32-bit and 64-bit length\n+  encoding.\n+* **Struct**: a nested layout type consisting of a collection of child\n+  **fields** each having the same length\n+* **Sparse** and **Dense Union**: a nested layout type representing a\n+  sequence of values, each of which can have type chosen from a\n+  collection of child array types.\n+* **Null**: a sequence of all null values, having null logical type\n+\n+Buffer Alignment and Padding\n+----------------------------\n+\n+Implementations are recommended allocate memory on aligned (8- or\n+64-byte boundaries) and pad (overallocate) to a length that is a\n+multiple of 8 or 64 bytes. When serializing Arrow data for\n+interprocess communication, these alignment and padding requirements\n+are enforced. If possible, we suggest that you prefer using 64-byte\n+alignment and padding. Unless otherwise noted, padded bytes do not\n+need to have a specific value.\n+\n+The alignment requirement follows best practices for optimized memory\n+access:\n+\n+* Elements in numeric arrays will be guaranteed to be retrieved via aligned access.\n+* On some architectures alignment can help limit partially used cache lines.\n+\n+The recommendation for 64 byte alignment comes from the `Intel\n+performance guide`_ that recommends alignment of memory to match SIMD\n+register width.  The specific padding length was chosen because it\n+matches the largest known SIMD instruction registers available as of\n+April 2016 (Intel AVX-512).\n+\n+The recommended padding of 64 bytes allows for using `SIMD`_\n+instructions consistently in loops without additional conditional\n+checks.  This should allow for simpler, efficient and CPU\n+cache-friendly code.  In other words, we can load the entire 64-byte\n+buffer into a 512-bit wide SIMD register and get data-level\n+parallelism on all the columnar values packed into the 64-byte\n+buffer. Guaranteed padding can also allow certain compilers to\n+generate more optimized code directly (e.g. One can safely use Intel's\n+``-qopt-assume-safe-padding``).\n+\n+Byte Order (`Endianness`_)\n+---------------------------\n+\n+The Arrow format is little endian by default.\n+\n+Serialized Schema metadata has an endianness field indicating\n+endianness of RecordBatches. Typically this is the endianness of the\n+system where the RecordBatch was generated. The main use case is\n+exchanging RecordBatches between systems with the same Endianness.  At\n+first we will return an error when trying to read a Schema with an\n+endianness that does not match the underlying system. The reference\n+implementation is focused on Little Endian and provides tests for\n+it. Eventually we may provide automatic conversion via byte swapping.\n+\n+Array lengths\n+-------------\n+\n+Array lengths are represented in the Arrow metadata as a 64-bit signed\n+integer. An implementation of Arrow is considered valid even if it only\n+supports lengths up to the maximum 32-bit signed integer, though. If using\n+Arrow in a multi-language environment, we recommend limiting lengths to\n+2 :sup:`31` - 1 elements or less. Larger data sets can be represented using\n+multiple array chunks.\n+\n+Null count\n+----------\n+\n+The number of null value slots is a property of the physical array and\n+considered part of the data structure. The null count is represented\n+in the Arrow metadata as a 64-bit signed integer, as it may be as\n+large as the array length.\n+\n+Validity bitmaps\n+----------------\n+\n+Any type can have null value slots, whether primitive or nested type.\n+\n+An array with nulls must have a contiguous memory buffer, known as the\n+validity (or \"null\") bitmap, large enough to have at least 1 bit for\n+each array slot.\n+\n+Whether any array slot is valid (non-null) is encoded in the respective bits of\n+this bitmap. A 1 (set bit) for index ``j`` indicates that the value is not null,\n+while a 0 (bit not set) indicates that it is null. Bitmaps are to be\n+initialized to be all unset at allocation time (this includes padding).::\n+\n+    is_valid[j] -> bitmap[j / 8] & (1 << (j % 8))\n+\n+We use `least-significant bit (LSB) numbering`_ (also known as\n+bit-endianness). This means that within a group of 8 bits, we read\n+right-to-left: ::\n+\n+    values = [0, 1, null, 2, null, 3]\n+\n+    bitmap\n+    j mod 8   7  6  5  4  3  2  1  0\n+              0  0  1  0  1  0  1  1\n+\n+Arrays having a 0 null count may choose to not allocate the null\n+bitmap. Implementations may choose to always allocate one anyway as a matter of\n+convenience, but this should be noted when memory is being shared.\n+\n+Nested type arrays have their own null bitmap and null count regardless of\n+the null count and null bits of their child arrays.\n+\n+Primitive\n+---------\n+\n+A primitive value array represents a fixed-length array of values each having\n+the same physical slot width typically measured in bytes, though the spec also\n+provides for bit-packed types (e.g. boolean values encoded in bits).\n+\n+Internally, the array contains a contiguous memory buffer whose total size is\n+equal to the slot width multiplied by the array length. For bit-packed types,\n+the size is rounded up to the nearest byte.\n+\n+The associated null bitmap is contiguously allocated (as described above) but\n+does not need to be adjacent in memory to the values buffer.\n+\n+**Example Layout: Int32 Array**\n+\n+For example a primitive array of int32s: ::\n+\n+    [1, null, 2, 4, 8]\n+\n+Would look like: ::\n+\n+    * Length: 5, Null count: 1\n+    * Null bitmap buffer:\n+\n+      |Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |-------------------------|-----------------------|\n+      | 00011101                | 0 (padding)           |\n+\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | unspecified | 2           | 4           | 8           | unspecified |\n+\n+**Example Layout: Non-null int32 Array**\n+\n+``[1, 2, 3, 4, 8]`` has two possible layouts: ::\n+\n+    * Length: 5, Null count: 0\n+    * Null bitmap buffer:\n+\n+      | Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |--------------------------|-----------------------|\n+      | 00011111                 | 0 (padding)           |\n+\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | bytes 12-15 | bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | 2           | 3           | 4           | 8           | unspecified |\n+\n+or with the bitmap elided: ::\n+\n+    * Length 5, Null count: 0\n+    * Null bitmap buffer: Not required\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | bytes 12-15 | bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | 2           | 3           | 4           | 8           | unspecified |\n+\n+Variable-size\n+-------------\n+\n+Each value in this layout type consists of 0 or more bytes. While\n+primitive arrays have a single values buffer, variable-size binary\n+have an **offsets** buffer and **data** buffer\n+\n+The offsets buffer contains `length + 1` signed integers (either\n+32-bit or 64-bit), which encode the start position of each element in\n+the data buffer. The length of the value in each slot is computed\n+using the first difference with the next element in the offsets\n \n Review comment:\n   Hmm... why \"first difference\"? How about \"the difference between the start offset of the slot and the start offset of the next slot\"?\r\n   (also, are \"slot\" and \"element\" the same thing?)\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T15:20:32.775+0000",
                    "updated": "2019-08-27T15:20:32.775+0000",
                    "started": "2019-08-27T15:20:32.774+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "302069",
                    "issueId": "13214524"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/302070",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202#discussion_r318123256\n \n \n\n ##########\n File path: docs/source/format/Columnar.rst\n ##########\n @@ -0,0 +1,1266 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. _format_columnar:\n+\n+*********************\n+Arrow Columnar Format\n+*********************\n+\n+The \"Arrow Columnar Format\" includes a language-agnostic in-memory\n+data structure specification, metadata serialization, and a protocol\n+for serialization and generic data transport.\n+\n+This document is intended to provide adequate detail to create a new\n+implementation of the columnar format without the aid of an existing\n+implementation. We utilize Google's `Flatbuffers`_ project for\n+metadata serialization, so it will be necessary to refer to the\n+project's `Flatbuffers protocol definition files <FlatbuffersFiles>`_\n+while reading this document.\n+\n+The columnar format has some key features:\n+\n+* Data adjacency for sequential access (scans)\n+* O(1) (constant-time) random access\n+* SIMD and vectorization-friendly\n+* Relocatable without \"pointer swizzling\", allowing for true zero-copy\n+  access in shared memory\n+\n+Some things to keep in mind:\n+\n+* Some data types can be mutated in-place in memory, but others\n+  cannot. The community has made deliberate trade-offs regarding\n+  in-place mutability to provide analytical performance and data\n+  locality guarantees\n+\n+Terminology\n+===========\n+\n+Since different projects have used different words to describe various\n+concepts, here is a small glossary to help disambiguate.\n+\n+* **Array** or **Vector**: a sequence of values with known length all\n+  having the same type. These terms are used interchangeably in\n+  different Arrow implementations, but we use \"array\" in this\n+  document.\n+* **Slot**: a single logical value in an array of some particular data type\n+* **Buffer** or **Contiguous memory region**: a sequential virtual\n+  address space with a given length. Any byte can be reached via a\n+  single pointer offset less than the region's length.\n+* **Physical Layout type**: The underlying memory layout for an array\n+  without taking into account any value semantics. For example, a\n+  32-bit signed integer array and 32-bit floating point array have the\n+  same layout type.\n+* **Logical type**: An application-facing semantic value type that is\n+  implemented using some physical layout type. For example, Decimal\n+  values are stored as 16 bytes in a fixed-size binary\n+  layout. Similarly, strings can be stored as ``List<1-byte>``. A\n+  timestamp may be stored as 64-bit fixed-size layout.\n+* **Nested** or **parametric type**: a data type whose full structure\n+  depends on one or more other child types. Two fully-specified nested\n+  types are equal if and only if their child types are equal. For\n+  example, ``List<U>`` is distinct from ``List<V>`` iff U and V are\n+  different types.\n+* **Parent** and **child arrays**: names to express relationships\n+  between physical value arrays in a nested type structure. For\n+  example, a ``List<T>``-type parent array has a T-type array as its\n+  child (see more on lists below).\n+* **Leaf node** or **leaf**: A primitive value array that may or may\n+  not be a child array of some array with a nested type.\n+\n+Physical Memory Layout\n+======================\n+\n+Arrays are defined by a few pieces of metadata and data:\n+\n+* A logical data type\n+* A sequence of buffers\n+* A length as a 64-bit signed integer. Implementations are permitted\n+  to be limited to 32-bit lengths, see more on this below\n+* A null count as a 64-bit signed integer\n+* An optional **dictionary**, for dictionary-encoded arrays\n+\n+Nested arrays additionally have a sequence of one or more sets of\n+these items, called the **child arrays**.\n+\n+Each logical data type has a well-defined physical layout. Here are\n+the different physical layouts defined by Arrow:\n+\n+* **Primitive (fixed-size)**: a sequence of values each having the\n+  same byte or bit width\n+* **Variable-size Binary**: a sequence of values each having a variable\n+  byte length. Two variants of this layout are supported using 32-bit\n+  and 64-bit length encoding.\n+* **Fixed-size List**: a nested layout each each value has the same\n+  number of elements taken from a child data type.\n+* **Variable-size List**: a nested layout type where each value is a\n+  variable-length sequence of values taken from a child data type. Two\n+  variants of this layout are supported using 32-bit and 64-bit length\n+  encoding.\n+* **Struct**: a nested layout type consisting of a collection of child\n+  **fields** each having the same length\n+* **Sparse** and **Dense Union**: a nested layout type representing a\n+  sequence of values, each of which can have type chosen from a\n+  collection of child array types.\n+* **Null**: a sequence of all null values, having null logical type\n+\n+Buffer Alignment and Padding\n+----------------------------\n+\n+Implementations are recommended allocate memory on aligned (8- or\n+64-byte boundaries) and pad (overallocate) to a length that is a\n+multiple of 8 or 64 bytes. When serializing Arrow data for\n+interprocess communication, these alignment and padding requirements\n+are enforced. If possible, we suggest that you prefer using 64-byte\n+alignment and padding. Unless otherwise noted, padded bytes do not\n+need to have a specific value.\n+\n+The alignment requirement follows best practices for optimized memory\n+access:\n+\n+* Elements in numeric arrays will be guaranteed to be retrieved via aligned access.\n+* On some architectures alignment can help limit partially used cache lines.\n+\n+The recommendation for 64 byte alignment comes from the `Intel\n+performance guide`_ that recommends alignment of memory to match SIMD\n+register width.  The specific padding length was chosen because it\n+matches the largest known SIMD instruction registers available as of\n+April 2016 (Intel AVX-512).\n+\n+The recommended padding of 64 bytes allows for using `SIMD`_\n+instructions consistently in loops without additional conditional\n+checks.  This should allow for simpler, efficient and CPU\n+cache-friendly code.  In other words, we can load the entire 64-byte\n+buffer into a 512-bit wide SIMD register and get data-level\n+parallelism on all the columnar values packed into the 64-byte\n+buffer. Guaranteed padding can also allow certain compilers to\n+generate more optimized code directly (e.g. One can safely use Intel's\n+``-qopt-assume-safe-padding``).\n+\n+Byte Order (`Endianness`_)\n+---------------------------\n+\n+The Arrow format is little endian by default.\n+\n+Serialized Schema metadata has an endianness field indicating\n+endianness of RecordBatches. Typically this is the endianness of the\n+system where the RecordBatch was generated. The main use case is\n+exchanging RecordBatches between systems with the same Endianness.  At\n+first we will return an error when trying to read a Schema with an\n+endianness that does not match the underlying system. The reference\n+implementation is focused on Little Endian and provides tests for\n+it. Eventually we may provide automatic conversion via byte swapping.\n+\n+Array lengths\n+-------------\n+\n+Array lengths are represented in the Arrow metadata as a 64-bit signed\n+integer. An implementation of Arrow is considered valid even if it only\n+supports lengths up to the maximum 32-bit signed integer, though. If using\n+Arrow in a multi-language environment, we recommend limiting lengths to\n+2 :sup:`31` - 1 elements or less. Larger data sets can be represented using\n+multiple array chunks.\n+\n+Null count\n+----------\n+\n+The number of null value slots is a property of the physical array and\n+considered part of the data structure. The null count is represented\n+in the Arrow metadata as a 64-bit signed integer, as it may be as\n+large as the array length.\n+\n+Validity bitmaps\n+----------------\n+\n+Any type can have null value slots, whether primitive or nested type.\n+\n+An array with nulls must have a contiguous memory buffer, known as the\n+validity (or \"null\") bitmap, large enough to have at least 1 bit for\n+each array slot.\n+\n+Whether any array slot is valid (non-null) is encoded in the respective bits of\n+this bitmap. A 1 (set bit) for index ``j`` indicates that the value is not null,\n+while a 0 (bit not set) indicates that it is null. Bitmaps are to be\n+initialized to be all unset at allocation time (this includes padding).::\n+\n+    is_valid[j] -> bitmap[j / 8] & (1 << (j % 8))\n+\n+We use `least-significant bit (LSB) numbering`_ (also known as\n+bit-endianness). This means that within a group of 8 bits, we read\n+right-to-left: ::\n+\n+    values = [0, 1, null, 2, null, 3]\n+\n+    bitmap\n+    j mod 8   7  6  5  4  3  2  1  0\n+              0  0  1  0  1  0  1  1\n+\n+Arrays having a 0 null count may choose to not allocate the null\n+bitmap. Implementations may choose to always allocate one anyway as a matter of\n+convenience, but this should be noted when memory is being shared.\n+\n+Nested type arrays have their own null bitmap and null count regardless of\n+the null count and null bits of their child arrays.\n+\n+Primitive\n+---------\n+\n+A primitive value array represents a fixed-length array of values each having\n+the same physical slot width typically measured in bytes, though the spec also\n+provides for bit-packed types (e.g. boolean values encoded in bits).\n+\n+Internally, the array contains a contiguous memory buffer whose total size is\n+equal to the slot width multiplied by the array length. For bit-packed types,\n+the size is rounded up to the nearest byte.\n+\n+The associated null bitmap is contiguously allocated (as described above) but\n+does not need to be adjacent in memory to the values buffer.\n+\n+**Example Layout: Int32 Array**\n+\n+For example a primitive array of int32s: ::\n+\n+    [1, null, 2, 4, 8]\n+\n+Would look like: ::\n+\n+    * Length: 5, Null count: 1\n+    * Null bitmap buffer:\n+\n+      |Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |-------------------------|-----------------------|\n+      | 00011101                | 0 (padding)           |\n+\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | unspecified | 2           | 4           | 8           | unspecified |\n+\n+**Example Layout: Non-null int32 Array**\n+\n+``[1, 2, 3, 4, 8]`` has two possible layouts: ::\n+\n+    * Length: 5, Null count: 0\n+    * Null bitmap buffer:\n+\n+      | Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |--------------------------|-----------------------|\n+      | 00011111                 | 0 (padding)           |\n+\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | bytes 12-15 | bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | 2           | 3           | 4           | 8           | unspecified |\n+\n+or with the bitmap elided: ::\n+\n+    * Length 5, Null count: 0\n+    * Null bitmap buffer: Not required\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | bytes 12-15 | bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | 2           | 3           | 4           | 8           | unspecified |\n+\n+Variable-size\n+-------------\n+\n+Each value in this layout type consists of 0 or more bytes. While\n+primitive arrays have a single values buffer, variable-size binary\n+have an **offsets** buffer and **data** buffer\n+\n+The offsets buffer contains `length + 1` signed integers (either\n+32-bit or 64-bit), which encode the start position of each element in\n+the data buffer. The length of the value in each slot is computed\n+using the first difference with the next element in the offsets\n+array. For example, the position and length of slot j is computed as:\n+\n+::\n+\n+    slot_position = offsets[j]\n+    slot_length = offsets[j + 1] - offsets[j]  // (for 0 <= j < length)\n+\n+Generally the first value in the offsets array is 0, and the last\n+element is the length of the values array.\n+\n+Variable-size List\n+------------------\n+\n+List is a nested type which is semantically similar to variable-size\n+binary. It is defined by two buffers: a validity bitmap and an offsets\n+buffer. The offsets are the same as in the variable-size binary case,\n+and both 32-bit and 64-bit signed integer offsets are\n+supported. Rather than referencing an additional data buffer, instead\n+these offsets reference a child array having any type.\n+\n+A list type is specified like ``List<T>``, where ``T`` is any type\n+(primitive or nested).\n+\n+**Example Layout: ``List<Char>`` Array**\n+\n+We illustrate ``List<Int8>``.\n+\n+For an array of length 4 with respective values: ::\n+\n+    [[12, -7, 25], null, [0, -127, 127, 50], []]\n+\n+will have the following representation: ::\n+\n+    * Length: 4, Null count: 1\n+    * Null bitmap buffer:\n+\n+      | Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |--------------------------|-----------------------|\n+      | 00001101                 | 0 (padding)           |\n+\n+    * Offsets buffer (int32)\n+\n+      | Bytes 0-3  | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 0          | 3           | 3           | 7           | 7           | unspecified |\n+\n+    * Values array (Int8array):\n+      * Length: 7,  Null count: 0\n+      * Null bitmap buffer: Not required\n+\n+        | Bytes 0-6                   | Bytes 7-63  |\n+        |-----------------------------|-------------|\n+        | 12, 7, 25, 0, -127, 127, 50 | unspecified |\n+\n+**Example Layout: ``List<List<Int8>>``**\n+\n+``[[[1, 2], [3, 4]], [[5, 6, 7], null, [8]], [[9, 10]]]``\n+\n+will be represented as follows: ::\n+\n+    * Length 3\n+    * Nulls count: 0\n+    * Null bitmap buffer: Not required\n+    * Offsets buffer (int32)\n+\n+      | Bytes 0-3  | Bytes 4-7  | Bytes 8-11 | Bytes 12-15 | Bytes 16-63 |\n+      |------------|------------|------------|-------------|-------------|\n+      | 0          |  2         |  5         |  6          | unspecified |\n+\n+    * Values array (`List<Int8>`)\n+      * Length: 6, Null count: 1\n+      * Null bitmap buffer:\n+\n+        | Byte 0 (validity bitmap) | Bytes 1-63  |\n+        |--------------------------|-------------|\n+        | 00110111                 | 0 (padding) |\n+\n+      * Offsets buffer (int32)\n+\n+        | Bytes 0-27           | Bytes 28-63 |\n+        |----------------------|-------------|\n+        | 0, 2, 4, 7, 7, 8, 10 | unspecified |\n+\n+      * Values array (Int8):\n+        * Length: 10, Null count: 0\n+        * Null bitmap buffer: Not required\n+\n+          | Bytes 0-9                     | Bytes 10-63 |\n+          |-------------------------------|-------------|\n+          | 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 | unspecified |\n+\n+Note that while the inner offsets buffer encodes the start position in\n+the inner values array, the outer offsets buffer encodes the start\n+position of corresponding outer element in the inner offsets buffer.\n+\n+Fixed-Size List\n+---------------\n+\n+Fixed-Size List is a nested type in which each array slot contains a\n+fixed-size sequence of values all having the same type (heterogeneity\n+can be achieved through unions, described later).\n+\n+A fixed size list type is specified like ``FixedSizeList<T>[N]``,\n+where ``T`` is any type (primitive or nested) and ``N`` is a 32-bit\n+signed integer representing the length of the lists.\n+\n+A fixed size list array is represented by a values array, which is a\n+child array of type T. T may also be a nested type. The value in slot\n+``j`` of a fixed size list array is stored in an ``N``-long slice of\n+the values array, starting at an offset of ``j * N``.\n+\n+**Example Layout: ``FixedSizeList<byte>[4]`` Array**\n+\n+Here we illustrate ``FixedSizeList<byte>[4]``.\n+\n+For an array of length 4 with respective values: ::\n+\n+    [[192, 168, 0, 12], null, [192, 168, 0, 25], [192, 168, 0, 1]]\n+\n+will have the following representation: ::\n+\n+    * Length: 4, Null count: 1\n+    * Null bitmap buffer:\n+\n+      | Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |--------------------------|-----------------------|\n+      | 00001101                 | 0 (padding)           |\n+\n+    * Values array (byte array):\n+      * Length: 16,  Null count: 0\n+      * Null bitmap buffer: Not required\n+\n+        | Bytes 0-3       | Bytes 4-7   | Bytes 8-15                      |\n+        |-----------------|-------------|---------------------------------|\n+        | 192, 168, 0, 12 | unspecified | 192, 168, 0, 25, 192, 168, 0, 1 |\n+\n+\n+Struct\n+------\n+\n+A struct is a nested type parameterized by an ordered sequence of\n+types (which can all be distinct), called its fields. Typically the\n+fields have names, but the names and their types are part of the type\n+metadata, not the physical memory layout.\n+\n+A struct array does not have any additional allocated physical storage\n+for its values.  A struct array must still have an allocated null\n+bitmap, if it has one or more null values.\n+\n+Physically, a struct type has one child array for each field. The\n+child arrays are independent and need not be adjacent to each other in\n+memory.\n+\n+For example, the struct (field names shown here as strings for illustration\n+purposes)::\n+\n+    Struct <\n+      name: String (= List<char>),\n+      age: Int32\n+    >\n+\n+has two child arrays, one ``List<char>`` array (layout as above) and one 4-byte\n+primitive value array having ``Int32`` logical type.\n+\n+**Example Layout: ``Struct<List<char>, Int32>``**\n+\n+The layout for ``[{'joe', 1}, {null, 2}, null, {'mark', 4}]`` would be: ::\n+\n+    * Length: 4, Null count: 1\n+    * Null bitmap buffer:\n+\n+      |Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |-------------------------|-----------------------|\n+      | 00001011                | 0 (padding)           |\n+\n+    * Children arrays:\n+      * field-0 array (`List<char>`):\n+        * Length: 4, Null count: 2\n+        * Null bitmap buffer:\n+\n+          | Byte 0 (validity bitmap) | Bytes 1-63            |\n+          |--------------------------|-----------------------|\n+          | 00001001                 | 0 (padding)           |\n+\n+        * Offsets buffer:\n+\n+          | Bytes 0-19     |\n+          |----------------|\n+          | 0, 3, 3, 3, 7  |\n+\n+         * Values array:\n+            * Length: 7, Null count: 0\n+            * Null bitmap buffer: Not required\n+\n+            * Value buffer:\n+\n+              | Bytes 0-6      |\n+              |----------------|\n+              | joemark        |\n+\n+      * field-1 array (int32 array):\n+        * Length: 4, Null count: 1\n+        * Null bitmap buffer:\n+\n+          | Byte 0 (validity bitmap) | Bytes 1-63            |\n+          |--------------------------|-----------------------|\n+          | 00001011                 | 0 (padding)           |\n+\n+        * Value Buffer:\n+\n+          |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-63 |\n+          |------------|-------------|-------------|-------------|-------------|\n+          | 1          | 2           | unspecified | 4           | unspecified |\n+\n+While a struct does not have physical storage for each of its semantic\n+slots (i.e. each scalar C-like struct), an entire struct slot can be\n+set to null via the null bitmap. Any of the child field arrays can\n+have null values according to their respective independent null\n+bitmaps. This implies that for a particular struct slot the null\n+bitmap for the struct array might indicate a null slot when one or\n+more of its child arrays has a non-null value in their corresponding\n+slot.  When reading the struct array the parent null bitmap is\n+authoritative.  This is illustrated in the example above, the child\n \n Review comment:\n   Should we say \"takes priority\" instead of \"is authoritative\"? The latter may induce that null bitmaps of child arrays are ignored...\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T15:20:32.955+0000",
                    "updated": "2019-08-27T15:20:32.955+0000",
                    "started": "2019-08-27T15:20:32.955+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "302070",
                    "issueId": "13214524"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/302071",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202#discussion_r318124726\n \n \n\n ##########\n File path: docs/source/format/Columnar.rst\n ##########\n @@ -0,0 +1,1266 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. _format_columnar:\n+\n+*********************\n+Arrow Columnar Format\n+*********************\n+\n+The \"Arrow Columnar Format\" includes a language-agnostic in-memory\n+data structure specification, metadata serialization, and a protocol\n+for serialization and generic data transport.\n+\n+This document is intended to provide adequate detail to create a new\n+implementation of the columnar format without the aid of an existing\n+implementation. We utilize Google's `Flatbuffers`_ project for\n+metadata serialization, so it will be necessary to refer to the\n+project's `Flatbuffers protocol definition files <FlatbuffersFiles>`_\n+while reading this document.\n+\n+The columnar format has some key features:\n+\n+* Data adjacency for sequential access (scans)\n+* O(1) (constant-time) random access\n+* SIMD and vectorization-friendly\n+* Relocatable without \"pointer swizzling\", allowing for true zero-copy\n+  access in shared memory\n+\n+Some things to keep in mind:\n+\n+* Some data types can be mutated in-place in memory, but others\n+  cannot. The community has made deliberate trade-offs regarding\n+  in-place mutability to provide analytical performance and data\n+  locality guarantees\n+\n+Terminology\n+===========\n+\n+Since different projects have used different words to describe various\n+concepts, here is a small glossary to help disambiguate.\n+\n+* **Array** or **Vector**: a sequence of values with known length all\n+  having the same type. These terms are used interchangeably in\n+  different Arrow implementations, but we use \"array\" in this\n+  document.\n+* **Slot**: a single logical value in an array of some particular data type\n+* **Buffer** or **Contiguous memory region**: a sequential virtual\n+  address space with a given length. Any byte can be reached via a\n+  single pointer offset less than the region's length.\n+* **Physical Layout type**: The underlying memory layout for an array\n+  without taking into account any value semantics. For example, a\n+  32-bit signed integer array and 32-bit floating point array have the\n+  same layout type.\n+* **Logical type**: An application-facing semantic value type that is\n+  implemented using some physical layout type. For example, Decimal\n+  values are stored as 16 bytes in a fixed-size binary\n+  layout. Similarly, strings can be stored as ``List<1-byte>``. A\n+  timestamp may be stored as 64-bit fixed-size layout.\n+* **Nested** or **parametric type**: a data type whose full structure\n+  depends on one or more other child types. Two fully-specified nested\n+  types are equal if and only if their child types are equal. For\n+  example, ``List<U>`` is distinct from ``List<V>`` iff U and V are\n+  different types.\n+* **Parent** and **child arrays**: names to express relationships\n+  between physical value arrays in a nested type structure. For\n+  example, a ``List<T>``-type parent array has a T-type array as its\n+  child (see more on lists below).\n+* **Leaf node** or **leaf**: A primitive value array that may or may\n+  not be a child array of some array with a nested type.\n+\n+Physical Memory Layout\n+======================\n+\n+Arrays are defined by a few pieces of metadata and data:\n+\n+* A logical data type\n+* A sequence of buffers\n+* A length as a 64-bit signed integer. Implementations are permitted\n+  to be limited to 32-bit lengths, see more on this below\n+* A null count as a 64-bit signed integer\n+* An optional **dictionary**, for dictionary-encoded arrays\n+\n+Nested arrays additionally have a sequence of one or more sets of\n+these items, called the **child arrays**.\n+\n+Each logical data type has a well-defined physical layout. Here are\n+the different physical layouts defined by Arrow:\n+\n+* **Primitive (fixed-size)**: a sequence of values each having the\n+  same byte or bit width\n+* **Variable-size Binary**: a sequence of values each having a variable\n+  byte length. Two variants of this layout are supported using 32-bit\n+  and 64-bit length encoding.\n+* **Fixed-size List**: a nested layout each each value has the same\n+  number of elements taken from a child data type.\n+* **Variable-size List**: a nested layout type where each value is a\n+  variable-length sequence of values taken from a child data type. Two\n+  variants of this layout are supported using 32-bit and 64-bit length\n+  encoding.\n+* **Struct**: a nested layout type consisting of a collection of child\n+  **fields** each having the same length\n+* **Sparse** and **Dense Union**: a nested layout type representing a\n+  sequence of values, each of which can have type chosen from a\n+  collection of child array types.\n+* **Null**: a sequence of all null values, having null logical type\n+\n+Buffer Alignment and Padding\n+----------------------------\n+\n+Implementations are recommended allocate memory on aligned (8- or\n+64-byte boundaries) and pad (overallocate) to a length that is a\n+multiple of 8 or 64 bytes. When serializing Arrow data for\n+interprocess communication, these alignment and padding requirements\n+are enforced. If possible, we suggest that you prefer using 64-byte\n+alignment and padding. Unless otherwise noted, padded bytes do not\n+need to have a specific value.\n+\n+The alignment requirement follows best practices for optimized memory\n+access:\n+\n+* Elements in numeric arrays will be guaranteed to be retrieved via aligned access.\n+* On some architectures alignment can help limit partially used cache lines.\n+\n+The recommendation for 64 byte alignment comes from the `Intel\n+performance guide`_ that recommends alignment of memory to match SIMD\n+register width.  The specific padding length was chosen because it\n+matches the largest known SIMD instruction registers available as of\n+April 2016 (Intel AVX-512).\n+\n+The recommended padding of 64 bytes allows for using `SIMD`_\n+instructions consistently in loops without additional conditional\n+checks.  This should allow for simpler, efficient and CPU\n+cache-friendly code.  In other words, we can load the entire 64-byte\n+buffer into a 512-bit wide SIMD register and get data-level\n+parallelism on all the columnar values packed into the 64-byte\n+buffer. Guaranteed padding can also allow certain compilers to\n+generate more optimized code directly (e.g. One can safely use Intel's\n+``-qopt-assume-safe-padding``).\n+\n+Byte Order (`Endianness`_)\n+---------------------------\n+\n+The Arrow format is little endian by default.\n+\n+Serialized Schema metadata has an endianness field indicating\n+endianness of RecordBatches. Typically this is the endianness of the\n+system where the RecordBatch was generated. The main use case is\n+exchanging RecordBatches between systems with the same Endianness.  At\n+first we will return an error when trying to read a Schema with an\n+endianness that does not match the underlying system. The reference\n+implementation is focused on Little Endian and provides tests for\n+it. Eventually we may provide automatic conversion via byte swapping.\n+\n+Array lengths\n+-------------\n+\n+Array lengths are represented in the Arrow metadata as a 64-bit signed\n+integer. An implementation of Arrow is considered valid even if it only\n+supports lengths up to the maximum 32-bit signed integer, though. If using\n+Arrow in a multi-language environment, we recommend limiting lengths to\n+2 :sup:`31` - 1 elements or less. Larger data sets can be represented using\n+multiple array chunks.\n+\n+Null count\n+----------\n+\n+The number of null value slots is a property of the physical array and\n+considered part of the data structure. The null count is represented\n+in the Arrow metadata as a 64-bit signed integer, as it may be as\n+large as the array length.\n+\n+Validity bitmaps\n+----------------\n+\n+Any type can have null value slots, whether primitive or nested type.\n+\n+An array with nulls must have a contiguous memory buffer, known as the\n+validity (or \"null\") bitmap, large enough to have at least 1 bit for\n+each array slot.\n+\n+Whether any array slot is valid (non-null) is encoded in the respective bits of\n+this bitmap. A 1 (set bit) for index ``j`` indicates that the value is not null,\n+while a 0 (bit not set) indicates that it is null. Bitmaps are to be\n+initialized to be all unset at allocation time (this includes padding).::\n+\n+    is_valid[j] -> bitmap[j / 8] & (1 << (j % 8))\n+\n+We use `least-significant bit (LSB) numbering`_ (also known as\n+bit-endianness). This means that within a group of 8 bits, we read\n+right-to-left: ::\n+\n+    values = [0, 1, null, 2, null, 3]\n+\n+    bitmap\n+    j mod 8   7  6  5  4  3  2  1  0\n+              0  0  1  0  1  0  1  1\n+\n+Arrays having a 0 null count may choose to not allocate the null\n+bitmap. Implementations may choose to always allocate one anyway as a matter of\n+convenience, but this should be noted when memory is being shared.\n+\n+Nested type arrays have their own null bitmap and null count regardless of\n+the null count and null bits of their child arrays.\n+\n+Primitive\n+---------\n+\n+A primitive value array represents a fixed-length array of values each having\n+the same physical slot width typically measured in bytes, though the spec also\n+provides for bit-packed types (e.g. boolean values encoded in bits).\n+\n+Internally, the array contains a contiguous memory buffer whose total size is\n+equal to the slot width multiplied by the array length. For bit-packed types,\n+the size is rounded up to the nearest byte.\n+\n+The associated null bitmap is contiguously allocated (as described above) but\n+does not need to be adjacent in memory to the values buffer.\n+\n+**Example Layout: Int32 Array**\n+\n+For example a primitive array of int32s: ::\n+\n+    [1, null, 2, 4, 8]\n+\n+Would look like: ::\n+\n+    * Length: 5, Null count: 1\n+    * Null bitmap buffer:\n+\n+      |Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |-------------------------|-----------------------|\n+      | 00011101                | 0 (padding)           |\n+\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | unspecified | 2           | 4           | 8           | unspecified |\n+\n+**Example Layout: Non-null int32 Array**\n+\n+``[1, 2, 3, 4, 8]`` has two possible layouts: ::\n+\n+    * Length: 5, Null count: 0\n+    * Null bitmap buffer:\n+\n+      | Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |--------------------------|-----------------------|\n+      | 00011111                 | 0 (padding)           |\n+\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | bytes 12-15 | bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | 2           | 3           | 4           | 8           | unspecified |\n+\n+or with the bitmap elided: ::\n+\n+    * Length 5, Null count: 0\n+    * Null bitmap buffer: Not required\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | bytes 12-15 | bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | 2           | 3           | 4           | 8           | unspecified |\n+\n+Variable-size\n+-------------\n+\n+Each value in this layout type consists of 0 or more bytes. While\n+primitive arrays have a single values buffer, variable-size binary\n+have an **offsets** buffer and **data** buffer\n+\n+The offsets buffer contains `length + 1` signed integers (either\n+32-bit or 64-bit), which encode the start position of each element in\n+the data buffer. The length of the value in each slot is computed\n+using the first difference with the next element in the offsets\n+array. For example, the position and length of slot j is computed as:\n+\n+::\n+\n+    slot_position = offsets[j]\n+    slot_length = offsets[j + 1] - offsets[j]  // (for 0 <= j < length)\n+\n+Generally the first value in the offsets array is 0, and the last\n+element is the length of the values array.\n+\n+Variable-size List\n+------------------\n+\n+List is a nested type which is semantically similar to variable-size\n+binary. It is defined by two buffers: a validity bitmap and an offsets\n+buffer. The offsets are the same as in the variable-size binary case,\n+and both 32-bit and 64-bit signed integer offsets are\n+supported. Rather than referencing an additional data buffer, instead\n+these offsets reference a child array having any type.\n+\n+A list type is specified like ``List<T>``, where ``T`` is any type\n+(primitive or nested).\n+\n+**Example Layout: ``List<Char>`` Array**\n+\n+We illustrate ``List<Int8>``.\n+\n+For an array of length 4 with respective values: ::\n+\n+    [[12, -7, 25], null, [0, -127, 127, 50], []]\n+\n+will have the following representation: ::\n+\n+    * Length: 4, Null count: 1\n+    * Null bitmap buffer:\n+\n+      | Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |--------------------------|-----------------------|\n+      | 00001101                 | 0 (padding)           |\n+\n+    * Offsets buffer (int32)\n+\n+      | Bytes 0-3  | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 0          | 3           | 3           | 7           | 7           | unspecified |\n+\n+    * Values array (Int8array):\n+      * Length: 7,  Null count: 0\n+      * Null bitmap buffer: Not required\n+\n+        | Bytes 0-6                   | Bytes 7-63  |\n+        |-----------------------------|-------------|\n+        | 12, 7, 25, 0, -127, 127, 50 | unspecified |\n+\n+**Example Layout: ``List<List<Int8>>``**\n+\n+``[[[1, 2], [3, 4]], [[5, 6, 7], null, [8]], [[9, 10]]]``\n+\n+will be represented as follows: ::\n+\n+    * Length 3\n+    * Nulls count: 0\n+    * Null bitmap buffer: Not required\n+    * Offsets buffer (int32)\n+\n+      | Bytes 0-3  | Bytes 4-7  | Bytes 8-11 | Bytes 12-15 | Bytes 16-63 |\n+      |------------|------------|------------|-------------|-------------|\n+      | 0          |  2         |  5         |  6          | unspecified |\n+\n+    * Values array (`List<Int8>`)\n+      * Length: 6, Null count: 1\n+      * Null bitmap buffer:\n+\n+        | Byte 0 (validity bitmap) | Bytes 1-63  |\n+        |--------------------------|-------------|\n+        | 00110111                 | 0 (padding) |\n+\n+      * Offsets buffer (int32)\n+\n+        | Bytes 0-27           | Bytes 28-63 |\n+        |----------------------|-------------|\n+        | 0, 2, 4, 7, 7, 8, 10 | unspecified |\n+\n+      * Values array (Int8):\n+        * Length: 10, Null count: 0\n+        * Null bitmap buffer: Not required\n+\n+          | Bytes 0-9                     | Bytes 10-63 |\n+          |-------------------------------|-------------|\n+          | 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 | unspecified |\n+\n+Note that while the inner offsets buffer encodes the start position in\n+the inner values array, the outer offsets buffer encodes the start\n+position of corresponding outer element in the inner offsets buffer.\n+\n+Fixed-Size List\n+---------------\n+\n+Fixed-Size List is a nested type in which each array slot contains a\n+fixed-size sequence of values all having the same type (heterogeneity\n+can be achieved through unions, described later).\n+\n+A fixed size list type is specified like ``FixedSizeList<T>[N]``,\n+where ``T`` is any type (primitive or nested) and ``N`` is a 32-bit\n+signed integer representing the length of the lists.\n+\n+A fixed size list array is represented by a values array, which is a\n+child array of type T. T may also be a nested type. The value in slot\n+``j`` of a fixed size list array is stored in an ``N``-long slice of\n+the values array, starting at an offset of ``j * N``.\n+\n+**Example Layout: ``FixedSizeList<byte>[4]`` Array**\n+\n+Here we illustrate ``FixedSizeList<byte>[4]``.\n+\n+For an array of length 4 with respective values: ::\n+\n+    [[192, 168, 0, 12], null, [192, 168, 0, 25], [192, 168, 0, 1]]\n+\n+will have the following representation: ::\n+\n+    * Length: 4, Null count: 1\n+    * Null bitmap buffer:\n+\n+      | Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |--------------------------|-----------------------|\n+      | 00001101                 | 0 (padding)           |\n+\n+    * Values array (byte array):\n+      * Length: 16,  Null count: 0\n+      * Null bitmap buffer: Not required\n+\n+        | Bytes 0-3       | Bytes 4-7   | Bytes 8-15                      |\n+        |-----------------|-------------|---------------------------------|\n+        | 192, 168, 0, 12 | unspecified | 192, 168, 0, 25, 192, 168, 0, 1 |\n+\n+\n+Struct\n+------\n+\n+A struct is a nested type parameterized by an ordered sequence of\n+types (which can all be distinct), called its fields. Typically the\n+fields have names, but the names and their types are part of the type\n+metadata, not the physical memory layout.\n+\n+A struct array does not have any additional allocated physical storage\n+for its values.  A struct array must still have an allocated null\n+bitmap, if it has one or more null values.\n+\n+Physically, a struct type has one child array for each field. The\n+child arrays are independent and need not be adjacent to each other in\n+memory.\n+\n+For example, the struct (field names shown here as strings for illustration\n+purposes)::\n+\n+    Struct <\n+      name: String (= List<char>),\n+      age: Int32\n+    >\n+\n+has two child arrays, one ``List<char>`` array (layout as above) and one 4-byte\n+primitive value array having ``Int32`` logical type.\n+\n+**Example Layout: ``Struct<List<char>, Int32>``**\n+\n+The layout for ``[{'joe', 1}, {null, 2}, null, {'mark', 4}]`` would be: ::\n+\n+    * Length: 4, Null count: 1\n+    * Null bitmap buffer:\n+\n+      |Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |-------------------------|-----------------------|\n+      | 00001011                | 0 (padding)           |\n+\n+    * Children arrays:\n+      * field-0 array (`List<char>`):\n+        * Length: 4, Null count: 2\n+        * Null bitmap buffer:\n+\n+          | Byte 0 (validity bitmap) | Bytes 1-63            |\n+          |--------------------------|-----------------------|\n+          | 00001001                 | 0 (padding)           |\n+\n+        * Offsets buffer:\n+\n+          | Bytes 0-19     |\n+          |----------------|\n+          | 0, 3, 3, 3, 7  |\n+\n+         * Values array:\n+            * Length: 7, Null count: 0\n+            * Null bitmap buffer: Not required\n+\n+            * Value buffer:\n+\n+              | Bytes 0-6      |\n+              |----------------|\n+              | joemark        |\n+\n+      * field-1 array (int32 array):\n+        * Length: 4, Null count: 1\n+        * Null bitmap buffer:\n+\n+          | Byte 0 (validity bitmap) | Bytes 1-63            |\n+          |--------------------------|-----------------------|\n+          | 00001011                 | 0 (padding)           |\n+\n+        * Value Buffer:\n+\n+          |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-63 |\n+          |------------|-------------|-------------|-------------|-------------|\n+          | 1          | 2           | unspecified | 4           | unspecified |\n+\n+While a struct does not have physical storage for each of its semantic\n+slots (i.e. each scalar C-like struct), an entire struct slot can be\n+set to null via the null bitmap. Any of the child field arrays can\n+have null values according to their respective independent null\n+bitmaps. This implies that for a particular struct slot the null\n+bitmap for the struct array might indicate a null slot when one or\n+more of its child arrays has a non-null value in their corresponding\n+slot.  When reading the struct array the parent null bitmap is\n+authoritative.  This is illustrated in the example above, the child\n+arrays have valid entries for the null struct but are 'hidden' from\n+the consumer by the parent array's null bitmap.  However, when treated\n+independently corresponding values of the children array will be\n+non-null.\n+\n+Dense Union\n+-----------\n+\n+A dense union is semantically similar to a struct, and contains an\n+ordered sequence of types. While a struct contains multiple arrays, a\n+union is semantically a single array in which each slot can have a\n+different type.\n \n Review comment:\n   \"can have one of the child types of the union\"?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T15:20:33.040+0000",
                    "updated": "2019-08-27T15:20:33.040+0000",
                    "started": "2019-08-27T15:20:33.040+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "302071",
                    "issueId": "13214524"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/302072",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202#discussion_r318124387\n \n \n\n ##########\n File path: docs/source/format/Columnar.rst\n ##########\n @@ -0,0 +1,1266 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. _format_columnar:\n+\n+*********************\n+Arrow Columnar Format\n+*********************\n+\n+The \"Arrow Columnar Format\" includes a language-agnostic in-memory\n+data structure specification, metadata serialization, and a protocol\n+for serialization and generic data transport.\n+\n+This document is intended to provide adequate detail to create a new\n+implementation of the columnar format without the aid of an existing\n+implementation. We utilize Google's `Flatbuffers`_ project for\n+metadata serialization, so it will be necessary to refer to the\n+project's `Flatbuffers protocol definition files <FlatbuffersFiles>`_\n+while reading this document.\n+\n+The columnar format has some key features:\n+\n+* Data adjacency for sequential access (scans)\n+* O(1) (constant-time) random access\n+* SIMD and vectorization-friendly\n+* Relocatable without \"pointer swizzling\", allowing for true zero-copy\n+  access in shared memory\n+\n+Some things to keep in mind:\n+\n+* Some data types can be mutated in-place in memory, but others\n+  cannot. The community has made deliberate trade-offs regarding\n+  in-place mutability to provide analytical performance and data\n+  locality guarantees\n+\n+Terminology\n+===========\n+\n+Since different projects have used different words to describe various\n+concepts, here is a small glossary to help disambiguate.\n+\n+* **Array** or **Vector**: a sequence of values with known length all\n+  having the same type. These terms are used interchangeably in\n+  different Arrow implementations, but we use \"array\" in this\n+  document.\n+* **Slot**: a single logical value in an array of some particular data type\n+* **Buffer** or **Contiguous memory region**: a sequential virtual\n+  address space with a given length. Any byte can be reached via a\n+  single pointer offset less than the region's length.\n+* **Physical Layout type**: The underlying memory layout for an array\n+  without taking into account any value semantics. For example, a\n+  32-bit signed integer array and 32-bit floating point array have the\n+  same layout type.\n+* **Logical type**: An application-facing semantic value type that is\n+  implemented using some physical layout type. For example, Decimal\n+  values are stored as 16 bytes in a fixed-size binary\n+  layout. Similarly, strings can be stored as ``List<1-byte>``. A\n+  timestamp may be stored as 64-bit fixed-size layout.\n+* **Nested** or **parametric type**: a data type whose full structure\n+  depends on one or more other child types. Two fully-specified nested\n+  types are equal if and only if their child types are equal. For\n+  example, ``List<U>`` is distinct from ``List<V>`` iff U and V are\n+  different types.\n+* **Parent** and **child arrays**: names to express relationships\n+  between physical value arrays in a nested type structure. For\n+  example, a ``List<T>``-type parent array has a T-type array as its\n+  child (see more on lists below).\n+* **Leaf node** or **leaf**: A primitive value array that may or may\n+  not be a child array of some array with a nested type.\n+\n+Physical Memory Layout\n+======================\n+\n+Arrays are defined by a few pieces of metadata and data:\n+\n+* A logical data type\n+* A sequence of buffers\n+* A length as a 64-bit signed integer. Implementations are permitted\n+  to be limited to 32-bit lengths, see more on this below\n+* A null count as a 64-bit signed integer\n+* An optional **dictionary**, for dictionary-encoded arrays\n+\n+Nested arrays additionally have a sequence of one or more sets of\n+these items, called the **child arrays**.\n+\n+Each logical data type has a well-defined physical layout. Here are\n+the different physical layouts defined by Arrow:\n+\n+* **Primitive (fixed-size)**: a sequence of values each having the\n+  same byte or bit width\n+* **Variable-size Binary**: a sequence of values each having a variable\n+  byte length. Two variants of this layout are supported using 32-bit\n+  and 64-bit length encoding.\n+* **Fixed-size List**: a nested layout each each value has the same\n+  number of elements taken from a child data type.\n+* **Variable-size List**: a nested layout type where each value is a\n+  variable-length sequence of values taken from a child data type. Two\n+  variants of this layout are supported using 32-bit and 64-bit length\n+  encoding.\n+* **Struct**: a nested layout type consisting of a collection of child\n+  **fields** each having the same length\n+* **Sparse** and **Dense Union**: a nested layout type representing a\n+  sequence of values, each of which can have type chosen from a\n+  collection of child array types.\n+* **Null**: a sequence of all null values, having null logical type\n+\n+Buffer Alignment and Padding\n+----------------------------\n+\n+Implementations are recommended allocate memory on aligned (8- or\n+64-byte boundaries) and pad (overallocate) to a length that is a\n+multiple of 8 or 64 bytes. When serializing Arrow data for\n+interprocess communication, these alignment and padding requirements\n+are enforced. If possible, we suggest that you prefer using 64-byte\n+alignment and padding. Unless otherwise noted, padded bytes do not\n+need to have a specific value.\n+\n+The alignment requirement follows best practices for optimized memory\n+access:\n+\n+* Elements in numeric arrays will be guaranteed to be retrieved via aligned access.\n+* On some architectures alignment can help limit partially used cache lines.\n+\n+The recommendation for 64 byte alignment comes from the `Intel\n+performance guide`_ that recommends alignment of memory to match SIMD\n+register width.  The specific padding length was chosen because it\n+matches the largest known SIMD instruction registers available as of\n+April 2016 (Intel AVX-512).\n+\n+The recommended padding of 64 bytes allows for using `SIMD`_\n+instructions consistently in loops without additional conditional\n+checks.  This should allow for simpler, efficient and CPU\n+cache-friendly code.  In other words, we can load the entire 64-byte\n+buffer into a 512-bit wide SIMD register and get data-level\n+parallelism on all the columnar values packed into the 64-byte\n+buffer. Guaranteed padding can also allow certain compilers to\n+generate more optimized code directly (e.g. One can safely use Intel's\n+``-qopt-assume-safe-padding``).\n+\n+Byte Order (`Endianness`_)\n+---------------------------\n+\n+The Arrow format is little endian by default.\n+\n+Serialized Schema metadata has an endianness field indicating\n+endianness of RecordBatches. Typically this is the endianness of the\n+system where the RecordBatch was generated. The main use case is\n+exchanging RecordBatches between systems with the same Endianness.  At\n+first we will return an error when trying to read a Schema with an\n+endianness that does not match the underlying system. The reference\n+implementation is focused on Little Endian and provides tests for\n+it. Eventually we may provide automatic conversion via byte swapping.\n+\n+Array lengths\n+-------------\n+\n+Array lengths are represented in the Arrow metadata as a 64-bit signed\n+integer. An implementation of Arrow is considered valid even if it only\n+supports lengths up to the maximum 32-bit signed integer, though. If using\n+Arrow in a multi-language environment, we recommend limiting lengths to\n+2 :sup:`31` - 1 elements or less. Larger data sets can be represented using\n+multiple array chunks.\n+\n+Null count\n+----------\n+\n+The number of null value slots is a property of the physical array and\n+considered part of the data structure. The null count is represented\n+in the Arrow metadata as a 64-bit signed integer, as it may be as\n+large as the array length.\n+\n+Validity bitmaps\n+----------------\n+\n+Any type can have null value slots, whether primitive or nested type.\n+\n+An array with nulls must have a contiguous memory buffer, known as the\n+validity (or \"null\") bitmap, large enough to have at least 1 bit for\n+each array slot.\n+\n+Whether any array slot is valid (non-null) is encoded in the respective bits of\n+this bitmap. A 1 (set bit) for index ``j`` indicates that the value is not null,\n+while a 0 (bit not set) indicates that it is null. Bitmaps are to be\n+initialized to be all unset at allocation time (this includes padding).::\n+\n+    is_valid[j] -> bitmap[j / 8] & (1 << (j % 8))\n+\n+We use `least-significant bit (LSB) numbering`_ (also known as\n+bit-endianness). This means that within a group of 8 bits, we read\n+right-to-left: ::\n+\n+    values = [0, 1, null, 2, null, 3]\n+\n+    bitmap\n+    j mod 8   7  6  5  4  3  2  1  0\n+              0  0  1  0  1  0  1  1\n+\n+Arrays having a 0 null count may choose to not allocate the null\n+bitmap. Implementations may choose to always allocate one anyway as a matter of\n+convenience, but this should be noted when memory is being shared.\n+\n+Nested type arrays have their own null bitmap and null count regardless of\n+the null count and null bits of their child arrays.\n+\n+Primitive\n+---------\n+\n+A primitive value array represents a fixed-length array of values each having\n+the same physical slot width typically measured in bytes, though the spec also\n+provides for bit-packed types (e.g. boolean values encoded in bits).\n+\n+Internally, the array contains a contiguous memory buffer whose total size is\n+equal to the slot width multiplied by the array length. For bit-packed types,\n+the size is rounded up to the nearest byte.\n+\n+The associated null bitmap is contiguously allocated (as described above) but\n+does not need to be adjacent in memory to the values buffer.\n+\n+**Example Layout: Int32 Array**\n+\n+For example a primitive array of int32s: ::\n+\n+    [1, null, 2, 4, 8]\n+\n+Would look like: ::\n+\n+    * Length: 5, Null count: 1\n+    * Null bitmap buffer:\n+\n+      |Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |-------------------------|-----------------------|\n+      | 00011101                | 0 (padding)           |\n+\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | unspecified | 2           | 4           | 8           | unspecified |\n+\n+**Example Layout: Non-null int32 Array**\n+\n+``[1, 2, 3, 4, 8]`` has two possible layouts: ::\n+\n+    * Length: 5, Null count: 0\n+    * Null bitmap buffer:\n+\n+      | Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |--------------------------|-----------------------|\n+      | 00011111                 | 0 (padding)           |\n+\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | bytes 12-15 | bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | 2           | 3           | 4           | 8           | unspecified |\n+\n+or with the bitmap elided: ::\n+\n+    * Length 5, Null count: 0\n+    * Null bitmap buffer: Not required\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | bytes 12-15 | bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | 2           | 3           | 4           | 8           | unspecified |\n+\n+Variable-size\n+-------------\n+\n+Each value in this layout type consists of 0 or more bytes. While\n+primitive arrays have a single values buffer, variable-size binary\n+have an **offsets** buffer and **data** buffer\n+\n+The offsets buffer contains `length + 1` signed integers (either\n+32-bit or 64-bit), which encode the start position of each element in\n+the data buffer. The length of the value in each slot is computed\n+using the first difference with the next element in the offsets\n+array. For example, the position and length of slot j is computed as:\n+\n+::\n+\n+    slot_position = offsets[j]\n+    slot_length = offsets[j + 1] - offsets[j]  // (for 0 <= j < length)\n+\n+Generally the first value in the offsets array is 0, and the last\n+element is the length of the values array.\n+\n+Variable-size List\n+------------------\n+\n+List is a nested type which is semantically similar to variable-size\n+binary. It is defined by two buffers: a validity bitmap and an offsets\n+buffer. The offsets are the same as in the variable-size binary case,\n+and both 32-bit and 64-bit signed integer offsets are\n+supported. Rather than referencing an additional data buffer, instead\n+these offsets reference a child array having any type.\n+\n+A list type is specified like ``List<T>``, where ``T`` is any type\n+(primitive or nested).\n+\n+**Example Layout: ``List<Char>`` Array**\n+\n+We illustrate ``List<Int8>``.\n+\n+For an array of length 4 with respective values: ::\n+\n+    [[12, -7, 25], null, [0, -127, 127, 50], []]\n+\n+will have the following representation: ::\n+\n+    * Length: 4, Null count: 1\n+    * Null bitmap buffer:\n+\n+      | Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |--------------------------|-----------------------|\n+      | 00001101                 | 0 (padding)           |\n+\n+    * Offsets buffer (int32)\n+\n+      | Bytes 0-3  | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 0          | 3           | 3           | 7           | 7           | unspecified |\n+\n+    * Values array (Int8array):\n+      * Length: 7,  Null count: 0\n+      * Null bitmap buffer: Not required\n+\n+        | Bytes 0-6                   | Bytes 7-63  |\n+        |-----------------------------|-------------|\n+        | 12, 7, 25, 0, -127, 127, 50 | unspecified |\n+\n+**Example Layout: ``List<List<Int8>>``**\n+\n+``[[[1, 2], [3, 4]], [[5, 6, 7], null, [8]], [[9, 10]]]``\n+\n+will be represented as follows: ::\n+\n+    * Length 3\n+    * Nulls count: 0\n+    * Null bitmap buffer: Not required\n+    * Offsets buffer (int32)\n+\n+      | Bytes 0-3  | Bytes 4-7  | Bytes 8-11 | Bytes 12-15 | Bytes 16-63 |\n+      |------------|------------|------------|-------------|-------------|\n+      | 0          |  2         |  5         |  6          | unspecified |\n+\n+    * Values array (`List<Int8>`)\n+      * Length: 6, Null count: 1\n+      * Null bitmap buffer:\n+\n+        | Byte 0 (validity bitmap) | Bytes 1-63  |\n+        |--------------------------|-------------|\n+        | 00110111                 | 0 (padding) |\n+\n+      * Offsets buffer (int32)\n+\n+        | Bytes 0-27           | Bytes 28-63 |\n+        |----------------------|-------------|\n+        | 0, 2, 4, 7, 7, 8, 10 | unspecified |\n+\n+      * Values array (Int8):\n+        * Length: 10, Null count: 0\n+        * Null bitmap buffer: Not required\n+\n+          | Bytes 0-9                     | Bytes 10-63 |\n+          |-------------------------------|-------------|\n+          | 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 | unspecified |\n+\n+Note that while the inner offsets buffer encodes the start position in\n+the inner values array, the outer offsets buffer encodes the start\n+position of corresponding outer element in the inner offsets buffer.\n+\n+Fixed-Size List\n+---------------\n+\n+Fixed-Size List is a nested type in which each array slot contains a\n+fixed-size sequence of values all having the same type (heterogeneity\n+can be achieved through unions, described later).\n+\n+A fixed size list type is specified like ``FixedSizeList<T>[N]``,\n+where ``T`` is any type (primitive or nested) and ``N`` is a 32-bit\n+signed integer representing the length of the lists.\n+\n+A fixed size list array is represented by a values array, which is a\n+child array of type T. T may also be a nested type. The value in slot\n+``j`` of a fixed size list array is stored in an ``N``-long slice of\n+the values array, starting at an offset of ``j * N``.\n+\n+**Example Layout: ``FixedSizeList<byte>[4]`` Array**\n+\n+Here we illustrate ``FixedSizeList<byte>[4]``.\n+\n+For an array of length 4 with respective values: ::\n+\n+    [[192, 168, 0, 12], null, [192, 168, 0, 25], [192, 168, 0, 1]]\n+\n+will have the following representation: ::\n+\n+    * Length: 4, Null count: 1\n+    * Null bitmap buffer:\n+\n+      | Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |--------------------------|-----------------------|\n+      | 00001101                 | 0 (padding)           |\n+\n+    * Values array (byte array):\n+      * Length: 16,  Null count: 0\n+      * Null bitmap buffer: Not required\n+\n+        | Bytes 0-3       | Bytes 4-7   | Bytes 8-15                      |\n+        |-----------------|-------------|---------------------------------|\n+        | 192, 168, 0, 12 | unspecified | 192, 168, 0, 25, 192, 168, 0, 1 |\n+\n+\n+Struct\n+------\n+\n+A struct is a nested type parameterized by an ordered sequence of\n+types (which can all be distinct), called its fields. Typically the\n+fields have names, but the names and their types are part of the type\n+metadata, not the physical memory layout.\n+\n+A struct array does not have any additional allocated physical storage\n+for its values.  A struct array must still have an allocated null\n+bitmap, if it has one or more null values.\n+\n+Physically, a struct type has one child array for each field. The\n+child arrays are independent and need not be adjacent to each other in\n+memory.\n+\n+For example, the struct (field names shown here as strings for illustration\n+purposes)::\n+\n+    Struct <\n+      name: String (= List<char>),\n+      age: Int32\n+    >\n+\n+has two child arrays, one ``List<char>`` array (layout as above) and one 4-byte\n+primitive value array having ``Int32`` logical type.\n+\n+**Example Layout: ``Struct<List<char>, Int32>``**\n+\n+The layout for ``[{'joe', 1}, {null, 2}, null, {'mark', 4}]`` would be: ::\n+\n+    * Length: 4, Null count: 1\n+    * Null bitmap buffer:\n+\n+      |Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |-------------------------|-----------------------|\n+      | 00001011                | 0 (padding)           |\n+\n+    * Children arrays:\n+      * field-0 array (`List<char>`):\n+        * Length: 4, Null count: 2\n+        * Null bitmap buffer:\n+\n+          | Byte 0 (validity bitmap) | Bytes 1-63            |\n+          |--------------------------|-----------------------|\n+          | 00001001                 | 0 (padding)           |\n+\n+        * Offsets buffer:\n+\n+          | Bytes 0-19     |\n+          |----------------|\n+          | 0, 3, 3, 3, 7  |\n+\n+         * Values array:\n+            * Length: 7, Null count: 0\n+            * Null bitmap buffer: Not required\n+\n+            * Value buffer:\n+\n+              | Bytes 0-6      |\n+              |----------------|\n+              | joemark        |\n+\n+      * field-1 array (int32 array):\n+        * Length: 4, Null count: 1\n+        * Null bitmap buffer:\n+\n+          | Byte 0 (validity bitmap) | Bytes 1-63            |\n+          |--------------------------|-----------------------|\n+          | 00001011                 | 0 (padding)           |\n+\n+        * Value Buffer:\n+\n+          |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-63 |\n+          |------------|-------------|-------------|-------------|-------------|\n+          | 1          | 2           | unspecified | 4           | unspecified |\n+\n+While a struct does not have physical storage for each of its semantic\n+slots (i.e. each scalar C-like struct), an entire struct slot can be\n+set to null via the null bitmap. Any of the child field arrays can\n+have null values according to their respective independent null\n+bitmaps. This implies that for a particular struct slot the null\n+bitmap for the struct array might indicate a null slot when one or\n+more of its child arrays has a non-null value in their corresponding\n+slot.  When reading the struct array the parent null bitmap is\n+authoritative.  This is illustrated in the example above, the child\n+arrays have valid entries for the null struct but are 'hidden' from\n+the consumer by the parent array's null bitmap.  However, when treated\n+independently corresponding values of the children array will be\n+non-null.\n+\n+Dense Union\n+-----------\n+\n+A dense union is semantically similar to a struct, and contains an\n \n Review comment:\n   I find it weird to say that they're semantically similar.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T15:20:33.043+0000",
                    "updated": "2019-08-27T15:20:33.043+0000",
                    "started": "2019-08-27T15:20:33.043+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "302072",
                    "issueId": "13214524"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/302073",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202#discussion_r318134487\n \n \n\n ##########\n File path: docs/source/format/Columnar.rst\n ##########\n @@ -0,0 +1,1266 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. _format_columnar:\n+\n+*********************\n+Arrow Columnar Format\n+*********************\n+\n+The \"Arrow Columnar Format\" includes a language-agnostic in-memory\n+data structure specification, metadata serialization, and a protocol\n+for serialization and generic data transport.\n+\n+This document is intended to provide adequate detail to create a new\n+implementation of the columnar format without the aid of an existing\n+implementation. We utilize Google's `Flatbuffers`_ project for\n+metadata serialization, so it will be necessary to refer to the\n+project's `Flatbuffers protocol definition files <FlatbuffersFiles>`_\n+while reading this document.\n+\n+The columnar format has some key features:\n+\n+* Data adjacency for sequential access (scans)\n+* O(1) (constant-time) random access\n+* SIMD and vectorization-friendly\n+* Relocatable without \"pointer swizzling\", allowing for true zero-copy\n+  access in shared memory\n+\n+Some things to keep in mind:\n+\n+* Some data types can be mutated in-place in memory, but others\n+  cannot. The community has made deliberate trade-offs regarding\n+  in-place mutability to provide analytical performance and data\n+  locality guarantees\n+\n+Terminology\n+===========\n+\n+Since different projects have used different words to describe various\n+concepts, here is a small glossary to help disambiguate.\n+\n+* **Array** or **Vector**: a sequence of values with known length all\n+  having the same type. These terms are used interchangeably in\n+  different Arrow implementations, but we use \"array\" in this\n+  document.\n+* **Slot**: a single logical value in an array of some particular data type\n+* **Buffer** or **Contiguous memory region**: a sequential virtual\n+  address space with a given length. Any byte can be reached via a\n+  single pointer offset less than the region's length.\n+* **Physical Layout type**: The underlying memory layout for an array\n+  without taking into account any value semantics. For example, a\n+  32-bit signed integer array and 32-bit floating point array have the\n+  same layout type.\n+* **Logical type**: An application-facing semantic value type that is\n+  implemented using some physical layout type. For example, Decimal\n+  values are stored as 16 bytes in a fixed-size binary\n+  layout. Similarly, strings can be stored as ``List<1-byte>``. A\n+  timestamp may be stored as 64-bit fixed-size layout.\n+* **Nested** or **parametric type**: a data type whose full structure\n+  depends on one or more other child types. Two fully-specified nested\n+  types are equal if and only if their child types are equal. For\n+  example, ``List<U>`` is distinct from ``List<V>`` iff U and V are\n+  different types.\n+* **Parent** and **child arrays**: names to express relationships\n+  between physical value arrays in a nested type structure. For\n+  example, a ``List<T>``-type parent array has a T-type array as its\n+  child (see more on lists below).\n+* **Leaf node** or **leaf**: A primitive value array that may or may\n+  not be a child array of some array with a nested type.\n+\n+Physical Memory Layout\n+======================\n+\n+Arrays are defined by a few pieces of metadata and data:\n+\n+* A logical data type\n+* A sequence of buffers\n+* A length as a 64-bit signed integer. Implementations are permitted\n+  to be limited to 32-bit lengths, see more on this below\n+* A null count as a 64-bit signed integer\n+* An optional **dictionary**, for dictionary-encoded arrays\n+\n+Nested arrays additionally have a sequence of one or more sets of\n+these items, called the **child arrays**.\n+\n+Each logical data type has a well-defined physical layout. Here are\n+the different physical layouts defined by Arrow:\n+\n+* **Primitive (fixed-size)**: a sequence of values each having the\n+  same byte or bit width\n+* **Variable-size Binary**: a sequence of values each having a variable\n+  byte length. Two variants of this layout are supported using 32-bit\n+  and 64-bit length encoding.\n+* **Fixed-size List**: a nested layout each each value has the same\n+  number of elements taken from a child data type.\n+* **Variable-size List**: a nested layout type where each value is a\n+  variable-length sequence of values taken from a child data type. Two\n+  variants of this layout are supported using 32-bit and 64-bit length\n+  encoding.\n+* **Struct**: a nested layout type consisting of a collection of child\n+  **fields** each having the same length\n+* **Sparse** and **Dense Union**: a nested layout type representing a\n+  sequence of values, each of which can have type chosen from a\n+  collection of child array types.\n+* **Null**: a sequence of all null values, having null logical type\n+\n+Buffer Alignment and Padding\n+----------------------------\n+\n+Implementations are recommended allocate memory on aligned (8- or\n+64-byte boundaries) and pad (overallocate) to a length that is a\n+multiple of 8 or 64 bytes. When serializing Arrow data for\n+interprocess communication, these alignment and padding requirements\n+are enforced. If possible, we suggest that you prefer using 64-byte\n+alignment and padding. Unless otherwise noted, padded bytes do not\n+need to have a specific value.\n+\n+The alignment requirement follows best practices for optimized memory\n+access:\n+\n+* Elements in numeric arrays will be guaranteed to be retrieved via aligned access.\n+* On some architectures alignment can help limit partially used cache lines.\n+\n+The recommendation for 64 byte alignment comes from the `Intel\n+performance guide`_ that recommends alignment of memory to match SIMD\n+register width.  The specific padding length was chosen because it\n+matches the largest known SIMD instruction registers available as of\n+April 2016 (Intel AVX-512).\n+\n+The recommended padding of 64 bytes allows for using `SIMD`_\n+instructions consistently in loops without additional conditional\n+checks.  This should allow for simpler, efficient and CPU\n+cache-friendly code.  In other words, we can load the entire 64-byte\n+buffer into a 512-bit wide SIMD register and get data-level\n+parallelism on all the columnar values packed into the 64-byte\n+buffer. Guaranteed padding can also allow certain compilers to\n+generate more optimized code directly (e.g. One can safely use Intel's\n+``-qopt-assume-safe-padding``).\n+\n+Byte Order (`Endianness`_)\n+---------------------------\n+\n+The Arrow format is little endian by default.\n+\n+Serialized Schema metadata has an endianness field indicating\n+endianness of RecordBatches. Typically this is the endianness of the\n+system where the RecordBatch was generated. The main use case is\n+exchanging RecordBatches between systems with the same Endianness.  At\n+first we will return an error when trying to read a Schema with an\n+endianness that does not match the underlying system. The reference\n+implementation is focused on Little Endian and provides tests for\n+it. Eventually we may provide automatic conversion via byte swapping.\n+\n+Array lengths\n+-------------\n+\n+Array lengths are represented in the Arrow metadata as a 64-bit signed\n+integer. An implementation of Arrow is considered valid even if it only\n+supports lengths up to the maximum 32-bit signed integer, though. If using\n+Arrow in a multi-language environment, we recommend limiting lengths to\n+2 :sup:`31` - 1 elements or less. Larger data sets can be represented using\n+multiple array chunks.\n+\n+Null count\n+----------\n+\n+The number of null value slots is a property of the physical array and\n+considered part of the data structure. The null count is represented\n+in the Arrow metadata as a 64-bit signed integer, as it may be as\n+large as the array length.\n+\n+Validity bitmaps\n+----------------\n+\n+Any type can have null value slots, whether primitive or nested type.\n+\n+An array with nulls must have a contiguous memory buffer, known as the\n+validity (or \"null\") bitmap, large enough to have at least 1 bit for\n+each array slot.\n+\n+Whether any array slot is valid (non-null) is encoded in the respective bits of\n+this bitmap. A 1 (set bit) for index ``j`` indicates that the value is not null,\n+while a 0 (bit not set) indicates that it is null. Bitmaps are to be\n+initialized to be all unset at allocation time (this includes padding).::\n+\n+    is_valid[j] -> bitmap[j / 8] & (1 << (j % 8))\n+\n+We use `least-significant bit (LSB) numbering`_ (also known as\n+bit-endianness). This means that within a group of 8 bits, we read\n+right-to-left: ::\n+\n+    values = [0, 1, null, 2, null, 3]\n+\n+    bitmap\n+    j mod 8   7  6  5  4  3  2  1  0\n+              0  0  1  0  1  0  1  1\n+\n+Arrays having a 0 null count may choose to not allocate the null\n+bitmap. Implementations may choose to always allocate one anyway as a matter of\n+convenience, but this should be noted when memory is being shared.\n+\n+Nested type arrays have their own null bitmap and null count regardless of\n+the null count and null bits of their child arrays.\n+\n+Primitive\n+---------\n+\n+A primitive value array represents a fixed-length array of values each having\n+the same physical slot width typically measured in bytes, though the spec also\n+provides for bit-packed types (e.g. boolean values encoded in bits).\n+\n+Internally, the array contains a contiguous memory buffer whose total size is\n+equal to the slot width multiplied by the array length. For bit-packed types,\n+the size is rounded up to the nearest byte.\n+\n+The associated null bitmap is contiguously allocated (as described above) but\n+does not need to be adjacent in memory to the values buffer.\n+\n+**Example Layout: Int32 Array**\n+\n+For example a primitive array of int32s: ::\n+\n+    [1, null, 2, 4, 8]\n+\n+Would look like: ::\n+\n+    * Length: 5, Null count: 1\n+    * Null bitmap buffer:\n+\n+      |Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |-------------------------|-----------------------|\n+      | 00011101                | 0 (padding)           |\n+\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | unspecified | 2           | 4           | 8           | unspecified |\n+\n+**Example Layout: Non-null int32 Array**\n+\n+``[1, 2, 3, 4, 8]`` has two possible layouts: ::\n+\n+    * Length: 5, Null count: 0\n+    * Null bitmap buffer:\n+\n+      | Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |--------------------------|-----------------------|\n+      | 00011111                 | 0 (padding)           |\n+\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | bytes 12-15 | bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | 2           | 3           | 4           | 8           | unspecified |\n+\n+or with the bitmap elided: ::\n+\n+    * Length 5, Null count: 0\n+    * Null bitmap buffer: Not required\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | bytes 12-15 | bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | 2           | 3           | 4           | 8           | unspecified |\n+\n+Variable-size\n+-------------\n+\n+Each value in this layout type consists of 0 or more bytes. While\n+primitive arrays have a single values buffer, variable-size binary\n+have an **offsets** buffer and **data** buffer\n+\n+The offsets buffer contains `length + 1` signed integers (either\n+32-bit or 64-bit), which encode the start position of each element in\n+the data buffer. The length of the value in each slot is computed\n+using the first difference with the next element in the offsets\n+array. For example, the position and length of slot j is computed as:\n+\n+::\n+\n+    slot_position = offsets[j]\n+    slot_length = offsets[j + 1] - offsets[j]  // (for 0 <= j < length)\n+\n+Generally the first value in the offsets array is 0, and the last\n+element is the length of the values array.\n+\n+Variable-size List\n+------------------\n+\n+List is a nested type which is semantically similar to variable-size\n+binary. It is defined by two buffers: a validity bitmap and an offsets\n+buffer. The offsets are the same as in the variable-size binary case,\n+and both 32-bit and 64-bit signed integer offsets are\n+supported. Rather than referencing an additional data buffer, instead\n+these offsets reference a child array having any type.\n+\n+A list type is specified like ``List<T>``, where ``T`` is any type\n+(primitive or nested).\n+\n+**Example Layout: ``List<Char>`` Array**\n+\n+We illustrate ``List<Int8>``.\n+\n+For an array of length 4 with respective values: ::\n+\n+    [[12, -7, 25], null, [0, -127, 127, 50], []]\n+\n+will have the following representation: ::\n+\n+    * Length: 4, Null count: 1\n+    * Null bitmap buffer:\n+\n+      | Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |--------------------------|-----------------------|\n+      | 00001101                 | 0 (padding)           |\n+\n+    * Offsets buffer (int32)\n+\n+      | Bytes 0-3  | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 0          | 3           | 3           | 7           | 7           | unspecified |\n+\n+    * Values array (Int8array):\n+      * Length: 7,  Null count: 0\n+      * Null bitmap buffer: Not required\n+\n+        | Bytes 0-6                   | Bytes 7-63  |\n+        |-----------------------------|-------------|\n+        | 12, 7, 25, 0, -127, 127, 50 | unspecified |\n+\n+**Example Layout: ``List<List<Int8>>``**\n+\n+``[[[1, 2], [3, 4]], [[5, 6, 7], null, [8]], [[9, 10]]]``\n+\n+will be represented as follows: ::\n+\n+    * Length 3\n+    * Nulls count: 0\n+    * Null bitmap buffer: Not required\n+    * Offsets buffer (int32)\n+\n+      | Bytes 0-3  | Bytes 4-7  | Bytes 8-11 | Bytes 12-15 | Bytes 16-63 |\n+      |------------|------------|------------|-------------|-------------|\n+      | 0          |  2         |  5         |  6          | unspecified |\n+\n+    * Values array (`List<Int8>`)\n+      * Length: 6, Null count: 1\n+      * Null bitmap buffer:\n+\n+        | Byte 0 (validity bitmap) | Bytes 1-63  |\n+        |--------------------------|-------------|\n+        | 00110111                 | 0 (padding) |\n+\n+      * Offsets buffer (int32)\n+\n+        | Bytes 0-27           | Bytes 28-63 |\n+        |----------------------|-------------|\n+        | 0, 2, 4, 7, 7, 8, 10 | unspecified |\n+\n+      * Values array (Int8):\n+        * Length: 10, Null count: 0\n+        * Null bitmap buffer: Not required\n+\n+          | Bytes 0-9                     | Bytes 10-63 |\n+          |-------------------------------|-------------|\n+          | 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 | unspecified |\n+\n+Note that while the inner offsets buffer encodes the start position in\n+the inner values array, the outer offsets buffer encodes the start\n+position of corresponding outer element in the inner offsets buffer.\n+\n+Fixed-Size List\n+---------------\n+\n+Fixed-Size List is a nested type in which each array slot contains a\n+fixed-size sequence of values all having the same type (heterogeneity\n+can be achieved through unions, described later).\n+\n+A fixed size list type is specified like ``FixedSizeList<T>[N]``,\n+where ``T`` is any type (primitive or nested) and ``N`` is a 32-bit\n+signed integer representing the length of the lists.\n+\n+A fixed size list array is represented by a values array, which is a\n+child array of type T. T may also be a nested type. The value in slot\n+``j`` of a fixed size list array is stored in an ``N``-long slice of\n+the values array, starting at an offset of ``j * N``.\n+\n+**Example Layout: ``FixedSizeList<byte>[4]`` Array**\n+\n+Here we illustrate ``FixedSizeList<byte>[4]``.\n+\n+For an array of length 4 with respective values: ::\n+\n+    [[192, 168, 0, 12], null, [192, 168, 0, 25], [192, 168, 0, 1]]\n+\n+will have the following representation: ::\n+\n+    * Length: 4, Null count: 1\n+    * Null bitmap buffer:\n+\n+      | Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |--------------------------|-----------------------|\n+      | 00001101                 | 0 (padding)           |\n+\n+    * Values array (byte array):\n+      * Length: 16,  Null count: 0\n+      * Null bitmap buffer: Not required\n+\n+        | Bytes 0-3       | Bytes 4-7   | Bytes 8-15                      |\n+        |-----------------|-------------|---------------------------------|\n+        | 192, 168, 0, 12 | unspecified | 192, 168, 0, 25, 192, 168, 0, 1 |\n+\n+\n+Struct\n+------\n+\n+A struct is a nested type parameterized by an ordered sequence of\n+types (which can all be distinct), called its fields. Typically the\n+fields have names, but the names and their types are part of the type\n+metadata, not the physical memory layout.\n+\n+A struct array does not have any additional allocated physical storage\n+for its values.  A struct array must still have an allocated null\n+bitmap, if it has one or more null values.\n+\n+Physically, a struct type has one child array for each field. The\n+child arrays are independent and need not be adjacent to each other in\n+memory.\n+\n+For example, the struct (field names shown here as strings for illustration\n+purposes)::\n+\n+    Struct <\n+      name: String (= List<char>),\n+      age: Int32\n+    >\n+\n+has two child arrays, one ``List<char>`` array (layout as above) and one 4-byte\n+primitive value array having ``Int32`` logical type.\n+\n+**Example Layout: ``Struct<List<char>, Int32>``**\n+\n+The layout for ``[{'joe', 1}, {null, 2}, null, {'mark', 4}]`` would be: ::\n+\n+    * Length: 4, Null count: 1\n+    * Null bitmap buffer:\n+\n+      |Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |-------------------------|-----------------------|\n+      | 00001011                | 0 (padding)           |\n+\n+    * Children arrays:\n+      * field-0 array (`List<char>`):\n+        * Length: 4, Null count: 2\n+        * Null bitmap buffer:\n+\n+          | Byte 0 (validity bitmap) | Bytes 1-63            |\n+          |--------------------------|-----------------------|\n+          | 00001001                 | 0 (padding)           |\n+\n+        * Offsets buffer:\n+\n+          | Bytes 0-19     |\n+          |----------------|\n+          | 0, 3, 3, 3, 7  |\n+\n+         * Values array:\n+            * Length: 7, Null count: 0\n+            * Null bitmap buffer: Not required\n+\n+            * Value buffer:\n+\n+              | Bytes 0-6      |\n+              |----------------|\n+              | joemark        |\n+\n+      * field-1 array (int32 array):\n+        * Length: 4, Null count: 1\n+        * Null bitmap buffer:\n+\n+          | Byte 0 (validity bitmap) | Bytes 1-63            |\n+          |--------------------------|-----------------------|\n+          | 00001011                 | 0 (padding)           |\n+\n+        * Value Buffer:\n+\n+          |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-63 |\n+          |------------|-------------|-------------|-------------|-------------|\n+          | 1          | 2           | unspecified | 4           | unspecified |\n+\n+While a struct does not have physical storage for each of its semantic\n+slots (i.e. each scalar C-like struct), an entire struct slot can be\n+set to null via the null bitmap. Any of the child field arrays can\n+have null values according to their respective independent null\n+bitmaps. This implies that for a particular struct slot the null\n+bitmap for the struct array might indicate a null slot when one or\n+more of its child arrays has a non-null value in their corresponding\n+slot.  When reading the struct array the parent null bitmap is\n+authoritative.  This is illustrated in the example above, the child\n+arrays have valid entries for the null struct but are 'hidden' from\n+the consumer by the parent array's null bitmap.  However, when treated\n+independently corresponding values of the children array will be\n+non-null.\n+\n+Dense Union\n+-----------\n+\n+A dense union is semantically similar to a struct, and contains an\n+ordered sequence of types. While a struct contains multiple arrays, a\n+union is semantically a single array in which each slot can have a\n+different type.\n+\n+The union types may be named, but like structs this will be a matter\n+of the metadata and will not affect the physical memory layout.\n+\n+We define two distinct union types that are optimized for different use\n+cases. This first, the dense union, represents a mixed-type array with 5 bytes\n+of overhead for each value. Its physical layout is as follows:\n+\n+* One child array for each type\n+* Types buffer: A buffer of 8-bit signed integers, enumerated from 0 corresponding\n+  to each type.  A union with more then 127 possible types can be modeled as a\n+  union of unions.\n+* Offsets buffer: A buffer of signed int32 values indicating the relative offset\n+  into the respective child array for the type in a given slot. The respective\n+  offsets for each child value array must be in order / increasing.\n+\n+Critically, the dense union allows for minimal overhead in the ubiquitous\n+union-of-structs with non-overlapping-fields use case (``Union<s1: Struct1, s2:\n+Struct2, s3: Struct3, ...>``)\n+\n+**Example Layout: Dense union**\n+\n+An example layout for logical union of: ``Union<f: float, i: int32>``\n+having the values: ``[{f=1.2}, null, {f=3.4}, {i=5}]``\n+\n+::\n+\n+    * Length: 4, Null count: 1\n+    * Null bitmap buffer:\n+      |Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |-------------------------|-----------------------|\n+      |00001101                 | 0 (padding)           |\n+\n+    * Types buffer:\n+\n+      |Byte 0   | Byte 1      | Byte 2   | Byte 3   | Bytes 4-63  |\n+      |---------|-------------|----------|----------|-------------|\n+      | 0       | unspecified | 0        | 1        | unspecified |\n+\n+    * Offset buffer:\n+\n+      |Byte 0-3 | Byte 4-7    | Byte 8-11 | Byte 12-15 | Bytes 16-63 |\n+      |---------|-------------|-----------|------------|-------------|\n+      | 0       | unspecified | 1         | 0          | unspecified |\n+\n+    * Children arrays:\n+      * Field-0 array (f: float):\n+        * Length: 2, nulls: 0\n+        * Null bitmap buffer: Not required\n+\n+        * Value Buffer:\n+\n+          | Bytes 0-7 | Bytes 8-63  |\n+          |-----------|-------------|\n+          | 1.2, 3.4  | unspecified |\n+\n+\n+      * Field-1 array (i: int32):\n+        * Length: 1, nulls: 0\n+        * Null bitmap buffer: Not required\n+\n+        * Value Buffer:\n+\n+          | Bytes 0-3 | Bytes 4-63  |\n+          |-----------|-------------|\n+          | 5         | unspecified |\n+\n+Sparse Union\n+------------\n+\n+A sparse union has the same structure as a dense union, with the omission of\n+the offsets array. In this case, the child arrays are each equal in length to\n+the length of the union.\n+\n+While a sparse union may use significantly more space compared with a\n+dense union, it has some advantages that may be desirable in certain\n+use cases:\n+\n+* A sparse union is more amenable to vectorized expression evaluation in some use cases.\n+* Equal-length arrays can be interpreted as a union by only defining the types array.\n+\n+**Example layout: ``SparseUnion<u0: Int32, u1: Float, u2: List<Char>>``**\n+\n+For the union array: ::\n+\n+    [{u0=5}, {u1=1.2}, {u2='joe'}, {u1=3.4}, {u0=4}, {u2='mark'}]\n+\n+will have the following layout: ::\n+\n+    * Length: 6, Null count: 0\n+    * Null bitmap buffer: Not required\n+\n+    * Types buffer:\n+\n+     | Byte 0     | Byte 1      | Byte 2      | Byte 3      | Byte 4      | Byte 5       | Bytes  6-63           |\n+     |------------|-------------|-------------|-------------|-------------|--------------|-----------------------|\n+     | 0          | 1           | 2           | 1           | 0           | 2            | unspecified (padding) |\n+\n+    * Children arrays:\n+\n+      * u0 (Int32):\n+        * Length: 6, Null count: 4\n+        * Null bitmap buffer:\n+\n+          |Byte 0 (validity bitmap) | Bytes 1-63            |\n+          |-------------------------|-----------------------|\n+          |00010001                 | 0 (padding)           |\n+\n+        * Value buffer:\n+\n+          |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-19 | Bytes 20-23  | Bytes 24-63           |\n+          |------------|-------------|-------------|-------------|-------------|--------------|-----------------------|\n+          | 5          | unspecified | unspecified | unspecified | 4           |  unspecified | unspecified (padding) |\n+\n+      * u1 (float):\n+        * Length: 6, Null count: 4\n+        * Null bitmap buffer:\n+\n+          |Byte 0 (validity bitmap) | Bytes 1-63            |\n+          |-------------------------|-----------------------|\n+          | 00001010                | 0 (padding)           |\n+\n+        * Value buffer:\n+\n+          |Bytes 0-3    | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-19 | Bytes 20-23  | Bytes 24-63           |\n+          |-------------|-------------|-------------|-------------|-------------|--------------|-----------------------|\n+          | unspecified |  1.2        | unspecified | 3.4         | unspecified |  unspecified | unspecified (padding) |\n+\n+      * u2 (`List<char>`)\n+        * Length: 6, Null count: 4\n+        * Null bitmap buffer:\n+\n+          | Byte 0 (validity bitmap) | Bytes 1-63            |\n+          |--------------------------|-----------------------|\n+          | 00100100                 | 0 (padding)           |\n+\n+        * Offsets buffer (int32)\n+\n+          | Bytes 0-3  | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-19 | Bytes 20-23 | Bytes 24-27 | Bytes 28-63 |\n+          |------------|-------------|-------------|-------------|-------------|-------------|-------------|-------------|\n+          | 0          | 0           | 0           | 3           | 3           | 3           | 7           | unspecified |\n+\n+        * Values array (char array):\n+          * Length: 7,  Null count: 0\n+          * Null bitmap buffer: Not required\n+\n+            | Bytes 0-6  | Bytes 7-63            |\n+            |------------|-----------------------|\n+            | joemark    | unspecified (padding) |\n+\n+Note that nested types in a sparse union must be internally consistent\n+(e.g. see the List in the diagram), i.e. random access at any index j\n+on any child array will not cause an error.  In other words, the array\n+for the nested type must be valid if it is reinterpreted as a\n+non-nested array.\n+\n+Similar to structs, a particular child array may have a non-null slot\n+even if the null bitmap of the parent union array indicates the slot\n+is null.  Additionally, a child array may have a non-null slot even if\n+the types array indicates that a slot contains a different type at the\n+index.\n+\n+Null\n+----\n+\n+We provide a simplified memory-efficient layout for the Null data type\n+where all values are null. In this case no memory buffers are\n+allocated.\n+\n+Dictionary encoding\n+-------------------\n+\n+Dictionary encoding is a data representation technique to represent\n+values by integers referencing a **dictionary** usually consisting of\n+unique values. It can be effective when you have data with many\n+repeated values.\n+\n+Any array can be dictionary-encoded. The dictionary is stored as an\n+optional property of an array. When a field is dictionary encoded, the\n+values are represented by an array of signed integers representing the\n+index of the value in the dictionary.\n+\n+As an example, you could have the following data: ::\n+\n+    type: String\n+\n+    ['foo', 'bar', 'foo', 'bar', null, 'baz']\n+\n+In dictionary-encoded form, this could appear as:\n+\n+::\n+\n+    data String (dictionary-encoded)\n+       index_type: Int32\n+       values: [0, 1, 0, 1, null, 2]\n+\n+    dictionary\n+       type: String\n+       values: ['foo', 'bar', 'baz']\n+\n+We discuss dictionary encoding as it relates to serialization further\n+below.\n+\n+Buffer Layout Listing\n+---------------------\n+\n+For the avoidance of ambiguity, we provide listing the order and type\n+of memory buffers for each layout type.\n+\n+.. csv-table:: Buffer Layouts\n+   :header: \"Layout Type\", \"Buffer 0\", \"Buffer 1\", \"Buffer 2\"\n+   :widths: 30, 20, 20, 20\n+\n+   \"Primitive\",validity,data,\n+   \"Variable Binary\",validity,offsets,data\n+   \"List\",validity,offsets,\n+   \"Fixed-size List\",validity,,\n+   \"Struct\",validity,,\n+   \"Sparse Union\",validity,type ids,\n+   \"Dense Union\",validity,type ids,offsets\n+   \"Null\",placeholder (length 0),,\n+\n+Logical Types\n+=============\n+\n+The `Schema.fbs`_ defines built-in logical types supported by Apache\n+Arrow. Each logical type uses one of the above physical\n+layouts. Parametric or nested logical types may have different\n+physical layouts depending on the particular realization of the type.\n+\n+We do not go into detail about the logical types definitions in this\n+document as we consider `Schema.fbs`_ to be the ultimate point of\n+truth.\n+\n+Serialization and Interprocess Communication\n+============================================\n+\n+The primitive unit of serialized data in Apache Arrow is the \"record\n+batch\". Semantically, a record batch is a collection of independent\n+arrays each having the same length as one another but potentially\n+different data types\n+\n+In this section we define a protocol for serializing record batches\n+into a stream of binary payloads and reconstructing record batches\n+from these payloads without need for memory copying.\n+\n+Metadata serialization\n+----------------------\n+\n+The Flatbuffers files `Schema.fbs`_ contains the definitions for all\n+built-in logical data types and the ``Schema`` metadata type which\n+represents the schema of a given record batch. A schema consists of\n+names, logical types, and child fields for each top-level schema\n+field.\n+\n+The ``Schema`` message contains no data whatsoever. We provide both\n+schema-level and field-level ``custom_metadata`` attributes allowing\n+for systems to insert their own application defined metadata to\n+customize behavior.\n+\n+The ``Field`` Flatbuffers type contains the metadata for a single\n+array. This includes:\n+\n+* The field's name\n+* The field's logical type\n+* Whether the field is semantically nullable. Note that this has no\n+  bearing on the array's layout\n+* A collection of child ``Field`` values, for nested types\n+* A ``dictionary`` property indicating whether the field is\n+  dictionary-encoded or not\n+\n+RecordBatch serialization\n+-------------------------\n+\n+A record batch can be considered to be the realization of a\n+schema. The serialized form of the record batch is the following:\n+\n+* The ``data header``, defined as the ``RecordBatch`` type in\n+  `Message.fbs`_.\n+* The ``body``, a flat sequence of memory buffers written end-to-end\n+  with appropriate padding to ensure a minimum of 8-byte alignment\n+\n+The data header contains the following:\n+\n+* The length and null count for each flattened field in the record\n+  batch\n+* The memory offset and length of each constituent ``Buffer`` in the\n+  record batch's body\n+\n+Fields and buffers are flattened by a pre-order depth-first traversal\n+of the fields in the record batch. For example, let's consider the\n+schema ::\n+\n+    col1: Struct<a: Int32, b: List<item: Int64>, c: Float64>\n+    col2: Utf8\n+\n+The flattened version of this is: ::\n+\n+    FieldNode 0: Struct name='col1'\n+    FieldNode 1: Int32 name=a'\n+    FieldNode 2: List name='b'\n+    FieldNode 3: Int64 name='item'\n+    FieldNode 4: Float64 name='c'\n+    FieldNode 5: Utf8 name='col2'\n+\n+For the buffers produced, we would have the following (refer to the\n+table above): ::\n+\n+    buffer 0: field 0 validity\n+    buffer 1: field 1 validity\n+    buffer 2: field 1 values\n+    buffer 3: field 2 validity\n+    buffer 4: field 2 offsets\n+    buffer 5: field 3 validity\n+    buffer 6: field 3 values\n+    buffer 7: field 4 validity\n+    buffer 8: field 4 values\n+    buffer 9: field 5 validity\n+    buffer 10: field 5 offsets\n+    buffer 11: field 5 data\n+\n+The ``Buffer`` Flatbuffers value describes the location and size of a\n+piece of memory. Generally these are interpreted relative to the\n+**encapsulated message format** defined next.\n+\n+Encapsulated message format\n+---------------------------\n+\n+For simple streaming and file-based serialization, we define a\n+so-called \"encapsulated\" message format for interprocess\n+communication. Such messages can be \"deserialized\" into in-memory\n+Arrow array objects by examining only the message metadata without any\n+need to copy or move any of the actual data.\n+\n+The encapsulated binary message format is as follows:\n+\n+* A 32-bit continuation indicator. The value ``0xFFFFFFFF`` indicates\n+  a valid message. This component was introduced in version 0.15.0 in\n+  part to address the 8-byte alignment requirement of Flatbuffers\n+* A 32-bit little-endian length prefix indicating the metadata size\n+* The message metadata as a Flatbuffer\n+* Padding bytes to an 8-byte boundary\n+* The message body, which must be a multiple of 8 bytes\n \n Review comment:\n   \"whose length must be\"?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T15:20:33.044+0000",
                    "updated": "2019-08-27T15:20:33.044+0000",
                    "started": "2019-08-27T15:20:33.044+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "302073",
                    "issueId": "13214524"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/worklog/302074",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #5202: ARROW-4511: [Format][Docs] Revamp Format documentation, consolidate columnar format docs into a more coherent single document. Add Versioning/Stability page\nURL: https://github.com/apache/arrow/pull/5202#discussion_r318125770\n \n \n\n ##########\n File path: docs/source/format/Columnar.rst\n ##########\n @@ -0,0 +1,1266 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. _format_columnar:\n+\n+*********************\n+Arrow Columnar Format\n+*********************\n+\n+The \"Arrow Columnar Format\" includes a language-agnostic in-memory\n+data structure specification, metadata serialization, and a protocol\n+for serialization and generic data transport.\n+\n+This document is intended to provide adequate detail to create a new\n+implementation of the columnar format without the aid of an existing\n+implementation. We utilize Google's `Flatbuffers`_ project for\n+metadata serialization, so it will be necessary to refer to the\n+project's `Flatbuffers protocol definition files <FlatbuffersFiles>`_\n+while reading this document.\n+\n+The columnar format has some key features:\n+\n+* Data adjacency for sequential access (scans)\n+* O(1) (constant-time) random access\n+* SIMD and vectorization-friendly\n+* Relocatable without \"pointer swizzling\", allowing for true zero-copy\n+  access in shared memory\n+\n+Some things to keep in mind:\n+\n+* Some data types can be mutated in-place in memory, but others\n+  cannot. The community has made deliberate trade-offs regarding\n+  in-place mutability to provide analytical performance and data\n+  locality guarantees\n+\n+Terminology\n+===========\n+\n+Since different projects have used different words to describe various\n+concepts, here is a small glossary to help disambiguate.\n+\n+* **Array** or **Vector**: a sequence of values with known length all\n+  having the same type. These terms are used interchangeably in\n+  different Arrow implementations, but we use \"array\" in this\n+  document.\n+* **Slot**: a single logical value in an array of some particular data type\n+* **Buffer** or **Contiguous memory region**: a sequential virtual\n+  address space with a given length. Any byte can be reached via a\n+  single pointer offset less than the region's length.\n+* **Physical Layout type**: The underlying memory layout for an array\n+  without taking into account any value semantics. For example, a\n+  32-bit signed integer array and 32-bit floating point array have the\n+  same layout type.\n+* **Logical type**: An application-facing semantic value type that is\n+  implemented using some physical layout type. For example, Decimal\n+  values are stored as 16 bytes in a fixed-size binary\n+  layout. Similarly, strings can be stored as ``List<1-byte>``. A\n+  timestamp may be stored as 64-bit fixed-size layout.\n+* **Nested** or **parametric type**: a data type whose full structure\n+  depends on one or more other child types. Two fully-specified nested\n+  types are equal if and only if their child types are equal. For\n+  example, ``List<U>`` is distinct from ``List<V>`` iff U and V are\n+  different types.\n+* **Parent** and **child arrays**: names to express relationships\n+  between physical value arrays in a nested type structure. For\n+  example, a ``List<T>``-type parent array has a T-type array as its\n+  child (see more on lists below).\n+* **Leaf node** or **leaf**: A primitive value array that may or may\n+  not be a child array of some array with a nested type.\n+\n+Physical Memory Layout\n+======================\n+\n+Arrays are defined by a few pieces of metadata and data:\n+\n+* A logical data type\n+* A sequence of buffers\n+* A length as a 64-bit signed integer. Implementations are permitted\n+  to be limited to 32-bit lengths, see more on this below\n+* A null count as a 64-bit signed integer\n+* An optional **dictionary**, for dictionary-encoded arrays\n+\n+Nested arrays additionally have a sequence of one or more sets of\n+these items, called the **child arrays**.\n+\n+Each logical data type has a well-defined physical layout. Here are\n+the different physical layouts defined by Arrow:\n+\n+* **Primitive (fixed-size)**: a sequence of values each having the\n+  same byte or bit width\n+* **Variable-size Binary**: a sequence of values each having a variable\n+  byte length. Two variants of this layout are supported using 32-bit\n+  and 64-bit length encoding.\n+* **Fixed-size List**: a nested layout each each value has the same\n+  number of elements taken from a child data type.\n+* **Variable-size List**: a nested layout type where each value is a\n+  variable-length sequence of values taken from a child data type. Two\n+  variants of this layout are supported using 32-bit and 64-bit length\n+  encoding.\n+* **Struct**: a nested layout type consisting of a collection of child\n+  **fields** each having the same length\n+* **Sparse** and **Dense Union**: a nested layout type representing a\n+  sequence of values, each of which can have type chosen from a\n+  collection of child array types.\n+* **Null**: a sequence of all null values, having null logical type\n+\n+Buffer Alignment and Padding\n+----------------------------\n+\n+Implementations are recommended allocate memory on aligned (8- or\n+64-byte boundaries) and pad (overallocate) to a length that is a\n+multiple of 8 or 64 bytes. When serializing Arrow data for\n+interprocess communication, these alignment and padding requirements\n+are enforced. If possible, we suggest that you prefer using 64-byte\n+alignment and padding. Unless otherwise noted, padded bytes do not\n+need to have a specific value.\n+\n+The alignment requirement follows best practices for optimized memory\n+access:\n+\n+* Elements in numeric arrays will be guaranteed to be retrieved via aligned access.\n+* On some architectures alignment can help limit partially used cache lines.\n+\n+The recommendation for 64 byte alignment comes from the `Intel\n+performance guide`_ that recommends alignment of memory to match SIMD\n+register width.  The specific padding length was chosen because it\n+matches the largest known SIMD instruction registers available as of\n+April 2016 (Intel AVX-512).\n+\n+The recommended padding of 64 bytes allows for using `SIMD`_\n+instructions consistently in loops without additional conditional\n+checks.  This should allow for simpler, efficient and CPU\n+cache-friendly code.  In other words, we can load the entire 64-byte\n+buffer into a 512-bit wide SIMD register and get data-level\n+parallelism on all the columnar values packed into the 64-byte\n+buffer. Guaranteed padding can also allow certain compilers to\n+generate more optimized code directly (e.g. One can safely use Intel's\n+``-qopt-assume-safe-padding``).\n+\n+Byte Order (`Endianness`_)\n+---------------------------\n+\n+The Arrow format is little endian by default.\n+\n+Serialized Schema metadata has an endianness field indicating\n+endianness of RecordBatches. Typically this is the endianness of the\n+system where the RecordBatch was generated. The main use case is\n+exchanging RecordBatches between systems with the same Endianness.  At\n+first we will return an error when trying to read a Schema with an\n+endianness that does not match the underlying system. The reference\n+implementation is focused on Little Endian and provides tests for\n+it. Eventually we may provide automatic conversion via byte swapping.\n+\n+Array lengths\n+-------------\n+\n+Array lengths are represented in the Arrow metadata as a 64-bit signed\n+integer. An implementation of Arrow is considered valid even if it only\n+supports lengths up to the maximum 32-bit signed integer, though. If using\n+Arrow in a multi-language environment, we recommend limiting lengths to\n+2 :sup:`31` - 1 elements or less. Larger data sets can be represented using\n+multiple array chunks.\n+\n+Null count\n+----------\n+\n+The number of null value slots is a property of the physical array and\n+considered part of the data structure. The null count is represented\n+in the Arrow metadata as a 64-bit signed integer, as it may be as\n+large as the array length.\n+\n+Validity bitmaps\n+----------------\n+\n+Any type can have null value slots, whether primitive or nested type.\n+\n+An array with nulls must have a contiguous memory buffer, known as the\n+validity (or \"null\") bitmap, large enough to have at least 1 bit for\n+each array slot.\n+\n+Whether any array slot is valid (non-null) is encoded in the respective bits of\n+this bitmap. A 1 (set bit) for index ``j`` indicates that the value is not null,\n+while a 0 (bit not set) indicates that it is null. Bitmaps are to be\n+initialized to be all unset at allocation time (this includes padding).::\n+\n+    is_valid[j] -> bitmap[j / 8] & (1 << (j % 8))\n+\n+We use `least-significant bit (LSB) numbering`_ (also known as\n+bit-endianness). This means that within a group of 8 bits, we read\n+right-to-left: ::\n+\n+    values = [0, 1, null, 2, null, 3]\n+\n+    bitmap\n+    j mod 8   7  6  5  4  3  2  1  0\n+              0  0  1  0  1  0  1  1\n+\n+Arrays having a 0 null count may choose to not allocate the null\n+bitmap. Implementations may choose to always allocate one anyway as a matter of\n+convenience, but this should be noted when memory is being shared.\n+\n+Nested type arrays have their own null bitmap and null count regardless of\n+the null count and null bits of their child arrays.\n+\n+Primitive\n+---------\n+\n+A primitive value array represents a fixed-length array of values each having\n+the same physical slot width typically measured in bytes, though the spec also\n+provides for bit-packed types (e.g. boolean values encoded in bits).\n+\n+Internally, the array contains a contiguous memory buffer whose total size is\n+equal to the slot width multiplied by the array length. For bit-packed types,\n+the size is rounded up to the nearest byte.\n+\n+The associated null bitmap is contiguously allocated (as described above) but\n+does not need to be adjacent in memory to the values buffer.\n+\n+**Example Layout: Int32 Array**\n+\n+For example a primitive array of int32s: ::\n+\n+    [1, null, 2, 4, 8]\n+\n+Would look like: ::\n+\n+    * Length: 5, Null count: 1\n+    * Null bitmap buffer:\n+\n+      |Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |-------------------------|-----------------------|\n+      | 00011101                | 0 (padding)           |\n+\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | unspecified | 2           | 4           | 8           | unspecified |\n+\n+**Example Layout: Non-null int32 Array**\n+\n+``[1, 2, 3, 4, 8]`` has two possible layouts: ::\n+\n+    * Length: 5, Null count: 0\n+    * Null bitmap buffer:\n+\n+      | Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |--------------------------|-----------------------|\n+      | 00011111                 | 0 (padding)           |\n+\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | bytes 12-15 | bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | 2           | 3           | 4           | 8           | unspecified |\n+\n+or with the bitmap elided: ::\n+\n+    * Length 5, Null count: 0\n+    * Null bitmap buffer: Not required\n+    * Value Buffer:\n+\n+      |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | bytes 12-15 | bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 1          | 2           | 3           | 4           | 8           | unspecified |\n+\n+Variable-size\n+-------------\n+\n+Each value in this layout type consists of 0 or more bytes. While\n+primitive arrays have a single values buffer, variable-size binary\n+have an **offsets** buffer and **data** buffer\n+\n+The offsets buffer contains `length + 1` signed integers (either\n+32-bit or 64-bit), which encode the start position of each element in\n+the data buffer. The length of the value in each slot is computed\n+using the first difference with the next element in the offsets\n+array. For example, the position and length of slot j is computed as:\n+\n+::\n+\n+    slot_position = offsets[j]\n+    slot_length = offsets[j + 1] - offsets[j]  // (for 0 <= j < length)\n+\n+Generally the first value in the offsets array is 0, and the last\n+element is the length of the values array.\n+\n+Variable-size List\n+------------------\n+\n+List is a nested type which is semantically similar to variable-size\n+binary. It is defined by two buffers: a validity bitmap and an offsets\n+buffer. The offsets are the same as in the variable-size binary case,\n+and both 32-bit and 64-bit signed integer offsets are\n+supported. Rather than referencing an additional data buffer, instead\n+these offsets reference a child array having any type.\n+\n+A list type is specified like ``List<T>``, where ``T`` is any type\n+(primitive or nested).\n+\n+**Example Layout: ``List<Char>`` Array**\n+\n+We illustrate ``List<Int8>``.\n+\n+For an array of length 4 with respective values: ::\n+\n+    [[12, -7, 25], null, [0, -127, 127, 50], []]\n+\n+will have the following representation: ::\n+\n+    * Length: 4, Null count: 1\n+    * Null bitmap buffer:\n+\n+      | Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |--------------------------|-----------------------|\n+      | 00001101                 | 0 (padding)           |\n+\n+    * Offsets buffer (int32)\n+\n+      | Bytes 0-3  | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-19 | Bytes 20-63 |\n+      |------------|-------------|-------------|-------------|-------------|-------------|\n+      | 0          | 3           | 3           | 7           | 7           | unspecified |\n+\n+    * Values array (Int8array):\n+      * Length: 7,  Null count: 0\n+      * Null bitmap buffer: Not required\n+\n+        | Bytes 0-6                   | Bytes 7-63  |\n+        |-----------------------------|-------------|\n+        | 12, 7, 25, 0, -127, 127, 50 | unspecified |\n+\n+**Example Layout: ``List<List<Int8>>``**\n+\n+``[[[1, 2], [3, 4]], [[5, 6, 7], null, [8]], [[9, 10]]]``\n+\n+will be represented as follows: ::\n+\n+    * Length 3\n+    * Nulls count: 0\n+    * Null bitmap buffer: Not required\n+    * Offsets buffer (int32)\n+\n+      | Bytes 0-3  | Bytes 4-7  | Bytes 8-11 | Bytes 12-15 | Bytes 16-63 |\n+      |------------|------------|------------|-------------|-------------|\n+      | 0          |  2         |  5         |  6          | unspecified |\n+\n+    * Values array (`List<Int8>`)\n+      * Length: 6, Null count: 1\n+      * Null bitmap buffer:\n+\n+        | Byte 0 (validity bitmap) | Bytes 1-63  |\n+        |--------------------------|-------------|\n+        | 00110111                 | 0 (padding) |\n+\n+      * Offsets buffer (int32)\n+\n+        | Bytes 0-27           | Bytes 28-63 |\n+        |----------------------|-------------|\n+        | 0, 2, 4, 7, 7, 8, 10 | unspecified |\n+\n+      * Values array (Int8):\n+        * Length: 10, Null count: 0\n+        * Null bitmap buffer: Not required\n+\n+          | Bytes 0-9                     | Bytes 10-63 |\n+          |-------------------------------|-------------|\n+          | 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 | unspecified |\n+\n+Note that while the inner offsets buffer encodes the start position in\n+the inner values array, the outer offsets buffer encodes the start\n+position of corresponding outer element in the inner offsets buffer.\n+\n+Fixed-Size List\n+---------------\n+\n+Fixed-Size List is a nested type in which each array slot contains a\n+fixed-size sequence of values all having the same type (heterogeneity\n+can be achieved through unions, described later).\n+\n+A fixed size list type is specified like ``FixedSizeList<T>[N]``,\n+where ``T`` is any type (primitive or nested) and ``N`` is a 32-bit\n+signed integer representing the length of the lists.\n+\n+A fixed size list array is represented by a values array, which is a\n+child array of type T. T may also be a nested type. The value in slot\n+``j`` of a fixed size list array is stored in an ``N``-long slice of\n+the values array, starting at an offset of ``j * N``.\n+\n+**Example Layout: ``FixedSizeList<byte>[4]`` Array**\n+\n+Here we illustrate ``FixedSizeList<byte>[4]``.\n+\n+For an array of length 4 with respective values: ::\n+\n+    [[192, 168, 0, 12], null, [192, 168, 0, 25], [192, 168, 0, 1]]\n+\n+will have the following representation: ::\n+\n+    * Length: 4, Null count: 1\n+    * Null bitmap buffer:\n+\n+      | Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |--------------------------|-----------------------|\n+      | 00001101                 | 0 (padding)           |\n+\n+    * Values array (byte array):\n+      * Length: 16,  Null count: 0\n+      * Null bitmap buffer: Not required\n+\n+        | Bytes 0-3       | Bytes 4-7   | Bytes 8-15                      |\n+        |-----------------|-------------|---------------------------------|\n+        | 192, 168, 0, 12 | unspecified | 192, 168, 0, 25, 192, 168, 0, 1 |\n+\n+\n+Struct\n+------\n+\n+A struct is a nested type parameterized by an ordered sequence of\n+types (which can all be distinct), called its fields. Typically the\n+fields have names, but the names and their types are part of the type\n+metadata, not the physical memory layout.\n+\n+A struct array does not have any additional allocated physical storage\n+for its values.  A struct array must still have an allocated null\n+bitmap, if it has one or more null values.\n+\n+Physically, a struct type has one child array for each field. The\n+child arrays are independent and need not be adjacent to each other in\n+memory.\n+\n+For example, the struct (field names shown here as strings for illustration\n+purposes)::\n+\n+    Struct <\n+      name: String (= List<char>),\n+      age: Int32\n+    >\n+\n+has two child arrays, one ``List<char>`` array (layout as above) and one 4-byte\n+primitive value array having ``Int32`` logical type.\n+\n+**Example Layout: ``Struct<List<char>, Int32>``**\n+\n+The layout for ``[{'joe', 1}, {null, 2}, null, {'mark', 4}]`` would be: ::\n+\n+    * Length: 4, Null count: 1\n+    * Null bitmap buffer:\n+\n+      |Byte 0 (validity bitmap) | Bytes 1-63            |\n+      |-------------------------|-----------------------|\n+      | 00001011                | 0 (padding)           |\n+\n+    * Children arrays:\n+      * field-0 array (`List<char>`):\n+        * Length: 4, Null count: 2\n+        * Null bitmap buffer:\n+\n+          | Byte 0 (validity bitmap) | Bytes 1-63            |\n+          |--------------------------|-----------------------|\n+          | 00001001                 | 0 (padding)           |\n+\n+        * Offsets buffer:\n+\n+          | Bytes 0-19     |\n+          |----------------|\n+          | 0, 3, 3, 3, 7  |\n+\n+         * Values array:\n+            * Length: 7, Null count: 0\n+            * Null bitmap buffer: Not required\n+\n+            * Value buffer:\n+\n+              | Bytes 0-6      |\n+              |----------------|\n+              | joemark        |\n+\n+      * field-1 array (int32 array):\n+        * Length: 4, Null count: 1\n+        * Null bitmap buffer:\n+\n+          | Byte 0 (validity bitmap) | Bytes 1-63            |\n+          |--------------------------|-----------------------|\n+          | 00001011                 | 0 (padding)           |\n+\n+        * Value Buffer:\n+\n+          |Bytes 0-3   | Bytes 4-7   | Bytes 8-11  | Bytes 12-15 | Bytes 16-63 |\n+          |------------|-------------|-------------|-------------|-------------|\n+          | 1          | 2           | unspecified | 4           | unspecified |\n+\n+While a struct does not have physical storage for each of its semantic\n+slots (i.e. each scalar C-like struct), an entire struct slot can be\n+set to null via the null bitmap. Any of the child field arrays can\n+have null values according to their respective independent null\n+bitmaps. This implies that for a particular struct slot the null\n+bitmap for the struct array might indicate a null slot when one or\n+more of its child arrays has a non-null value in their corresponding\n+slot.  When reading the struct array the parent null bitmap is\n+authoritative.  This is illustrated in the example above, the child\n+arrays have valid entries for the null struct but are 'hidden' from\n+the consumer by the parent array's null bitmap.  However, when treated\n+independently corresponding values of the children array will be\n+non-null.\n+\n+Dense Union\n+-----------\n+\n+A dense union is semantically similar to a struct, and contains an\n+ordered sequence of types. While a struct contains multiple arrays, a\n+union is semantically a single array in which each slot can have a\n+different type.\n+\n+The union types may be named, but like structs this will be a matter\n+of the metadata and will not affect the physical memory layout.\n+\n+We define two distinct union types that are optimized for different use\n+cases. This first, the dense union, represents a mixed-type array with 5 bytes\n+of overhead for each value. Its physical layout is as follows:\n+\n+* One child array for each type\n+* Types buffer: A buffer of 8-bit signed integers, enumerated from 0 corresponding\n \n Review comment:\n   Are they really enumerated from 0? I thought those were logical type numbers, to allow for adding/removing types without rewriting the types buffer...\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-08-27T15:20:33.046+0000",
                    "updated": "2019-08-27T15:20:33.046+0000",
                    "started": "2019-08-27T15:20:33.046+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "302074",
                    "issueId": "13214524"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 47400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@2492ca55[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5f00a126[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@26e9a2[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@5a757111[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@25123dd4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@35b8260c[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2e4b2e0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@73e8b654[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@47a0c960[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@33dc0fde[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1488d8f7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@22648624[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 47400,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Aug 28 21:01:18 UTC 2019",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2019-08-28T21:01:18.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-4511/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2019-02-08T05:39:14.000+0000",
        "updated": "2019-08-28T21:01:19.000+0000",
        "timeoriginalestimate": null,
        "description": "We might want to leave the documents in place and provide links to the new consolidated document in case others are linking to published content.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "13h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 47400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Format] remove individual documents in favor of new document once all content is moved",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13214524/comment/16918106",
                    "id": "16918106",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 5202\n[https://github.com/apache/arrow/pull/5202]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2019-08-28T21:01:18.822+0000",
                    "updated": "2019-08-28T21:01:18.822+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|yi0rwg:",
        "customfield_12314139": null
    }
}