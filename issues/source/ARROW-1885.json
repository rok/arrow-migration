{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13122643",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122643",
    "key": "ARROW-1885",
    "fields": {
        "parent": {
            "id": "13099860",
            "key": "ARROW-1463",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860",
            "fields": {
                "summary": "[JAVA] Restructure ValueVector hierarchy to minimize compile-time generated code",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                    "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                    "name": "Resolved",
                    "id": "5",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                    "id": "4",
                    "description": "An improvement or enhancement to an existing feature or task.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                    "name": "Improvement",
                    "subtask": false,
                    "avatarId": 21140
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12341352",
                "id": "12341352",
                "name": "0.8.0",
                "archived": false,
                "released": true,
                "releaseDate": "2017-12-18"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": null,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
            "name": "bryanc",
            "key": "bryanc",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
            },
            "displayName": "Bryan Cutler",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328933",
                "id": "12328933",
                "name": "Java"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": null,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
            "name": "bryanc",
            "key": "bryanc",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
            },
            "displayName": "Bryan Cutler",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
            "name": "bryanc",
            "key": "bryanc",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
            },
            "displayName": "Bryan Cutler",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1885/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 0,
            "worklogs": []
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": null,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@74d4032b[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@70536b00[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@71282e45[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@1ac8400b[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@61a0c86f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@495d357c[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@79377014[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@2127bf21[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@46a3e8da[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@6675c3a7[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2480a8ad[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@3842c5ab[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": null,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Dec 04 23:01:02 UTC 2017",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2017-12-04T22:46:19.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1885/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2017-12-04T18:23:50.000+0000",
        "updated": "2017-12-04T23:01:02.000+0000",
        "timeoriginalestimate": null,
        "description": "Making changes to the MapVector class was not part of refactoring plan and should not have been done in ARROW-1710.  This will restore class names to the previous state of {{NullableMapVector}} -> {{MapVector}} -> {{AbstractMapVector}}",
        "customfield_10010": null,
        "timetracking": {},
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Java] Restore previous MapVector class names",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122643/comment/16277402",
                    "id": "16277402",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler opened a new pull request #1389: ARROW-1885: [Java] Restore MapVector class names prior to ARROW-1710\nURL: https://github.com/apache/arrow/pull/1389\n \n \n   Changes to MapVector were not part of the intended goal for ARROW-1710 and should be restored to `NullableMapVector` -> `MapVector` -> `AbstractMapVector` as existed prior to #1341.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-12-04T20:07:01.947+0000",
                    "updated": "2017-12-04T20:07:01.947+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122643/comment/16277411",
                    "id": "16277411",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1389: ARROW-1885: [Java] Restore MapVector class names prior to ARROW-1710\nURL: https://github.com/apache/arrow/pull/1389#issuecomment-349090621\n \n \n   @siddharthteotia I manually checked differences of this change to those done in #1341 to ensure readers/writers and others are back to the previous state, but please double check and let me know if you feel comfortable with this. \r\n   cc @icexelloss @jacques-n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-12-04T20:12:58.404+0000",
                    "updated": "2017-12-04T20:12:58.404+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122643/comment/16277557",
                    "id": "16277557",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1389: ARROW-1885: [Java] Restore MapVector class names prior to ARROW-1710\nURL: https://github.com/apache/arrow/pull/1389#discussion_r154782541\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n ##########\n @@ -21,480 +21,322 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n \n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n+import java.util.Collection;\n+import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n \n-import com.google.common.collect.ObjectArrays;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Ordering;\n+import com.google.common.primitives.Ints;\n \n import io.netty.buffer.ArrowBuf;\n-import org.apache.arrow.memory.BaseAllocator;\n+\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.*;\n-import org.apache.arrow.vector.complex.impl.NullableMapReaderImpl;\n-import org.apache.arrow.vector.complex.impl.NullableMapWriter;\n+import org.apache.arrow.vector.complex.impl.SingleMapReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.ComplexHolder;\n-import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.ArrowType;\n-import org.apache.arrow.vector.types.pojo.ArrowType.Struct;\n-import org.apache.arrow.vector.types.pojo.DictionaryEncoding;\n-import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.CallBack;\n-import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.JsonStringHashMap;\n import org.apache.arrow.vector.util.TransferPair;\n \n-public class MapVector extends NonNullableMapVector implements FieldVector {\n+public class MapVector extends AbstractMapVector {\n+  //private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(MapVector.class);\n \n   public static MapVector empty(String name, BufferAllocator allocator) {\n-    FieldType fieldType = FieldType.nullable(Struct.INSTANCE);\n+    FieldType fieldType = new FieldType(false, ArrowType.Struct.INSTANCE, null, null);\n     return new MapVector(name, allocator, fieldType, null);\n   }\n \n-  private final NullableMapReaderImpl reader = new NullableMapReaderImpl(this);\n-  private final NullableMapWriter writer = new NullableMapWriter(this);\n-\n-  protected ArrowBuf validityBuffer;\n-  private int validityAllocationSizeInBytes;\n+  private final SingleMapReaderImpl reader = new SingleMapReaderImpl(this);\n+  protected final FieldType fieldType;\n+  public int valueCount;\n \n   // deprecated, use FieldType or static constructor instead\n   @Deprecated\n   public MapVector(String name, BufferAllocator allocator, CallBack callBack) {\n-    this(name, allocator, FieldType.nullable(ArrowType.Struct.INSTANCE), callBack);\n+    this(name, allocator, new FieldType(false, ArrowType.Struct.INSTANCE, null, null), callBack);\n   }\n \n-  // deprecated, use FieldType or static constructor instead\n-  @Deprecated\n-  public MapVector(String name, BufferAllocator allocator, DictionaryEncoding dictionary, CallBack callBack) {\n-    this(name, allocator, new FieldType(true, ArrowType.Struct.INSTANCE, dictionary, null), callBack);\n+  public MapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(name, allocator, callBack);\n+    this.fieldType = checkNotNull(fieldType);\n+    this.valueCount = 0;\n   }\n \n-  public MapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n-    super(name, checkNotNull(allocator), fieldType, callBack);\n-    this.validityBuffer = allocator.getEmpty();\n-    this.validityAllocationSizeInBytes = BitVectorHelper.getValidityBufferSize(BaseValueVector.INITIAL_VALUE_ALLOCATION);\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  transient private MapTransferPair ephPair;\n \n Review comment:\n   `ephPair` seems wrong\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-12-04T21:37:33.297+0000",
                    "updated": "2017-12-04T21:37:33.297+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122643/comment/16277563",
                    "id": "16277563",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1389: ARROW-1885: [Java] Restore MapVector class names prior to ARROW-1710\nURL: https://github.com/apache/arrow/pull/1389#issuecomment-349115053\n \n \n   LGTM except for what seems to be a typo .\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-12-04T21:40:50.594+0000",
                    "updated": "2017-12-04T21:40:50.594+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122643/comment/16277567",
                    "id": "16277567",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1389: ARROW-1885: [Java] Restore MapVector class names prior to ARROW-1710\nURL: https://github.com/apache/arrow/pull/1389#discussion_r154784697\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n ##########\n @@ -21,480 +21,322 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n \n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n+import java.util.Collection;\n+import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n \n-import com.google.common.collect.ObjectArrays;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Ordering;\n+import com.google.common.primitives.Ints;\n \n import io.netty.buffer.ArrowBuf;\n-import org.apache.arrow.memory.BaseAllocator;\n+\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.*;\n-import org.apache.arrow.vector.complex.impl.NullableMapReaderImpl;\n-import org.apache.arrow.vector.complex.impl.NullableMapWriter;\n+import org.apache.arrow.vector.complex.impl.SingleMapReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.ComplexHolder;\n-import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.ArrowType;\n-import org.apache.arrow.vector.types.pojo.ArrowType.Struct;\n-import org.apache.arrow.vector.types.pojo.DictionaryEncoding;\n-import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.CallBack;\n-import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.JsonStringHashMap;\n import org.apache.arrow.vector.util.TransferPair;\n \n-public class MapVector extends NonNullableMapVector implements FieldVector {\n+public class MapVector extends AbstractMapVector {\n+  //private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(MapVector.class);\n \n   public static MapVector empty(String name, BufferAllocator allocator) {\n-    FieldType fieldType = FieldType.nullable(Struct.INSTANCE);\n+    FieldType fieldType = new FieldType(false, ArrowType.Struct.INSTANCE, null, null);\n     return new MapVector(name, allocator, fieldType, null);\n   }\n \n-  private final NullableMapReaderImpl reader = new NullableMapReaderImpl(this);\n-  private final NullableMapWriter writer = new NullableMapWriter(this);\n-\n-  protected ArrowBuf validityBuffer;\n-  private int validityAllocationSizeInBytes;\n+  private final SingleMapReaderImpl reader = new SingleMapReaderImpl(this);\n+  protected final FieldType fieldType;\n+  public int valueCount;\n \n   // deprecated, use FieldType or static constructor instead\n   @Deprecated\n   public MapVector(String name, BufferAllocator allocator, CallBack callBack) {\n-    this(name, allocator, FieldType.nullable(ArrowType.Struct.INSTANCE), callBack);\n+    this(name, allocator, new FieldType(false, ArrowType.Struct.INSTANCE, null, null), callBack);\n   }\n \n-  // deprecated, use FieldType or static constructor instead\n-  @Deprecated\n-  public MapVector(String name, BufferAllocator allocator, DictionaryEncoding dictionary, CallBack callBack) {\n-    this(name, allocator, new FieldType(true, ArrowType.Struct.INSTANCE, dictionary, null), callBack);\n+  public MapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(name, allocator, callBack);\n+    this.fieldType = checkNotNull(fieldType);\n+    this.valueCount = 0;\n   }\n \n-  public MapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n-    super(name, checkNotNull(allocator), fieldType, callBack);\n-    this.validityBuffer = allocator.getEmpty();\n-    this.validityAllocationSizeInBytes = BitVectorHelper.getValidityBufferSize(BaseValueVector.INITIAL_VALUE_ALLOCATION);\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  transient private MapTransferPair ephPair;\n \n Review comment:\n   how so, you mean the name?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-12-04T21:45:28.720+0000",
                    "updated": "2017-12-04T21:45:28.720+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122643/comment/16277571",
                    "id": "16277571",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1389: ARROW-1885: [Java] Restore MapVector class names prior to ARROW-1710\nURL: https://github.com/apache/arrow/pull/1389#discussion_r154785430\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n ##########\n @@ -21,480 +21,322 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n \n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n+import java.util.Collection;\n+import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n \n-import com.google.common.collect.ObjectArrays;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Ordering;\n+import com.google.common.primitives.Ints;\n \n import io.netty.buffer.ArrowBuf;\n-import org.apache.arrow.memory.BaseAllocator;\n+\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.*;\n-import org.apache.arrow.vector.complex.impl.NullableMapReaderImpl;\n-import org.apache.arrow.vector.complex.impl.NullableMapWriter;\n+import org.apache.arrow.vector.complex.impl.SingleMapReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.ComplexHolder;\n-import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.ArrowType;\n-import org.apache.arrow.vector.types.pojo.ArrowType.Struct;\n-import org.apache.arrow.vector.types.pojo.DictionaryEncoding;\n-import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.CallBack;\n-import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.JsonStringHashMap;\n import org.apache.arrow.vector.util.TransferPair;\n \n-public class MapVector extends NonNullableMapVector implements FieldVector {\n+public class MapVector extends AbstractMapVector {\n+  //private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(MapVector.class);\n \n   public static MapVector empty(String name, BufferAllocator allocator) {\n-    FieldType fieldType = FieldType.nullable(Struct.INSTANCE);\n+    FieldType fieldType = new FieldType(false, ArrowType.Struct.INSTANCE, null, null);\n     return new MapVector(name, allocator, fieldType, null);\n   }\n \n-  private final NullableMapReaderImpl reader = new NullableMapReaderImpl(this);\n-  private final NullableMapWriter writer = new NullableMapWriter(this);\n-\n-  protected ArrowBuf validityBuffer;\n-  private int validityAllocationSizeInBytes;\n+  private final SingleMapReaderImpl reader = new SingleMapReaderImpl(this);\n+  protected final FieldType fieldType;\n+  public int valueCount;\n \n   // deprecated, use FieldType or static constructor instead\n   @Deprecated\n   public MapVector(String name, BufferAllocator allocator, CallBack callBack) {\n-    this(name, allocator, FieldType.nullable(ArrowType.Struct.INSTANCE), callBack);\n+    this(name, allocator, new FieldType(false, ArrowType.Struct.INSTANCE, null, null), callBack);\n   }\n \n-  // deprecated, use FieldType or static constructor instead\n-  @Deprecated\n-  public MapVector(String name, BufferAllocator allocator, DictionaryEncoding dictionary, CallBack callBack) {\n-    this(name, allocator, new FieldType(true, ArrowType.Struct.INSTANCE, dictionary, null), callBack);\n+  public MapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(name, allocator, callBack);\n+    this.fieldType = checkNotNull(fieldType);\n+    this.valueCount = 0;\n   }\n \n-  public MapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n-    super(name, checkNotNull(allocator), fieldType, callBack);\n-    this.validityBuffer = allocator.getEmpty();\n-    this.validityAllocationSizeInBytes = BitVectorHelper.getValidityBufferSize(BaseValueVector.INITIAL_VALUE_ALLOCATION);\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  transient private MapTransferPair ephPair;\n \n Review comment:\n   keep in mind the diff is showing the result of renaming `NonNullableMapVector` to `MapVector` and none of the code was actually changed, just the class name\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-12-04T21:47:55.367+0000",
                    "updated": "2017-12-04T21:47:55.367+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122643/comment/16277586",
                    "id": "16277586",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1389: ARROW-1885: [Java] Restore MapVector class names prior to ARROW-1710\nURL: https://github.com/apache/arrow/pull/1389#discussion_r154786386\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n ##########\n @@ -21,480 +21,322 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n \n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n+import java.util.Collection;\n+import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n \n-import com.google.common.collect.ObjectArrays;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Ordering;\n+import com.google.common.primitives.Ints;\n \n import io.netty.buffer.ArrowBuf;\n-import org.apache.arrow.memory.BaseAllocator;\n+\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.*;\n-import org.apache.arrow.vector.complex.impl.NullableMapReaderImpl;\n-import org.apache.arrow.vector.complex.impl.NullableMapWriter;\n+import org.apache.arrow.vector.complex.impl.SingleMapReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.ComplexHolder;\n-import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.ArrowType;\n-import org.apache.arrow.vector.types.pojo.ArrowType.Struct;\n-import org.apache.arrow.vector.types.pojo.DictionaryEncoding;\n-import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.CallBack;\n-import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.JsonStringHashMap;\n import org.apache.arrow.vector.util.TransferPair;\n \n-public class MapVector extends NonNullableMapVector implements FieldVector {\n+public class MapVector extends AbstractMapVector {\n+  //private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(MapVector.class);\n \n   public static MapVector empty(String name, BufferAllocator allocator) {\n-    FieldType fieldType = FieldType.nullable(Struct.INSTANCE);\n+    FieldType fieldType = new FieldType(false, ArrowType.Struct.INSTANCE, null, null);\n     return new MapVector(name, allocator, fieldType, null);\n   }\n \n-  private final NullableMapReaderImpl reader = new NullableMapReaderImpl(this);\n-  private final NullableMapWriter writer = new NullableMapWriter(this);\n-\n-  protected ArrowBuf validityBuffer;\n-  private int validityAllocationSizeInBytes;\n+  private final SingleMapReaderImpl reader = new SingleMapReaderImpl(this);\n+  protected final FieldType fieldType;\n+  public int valueCount;\n \n   // deprecated, use FieldType or static constructor instead\n   @Deprecated\n   public MapVector(String name, BufferAllocator allocator, CallBack callBack) {\n-    this(name, allocator, FieldType.nullable(ArrowType.Struct.INSTANCE), callBack);\n+    this(name, allocator, new FieldType(false, ArrowType.Struct.INSTANCE, null, null), callBack);\n   }\n \n-  // deprecated, use FieldType or static constructor instead\n-  @Deprecated\n-  public MapVector(String name, BufferAllocator allocator, DictionaryEncoding dictionary, CallBack callBack) {\n-    this(name, allocator, new FieldType(true, ArrowType.Struct.INSTANCE, dictionary, null), callBack);\n+  public MapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(name, allocator, callBack);\n+    this.fieldType = checkNotNull(fieldType);\n+    this.valueCount = 0;\n   }\n \n-  public MapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n-    super(name, checkNotNull(allocator), fieldType, callBack);\n-    this.validityBuffer = allocator.getEmpty();\n-    this.validityAllocationSizeInBytes = BitVectorHelper.getValidityBufferSize(BaseValueVector.INITIAL_VALUE_ALLOCATION);\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  transient private MapTransferPair ephPair;\n \n Review comment:\n   Oh sorry I should be clear - the variable name `ephPair` seems wrong - I don't know if it has always been `ephPair` or somehow changed during refactoring. Either way, seems worth fixing.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-12-04T21:51:47.513+0000",
                    "updated": "2017-12-04T21:51:47.513+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122643/comment/16277594",
                    "id": "16277594",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1389: ARROW-1885: [Java] Restore MapVector class names prior to ARROW-1710\nURL: https://github.com/apache/arrow/pull/1389#discussion_r154787173\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n ##########\n @@ -21,480 +21,322 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n \n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n+import java.util.Collection;\n+import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n \n-import com.google.common.collect.ObjectArrays;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Ordering;\n+import com.google.common.primitives.Ints;\n \n import io.netty.buffer.ArrowBuf;\n-import org.apache.arrow.memory.BaseAllocator;\n+\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.*;\n-import org.apache.arrow.vector.complex.impl.NullableMapReaderImpl;\n-import org.apache.arrow.vector.complex.impl.NullableMapWriter;\n+import org.apache.arrow.vector.complex.impl.SingleMapReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.ComplexHolder;\n-import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.ArrowType;\n-import org.apache.arrow.vector.types.pojo.ArrowType.Struct;\n-import org.apache.arrow.vector.types.pojo.DictionaryEncoding;\n-import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.CallBack;\n-import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.JsonStringHashMap;\n import org.apache.arrow.vector.util.TransferPair;\n \n-public class MapVector extends NonNullableMapVector implements FieldVector {\n+public class MapVector extends AbstractMapVector {\n+  //private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(MapVector.class);\n \n   public static MapVector empty(String name, BufferAllocator allocator) {\n-    FieldType fieldType = FieldType.nullable(Struct.INSTANCE);\n+    FieldType fieldType = new FieldType(false, ArrowType.Struct.INSTANCE, null, null);\n     return new MapVector(name, allocator, fieldType, null);\n   }\n \n-  private final NullableMapReaderImpl reader = new NullableMapReaderImpl(this);\n-  private final NullableMapWriter writer = new NullableMapWriter(this);\n-\n-  protected ArrowBuf validityBuffer;\n-  private int validityAllocationSizeInBytes;\n+  private final SingleMapReaderImpl reader = new SingleMapReaderImpl(this);\n+  protected final FieldType fieldType;\n+  public int valueCount;\n \n   // deprecated, use FieldType or static constructor instead\n   @Deprecated\n   public MapVector(String name, BufferAllocator allocator, CallBack callBack) {\n-    this(name, allocator, FieldType.nullable(ArrowType.Struct.INSTANCE), callBack);\n+    this(name, allocator, new FieldType(false, ArrowType.Struct.INSTANCE, null, null), callBack);\n   }\n \n-  // deprecated, use FieldType or static constructor instead\n-  @Deprecated\n-  public MapVector(String name, BufferAllocator allocator, DictionaryEncoding dictionary, CallBack callBack) {\n-    this(name, allocator, new FieldType(true, ArrowType.Struct.INSTANCE, dictionary, null), callBack);\n+  public MapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(name, allocator, callBack);\n+    this.fieldType = checkNotNull(fieldType);\n+    this.valueCount = 0;\n   }\n \n-  public MapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n-    super(name, checkNotNull(allocator), fieldType, callBack);\n-    this.validityBuffer = allocator.getEmpty();\n-    this.validityAllocationSizeInBytes = BitVectorHelper.getValidityBufferSize(BaseValueVector.INITIAL_VALUE_ALLOCATION);\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  transient private MapTransferPair ephPair;\n \n Review comment:\n   Oh ok, I'm not sure of the reason for the name, this is how it was previously to ARROW-1710.  I'd prefer to keep the changes here to that scope so we can be sure they are restored correctly.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-12-04T21:54:51.902+0000",
                    "updated": "2017-12-04T21:54:51.902+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122643/comment/16277596",
                    "id": "16277596",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1389: ARROW-1885: [Java] Restore MapVector class names prior to ARROW-1710\nURL: https://github.com/apache/arrow/pull/1389#issuecomment-349119249\n \n \n   +1\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-12-04T21:55:35.492+0000",
                    "updated": "2017-12-04T21:55:35.492+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122643/comment/16277614",
                    "id": "16277614",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1389: ARROW-1885: [Java] Restore MapVector class names prior to ARROW-1710\nURL: https://github.com/apache/arrow/pull/1389#discussion_r154789025\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n ##########\n @@ -21,480 +21,322 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n \n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n+import java.util.Collection;\n+import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n \n-import com.google.common.collect.ObjectArrays;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Ordering;\n+import com.google.common.primitives.Ints;\n \n import io.netty.buffer.ArrowBuf;\n-import org.apache.arrow.memory.BaseAllocator;\n+\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.*;\n-import org.apache.arrow.vector.complex.impl.NullableMapReaderImpl;\n-import org.apache.arrow.vector.complex.impl.NullableMapWriter;\n+import org.apache.arrow.vector.complex.impl.SingleMapReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.ComplexHolder;\n-import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.ArrowType;\n-import org.apache.arrow.vector.types.pojo.ArrowType.Struct;\n-import org.apache.arrow.vector.types.pojo.DictionaryEncoding;\n-import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.CallBack;\n-import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.JsonStringHashMap;\n import org.apache.arrow.vector.util.TransferPair;\n \n-public class MapVector extends NonNullableMapVector implements FieldVector {\n+public class MapVector extends AbstractMapVector {\n+  //private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(MapVector.class);\n \n   public static MapVector empty(String name, BufferAllocator allocator) {\n-    FieldType fieldType = FieldType.nullable(Struct.INSTANCE);\n+    FieldType fieldType = new FieldType(false, ArrowType.Struct.INSTANCE, null, null);\n     return new MapVector(name, allocator, fieldType, null);\n   }\n \n-  private final NullableMapReaderImpl reader = new NullableMapReaderImpl(this);\n-  private final NullableMapWriter writer = new NullableMapWriter(this);\n-\n-  protected ArrowBuf validityBuffer;\n-  private int validityAllocationSizeInBytes;\n+  private final SingleMapReaderImpl reader = new SingleMapReaderImpl(this);\n+  protected final FieldType fieldType;\n+  public int valueCount;\n \n   // deprecated, use FieldType or static constructor instead\n   @Deprecated\n   public MapVector(String name, BufferAllocator allocator, CallBack callBack) {\n-    this(name, allocator, FieldType.nullable(ArrowType.Struct.INSTANCE), callBack);\n+    this(name, allocator, new FieldType(false, ArrowType.Struct.INSTANCE, null, null), callBack);\n   }\n \n-  // deprecated, use FieldType or static constructor instead\n-  @Deprecated\n-  public MapVector(String name, BufferAllocator allocator, DictionaryEncoding dictionary, CallBack callBack) {\n-    this(name, allocator, new FieldType(true, ArrowType.Struct.INSTANCE, dictionary, null), callBack);\n+  public MapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(name, allocator, callBack);\n+    this.fieldType = checkNotNull(fieldType);\n+    this.valueCount = 0;\n   }\n \n-  public MapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n-    super(name, checkNotNull(allocator), fieldType, callBack);\n-    this.validityBuffer = allocator.getEmpty();\n-    this.validityAllocationSizeInBytes = BitVectorHelper.getValidityBufferSize(BaseValueVector.INITIAL_VALUE_ALLOCATION);\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  transient private MapTransferPair ephPair;\n \n Review comment:\n   Ok, sounds good.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-12-04T22:02:19.856+0000",
                    "updated": "2017-12-04T22:02:19.856+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122643/comment/16277685",
                    "id": "16277685",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 1389\n[https://github.com/apache/arrow/pull/1389]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-12-04T22:46:19.379+0000",
                    "updated": "2017-12-04T22:46:19.379+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122643/comment/16277686",
                    "id": "16277686",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm closed pull request #1389: ARROW-1885: [Java] Restore MapVector class names prior to ARROW-1710\nURL: https://github.com/apache/arrow/pull/1389\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/java/vector/src/main/codegen/templates/CaseSensitiveMapWriters.java b/java/vector/src/main/codegen/templates/CaseSensitiveMapWriters.java\nindex 7c652902e..5357f9b8a 100644\n--- a/java/vector/src/main/codegen/templates/CaseSensitiveMapWriters.java\n+++ b/java/vector/src/main/codegen/templates/CaseSensitiveMapWriters.java\n@@ -23,7 +23,7 @@\n <#if mode == \"Single\">\n <#assign containerClass = \"MapVector\" />\n <#else>\n-<#assign containerClass = \"MapVector\" />\n+<#assign containerClass = \"NullableMapVector\" />\n </#if>\n \n <#include \"/@includes/license.ftl\" />\ndiff --git a/java/vector/src/main/codegen/templates/MapWriters.java b/java/vector/src/main/codegen/templates/MapWriters.java\nindex a5ac1b717..ac59e59b3 100644\n--- a/java/vector/src/main/codegen/templates/MapWriters.java\n+++ b/java/vector/src/main/codegen/templates/MapWriters.java\n@@ -21,9 +21,9 @@\n <@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/impl/${mode}MapWriter.java\" />\n <#assign index = \"idx()\">\n <#if mode == \"Single\">\n-<#assign containerClass = \"NonNullableMapVector\" />\n-<#else>\n <#assign containerClass = \"MapVector\" />\n+<#else>\n+<#assign containerClass = \"NullableMapVector\" />\n </#if>\n \n <#include \"/@includes/license.ftl\" />\n@@ -51,7 +51,7 @@\n   private final Map<String, FieldWriter> fields = Maps.newHashMap();\n   public ${mode}MapWriter(${containerClass} container) {\n     <#if mode == \"Single\">\n-    if (container instanceof MapVector) {\n+    if (container instanceof NullableMapVector) {\n       throw new IllegalArgumentException(\"Invalid container: \" + container);\n     }\n     </#if>\n@@ -124,7 +124,7 @@ public MapWriter map(String name) {\n     FieldWriter writer = fields.get(finalName);\n     if(writer == null){\n       int vectorCount=container.size();\n-      MapVector vector = container.addOrGet(name, FieldType.nullable(MinorType.MAP.getType()), MapVector.class);\n+      NullableMapVector vector = container.addOrGet(name, FieldType.nullable(MinorType.MAP.getType()), NullableMapVector.class);\n       writer = new PromotableWriter(vector, container, getNullableMapWriterFactory());\n       if(vectorCount != container.size()) {\n         writer.allocate();\ndiff --git a/java/vector/src/main/codegen/templates/UnionVector.java b/java/vector/src/main/codegen/templates/UnionVector.java\nindex 60cd24dcc..9377bd0da 100644\n--- a/java/vector/src/main/codegen/templates/UnionVector.java\n+++ b/java/vector/src/main/codegen/templates/UnionVector.java\n@@ -48,8 +48,8 @@\n \n \n /**\n- * A vector which can hold values of different types. It does so by using a MapVector which contains a vector for each\n- * primitive type that is stored. MapVector is used in order to take advantage of its serialization/deserialization methods,\n+ * A vector which can hold values of different types. It does so by using a NullableMapVector which contains a vector for each\n+ * primitive type that is stored. NullableMapVector is used in order to take advantage of its serialization/deserialization methods,\n  * as well as the addOrGet method.\n  *\n  * For performance reasons, UnionVector stores a cached reference to each subtype vector, to avoid having to do the map lookup\n@@ -65,7 +65,7 @@\n   MapVector internalMap;\n   protected ArrowBuf typeBuffer;\n \n-  private MapVector mapVector;\n+  private NullableMapVector mapVector;\n   private ListVector listVector;\n \n   private FieldReader reader;\n@@ -174,10 +174,10 @@ public long getOffsetBufferAddress() {\n   @Override\n   public ArrowBuf getOffsetBuffer() { throw new UnsupportedOperationException(); }\n \n-  public MapVector getMap() {\n+  public NullableMapVector getMap() {\n     if (mapVector == null) {\n       int vectorCount = internalMap.size();\n-      mapVector = addOrGet(MinorType.MAP, MapVector.class);\n+      mapVector = addOrGet(MinorType.MAP, NullableMapVector.class);\n       if (internalMap.size() > vectorCount) {\n         mapVector.allocateNew();\n         if (callBack != null) {\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BaseVariableWidthVector.java b/java/vector/src/main/java/org/apache/arrow/vector/BaseVariableWidthVector.java\nindex 98820a236..fbadb35d7 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/BaseVariableWidthVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BaseVariableWidthVector.java\n@@ -24,7 +24,7 @@\n import org.apache.arrow.memory.OutOfMemoryException;\n import org.apache.arrow.memory.BaseAllocator;\n import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.vector.complex.MapVector;\n+import org.apache.arrow.vector.complex.NullableMapVector;\n import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n import org.apache.arrow.vector.types.pojo.Field;\n import org.apache.arrow.vector.types.pojo.FieldType;\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/AbstractContainerVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/AbstractContainerVector.java\nindex 5ded1cc6f..db0ff86df 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/AbstractContainerVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/AbstractContainerVector.java\n@@ -100,8 +100,8 @@ protected boolean supportsDirectRead() {\n   // return the child vector's ordinal in the composite container\n   public abstract VectorWithOrdinal getChildVectorWithOrdinal(String name);\n \n-  public MapVector addOrGetMap(String name) {\n-    return addOrGet(name, FieldType.nullable(new Struct()), MapVector.class);\n+  public NullableMapVector addOrGetMap(String name) {\n+    return addOrGet(name, FieldType.nullable(new Struct()), NullableMapVector.class);\n   }\n \n   public ListVector addOrGetList(String name) {\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\nindex 72cc29f30..e13084588 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n@@ -6,9 +6,9 @@\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * <p>\n+ *\n  * http://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -21,480 +21,322 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n \n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n+import java.util.Collection;\n+import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n \n-import com.google.common.collect.ObjectArrays;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Ordering;\n+import com.google.common.primitives.Ints;\n \n import io.netty.buffer.ArrowBuf;\n-import org.apache.arrow.memory.BaseAllocator;\n+\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.*;\n-import org.apache.arrow.vector.complex.impl.NullableMapReaderImpl;\n-import org.apache.arrow.vector.complex.impl.NullableMapWriter;\n+import org.apache.arrow.vector.complex.impl.SingleMapReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.ComplexHolder;\n-import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.ArrowType;\n-import org.apache.arrow.vector.types.pojo.ArrowType.Struct;\n-import org.apache.arrow.vector.types.pojo.DictionaryEncoding;\n-import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.CallBack;\n-import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.JsonStringHashMap;\n import org.apache.arrow.vector.util.TransferPair;\n \n-public class MapVector extends NonNullableMapVector implements FieldVector {\n+public class MapVector extends AbstractMapVector {\n+  //private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(MapVector.class);\n \n   public static MapVector empty(String name, BufferAllocator allocator) {\n-    FieldType fieldType = FieldType.nullable(Struct.INSTANCE);\n+    FieldType fieldType = new FieldType(false, ArrowType.Struct.INSTANCE, null, null);\n     return new MapVector(name, allocator, fieldType, null);\n   }\n \n-  private final NullableMapReaderImpl reader = new NullableMapReaderImpl(this);\n-  private final NullableMapWriter writer = new NullableMapWriter(this);\n-\n-  protected ArrowBuf validityBuffer;\n-  private int validityAllocationSizeInBytes;\n+  private final SingleMapReaderImpl reader = new SingleMapReaderImpl(this);\n+  protected final FieldType fieldType;\n+  public int valueCount;\n \n   // deprecated, use FieldType or static constructor instead\n   @Deprecated\n   public MapVector(String name, BufferAllocator allocator, CallBack callBack) {\n-    this(name, allocator, FieldType.nullable(ArrowType.Struct.INSTANCE), callBack);\n+    this(name, allocator, new FieldType(false, ArrowType.Struct.INSTANCE, null, null), callBack);\n   }\n \n-  // deprecated, use FieldType or static constructor instead\n-  @Deprecated\n-  public MapVector(String name, BufferAllocator allocator, DictionaryEncoding dictionary, CallBack callBack) {\n-    this(name, allocator, new FieldType(true, ArrowType.Struct.INSTANCE, dictionary, null), callBack);\n+  public MapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(name, allocator, callBack);\n+    this.fieldType = checkNotNull(fieldType);\n+    this.valueCount = 0;\n   }\n \n-  public MapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n-    super(name, checkNotNull(allocator), fieldType, callBack);\n-    this.validityBuffer = allocator.getEmpty();\n-    this.validityAllocationSizeInBytes = BitVectorHelper.getValidityBufferSize(BaseValueVector.INITIAL_VALUE_ALLOCATION);\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  transient private MapTransferPair ephPair;\n+\n+  public void copyFromSafe(int fromIndex, int thisIndex, MapVector from) {\n+    if (ephPair == null || ephPair.from != from) {\n+      ephPair = (MapTransferPair) from.makeTransferPair(this);\n+    }\n+    ephPair.copyValueSafe(fromIndex, thisIndex);\n   }\n \n   @Override\n-  public Field getField() {\n-    Field f = super.getField();\n-    FieldType type = new FieldType(true, f.getType(), f.getFieldType().getDictionary(), f.getFieldType().getMetadata());\n-    return new Field(f.getName(), type, f.getChildren());\n+  protected boolean supportsDirectRead() {\n+    return true;\n+  }\n+\n+  public Iterator<String> fieldNameIterator() {\n+    return getChildFieldNames().iterator();\n   }\n \n   @Override\n-  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n-    if (ownBuffers.size() != 1) {\n-      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 1 + \", got: \" + ownBuffers.size());\n+  public void setInitialCapacity(int numRecords) {\n+    for (final ValueVector v : (Iterable<ValueVector>) this) {\n+      v.setInitialCapacity(numRecords);\n     }\n+  }\n \n-    ArrowBuf bitBuffer = ownBuffers.get(0);\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0 || size() == 0) {\n+      return 0;\n+    }\n+    long buffer = 0;\n+    for (final ValueVector v : (Iterable<ValueVector>) this) {\n+      buffer += v.getBufferSize();\n+    }\n \n-    validityBuffer.release();\n-    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n-    valueCount = fieldNode.getLength();\n-    validityAllocationSizeInBytes = validityBuffer.capacity();\n+    return (int) buffer;\n   }\n \n   @Override\n-  public List<ArrowBuf> getFieldBuffers() {\n-    List<ArrowBuf> result = new ArrayList<>(1);\n-    setReaderAndWriterIndex();\n-    result.add(validityBuffer);\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n \n-    return result;\n-  }\n+    long bufferSize = 0;\n+    for (final ValueVector v : (Iterable<ValueVector>) this) {\n+      bufferSize += v.getBufferSizeFor(valueCount);\n+    }\n \n-  private void setReaderAndWriterIndex() {\n-    validityBuffer.readerIndex(0);\n-    validityBuffer.writerIndex(BitVectorHelper.getValidityBufferSize(valueCount));\n+    return (int) bufferSize;\n   }\n \n   @Override\n-  @Deprecated\n-  public List<BufferBacked> getFieldInnerVectors() {\n-    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  public ArrowBuf getValidityBuffer() {\n+    throw new UnsupportedOperationException();\n   }\n \n   @Override\n-  public NullableMapReaderImpl getReader() {\n-    return reader;\n+  public ArrowBuf getDataBuffer() {\n+    throw new UnsupportedOperationException();\n   }\n \n-  public NullableMapWriter getWriter() {\n-    return writer;\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    throw new UnsupportedOperationException();\n   }\n \n   @Override\n   public TransferPair getTransferPair(BufferAllocator allocator) {\n-    return new NullableMapTransferPair(this, new MapVector(name, allocator, fieldType, null), false);\n+    return getTransferPair(name, allocator, null);\n   }\n \n   @Override\n-  public TransferPair makeTransferPair(ValueVector to) {\n-    return new NullableMapTransferPair(this, (MapVector) to, true);\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new MapTransferPair(this, new MapVector(name, allocator, fieldType, callBack), false);\n   }\n \n   @Override\n-  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n-    return new NullableMapTransferPair(this, new MapVector(ref, allocator, fieldType, null), false);\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new MapTransferPair(this, (MapVector) to);\n   }\n \n   @Override\n-  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n-    return new NullableMapTransferPair(this, new MapVector(ref, allocator, fieldType, callBack), false);\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new MapTransferPair(this, new MapVector(ref, allocator, fieldType, callBack), false);\n   }\n \n-  protected class NullableMapTransferPair extends MapTransferPair {\n-\n-    private MapVector target;\n+  protected static class MapTransferPair implements TransferPair {\n+    private final TransferPair[] pairs;\n+    private final MapVector from;\n+    private final MapVector to;\n \n-    protected NullableMapTransferPair(MapVector from, MapVector to, boolean allocate) {\n-      super(from, to, allocate);\n-      this.target = to;\n+    public MapTransferPair(MapVector from, MapVector to) {\n+      this(from, to, true);\n     }\n \n-    @Override\n-    public void transfer() {\n-      target.clear();\n-      target.validityBuffer = validityBuffer.transferOwnership(target.allocator).buffer;\n-      super.transfer();\n-      clear();\n+    protected MapTransferPair(MapVector from, MapVector to, boolean allocate) {\n+      this.from = from;\n+      this.to = to;\n+      this.pairs = new TransferPair[from.size()];\n+      this.to.ephPair = null;\n+\n+      int i = 0;\n+      FieldVector vector;\n+      for (String child : from.getChildFieldNames()) {\n+        int preSize = to.size();\n+        vector = from.getChild(child);\n+        if (vector == null) {\n+          continue;\n+        }\n+        //DRILL-1872: we add the child fields for the vector, looking up the field by name. For a map vector,\n+        // the child fields may be nested fields of the top level child. For example if the structure\n+        // of a child field is oa.oab.oabc then we add oa, then add oab to oa then oabc to oab.\n+        // But the children member of a Materialized field is a HashSet. If the fields are added in the\n+        // children HashSet, and the hashCode of the Materialized field includes the hash code of the\n+        // children, the hashCode value of oa changes *after* the field has been added to the HashSet.\n+        // (This is similar to what happens in ScanBatch where the children cannot be added till they are\n+        // read). To take care of this, we ensure that the hashCode of the MaterializedField does not\n+        // include the hashCode of the children but is based only on MaterializedField$key.\n+        final FieldVector newVector = to.addOrGet(child, vector.getField().getFieldType(), vector.getClass());\n+        if (allocate && to.size() != preSize) {\n+          newVector.allocateNew();\n+        }\n+        pairs[i++] = vector.makeTransferPair(newVector);\n+      }\n     }\n \n     @Override\n-    public void copyValueSafe(int fromIndex, int toIndex) {\n-      while (toIndex >= target.getValidityBufferValueCapacity()) {\n-        target.reallocValidityBuffer();\n+    public void transfer() {\n+      for (final TransferPair p : pairs) {\n+        p.transfer();\n       }\n-      BitVectorHelper.setValidityBit(target.validityBuffer, toIndex, isSet(fromIndex));\n-      super.copyValueSafe(fromIndex, toIndex);\n+      to.valueCount = from.valueCount;\n+      from.clear();\n     }\n \n     @Override\n-    public void splitAndTransfer(int startIndex, int length) {\n-      target.clear();\n-      splitAndTransferValidityBuffer(startIndex, length, target);\n-      super.splitAndTransfer(startIndex, length);\n+    public ValueVector getTo() {\n+      return to;\n     }\n-  }\n \n-  /*\n-   * transfer the validity.\n-   */\n-  private void splitAndTransferValidityBuffer(int startIndex, int length, MapVector target) {\n-    assert startIndex + length <= valueCount;\n-    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n-    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n-    int byteSizeTarget = BitVectorHelper.getValidityBufferSize(length);\n-    int offset = startIndex % 8;\n-\n-    if (length > 0) {\n-      if (offset == 0) {\n-        // slice\n-        if (target.validityBuffer != null) {\n-          target.validityBuffer.release();\n-        }\n-        target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n-        target.validityBuffer.retain(1);\n-      } else {\n-        /* Copy data\n-         * When the first bit starts from the middle of a byte (offset != 0),\n-         * copy data from src BitVector.\n-         * Each byte in the target is composed by a part in i-th byte,\n-         * another part in (i+1)-th byte.\n-         */\n-        target.allocateValidityBuffer(byteSizeTarget);\n-\n-        for (int i = 0; i < byteSizeTarget - 1; i++) {\n-          byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n-          byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n-\n-          target.validityBuffer.setByte(i, (b1 + b2));\n-        }\n-\n-        /* Copying the last piece is done in the following manner:\n-         * if the source vector has 1 or more bytes remaining, we copy\n-         * the last piece as a byte formed by shifting data\n-         * from the current byte and the next byte.\n-         *\n-         * if the source vector has no more bytes remaining\n-         * (we are at the last byte), we copy the last piece as a byte\n-         * by shifting data from the current byte.\n-         */\n-        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n-          byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n-                  firstByteSource + byteSizeTarget - 1, offset);\n-          byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n-                  firstByteSource + byteSizeTarget, offset);\n-\n-          target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n-        } else {\n-          byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n-                  firstByteSource + byteSizeTarget - 1, offset);\n-          target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n-        }\n+    @Override\n+    public void copyValueSafe(int from, int to) {\n+      for (TransferPair p : pairs) {\n+        p.copyValueSafe(from, to);\n       }\n     }\n-  }\n-\n-  /**\n-   * Get the value capacity of the internal validity buffer.\n-   * @return number of elements that validity buffer can hold\n-   */\n-  private int getValidityBufferValueCapacity() {\n-    return (int) (validityBuffer.capacity() * 8L);\n-  }\n-\n-  /**\n-   * Get the current value capacity for the vector\n-   * @return number of elements that vector can hold.\n-   */\n-  @Override\n-  public int getValueCapacity() {\n-    return Math.min(getValidityBufferValueCapacity(),\n-            super.getValueCapacity());\n-  }\n \n-  /**\n-   * Return the underlying buffers associated with this vector. Note that this doesn't\n-   * impact the reference counts for this buffer so it only should be used for in-context\n-   * access. Also note that this buffer changes regularly thus\n-   * external classes shouldn't hold a reference to it (unless they change it).\n-   *\n-   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n-   *              but the returned array will be the only reference to them\n-   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n-   *         vector instance.\n-   */\n-  @Override\n-  public ArrowBuf[] getBuffers(boolean clear) {\n-    setReaderAndWriterIndex();\n-    final ArrowBuf[] buffers;\n-    if (getBufferSize() == 0) {\n-      buffers = new ArrowBuf[0];\n-    } else {\n-      buffers = ObjectArrays.concat(new ArrowBuf[]{validityBuffer}, super.getBuffers(false),\n-              ArrowBuf.class);\n-    }\n-    if (clear) {\n-      for (ArrowBuf buffer : buffers) {\n-        buffer.retain();\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      for (TransferPair p : pairs) {\n+        p.splitAndTransfer(startIndex, length);\n       }\n-      clear();\n+      to.setValueCount(length);\n     }\n-\n-    return buffers;\n   }\n \n-  /**\n-   * Close the vector and release the associated buffers.\n-   */\n   @Override\n-  public void close() {\n-    clearValidityBuffer();\n-    super.close();\n-  }\n-\n-  /**\n-   * Same as {@link #close()}\n-   */\n-  @Override\n-  public void clear() {\n-    clearValidityBuffer();\n-    super.clear();\n-  }\n-\n-  /**\n-   * Release the validity buffer\n-   */\n-  private void clearValidityBuffer() {\n-    validityBuffer.release();\n-    validityBuffer = allocator.getEmpty();\n-  }\n-\n-  /**\n-   * Get the size (number of bytes) of underlying buffers used by this\n-   * vector\n-   * @return size of underlying buffers.\n-   */\n-  @Override\n-  public int getBufferSize() {\n-    if (valueCount == 0) {\n+  public int getValueCapacity() {\n+    if (size() == 0) {\n       return 0;\n     }\n-    return super.getBufferSize() +\n-            BitVectorHelper.getValidityBufferSize(valueCount);\n-  }\n \n-  /**\n-   * Get the potential buffer size for a particular number of records.\n-   * @param valueCount desired number of elements in the vector\n-   * @return estimated size of underlying buffers if the vector holds\n-   *         a given number of elements\n-   */\n-  @Override\n-  public int getBufferSizeFor(final int valueCount) {\n-    if (valueCount == 0) {\n-      return 0;\n-    }\n-    return super.getBufferSizeFor(valueCount)\n-            + BitVectorHelper.getValidityBufferSize(valueCount);\n-  }\n+    final Ordering<ValueVector> natural = new Ordering<ValueVector>() {\n+      @Override\n+      public int compare(@Nullable ValueVector left, @Nullable ValueVector right) {\n+        return Ints.compare(\n+            checkNotNull(left).getValueCapacity(),\n+            checkNotNull(right).getValueCapacity()\n+        );\n+      }\n+    };\n \n-  @Override\n-  public void setInitialCapacity(int numRecords) {\n-    validityAllocationSizeInBytes = BitVectorHelper.getValidityBufferSize(numRecords);\n-    super.setInitialCapacity(numRecords);\n+    return natural.min(getChildren()).getValueCapacity();\n   }\n \n   @Override\n-  public boolean allocateNewSafe() {\n-    /* Boolean to keep track if all the memory allocations were successful\n-     * Used in the case of composite vectors when we need to allocate multiple\n-     * buffers for multiple vectors. If one of the allocations failed we need to\n-     * clear all the memory that we allocated\n-     */\n-    boolean success = false;\n-    try {\n-      clear();\n-      allocateValidityBuffer(validityAllocationSizeInBytes);\n-      success = super.allocateNewSafe();\n-    } finally {\n-      if (!success) {\n-        clear();\n-        return false;\n+  public Object getObject(int index) {\n+    Map<String, Object> vv = new JsonStringHashMap<>();\n+    for (String child : getChildFieldNames()) {\n+      ValueVector v = getChild(child);\n+      if (v != null && index < v.getValueCount()) {\n+        Object value = v.getObject(index);\n+        if (value != null) {\n+          vv.put(child, value);\n+        }\n       }\n     }\n-    return true;\n-  }\n-\n-  private void allocateValidityBuffer(final long size) {\n-    final int curSize = (int) size;\n-    validityBuffer = allocator.buffer(curSize);\n-    validityBuffer.readerIndex(0);\n-    validityAllocationSizeInBytes = curSize;\n-    validityBuffer.setZero(0, validityBuffer.capacity());\n+    return vv;\n   }\n \n   @Override\n-  public void reAlloc() {\n-    /* reallocate the validity buffer */\n-    reallocValidityBuffer();\n-    super.reAlloc();\n-  }\n-\n-  private void reallocValidityBuffer() {\n-    final int currentBufferCapacity = validityBuffer.capacity();\n-    long baseSize = validityAllocationSizeInBytes;\n-\n-    if (baseSize < (long) currentBufferCapacity) {\n-      baseSize = (long) currentBufferCapacity;\n-    }\n-\n-    long newAllocationSize = baseSize * 2L;\n-    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n-\n-    if (newAllocationSize > BaseValueVector.MAX_ALLOCATION_SIZE) {\n-      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n-    }\n-\n-    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n-    newBuf.setZero(0, newBuf.capacity());\n-    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n-    validityBuffer.release(1);\n-    validityBuffer = newBuf;\n-    validityAllocationSizeInBytes = (int) newAllocationSize;\n-  }\n-\n+  public boolean isNull(int index) { return false; }\n   @Override\n-  public long getValidityBufferAddress() {\n-    return validityBuffer.memoryAddress();\n-  }\n+  public int getNullCount() { return 0; }\n \n-  @Override\n-  public long getDataBufferAddress() {\n-    throw new UnsupportedOperationException();\n+  public void get(int index, ComplexHolder holder) {\n+    reader.setPosition(index);\n+    holder.reader = reader;\n   }\n \n   @Override\n-  public long getOffsetBufferAddress() {\n-    throw new UnsupportedOperationException();\n+  public int getValueCount() {\n+    return valueCount;\n   }\n \n-  @Override\n-  public ArrowBuf getValidityBuffer() {\n-    return validityBuffer;\n-  }\n+  public ValueVector getVectorById(int id) {\n+  return getChildByOrdinal(id);\n+}\n \n   @Override\n-  public ArrowBuf getDataBuffer() {\n-    throw new UnsupportedOperationException();\n+  public void setValueCount(int valueCount) {\n+    for (final ValueVector v : getChildren()) {\n+      v.setValueCount(valueCount);\n+    }\n+    MapVector.this.valueCount = valueCount;\n   }\n \n   @Override\n-  public ArrowBuf getOffsetBuffer() {\n-    throw new UnsupportedOperationException();\n+  public void clear() {\n+    for (final ValueVector v : getChildren()) {\n+      v.clear();\n+    }\n+    valueCount = 0;\n   }\n \n   @Override\n-  public Object getObject(int index) {\n-    if (isSet(index) == 0) {\n-      return null;\n-    } else {\n-      return super.getObject(index);\n+  public Field getField() {\n+    List<Field> children = new ArrayList<>();\n+    for (ValueVector child : getChildren()) {\n+      children.add(child.getField());\n     }\n+    return new Field(name, fieldType, children);\n   }\n \n   @Override\n-  public void get(int index, ComplexHolder holder) {\n-    holder.isSet = isSet(index);\n-    super.get(index, holder);\n+  public MinorType getMinorType() {\n+    return MinorType.MAP;\n   }\n \n-  public int getNullCount() {\n-    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n-  }\n-\n-  public boolean isNull(int index) {\n-    return isSet(index) == 0;\n-  }\n-\n-  public int isSet(int index) {\n-    final int byteIndex = index >> 3;\n-    final byte b = validityBuffer.getByte(byteIndex);\n-    final int bitIndex = index & 7;\n-    return Long.bitCount(b & (1L << bitIndex));\n-  }\n-\n-  public void setIndexDefined(int index) {\n-    while (index >= getValidityBufferValueCapacity()) {\n-      /* realloc the inner buffers if needed */\n-      reallocValidityBuffer();\n+  @Override\n+  public void close() {\n+    final Collection<FieldVector> vectors = getChildren();\n+    for (final FieldVector v : vectors) {\n+      v.close();\n     }\n-    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n-  }\n+    vectors.clear();\n \n-  public void setNull(int index) {\n-    while (index >= getValidityBufferValueCapacity()) {\n-      /* realloc the inner buffers if needed */\n-      reallocValidityBuffer();\n-    }\n-    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    valueCount = 0;\n+\n+    super.close();\n   }\n \n-  @Override\n-  public void setValueCount(int valueCount) {\n-    assert valueCount >= 0;\n-    while (valueCount > getValidityBufferValueCapacity()) {\n-      /* realloc the inner buffers if needed */\n-      reallocValidityBuffer();\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    for (Field field : children) {\n+      FieldVector vector = (FieldVector) this.add(field.getName(), field.getFieldType());\n+      vector.initializeChildrenFromFields(field.getChildren());\n     }\n-    super.setValueCount(valueCount);\n-    this.valueCount = valueCount;\n   }\n \n-  public void reset() {\n-    valueCount = 0;\n+  public List<FieldVector> getChildrenFromFields() {\n+    return getChildren();\n   }\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/NonNullableMapVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/NonNullableMapVector.java\ndeleted file mode 100644\nindex 1cd7b70d7..000000000\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/NonNullableMapVector.java\n+++ /dev/null\n@@ -1,342 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.arrow.vector.complex;\n-\n-import static com.google.common.base.Preconditions.checkNotNull;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-\n-import javax.annotation.Nullable;\n-\n-import com.google.common.base.Preconditions;\n-import com.google.common.collect.Ordering;\n-import com.google.common.primitives.Ints;\n-\n-import io.netty.buffer.ArrowBuf;\n-\n-import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.vector.*;\n-import org.apache.arrow.vector.complex.impl.SingleMapReaderImpl;\n-import org.apache.arrow.vector.complex.reader.FieldReader;\n-import org.apache.arrow.vector.holders.ComplexHolder;\n-import org.apache.arrow.vector.types.Types.MinorType;\n-import org.apache.arrow.vector.types.pojo.ArrowType;\n-import org.apache.arrow.vector.types.pojo.Field;\n-import org.apache.arrow.vector.types.pojo.FieldType;\n-import org.apache.arrow.vector.util.CallBack;\n-import org.apache.arrow.vector.util.JsonStringHashMap;\n-import org.apache.arrow.vector.util.TransferPair;\n-\n-public class NonNullableMapVector extends AbstractMapVector {\n-  //private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(NonNullableMapVector.class);\n-\n-  public static NonNullableMapVector empty(String name, BufferAllocator allocator) {\n-    FieldType fieldType = new FieldType(false, ArrowType.Struct.INSTANCE, null, null);\n-    return new NonNullableMapVector(name, allocator, fieldType, null);\n-  }\n-\n-  private final SingleMapReaderImpl reader = new SingleMapReaderImpl(this);\n-  protected final FieldType fieldType;\n-  public int valueCount;\n-\n-  // deprecated, use FieldType or static constructor instead\n-  @Deprecated\n-  public NonNullableMapVector(String name, BufferAllocator allocator, CallBack callBack) {\n-    this(name, allocator, new FieldType(false, ArrowType.Struct.INSTANCE, null, null), callBack);\n-  }\n-\n-  public NonNullableMapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n-    super(name, allocator, callBack);\n-    this.fieldType = checkNotNull(fieldType);\n-    this.valueCount = 0;\n-  }\n-\n-  @Override\n-  public FieldReader getReader() {\n-    return reader;\n-  }\n-\n-  transient private MapTransferPair ephPair;\n-\n-  public void copyFromSafe(int fromIndex, int thisIndex, NonNullableMapVector from) {\n-    if (ephPair == null || ephPair.from != from) {\n-      ephPair = (MapTransferPair) from.makeTransferPair(this);\n-    }\n-    ephPair.copyValueSafe(fromIndex, thisIndex);\n-  }\n-\n-  @Override\n-  protected boolean supportsDirectRead() {\n-    return true;\n-  }\n-\n-  public Iterator<String> fieldNameIterator() {\n-    return getChildFieldNames().iterator();\n-  }\n-\n-  @Override\n-  public void setInitialCapacity(int numRecords) {\n-    for (final ValueVector v : (Iterable<ValueVector>) this) {\n-      v.setInitialCapacity(numRecords);\n-    }\n-  }\n-\n-  @Override\n-  public int getBufferSize() {\n-    if (valueCount == 0 || size() == 0) {\n-      return 0;\n-    }\n-    long buffer = 0;\n-    for (final ValueVector v : (Iterable<ValueVector>) this) {\n-      buffer += v.getBufferSize();\n-    }\n-\n-    return (int) buffer;\n-  }\n-\n-  @Override\n-  public int getBufferSizeFor(final int valueCount) {\n-    if (valueCount == 0) {\n-      return 0;\n-    }\n-\n-    long bufferSize = 0;\n-    for (final ValueVector v : (Iterable<ValueVector>) this) {\n-      bufferSize += v.getBufferSizeFor(valueCount);\n-    }\n-\n-    return (int) bufferSize;\n-  }\n-\n-  @Override\n-  public ArrowBuf getValidityBuffer() {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public ArrowBuf getDataBuffer() {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public ArrowBuf getOffsetBuffer() {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public TransferPair getTransferPair(BufferAllocator allocator) {\n-    return getTransferPair(name, allocator, null);\n-  }\n-\n-  @Override\n-  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n-    return new MapTransferPair(this, new NonNullableMapVector(name, allocator, fieldType, callBack), false);\n-  }\n-\n-  @Override\n-  public TransferPair makeTransferPair(ValueVector to) {\n-    return new MapTransferPair(this, (NonNullableMapVector) to);\n-  }\n-\n-  @Override\n-  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n-    return new MapTransferPair(this, new NonNullableMapVector(ref, allocator, fieldType, callBack), false);\n-  }\n-\n-  protected static class MapTransferPair implements TransferPair {\n-    private final TransferPair[] pairs;\n-    private final NonNullableMapVector from;\n-    private final NonNullableMapVector to;\n-\n-    public MapTransferPair(NonNullableMapVector from, NonNullableMapVector to) {\n-      this(from, to, true);\n-    }\n-\n-    protected MapTransferPair(NonNullableMapVector from, NonNullableMapVector to, boolean allocate) {\n-      this.from = from;\n-      this.to = to;\n-      this.pairs = new TransferPair[from.size()];\n-      this.to.ephPair = null;\n-\n-      int i = 0;\n-      FieldVector vector;\n-      for (String child : from.getChildFieldNames()) {\n-        int preSize = to.size();\n-        vector = from.getChild(child);\n-        if (vector == null) {\n-          continue;\n-        }\n-        //DRILL-1872: we add the child fields for the vector, looking up the field by name. For a map vector,\n-        // the child fields may be nested fields of the top level child. For example if the structure\n-        // of a child field is oa.oab.oabc then we add oa, then add oab to oa then oabc to oab.\n-        // But the children member of a Materialized field is a HashSet. If the fields are added in the\n-        // children HashSet, and the hashCode of the Materialized field includes the hash code of the\n-        // children, the hashCode value of oa changes *after* the field has been added to the HashSet.\n-        // (This is similar to what happens in ScanBatch where the children cannot be added till they are\n-        // read). To take care of this, we ensure that the hashCode of the MaterializedField does not\n-        // include the hashCode of the children but is based only on MaterializedField$key.\n-        final FieldVector newVector = to.addOrGet(child, vector.getField().getFieldType(), vector.getClass());\n-        if (allocate && to.size() != preSize) {\n-          newVector.allocateNew();\n-        }\n-        pairs[i++] = vector.makeTransferPair(newVector);\n-      }\n-    }\n-\n-    @Override\n-    public void transfer() {\n-      for (final TransferPair p : pairs) {\n-        p.transfer();\n-      }\n-      to.valueCount = from.valueCount;\n-      from.clear();\n-    }\n-\n-    @Override\n-    public ValueVector getTo() {\n-      return to;\n-    }\n-\n-    @Override\n-    public void copyValueSafe(int from, int to) {\n-      for (TransferPair p : pairs) {\n-        p.copyValueSafe(from, to);\n-      }\n-    }\n-\n-    @Override\n-    public void splitAndTransfer(int startIndex, int length) {\n-      for (TransferPair p : pairs) {\n-        p.splitAndTransfer(startIndex, length);\n-      }\n-      to.setValueCount(length);\n-    }\n-  }\n-\n-  @Override\n-  public int getValueCapacity() {\n-    if (size() == 0) {\n-      return 0;\n-    }\n-\n-    final Ordering<ValueVector> natural = new Ordering<ValueVector>() {\n-      @Override\n-      public int compare(@Nullable ValueVector left, @Nullable ValueVector right) {\n-        return Ints.compare(\n-            checkNotNull(left).getValueCapacity(),\n-            checkNotNull(right).getValueCapacity()\n-        );\n-      }\n-    };\n-\n-    return natural.min(getChildren()).getValueCapacity();\n-  }\n-\n-  @Override\n-  public Object getObject(int index) {\n-    Map<String, Object> vv = new JsonStringHashMap<>();\n-    for (String child : getChildFieldNames()) {\n-      ValueVector v = getChild(child);\n-      if (v != null && index < v.getValueCount()) {\n-        Object value = v.getObject(index);\n-        if (value != null) {\n-          vv.put(child, value);\n-        }\n-      }\n-    }\n-    return vv;\n-  }\n-\n-  @Override\n-  public boolean isNull(int index) { return false; }\n-  @Override\n-  public int getNullCount() { return 0; }\n-\n-  public void get(int index, ComplexHolder holder) {\n-    reader.setPosition(index);\n-    holder.reader = reader;\n-  }\n-\n-  @Override\n-  public int getValueCount() {\n-    return valueCount;\n-  }\n-\n-  public ValueVector getVectorById(int id) {\n-  return getChildByOrdinal(id);\n-}\n-\n-  @Override\n-  public void setValueCount(int valueCount) {\n-    for (final ValueVector v : getChildren()) {\n-      v.setValueCount(valueCount);\n-    }\n-    NonNullableMapVector.this.valueCount = valueCount;\n-  }\n-\n-  @Override\n-  public void clear() {\n-    for (final ValueVector v : getChildren()) {\n-      v.clear();\n-    }\n-    valueCount = 0;\n-  }\n-\n-  @Override\n-  public Field getField() {\n-    List<Field> children = new ArrayList<>();\n-    for (ValueVector child : getChildren()) {\n-      children.add(child.getField());\n-    }\n-    return new Field(name, fieldType, children);\n-  }\n-\n-  @Override\n-  public MinorType getMinorType() {\n-    return MinorType.MAP;\n-  }\n-\n-  @Override\n-  public void close() {\n-    final Collection<FieldVector> vectors = getChildren();\n-    for (final FieldVector v : vectors) {\n-      v.close();\n-    }\n-    vectors.clear();\n-\n-    valueCount = 0;\n-\n-    super.close();\n-  }\n-\n-  public void initializeChildrenFromFields(List<Field> children) {\n-    for (Field field : children) {\n-      FieldVector vector = (FieldVector) this.add(field.getName(), field.getFieldType());\n-      vector.initializeChildrenFromFields(field.getChildren());\n-    }\n-  }\n-\n-  public List<FieldVector> getChildrenFromFields() {\n-    return getChildren();\n-  }\n-}\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/NullableMapVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/NullableMapVector.java\nnew file mode 100644\nindex 000000000..d887b7306\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/NullableMapVector.java\n@@ -0,0 +1,500 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import com.google.common.collect.ObjectArrays;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.impl.NullableMapReaderImpl;\n+import org.apache.arrow.vector.complex.impl.NullableMapWriter;\n+import org.apache.arrow.vector.holders.ComplexHolder;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.ArrowType.Struct;\n+import org.apache.arrow.vector.types.pojo.DictionaryEncoding;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+public class NullableMapVector extends MapVector implements FieldVector {\n+\n+  public static NullableMapVector empty(String name, BufferAllocator allocator) {\n+    FieldType fieldType = FieldType.nullable(Struct.INSTANCE);\n+    return new NullableMapVector(name, allocator, fieldType, null);\n+  }\n+\n+  private final NullableMapReaderImpl reader = new NullableMapReaderImpl(this);\n+  private final NullableMapWriter writer = new NullableMapWriter(this);\n+\n+  protected ArrowBuf validityBuffer;\n+  private int validityAllocationSizeInBytes;\n+\n+  // deprecated, use FieldType or static constructor instead\n+  @Deprecated\n+  public NullableMapVector(String name, BufferAllocator allocator, CallBack callBack) {\n+    this(name, allocator, FieldType.nullable(ArrowType.Struct.INSTANCE), callBack);\n+  }\n+\n+  // deprecated, use FieldType or static constructor instead\n+  @Deprecated\n+  public NullableMapVector(String name, BufferAllocator allocator, DictionaryEncoding dictionary, CallBack callBack) {\n+    this(name, allocator, new FieldType(true, ArrowType.Struct.INSTANCE, dictionary, null), callBack);\n+  }\n+\n+  public NullableMapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(name, checkNotNull(allocator), fieldType, callBack);\n+    this.validityBuffer = allocator.getEmpty();\n+    this.validityAllocationSizeInBytes = BitVectorHelper.getValidityBufferSize(BaseValueVector.INITIAL_VALUE_ALLOCATION);\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    Field f = super.getField();\n+    FieldType type = new FieldType(true, f.getType(), f.getFieldType().getDictionary(), f.getFieldType().getMetadata());\n+    return new Field(f.getName(), type, f.getChildren());\n+  }\n+\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 1) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 1 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+\n+    validityBuffer.release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    valueCount = fieldNode.getLength();\n+    validityAllocationSizeInBytes = validityBuffer.capacity();\n+  }\n+\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(1);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+\n+    return result;\n+  }\n+\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    validityBuffer.writerIndex(BitVectorHelper.getValidityBufferSize(valueCount));\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  @Override\n+  public NullableMapReaderImpl getReader() {\n+    return reader;\n+  }\n+\n+  public NullableMapWriter getWriter() {\n+    return writer;\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(BufferAllocator allocator) {\n+    return new NullableMapTransferPair(this, new NullableMapVector(name, allocator, fieldType, null), false);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new NullableMapTransferPair(this, (NullableMapVector) to, true);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new NullableMapTransferPair(this, new NullableMapVector(ref, allocator, fieldType, null), false);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new NullableMapTransferPair(this, new NullableMapVector(ref, allocator, fieldType, callBack), false);\n+  }\n+\n+  protected class NullableMapTransferPair extends MapTransferPair {\n+\n+    private NullableMapVector target;\n+\n+    protected NullableMapTransferPair(NullableMapVector from, NullableMapVector to, boolean allocate) {\n+      super(from, to, allocate);\n+      this.target = to;\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      target.clear();\n+      target.validityBuffer = validityBuffer.transferOwnership(target.allocator).buffer;\n+      super.transfer();\n+      clear();\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      while (toIndex >= target.getValidityBufferValueCapacity()) {\n+        target.reallocValidityBuffer();\n+      }\n+      BitVectorHelper.setValidityBit(target.validityBuffer, toIndex, isSet(fromIndex));\n+      super.copyValueSafe(fromIndex, toIndex);\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      target.clear();\n+      splitAndTransferValidityBuffer(startIndex, length, target);\n+      super.splitAndTransfer(startIndex, length);\n+    }\n+  }\n+\n+  /*\n+   * transfer the validity.\n+   */\n+  private void splitAndTransferValidityBuffer(int startIndex, int length, NullableMapVector target) {\n+    assert startIndex + length <= valueCount;\n+    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+    int byteSizeTarget = BitVectorHelper.getValidityBufferSize(length);\n+    int offset = startIndex % 8;\n+\n+    if (length > 0) {\n+      if (offset == 0) {\n+        // slice\n+        if (target.validityBuffer != null) {\n+          target.validityBuffer.release();\n+        }\n+        target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+        target.validityBuffer.retain(1);\n+      } else {\n+        /* Copy data\n+         * When the first bit starts from the middle of a byte (offset != 0),\n+         * copy data from src BitVector.\n+         * Each byte in the target is composed by a part in i-th byte,\n+         * another part in (i+1)-th byte.\n+         */\n+        target.allocateValidityBuffer(byteSizeTarget);\n+\n+        for (int i = 0; i < byteSizeTarget - 1; i++) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n+\n+          target.validityBuffer.setByte(i, (b1 + b2));\n+        }\n+\n+        /* Copying the last piece is done in the following manner:\n+         * if the source vector has 1 or more bytes remaining, we copy\n+         * the last piece as a byte formed by shifting data\n+         * from the current byte and the next byte.\n+         *\n+         * if the source vector has no more bytes remaining\n+         * (we are at the last byte), we copy the last piece as a byte\n+         * by shifting data from the current byte.\n+         */\n+        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n+                  firstByteSource + byteSizeTarget, offset);\n+\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+        } else {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Get the value capacity of the internal validity buffer.\n+   * @return number of elements that validity buffer can hold\n+   */\n+  private int getValidityBufferValueCapacity() {\n+    return (int) (validityBuffer.capacity() * 8L);\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return Math.min(getValidityBufferValueCapacity(),\n+            super.getValueCapacity());\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    setReaderAndWriterIndex();\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = ObjectArrays.concat(new ArrowBuf[]{validityBuffer}, super.getBuffers(false),\n+              ArrowBuf.class);\n+    }\n+    if (clear) {\n+      for (ArrowBuf buffer : buffers) {\n+        buffer.retain();\n+      }\n+      clear();\n+    }\n+\n+    return buffers;\n+  }\n+\n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n+  @Override\n+  public void close() {\n+    clearValidityBuffer();\n+    super.close();\n+  }\n+\n+  /**\n+   * Same as {@link #close()}\n+   */\n+  @Override\n+  public void clear() {\n+    clearValidityBuffer();\n+    super.clear();\n+  }\n+\n+  /**\n+   * Release the validity buffer\n+   */\n+  private void clearValidityBuffer() {\n+    validityBuffer.release();\n+    validityBuffer = allocator.getEmpty();\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    return super.getBufferSize() +\n+            BitVectorHelper.getValidityBufferSize(valueCount);\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param valueCount desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    return super.getBufferSizeFor(valueCount)\n+            + BitVectorHelper.getValidityBufferSize(valueCount);\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = BitVectorHelper.getValidityBufferSize(numRecords);\n+    super.setInitialCapacity(numRecords);\n+  }\n+\n+  @Override\n+  public boolean allocateNewSafe() {\n+    /* Boolean to keep track if all the memory allocations were successful\n+     * Used in the case of composite vectors when we need to allocate multiple\n+     * buffers for multiple vectors. If one of the allocations failed we need to\n+     * clear all the memory that we allocated\n+     */\n+    boolean success = false;\n+    try {\n+      clear();\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      success = super.allocateNewSafe();\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+\n+  @Override\n+  public void reAlloc() {\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n+    super.reAlloc();\n+  }\n+\n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = validityBuffer.capacity();\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > BaseValueVector.MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setZero(0, newBuf.capacity());\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    validityBuffer.release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return validityBuffer.memoryAddress();\n+  }\n+\n+  @Override\n+  public long getDataBufferAddress() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return super.getObject(index);\n+    }\n+  }\n+\n+  @Override\n+  public void get(int index, ComplexHolder holder) {\n+    holder.isSet = isSet(index);\n+    super.get(index, holder);\n+  }\n+\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  public boolean isNull(int index) {\n+    return isSet(index) == 0;\n+  }\n+\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return Long.bitCount(b & (1L << bitIndex));\n+  }\n+\n+  public void setIndexDefined(int index) {\n+    while (index >= getValidityBufferValueCapacity()) {\n+      /* realloc the inner buffers if needed */\n+      reallocValidityBuffer();\n+    }\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+  }\n+\n+  public void setNull(int index) {\n+    while (index >= getValidityBufferValueCapacity()) {\n+      /* realloc the inner buffers if needed */\n+      reallocValidityBuffer();\n+    }\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+  }\n+\n+  @Override\n+  public void setValueCount(int valueCount) {\n+    assert valueCount >= 0;\n+    while (valueCount > getValidityBufferValueCapacity()) {\n+      /* realloc the inner buffers if needed */\n+      reallocValidityBuffer();\n+    }\n+    super.setValueCount(valueCount);\n+    this.valueCount = valueCount;\n+  }\n+\n+  public void reset() {\n+    valueCount = 0;\n+  }\n+}\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/ComplexWriterImpl.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/ComplexWriterImpl.java\nindex 970b90ef5..a6960238b 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/ComplexWriterImpl.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/ComplexWriterImpl.java\n@@ -20,7 +20,7 @@\n \n import org.apache.arrow.vector.complex.ListVector;\n import org.apache.arrow.vector.complex.MapVector;\n-import org.apache.arrow.vector.complex.MapVector;\n+import org.apache.arrow.vector.complex.NullableMapVector;\n import org.apache.arrow.vector.complex.StateTool;\n import org.apache.arrow.vector.complex.writer.BaseWriter.ComplexWriter;\n import org.apache.arrow.vector.types.pojo.Field;\n@@ -131,7 +131,7 @@ public MapWriter directMap() {\n     switch (mode) {\n \n       case INIT:\n-        mapRoot = nullableMapWriterFactory.build((MapVector) container);\n+        mapRoot = nullableMapWriterFactory.build((NullableMapVector) container);\n         mapRoot.setPosition(idx());\n         mode = Mode.MAP;\n         break;\n@@ -152,7 +152,7 @@ public MapWriter rootAsMap() {\n \n       case INIT:\n         // TODO allow dictionaries in complex types\n-        MapVector map = container.addOrGetMap(name);\n+        NullableMapVector map = container.addOrGetMap(name);\n         mapRoot = nullableMapWriterFactory.build(map);\n         mapRoot.setPosition(idx());\n         mode = Mode.MAP;\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapReaderImpl.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapReaderImpl.java\nindex acf155af7..06b0f4d43 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapReaderImpl.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapReaderImpl.java\n@@ -20,17 +20,17 @@\n package org.apache.arrow.vector.complex.impl;\n \n import org.apache.arrow.vector.complex.MapVector;\n-import org.apache.arrow.vector.complex.MapVector;\n+import org.apache.arrow.vector.complex.NullableMapVector;\n import org.apache.arrow.vector.complex.writer.BaseWriter.MapWriter;\n import org.apache.arrow.vector.types.pojo.Field;\n \n public class NullableMapReaderImpl extends SingleMapReaderImpl {\n \n-  private MapVector nullableMapVector;\n+  private NullableMapVector nullableMapVector;\n \n   public NullableMapReaderImpl(MapVector vector) {\n-    super((MapVector) vector);\n-    this.nullableMapVector = (MapVector) vector;\n+    super((NullableMapVector) vector);\n+    this.nullableMapVector = (NullableMapVector) vector;\n   }\n \n   @Override\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapWriterFactory.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapWriterFactory.java\nindex 06dbf784b..d2dcb2374 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapWriterFactory.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapWriterFactory.java\n@@ -18,7 +18,7 @@\n \n package org.apache.arrow.vector.complex.impl;\n \n-import org.apache.arrow.vector.complex.MapVector;\n+import org.apache.arrow.vector.complex.NullableMapVector;\n \n public class NullableMapWriterFactory {\n   private final boolean caseSensitive;\n@@ -29,7 +29,7 @@ public NullableMapWriterFactory(boolean caseSensitive) {\n     this.caseSensitive = caseSensitive;\n   }\n \n-  public NullableMapWriter build(MapVector container) {\n+  public NullableMapWriter build(NullableMapVector container) {\n     return this.caseSensitive ? new NullableCaseSensitiveMapWriter(container) : new NullableMapWriter(container);\n   }\n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/PromotableWriter.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/PromotableWriter.java\nindex 9abd38d20..5bd439cac 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/PromotableWriter.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/PromotableWriter.java\n@@ -23,7 +23,7 @@\n import org.apache.arrow.vector.ZeroVector;\n import org.apache.arrow.vector.complex.AbstractMapVector;\n import org.apache.arrow.vector.complex.ListVector;\n-import org.apache.arrow.vector.complex.MapVector;\n+import org.apache.arrow.vector.complex.NullableMapVector;\n import org.apache.arrow.vector.complex.UnionVector;\n import org.apache.arrow.vector.complex.writer.FieldWriter;\n import org.apache.arrow.vector.types.Types.MinorType;\n@@ -94,7 +94,7 @@ private void setWriter(ValueVector v) {\n     type = v.getMinorType();\n     switch (type) {\n       case MAP:\n-        writer = nullableMapWriterFactory.build((MapVector) vector);\n+        writer = nullableMapWriterFactory.build((NullableMapVector) vector);\n         break;\n       case LIST:\n         writer = new UnionListWriter((ListVector) vector, nullableMapWriterFactory);\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/SingleMapReaderImpl.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/SingleMapReaderImpl.java\nindex 0341b622e..c77ca4e8f 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/SingleMapReaderImpl.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/SingleMapReaderImpl.java\n@@ -24,7 +24,6 @@\n \n import org.apache.arrow.vector.ValueVector;\n import org.apache.arrow.vector.complex.MapVector;\n-import org.apache.arrow.vector.complex.NonNullableMapVector;\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.complex.writer.BaseWriter.MapWriter;\n import org.apache.arrow.vector.types.Types.MinorType;\n@@ -35,10 +34,10 @@\n @SuppressWarnings(\"unused\")\n public class SingleMapReaderImpl extends AbstractFieldReader {\n \n-  private final NonNullableMapVector vector;\n+  private final MapVector vector;\n   private final Map<String, FieldReader> fields = Maps.newHashMap();\n \n-  public SingleMapReaderImpl(NonNullableMapVector vector) {\n+  public SingleMapReaderImpl(MapVector vector) {\n     this.vector = vector;\n   }\n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/types/Types.java b/java/vector/src/main/java/org/apache/arrow/vector/types/Types.java\nindex 7834845aa..3c5fd81d5 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/types/Types.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/types/Types.java\n@@ -58,7 +58,7 @@\n import org.apache.arrow.vector.ZeroVector;\n import org.apache.arrow.vector.complex.FixedSizeListVector;\n import org.apache.arrow.vector.complex.ListVector;\n-import org.apache.arrow.vector.complex.MapVector;\n+import org.apache.arrow.vector.complex.NullableMapVector;\n import org.apache.arrow.vector.complex.UnionVector;\n import org.apache.arrow.vector.complex.impl.BigIntWriterImpl;\n import org.apache.arrow.vector.complex.impl.BitWriterImpl;\n@@ -131,12 +131,12 @@ public FieldWriter getNewFieldWriter(ValueVector vector) {\n     MAP(Struct.INSTANCE) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new MapVector(name, allocator, fieldType, schemaChangeCallback);\n+        return new NullableMapVector(name, allocator, fieldType, schemaChangeCallback);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new NullableMapWriter((MapVector) vector);\n+        return new NullableMapWriter((NullableMapVector) vector);\n       }\n     },\n     TINYINT(new Int(8, true)) {\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestMapVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestMapVector.java\nindex e5682955b..357df96aa 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestMapVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestMapVector.java\n@@ -22,7 +22,7 @@\n import java.util.Map;\n \n import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.vector.complex.MapVector;\n+import org.apache.arrow.vector.complex.NullableMapVector;\n import org.apache.arrow.vector.types.pojo.ArrowType.Struct;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.junit.After;\n@@ -50,7 +50,7 @@ public void testFieldMetadata() throws Exception {\n     Map<String, String> metadata = new HashMap<>();\n     metadata.put(\"k1\", \"v1\");\n     FieldType type = new FieldType(true, Struct.INSTANCE, null, metadata);\n-    try (MapVector vector = new MapVector(\"map\", allocator, type, null)) {\n+    try (NullableMapVector vector = new NullableMapVector(\"map\", allocator, type, null)) {\n       Assert.assertEquals(vector.getField().getMetadata(), type.getMetadata());\n     }\n   }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java\nindex 1b13c2ed9..f8edf8904 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java\n@@ -26,7 +26,7 @@\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.memory.RootAllocator;\n import org.apache.arrow.vector.complex.ListVector;\n-import org.apache.arrow.vector.complex.MapVector;\n+import org.apache.arrow.vector.complex.NullableMapVector;\n import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.ArrowType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n@@ -121,7 +121,7 @@ public void testListType() {\n \n   @Test\n   public void testMapType() {\n-    try (final MapVector vector = MapVector.empty(\"\", allocator)) {\n+    try (final NullableMapVector vector = NullableMapVector.empty(\"\", allocator)) {\n       vector.addOrGet(\"\", FieldType.nullable(MinorType.INT.getType()), IntVector.class);\n \n       vector.setInitialCapacity(512);\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/complex/impl/TestPromotableWriter.java b/java/vector/src/test/java/org/apache/arrow/vector/complex/impl/TestPromotableWriter.java\nindex 38b78424d..b0d6cf555 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/complex/impl/TestPromotableWriter.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/complex/impl/TestPromotableWriter.java\n@@ -25,7 +25,7 @@\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.DirtyRootAllocator;\n import org.apache.arrow.vector.complex.MapVector;\n-import org.apache.arrow.vector.complex.MapVector;\n+import org.apache.arrow.vector.complex.NullableMapVector;\n import org.apache.arrow.vector.complex.UnionVector;\n import org.apache.arrow.vector.complex.writer.BaseWriter.MapWriter;\n import org.apache.arrow.vector.types.pojo.ArrowType;\n@@ -55,7 +55,7 @@ public void terminate() throws Exception {\n   public void testPromoteToUnion() throws Exception {\n \n     try (final MapVector container = MapVector.empty(EMPTY_SCHEMA_PATH, allocator);\n-         final MapVector v = container.addOrGetMap(\"test\");\n+         final NullableMapVector v = container.addOrGetMap(\"test\");\n          final PromotableWriter writer = new PromotableWriter(v, container)) {\n \n       container.allocateNew();\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/complex/writer/TestComplexWriter.java b/java/vector/src/test/java/org/apache/arrow/vector/complex/writer/TestComplexWriter.java\nindex bd8489eb2..29d39aabe 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/complex/writer/TestComplexWriter.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/complex/writer/TestComplexWriter.java\n@@ -34,7 +34,7 @@\n import org.apache.arrow.vector.IntVector;\n import org.apache.arrow.vector.complex.ListVector;\n import org.apache.arrow.vector.complex.MapVector;\n-import org.apache.arrow.vector.complex.NonNullableMapVector;\n+import org.apache.arrow.vector.complex.NullableMapVector;\n import org.apache.arrow.vector.complex.UnionVector;\n import org.apache.arrow.vector.complex.impl.ComplexWriterImpl;\n import org.apache.arrow.vector.complex.impl.SingleMapReaderImpl;\n@@ -830,7 +830,7 @@ public void complexCopierWithList() {\n     rootWriter.end();\n     writer.setValueCount(1);\n \n-    MapVector mapVector = (MapVector) parent.getChild(\"root\");\n+    NullableMapVector mapVector = (NullableMapVector) parent.getChild(\"root\");\n     TransferPair tp = mapVector.getTransferPair(allocator);\n     tp.splitAndTransfer(0, 1);\n     MapVector toMapVector = (MapVector) tp.getTo();\n@@ -849,7 +849,7 @@ public void testSingleMapWriter1() {\n     /* initialize a SingleMapWriter with empty MapVector and then lazily\n      * create all vectors with expected initialCapacity.\n      */\n-    NonNullableMapVector parent = NonNullableMapVector.empty(\"parent\", allocator);\n+    MapVector parent = MapVector.empty(\"parent\", allocator);\n     SingleMapWriter singleMapWriter = new SingleMapWriter(parent);\n \n     int initialCapacity = 1024;\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/ipc/BaseFileTest.java b/java/vector/src/test/java/org/apache/arrow/vector/ipc/BaseFileTest.java\nindex 1a7f71c72..9eb55c9bb 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/ipc/BaseFileTest.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/ipc/BaseFileTest.java\n@@ -36,7 +36,7 @@\n import org.apache.arrow.vector.VarCharVector;\n import org.apache.arrow.vector.VectorSchemaRoot;\n import org.apache.arrow.vector.complex.ListVector;\n-import org.apache.arrow.vector.complex.MapVector;\n+import org.apache.arrow.vector.complex.NullableMapVector;\n import org.apache.arrow.vector.complex.impl.ComplexWriterImpl;\n import org.apache.arrow.vector.complex.impl.UnionListWriter;\n import org.apache.arrow.vector.complex.reader.FieldReader;\n@@ -94,7 +94,7 @@ public void tearDown() {\n     DateTimeZone.setDefault(defaultTimezone);\n   }\n \n-  protected void writeData(int count, MapVector parent) {\n+  protected void writeData(int count, NullableMapVector parent) {\n     ComplexWriter writer = new ComplexWriterImpl(\"root\", parent);\n     MapWriter rootWriter = writer.rootAsMap();\n     IntWriter intWriter = rootWriter.integer(\"int\");\n@@ -119,7 +119,7 @@ protected void validateContent(int count, VectorSchemaRoot root) {\n     }\n   }\n \n-  protected void writeComplexData(int count, MapVector parent) {\n+  protected void writeComplexData(int count, NullableMapVector parent) {\n     ArrowBuf varchar = allocator.buffer(3);\n     varchar.readerIndex(0);\n     varchar.setByte(0, 'a');\n@@ -189,7 +189,7 @@ private LocalDateTime makeDateTimeFromCount(int i) {\n     return new LocalDateTime(2000 + i, 1 + i, 1 + i, i, i, i, i);\n   }\n \n-  protected void writeDateTimeData(int count, MapVector parent) {\n+  protected void writeDateTimeData(int count, NullableMapVector parent) {\n     Assert.assertTrue(count < 100);\n     ComplexWriter writer = new ComplexWriterImpl(\"root\", parent);\n     MapWriter rootWriter = writer.rootAsMap();\n@@ -494,7 +494,7 @@ public void validateUnionData(int count, VectorSchemaRoot root) {\n     }\n   }\n \n-  public void writeUnionData(int count, MapVector parent) {\n+  public void writeUnionData(int count, NullableMapVector parent) {\n     ArrowBuf varchar = allocator.buffer(3);\n     varchar.readerIndex(0);\n     varchar.setByte(0, 'a');\n@@ -537,7 +537,7 @@ public void writeUnionData(int count, MapVector parent) {\n     varchar.release();\n   }\n \n-  protected void writeVarBinaryData(int count, MapVector parent) {\n+  protected void writeVarBinaryData(int count, NullableMapVector parent) {\n     Assert.assertTrue(count < 100);\n     ComplexWriter writer = new ComplexWriterImpl(\"root\", parent);\n     MapWriter rootWriter = writer.rootAsMap();\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestArrowFile.java b/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestArrowFile.java\nindex 0cfc9ba91..055c34e70 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestArrowFile.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestArrowFile.java\n@@ -42,8 +42,7 @@\n import org.apache.arrow.vector.VectorSchemaRoot;\n import org.apache.arrow.vector.VectorUnloader;\n import org.apache.arrow.vector.complex.FixedSizeListVector;\n-import org.apache.arrow.vector.complex.MapVector;\n-import org.apache.arrow.vector.complex.MapVector;\n+import org.apache.arrow.vector.complex.NullableMapVector;\n import org.apache.arrow.vector.dictionary.DictionaryProvider.MapDictionaryProvider;\n import org.apache.arrow.vector.ipc.message.ArrowBlock;\n import org.apache.arrow.vector.ipc.message.ArrowBuffer;\n@@ -70,7 +69,7 @@ public void testWrite() throws IOException {\n     int count = COUNT;\n     try (\n         BufferAllocator vectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-        MapVector parent = MapVector.empty(\"parent\", vectorAllocator)) {\n+        NullableMapVector parent = NullableMapVector.empty(\"parent\", vectorAllocator)) {\n       writeData(count, parent);\n       write(parent.getChild(\"root\"), file, new ByteArrayOutputStream());\n     }\n@@ -82,7 +81,7 @@ public void testWriteComplex() throws IOException {\n     int count = COUNT;\n     try (\n         BufferAllocator vectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-        MapVector parent = MapVector.empty(\"parent\", vectorAllocator)) {\n+        NullableMapVector parent = NullableMapVector.empty(\"parent\", vectorAllocator)) {\n       writeComplexData(count, parent);\n       FieldVector root = parent.getChild(\"root\");\n       validateComplexContent(count, new VectorSchemaRoot(root));\n@@ -98,7 +97,7 @@ public void testWriteRead() throws IOException {\n \n     // write\n     try (BufferAllocator originalVectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-         MapVector parent = MapVector.empty(\"parent\", originalVectorAllocator)) {\n+         NullableMapVector parent = NullableMapVector.empty(\"parent\", originalVectorAllocator)) {\n       writeData(count, parent);\n       write(parent.getChild(\"root\"), file, stream);\n     }\n@@ -154,7 +153,7 @@ public void testWriteReadComplex() throws IOException {\n \n     // write\n     try (BufferAllocator originalVectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-         MapVector parent = MapVector.empty(\"parent\", originalVectorAllocator)) {\n+         NullableMapVector parent = NullableMapVector.empty(\"parent\", originalVectorAllocator)) {\n       writeComplexData(count, parent);\n       write(parent.getChild(\"root\"), file, stream);\n     }\n@@ -195,7 +194,7 @@ public void testWriteReadMultipleRBs() throws IOException {\n \n     // write\n     try (BufferAllocator originalVectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-         MapVector parent = MapVector.empty(\"parent\", originalVectorAllocator);\n+         NullableMapVector parent = NullableMapVector.empty(\"parent\", originalVectorAllocator);\n          FileOutputStream fileOutputStream = new FileOutputStream(file)) {\n       writeData(counts[0], parent);\n       VectorSchemaRoot root = new VectorSchemaRoot(parent.getChild(\"root\"));\n@@ -268,7 +267,7 @@ public void testWriteReadUnion() throws IOException {\n \n     // write\n     try (BufferAllocator vectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-         MapVector parent = MapVector.empty(\"parent\", vectorAllocator)) {\n+         NullableMapVector parent = NullableMapVector.empty(\"parent\", vectorAllocator)) {\n       writeUnionData(count, parent);\n       validateUnionData(count, new VectorSchemaRoot(parent.getChild(\"root\")));\n       write(parent.getChild(\"root\"), file, stream);\n@@ -382,7 +381,7 @@ public void testWriteReadMetadata() throws IOException {\n \n     // write\n     try (BufferAllocator originalVectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-         MapVector vector = (MapVector) field.createVector(originalVectorAllocator)) {\n+         NullableMapVector vector = (NullableMapVector) field.createVector(originalVectorAllocator)) {\n       vector.allocateNewSafe();\n       vector.setValueCount(0);\n \n@@ -558,7 +557,7 @@ public void testWriteReadFixedSizeList() throws IOException {\n \n     // write\n     try (BufferAllocator originalVectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-         MapVector parent = MapVector.empty(\"parent\", originalVectorAllocator)) {\n+         NullableMapVector parent = NullableMapVector.empty(\"parent\", originalVectorAllocator)) {\n       FixedSizeListVector tuples = parent.addOrGet(\"float-pairs\", FieldType.nullable(new FixedSizeList(2)), FixedSizeListVector.class);\n       Float4Vector floats = (Float4Vector) tuples.addOrGetVector(FieldType.nullable(MinorType.FLOAT4.getType())).getVector();\n       IntVector ints = parent.addOrGet(\"ints\", FieldType.nullable(new Int(32, true)), IntVector.class);\n@@ -618,7 +617,7 @@ public void testWriteReadVarBin() throws IOException {\n     // write\n     try (\n         BufferAllocator vectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-        MapVector parent = MapVector.empty(\"parent\", vectorAllocator)) {\n+        NullableMapVector parent = NullableMapVector.empty(\"parent\", vectorAllocator)) {\n       writeVarBinaryData(count, parent);\n       VectorSchemaRoot root = new VectorSchemaRoot(parent.getChild(\"root\"));\n       validateVarBinary(count, root);\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestJSONFile.java b/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestJSONFile.java\nindex 4f9093b8c..6a23a8438 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestJSONFile.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestJSONFile.java\n@@ -24,8 +24,7 @@\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.FieldVector;\n import org.apache.arrow.vector.VectorSchemaRoot;\n-import org.apache.arrow.vector.complex.MapVector;\n-import org.apache.arrow.vector.complex.MapVector;\n+import org.apache.arrow.vector.complex.NullableMapVector;\n import org.apache.arrow.vector.dictionary.DictionaryProvider;\n import org.apache.arrow.vector.dictionary.DictionaryProvider.MapDictionaryProvider;\n import org.apache.arrow.vector.types.pojo.Schema;\n@@ -45,7 +44,7 @@ public void testWriteRead() throws IOException {\n \n     // write\n     try (BufferAllocator originalVectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-         MapVector parent = MapVector.empty(\"parent\", originalVectorAllocator)) {\n+         NullableMapVector parent = NullableMapVector.empty(\"parent\", originalVectorAllocator)) {\n       writeData(count, parent);\n       writeJSON(file, new VectorSchemaRoot(parent.getChild(\"root\")), null);\n     }\n@@ -73,7 +72,7 @@ public void testWriteReadComplexJSON() throws IOException {\n     // write\n     try (\n         BufferAllocator originalVectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-        MapVector parent = MapVector.empty(\"parent\", originalVectorAllocator)) {\n+        NullableMapVector parent = NullableMapVector.empty(\"parent\", originalVectorAllocator)) {\n       writeComplexData(count, parent);\n       writeJSON(file, new VectorSchemaRoot(parent.getChild(\"root\")), null);\n     }\n@@ -100,7 +99,7 @@ public void testWriteComplexJSON() throws IOException {\n     int count = COUNT;\n     try (\n         BufferAllocator vectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-        MapVector parent = MapVector.empty(\"parent\", vectorAllocator)) {\n+        NullableMapVector parent = NullableMapVector.empty(\"parent\", vectorAllocator)) {\n       writeComplexData(count, parent);\n       VectorSchemaRoot root = new VectorSchemaRoot(parent.getChild(\"root\"));\n       validateComplexContent(root.getRowCount(), root);\n@@ -122,7 +121,7 @@ public void testWriteReadUnionJSON() throws IOException {\n     int count = COUNT;\n     try (\n         BufferAllocator vectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-        MapVector parent = MapVector.empty(\"parent\", vectorAllocator)) {\n+        NullableMapVector parent = NullableMapVector.empty(\"parent\", vectorAllocator)) {\n       writeUnionData(count, parent);\n       printVectors(parent.getChildrenFromFields());\n \n@@ -154,7 +153,7 @@ public void testWriteReadDateTimeJSON() throws IOException {\n     // write\n     try (\n         BufferAllocator vectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-        MapVector parent = MapVector.empty(\"parent\", vectorAllocator)) {\n+        NullableMapVector parent = NullableMapVector.empty(\"parent\", vectorAllocator)) {\n \n       writeDateTimeData(count, parent);\n \n@@ -319,7 +318,7 @@ public void testWriteReadVarBinJSON() throws IOException {\n     // write\n     try (\n         BufferAllocator vectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-        MapVector parent = MapVector.empty(\"parent\", vectorAllocator)) {\n+        NullableMapVector parent = NullableMapVector.empty(\"parent\", vectorAllocator)) {\n       writeVarBinaryData(count, parent);\n       VectorSchemaRoot root = new VectorSchemaRoot(parent.getChild(\"root\"));\n       validateVarBinary(count, root);\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-12-04T22:46:22.354+0000",
                    "updated": "2017-12-04T22:46:22.354+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122643/comment/16277711",
                    "id": "16277711",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1389: ARROW-1885: [Java] Restore MapVector class names prior to ARROW-1710\nURL: https://github.com/apache/arrow/pull/1389#issuecomment-349135862\n \n \n   Thanks all for the quick reviews!\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-12-04T23:01:02.678+0000",
                    "updated": "2017-12-04T23:01:02.678+0000"
                }
            ],
            "maxResults": 13,
            "total": 13,
            "startAt": 0
        },
        "customfield_12311820": "0|i3nief:",
        "customfield_12314139": null
    }
}