{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13362714",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714",
    "key": "ARROW-11883",
    "fields": {
        "parent": {
            "id": "13264619",
            "key": "ARROW-7001",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13264619",
            "fields": {
                "summary": "[C++] Develop threading APIs to accommodate nested parallelism ",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                    "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                    "name": "Resolved",
                    "id": "5",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                    "id": "2",
                    "description": "A new feature of the product, which has yet to be developed.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                    "name": "New Feature",
                    "subtask": false,
                    "avatarId": 21141
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 36600,
            "total": 36600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 36600,
            "total": 36600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11883/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 61,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/561640",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace opened a new pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643\n\n\n   These items can all stand on their own and they are used by the async datasets conversion.\r\n   \r\n   MergeMap - Given AsyncGenerator<AsyncGenerator<T>> return AsyncGenerator<T>.  This method flattens a generator of generators into a generator of items.  It may reorder the items.\r\n   \r\n   ConcatMap - Same as MergeMap but it will only pull items from one inner subscription at a time.  This reduced parallelism allows items to be returned in-order.\r\n   \r\n   Async-reentrant Map - In some cases the map function is slow.  Even if the source is not async-reentrant this map can still be async-reentrant by allowing multiple instances of the map function to run at once.  The resulting mapped generator is async reentrant but it will not pull reentrantly from the source.\r\n   \r\n   Vector utilities - In order to make migrating from Iterator code to vector code easier I added some map style utilities.  These copy the vectors (where an iterator wouldn't) so some care should be taken but they can still be useful.\r\n   \r\n   Moved Future/AsyncGenerator into top level type_fwd.  This is needed for the RecordBatchGenerator alias in the same way Iterator is needed at the top level.\r\n   \r\n   Added `IsEnd` to `IterationTraits`.  This allows non-comparable types to be iterated on.  It allows us to create an AsyncGenerator<AsyncGenerator<T>> since AsyncGenerator is std::function and we can use an empty instance as an end token even though std::function is not comaprable.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-05T22:50:47.992+0000",
                    "updated": "2021-03-05T22:50:47.992+0000",
                    "started": "2021-03-05T22:50:47.992+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "561640",
                    "issueId": "13362714"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/561641",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643#issuecomment-791770741\n\n\n   https://issues.apache.org/jira/browse/ARROW-11883\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-05T22:51:11.373+0000",
                    "updated": "2021-03-05T22:51:11.373+0000",
                    "started": "2021-03-05T22:51:11.372+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "561641",
                    "issueId": "13362714"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/562450",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643#discussion_r589534292\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -87,6 +103,143 @@ Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n   return Loop(LoopBody{std::move(generator), std::move(vec)});\n }\n \n+template <typename T, typename V>\n+class MappingGenerator {\n+ public:\n+  MappingGenerator(AsyncGenerator<T> source, std::function<Future<V>(const T&)> map)\n+      : state_(std::make_shared<State>(std::move(source), std::move(map))) {}\n+\n+  Future<V> operator()() {\n+    auto future = Future<V>::Make();\n+    bool should_trigger;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (state_->finished) {\n+        return Future<V>::MakeFinished(IterationTraits<V>::End());\n+      }\n+      should_trigger = state_->waiting_jobs.empty();\n+      state_->waiting_jobs.push_back(future);\n+    }\n+    if (should_trigger) {\n+      state_->source().AddCallback(Callback{state_});\n+    }\n+    return future;\n+  }\n+\n+ private:\n+  struct State {\n+    State(AsyncGenerator<T> source, std::function<Future<V>(const T&)> map)\n+        : source(std::move(source)),\n+          map(std::move(map)),\n+          waiting_jobs(),\n+          mutex(),\n+          finished(false) {}\n+\n+    AsyncGenerator<T> source;\n+    std::function<Future<V>(const T&)> map;\n+    std::deque<Future<V>> waiting_jobs;\n+    util::Mutex mutex;\n+    bool finished;\n+  };\n+\n+  struct Callback;\n+\n+  struct MappedCallback {\n+    void operator()(const Result<V>& maybe_next) {\n+      bool end = !maybe_next.ok() || IterationTraits<V>::IsEnd(*maybe_next);\n+      bool should_purge = false;\n+      if (end) {\n+        {\n+          auto guard = state->mutex.Lock();\n+          should_purge = !state->finished;\n+          state->finished = true;\n+        }\n+      }\n+      sink.MarkFinished(maybe_next);\n+      if (should_purge) {\n+        while (!state->waiting_jobs.empty()) {\n+          state->waiting_jobs.front().MarkFinished(IterationTraits<V>::End());\n+          state->waiting_jobs.pop_front();\n+        }\n+      }\n+    }\n+    std::shared_ptr<State> state;\n+    Future<V> sink;\n+  };\n+\n+  struct Callback {\n+    void operator()(const Result<T>& maybe_next) {\n+      Future<V> sink;\n+      bool end = !maybe_next.ok() || IterationTraits<T>::IsEnd(*maybe_next);\n+      bool should_purge = false;\n+      bool should_trigger;\n+      {\n+        auto guard = state->mutex.Lock();\n+        if (end) {\n+          should_purge = !state->finished;\n+          state->finished = true;\n+        }\n+        sink = state->waiting_jobs.front();\n+        state->waiting_jobs.pop_front();\n+        should_trigger = !end && !state->waiting_jobs.empty();\n+      }\n+      if (should_purge) {\n+        while (!state->waiting_jobs.empty()) {\n+          state->waiting_jobs.front().MarkFinished(IterationTraits<V>::End());\n+          state->waiting_jobs.pop_front();\n+        }\n+      }\n+      if (should_trigger) {\n\nReview comment:\n       If I'm not mistaken, even though the resulting generator is async-reentrant, no more than one underlying future will be exist at a time, right? This makes it maximally compatible, but there's a caveat to be had if the user expects readahead on the outer generator to also bring parallelism, which should be documented up front.\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -87,6 +103,143 @@ Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n   return Loop(LoopBody{std::move(generator), std::move(vec)});\n }\n \n+template <typename T, typename V>\n+class MappingGenerator {\n+ public:\n+  MappingGenerator(AsyncGenerator<T> source, std::function<Future<V>(const T&)> map)\n+      : state_(std::make_shared<State>(std::move(source), std::move(map))) {}\n+\n+  Future<V> operator()() {\n+    auto future = Future<V>::Make();\n+    bool should_trigger;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (state_->finished) {\n+        return Future<V>::MakeFinished(IterationTraits<V>::End());\n+      }\n+      should_trigger = state_->waiting_jobs.empty();\n+      state_->waiting_jobs.push_back(future);\n+    }\n+    if (should_trigger) {\n+      state_->source().AddCallback(Callback{state_});\n+    }\n+    return future;\n+  }\n+\n+ private:\n+  struct State {\n+    State(AsyncGenerator<T> source, std::function<Future<V>(const T&)> map)\n+        : source(std::move(source)),\n+          map(std::move(map)),\n+          waiting_jobs(),\n+          mutex(),\n+          finished(false) {}\n+\n+    AsyncGenerator<T> source;\n+    std::function<Future<V>(const T&)> map;\n+    std::deque<Future<V>> waiting_jobs;\n+    util::Mutex mutex;\n+    bool finished;\n+  };\n+\n+  struct Callback;\n+\n+  struct MappedCallback {\n+    void operator()(const Result<V>& maybe_next) {\n+      bool end = !maybe_next.ok() || IterationTraits<V>::IsEnd(*maybe_next);\n+      bool should_purge = false;\n+      if (end) {\n+        {\n+          auto guard = state->mutex.Lock();\n+          should_purge = !state->finished;\n+          state->finished = true;\n+        }\n+      }\n+      sink.MarkFinished(maybe_next);\n+      if (should_purge) {\n+        while (!state->waiting_jobs.empty()) {\n\nReview comment:\n       nit: maybe this could be State::Purge?\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -235,29 +505,213 @@ class ReadaheadGenerator {\n /// The source generator must be async-reentrant\n ///\n /// This generator itself is async-reentrant.\n+///\n+/// This generator may queue up to max_readahead instances of T\n template <typename T>\n AsyncGenerator<T> MakeReadaheadGenerator(AsyncGenerator<T> source_generator,\n                                          int max_readahead) {\n   return ReadaheadGenerator<T>(std::move(source_generator), max_readahead);\n }\n \n-/// \\brief Transforms an async generator using a transformer function returning a new\n-/// AsyncGenerator\n+/// \\brief Creates a generator that will yield finished futures from a vector\n ///\n-/// The transform function here behaves exactly the same as the transform function in\n-/// MakeTransformedIterator and you can safely use the same transform function to\n-/// transform both synchronous and asynchronous streams.\n+/// This generator is async-reentrant\n+template <typename T>\n+AsyncGenerator<T> MakeVectorGenerator(std::vector<T> vec) {\n+  struct State {\n+    explicit State(std::vector<T> vec_) : vec(std::move(vec_)), vec_idx(0) {}\n+\n+    std::vector<T> vec;\n+    std::atomic<std::size_t> vec_idx;\n+  };\n+\n+  auto state = std::make_shared<State>(std::move(vec));\n+  return [state]() {\n+    auto idx = state->vec_idx.fetch_add(1);\n+    if (idx >= state->vec.size()) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+    return Future<T>::MakeFinished(state->vec[idx]);\n+  };\n+}\n+\n+template <typename T>\n+class MergeMapGenerator {\n+ public:\n+  explicit MergeMapGenerator(AsyncGenerator<AsyncGenerator<T>> source,\n+                             int max_subscriptions)\n+      : state_(std::make_shared<State>(std::move(source), max_subscriptions)) {}\n+\n+  Future<T> operator()() {\n+    Future<T> waiting_future;\n+    std::shared_ptr<DeliveredJob> delivered_job;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->delivered_jobs.empty()) {\n+        delivered_job = std::move(state_->delivered_jobs.front());\n+        state_->delivered_jobs.pop_front();\n+      } else if (state_->finished) {\n+        return IterationTraits<T>::End();\n+      } else {\n+        waiting_future = Future<T>::Make();\n+        state_->waiting_jobs.push_back(std::make_shared<Future<T>>(waiting_future));\n+      }\n+    }\n+    if (delivered_job) {\n+      delivered_job->deliverer().AddCallback(InnerCallback{state_, delivered_job->index});\n+      return std::move(delivered_job->value);\n+    }\n+    if (state_->first) {\n+      state_->first = false;\n+      for (std::size_t i = 0; i < state_->active_subscriptions.size(); i++) {\n+        state_->source().AddCallback(OuterCallback{state_, i});\n+      }\n+    }\n+    return waiting_future;\n+  }\n+\n+ private:\n+  struct DeliveredJob {\n+    explicit DeliveredJob(AsyncGenerator<T> deliverer_, T value_, std::size_t index_)\n+        : deliverer(deliverer_), value(value_), index(index_) {}\n+\n+    AsyncGenerator<T> deliverer;\n+    T value;\n+    std::size_t index;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<AsyncGenerator<T>> source, int max_subscriptions)\n+        : source(std::move(source)),\n+          active_subscriptions(max_subscriptions),\n+          delivered_jobs(),\n+          waiting_jobs(),\n+          mutex(),\n+          first(true),\n+          source_exhausted(false),\n+          finished(false),\n+          num_active_subscriptions(max_subscriptions) {}\n+\n+    AsyncGenerator<AsyncGenerator<T>> source;\n+    // active_subscriptions and delivered_jobs will be bounded by max_subscriptions\n+    std::vector<AsyncGenerator<T>> active_subscriptions;\n+    std::deque<std::shared_ptr<DeliveredJob>> delivered_jobs;\n+    // waiting_jobs is unbounded, reentrant pulls (e.g. AddReadahead) will provide the\n+    // backpressure\n+    std::deque<std::shared_ptr<Future<T>>> waiting_jobs;\n+    util::Mutex mutex;\n+    bool first;\n+    bool source_exhausted;\n+    bool finished;\n+    int num_active_subscriptions;\n+  };\n+\n+  struct InnerCallback {\n+    void operator()(const Result<T>& maybe_next) {\n+      bool finished = false;\n+      Future<T> sink;\n+      if (maybe_next.ok()) {\n+        finished = IterationTraits<T>::IsEnd(*maybe_next);\n+        {\n+          auto guard = state->mutex.Lock();\n+          if (!finished) {\n+            if (state->waiting_jobs.empty()) {\n+              state->delivered_jobs.push_back(std::make_shared<DeliveredJob>(\n+                  state->active_subscriptions[index], *maybe_next, index));\n+            } else {\n+              sink = std::move(*state->waiting_jobs.front());\n+              state->waiting_jobs.pop_front();\n+            }\n+          }\n+        }\n+      } else {\n+        finished = true;\n+      }\n+      if (finished) {\n+        state->source().AddCallback(OuterCallback{state, index});\n+      } else if (sink.is_valid()) {\n+        sink.MarkFinished(*maybe_next);\n+        state->active_subscriptions[index]().AddCallback(*this);\n+      }\n+    }\n+    std::shared_ptr<State> state;\n+    std::size_t index;\n+  };\n+\n+  struct OuterCallback {\n+    void operator()(const Result<AsyncGenerator<T>>& maybe_next) {\n+      bool should_purge = false;\n+      bool should_continue = false;\n+      {\n+        auto guard = state->mutex.Lock();\n+        if (!maybe_next.ok() || IterationTraits<AsyncGenerator<T>>::IsEnd(*maybe_next)) {\n+          state->source_exhausted = true;\n+          if (--state->num_active_subscriptions == 0) {\n+            state->finished = true;\n+            should_purge = true;\n+          }\n+        } else {\n+          state->active_subscriptions[index] = *maybe_next;\n+          should_continue = true;\n+        }\n+      }\n+      if (should_continue) {\n+        (*maybe_next)().AddCallback(InnerCallback{state, index});\n+      } else if (should_purge) {\n+        // At this point state->finished has been marked true so no one else\n+        // will be interacting with waiting_jobs and we can iterate outside lock\n+        while (!state->waiting_jobs.empty()) {\n+          state->waiting_jobs.front()->MarkFinished(IterationTraits<T>::End());\n+          state->waiting_jobs.pop_front();\n+        }\n+      }\n+    }\n+    std::shared_ptr<State> state;\n+    std::size_t index;\n+  };\n+\n+  std::shared_ptr<State> state_;\n+};\n+\n+/// \\brief Creates a generator that takes in a stream of generators and pulls from up to\n+/// max_subscriptions at a time\n ///\n-/// This generator is not async-reentrant\n-template <typename T, typename V>\n-AsyncGenerator<V> MakeAsyncGenerator(AsyncGenerator<T> generator,\n-                                     Transformer<T, V> transformer) {\n-  return TransformingGenerator<T, V>(generator, transformer);\n+/// Note: This is the equivalent of Rx::MergeMap.  This may deliver items out of\n+/// sequence. For example, items from the third AsyncGenerator generated by the source\n+/// may be emitted before some items from the first AsyncGenerator generated by the\n+/// source.\n+///\n+/// This generator expects source to be async-reentrant regardless of whether this\n+/// generator is async-reentrant or not (unless max_readahead is 1)\n+/// This generator will not pull from the individual subscriptions reentrantly.  Add\n+/// readahead to the individual subscriptions if that is desired.\n+/// This generator is async-reentrant\n+///\n+/// This generator may queue up to max_readahead instances of T\n+template <typename T>\n+AsyncGenerator<T> MakeMergeMapGenerator(AsyncGenerator<AsyncGenerator<T>> source,\n+                                        int max_readahead) {\n+  return MergeMapGenerator<T>(std::move(source), max_readahead);\n }\n \n-/// \\brief Transfers execution of the generator onto the given executor\n+/// \\brief Creates a generator that takes in a stream of generators and pulls from each\n+/// one in sequence.\n+///\n+/// Note: This is the equivalent of Rx::ConcatMap.  One could conceivably create the\n+/// equivalent of Rx::MergeMap by pulling from `source` before the last emitted\n+/// generator is exhausted.  Then ConcatMap folds into the special case of MergeMap with\n+/// one max subscription (which is how its handled in Rx)  TODO(ARROW-11800).  Deferring\n+/// that now for simplicity.\n\nReview comment:\n       It seems this TODO is already done, assuming max_readahead above is really max_subscriptions.\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -235,29 +505,213 @@ class ReadaheadGenerator {\n /// The source generator must be async-reentrant\n ///\n /// This generator itself is async-reentrant.\n+///\n+/// This generator may queue up to max_readahead instances of T\n template <typename T>\n AsyncGenerator<T> MakeReadaheadGenerator(AsyncGenerator<T> source_generator,\n                                          int max_readahead) {\n   return ReadaheadGenerator<T>(std::move(source_generator), max_readahead);\n }\n \n-/// \\brief Transforms an async generator using a transformer function returning a new\n-/// AsyncGenerator\n+/// \\brief Creates a generator that will yield finished futures from a vector\n ///\n-/// The transform function here behaves exactly the same as the transform function in\n-/// MakeTransformedIterator and you can safely use the same transform function to\n-/// transform both synchronous and asynchronous streams.\n+/// This generator is async-reentrant\n+template <typename T>\n+AsyncGenerator<T> MakeVectorGenerator(std::vector<T> vec) {\n+  struct State {\n+    explicit State(std::vector<T> vec_) : vec(std::move(vec_)), vec_idx(0) {}\n+\n+    std::vector<T> vec;\n+    std::atomic<std::size_t> vec_idx;\n+  };\n+\n+  auto state = std::make_shared<State>(std::move(vec));\n+  return [state]() {\n+    auto idx = state->vec_idx.fetch_add(1);\n+    if (idx >= state->vec.size()) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+    return Future<T>::MakeFinished(state->vec[idx]);\n+  };\n+}\n+\n+template <typename T>\n+class MergeMapGenerator {\n+ public:\n+  explicit MergeMapGenerator(AsyncGenerator<AsyncGenerator<T>> source,\n+                             int max_subscriptions)\n+      : state_(std::make_shared<State>(std::move(source), max_subscriptions)) {}\n+\n+  Future<T> operator()() {\n+    Future<T> waiting_future;\n+    std::shared_ptr<DeliveredJob> delivered_job;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->delivered_jobs.empty()) {\n+        delivered_job = std::move(state_->delivered_jobs.front());\n+        state_->delivered_jobs.pop_front();\n+      } else if (state_->finished) {\n+        return IterationTraits<T>::End();\n+      } else {\n+        waiting_future = Future<T>::Make();\n+        state_->waiting_jobs.push_back(std::make_shared<Future<T>>(waiting_future));\n+      }\n+    }\n+    if (delivered_job) {\n+      delivered_job->deliverer().AddCallback(InnerCallback{state_, delivered_job->index});\n+      return std::move(delivered_job->value);\n+    }\n+    if (state_->first) {\n+      state_->first = false;\n+      for (std::size_t i = 0; i < state_->active_subscriptions.size(); i++) {\n+        state_->source().AddCallback(OuterCallback{state_, i});\n+      }\n+    }\n+    return waiting_future;\n+  }\n+\n+ private:\n+  struct DeliveredJob {\n+    explicit DeliveredJob(AsyncGenerator<T> deliverer_, T value_, std::size_t index_)\n+        : deliverer(deliverer_), value(value_), index(index_) {}\n+\n+    AsyncGenerator<T> deliverer;\n+    T value;\n+    std::size_t index;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<AsyncGenerator<T>> source, int max_subscriptions)\n+        : source(std::move(source)),\n+          active_subscriptions(max_subscriptions),\n+          delivered_jobs(),\n+          waiting_jobs(),\n+          mutex(),\n+          first(true),\n+          source_exhausted(false),\n+          finished(false),\n+          num_active_subscriptions(max_subscriptions) {}\n+\n+    AsyncGenerator<AsyncGenerator<T>> source;\n+    // active_subscriptions and delivered_jobs will be bounded by max_subscriptions\n+    std::vector<AsyncGenerator<T>> active_subscriptions;\n+    std::deque<std::shared_ptr<DeliveredJob>> delivered_jobs;\n+    // waiting_jobs is unbounded, reentrant pulls (e.g. AddReadahead) will provide the\n+    // backpressure\n+    std::deque<std::shared_ptr<Future<T>>> waiting_jobs;\n+    util::Mutex mutex;\n+    bool first;\n+    bool source_exhausted;\n+    bool finished;\n+    int num_active_subscriptions;\n+  };\n+\n+  struct InnerCallback {\n+    void operator()(const Result<T>& maybe_next) {\n+      bool finished = false;\n+      Future<T> sink;\n+      if (maybe_next.ok()) {\n+        finished = IterationTraits<T>::IsEnd(*maybe_next);\n+        {\n+          auto guard = state->mutex.Lock();\n+          if (!finished) {\n+            if (state->waiting_jobs.empty()) {\n+              state->delivered_jobs.push_back(std::make_shared<DeliveredJob>(\n+                  state->active_subscriptions[index], *maybe_next, index));\n+            } else {\n+              sink = std::move(*state->waiting_jobs.front());\n+              state->waiting_jobs.pop_front();\n+            }\n+          }\n+        }\n+      } else {\n+        finished = true;\n+      }\n+      if (finished) {\n+        state->source().AddCallback(OuterCallback{state, index});\n+      } else if (sink.is_valid()) {\n+        sink.MarkFinished(*maybe_next);\n+        state->active_subscriptions[index]().AddCallback(*this);\n+      }\n+    }\n+    std::shared_ptr<State> state;\n+    std::size_t index;\n+  };\n+\n+  struct OuterCallback {\n+    void operator()(const Result<AsyncGenerator<T>>& maybe_next) {\n+      bool should_purge = false;\n+      bool should_continue = false;\n+      {\n+        auto guard = state->mutex.Lock();\n+        if (!maybe_next.ok() || IterationTraits<AsyncGenerator<T>>::IsEnd(*maybe_next)) {\n+          state->source_exhausted = true;\n+          if (--state->num_active_subscriptions == 0) {\n+            state->finished = true;\n+            should_purge = true;\n+          }\n+        } else {\n+          state->active_subscriptions[index] = *maybe_next;\n+          should_continue = true;\n+        }\n+      }\n+      if (should_continue) {\n+        (*maybe_next)().AddCallback(InnerCallback{state, index});\n+      } else if (should_purge) {\n+        // At this point state->finished has been marked true so no one else\n+        // will be interacting with waiting_jobs and we can iterate outside lock\n+        while (!state->waiting_jobs.empty()) {\n+          state->waiting_jobs.front()->MarkFinished(IterationTraits<T>::End());\n+          state->waiting_jobs.pop_front();\n+        }\n+      }\n+    }\n+    std::shared_ptr<State> state;\n+    std::size_t index;\n+  };\n+\n+  std::shared_ptr<State> state_;\n+};\n+\n+/// \\brief Creates a generator that takes in a stream of generators and pulls from up to\n+/// max_subscriptions at a time\n ///\n-/// This generator is not async-reentrant\n-template <typename T, typename V>\n-AsyncGenerator<V> MakeAsyncGenerator(AsyncGenerator<T> generator,\n-                                     Transformer<T, V> transformer) {\n-  return TransformingGenerator<T, V>(generator, transformer);\n+/// Note: This is the equivalent of Rx::MergeMap.  This may deliver items out of\n+/// sequence. For example, items from the third AsyncGenerator generated by the source\n+/// may be emitted before some items from the first AsyncGenerator generated by the\n+/// source.\n+///\n+/// This generator expects source to be async-reentrant regardless of whether this\n+/// generator is async-reentrant or not (unless max_readahead is 1)\n+/// This generator will not pull from the individual subscriptions reentrantly.  Add\n+/// readahead to the individual subscriptions if that is desired.\n+/// This generator is async-reentrant\n+///\n+/// This generator may queue up to max_readahead instances of T\n+template <typename T>\n+AsyncGenerator<T> MakeMergeMapGenerator(AsyncGenerator<AsyncGenerator<T>> source,\n+                                        int max_readahead) {\n+  return MergeMapGenerator<T>(std::move(source), max_readahead);\n\nReview comment:\n       Is this max readahead or max subscriptions (as the implementation itself calls it?)\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -87,6 +103,143 @@ Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n   return Loop(LoopBody{std::move(generator), std::move(vec)});\n }\n \n+template <typename T, typename V>\n+class MappingGenerator {\n+ public:\n+  MappingGenerator(AsyncGenerator<T> source, std::function<Future<V>(const T&)> map)\n+      : state_(std::make_shared<State>(std::move(source), std::move(map))) {}\n+\n+  Future<V> operator()() {\n+    auto future = Future<V>::Make();\n+    bool should_trigger;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (state_->finished) {\n+        return Future<V>::MakeFinished(IterationTraits<V>::End());\n+      }\n+      should_trigger = state_->waiting_jobs.empty();\n+      state_->waiting_jobs.push_back(future);\n+    }\n+    if (should_trigger) {\n+      state_->source().AddCallback(Callback{state_});\n+    }\n+    return future;\n+  }\n+\n+ private:\n+  struct State {\n+    State(AsyncGenerator<T> source, std::function<Future<V>(const T&)> map)\n+        : source(std::move(source)),\n+          map(std::move(map)),\n+          waiting_jobs(),\n+          mutex(),\n+          finished(false) {}\n+\n+    AsyncGenerator<T> source;\n+    std::function<Future<V>(const T&)> map;\n+    std::deque<Future<V>> waiting_jobs;\n+    util::Mutex mutex;\n+    bool finished;\n+  };\n+\n+  struct Callback;\n+\n+  struct MappedCallback {\n+    void operator()(const Result<V>& maybe_next) {\n+      bool end = !maybe_next.ok() || IterationTraits<V>::IsEnd(*maybe_next);\n+      bool should_purge = false;\n+      if (end) {\n+        {\n+          auto guard = state->mutex.Lock();\n+          should_purge = !state->finished;\n+          state->finished = true;\n+        }\n+      }\n+      sink.MarkFinished(maybe_next);\n+      if (should_purge) {\n+        while (!state->waiting_jobs.empty()) {\n+          state->waiting_jobs.front().MarkFinished(IterationTraits<V>::End());\n+          state->waiting_jobs.pop_front();\n+        }\n+      }\n+    }\n+    std::shared_ptr<State> state;\n+    Future<V> sink;\n+  };\n+\n+  struct Callback {\n+    void operator()(const Result<T>& maybe_next) {\n+      Future<V> sink;\n+      bool end = !maybe_next.ok() || IterationTraits<T>::IsEnd(*maybe_next);\n+      bool should_purge = false;\n+      bool should_trigger;\n+      {\n+        auto guard = state->mutex.Lock();\n+        if (end) {\n+          should_purge = !state->finished;\n+          state->finished = true;\n+        }\n+        sink = state->waiting_jobs.front();\n+        state->waiting_jobs.pop_front();\n+        should_trigger = !end && !state->waiting_jobs.empty();\n+      }\n+      if (should_purge) {\n+        while (!state->waiting_jobs.empty()) {\n+          state->waiting_jobs.front().MarkFinished(IterationTraits<V>::End());\n+          state->waiting_jobs.pop_front();\n+        }\n+      }\n+      if (should_trigger) {\n\nReview comment:\n       On that note, it's still early days for this abstraction, but it would be nice if we eventually specified what things like async-reentrant mean (I realized while reading through that I had the wrong idea), and consistently annotated each helper with its requirements and outputs (e.g. requires: any kind of generator, provides: async-reentrant, but non-current, generator).\n\n##########\nFile path: cpp/src/arrow/util/vector.h\n##########\n@@ -81,5 +84,53 @@ std::vector<T> FilterVector(std::vector<T> values, Predicate&& predicate) {\n   return values;\n }\n \n+/// \\brief Like MapIterator, but where the function can fail.\n\nReview comment:\n       ```suggestion\r\n   /// \\brief Like MapVector, but where the function can fail.\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +330,124 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+/// \\brief Transforms an async generator using a transformer function returning a new\n\nReview comment:\n       It seems this + the queue files could be removed in favor of the version in #9533?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T16:36:38.030+0000",
                    "updated": "2021-03-08T16:36:38.030+0000",
                    "started": "2021-03-08T16:36:38.030+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562450",
                    "issueId": "13362714"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/562606",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643#discussion_r589759293\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -87,6 +103,143 @@ Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n   return Loop(LoopBody{std::move(generator), std::move(vec)});\n }\n \n+template <typename T, typename V>\n+class MappingGenerator {\n+ public:\n+  MappingGenerator(AsyncGenerator<T> source, std::function<Future<V>(const T&)> map)\n+      : state_(std::make_shared<State>(std::move(source), std::move(map))) {}\n+\n+  Future<V> operator()() {\n+    auto future = Future<V>::Make();\n+    bool should_trigger;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (state_->finished) {\n+        return Future<V>::MakeFinished(IterationTraits<V>::End());\n+      }\n+      should_trigger = state_->waiting_jobs.empty();\n+      state_->waiting_jobs.push_back(future);\n+    }\n+    if (should_trigger) {\n+      state_->source().AddCallback(Callback{state_});\n+    }\n+    return future;\n+  }\n+\n+ private:\n+  struct State {\n+    State(AsyncGenerator<T> source, std::function<Future<V>(const T&)> map)\n+        : source(std::move(source)),\n+          map(std::move(map)),\n+          waiting_jobs(),\n+          mutex(),\n+          finished(false) {}\n+\n+    AsyncGenerator<T> source;\n+    std::function<Future<V>(const T&)> map;\n+    std::deque<Future<V>> waiting_jobs;\n+    util::Mutex mutex;\n+    bool finished;\n+  };\n+\n+  struct Callback;\n+\n+  struct MappedCallback {\n+    void operator()(const Result<V>& maybe_next) {\n+      bool end = !maybe_next.ok() || IterationTraits<V>::IsEnd(*maybe_next);\n+      bool should_purge = false;\n+      if (end) {\n+        {\n+          auto guard = state->mutex.Lock();\n+          should_purge = !state->finished;\n+          state->finished = true;\n+        }\n+      }\n+      sink.MarkFinished(maybe_next);\n+      if (should_purge) {\n+        while (!state->waiting_jobs.empty()) {\n+          state->waiting_jobs.front().MarkFinished(IterationTraits<V>::End());\n+          state->waiting_jobs.pop_front();\n+        }\n+      }\n+    }\n+    std::shared_ptr<State> state;\n+    Future<V> sink;\n+  };\n+\n+  struct Callback {\n+    void operator()(const Result<T>& maybe_next) {\n+      Future<V> sink;\n+      bool end = !maybe_next.ok() || IterationTraits<T>::IsEnd(*maybe_next);\n+      bool should_purge = false;\n+      bool should_trigger;\n+      {\n+        auto guard = state->mutex.Lock();\n+        if (end) {\n+          should_purge = !state->finished;\n+          state->finished = true;\n+        }\n+        sink = state->waiting_jobs.front();\n+        state->waiting_jobs.pop_front();\n+        should_trigger = !end && !state->waiting_jobs.empty();\n+      }\n+      if (should_purge) {\n+        while (!state->waiting_jobs.empty()) {\n+          state->waiting_jobs.front().MarkFinished(IterationTraits<V>::End());\n+          state->waiting_jobs.pop_front();\n+        }\n+      }\n+      if (should_trigger) {\n\nReview comment:\n       All of the MakeXYZ functions should be clearly commented with what the generator expects (regarding reentrancy), whether the generator itself can be called reentrantly, and how many results the generator might queue.\r\n   \r\n   I agree it would be good to add a definition for async-reentrant.  I'll add it to the top of the file.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T21:26:13.745+0000",
                    "updated": "2021-03-08T21:26:13.745+0000",
                    "started": "2021-03-08T21:26:13.745+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562606",
                    "issueId": "13362714"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/562623",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643#discussion_r589775425\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +330,124 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+/// \\brief Transforms an async generator using a transformer function returning a new\n\nReview comment:\n       Hmm, I'm not sure what you mean here.  The version in #9533 still relies on the transforming generator.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T21:54:07.508+0000",
                    "updated": "2021-03-08T21:54:07.508+0000",
                    "started": "2021-03-08T21:54:07.508+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562623",
                    "issueId": "13362714"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/562625",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643#discussion_r589776738\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +330,124 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+/// \\brief Transforms an async generator using a transformer function returning a new\n\nReview comment:\n       Sorry, I mean that since nothing in this PR uses this or the queue, it could be removed from this PR and reviewed solely in the context of the other PR.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T21:56:23.922+0000",
                    "updated": "2021-03-08T21:56:23.922+0000",
                    "started": "2021-03-08T21:56:23.922+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562625",
                    "issueId": "13362714"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/562631",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643#discussion_r589783197\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +330,124 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+/// \\brief Transforms an async generator using a transformer function returning a new\n\nReview comment:\n       Ah, right.  All of these build on each other.  So hopefully these changes will magically just go away once #9533 is merged.  I think it would be too much work for me to keep track of the branching otherwise.  The next PR 11887 needs both these changes and the changes from #9533 so I wouldn't be saving too much by splitting at the moment.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T22:07:54.133+0000",
                    "updated": "2021-03-08T22:07:54.133+0000",
                    "started": "2021-03-08T22:07:54.132+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562631",
                    "issueId": "13362714"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/562653",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643#discussion_r589800180\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -235,29 +505,213 @@ class ReadaheadGenerator {\n /// The source generator must be async-reentrant\n ///\n /// This generator itself is async-reentrant.\n+///\n+/// This generator may queue up to max_readahead instances of T\n template <typename T>\n AsyncGenerator<T> MakeReadaheadGenerator(AsyncGenerator<T> source_generator,\n                                          int max_readahead) {\n   return ReadaheadGenerator<T>(std::move(source_generator), max_readahead);\n }\n \n-/// \\brief Transforms an async generator using a transformer function returning a new\n-/// AsyncGenerator\n+/// \\brief Creates a generator that will yield finished futures from a vector\n ///\n-/// The transform function here behaves exactly the same as the transform function in\n-/// MakeTransformedIterator and you can safely use the same transform function to\n-/// transform both synchronous and asynchronous streams.\n+/// This generator is async-reentrant\n+template <typename T>\n+AsyncGenerator<T> MakeVectorGenerator(std::vector<T> vec) {\n+  struct State {\n+    explicit State(std::vector<T> vec_) : vec(std::move(vec_)), vec_idx(0) {}\n+\n+    std::vector<T> vec;\n+    std::atomic<std::size_t> vec_idx;\n+  };\n+\n+  auto state = std::make_shared<State>(std::move(vec));\n+  return [state]() {\n+    auto idx = state->vec_idx.fetch_add(1);\n+    if (idx >= state->vec.size()) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+    return Future<T>::MakeFinished(state->vec[idx]);\n+  };\n+}\n+\n+template <typename T>\n+class MergeMapGenerator {\n+ public:\n+  explicit MergeMapGenerator(AsyncGenerator<AsyncGenerator<T>> source,\n+                             int max_subscriptions)\n+      : state_(std::make_shared<State>(std::move(source), max_subscriptions)) {}\n+\n+  Future<T> operator()() {\n+    Future<T> waiting_future;\n+    std::shared_ptr<DeliveredJob> delivered_job;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->delivered_jobs.empty()) {\n+        delivered_job = std::move(state_->delivered_jobs.front());\n+        state_->delivered_jobs.pop_front();\n+      } else if (state_->finished) {\n+        return IterationTraits<T>::End();\n+      } else {\n+        waiting_future = Future<T>::Make();\n+        state_->waiting_jobs.push_back(std::make_shared<Future<T>>(waiting_future));\n+      }\n+    }\n+    if (delivered_job) {\n+      delivered_job->deliverer().AddCallback(InnerCallback{state_, delivered_job->index});\n+      return std::move(delivered_job->value);\n+    }\n+    if (state_->first) {\n+      state_->first = false;\n+      for (std::size_t i = 0; i < state_->active_subscriptions.size(); i++) {\n+        state_->source().AddCallback(OuterCallback{state_, i});\n+      }\n+    }\n+    return waiting_future;\n+  }\n+\n+ private:\n+  struct DeliveredJob {\n+    explicit DeliveredJob(AsyncGenerator<T> deliverer_, T value_, std::size_t index_)\n+        : deliverer(deliverer_), value(value_), index(index_) {}\n+\n+    AsyncGenerator<T> deliverer;\n+    T value;\n+    std::size_t index;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<AsyncGenerator<T>> source, int max_subscriptions)\n+        : source(std::move(source)),\n+          active_subscriptions(max_subscriptions),\n+          delivered_jobs(),\n+          waiting_jobs(),\n+          mutex(),\n+          first(true),\n+          source_exhausted(false),\n+          finished(false),\n+          num_active_subscriptions(max_subscriptions) {}\n+\n+    AsyncGenerator<AsyncGenerator<T>> source;\n+    // active_subscriptions and delivered_jobs will be bounded by max_subscriptions\n+    std::vector<AsyncGenerator<T>> active_subscriptions;\n+    std::deque<std::shared_ptr<DeliveredJob>> delivered_jobs;\n+    // waiting_jobs is unbounded, reentrant pulls (e.g. AddReadahead) will provide the\n+    // backpressure\n+    std::deque<std::shared_ptr<Future<T>>> waiting_jobs;\n+    util::Mutex mutex;\n+    bool first;\n+    bool source_exhausted;\n+    bool finished;\n+    int num_active_subscriptions;\n+  };\n+\n+  struct InnerCallback {\n+    void operator()(const Result<T>& maybe_next) {\n+      bool finished = false;\n+      Future<T> sink;\n+      if (maybe_next.ok()) {\n+        finished = IterationTraits<T>::IsEnd(*maybe_next);\n+        {\n+          auto guard = state->mutex.Lock();\n+          if (!finished) {\n+            if (state->waiting_jobs.empty()) {\n+              state->delivered_jobs.push_back(std::make_shared<DeliveredJob>(\n+                  state->active_subscriptions[index], *maybe_next, index));\n+            } else {\n+              sink = std::move(*state->waiting_jobs.front());\n+              state->waiting_jobs.pop_front();\n+            }\n+          }\n+        }\n+      } else {\n+        finished = true;\n+      }\n+      if (finished) {\n+        state->source().AddCallback(OuterCallback{state, index});\n+      } else if (sink.is_valid()) {\n+        sink.MarkFinished(*maybe_next);\n+        state->active_subscriptions[index]().AddCallback(*this);\n+      }\n+    }\n+    std::shared_ptr<State> state;\n+    std::size_t index;\n+  };\n+\n+  struct OuterCallback {\n+    void operator()(const Result<AsyncGenerator<T>>& maybe_next) {\n+      bool should_purge = false;\n+      bool should_continue = false;\n+      {\n+        auto guard = state->mutex.Lock();\n+        if (!maybe_next.ok() || IterationTraits<AsyncGenerator<T>>::IsEnd(*maybe_next)) {\n+          state->source_exhausted = true;\n+          if (--state->num_active_subscriptions == 0) {\n+            state->finished = true;\n+            should_purge = true;\n+          }\n+        } else {\n+          state->active_subscriptions[index] = *maybe_next;\n+          should_continue = true;\n+        }\n+      }\n+      if (should_continue) {\n+        (*maybe_next)().AddCallback(InnerCallback{state, index});\n+      } else if (should_purge) {\n+        // At this point state->finished has been marked true so no one else\n+        // will be interacting with waiting_jobs and we can iterate outside lock\n+        while (!state->waiting_jobs.empty()) {\n+          state->waiting_jobs.front()->MarkFinished(IterationTraits<T>::End());\n+          state->waiting_jobs.pop_front();\n+        }\n+      }\n+    }\n+    std::shared_ptr<State> state;\n+    std::size_t index;\n+  };\n+\n+  std::shared_ptr<State> state_;\n+};\n+\n+/// \\brief Creates a generator that takes in a stream of generators and pulls from up to\n+/// max_subscriptions at a time\n ///\n-/// This generator is not async-reentrant\n-template <typename T, typename V>\n-AsyncGenerator<V> MakeAsyncGenerator(AsyncGenerator<T> generator,\n-                                     Transformer<T, V> transformer) {\n-  return TransformingGenerator<T, V>(generator, transformer);\n+/// Note: This is the equivalent of Rx::MergeMap.  This may deliver items out of\n+/// sequence. For example, items from the third AsyncGenerator generated by the source\n+/// may be emitted before some items from the first AsyncGenerator generated by the\n+/// source.\n+///\n+/// This generator expects source to be async-reentrant regardless of whether this\n+/// generator is async-reentrant or not (unless max_readahead is 1)\n+/// This generator will not pull from the individual subscriptions reentrantly.  Add\n+/// readahead to the individual subscriptions if that is desired.\n+/// This generator is async-reentrant\n+///\n+/// This generator may queue up to max_readahead instances of T\n+template <typename T>\n+AsyncGenerator<T> MakeMergeMapGenerator(AsyncGenerator<AsyncGenerator<T>> source,\n+                                        int max_readahead) {\n+  return MergeMapGenerator<T>(std::move(source), max_readahead);\n }\n \n-/// \\brief Transfers execution of the generator onto the given executor\n+/// \\brief Creates a generator that takes in a stream of generators and pulls from each\n+/// one in sequence.\n+///\n+/// Note: This is the equivalent of Rx::ConcatMap.  One could conceivably create the\n+/// equivalent of Rx::MergeMap by pulling from `source` before the last emitted\n+/// generator is exhausted.  Then ConcatMap folds into the special case of MergeMap with\n+/// one max subscription (which is how its handled in Rx)  TODO(ARROW-11800).  Deferring\n+/// that now for simplicity.\n\nReview comment:\n       Good catch.  I removed the comment.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T22:39:12.112+0000",
                    "updated": "2021-03-08T22:39:12.112+0000",
                    "started": "2021-03-08T22:39:12.112+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562653",
                    "issueId": "13362714"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/562654",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643#discussion_r589800293\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -87,6 +103,143 @@ Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n   return Loop(LoopBody{std::move(generator), std::move(vec)});\n }\n \n+template <typename T, typename V>\n+class MappingGenerator {\n+ public:\n+  MappingGenerator(AsyncGenerator<T> source, std::function<Future<V>(const T&)> map)\n+      : state_(std::make_shared<State>(std::move(source), std::move(map))) {}\n+\n+  Future<V> operator()() {\n+    auto future = Future<V>::Make();\n+    bool should_trigger;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (state_->finished) {\n+        return Future<V>::MakeFinished(IterationTraits<V>::End());\n+      }\n+      should_trigger = state_->waiting_jobs.empty();\n+      state_->waiting_jobs.push_back(future);\n+    }\n+    if (should_trigger) {\n+      state_->source().AddCallback(Callback{state_});\n+    }\n+    return future;\n+  }\n+\n+ private:\n+  struct State {\n+    State(AsyncGenerator<T> source, std::function<Future<V>(const T&)> map)\n+        : source(std::move(source)),\n+          map(std::move(map)),\n+          waiting_jobs(),\n+          mutex(),\n+          finished(false) {}\n+\n+    AsyncGenerator<T> source;\n+    std::function<Future<V>(const T&)> map;\n+    std::deque<Future<V>> waiting_jobs;\n+    util::Mutex mutex;\n+    bool finished;\n+  };\n+\n+  struct Callback;\n+\n+  struct MappedCallback {\n+    void operator()(const Result<V>& maybe_next) {\n+      bool end = !maybe_next.ok() || IterationTraits<V>::IsEnd(*maybe_next);\n+      bool should_purge = false;\n+      if (end) {\n+        {\n+          auto guard = state->mutex.Lock();\n+          should_purge = !state->finished;\n+          state->finished = true;\n+        }\n+      }\n+      sink.MarkFinished(maybe_next);\n+      if (should_purge) {\n+        while (!state->waiting_jobs.empty()) {\n\nReview comment:\n       Done.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T22:39:25.280+0000",
                    "updated": "2021-03-08T22:39:25.280+0000",
                    "started": "2021-03-08T22:39:25.279+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562654",
                    "issueId": "13362714"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/562655",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643#discussion_r589800665\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -87,6 +103,143 @@ Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n   return Loop(LoopBody{std::move(generator), std::move(vec)});\n }\n \n+template <typename T, typename V>\n+class MappingGenerator {\n+ public:\n+  MappingGenerator(AsyncGenerator<T> source, std::function<Future<V>(const T&)> map)\n+      : state_(std::make_shared<State>(std::move(source), std::move(map))) {}\n+\n+  Future<V> operator()() {\n+    auto future = Future<V>::Make();\n+    bool should_trigger;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (state_->finished) {\n+        return Future<V>::MakeFinished(IterationTraits<V>::End());\n+      }\n+      should_trigger = state_->waiting_jobs.empty();\n+      state_->waiting_jobs.push_back(future);\n+    }\n+    if (should_trigger) {\n+      state_->source().AddCallback(Callback{state_});\n+    }\n+    return future;\n+  }\n+\n+ private:\n+  struct State {\n+    State(AsyncGenerator<T> source, std::function<Future<V>(const T&)> map)\n+        : source(std::move(source)),\n+          map(std::move(map)),\n+          waiting_jobs(),\n+          mutex(),\n+          finished(false) {}\n+\n+    AsyncGenerator<T> source;\n+    std::function<Future<V>(const T&)> map;\n+    std::deque<Future<V>> waiting_jobs;\n+    util::Mutex mutex;\n+    bool finished;\n+  };\n+\n+  struct Callback;\n+\n+  struct MappedCallback {\n+    void operator()(const Result<V>& maybe_next) {\n+      bool end = !maybe_next.ok() || IterationTraits<V>::IsEnd(*maybe_next);\n+      bool should_purge = false;\n+      if (end) {\n+        {\n+          auto guard = state->mutex.Lock();\n+          should_purge = !state->finished;\n+          state->finished = true;\n+        }\n+      }\n+      sink.MarkFinished(maybe_next);\n+      if (should_purge) {\n+        while (!state->waiting_jobs.empty()) {\n+          state->waiting_jobs.front().MarkFinished(IterationTraits<V>::End());\n+          state->waiting_jobs.pop_front();\n+        }\n+      }\n+    }\n+    std::shared_ptr<State> state;\n+    Future<V> sink;\n+  };\n+\n+  struct Callback {\n+    void operator()(const Result<T>& maybe_next) {\n+      Future<V> sink;\n+      bool end = !maybe_next.ok() || IterationTraits<T>::IsEnd(*maybe_next);\n+      bool should_purge = false;\n+      bool should_trigger;\n+      {\n+        auto guard = state->mutex.Lock();\n+        if (end) {\n+          should_purge = !state->finished;\n+          state->finished = true;\n+        }\n+        sink = state->waiting_jobs.front();\n+        state->waiting_jobs.pop_front();\n+        should_trigger = !end && !state->waiting_jobs.empty();\n+      }\n+      if (should_purge) {\n+        while (!state->waiting_jobs.empty()) {\n+          state->waiting_jobs.front().MarkFinished(IterationTraits<V>::End());\n+          state->waiting_jobs.pop_front();\n+        }\n+      }\n+      if (should_trigger) {\n\nReview comment:\n       Ok, I added an explanation of async-reentrant to the top of the file (couldn't find a better place) and added \"\\see MakeXYZ\" to \"class XYZGenerator\".\n\n##########\nFile path: cpp/src/arrow/util/vector.h\n##########\n@@ -81,5 +84,53 @@ std::vector<T> FilterVector(std::vector<T> values, Predicate&& predicate) {\n   return values;\n }\n \n+/// \\brief Like MapIterator, but where the function can fail.\n\nReview comment:\n       Done.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T22:40:18.337+0000",
                    "updated": "2021-03-08T22:40:18.337+0000",
                    "started": "2021-03-08T22:40:18.337+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562655",
                    "issueId": "13362714"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/562660",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643#discussion_r589801536\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -235,29 +505,213 @@ class ReadaheadGenerator {\n /// The source generator must be async-reentrant\n ///\n /// This generator itself is async-reentrant.\n+///\n+/// This generator may queue up to max_readahead instances of T\n template <typename T>\n AsyncGenerator<T> MakeReadaheadGenerator(AsyncGenerator<T> source_generator,\n                                          int max_readahead) {\n   return ReadaheadGenerator<T>(std::move(source_generator), max_readahead);\n }\n \n-/// \\brief Transforms an async generator using a transformer function returning a new\n-/// AsyncGenerator\n+/// \\brief Creates a generator that will yield finished futures from a vector\n ///\n-/// The transform function here behaves exactly the same as the transform function in\n-/// MakeTransformedIterator and you can safely use the same transform function to\n-/// transform both synchronous and asynchronous streams.\n+/// This generator is async-reentrant\n+template <typename T>\n+AsyncGenerator<T> MakeVectorGenerator(std::vector<T> vec) {\n+  struct State {\n+    explicit State(std::vector<T> vec_) : vec(std::move(vec_)), vec_idx(0) {}\n+\n+    std::vector<T> vec;\n+    std::atomic<std::size_t> vec_idx;\n+  };\n+\n+  auto state = std::make_shared<State>(std::move(vec));\n+  return [state]() {\n+    auto idx = state->vec_idx.fetch_add(1);\n+    if (idx >= state->vec.size()) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+    return Future<T>::MakeFinished(state->vec[idx]);\n+  };\n+}\n+\n+template <typename T>\n+class MergeMapGenerator {\n+ public:\n+  explicit MergeMapGenerator(AsyncGenerator<AsyncGenerator<T>> source,\n+                             int max_subscriptions)\n+      : state_(std::make_shared<State>(std::move(source), max_subscriptions)) {}\n+\n+  Future<T> operator()() {\n+    Future<T> waiting_future;\n+    std::shared_ptr<DeliveredJob> delivered_job;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->delivered_jobs.empty()) {\n+        delivered_job = std::move(state_->delivered_jobs.front());\n+        state_->delivered_jobs.pop_front();\n+      } else if (state_->finished) {\n+        return IterationTraits<T>::End();\n+      } else {\n+        waiting_future = Future<T>::Make();\n+        state_->waiting_jobs.push_back(std::make_shared<Future<T>>(waiting_future));\n+      }\n+    }\n+    if (delivered_job) {\n+      delivered_job->deliverer().AddCallback(InnerCallback{state_, delivered_job->index});\n+      return std::move(delivered_job->value);\n+    }\n+    if (state_->first) {\n+      state_->first = false;\n+      for (std::size_t i = 0; i < state_->active_subscriptions.size(); i++) {\n+        state_->source().AddCallback(OuterCallback{state_, i});\n+      }\n+    }\n+    return waiting_future;\n+  }\n+\n+ private:\n+  struct DeliveredJob {\n+    explicit DeliveredJob(AsyncGenerator<T> deliverer_, T value_, std::size_t index_)\n+        : deliverer(deliverer_), value(value_), index(index_) {}\n+\n+    AsyncGenerator<T> deliverer;\n+    T value;\n+    std::size_t index;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<AsyncGenerator<T>> source, int max_subscriptions)\n+        : source(std::move(source)),\n+          active_subscriptions(max_subscriptions),\n+          delivered_jobs(),\n+          waiting_jobs(),\n+          mutex(),\n+          first(true),\n+          source_exhausted(false),\n+          finished(false),\n+          num_active_subscriptions(max_subscriptions) {}\n+\n+    AsyncGenerator<AsyncGenerator<T>> source;\n+    // active_subscriptions and delivered_jobs will be bounded by max_subscriptions\n+    std::vector<AsyncGenerator<T>> active_subscriptions;\n+    std::deque<std::shared_ptr<DeliveredJob>> delivered_jobs;\n+    // waiting_jobs is unbounded, reentrant pulls (e.g. AddReadahead) will provide the\n+    // backpressure\n+    std::deque<std::shared_ptr<Future<T>>> waiting_jobs;\n+    util::Mutex mutex;\n+    bool first;\n+    bool source_exhausted;\n+    bool finished;\n+    int num_active_subscriptions;\n+  };\n+\n+  struct InnerCallback {\n+    void operator()(const Result<T>& maybe_next) {\n+      bool finished = false;\n+      Future<T> sink;\n+      if (maybe_next.ok()) {\n+        finished = IterationTraits<T>::IsEnd(*maybe_next);\n+        {\n+          auto guard = state->mutex.Lock();\n+          if (!finished) {\n+            if (state->waiting_jobs.empty()) {\n+              state->delivered_jobs.push_back(std::make_shared<DeliveredJob>(\n+                  state->active_subscriptions[index], *maybe_next, index));\n+            } else {\n+              sink = std::move(*state->waiting_jobs.front());\n+              state->waiting_jobs.pop_front();\n+            }\n+          }\n+        }\n+      } else {\n+        finished = true;\n+      }\n+      if (finished) {\n+        state->source().AddCallback(OuterCallback{state, index});\n+      } else if (sink.is_valid()) {\n+        sink.MarkFinished(*maybe_next);\n+        state->active_subscriptions[index]().AddCallback(*this);\n+      }\n+    }\n+    std::shared_ptr<State> state;\n+    std::size_t index;\n+  };\n+\n+  struct OuterCallback {\n+    void operator()(const Result<AsyncGenerator<T>>& maybe_next) {\n+      bool should_purge = false;\n+      bool should_continue = false;\n+      {\n+        auto guard = state->mutex.Lock();\n+        if (!maybe_next.ok() || IterationTraits<AsyncGenerator<T>>::IsEnd(*maybe_next)) {\n+          state->source_exhausted = true;\n+          if (--state->num_active_subscriptions == 0) {\n+            state->finished = true;\n+            should_purge = true;\n+          }\n+        } else {\n+          state->active_subscriptions[index] = *maybe_next;\n+          should_continue = true;\n+        }\n+      }\n+      if (should_continue) {\n+        (*maybe_next)().AddCallback(InnerCallback{state, index});\n+      } else if (should_purge) {\n+        // At this point state->finished has been marked true so no one else\n+        // will be interacting with waiting_jobs and we can iterate outside lock\n+        while (!state->waiting_jobs.empty()) {\n+          state->waiting_jobs.front()->MarkFinished(IterationTraits<T>::End());\n+          state->waiting_jobs.pop_front();\n+        }\n+      }\n+    }\n+    std::shared_ptr<State> state;\n+    std::size_t index;\n+  };\n+\n+  std::shared_ptr<State> state_;\n+};\n+\n+/// \\brief Creates a generator that takes in a stream of generators and pulls from up to\n+/// max_subscriptions at a time\n ///\n-/// This generator is not async-reentrant\n-template <typename T, typename V>\n-AsyncGenerator<V> MakeAsyncGenerator(AsyncGenerator<T> generator,\n-                                     Transformer<T, V> transformer) {\n-  return TransformingGenerator<T, V>(generator, transformer);\n+/// Note: This is the equivalent of Rx::MergeMap.  This may deliver items out of\n+/// sequence. For example, items from the third AsyncGenerator generated by the source\n+/// may be emitted before some items from the first AsyncGenerator generated by the\n+/// source.\n+///\n+/// This generator expects source to be async-reentrant regardless of whether this\n+/// generator is async-reentrant or not (unless max_readahead is 1)\n+/// This generator will not pull from the individual subscriptions reentrantly.  Add\n+/// readahead to the individual subscriptions if that is desired.\n+/// This generator is async-reentrant\n+///\n+/// This generator may queue up to max_readahead instances of T\n+template <typename T>\n+AsyncGenerator<T> MakeMergeMapGenerator(AsyncGenerator<AsyncGenerator<T>> source,\n+                                        int max_readahead) {\n+  return MergeMapGenerator<T>(std::move(source), max_readahead);\n\nReview comment:\n       Max subscriptions.  I fixed up the naming.  Maybe it's not the best name as subscriptions comes from Rx where there are actual \"subscriptions\" but the concept is pretty much the same.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T22:41:39.260+0000",
                    "updated": "2021-03-08T22:41:39.260+0000",
                    "started": "2021-03-08T22:41:39.260+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562660",
                    "issueId": "13362714"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/562677",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643#discussion_r589812144\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -87,6 +103,143 @@ Future<std::vector<T>> CollectAsyncGenerator(AsyncGenerator<T> generator) {\n   return Loop(LoopBody{std::move(generator), std::move(vec)});\n }\n \n+template <typename T, typename V>\n+class MappingGenerator {\n+ public:\n+  MappingGenerator(AsyncGenerator<T> source, std::function<Future<V>(const T&)> map)\n+      : state_(std::make_shared<State>(std::move(source), std::move(map))) {}\n+\n+  Future<V> operator()() {\n+    auto future = Future<V>::Make();\n+    bool should_trigger;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (state_->finished) {\n+        return Future<V>::MakeFinished(IterationTraits<V>::End());\n+      }\n+      should_trigger = state_->waiting_jobs.empty();\n+      state_->waiting_jobs.push_back(future);\n+    }\n+    if (should_trigger) {\n+      state_->source().AddCallback(Callback{state_});\n+    }\n+    return future;\n+  }\n+\n+ private:\n+  struct State {\n+    State(AsyncGenerator<T> source, std::function<Future<V>(const T&)> map)\n+        : source(std::move(source)),\n+          map(std::move(map)),\n+          waiting_jobs(),\n+          mutex(),\n+          finished(false) {}\n+\n+    AsyncGenerator<T> source;\n+    std::function<Future<V>(const T&)> map;\n+    std::deque<Future<V>> waiting_jobs;\n+    util::Mutex mutex;\n+    bool finished;\n+  };\n+\n+  struct Callback;\n+\n+  struct MappedCallback {\n+    void operator()(const Result<V>& maybe_next) {\n+      bool end = !maybe_next.ok() || IterationTraits<V>::IsEnd(*maybe_next);\n+      bool should_purge = false;\n+      if (end) {\n+        {\n+          auto guard = state->mutex.Lock();\n+          should_purge = !state->finished;\n+          state->finished = true;\n+        }\n+      }\n+      sink.MarkFinished(maybe_next);\n+      if (should_purge) {\n+        while (!state->waiting_jobs.empty()) {\n+          state->waiting_jobs.front().MarkFinished(IterationTraits<V>::End());\n+          state->waiting_jobs.pop_front();\n+        }\n+      }\n+    }\n+    std::shared_ptr<State> state;\n+    Future<V> sink;\n+  };\n+\n+  struct Callback {\n+    void operator()(const Result<T>& maybe_next) {\n+      Future<V> sink;\n+      bool end = !maybe_next.ok() || IterationTraits<T>::IsEnd(*maybe_next);\n+      bool should_purge = false;\n+      bool should_trigger;\n+      {\n+        auto guard = state->mutex.Lock();\n+        if (end) {\n+          should_purge = !state->finished;\n+          state->finished = true;\n+        }\n+        sink = state->waiting_jobs.front();\n+        state->waiting_jobs.pop_front();\n+        should_trigger = !end && !state->waiting_jobs.empty();\n+      }\n+      if (should_purge) {\n+        while (!state->waiting_jobs.empty()) {\n+          state->waiting_jobs.front().MarkFinished(IterationTraits<V>::End());\n+          state->waiting_jobs.pop_front();\n+        }\n+      }\n+      if (should_trigger) {\n\nReview comment:\n       Thank you!\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T22:59:53.742+0000",
                    "updated": "2021-03-08T22:59:53.742+0000",
                    "started": "2021-03-08T22:59:53.742+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562677",
                    "issueId": "13362714"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/563097",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643#discussion_r590411792\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +364,126 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+/// \\brief Transforms an async generator using a transformer function returning a new\n+/// AsyncGenerator\n+///\n+/// The transform function here behaves exactly the same as the transform function in\n+/// MakeTransformedIterator and you can safely use the same transform function to\n+/// transform both synchronous and asynchronous streams.\n+///\n+/// This generator is not async-reentrant\n+///\n+/// This generator may queue up to 1 instance of T\n+template <typename T, typename V>\n+AsyncGenerator<V> MakeAsyncGenerator(AsyncGenerator<T> generator,\n+                                     Transformer<T, V> transformer) {\n+  return TransformingGenerator<T, V>(generator, transformer);\n+}\n+\n+/// \\see MakeSerialReadaheadGenerator\n+template <typename T>\n+class SerialReadaheadGenerator {\n+ public:\n+  SerialReadaheadGenerator(AsyncGenerator<T> source_generator, int max_readahead)\n+      : state_(std::make_shared<State>(std::move(source_generator), max_readahead)) {}\n+\n+  Future<T> operator()() {\n+    if (state_->first) {\n+      // Lazy generator, need to wait for the first ask to prime the pump\n+      state_->first = false;\n+      auto next = state_->source();\n+      return next.Then(Callback{state_});\n+    }\n+\n+    // This generator is not async-reentrant.  We won't be called until the last\n+    // future finished so we know there is something in the queue\n+    auto finished = state_->finished.load();\n+    if (finished && state_->readahead_queue.IsEmpty()) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+\n+    auto next_ptr = state_->readahead_queue.FrontPtr();\n+    auto next = std::move(**next_ptr);\n+    state_->readahead_queue.PopFront();\n+\n+    auto last_available = state_->spaces_available.fetch_add(1);\n+    if (last_available == 0 && !finished) {\n+      // Reader idled out, we need to restart it\n+      ARROW_RETURN_NOT_OK(state_->Pump(state_));\n+    }\n+    return next;\n+  }\n+\n+ private:\n+  struct State {\n+    State(AsyncGenerator<T> source_, int max_readahead)\n+        : first(true),\n+          source(std::move(source_)),\n+          finished(false),\n+          spaces_available(max_readahead),\n+          readahead_queue(max_readahead) {}\n+\n+    Status Pump(const std::shared_ptr<State>& self) {\n+      // Can't do readahead_queue.write(source().Then(Callback{self})) because then the\n+      // callback might run immediately and add itself to the queue before this gets added\n+      // to the queue messing up the order\n+      auto next_slot = std::make_shared<Future<T>>();\n+      auto written = readahead_queue.Write(next_slot);\n+      if (!written) {\n+        return Status::UnknownError(\"Could not write to readahead_queue\");\n+      }\n+      *next_slot = source().Then(Callback{self});\n+      return Status::OK();\n+    }\n+\n+    // Only accessed by the consumer end\n+    bool first;\n+    // Accessed by both threads\n+    AsyncGenerator<T> source;\n+    std::atomic<bool> finished;\n+    std::atomic<uint32_t> spaces_available;\n+    util::SpscQueue<std::shared_ptr<Future<T>>> readahead_queue;\n+  };\n+\n+  struct Callback {\n+    Result<T> operator()(const Result<T>& maybe_next) {\n+      if (!maybe_next.ok()) {\n+        state_->finished.store(true);\n+        return maybe_next;\n+      }\n+      const auto& next = *maybe_next;\n+      if (IterationTraits<T>::IsEnd(next)) {\n+        state_->finished = true;\n+        return maybe_next;\n+      }\n+      auto last_available = state_->spaces_available.fetch_sub(1);\n+      if (last_available > 1) {\n\nReview comment:\n       Hmm. In the case that `max_readahead == 1`, the first Callback will run and won't enqueue anything. Then the next time the caller gets a future from the generator, the readahead queue will be empty, even though the generator isn't finished. \r\n   \r\n   But if we instead had `last_available > 0`, then we'd accidentally make spaces_available negative when the callback runs. I think we have to check last_available before decrementing it, which should be okay since it's not accessed concurrently. Not only that, but the check and decrement should be done in Pump(), which is what actually adds to the queue - otherwise you'd have the same problem again when operator() calls Pump().\r\n   \n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -177,6 +364,126 @@ class TransformingGenerator {\n   std::shared_ptr<TransformingGeneratorState> state_;\n };\n \n+/// \\brief Transforms an async generator using a transformer function returning a new\n+/// AsyncGenerator\n+///\n+/// The transform function here behaves exactly the same as the transform function in\n+/// MakeTransformedIterator and you can safely use the same transform function to\n+/// transform both synchronous and asynchronous streams.\n+///\n+/// This generator is not async-reentrant\n+///\n+/// This generator may queue up to 1 instance of T\n+template <typename T, typename V>\n+AsyncGenerator<V> MakeAsyncGenerator(AsyncGenerator<T> generator,\n+                                     Transformer<T, V> transformer) {\n+  return TransformingGenerator<T, V>(generator, transformer);\n+}\n+\n+/// \\see MakeSerialReadaheadGenerator\n+template <typename T>\n+class SerialReadaheadGenerator {\n+ public:\n+  SerialReadaheadGenerator(AsyncGenerator<T> source_generator, int max_readahead)\n+      : state_(std::make_shared<State>(std::move(source_generator), max_readahead)) {}\n+\n+  Future<T> operator()() {\n+    if (state_->first) {\n+      // Lazy generator, need to wait for the first ask to prime the pump\n+      state_->first = false;\n+      auto next = state_->source();\n+      return next.Then(Callback{state_});\n+    }\n+\n+    // This generator is not async-reentrant.  We won't be called until the last\n+    // future finished so we know there is something in the queue\n+    auto finished = state_->finished.load();\n+    if (finished && state_->readahead_queue.IsEmpty()) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+\n+    auto next_ptr = state_->readahead_queue.FrontPtr();\n+    auto next = std::move(**next_ptr);\n+    state_->readahead_queue.PopFront();\n+\n+    auto last_available = state_->spaces_available.fetch_add(1);\n+    if (last_available == 0 && !finished) {\n+      // Reader idled out, we need to restart it\n+      ARROW_RETURN_NOT_OK(state_->Pump(state_));\n+    }\n+    return next;\n+  }\n+\n+ private:\n+  struct State {\n+    State(AsyncGenerator<T> source_, int max_readahead)\n+        : first(true),\n+          source(std::move(source_)),\n+          finished(false),\n+          spaces_available(max_readahead),\n+          readahead_queue(max_readahead) {}\n+\n+    Status Pump(const std::shared_ptr<State>& self) {\n+      // Can't do readahead_queue.write(source().Then(Callback{self})) because then the\n+      // callback might run immediately and add itself to the queue before this gets added\n+      // to the queue messing up the order\n+      auto next_slot = std::make_shared<Future<T>>();\n+      auto written = readahead_queue.Write(next_slot);\n+      if (!written) {\n+        return Status::UnknownError(\"Could not write to readahead_queue\");\n+      }\n+      *next_slot = source().Then(Callback{self});\n+      return Status::OK();\n+    }\n+\n+    // Only accessed by the consumer end\n+    bool first;\n+    // Accessed by both threads\n+    AsyncGenerator<T> source;\n+    std::atomic<bool> finished;\n+    std::atomic<uint32_t> spaces_available;\n+    util::SpscQueue<std::shared_ptr<Future<T>>> readahead_queue;\n+  };\n+\n+  struct Callback {\n+    Result<T> operator()(const Result<T>& maybe_next) {\n+      if (!maybe_next.ok()) {\n+        state_->finished.store(true);\n+        return maybe_next;\n+      }\n+      const auto& next = *maybe_next;\n+      if (IterationTraits<T>::IsEnd(next)) {\n+        state_->finished = true;\n+        return maybe_next;\n+      }\n+      auto last_available = state_->spaces_available.fetch_sub(1);\n+      if (last_available > 1) {\n\nReview comment:\n       And as written, `max_readahead > 1` is safe, but will enqueue one fewer item than declared - maybe this is all intentional and I'm misunderstanding the intent here, given the SerialReadaheadSlowConsumer test below which explicitly checks the current behavior (num_delivered == 3 whereas I would expect 4). But if that's the case maybe we should enforce that `max_readahead > 1`, or add 1 to the given value.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-09T14:33:58.243+0000",
                    "updated": "2021-03-09T14:33:58.243+0000",
                    "started": "2021-03-09T14:33:58.243+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "563097",
                    "issueId": "13362714"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/563782",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643#discussion_r591557203\n\n\n\n##########\nFile path: cpp/src/arrow/csv/reader.cc\n##########\n@@ -805,7 +798,7 @@ class SerialTableReader : public BaseTableReader {\n                                                           std::move(first_buffer));\n     while (true) {\n       ARROW_ASSIGN_OR_RAISE(auto maybe_block, block_iterator.Next());\n-      if (maybe_block == IterationTraits<CSVBlock>::End()) {\n+      if (IterationTraits<CSVBlock>::IsEnd(maybe_block)) {\n\nReview comment:\n       Perhaps have a global utility `template <typename T> bool IsGeneratorEnd(const T&)`?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-10T14:18:19.483+0000",
                    "updated": "2021-03-10T14:18:19.483+0000",
                    "started": "2021-03-10T14:18:19.483+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "563782",
                    "issueId": "13362714"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/563783",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643#issuecomment-795473939\n\n\n   This seems to be based on another PR?\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-10T14:18:32.418+0000",
                    "updated": "2021-03-10T14:18:32.418+0000",
                    "started": "2021-03-10T14:18:32.418+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "563783",
                    "issueId": "13362714"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/564129",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643#discussion_r591684737\n\n\n\n##########\nFile path: cpp/src/arrow/util/vector.h\n##########\n@@ -81,5 +84,53 @@ std::vector<T> FilterVector(std::vector<T> values, Predicate&& predicate) {\n   return values;\n }\n \n+/// \\brief Like MapVector, but where the function can fail.\n+template <typename Fn, typename From = internal::call_traits::argument_type<0, Fn>,\n+          typename To = typename internal::call_traits::return_type<Fn>::ValueType>\n+Result<std::vector<To>> MaybeMapVector(Fn map, const std::vector<From>& src) {\n+  std::vector<To> out;\n+  out.reserve(src.size());\n+  ARROW_RETURN_NOT_OK(\n+      MaybeTransform(src.begin(), src.end(), std::back_inserter(out), map));\n+  return out;\n+}\n+\n+template <typename Fn, typename From = internal::call_traits::argument_type<0, Fn>,\n+          typename To = typename internal::call_traits::return_type<Fn>>\n+std::vector<To> MapVector(Fn map, const std::vector<From>& source) {\n\nReview comment:\n       ```suggestion\r\n   std::vector<To> MapVector(Fn&& map, const std::vector<From>& source) {\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/type_fwd.h\n##########\n@@ -17,14 +17,14 @@\n \n #pragma once\n \n+#include <functional>\n+\n namespace arrow {\n \n namespace detail {\n struct Empty;\n-}  // namespace detail\n+}\n\nReview comment:\n       code style: revert this please\n\n##########\nFile path: cpp/src/arrow/util/type_fwd.h\n##########\n@@ -17,14 +17,14 @@\n \n #pragma once\n \n+#include <functional>\n+\n namespace arrow {\n \n namespace detail {\n struct Empty;\n-}  // namespace detail\n+}\n \n-template <typename T = detail::Empty>\n-class Future;\n\nReview comment:\n       Is it worth maintaining arrow/util/type_fwd.h? Maybe it can be inlined into arrow/type_fwd.h. In any case, it can wait for follow up\n\n##########\nFile path: cpp/src/arrow/util/type_fwd.h\n##########\n@@ -17,14 +17,14 @@\n \n #pragma once\n \n+#include <functional>\n\nReview comment:\n       revert this; any code which depends on this line should directly include `<functional>` instead\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -21,23 +21,58 @@\n #include \"arrow/util/functional.h\"\n #include \"arrow/util/future.h\"\n #include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/mutex.h\"\n #include \"arrow/util/optional.h\"\n+#include \"arrow/util/queue.h\"\n #include \"arrow/util/thread_pool.h\"\n \n namespace arrow {\n \n+/*\n+The methods in this file create, modify, and utilize AsyncGenerator which is an iterator\n+of futures.  This allows an asynchronous source (like file input) to be run through a\n+pipeline in the same way that iterators can be used to create pipelined workflows.\n+\n+In order to support pipeline parallelism we introduce the concept of asynchronous\n+reentrancy. This is different than synchronous reentrancy.  With synchronous code a\n+function is reentrant if the function can be called again while a previous call to that\n+function is still running.  Unless otherwise called out none of these generators are\n+synchronously reentrant.  Care should be taken to avoid calling them in such a way (and\n+the utilities Visit/Collect/Await take care to do this).\n+\n+Asynchronous reentrancy on the other hand means the function is called again before the\n+future returned by the function completes (but after the call to get the future\n+completes).  Some of these generators are async-reentrant while others (e.g. those that\n\nReview comment:\n       ```suggestion\r\n   future returned by the function is marked finished (but after the call to get the future\r\n   returns).  Some of these generators are async-reentrant while others (e.g. those that\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -65,6 +100,14 @@ Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n   return Loop(LoopBody{std::move(generator), std::move(visitor)});\n }\n \n+/// \\brief Waits for an async generator to complete, discarding results.\n+template <typename T>\n+Future<> AwaitAsyncGenerator(AsyncGenerator<T> generator) {\n+  std::function<Status(T)> visitor = [](...) { return Status::OK(); };\n+  return VisitAsyncGenerator(generator, visitor);\n+}  // namespace arrow\n\nReview comment:\n       ```suggestion\r\n   }\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -21,23 +21,58 @@\n #include \"arrow/util/functional.h\"\n #include \"arrow/util/future.h\"\n #include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/mutex.h\"\n #include \"arrow/util/optional.h\"\n+#include \"arrow/util/queue.h\"\n #include \"arrow/util/thread_pool.h\"\n \n namespace arrow {\n \n+/*\n+The methods in this file create, modify, and utilize AsyncGenerator which is an iterator\n+of futures.  This allows an asynchronous source (like file input) to be run through a\n+pipeline in the same way that iterators can be used to create pipelined workflows.\n+\n+In order to support pipeline parallelism we introduce the concept of asynchronous\n+reentrancy. This is different than synchronous reentrancy.  With synchronous code a\n+function is reentrant if the function can be called again while a previous call to that\n+function is still running.  Unless otherwise called out none of these generators are\n\nReview comment:\n       ```suggestion\r\n   function is still running.  Unless otherwise specified none of these generators are\r\n   ```\r\n   (just because \"call\" is overloaded here)\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -65,6 +100,14 @@ Future<> VisitAsyncGenerator(AsyncGenerator<T> generator,\n   return Loop(LoopBody{std::move(generator), std::move(visitor)});\n }\n \n+/// \\brief Waits for an async generator to complete, discarding results.\n+template <typename T>\n+Future<> AwaitAsyncGenerator(AsyncGenerator<T> generator) {\n\nReview comment:\n       ```suggestion\r\n   Future<> DiscardAllFromAsyncGenerator(AsyncGenerator<T> generator) {\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/vector.h\n##########\n@@ -81,5 +84,53 @@ std::vector<T> FilterVector(std::vector<T> values, Predicate&& predicate) {\n   return values;\n }\n \n+/// \\brief Like MapVector, but where the function can fail.\n+template <typename Fn, typename From = internal::call_traits::argument_type<0, Fn>,\n+          typename To = typename internal::call_traits::return_type<Fn>::ValueType>\n+Result<std::vector<To>> MaybeMapVector(Fn map, const std::vector<From>& src) {\n+  std::vector<To> out;\n+  out.reserve(src.size());\n+  ARROW_RETURN_NOT_OK(\n+      MaybeTransform(src.begin(), src.end(), std::back_inserter(out), map));\n+  return out;\n+}\n+\n+template <typename Fn, typename From = internal::call_traits::argument_type<0, Fn>,\n+          typename To = typename internal::call_traits::return_type<Fn>>\n+std::vector<To> MapVector(Fn map, const std::vector<From>& source) {\n+  std::vector<To> out;\n+  out.reserve(source.size());\n+  std::transform(source.begin(), source.end(), std::back_inserter(out), map);\n+  return out;\n+}\n+\n+template <typename T>\n+std::vector<T> FlattenVectors(const std::vector<std::vector<T>> vecs) {\n\nReview comment:\n       ```suggestion\r\n   std::vector<T> FlattenVectors(const std::vector<std::vector<T>>& vecs) {\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/vector.h\n##########\n@@ -81,5 +84,53 @@ std::vector<T> FilterVector(std::vector<T> values, Predicate&& predicate) {\n   return values;\n }\n \n+/// \\brief Like MapVector, but where the function can fail.\n+template <typename Fn, typename From = internal::call_traits::argument_type<0, Fn>,\n+          typename To = typename internal::call_traits::return_type<Fn>::ValueType>\n+Result<std::vector<To>> MaybeMapVector(Fn map, const std::vector<From>& src) {\n\nReview comment:\n       ```suggestion\r\n   Result<std::vector<To>> MaybeMapVector(Fn&& map, const std::vector<From>& src) {\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -570,8 +616,48 @@ TEST(ReadaheadIterator, NextError) {\n // --------------------------------------------------------------------\n // Asynchronous iterator tests\n \n+template <typename T>\n+class ReentrantChecker {\n+ public:\n+  explicit ReentrantChecker(AsyncGenerator<T> source)\n+      : state_(std::make_shared<State>(std::move(source))) {}\n+\n+  Future<T> operator()() {\n+    if (state_->in.load()) {\n+      state_->valid.store(false);\n+    }\n+    state_->in.store(true);\n+    auto result = state_->source();\n+    return result.Then(Callback{state_});\n+  }\n+\n+  void AssertValid() {\n\nReview comment:\n       There are some cases below where AssertValid is not called (and would be difficult to call). Replacing this with a destructor will ensure that we always assert the checker is valid.\r\n   ```suggestion\r\n     ~ReentrantChecker() {\r\n   ```\r\n   \r\n   This is a bit inflexible, though; you might want to assert invalidity instead or assert sooner than the checker will fall out of scope. Instead, it might be better to move the validity flag outside this helper:\r\n   \r\n   ```c++\r\n     ReentrantChecker(AsyncGenerator<T> source, std::atomic<bool>* is_valid)\r\n         : state_(std::make_shared<State>(std::move(source), is_valid)) {}\r\n   ```\r\n   \r\n   So that the flag's value can be asserted as needed:\r\n   \r\n   ```c++\r\n   std::atomic<bool> all_reentrant_checkers_valid(true);\r\n   for (...) {\r\n     sources[i] = ReentrantChecker<TestInt>(std::move(sources[i]), &all_reentrant_checkers_valid);\r\n   }\r\n   //...\r\n   ASSERT_TRUE(all_reentrant_checkers_valid.load());\r\n   ```\n\n##########\nFile path: cpp/src/arrow/csv/reader.cc\n##########\n@@ -805,7 +798,7 @@ class SerialTableReader : public BaseTableReader {\n                                                           std::move(first_buffer));\n     while (true) {\n       ARROW_ASSIGN_OR_RAISE(auto maybe_block, block_iterator.Next());\n-      if (maybe_block == IterationTraits<CSVBlock>::End()) {\n+      if (IterationTraits<CSVBlock>::IsEnd(maybe_block)) {\n\nReview comment:\n       I agree that this is more ergonomic. Additionally, please make it clear which is the intended single point of truth for detecting the end sentinel (::End() or ::IsEnd())\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -21,23 +21,58 @@\n #include \"arrow/util/functional.h\"\n #include \"arrow/util/future.h\"\n #include \"arrow/util/iterator.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/mutex.h\"\n #include \"arrow/util/optional.h\"\n+#include \"arrow/util/queue.h\"\n #include \"arrow/util/thread_pool.h\"\n \n namespace arrow {\n \n+/*\n\nReview comment:\n       Style nit: please use `//`\n\n##########\nFile path: cpp/src/arrow/util/async_generator.h\n##########\n@@ -235,29 +541,209 @@ class ReadaheadGenerator {\n /// The source generator must be async-reentrant\n ///\n /// This generator itself is async-reentrant.\n+///\n+/// This generator may queue up to max_readahead instances of T\n template <typename T>\n AsyncGenerator<T> MakeReadaheadGenerator(AsyncGenerator<T> source_generator,\n                                          int max_readahead) {\n   return ReadaheadGenerator<T>(std::move(source_generator), max_readahead);\n }\n \n-/// \\brief Transforms an async generator using a transformer function returning a new\n-/// AsyncGenerator\n+/// \\brief Creates a generator that will yield finished futures from a vector\n ///\n-/// The transform function here behaves exactly the same as the transform function in\n-/// MakeTransformedIterator and you can safely use the same transform function to\n-/// transform both synchronous and asynchronous streams.\n+/// This generator is async-reentrant\n+template <typename T>\n+AsyncGenerator<T> MakeVectorGenerator(std::vector<T> vec) {\n+  struct State {\n+    explicit State(std::vector<T> vec_) : vec(std::move(vec_)), vec_idx(0) {}\n+\n+    std::vector<T> vec;\n+    std::atomic<std::size_t> vec_idx;\n+  };\n+\n+  auto state = std::make_shared<State>(std::move(vec));\n+  return [state]() {\n+    auto idx = state->vec_idx.fetch_add(1);\n+    if (idx >= state->vec.size()) {\n+      return Future<T>::MakeFinished(IterationTraits<T>::End());\n+    }\n+    return Future<T>::MakeFinished(state->vec[idx]);\n+  };\n+}\n+\n+/// \\see MakeMergeMapGenerator\n+template <typename T>\n+class MergeMapGenerator {\n+ public:\n+  explicit MergeMapGenerator(AsyncGenerator<AsyncGenerator<T>> source,\n+                             int max_subscriptions)\n+      : state_(std::make_shared<State>(std::move(source), max_subscriptions)) {}\n+\n+  Future<T> operator()() {\n+    Future<T> waiting_future;\n+    std::shared_ptr<DeliveredJob> delivered_job;\n+    {\n+      auto guard = state_->mutex.Lock();\n+      if (!state_->delivered_jobs.empty()) {\n+        delivered_job = std::move(state_->delivered_jobs.front());\n+        state_->delivered_jobs.pop_front();\n+      } else if (state_->finished) {\n+        return IterationTraits<T>::End();\n+      } else {\n+        waiting_future = Future<T>::Make();\n+        state_->waiting_jobs.push_back(std::make_shared<Future<T>>(waiting_future));\n+      }\n+    }\n+    if (delivered_job) {\n+      delivered_job->deliverer().AddCallback(InnerCallback{state_, delivered_job->index});\n+      return std::move(delivered_job->value);\n+    }\n+    if (state_->first) {\n+      state_->first = false;\n+      for (std::size_t i = 0; i < state_->active_subscriptions.size(); i++) {\n+        state_->source().AddCallback(OuterCallback{state_, i});\n+      }\n+    }\n+    return waiting_future;\n+  }\n+\n+ private:\n+  struct DeliveredJob {\n+    explicit DeliveredJob(AsyncGenerator<T> deliverer_, T value_, std::size_t index_)\n+        : deliverer(deliverer_), value(value_), index(index_) {}\n+\n+    AsyncGenerator<T> deliverer;\n+    T value;\n+    std::size_t index;\n+  };\n+\n+  struct State {\n+    State(AsyncGenerator<AsyncGenerator<T>> source, int max_subscriptions)\n+        : source(std::move(source)),\n+          active_subscriptions(max_subscriptions),\n+          delivered_jobs(),\n+          waiting_jobs(),\n+          mutex(),\n+          first(true),\n+          source_exhausted(false),\n+          finished(false),\n+          num_active_subscriptions(max_subscriptions) {}\n+\n+    AsyncGenerator<AsyncGenerator<T>> source;\n+    // active_subscriptions and delivered_jobs will be bounded by max_subscriptions\n+    std::vector<AsyncGenerator<T>> active_subscriptions;\n+    std::deque<std::shared_ptr<DeliveredJob>> delivered_jobs;\n+    // waiting_jobs is unbounded, reentrant pulls (e.g. AddReadahead) will provide the\n+    // backpressure\n+    std::deque<std::shared_ptr<Future<T>>> waiting_jobs;\n+    util::Mutex mutex;\n+    bool first;\n+    bool source_exhausted;\n+    bool finished;\n+    int num_active_subscriptions;\n+  };\n+\n+  struct InnerCallback {\n+    void operator()(const Result<T>& maybe_next) {\n+      bool finished = false;\n+      Future<T> sink;\n+      if (maybe_next.ok()) {\n+        finished = IterationTraits<T>::IsEnd(*maybe_next);\n+        {\n+          auto guard = state->mutex.Lock();\n+          if (!finished) {\n+            if (state->waiting_jobs.empty()) {\n+              state->delivered_jobs.push_back(std::make_shared<DeliveredJob>(\n+                  state->active_subscriptions[index], *maybe_next, index));\n+            } else {\n+              sink = std::move(*state->waiting_jobs.front());\n+              state->waiting_jobs.pop_front();\n+            }\n+          }\n+        }\n+      } else {\n+        finished = true;\n+      }\n+      if (finished) {\n+        state->source().AddCallback(OuterCallback{state, index});\n+      } else if (sink.is_valid()) {\n+        sink.MarkFinished(*maybe_next);\n+        state->active_subscriptions[index]().AddCallback(*this);\n+      }\n+    }\n+    std::shared_ptr<State> state;\n+    std::size_t index;\n+  };\n+\n+  struct OuterCallback {\n+    void operator()(const Result<AsyncGenerator<T>>& maybe_next) {\n+      bool should_purge = false;\n+      bool should_continue = false;\n+      {\n+        auto guard = state->mutex.Lock();\n+        if (!maybe_next.ok() || IterationTraits<AsyncGenerator<T>>::IsEnd(*maybe_next)) {\n+          state->source_exhausted = true;\n+          if (--state->num_active_subscriptions == 0) {\n+            state->finished = true;\n+            should_purge = true;\n+          }\n+        } else {\n+          state->active_subscriptions[index] = *maybe_next;\n+          should_continue = true;\n+        }\n+      }\n+      if (should_continue) {\n+        (*maybe_next)().AddCallback(InnerCallback{state, index});\n+      } else if (should_purge) {\n+        // At this point state->finished has been marked true so no one else\n+        // will be interacting with waiting_jobs and we can iterate outside lock\n+        while (!state->waiting_jobs.empty()) {\n+          state->waiting_jobs.front()->MarkFinished(IterationTraits<T>::End());\n+          state->waiting_jobs.pop_front();\n+        }\n+      }\n+    }\n+    std::shared_ptr<State> state;\n+    std::size_t index;\n+  };\n+\n+  std::shared_ptr<State> state_;\n+};\n+\n+/// \\brief Creates a generator that takes in a stream of generators and pulls from up to\n+/// max_subscriptions at a time\n ///\n-/// This generator is not async-reentrant\n-template <typename T, typename V>\n-AsyncGenerator<V> MakeAsyncGenerator(AsyncGenerator<T> generator,\n-                                     Transformer<T, V> transformer) {\n-  return TransformingGenerator<T, V>(generator, transformer);\n+/// Note: This is the equivalent of Rx::MergeMap.  This may deliver items out of\n\nReview comment:\n       I see the connection, but I'm not sure this is precisely analagous since there isn't a `map` function here. Readers unfamiliar with Rx::MergeMap might misunderstand. Could we just name this `MergedGenerator` or so?\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -570,8 +616,48 @@ TEST(ReadaheadIterator, NextError) {\n // --------------------------------------------------------------------\n // Asynchronous iterator tests\n \n+template <typename T>\n+class ReentrantChecker {\n+ public:\n+  explicit ReentrantChecker(AsyncGenerator<T> source)\n+      : state_(std::make_shared<State>(std::move(source))) {}\n+\n+  Future<T> operator()() {\n+    if (state_->in.load()) {\n+      state_->valid.store(false);\n+    }\n+    state_->in.store(true);\n+    auto result = state_->source();\n+    return result.Then(Callback{state_});\n+  }\n+\n+  void AssertValid() {\n+    EXPECT_EQ(true, state_->valid.load())\n+        << \"The generator was accessed in a reentrant manner\";\n+  }\n+\n+ private:\n+  struct State {\n+    explicit State(AsyncGenerator<T> source_)\n+        : source(std::move(source_)), in(false), valid(true) {}\n+\n+    AsyncGenerator<T> source;\n+    std::atomic<bool> in;\n\nReview comment:\n       Nit: more descriptive nam\r\n   ```suggestion\r\n       std::atomic<bool> generated_unfinished_future;\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/iterator_test.cc\n##########\n@@ -589,15 +675,255 @@ TEST(TestAsyncUtil, Collect) {\n   ASSERT_EQ(expected, collected_val);\n }\n \n+TEST(TestAsyncUtil, Map) {\n+  std::vector<TestInt> input = {1, 2, 3};\n+  auto generator = AsyncVectorIt(input);\n+  std::function<TestStr(const TestInt&)> mapper = [](const TestInt& in) {\n+    return std::to_string(in.value);\n+  };\n+  auto mapped = MakeMappedGenerator(std::move(generator), mapper);\n+  std::vector<TestStr> expected{\"1\", \"2\", \"3\"};\n+  AssertAsyncGeneratorMatch(expected, mapped);\n+}\n+\n+TEST(TestAsyncUtil, MapAsync) {\n+  std::vector<TestInt> input = {1, 2, 3};\n+  auto generator = AsyncVectorIt(input);\n+  std::function<Future<TestStr>(const TestInt&)> mapper = [](const TestInt& in) {\n+    return SleepAsync(1e-3).Then([in](const Result<detail::Empty>& empty) {\n+      return TestStr(std::to_string(in.value));\n+    });\n+  };\n+  auto mapped = MakeMappedGenerator(std::move(generator), mapper);\n+  std::vector<TestStr> expected{\"1\", \"2\", \"3\"};\n+  AssertAsyncGeneratorMatch(expected, mapped);\n+}\n+\n+TEST(TestAsyncUtil, MapReentrant) {\n+  std::vector<TestInt> input = {1, 2};\n+  auto source = AsyncVectorIt(input);\n+  TrackingGenerator<TestInt> tracker(std::move(source));\n+  source = MakeTransferredGenerator(AsyncGenerator<TestInt>(tracker),\n+                                    internal::GetCpuThreadPool());\n+\n+  std::atomic<int> map_tasks_running(0);\n+  // Mapper blocks until signal, should start multiple map tasks\n+  std::atomic<bool> can_proceed(false);\n+  std::function<Future<TestStr>(const TestInt&)> mapper =\n+      [&can_proceed, &map_tasks_running](const TestInt& in) -> Future<TestStr> {\n+    auto fut = Future<TestStr>::Make();\n+    map_tasks_running.fetch_add(1);\n+    std::thread([fut, in, &can_proceed]() mutable {\n+      while (!can_proceed.load()) {\n+        SleepABit();\n+      }\n+      fut.MarkFinished(TestStr(std::to_string(in.value)));\n+    }).detach();\n+    return fut;\n\nReview comment:\n       Instead, could we use\r\n   ```suggestion\r\n     Future<> can_proceed;\r\n     std::function<Future<TestStr>(const TestInt&)> mapper = [&](const TestInt& in) {\r\n       map_tasks_running.fetch_add(1);\r\n       return can_proceed.Then([in](...) {\r\n         return TestStr(std::to_string(in.value));\r\n       });\r\n   ```\r\n   ?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-10T23:03:29.305+0000",
                    "updated": "2021-03-10T23:03:29.305+0000",
                    "started": "2021-03-10T23:03:29.305+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "564129",
                    "issueId": "13362714"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/565242",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643#discussion_r593081103\n\n\n\n##########\nFile path: cpp/src/arrow/csv/reader.cc\n##########\n@@ -805,7 +798,7 @@ class SerialTableReader : public BaseTableReader {\n                                                           std::move(first_buffer));\n     while (true) {\n       ARROW_ASSIGN_OR_RAISE(auto maybe_block, block_iterator.Next());\n-      if (maybe_block == IterationTraits<CSVBlock>::End()) {\n+      if (IterationTraits<CSVBlock>::IsEnd(maybe_block)) {\n\nReview comment:\n       Added.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-12T10:49:13.389+0000",
                    "updated": "2021-03-12T10:49:13.389+0000",
                    "started": "2021-03-12T10:49:13.389+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "565242",
                    "issueId": "13362714"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/565243",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643#discussion_r593081442\n\n\n\n##########\nFile path: cpp/src/arrow/util/type_fwd.h\n##########\n@@ -17,14 +17,14 @@\n \n #pragma once\n \n+#include <functional>\n\nReview comment:\n       Done.\n\n##########\nFile path: cpp/src/arrow/util/type_fwd.h\n##########\n@@ -17,14 +17,14 @@\n \n #pragma once\n \n+#include <functional>\n+\n namespace arrow {\n \n namespace detail {\n struct Empty;\n-}  // namespace detail\n+}\n\nReview comment:\n       Done.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-12T10:49:57.421+0000",
                    "updated": "2021-03-12T10:49:57.421+0000",
                    "started": "2021-03-12T10:49:57.421+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "565243",
                    "issueId": "13362714"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/565244",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643#discussion_r593081752\n\n\n\n##########\nFile path: cpp/src/arrow/util/vector.h\n##########\n@@ -81,5 +84,53 @@ std::vector<T> FilterVector(std::vector<T> values, Predicate&& predicate) {\n   return values;\n }\n \n+/// \\brief Like MapVector, but where the function can fail.\n+template <typename Fn, typename From = internal::call_traits::argument_type<0, Fn>,\n+          typename To = typename internal::call_traits::return_type<Fn>::ValueType>\n+Result<std::vector<To>> MaybeMapVector(Fn map, const std::vector<From>& src) {\n\nReview comment:\n       Done.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-12T10:50:10.334+0000",
                    "updated": "2021-03-12T10:50:10.334+0000",
                    "started": "2021-03-12T10:50:10.334+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "565244",
                    "issueId": "13362714"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/worklog/565245",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9643:\nURL: https://github.com/apache/arrow/pull/9643#discussion_r593081844\n\n\n\n##########\nFile path: cpp/src/arrow/util/vector.h\n##########\n@@ -81,5 +84,53 @@ std::vector<T> FilterVector(std::vector<T> values, Predicate&& predicate) {\n   return values;\n }\n \n+/// \\brief Like MapVector, but where the function can fail.\n+template <typename Fn, typename From = internal::call_traits::argument_type<0, Fn>,\n+          typename To = typename internal::call_traits::return_type<Fn>::ValueType>\n+Result<std::vector<To>> MaybeMapVector(Fn map, const std::vector<From>& src) {\n+  std::vector<To> out;\n+  out.reserve(src.size());\n+  ARROW_RETURN_NOT_OK(\n+      MaybeTransform(src.begin(), src.end(), std::back_inserter(out), map));\n+  return out;\n+}\n+\n+template <typename Fn, typename From = internal::call_traits::argument_type<0, Fn>,\n+          typename To = typename internal::call_traits::return_type<Fn>>\n+std::vector<To> MapVector(Fn map, const std::vector<From>& source) {\n\nReview comment:\n       Done.\n\n##########\nFile path: cpp/src/arrow/util/vector.h\n##########\n@@ -81,5 +84,53 @@ std::vector<T> FilterVector(std::vector<T> values, Predicate&& predicate) {\n   return values;\n }\n \n+/// \\brief Like MapVector, but where the function can fail.\n+template <typename Fn, typename From = internal::call_traits::argument_type<0, Fn>,\n+          typename To = typename internal::call_traits::return_type<Fn>::ValueType>\n+Result<std::vector<To>> MaybeMapVector(Fn map, const std::vector<From>& src) {\n+  std::vector<To> out;\n+  out.reserve(src.size());\n+  ARROW_RETURN_NOT_OK(\n+      MaybeTransform(src.begin(), src.end(), std::back_inserter(out), map));\n+  return out;\n+}\n+\n+template <typename Fn, typename From = internal::call_traits::argument_type<0, Fn>,\n+          typename To = typename internal::call_traits::return_type<Fn>>\n+std::vector<To> MapVector(Fn map, const std::vector<From>& source) {\n+  std::vector<To> out;\n+  out.reserve(source.size());\n+  std::transform(source.begin(), source.end(), std::back_inserter(out), map);\n+  return out;\n+}\n+\n+template <typename T>\n+std::vector<T> FlattenVectors(const std::vector<std::vector<T>> vecs) {\n\nReview comment:\n       Done.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-12T10:50:33.292+0000",
                    "updated": "2021-03-12T10:50:33.292+0000",
                    "started": "2021-03-12T10:50:33.291+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "565245",
                    "issueId": "13362714"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 36600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@acc3c53[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@615dc17f[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@199b913c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@16c2fd49[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@25853e2e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@27f54d1b[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@62222aa8[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@630bab10[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6f738d11[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@62639871[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@11e789ff[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@2f0ae3f8[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 36600,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Mar 24 11:49:36 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-03-24T11:49:36.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11883/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-03-05T22:05:20.000+0000",
        "updated": "2021-03-24T11:49:40.000+0000",
        "timeoriginalestimate": null,
        "description": "These are all needed for the current ARROW-7001 work.\u00a0 I'm breaking them out on their own so they can be reviewed in isolation.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "10h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 36600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Add ConcatMap, MergeMap, and an async-reentrant version of Map ",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13362714/comment/17307765",
                    "id": "17307765",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 9643\n[https://github.com/apache/arrow/pull/9643]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-03-24T11:49:36.560+0000",
                    "updated": "2021-03-24T11:49:36.560+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0oczs:",
        "customfield_12314139": null
    }
}