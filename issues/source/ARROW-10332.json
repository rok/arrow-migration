{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13335855",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335855",
    "key": "ARROW-10332",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
            "name": "jorgecarleitao",
            "key": "jorgecarleitao",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
            },
            "displayName": "Jorge Leit\u00e3o",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
            "name": "jorgecarleitao",
            "key": "jorgecarleitao",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
            },
            "displayName": "Jorge Leit\u00e3o",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
            "name": "jorgecarleitao",
            "key": "jorgecarleitao",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
            },
            "displayName": "Jorge Leit\u00e3o",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 6000,
            "total": 6000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 6000,
            "total": 6000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10332/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 10,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335855/worklog/501744",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao opened a new pull request #8482:\nURL: https://github.com/apache/arrow/pull/8482\n\n\n   This PR proposes the following changes:\r\n   \r\n   1. Make the CSV reader accept an optional argument to bound its iteration\r\n   2. Simplify the `next` code via iterators\r\n   3. Add a new struct to perform buffered iterations (useful to any reader)\r\n   \r\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-17T08:24:26.844+0000",
                    "updated": "2020-10-17T08:24:26.844+0000",
                    "started": "2020-10-17T08:24:26.843+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501744",
                    "issueId": "13335855"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335855/worklog/501745",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8482:\nURL: https://github.com/apache/arrow/pull/8482#issuecomment-710775116\n\n\n   https://issues.apache.org/jira/browse/ARROW-10332\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-17T08:29:34.599+0000",
                    "updated": "2020-10-17T08:29:34.599+0000",
                    "started": "2020-10-17T08:29:34.599+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501745",
                    "issueId": "13335855"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335855/worklog/501802",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8482:\nURL: https://github.com/apache/arrow/pull/8482#discussion_r506960675\n\n\n\n##########\nFile path: rust/arrow/src/csv/reader.rs\n##########\n@@ -304,162 +311,180 @@ impl<R: Read> Reader<R> {\n \n         let csv_reader = reader_builder.from_reader(buf_reader);\n         let record_iter = csv_reader.into_records();\n+\n+        let (start, end) = match bounds {\n+            None => (0, usize::MAX),\n+            Some((start, end)) => (start, end),\n+        };\n+        // Create an iterator that:\n+        // * skips the first `start` items\n+        // * runs up to `end` items\n+        // * buffers `batch_size` items\n+        // note that this skips by iteration. This is because in general it is not possible\n+        // to seek in CSV. However, skiping still saves the burden of creating arrow arrays,\n+        // which is a slow operation that scales with the number of columns\n+        let record_iter = Buffered::new(record_iter.skip(start).take(end), batch_size);\n+\n         Self {\n             schema,\n             projection,\n             record_iter,\n-            batch_size,\n-            line_number: if has_header { 1 } else { 0 },\n+            line_number: if has_header { start + 1 } else { start + 0 },\n         }\n     }\n-\n-    fn parse(&self, rows: &[StringRecord]) -> Result<RecordBatch> {\n-        let projection: Vec<usize> = match self.projection {\n-            Some(ref v) => v.clone(),\n-            None => self\n-                .schema\n-                .fields()\n-                .iter()\n-                .enumerate()\n-                .map(|(i, _)| i)\n-                .collect(),\n-        };\n-\n-        let arrays: Result<Vec<ArrayRef>> = projection\n-            .iter()\n-            .map(|i| {\n-                let i = *i;\n-                let field = self.schema.field(i);\n-                match field.data_type() {\n-                    &DataType::Boolean => {\n-                        self.build_primitive_array::<BooleanType>(rows, i)\n-                    }\n-                    &DataType::Int8 => self.build_primitive_array::<Int8Type>(rows, i),\n-                    &DataType::Int16 => self.build_primitive_array::<Int16Type>(rows, i),\n-                    &DataType::Int32 => self.build_primitive_array::<Int32Type>(rows, i),\n-                    &DataType::Int64 => self.build_primitive_array::<Int64Type>(rows, i),\n-                    &DataType::UInt8 => self.build_primitive_array::<UInt8Type>(rows, i),\n-                    &DataType::UInt16 => {\n-                        self.build_primitive_array::<UInt16Type>(rows, i)\n-                    }\n-                    &DataType::UInt32 => {\n-                        self.build_primitive_array::<UInt32Type>(rows, i)\n-                    }\n-                    &DataType::UInt64 => {\n-                        self.build_primitive_array::<UInt64Type>(rows, i)\n-                    }\n-                    &DataType::Float32 => {\n-                        self.build_primitive_array::<Float32Type>(rows, i)\n-                    }\n-                    &DataType::Float64 => {\n-                        self.build_primitive_array::<Float64Type>(rows, i)\n-                    }\n-                    &DataType::Utf8 => {\n-                        let mut builder = StringBuilder::new(rows.len());\n-                        for row in rows.iter() {\n-                            match row.get(i) {\n-                                Some(s) => builder.append_value(s).unwrap(),\n-                                _ => builder.append(false).unwrap(),\n-                            }\n-                        }\n-                        Ok(Arc::new(builder.finish()) as ArrayRef)\n-                    }\n-                    other => Err(ArrowError::ParseError(format!(\n-                        \"Unsupported data type {:?}\",\n-                        other\n-                    ))),\n-                }\n-            })\n-            .collect();\n-\n-        let schema_fields = self.schema.fields();\n-\n-        let projected_fields: Vec<Field> = projection\n-            .iter()\n-            .map(|i| schema_fields[*i].clone())\n-            .collect();\n-\n-        let projected_schema = Arc::new(Schema::new(projected_fields));\n-\n-        arrays.and_then(|arr| RecordBatch::try_new(projected_schema, arr))\n-    }\n-\n-    fn build_primitive_array<T: ArrowPrimitiveType>(\n-        &self,\n-        rows: &[StringRecord],\n-        col_idx: usize,\n-    ) -> Result<ArrayRef> {\n-        let is_boolean_type =\n-            *self.schema.field(col_idx).data_type() == DataType::Boolean;\n-\n-        rows.iter()\n-            .enumerate()\n-            .map(|(row_index, row)| {\n-                match row.get(col_idx) {\n-                    Some(s) => {\n-                        if s.is_empty() {\n-                            return Ok(None);\n-                        }\n-                        let parsed = if is_boolean_type {\n-                            s.to_lowercase().parse::<T::Native>()\n-                        } else {\n-                            s.parse::<T::Native>()\n-                        };\n-                        match parsed {\n-                            Ok(e) => Ok(Some(e)),\n-                            Err(_) => Err(ArrowError::ParseError(format!(\n-                                // TODO: we should surface the underlying error here.\n-                                \"Error while parsing value {} for column {} at line {}\",\n-                                s,\n-                                col_idx,\n-                                self.line_number + row_index\n-                            ))),\n-                        }\n-                    }\n-                    None => Ok(None),\n-                }\n-            })\n-            .collect::<Result<PrimitiveArray<T>>>()\n-            .map(|e| Arc::new(e) as ArrayRef)\n-    }\n }\n \n impl<R: Read> Iterator for Reader<R> {\n     type Item = Result<RecordBatch>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        // read a batch of rows into memory\n-        let mut rows: Vec<StringRecord> = Vec::with_capacity(self.batch_size);\n-        for i in 0..self.batch_size {\n-            match self.record_iter.next() {\n-                Some(Ok(r)) => {\n-                    rows.push(r);\n-                }\n-                Some(Err(e)) => {\n-                    return Some(Err(ArrowError::ParseError(format!(\n-                        \"Error parsing line {}: {:?}\",\n-                        self.line_number + i,\n-                        e\n-                    ))));\n-                }\n-                None => break,\n+        let rows = match self.record_iter.next() {\n+            Some(Ok(r)) => r,\n+            Some(Err(e)) => {\n+                return Some(Err(ArrowError::ParseError(format!(\n+                    \"Error parsing line {}: {:?}\",\n+                    self.line_number + self.record_iter.n(),\n+                    e\n+                ))));\n             }\n-        }\n+            None => return None,\n+        };\n \n         // return early if no data was loaded\n         if rows.is_empty() {\n             return None;\n         }\n \n         // parse the batches into a RecordBatch\n-        let result = self.parse(&rows);\n+        let result = parse(\n+            &rows,\n+            &self.schema.fields(),\n+            &self.projection,\n+            self.line_number,\n+        );\n \n         self.line_number += rows.len();\n \n         Some(result)\n     }\n }\n \n+/// parses a slice of [csv_crate::StringRecord] into a RecordBatch.\n+pub fn parse(\n\nReview comment:\n       Does this need to be public?\n\n##########\nFile path: rust/arrow/src/csv/reader.rs\n##########\n@@ -620,8 +645,15 @@ mod tests {\n \n         let file = File::open(\"test/data/uk_cities.csv\").unwrap();\n \n-        let mut csv =\n-            Reader::new(file, Arc::new(schema.clone()), false, None, 1024, None);\n+        let mut csv = Reader::new(\n\nReview comment:\n       I can't see where you test the bounds\n\n##########\nFile path: rust/arrow/src/csv/reader.rs\n##########\n@@ -483,6 +508,8 @@ pub struct ReaderBuilder {\n     ///\n     /// The default batch size when using the `ReaderBuilder` is 1024 records\n     batch_size: usize,\n+    ///\n\nReview comment:\n       doc\n\n##########\nFile path: rust/arrow/src/util/buffered_iterator.rs\n##########\n@@ -0,0 +1,138 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! [Buffered] is an iterator useful to build an [arrow::array::Array] and other\n+//! containers that benefit from batching or chunking.\n+\n+use std::marker::PhantomData;\n+\n+/// An iterator that buffers results in a vector so that the iterator returns a vector of `size` items.\n+/// The items must be a [std::result::Result] and if an error is returned, tha error is returned\n+/// and the iterator continues.\n+/// An invariant of this iterator is that every returned vector's size is at most the specified size.\n+#[derive(Debug)]\n+pub struct Buffered<I, T, R>\n+where\n+    T: Clone,\n+    I: Iterator<Item = Result<T, R>>,\n+{\n+    iter: I,\n+    size: usize,\n+    buffer: Vec<T>,\n+    phantom: PhantomData<R>,\n+}\n+\n+impl<I, T, R> Buffered<I, T, R>\n+where\n+    T: Clone,\n+    I: Iterator<Item = Result<T, R>>,\n+{\n+    pub fn new(iter: I, size: usize) -> Self {\n+        Buffered {\n+            iter,\n+            size,\n+            buffer: Vec::with_capacity(size),\n+            phantom: PhantomData,\n+        }\n+    }\n+\n+    /// returns the number of items buffered so far.\n+    /// Useful to extract the exact item where an error occurred\n+    #[inline]\n+    pub fn n(&self) -> usize {\n+        return self.buffer.len();\n+    }\n+}\n+\n+impl<I, T, R> Iterator for Buffered<I, T, R>\n+where\n+    T: Clone,\n+    I: Iterator<Item = Result<T, R>>,\n+{\n+    type Item = Result<Vec<T>, R>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        for _ in 0..(self.size - self.n()) {\n+            match self.iter.next() {\n+                Some(Ok(item)) => self.buffer.push(item),\n+                Some(Err(error)) => return Some(Err(error)),\n+                None => break,\n+            }\n+        }\n+        if self.buffer.is_empty() {\n+            None\n+        } else {\n+            let result = self.buffer.clone();\n+            self.buffer.clear();\n+            Some(Ok(result))\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[derive(Debug, PartialEq)]\n+    struct AError {}\n+\n+    impl std::fmt::Display for AError {\n+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+            write!(f, \"Bla\")\n+        }\n+    }\n+    impl std::error::Error for AError {}\n+\n+    #[test]\n+    fn test_basic() {\n+        let a: Vec<Result<i32, AError>> = vec![Ok(1), Ok(2), Ok(3)];\n+        let iter = a.into_iter();\n+        let mut iter = Buffered::new(iter, 2);\n+\n+        assert_eq!(iter.next(), Some(Ok(vec![1, 2])));\n+        assert_eq!(iter.next(), Some(Ok(vec![3])));\n+        assert_eq!(iter.next(), None);\n+    }\n+\n+    #[test]\n+    fn test_error_first() {\n+        let a: Vec<Result<i32, AError>> =\n+            vec![Ok(1), Ok(2), Err(AError {}), Ok(4), Ok(5)];\n+        let iter = a.into_iter();\n+        let mut iter = Buffered::new(iter, 2);\n+\n+        assert_eq!(iter.next(), Some(Ok(vec![1, 2])));\n+        assert_eq!(iter.next(), Some(Err(AError {})));\n\nReview comment:\n       Are we skipping errors to allow users to read files that have either corrupted records or non-UTF8 data in some columns? I've come across the irritating situation where Spark fails because a name column in a CSV contains non-UTF8 characters.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-17T16:51:29.510+0000",
                    "updated": "2020-10-17T16:51:29.510+0000",
                    "started": "2020-10-17T16:51:29.509+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501802",
                    "issueId": "13335855"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335855/worklog/501905",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8482:\nURL: https://github.com/apache/arrow/pull/8482#discussion_r507177994\n\n\n\n##########\nFile path: rust/arrow/src/util/buffered_iterator.rs\n##########\n@@ -0,0 +1,138 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! [Buffered] is an iterator useful to build an [arrow::array::Array] and other\n+//! containers that benefit from batching or chunking.\n+\n+use std::marker::PhantomData;\n+\n+/// An iterator that buffers results in a vector so that the iterator returns a vector of `size` items.\n+/// The items must be a [std::result::Result] and if an error is returned, tha error is returned\n+/// and the iterator continues.\n+/// An invariant of this iterator is that every returned vector's size is at most the specified size.\n+#[derive(Debug)]\n+pub struct Buffered<I, T, R>\n+where\n+    T: Clone,\n+    I: Iterator<Item = Result<T, R>>,\n+{\n+    iter: I,\n+    size: usize,\n+    buffer: Vec<T>,\n+    phantom: PhantomData<R>,\n+}\n+\n+impl<I, T, R> Buffered<I, T, R>\n+where\n+    T: Clone,\n+    I: Iterator<Item = Result<T, R>>,\n+{\n+    pub fn new(iter: I, size: usize) -> Self {\n+        Buffered {\n+            iter,\n+            size,\n+            buffer: Vec::with_capacity(size),\n+            phantom: PhantomData,\n+        }\n+    }\n+\n+    /// returns the number of items buffered so far.\n+    /// Useful to extract the exact item where an error occurred\n+    #[inline]\n+    pub fn n(&self) -> usize {\n+        return self.buffer.len();\n+    }\n+}\n+\n+impl<I, T, R> Iterator for Buffered<I, T, R>\n+where\n+    T: Clone,\n+    I: Iterator<Item = Result<T, R>>,\n+{\n+    type Item = Result<Vec<T>, R>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        for _ in 0..(self.size - self.n()) {\n+            match self.iter.next() {\n+                Some(Ok(item)) => self.buffer.push(item),\n+                Some(Err(error)) => return Some(Err(error)),\n+                None => break,\n+            }\n+        }\n+        if self.buffer.is_empty() {\n+            None\n+        } else {\n+            let result = self.buffer.clone();\n+            self.buffer.clear();\n+            Some(Ok(result))\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[derive(Debug, PartialEq)]\n+    struct AError {}\n+\n+    impl std::fmt::Display for AError {\n+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+            write!(f, \"Bla\")\n+        }\n+    }\n+    impl std::error::Error for AError {}\n+\n+    #[test]\n+    fn test_basic() {\n+        let a: Vec<Result<i32, AError>> = vec![Ok(1), Ok(2), Ok(3)];\n+        let iter = a.into_iter();\n+        let mut iter = Buffered::new(iter, 2);\n+\n+        assert_eq!(iter.next(), Some(Ok(vec![1, 2])));\n+        assert_eq!(iter.next(), Some(Ok(vec![3])));\n+        assert_eq!(iter.next(), None);\n+    }\n+\n+    #[test]\n+    fn test_error_first() {\n+        let a: Vec<Result<i32, AError>> =\n+            vec![Ok(1), Ok(2), Err(AError {}), Ok(4), Ok(5)];\n+        let iter = a.into_iter();\n+        let mut iter = Buffered::new(iter, 2);\n+\n+        assert_eq!(iter.next(), Some(Ok(vec![1, 2])));\n+        assert_eq!(iter.next(), Some(Err(AError {})));\n\nReview comment:\n       The iterator returns the error and continues, but I am not sure what happens during schema inference, or how the column names affect schema inference.\r\n   \r\n   One thing I do not like atm is that we error the whole batch if we can't parse/cast an entry. IMO we should place `null` if we can't cast/parse a value.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-18T15:40:32.577+0000",
                    "updated": "2020-10-18T15:40:32.577+0000",
                    "started": "2020-10-18T15:40:32.576+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501905",
                    "issueId": "13335855"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335855/worklog/501906",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8482:\nURL: https://github.com/apache/arrow/pull/8482#discussion_r507177994\n\n\n\n##########\nFile path: rust/arrow/src/util/buffered_iterator.rs\n##########\n@@ -0,0 +1,138 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! [Buffered] is an iterator useful to build an [arrow::array::Array] and other\n+//! containers that benefit from batching or chunking.\n+\n+use std::marker::PhantomData;\n+\n+/// An iterator that buffers results in a vector so that the iterator returns a vector of `size` items.\n+/// The items must be a [std::result::Result] and if an error is returned, tha error is returned\n+/// and the iterator continues.\n+/// An invariant of this iterator is that every returned vector's size is at most the specified size.\n+#[derive(Debug)]\n+pub struct Buffered<I, T, R>\n+where\n+    T: Clone,\n+    I: Iterator<Item = Result<T, R>>,\n+{\n+    iter: I,\n+    size: usize,\n+    buffer: Vec<T>,\n+    phantom: PhantomData<R>,\n+}\n+\n+impl<I, T, R> Buffered<I, T, R>\n+where\n+    T: Clone,\n+    I: Iterator<Item = Result<T, R>>,\n+{\n+    pub fn new(iter: I, size: usize) -> Self {\n+        Buffered {\n+            iter,\n+            size,\n+            buffer: Vec::with_capacity(size),\n+            phantom: PhantomData,\n+        }\n+    }\n+\n+    /// returns the number of items buffered so far.\n+    /// Useful to extract the exact item where an error occurred\n+    #[inline]\n+    pub fn n(&self) -> usize {\n+        return self.buffer.len();\n+    }\n+}\n+\n+impl<I, T, R> Iterator for Buffered<I, T, R>\n+where\n+    T: Clone,\n+    I: Iterator<Item = Result<T, R>>,\n+{\n+    type Item = Result<Vec<T>, R>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        for _ in 0..(self.size - self.n()) {\n+            match self.iter.next() {\n+                Some(Ok(item)) => self.buffer.push(item),\n+                Some(Err(error)) => return Some(Err(error)),\n+                None => break,\n+            }\n+        }\n+        if self.buffer.is_empty() {\n+            None\n+        } else {\n+            let result = self.buffer.clone();\n+            self.buffer.clear();\n+            Some(Ok(result))\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[derive(Debug, PartialEq)]\n+    struct AError {}\n+\n+    impl std::fmt::Display for AError {\n+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+            write!(f, \"Bla\")\n+        }\n+    }\n+    impl std::error::Error for AError {}\n+\n+    #[test]\n+    fn test_basic() {\n+        let a: Vec<Result<i32, AError>> = vec![Ok(1), Ok(2), Ok(3)];\n+        let iter = a.into_iter();\n+        let mut iter = Buffered::new(iter, 2);\n+\n+        assert_eq!(iter.next(), Some(Ok(vec![1, 2])));\n+        assert_eq!(iter.next(), Some(Ok(vec![3])));\n+        assert_eq!(iter.next(), None);\n+    }\n+\n+    #[test]\n+    fn test_error_first() {\n+        let a: Vec<Result<i32, AError>> =\n+            vec![Ok(1), Ok(2), Err(AError {}), Ok(4), Ok(5)];\n+        let iter = a.into_iter();\n+        let mut iter = Buffered::new(iter, 2);\n+\n+        assert_eq!(iter.next(), Some(Ok(vec![1, 2])));\n+        assert_eq!(iter.next(), Some(Err(AError {})));\n\nReview comment:\n       The iterator returns the error and continues, but I am not sure what happens during schema inference, or how the column names affect schema inference.\r\n   \r\n   One thing I do not like atm is that we error the whole batch if we can't parse/cast an entry to a type. IMO we should `null` the value and continue.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-18T15:41:05.802+0000",
                    "updated": "2020-10-18T15:41:05.802+0000",
                    "started": "2020-10-18T15:41:05.802+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501906",
                    "issueId": "13335855"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335855/worklog/501907",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8482:\nURL: https://github.com/apache/arrow/pull/8482#discussion_r507178148\n\n\n\n##########\nFile path: rust/arrow/src/csv/reader.rs\n##########\n@@ -304,162 +311,180 @@ impl<R: Read> Reader<R> {\n \n         let csv_reader = reader_builder.from_reader(buf_reader);\n         let record_iter = csv_reader.into_records();\n+\n+        let (start, end) = match bounds {\n+            None => (0, usize::MAX),\n+            Some((start, end)) => (start, end),\n+        };\n+        // Create an iterator that:\n+        // * skips the first `start` items\n+        // * runs up to `end` items\n+        // * buffers `batch_size` items\n+        // note that this skips by iteration. This is because in general it is not possible\n+        // to seek in CSV. However, skiping still saves the burden of creating arrow arrays,\n+        // which is a slow operation that scales with the number of columns\n+        let record_iter = Buffered::new(record_iter.skip(start).take(end), batch_size);\n+\n         Self {\n             schema,\n             projection,\n             record_iter,\n-            batch_size,\n-            line_number: if has_header { 1 } else { 0 },\n+            line_number: if has_header { start + 1 } else { start + 0 },\n         }\n     }\n-\n-    fn parse(&self, rows: &[StringRecord]) -> Result<RecordBatch> {\n-        let projection: Vec<usize> = match self.projection {\n-            Some(ref v) => v.clone(),\n-            None => self\n-                .schema\n-                .fields()\n-                .iter()\n-                .enumerate()\n-                .map(|(i, _)| i)\n-                .collect(),\n-        };\n-\n-        let arrays: Result<Vec<ArrayRef>> = projection\n-            .iter()\n-            .map(|i| {\n-                let i = *i;\n-                let field = self.schema.field(i);\n-                match field.data_type() {\n-                    &DataType::Boolean => {\n-                        self.build_primitive_array::<BooleanType>(rows, i)\n-                    }\n-                    &DataType::Int8 => self.build_primitive_array::<Int8Type>(rows, i),\n-                    &DataType::Int16 => self.build_primitive_array::<Int16Type>(rows, i),\n-                    &DataType::Int32 => self.build_primitive_array::<Int32Type>(rows, i),\n-                    &DataType::Int64 => self.build_primitive_array::<Int64Type>(rows, i),\n-                    &DataType::UInt8 => self.build_primitive_array::<UInt8Type>(rows, i),\n-                    &DataType::UInt16 => {\n-                        self.build_primitive_array::<UInt16Type>(rows, i)\n-                    }\n-                    &DataType::UInt32 => {\n-                        self.build_primitive_array::<UInt32Type>(rows, i)\n-                    }\n-                    &DataType::UInt64 => {\n-                        self.build_primitive_array::<UInt64Type>(rows, i)\n-                    }\n-                    &DataType::Float32 => {\n-                        self.build_primitive_array::<Float32Type>(rows, i)\n-                    }\n-                    &DataType::Float64 => {\n-                        self.build_primitive_array::<Float64Type>(rows, i)\n-                    }\n-                    &DataType::Utf8 => {\n-                        let mut builder = StringBuilder::new(rows.len());\n-                        for row in rows.iter() {\n-                            match row.get(i) {\n-                                Some(s) => builder.append_value(s).unwrap(),\n-                                _ => builder.append(false).unwrap(),\n-                            }\n-                        }\n-                        Ok(Arc::new(builder.finish()) as ArrayRef)\n-                    }\n-                    other => Err(ArrowError::ParseError(format!(\n-                        \"Unsupported data type {:?}\",\n-                        other\n-                    ))),\n-                }\n-            })\n-            .collect();\n-\n-        let schema_fields = self.schema.fields();\n-\n-        let projected_fields: Vec<Field> = projection\n-            .iter()\n-            .map(|i| schema_fields[*i].clone())\n-            .collect();\n-\n-        let projected_schema = Arc::new(Schema::new(projected_fields));\n-\n-        arrays.and_then(|arr| RecordBatch::try_new(projected_schema, arr))\n-    }\n-\n-    fn build_primitive_array<T: ArrowPrimitiveType>(\n-        &self,\n-        rows: &[StringRecord],\n-        col_idx: usize,\n-    ) -> Result<ArrayRef> {\n-        let is_boolean_type =\n-            *self.schema.field(col_idx).data_type() == DataType::Boolean;\n-\n-        rows.iter()\n-            .enumerate()\n-            .map(|(row_index, row)| {\n-                match row.get(col_idx) {\n-                    Some(s) => {\n-                        if s.is_empty() {\n-                            return Ok(None);\n-                        }\n-                        let parsed = if is_boolean_type {\n-                            s.to_lowercase().parse::<T::Native>()\n-                        } else {\n-                            s.parse::<T::Native>()\n-                        };\n-                        match parsed {\n-                            Ok(e) => Ok(Some(e)),\n-                            Err(_) => Err(ArrowError::ParseError(format!(\n-                                // TODO: we should surface the underlying error here.\n-                                \"Error while parsing value {} for column {} at line {}\",\n-                                s,\n-                                col_idx,\n-                                self.line_number + row_index\n-                            ))),\n-                        }\n-                    }\n-                    None => Ok(None),\n-                }\n-            })\n-            .collect::<Result<PrimitiveArray<T>>>()\n-            .map(|e| Arc::new(e) as ArrayRef)\n-    }\n }\n \n impl<R: Read> Iterator for Reader<R> {\n     type Item = Result<RecordBatch>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        // read a batch of rows into memory\n-        let mut rows: Vec<StringRecord> = Vec::with_capacity(self.batch_size);\n-        for i in 0..self.batch_size {\n-            match self.record_iter.next() {\n-                Some(Ok(r)) => {\n-                    rows.push(r);\n-                }\n-                Some(Err(e)) => {\n-                    return Some(Err(ArrowError::ParseError(format!(\n-                        \"Error parsing line {}: {:?}\",\n-                        self.line_number + i,\n-                        e\n-                    ))));\n-                }\n-                None => break,\n+        let rows = match self.record_iter.next() {\n+            Some(Ok(r)) => r,\n+            Some(Err(e)) => {\n+                return Some(Err(ArrowError::ParseError(format!(\n+                    \"Error parsing line {}: {:?}\",\n+                    self.line_number + self.record_iter.n(),\n+                    e\n+                ))));\n             }\n-        }\n+            None => return None,\n+        };\n \n         // return early if no data was loaded\n         if rows.is_empty() {\n             return None;\n         }\n \n         // parse the batches into a RecordBatch\n-        let result = self.parse(&rows);\n+        let result = parse(\n+            &rows,\n+            &self.schema.fields(),\n+            &self.projection,\n+            self.line_number,\n+        );\n \n         self.line_number += rows.len();\n \n         Some(result)\n     }\n }\n \n+/// parses a slice of [csv_crate::StringRecord] into a RecordBatch.\n+pub fn parse(\n\nReview comment:\n       Good catch. I reverted this.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-18T15:42:09.439+0000",
                    "updated": "2020-10-18T15:42:09.439+0000",
                    "started": "2020-10-18T15:42:09.439+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501907",
                    "issueId": "13335855"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335855/worklog/501908",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8482:\nURL: https://github.com/apache/arrow/pull/8482#discussion_r507178185\n\n\n\n##########\nFile path: rust/arrow/src/csv/reader.rs\n##########\n@@ -620,8 +645,15 @@ mod tests {\n \n         let file = File::open(\"test/data/uk_cities.csv\").unwrap();\n \n-        let mut csv =\n-            Reader::new(file, Arc::new(schema.clone()), false, None, 1024, None);\n+        let mut csv = Reader::new(\n\nReview comment:\n       I've added a test.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-18T15:42:32.496+0000",
                    "updated": "2020-10-18T15:42:32.496+0000",
                    "started": "2020-10-18T15:42:32.496+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501908",
                    "issueId": "13335855"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335855/worklog/501918",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8482:\nURL: https://github.com/apache/arrow/pull/8482#discussion_r507200840\n\n\n\n##########\nFile path: rust/arrow/src/util/buffered_iterator.rs\n##########\n@@ -0,0 +1,138 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! [Buffered] is an iterator useful to build an [arrow::array::Array] and other\n+//! containers that benefit from batching or chunking.\n+\n+use std::marker::PhantomData;\n+\n+/// An iterator that buffers results in a vector so that the iterator returns a vector of `size` items.\n+/// The items must be a [std::result::Result] and if an error is returned, tha error is returned\n+/// and the iterator continues.\n+/// An invariant of this iterator is that every returned vector's size is at most the specified size.\n+#[derive(Debug)]\n+pub struct Buffered<I, T, R>\n+where\n+    T: Clone,\n+    I: Iterator<Item = Result<T, R>>,\n+{\n+    iter: I,\n+    size: usize,\n+    buffer: Vec<T>,\n+    phantom: PhantomData<R>,\n+}\n+\n+impl<I, T, R> Buffered<I, T, R>\n+where\n+    T: Clone,\n+    I: Iterator<Item = Result<T, R>>,\n+{\n+    pub fn new(iter: I, size: usize) -> Self {\n+        Buffered {\n+            iter,\n+            size,\n+            buffer: Vec::with_capacity(size),\n+            phantom: PhantomData,\n+        }\n+    }\n+\n+    /// returns the number of items buffered so far.\n+    /// Useful to extract the exact item where an error occurred\n+    #[inline]\n+    pub fn n(&self) -> usize {\n+        return self.buffer.len();\n+    }\n+}\n+\n+impl<I, T, R> Iterator for Buffered<I, T, R>\n+where\n+    T: Clone,\n+    I: Iterator<Item = Result<T, R>>,\n+{\n+    type Item = Result<Vec<T>, R>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        for _ in 0..(self.size - self.n()) {\n+            match self.iter.next() {\n+                Some(Ok(item)) => self.buffer.push(item),\n+                Some(Err(error)) => return Some(Err(error)),\n+                None => break,\n+            }\n+        }\n+        if self.buffer.is_empty() {\n+            None\n+        } else {\n+            let result = self.buffer.clone();\n+            self.buffer.clear();\n+            Some(Ok(result))\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[derive(Debug, PartialEq)]\n+    struct AError {}\n+\n+    impl std::fmt::Display for AError {\n+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+            write!(f, \"Bla\")\n+        }\n+    }\n+    impl std::error::Error for AError {}\n+\n+    #[test]\n+    fn test_basic() {\n+        let a: Vec<Result<i32, AError>> = vec![Ok(1), Ok(2), Ok(3)];\n+        let iter = a.into_iter();\n+        let mut iter = Buffered::new(iter, 2);\n+\n+        assert_eq!(iter.next(), Some(Ok(vec![1, 2])));\n+        assert_eq!(iter.next(), Some(Ok(vec![3])));\n+        assert_eq!(iter.next(), None);\n+    }\n+\n+    #[test]\n+    fn test_error_first() {\n+        let a: Vec<Result<i32, AError>> =\n+            vec![Ok(1), Ok(2), Err(AError {}), Ok(4), Ok(5)];\n+        let iter = a.into_iter();\n+        let mut iter = Buffered::new(iter, 2);\n+\n+        assert_eq!(iter.next(), Some(Ok(vec![1, 2])));\n+        assert_eq!(iter.next(), Some(Err(AError {})));\n\nReview comment:\n       It could be fine if we have some way of notifying the user (logging a warning?) that some records weren't parsed, so they're aware of the incompleteness.\r\n   \r\n   I'd like to hear the opinions of others, my opinion would be to make this a configurable option if possible.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-18T19:10:27.469+0000",
                    "updated": "2020-10-18T19:10:27.469+0000",
                    "started": "2020-10-18T19:10:27.468+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501918",
                    "issueId": "13335855"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335855/worklog/502313",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on a change in pull request #8482:\nURL: https://github.com/apache/arrow/pull/8482#discussion_r507863412\n\n\n\n##########\nFile path: rust/arrow/src/util/buffered_iterator.rs\n##########\n@@ -0,0 +1,138 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! [Buffered] is an iterator useful to build an [arrow::array::Array] and other\n+//! containers that benefit from batching or chunking.\n+\n+use std::marker::PhantomData;\n+\n+/// An iterator that buffers results in a vector so that the iterator returns a vector of `size` items.\n+/// The items must be a [std::result::Result] and if an error is returned, tha error is returned\n+/// and the iterator continues.\n+/// An invariant of this iterator is that every returned vector's size is at most the specified size.\n+#[derive(Debug)]\n+pub struct Buffered<I, T, R>\n+where\n+    T: Clone,\n+    I: Iterator<Item = Result<T, R>>,\n+{\n+    iter: I,\n+    size: usize,\n+    buffer: Vec<T>,\n+    phantom: PhantomData<R>,\n+}\n+\n+impl<I, T, R> Buffered<I, T, R>\n+where\n+    T: Clone,\n+    I: Iterator<Item = Result<T, R>>,\n+{\n+    pub fn new(iter: I, size: usize) -> Self {\n+        Buffered {\n+            iter,\n+            size,\n+            buffer: Vec::with_capacity(size),\n+            phantom: PhantomData,\n+        }\n+    }\n+\n+    /// returns the number of items buffered so far.\n+    /// Useful to extract the exact item where an error occurred\n+    #[inline]\n+    pub fn n(&self) -> usize {\n+        return self.buffer.len();\n+    }\n+}\n+\n+impl<I, T, R> Iterator for Buffered<I, T, R>\n+where\n+    T: Clone,\n+    I: Iterator<Item = Result<T, R>>,\n+{\n+    type Item = Result<Vec<T>, R>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        for _ in 0..(self.size - self.n()) {\n+            match self.iter.next() {\n+                Some(Ok(item)) => self.buffer.push(item),\n+                Some(Err(error)) => return Some(Err(error)),\n+                None => break,\n+            }\n+        }\n+        if self.buffer.is_empty() {\n+            None\n+        } else {\n+            let result = self.buffer.clone();\n+            self.buffer.clear();\n+            Some(Ok(result))\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[derive(Debug, PartialEq)]\n+    struct AError {}\n+\n+    impl std::fmt::Display for AError {\n+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+            write!(f, \"Bla\")\n+        }\n+    }\n+    impl std::error::Error for AError {}\n+\n+    #[test]\n+    fn test_basic() {\n+        let a: Vec<Result<i32, AError>> = vec![Ok(1), Ok(2), Ok(3)];\n+        let iter = a.into_iter();\n+        let mut iter = Buffered::new(iter, 2);\n+\n+        assert_eq!(iter.next(), Some(Ok(vec![1, 2])));\n+        assert_eq!(iter.next(), Some(Ok(vec![3])));\n+        assert_eq!(iter.next(), None);\n+    }\n+\n+    #[test]\n+    fn test_error_first() {\n+        let a: Vec<Result<i32, AError>> =\n+            vec![Ok(1), Ok(2), Err(AError {}), Ok(4), Ok(5)];\n+        let iter = a.into_iter();\n+        let mut iter = Buffered::new(iter, 2);\n+\n+        assert_eq!(iter.next(), Some(Ok(vec![1, 2])));\n+        assert_eq!(iter.next(), Some(Err(AError {})));\n\nReview comment:\n       It seems acceptable to me that errors can be ignored during schema inference since schema inference is a best-effort thing anyway, but I do think it would be good to log warnings in this case.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-19T15:51:18.484+0000",
                    "updated": "2020-10-19T15:51:18.484+0000",
                    "started": "2020-10-19T15:51:18.484+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "502313",
                    "issueId": "13335855"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335855/worklog/504596",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me closed pull request #8482:\nURL: https://github.com/apache/arrow/pull/8482\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-25T20:23:45.111+0000",
                    "updated": "2020-10-25T20:23:45.111+0000",
                    "started": "2020-10-25T20:23:45.110+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "504596",
                    "issueId": "13335855"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 6000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@5777cd71[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@24fc98c7[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@35870c66[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@75fd80b1[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1656bdca[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@581c8562[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5575463b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@4c94bc2c[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6f8fe099[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@53845f9f[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2c3f9f4a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@45a3333d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 6000,
        "customfield_12312520": null,
        "customfield_12312521": "Sun Oct 25 20:23:38 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-10-25T20:23:38.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10332/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-10-17T08:18:53.000+0000",
        "updated": "2020-10-25T20:23:46.000+0000",
        "timeoriginalestimate": null,
        "description": "Currently, the CSV reader always start from 0 and go until the end, which makes it impossible for DataFusion to split a single file in parts, e.g. via multiple readers.\r\n\r\nThe goal of this issue is to generalize the reader to support starting from an arbitrary location (via iterating), and also have an optional upper limit.\r\n\r\n\u00a0",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 6000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] Allow CSV reader to start from a line",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335855/comment/17220380",
                    "id": "17220380",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
                        "name": "nevi_me",
                        "key": "nevi_me",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
                        },
                        "displayName": "Neville Dipale",
                        "active": true,
                        "timeZone": "Africa/Johannesburg"
                    },
                    "body": "Issue resolved by pull request 8482\n[https://github.com/apache/arrow/pull/8482]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
                        "name": "nevi_me",
                        "key": "nevi_me",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
                        },
                        "displayName": "Neville Dipale",
                        "active": true,
                        "timeZone": "Africa/Johannesburg"
                    },
                    "created": "2020-10-25T20:23:38.122+0000",
                    "updated": "2020-10-25T20:23:38.122+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0jrv4:",
        "customfield_12314139": null
    }
}