{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13374797",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797",
    "key": "ARROW-12526",
    "fields": {
        "fixVersions": [],
        "resolution": null,
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
            "name": "Minor",
            "id": "4"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "1.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": null,
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
            "description": "The issue is open and ready for the assignee to start work on it.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
            "name": "Open",
            "id": "1",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                "id": 2,
                "key": "new",
                "colorName": "blue-gray",
                "name": "To Do"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328936",
                "id": "12328936",
                "name": "Python"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=alippai",
            "name": "alippai",
            "key": "alippai",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Adam Lippai",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=alippai",
            "name": "alippai",
            "key": "alippai",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Adam Lippai",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 10200,
            "total": 10200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 10200,
            "total": 10200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12526/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 17,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/worklog/769392",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "krcrouse opened a new pull request, #13126:\nURL: https://github.com/apache/arrow/pull/13126\n\n   This PR addresses both the JIRA issue cited (pre-generate pyarrow.compute) and also a dev thread that suggests creating the ability to add in python docs for functions that inherit from the Arrow C++ would greatly improve the readability for python users.\r\n   \r\n   There are still a few things to work out, such as where in the build process to generate the code and whether a version of the generated code should be checked into version control or not, but @pitrou suggested opening the PR to field comments from developers.  \r\n   \r\n   Major points:\r\n   \r\n   - creates `python/docs/additions` tree where the reStructrued text docs that include the sections to overwrite. Using raw reSt so that code block examples can be tested using doctest - see the README for more verbose details\r\n   - `pyarrow.docutils` (or maybe should be _docutils) provides functions to processes `python/docs/additions` and return a data structure of the components per function.\r\n   - `python/scripts/generate_sources.py` uses `pyarrow.docutils` and writes out the code for the compute functions in `pyarrow/generated/compute.py`. All of the logic from the release-branch `pyarrow.compute` module that dynamically generated the compute functions has been moved to this script.\r\n   - I didn't check the generated file into the repo because I generally do not include generated files that would be generated by the build process should be in source control, but I realize there are other perspectives on this\r\n   - `pyarrow.compute` now imports from `pyarrow.generated.compute` for all of the autogenerated compute bindings. Override and custom functions are still defined here.\r\n   - The old `pyarrow._compute_docstrings` is gone because its purpose is subsumed in the above.\r\n   - I've updated the tests so that they work with the above changes.  \r\n   \r\n   \n\n\n",
                    "created": "2022-05-12T02:36:43.570+0000",
                    "updated": "2022-05-12T02:36:43.570+0000",
                    "started": "2022-05-12T02:36:43.569+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "769392",
                    "issueId": "13374797"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/worklog/769393",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13126:\nURL: https://github.com/apache/arrow/pull/13126#issuecomment-1124470157\n\n   https://issues.apache.org/jira/browse/ARROW-12526\n\n\n",
                    "created": "2022-05-12T02:37:02.050+0000",
                    "updated": "2022-05-12T02:37:02.050+0000",
                    "started": "2022-05-12T02:37:02.049+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "769393",
                    "issueId": "13374797"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/worklog/769394",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13126:\nURL: https://github.com/apache/arrow/pull/13126#issuecomment-1124470167\n\n   :warning: Ticket **has not been started in JIRA**, please click 'Start Progress'.\n\n\n",
                    "created": "2022-05-12T02:37:04.077+0000",
                    "updated": "2022-05-12T02:37:04.077+0000",
                    "started": "2022-05-12T02:37:04.077+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "769394",
                    "issueId": "13374797"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/worklog/769396",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "krcrouse commented on PR #13126:\nURL: https://github.com/apache/arrow/pull/13126#issuecomment-1124471692\n\n   To save you all from having to check out the branch and generate the code, attached is what the `python/pyarrow/generated/compute.py` file looks like at present (added as a .txt file because github rejects .py)\r\n   [compute.py.txt](https://github.com/apache/arrow/files/8674631/compute.py.txt)\r\n   .\n\n\n",
                    "created": "2022-05-12T02:40:58.199+0000",
                    "updated": "2022-05-12T02:40:58.199+0000",
                    "started": "2022-05-12T02:40:58.199+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "769396",
                    "issueId": "13374797"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/worklog/788557",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on PR #13126:\nURL: https://github.com/apache/arrow/pull/13126#issuecomment-1177349457\n\n   @krcrouse Just a word to tell you that I hadn't a chance to take a look yet, but it's definitely on my TODO list (or may be switched to someone else's :-)). I hope the wait isn't too demotivating.\n\n\n",
                    "created": "2022-07-07T10:06:25.011+0000",
                    "updated": "2022-07-07T10:06:25.011+0000",
                    "started": "2022-07-07T10:06:25.011+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "788557",
                    "issueId": "13374797"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/worklog/788644",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on PR #13126:\nURL: https://github.com/apache/arrow/pull/13126#issuecomment-1177693668\n\n   @krcrouse thanks a lot for your work on this!\r\n   \r\n   I didn't yet look in detail, but some general comments:\r\n   \r\n   - I think we will probably want to commit the generated code to the repo (and in any case, doing that for now might also make it easier to review (although you already linked the file above as well)).\r\n   - Can you explain a bit more the need for `pyarrow.docutils`? (we should also make it a private module, or put in eg python/scripts or so?) \r\n     As far as I understand, by using the full ability of docutils, we can override _any_ section of the docstring (eg also overriding the `Parameters` section), instead of only _appending_ content to the docstring? (eg appending the example of notes section). \r\n     Do we think we will really need that full ability? Or it might in almost all cases be sufficient to just append content? (I think for all cases you currently have additions in this PR, appending would also be fine?) If appending is sufficient, that might keep the generation code simpler?\r\n   - > pyarrow.compute now imports from pyarrow.generated.compute\r\n   \r\n     Small nit: this doesn't need to be a public module, so maybe something like `_compute_generated.py` instead?\r\n   \r\n   - > Using raw reSt so that code block examples can be tested using doctest \r\n   \r\n     We now started to tests docstring examples in general in the meantime (see https://github.com/apache/arrow/pull/13199, https://github.com/apache/arrow/pull/13216, https://github.com/apache/arrow/pull/13325), so we can probably test those docstrings that way as well.\r\n   \n\n\n",
                    "created": "2022-07-07T14:21:08.559+0000",
                    "updated": "2022-07-07T14:21:08.559+0000",
                    "started": "2022-07-07T14:21:08.558+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "788644",
                    "issueId": "13374797"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/worklog/789354",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "krcrouse commented on PR #13126:\nURL: https://github.com/apache/arrow/pull/13126#issuecomment-1179888233\n\n   @jorisvandenbossche, I'll wait for some more guidance from you all and just respond to your comments inline for the moment. \r\n   \r\n   > * I think we will probably want to commit the generated code to the repo (and in any case, doing that for now might also make it easier to review (although you already linked the file above as well)).\r\n   \r\n   That makes sense and probably helps in the overall structure.\r\n   \r\n   > * Can you explain a bit more the need for `pyarrow.docutils`? \r\n   \r\n   docutils is used to process the reStructured text appendices so that they can be merged with the autogenerated docs. In this model, I propose using reSt for the function documentation additions because it's established, it's testable, and contributors will at least understand what it is even if they're not proficient in it.\r\n   \r\n   If your question is more about \"the need for it as a required module\" -  If we include the generated files then the `docutils` requirement only needs to be a build dependency in order to generate the actual code files. It does not need to be included as a requirement for the actual package for end users.\r\n   \r\n   > (we should also make it a private module, or put in eg python/scripts or so?)\r\n   \r\n   Agreed - it should be a private module.\r\n   \r\n   >   As far as I understand, by using the full ability of docutils, we can override _any_ section of the docstring ...\r\n   >   Do we think we will really need that full ability? Or it might in almost all cases be sufficient to just append content? \r\n   \r\n   I think we would want both options. Since the default documentation is pulling from the C++ library code, I think you could browse the current [generated documentation](https://arrow.apache.org/docs/python/api/compute.html) and see sections that are not useful and could be entirely overwritten. I also think the hybrid approach of creating default documentation with options to append and/or overwrite is best because it will pull in changes to the core C++ function interface automatically while preserving the manually provided improved pythonic documentation.\r\n   \r\n   Take, for example, the parameter definitions of [`replace_with_mask`](https://arrow.apache.org/docs/python/generated/pyarrow.compute.replace_with_mask.html#pyarrow.compute.replace_with_mask) - in the context of the still not terribly verbose description, the parameter types are incorrect and the explanation of each parameter is useless ('Argument to compute function.\"). I don't have the code in front of me at the moment, but having implemented this function in pyarrow 7.0, there are several oddities in how these parameters are handled that should be in the param descriptions and not merely as an appended paragraph at the bottom.  \r\n   \r\n   >   Small nit: this doesn't need to be a public module, so maybe something like `_compute_generated.py` instead?\r\n   > * > Using raw reSt so that code block examples can be tested using doctest\r\n   \r\n   Agreed.\r\n   \n\n\n",
                    "created": "2022-07-11T02:13:57.609+0000",
                    "updated": "2022-07-11T02:13:57.609+0000",
                    "started": "2022-07-11T02:13:57.609+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789354",
                    "issueId": "13374797"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/worklog/789547",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "amol- commented on code in PR #13126:\nURL: https://github.com/apache/arrow/pull/13126#discussion_r917935809\n\n\n##########\npython/scripts/generate_sources.py:\n##########\n@@ -0,0 +1,414 @@\n+import pyarrow as pa\n+from pyarrow import docutils as arrowdoc\n+from pyarrow.vendored import docscrape\n+\n+from pyarrow._compute import (  # noqa\n+    Function,\n+    FunctionOptions,\n+    FunctionRegistry,\n+    HashAggregateFunction,\n+    HashAggregateKernel,\n+    Kernel,\n+    ScalarAggregateFunction,\n+    ScalarAggregateKernel,\n+    ScalarFunction,\n+    ScalarKernel,\n+    VectorFunction,\n+    VectorKernel,\n+    # Option classes\n+    ArraySortOptions,\n+    AssumeTimezoneOptions,\n+    CastOptions,\n+    CountOptions,\n+    DayOfWeekOptions,\n+    DictionaryEncodeOptions,\n+    ElementWiseAggregateOptions,\n+    ExtractRegexOptions,\n+    FilterOptions,\n+    IndexOptions,\n+    JoinOptions,\n+    MakeStructOptions,\n+    MapLookupOptions,\n+    MatchSubstringOptions,\n+    ModeOptions,\n+    NullOptions,\n+    PadOptions,\n+    PartitionNthOptions,\n+    QuantileOptions,\n+    RandomOptions,\n+    ReplaceSliceOptions,\n+    ReplaceSubstringOptions,\n+    RoundOptions,\n+    RoundTemporalOptions,\n+    RoundToMultipleOptions,\n+    ScalarAggregateOptions,\n+    SelectKOptions,\n+    SetLookupOptions,\n+    SliceOptions,\n+    SortOptions,\n+    SplitOptions,\n+    SplitPatternOptions,\n+    StrftimeOptions,\n+    StrptimeOptions,\n+    StructFieldOptions,\n+    TakeOptions,\n+    TDigestOptions,\n+    TrimOptions,\n+    Utf8NormalizeOptions,\n+    VarianceOptions,\n+    WeekOptions,\n+    # Functions\n+    call_function,\n+    function_registry,\n+    get_function,\n+    list_functions,\n+    _group_by,\n+    # Expressions\n+    Expression,\n+)\n+import sys\n+import os\n+import inspect\n+import warnings\n+from inspect import Parameter\n+from collections import namedtuple\n+from textwrap import indent, dedent\n+\n+# Avoid clashes with Python keywords\n+function_name_rewrites = {'and': 'and_', 'or': 'or_'}\n+\n+def _get_arg_names(func):\n+    return func._doc.arg_names\n+\n+_OptionsClassDoc = namedtuple('_OptionsClassDoc', ('params',))\n+\n+def _scrape_options_class_doc(options_class):\n+    if not options_class.__doc__:\n+        return None\n+    doc = docscrape.NumpyDocString(options_class.__doc__)\n+    return _OptionsClassDoc(doc['Parameters'])\n+\n+\n+def _get_options_class(func):\n+    class_name = func._doc.options_class\n+    if not class_name:\n+        return None\n+    try:\n+        return globals()[class_name]\n+    except KeyError:\n+        warnings.warn(\"Python binding for {} not exposed\"\n+                      .format(class_name), RuntimeWarning)\n+        return None\n+\n+\n+def generate_compute_function_doc(exposed_name, func, options_class, custom_overrides = None):\n+    \"\"\" Create the documentation for functions defined in Arrow C++.\n+\n+    Args:\n+        exposed_name: The name of the function.\n+        func: The cython function that connects to Arrow C++.\n+        options_class: The class object for the options. \n+        custom_overrides: Custom doc overrides as processed by pyarrow.docutils from the `python/docs/additions/compute` directory.\n+    Returns:\n+        str: The docstring to set the documentation for the pyarrow.compute function.\n+    \"\"\"\n+\n+    cpp_doc = func._doc\n+    \n+    if not custom_overrides:\n+        custom_overrides = {}\n+\n+    docstring = \"\"\n+\n+    # 1. One-line summary\n+    summary = cpp_doc.summary\n+    if not summary:\n+        arg_str = \"arguments\" if func.arity > 1 else \"argument\"\n+        summary = (\"Call compute function {!r} with the given {}\"\n+                   .format(func.name, arg_str))\n+\n+    docstring += f\"{summary}.\\n\\n\"\n+\n+    # 2.a. Multi-line description\n+    if 'description' in custom_overrides and custom_overrides['description']:\n+        docstring += custom_overrides['description'] + \"\\n\\n\"\n+    elif cpp_doc.description:\n+        docstring += cpp_doc.description + \"\\n\\n\"\n+\n+    # 2.b. If \"details\" are provided in the override, add them to the description block\n+    if 'details' in custom_overrides and custom_overrides['details']:\n+        docstring += \"\\n\\n\".join(custom_overrides['details']) + \"\\n\\n\"\n+\n+    # 3. Parameter description\n+    docstring += \"Parameters\\n----------\\n\"\n+\n+    if custom_overrides and 'parameters' in custom_overrides:\n+        custom_params = custom_overrides['parameters']\n+    else:\n+        custom_params = {}\n+\n+    # 3a. Compute function parameters\n+    arg_names = _get_arg_names(func)\n+    for arg_name in arg_names:\n+        if arg_name in custom_params:\n+            custom_arg = custom_params[arg_name]\n+        else:\n+            custom_arg = {}\n+\n+        if 'classifier' in custom_arg:\n+            arg_type = custom_arg['classifier']            \n+        elif func.kind in ('vector', 'scalar_aggregate'):\n+            arg_type = 'Array-like'\n+        else:\n+            arg_type = 'Array-like or scalar-like'\n+        docstring += f\"{arg_name} : {arg_type}\\n\"\n+\n+        if 'definition' in custom_arg:\n+            docstring += f\"    {custom_arg['definition']}\\n\"\n+        else:\n+            docstring += \"    Argument to compute function.\\n\"\n+\n+    # 3b. Compute function option values\n+    if options_class is not None:\n+        options_class_doc = _scrape_options_class_doc(options_class)\n+        if options_class_doc:\n+            for p in options_class_doc.params:\n+                if custom_overrides and 'parameters' in custom_overrides and p.name in custom_overrides['parameters']:\n+                    custom_args = custom_overrides['parameters'][p.name]\n+                else:\n+                    custom_args = {}\n+\n+                if 'type' in custom_args:\n+                    docstring += f\"{p.name} : {custom_args['type']}\\n\"\n+                else:\n+                    docstring += f\"{p.name} : {p.type}\\n\"\n+\n+                if 'definition' in custom_args:\n+                    docstring += f\"    {custom_args['definition']}\"\n+                else:\n+                    for s in p.desc:\n+                        docstring += f\"    {s}\\n\"\n+        else:\n+            warnings.warn(f\"Options class {options_class.__name__} \"\n+                          f\"does not have a docstring\", RuntimeWarning)\n+            options_sig = inspect.signature(options_class)\n+            for p in options_sig.parameters.values():\n+                docstring += dedent(\"\"\"\\\n+                {0} : optional\n+                    Parameter for {1} constructor. Either `options`\n+                    or `{0}` can be passed, but not both at the same time.\n+                \"\"\".format(p.name, options_class.__name__))\n+        docstring += dedent(f\"\"\"\\\n+            options : pyarrow.compute.{options_class.__name__}, optional\n+                Alternative way of passing options.\n+            \"\"\")\n+\n+    docstring += dedent(\"\"\"\\\n+        memory_pool : pyarrow.MemoryPool, optional\n+            If not passed, will allocate memory from the default memory pool.\\n\\n\"\"\")\n+\n+    # 4. Compute return type\n+    if 'return_type' in custom_overrides:\n+        return_string = \"Returns\\n-------\\n\"\n+        for retval, retdesc in custom_overrides['return_type']:\n+            return_string += f\"{retval}\\n    {retdesc}\\n\"\n+        docstring += return_string\n+\n+    # 5. Note about the C++ function\n+    docstring += f\"See Also\\n--------\\nThe `{func.name}` compute function in the Arrow C++ library.\" \n+\n+    # 6. Custom addition (e.g. examples)\n+    if 'examples' in custom_overrides:\n+        docstring += \"\\n\\nExamples\\n--------\\n\" + \"\\n\\n\".join(custom_overrides['examples'])\n+\n+    return(docstring)\n+\n+\n+def generate_function_def(name, cpp_name, func, arity, custom_overrides = None):  \n+    \"\"\" Create the function definition for the pyarrow.compute function.\n+\n+    Args:\n+        name: The name of the function.\n+        cpp_name: The name of the Arrow C++ function, which might differ slightly from the name parameter.\n+        func: The cython function that connects to Arrow C++.\n+        arity: The number of non-option arguments to the function.\n+        custom_overrides: Custom doc overrides as processed by pyarrow.docutils from the `python/docs/additions/compute` directory, which are passed on to the `generate_compute_function_doc` function.\n+    Returns:\n+        str: The generated function definition, in string format.\n+\n+    \"\"\"\n+\n+    # prepare args\n+    all_params = []\n+    # required options\n+    options_required = func._doc.options_required\n+    \n+    argnames = _get_arg_names(func)\n+    if argnames and argnames[-1].startswith('*'):\n+        var_argname = argnames.pop().lstrip('*')\n+    else:\n+        var_argname = None\n+    \n+    for argname in argnames:\n+        all_params.append(Parameter(argname, Parameter.POSITIONAL_ONLY))\n+    \n+    if var_argname:\n+        all_params.append(Parameter(var_argname, Parameter.VAR_POSITIONAL))\n+        argnames.append('*' + var_argname)\n+\n+    options_class = _get_options_class(func)\n+    options_class_name = 'pyarrow._compute.' + func._doc.options_class\n+    option_params = []\n+    if options_class is not None:\n+        options_sig = inspect.signature(options_class)\n+        for paramname, paramdef in options_sig.parameters.items():\n+            assert paramdef.kind in (Parameter.POSITIONAL_OR_KEYWORD,\n+                              Parameter.KEYWORD_ONLY)\n+            if var_argname:\n+                # Cannot have a positional argument after a *args\n+                paramdef = paramdef.replace(kind=Parameter.KEYWORD_ONLY)\n+            if paramdef.default == inspect._empty:\n+                paramdef = paramdef.replace(default = None)\n+            all_params.append(paramdef)\n+            option_params.append(paramname)\n+        all_params.append(Parameter(\"options\", Parameter.KEYWORD_ONLY,\n+                                default=None))\n+    all_params.append(Parameter(\"memory_pool\", Parameter.KEYWORD_ONLY,\n+                            default=None))\n+    \n+    #funcparams = make_function_signature(arg_names, var_arg_names, options_class)\n+\n+    funcdoc = generate_compute_function_doc(name, func, options_class, custom_overrides)    \n+    funcdoc = indent(funcdoc, \" \" * 12, lambda l: l != \"\\n\")\n+\n+    if len(argnames) == 1:\n+        #argstring = f'( {argnames[0]}, )'\n+        argstring = f'[ {argnames[0]} ]'\n+    else:\n+        #argstring = f\"( {', '.join(argnames)} )\"\n+        argstring = f\"[ {', '.join(argnames)} ]\"\n+    \n+    full_signature = inspect.Signature(all_params)\n+    if not options_class:\n+        # ",
                    "created": "2022-07-11T13:30:50.896+0000",
                    "updated": "2022-07-11T13:30:50.896+0000",
                    "started": "2022-07-11T13:30:50.896+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789547",
                    "issueId": "13374797"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/worklog/794638",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "krcrouse commented on PR #13126:\nURL: https://github.com/apache/arrow/pull/13126#issuecomment-1193349631\n\n   Hi, @jorisvandenbossche and @pitrou, \r\n   \r\n   I've pushed new updates to this branch based on the comments, including the fully generated source files in `pyarrow/_compute_generated.py`  \r\n   \r\n   I've resolved updates to the tests and included the new compute functions that have been added since the original creation of the branch. \r\n   \r\n   In line with the movement towards docutils, the following will test all of the examples that get pulled into the pyarrow.compute function documentation: `python -m doctest -v docs/additions/compute/*`\r\n   \n\n\n",
                    "created": "2022-07-24T16:13:30.595+0000",
                    "updated": "2022-07-24T16:13:30.595+0000",
                    "started": "2022-07-24T16:13:30.595+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "794638",
                    "issueId": "13374797"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/worklog/803958",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "krcrouse commented on PR #13126:\nURL: https://github.com/apache/arrow/pull/13126#issuecomment-1228457138\n\n   Hi @jorisvandenbossche and @pitrou,\r\n   \r\n   I made a number of additions so that the autogenerated _compute.py code conformed with flake8, since it doesn't distinguish between hand written and autogenerated code. I also updated the generated function signatures to be compliant with Python 3.7.  \r\n   \r\n   Please let me know how you would like to move forward on this / if you do. \r\n   \r\n   If I'm reading the workflow output correctly, I think the only issue right now is that `archery` is failing due to the lack of licenses in the ReSTructured text files, and I am not sure how that can be added as I don't know of any standard for adding licenses to ReST (output from workflow failure below)\r\n   \r\n   ```bash\r\n   INFO:archery:Running Docker linter\r\n   apache-rat license violation: python/docs/additions/compute/all.rst\r\n   apache-rat license violation: python/docs/additions/compute/any.rst\r\n   apache-rat license violation: python/docs/additions/compute/count.rst\r\n   apache-rat license violation: python/docs/additions/compute/count_distinct.rst\r\n   apache-rat license violation: python/docs/additions/compute/filter.rst\r\n   apache-rat license violation: python/docs/additions/compute/index.rst\r\n   apache-rat license violation: python/docs/additions/compute/indices_nonzero.rst\r\n   apache-rat license violation: python/docs/additions/compute/mode.rst\r\n   apache-rat license violation: python/docs/additions/test_example.rst\r\n   ```\r\n   \r\n   \n\n\n",
                    "created": "2022-08-26T12:59:05.329+0000",
                    "updated": "2022-08-26T12:59:05.329+0000",
                    "started": "2022-08-26T12:59:05.329+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803958",
                    "issueId": "13374797"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/worklog/803960",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on code in PR #13126:\nURL: https://github.com/apache/arrow/pull/13126#discussion_r956029277\n\n\n##########\npython/docs/additions/compute/all.rst:\n##########\n@@ -0,0 +1,24 @@\n+all\n+===\n+\n+Examples\n+--------\n+\n+.. code-block:: python\n\nReview Comment:\n   For our other docstrings (in the code), we do this without the `code-block:: python` (which doctest supports, and sphinx as well to render). I suppose that can be done here as well?\r\n   \r\n   See eg https://github.com/apache/arrow/blob/b832853ba62171d5fe5077681083fc6ea49bfd44/python/pyarrow/array.pxi#L180-L185\n\n\n\n##########\npython/docs/additions/compute/indices_nonzero.rst:\n##########\n@@ -0,0 +1,28 @@\n+indices_nonzero\n+===============\n+\n+Returns\n+-------\n+\n+pyarrow.lib.UInt64Array\n\nReview Comment:\n   ```suggestion\r\n   pyarrow.UInt64Array\r\n   ```\r\n   \r\n   (we can use the public import name, in which case it will also automatically link)\n\n\n\n##########\npython/pyarrow/_rstutils.py:\n##########\n@@ -0,0 +1,291 @@\n+# File GENERATED by scripts/generate_sources.py - DO NOT EDIT.\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+'''\n+pyarrow._rstutils\n\nReview Comment:\n   This module is only needed for the automatic generation, right? So in case we check in the generated file, this is only needed for developers, and can maybe be moved outside of pyarrow? (we don't need to ship this in the packages) For example also in python/scripts ?\n\n\n\n##########\npython/pyarrow/_compute_generated.py:\n##########\n@@ -0,0 +1,9381 @@\n+# File GENERATED by scripts/generate_sources.py - DO NOT EDIT.\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import pyarrow\n+import pyarrow._compute\n+from pyarrow._compute import Expression\n+\n+\n+def _handle_options(name, options_class, options, args, **kwargs):\n+    if options is not None:\n+        if isinstance(options, dict):\n+            return options_class(**options)\n+        elif isinstance(options, options_class):\n+            return options\n+        raise TypeError(\n+            \"Function {!r} expected a {} parameter, got {}\"\n+            .format(name, options_class, type(options)))\n+\n+    if args or kwargs:\n+        # Note: This check is no longer permissable\n+        # Generating function code with real signatures means that\n+        # All of the keyword arguments have default values, and so\n+        # this would always be true. As the default for the options object\n+        # is always false, the options object takes precedence if provided.\n+        #\n+        # if options is not None:\n+        #    raise TypeError(\n+        #        \"Function {!r} called with both an 'options' argument \"\n+        #        \"and additional arguments\"\n+        #        .format(name))\n+\n+        return options_class(*args, **kwargs)\n+\n+    return None\n+\n+\n+def abs(x, *, memory_pool=None):\n+    \"\"\"Calculate the absolute value of the argument element-wise.\n+\n+    Results will wrap around on integer overflow.\n+    Use function \"abs_checked\" if you want overflow\n+    to return an error.\n+\n+    This wraps the \"abs\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('abs')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'abs',\n+            [x]\n+        )\n+\n+    return (\n+        func.call([x], memory_pool=memory_pool)\n+    )\n+\n+\n+def abs_checked(x, *, memory_pool=None):\n+    \"\"\"Calculate the absolute value of the argument element-wise.\n+\n+    This function returns an error on overflow.  For a variant that\n+    doesn't fail on overflow, use function \"abs\".\n+\n+    This wraps the \"abs_checked\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('abs_checked')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'abs_checked',\n+            [x]\n+        )\n+\n+    return (\n+        func.call([x], memory_pool=memory_pool)\n+    )\n+\n+\n+def acos(x, *, memory_pool=None):\n+    \"\"\"Compute the inverse cosine.\n+\n+    NaN is returned for invalid input values;\n+    to raise an error instead, see \"acos_checked\".\n+\n+    This wraps the \"acos\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('acos')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'acos',\n+            [x]\n+        )\n+\n+    return (\n+        func.call([x], memory_pool=memory_pool)\n+    )\n+\n+\n+def acos_checked(x, *, memory_pool=None):\n+    \"\"\"Compute the inverse cosine.\n+\n+    Invalid input values raise an error;\n+    to return NaN instead, see \"acos\".\n+\n+    This wraps the \"acos_checked\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('acos_checked')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'acos_checked',\n+            [x]\n+        )\n+\n+    return (\n+        func.call([x], memory_pool=memory_pool)\n+    )\n+\n+\n+def add(x, y, *, memory_pool=None):\n+    \"\"\"Add the arguments element-wise.\n+\n+    Results will wrap around on integer overflow.\n+    Use function \"add_checked\" if you want overflow\n+    to return an error.\n+\n+    This wraps the \"add\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('add')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'add',\n+            [x, y]\n+        )\n+\n+    return (\n+        func.call([x, y], memory_pool=memory_pool)\n+    )\n+\n+\n+def add_checked(x, y, *, memory_pool=None):\n+    \"\"\"Add the arguments element-wise.\n+\n+    This function returns an error on overflow.  For a variant that\n+    doesn't fail on overflow, use function \"add\".\n+\n+    This wraps the \"add_checked\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('add_checked')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'add_checked',\n+            [x, y]\n+        )\n+\n+    return (\n+        func.call([x, y], memory_pool=memory_pool)\n+    )\n+\n+\n+def all(array, *, skip_nulls=True, min_count=1, options=None,\n+        memory_pool=None):\n+    \"\"\"Test whether all elements in a boolean array evaluate to true.\n+\n+    Null values are ignored by default.\n+    If the `skip_nulls` option is set to false, then Kleene logic is used.\n+    See \"kleene_and\" for more details on Kleene logic.\n+\n+    This wraps the \"all\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    array : Array-like\n+        Argument to compute function.\n+    skip_nulls : bool, default True\n+        Whether to skip (ignore) nulls in the input.\n+        If False, any null in the input forces the output to null.\n+    min_count : int, default 1\n+        Minimum number of non-null values in the input.  If the number\n+        of non-null values is below `min_count`, the output is null.\n+    options : pyarrow.compute.ScalarAggregateOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+\n+\n+\n+    Examples\n+    --------\n+    >>> import pyarrow as pa\n+    >>> import pyarrow.compute as pc\n+    >>> arr = pa.array([True, True, None, False, True])\n+    >>> pc.all(arr)\n+    <pyarrow.BooleanScalar: False>\n+    >>> arr = pa.array([True, True, None, True, None, None])\n+    >>> pc.all(arr)\n+    <pyarrow.BooleanScalar: True>\n+    >>> pc.all(arr, skip_nulls = False)\n+    <pyarrow.BooleanScalar: None>\n+    >>> pc.all(arr, min_count = 4)\n+    <pyarrow.BooleanScalar: None>\n+    >>> pc.all(arr, min_count = 10)\n+    <pyarrow.BooleanScalar: None>\n+    >>> pc.all(arr, min_count = 2)\n+    <pyarrow.BooleanScalar: True>\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'all',\n+        pyarrow._compute.ScalarAggregateOptions,\n+        options,\n+        (),\n+        skip_nulls=skip_nulls,\n+        min_count=min_count\n+    )\n+    func = pyarrow._compute.get_function('all')\n+\n+    if isinstance(array, Expression):\n+        return Expression._call(\n+            'all',\n+            [array],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([array], _computed_options, memory_pool)\n+    )\n+\n+\n+def and_(x, y, *, memory_pool=None):\n+    \"\"\"Logical 'and' boolean values.\n+\n+    When a null is encountered in either input, a null is output.\n+    For a different null behavior, see function \"and_kleene\".\n+\n+    This wraps the \"and\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('and')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'and_',\n+            [x, y]\n+        )\n+\n+    return (\n+        func.call([x, y], memory_pool=memory_pool)\n+    )\n+\n+\n+def and_kleene(x, y, *, memory_pool=None):\n+    \"\"\"Logical 'and' boolean values (Kleene logic).\n+\n+    This function behaves as follows with nulls:\n+\n+    - true and null = null\n+    - null and true = null\n+    - false and null = false\n+    - null and false = false\n+    - null and null = null\n+\n+    In other words, in this context a null value really means \"unknown\",\n+    and an unknown value 'and' false is always false.\n+    For a different null behavior, see function \"and\".\n+\n+    This wraps the \"and_kleene\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('and_kleene')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'and_kleene',\n+            [x, y]\n+        )\n+\n+    return (\n+        func.call([x, y], memory_pool=memory_pool)\n+    )\n+\n+\n+def and_not(x, y, *, memory_pool=None):\n+    \"\"\"Logical 'and not' boolean values.\n+\n+    When a null is encountered in either input, a null is output.\n+    For a different null behavior, see function \"and_not_kleene\".\n+\n+    This wraps the \"and_not\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('and_not')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'and_not',\n+            [x, y]\n+        )\n+\n+    return (\n+        func.call([x, y], memory_pool=memory_pool)\n+    )\n+\n+\n+def and_not_kleene(x, y, *, memory_pool=None):\n+    \"\"\"Logical 'and not' boolean values (Kleene logic).\n+\n+    This function behaves as follows with nulls:\n+\n+    - true and null = null\n+    - null and false = null\n+    - false and null = false\n+    - null and true = false\n+    - null and null = null\n+\n+    In other words, in this context a null value really means \"unknown\",\n+    and an unknown value 'and not' true is always false, as is false\n+    'and not' an unknown value.\n+    For a different null behavior, see function \"and_not\".\n+\n+    This wraps the \"and_not_kleene\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('and_not_kleene')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'and_not_kleene',\n+            [x, y]\n+        )\n+\n+    return (\n+        func.call([x, y], memory_pool=memory_pool)\n+    )\n+\n+\n+def any(array, *, skip_nulls=True, min_count=1, options=None,\n+        memory_pool=None):\n+    \"\"\"Test whether any element in a boolean array evaluates to true.\n+\n+    Null values are ignored by default.\n+    If the `skip_nulls` option is set to false, then Kleene logic is used.\n+    See \"kleene_or\" for more details on Kleene logic.\n+\n+    This wraps the \"any\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    array : Array-like\n+        Argument to compute function.\n+    skip_nulls : bool, default True\n+        Whether to skip (ignore) nulls in the input.\n+        If False, any null in the input forces the output to null.\n+    min_count : int, default 1\n+        Minimum number of non-null values in the input.  If the number\n+        of non-null values is below `min_count`, the output is null.\n+    options : pyarrow.compute.ScalarAggregateOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+\n+\n+\n+    Examples\n+    --------\n+    >>> import pyarrow as pa\n+    >>> import pyarrow.compute as pc\n+    >>> arr = pa.array([True, True, None, False, True])\n+    >>> pc.any(arr)\n+    <pyarrow.BooleanScalar: True>\n+    >>> pc.any(arr, min_count = 4)\n+    <pyarrow.BooleanScalar: True>\n+    >>> pc.any(arr, min_count = len(arr))\n+    <pyarrow.BooleanScalar: None>\n+    >>> arr = pa.array([False, False, None, False, True])\n+    >>> pc.any(arr)\n+    <pyarrow.BooleanScalar: True>\n+    >>> pc.any(arr, min_count = 2)\n+    <pyarrow.BooleanScalar: True>\n+    >>> pc.any(arr, min_count = len(arr))\n+    <pyarrow.BooleanScalar: None>\n+    >>> pc.any(arr, skip_nulls = False)\n+    <pyarrow.BooleanScalar: True>\n+    >>> pc.any([False,None], skip_nulls = False)\n+    <pyarrow.BooleanScalar: None>\n+    >>> pc.any([False,None], skip_nulls = True)\n+    <pyarrow.BooleanScalar: False>\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'any',\n+        pyarrow._compute.ScalarAggregateOptions,\n+        options,\n+        (),\n+        skip_nulls=skip_nulls,\n+        min_count=min_count\n+    )\n+    func = pyarrow._compute.get_function('any')\n+\n+    if isinstance(array, Expression):\n+        return Expression._call(\n+            'any',\n+            [array],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([array], _computed_options, memory_pool)\n+    )\n+\n+\n+def approximate_median(array, *, skip_nulls=True, min_count=1, options=None,\n+                       memory_pool=None):\n+    \"\"\"Approximate median of a numeric array with T-Digest algorithm.\n+\n+    Nulls and NaNs are ignored.\n+    A null scalar is returned if there is no valid data point.\n+\n+    This wraps the \"approximate_median\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    array : Array-like\n+        Argument to compute function.\n+    skip_nulls : bool, default True\n+        Whether to skip (ignore) nulls in the input.\n+        If False, any null in the input forces the output to null.\n+    min_count : int, default 1\n+        Minimum number of non-null values in the input.  If the number\n+        of non-null values is below `min_count`, the output is null.\n+    options : pyarrow.compute.ScalarAggregateOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'approximate_median',\n+        pyarrow._compute.ScalarAggregateOptions,\n+        options,\n+        (),\n+        skip_nulls=skip_nulls,\n+        min_count=min_count\n+    )\n+    func = pyarrow._compute.get_function('approximate_median')\n+\n+    if isinstance(array, Expression):\n+        return Expression._call(\n+            'approximate_median',\n+            [array],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([array], _computed_options, memory_pool)\n+    )\n+\n+\n+def array_filter(array, selection_filter, null_selection_behavior='drop', *,\n+                 options=None, memory_pool=None):\n+    \"\"\"Filter with a boolean selection filter.\n+\n+    The output is populated with values from the input `array` at positions\n+    where the selection filter is non-zero.  Nulls in the selection filter\n+    are handled based on FilterOptions.\n+\n+    This wraps the \"array_filter\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    array : Array-like\n+        Argument to compute function.\n+    selection_filter : Array-like\n+        Argument to compute function.\n+    null_selection_behavior : str, default \"drop\"\n+        How to handle nulls in the selection filter.\n+        Accepted values are \"drop\", \"emit_null\".\n+    options : pyarrow.compute.FilterOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'array_filter',\n+        pyarrow._compute.FilterOptions,\n+        options,\n+        (),\n+        null_selection_behavior=null_selection_behavior\n+    )\n+    func = pyarrow._compute.get_function('array_filter')\n+\n+    if isinstance(array, Expression):\n+        return Expression._call(\n+            'array_filter',\n+            [array, selection_filter],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([array, selection_filter], _computed_options, memory_pool)\n+    )\n+\n+\n+def array_sort_indices(array, order='ascending', *, null_placement='at_end',\n+                       options=None, memory_pool=None):\n+    \"\"\"Return the indices that would sort an array.\n+\n+    This function computes an array of indices that define a stable sort\n+    of the input array.  By default, Null values are considered greater\n+    than any other value and are therefore sorted at the end of the array.\n+    For floating-point types, NaNs are considered greater than any\n+    other non-null value, but smaller than null values.\n+\n+    The handling of nulls and NaNs can be changed in ArraySortOptions.\n+\n+    This wraps the \"array_sort_indices\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    array : Array-like\n+        Argument to compute function.\n+    order : str, default \"ascending\"\n+        Which order to sort values in.\n+        Accepted values are \"ascending\", \"descending\".\n+    null_placement : str, default \"at_end\"\n+        Where nulls in the input should be sorted.\n+        Accepted values are \"at_start\", \"at_end\".\n+    options : pyarrow.compute.ArraySortOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'array_sort_indices',\n+        pyarrow._compute.ArraySortOptions,\n+        options,\n+        (),\n+        order=order,\n+        null_placement=null_placement\n+    )\n+    func = pyarrow._compute.get_function('array_sort_indices')\n+\n+    if isinstance(array, Expression):\n+        return Expression._call(\n+            'array_sort_indices',\n+            [array],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([array], _computed_options, memory_pool)\n+    )\n+\n+\n+def array_take(array, indices, *, boundscheck=True, options=None,\n+               memory_pool=None):\n+    \"\"\"Select values from an array based on indices from another array.\n+\n+    The output is populated with values from the input array at positions\n+    given by `indices`.  Nulls in `indices` emit null in the output.\n+\n+    This wraps the \"array_take\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    array : Array-like\n+        Argument to compute function.\n+    indices : Array-like\n+        Argument to compute function.\n+    boundscheck : boolean, default True\n+        Whether to check indices are within bounds. If False and an\n+        index is out of boundes, behavior is undefined (the process\n+        may crash).\n+    options : pyarrow.compute.TakeOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'array_take',\n+        pyarrow._compute.TakeOptions,\n+        options,\n+        (),\n+        boundscheck=boundscheck\n+    )\n+    func = pyarrow._compute.get_function('array_take')\n+\n+    if isinstance(array, Expression):\n+        return Expression._call(\n+            'array_take',\n+            [array, indices],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([array, indices], _computed_options, memory_pool)\n+    )\n+\n+\n+def ascii_capitalize(strings, *, memory_pool=None):\n+    \"\"\"Capitalize the first character of ASCII input.\n+\n+    For each string in `strings`, return a capitalized version.\n+\n+    This function assumes the input is fully ASCII.  If it may contain\n+    non-ASCII characters, use \"utf8_capitalize\" instead.\n+\n+    This wraps the \"ascii_capitalize\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_capitalize')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_capitalize',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_center(strings, width=None, padding=' ', *, options=None,\n+                 memory_pool=None):\n+    \"\"\"Center strings by padding with a given character.\n+\n+    For each string in `strings`, emit a centered string by padding both\n+        sides\n+    with the given ASCII character.\n+    Null values emit null.\n+\n+    This wraps the \"ascii_center\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    width : int\n+        Desired string length.\n+    padding : str, default \" \"\n+        What to pad the string with. Should be one byte or codepoint.\n+    options : pyarrow.compute.PadOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'ascii_center',\n+        pyarrow._compute.PadOptions,\n+        options,\n+        (),\n+        width=width,\n+        padding=padding\n+    )\n+    func = pyarrow._compute.get_function('ascii_center')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_center',\n+            [strings],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([strings], _computed_options, memory_pool)\n+    )\n+\n+\n+def ascii_is_alnum(strings, *, memory_pool=None):\n+    \"\"\"Classify strings as ASCII alphanumeric.\n+\n+    For each string in `strings`, emit true iff the string is non-empty\n+    and consists only of alphanumeric ASCII characters.  Null strings emit\n+        null.\n+\n+    This wraps the \"ascii_is_alnum\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_is_alnum')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_is_alnum',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_is_alpha(strings, *, memory_pool=None):\n+    \"\"\"Classify strings as ASCII alphabetic.\n+\n+    For each string in `strings`, emit true iff the string is non-empty\n+    and consists only of alphabetic ASCII characters.  Null strings emit\n+        null.\n+\n+    This wraps the \"ascii_is_alpha\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_is_alpha')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_is_alpha',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_is_decimal(strings, *, memory_pool=None):\n+    \"\"\"Classify strings as ASCII decimal.\n+\n+    For each string in `strings`, emit true iff the string is non-empty\n+    and consists only of decimal ASCII characters.  Null strings emit null.\n+\n+    This wraps the \"ascii_is_decimal\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_is_decimal')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_is_decimal',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_is_lower(strings, *, memory_pool=None):\n+    \"\"\"Classify strings as ASCII lowercase.\n+\n+    For each string in `strings`, emit true iff the string is non-empty\n+    and consists only of lowercase ASCII characters.  Null strings emit null.\n+\n+    This wraps the \"ascii_is_lower\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_is_lower')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_is_lower',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_is_printable(strings, *, memory_pool=None):\n+    \"\"\"Classify strings as ASCII printable.\n+\n+    For each string in `strings`, emit true iff the string is non-empty\n+    and consists only of printable ASCII characters.  Null strings emit null.\n+\n+    This wraps the \"ascii_is_printable\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_is_printable')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_is_printable',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_is_space(strings, *, memory_pool=None):\n+    \"\"\"Classify strings as ASCII whitespace.\n+\n+    For each string in `strings`, emit true iff the string is non-empty\n+    and consists only of whitespace ASCII characters.  Null strings emit\n+        null.\n+\n+    This wraps the \"ascii_is_space\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_is_space')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_is_space',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_is_title(strings, *, memory_pool=None):\n+    \"\"\"Classify strings as ASCII titlecase.\n+\n+    For each string in `strings`, emit true iff the string is title-cased,\n+    i.e. it has at least one cased character, each uppercase character\n+    follows an uncased character, and each lowercase character follows\n+    an uppercase character.\n+\n+    This wraps the \"ascii_is_title\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_is_title')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_is_title',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_is_upper(strings, *, memory_pool=None):\n+    \"\"\"Classify strings as ASCII uppercase.\n+\n+    For each string in `strings`, emit true iff the string is non-empty\n+    and consists only of uppercase ASCII characters.  Null strings emit null.\n+\n+    This wraps the \"ascii_is_upper\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_is_upper')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_is_upper',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_lower(strings, *, memory_pool=None):\n+    \"\"\"Transform ASCII input to lowercase.\n+\n+    For each string in `strings`, return a lowercase version.\n+\n+    This function assumes the input is fully ASCII.  If it may contain\n+    non-ASCII characters, use \"utf8_lower\" instead.\n+\n+    This wraps the \"ascii_lower\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_lower')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_lower',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_lpad(strings, width=None, padding=' ', *, options=None,\n+               memory_pool=None):\n+    \"\"\"Right-align strings by padding with a given character.\n+\n+    For each string in `strings`, emit a right-aligned string by prepending\n+    the given ASCII character.\n+    Null values emit null.\n+\n+    This wraps the \"ascii_lpad\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    width : int\n+        Desired string length.\n+    padding : str, default \" \"\n+        What to pad the string with. Should be one byte or codepoint.\n+    options : pyarrow.compute.PadOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'ascii_lpad',\n+        pyarrow._compute.PadOptions,\n+        options,\n+        (),\n+        width=width,\n+        padding=padding\n+    )\n+    func = pyarrow._compute.get_function('ascii_lpad')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_lpad',\n+            [strings],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([strings], _computed_options, memory_pool)\n+    )\n+\n+\n+def ascii_ltrim(strings, characters=None, *, options=None, memory_pool=None):\n+    \"\"\"Trim leading characters.\n+\n+    For each string in `strings`, remove any leading characters\n+    from the `characters` option (as given in TrimOptions).\n+    Null values emit null.\n+    Both the `strings` and the `characters` are interpreted as\n+    ASCII; to trim non-ASCII characters, use `utf8_ltrim`.\n+\n+    This wraps the \"ascii_ltrim\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    characters : str\n+        Individual characters to be trimmed from the string.\n+    options : pyarrow.compute.TrimOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'ascii_ltrim',\n+        pyarrow._compute.TrimOptions,\n+        options,\n+        (),\n+        characters=characters\n+    )\n+    func = pyarrow._compute.get_function('ascii_ltrim')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_ltrim',\n+            [strings],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([strings], _computed_options, memory_pool)\n+    )\n+\n+\n+def ascii_ltrim_whitespace(strings, *, memory_pool=None):\n+    \"\"\"Trim leading ASCII whitespace characters.\n+\n+    For each string in `strings`, emit a string with leading ASCII whitespace\n+    characters removed.  Use `utf8_ltrim_whitespace` to trim leading Unicode\n+    whitespace characters. Null values emit null.\n+\n+    This wraps the \"ascii_ltrim_whitespace\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_ltrim_whitespace')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_ltrim_whitespace',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_reverse(strings, *, memory_pool=None):\n+    \"\"\"Reverse ASCII input.\n+\n+    For each ASCII string in `strings`, return a reversed version.\n+\n+    This function assumes the input is fully ASCII.  If it may contain\n+    non-ASCII characters, use \"utf8_reverse\" instead.\n+\n+    This wraps the \"ascii_reverse\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_reverse')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_reverse',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_rpad(strings, width=None, padding=' ', *, options=None,\n+               memory_pool=None):\n+    \"\"\"Left-align strings by padding with a given character.\n+\n+    For each string in `strings`, emit a left-aligned string by appending\n+    the given ASCII character.\n+    Null values emit null.\n+\n+    This wraps the \"ascii_rpad\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    width : int\n+        Desired string length.\n+    padding : str, default \" \"\n+        What to pad the string with. Should be one byte or codepoint.\n+    options : pyarrow.compute.PadOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'ascii_rpad',\n+        pyarrow._compute.PadOptions,\n+        options,\n+        (),\n+        width=width,\n+        padding=padding\n+    )\n+    func = pyarrow._compute.get_function('ascii_rpad')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_rpad',\n+            [strings],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([strings], _computed_options, memory_pool)\n+    )\n+\n+\n+def ascii_rtrim(strings, characters=None, *, options=None, memory_pool=None):\n+    \"\"\"Trim trailing characters.\n+\n+    For each string in `strings`, remove any trailing characters\n+    from the `characters` option (as given in TrimOptions).\n+    Null values emit null.\n+    Both the `strings` and the `characters` are interpreted as\n+    ASCII; to trim non-ASCII characters, use `utf8_rtrim`.\n+\n+    This wraps the \"ascii_rtrim\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    characters : str\n+        Individual characters to be trimmed from the string.\n+    options : pyarrow.compute.TrimOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'ascii_rtrim',\n+        pyarrow._compute.TrimOptions,\n+        options,\n+        (),\n+        characters=characters\n+    )\n+    func = pyarrow._compute.get_function('ascii_rtrim')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_rtrim',\n+            [strings],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([strings], _computed_options, memory_pool)\n+    )\n+\n+\n+def ascii_rtrim_whitespace(strings, *, memory_pool=None):\n+    \"\"\"Trim trailing ASCII whitespace characters.\n+\n+    For each string in `strings`, emit a string with trailing ASCII\n+        whitespace\n+    characters removed. Use `utf8_rtrim_whitespace` to trim trailing Unicode\n+    whitespace characters. Null values emit null.\n+\n+    This wraps the \"ascii_rtrim_whitespace\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_rtrim_whitespace')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_rtrim_whitespace',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_split_whitespace(strings, *, max_splits=None, reverse=False,\n+                           options=None,\n+                           memory_pool=None):\n+    \"\"\"Split string according to any ASCII whitespace.\n+\n+    Split each string according any non-zero length sequence of ASCII\n+    whitespace characters.  The output for each string input is a list\n+    of strings.\n+\n+    The maximum number of splits and direction of splitting\n+    (forward, reverse) can optionally be defined in SplitOptions.\n+\n+    This wraps the \"ascii_split_whitespace\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    max_splits : int or None, default None\n+        Maximum number of splits for each input value (unlimited if None).\n+    reverse : bool, default False\n+        Whether to start splitting from the end of each input value.\n+        This only has an effect if `max_splits` is not None.\n+    options : pyarrow.compute.SplitOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'ascii_split_whitespace',\n+        pyarrow._compute.SplitOptions,\n+        options,\n+        (),\n+        max_splits=max_splits,\n+        reverse=reverse\n+    )\n+    func = pyarrow._compute.get_function('ascii_split_whitespace')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_split_whitespace',\n+            [strings],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([strings], _computed_options, memory_pool)\n+    )\n+\n+\n+def ascii_swapcase(strings, *, memory_pool=None):\n+    \"\"\"Transform ASCII input by inverting casing.\n+\n+    For each string in `strings`, return a string with opposite casing.\n+\n+    This function assumes the input is fully ASCII.  If it may contain\n+    non-ASCII characters, use \"utf8_swapcase\" instead.\n+\n+    This wraps the \"ascii_swapcase\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_swapcase')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_swapcase',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_title(strings, *, memory_pool=None):\n+    \"\"\"Titlecase each word of ASCII input.\n+\n+    For each string in `strings`, return a titlecased version.\n+    Each word in the output will start with an uppercase character and its\n+    remaining characters will be lowercase.\n+\n+    This function assumes the input is fully ASCII.  If it may contain\n+    non-ASCII characters, use \"utf8_title\" instead.\n+\n+    This wraps the \"ascii_title\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_title')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_title',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_trim(strings, characters=None, *, options=None, memory_pool=None):\n+    \"\"\"Trim leading and trailing characters.\n+\n+    For each string in `strings`, remove any leading or trailing characters\n+    from the `characters` option (as given in TrimOptions).\n+    Null values emit null.\n+    Both the `strings` and the `characters` are interpreted as\n+    ASCII; to trim non-ASCII characters, use `utf8_trim`.\n+\n+    This wraps the \"ascii_trim\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    characters : str\n+        Individual characters to be trimmed from the string.\n+    options : pyarrow.compute.TrimOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'ascii_trim',\n+        pyarrow._compute.TrimOptions,\n+        options,\n+        (),\n+        characters=characters\n+    )\n+    func = pyarrow._compute.get_function('ascii_trim')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_trim',\n+            [strings],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([strings], _computed_options, memory_pool)\n+    )\n+\n+\n+def ascii_trim_whitespace(strings, *, memory_pool=None):\n+    \"\"\"Trim leading and trailing ASCII whitespace characters.\n+\n+    For each string in `strings`, emit a string with leading and trailing\n+        ASCII\n+    whitespace characters removed. Use `utf8_trim_whitespace` to trim Unicode\n+    whitespace characters. Null values emit null.\n+\n+    This wraps the \"ascii_trim_whitespace\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_trim_whitespace')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_trim_whitespace',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_upper(strings, *, memory_pool=None):\n+    \"\"\"Transform ASCII input to uppercase.\n+\n+    For each string in `strings`, return an uppercase version.\n+\n+    This function assumes the input is fully ASCII.  It it may contain\n+    non-ASCII characters, use \"utf8_upper\" instead.\n+\n+    This wraps the \"ascii_upper\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_upper')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_upper',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def asin(x, *, memory_pool=None):\n+    \"\"\"Compute the inverse sine.\n+\n+    NaN is returned for invalid input values;\n+    to raise an error instead, see \"asin_checked\".\n+\n+    This wraps the \"asin\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('asin')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'asin',\n+            [x]\n+        )\n+\n+    return (\n+        func.call([x], memory_pool=memory_pool)\n+    )\n+\n+\n+def asin_checked(x, *, memory_pool=None):\n+    \"\"\"Compute the inverse sine.\n+\n+    Invalid input values raise an error;\n+    to return NaN instead, see \"asin\".\n+\n+    This wraps the \"asin_checked\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('asin_checked')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'asin_checked',\n+            [x]\n+        )\n+\n+    return (\n+        func.call([x], memory_pool=memory_pool)\n+    )\n+\n+\n+def assume_timezone(timestamps, timezone=None, *, ambiguous='raise',\n+                    nonexistent='raise', options=None,\n+                    memory_pool=None):\n+    \"\"\"Convert naive timestamp to timezone-aware timestamp.\n+\n+    Input timestamps are assumed to be relative to the timezone given in the\n+    `timezone` option. They are converted to UTC-relative timestamps and\n+    the output type has its timezone set to the value of the `timezone`\n+    option. Null values emit null.\n+    This function is meant to be used when an external system produces\n+    \"timezone-naive\" timestamps which need to be converted to\n+    \"timezone-aware\" timestamps. An error is returned if the timestamps\n+    already have a defined timezone.\n+\n+    This wraps the \"assume_timezone\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    timestamps : Array-like or scalar-like\n+        Argument to compute function.\n+    timezone : str\n+        Timezone to assume for the input.\n+    ambiguous : str, default \"raise\"\n+        How to handle timestamps that are ambiguous in the assumed timezone.\n+        Accepted values are \"raise\", \"earliest\", \"latest\".\n+    nonexistent : str, default \"raise\"\n+        How to handle timestamps that don't exist in the assumed timezone.\n+        Accepted values are \"raise\", \"earliest\", \"latest\".\n+    options : pyarrow.compute.AssumeTimezoneOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'assume_timezone',\n+        pyarrow._compute.AssumeTimezoneOptions,\n+        options,\n+        (),\n+        timezone=timezone,\n+        ambiguous=ambiguous,\n+        nonexistent=nonexistent\n+    )\n+    func = pyarrow._compute.get_function('assume_timezone')\n+\n+    if isinstance(timestamps, Expression):\n+        return Expression._call(\n+            'assume_timezone',\n+            [timestamps],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([timestamps], _computed_options, memory_pool)\n+    )\n+\n+\n+def atan(x, *, memory_pool=None):\n+    \"\"\"Compute the inverse tangent of x.\n+\n+    The return value is in the range [-pi/2, pi/2];\n+    for a full return range [-pi, pi], see \"atan2\".\n+\n+    This wraps the \"atan\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('atan')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'atan',\n+            [x]\n+        )\n+\n+    return (\n+        func.call([x], memory_pool=memory_pool)\n+    )\n+\n+\n+def atan2(y, x, *, memory_pool=None):\n+    \"\"\"Compute the inverse tangent of y/x.\n+\n+    The return value is in the range [-pi, pi].\n+\n+    This wraps the \"atan2\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('atan2')\n+\n+    if isinstance(y, Expression):\n+        return Expression._call(\n+            'atan2',\n+            [y, x]\n+        )\n+\n+    return (\n+        func.call([y, x], memory_pool=memory_pool)\n+    )\n+\n+\n+def binary_join(strings, separator, *, memory_pool=None):\n+    \"\"\"Join a list of strings together with a separator.\n+\n+    Concatenate the strings in `list`. The `separator` is inserted\n+    between each given string.\n+    Any null input and any null `list` element emits a null output.\n+\n+    This wraps the \"binary_join\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    separator : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('binary_join')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'binary_join',\n+            [strings, separator]\n+        )\n+\n+    return (\n+        func.call([strings, separator], memory_pool=memory_pool)\n+    )\n+\n+\n+def binary_join_element_wise(*strings, null_handling='emit_null',\n+                             null_replacement='',\n+                             options=None,\n+                             memory_pool=None):\n+    \"\"\"Join string arguments together, with the last argument as separator.\n+\n+    Concatenate the `strings` except for the last one. The last argument\n+    in `strings` is inserted between each given string.\n+    Any null separator element emits a null output. Null elements either\n+    emit a null (the default), are skipped, or replaced with a given string.\n+\n+    This wraps the \"binary_join_element_wise\" compute function in the Arrow\n+        C++ library.\n+\n+    Parameters\n+    ----------\n+    *strings : Array-like or scalar-like\n+        Argument to compute function.\n+    null_handling : str, default \"emit_null\"\n+        How to handle null values in the inputs.\n+        Accepted values are \"emit_null\", \"skip\", \"replace\".\n+    null_replacement : str, default \"\"\n+        Replacement string to emit for null inputs if `null_handling`\n+        is \"replace\".\n+    options : pyarrow.compute.JoinOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'binary_join_element_wise',\n+        pyarrow._compute.JoinOptions,\n+        options,\n+        (),\n+        null_handling=null_handling,\n+        null_replacement=null_replacement\n+    )\n+    func = pyarrow._compute.get_function('binary_join_element_wise')\n+    return (\n+        func.call([*strings], _computed_options, memory_pool)\n+    )\n+\n+\n+def binary_length(strings, *, memory_pool=None):\n+    \"\"\"Compute string lengths.\n+\n+    For each string in `strings`, emit its length of bytes.\n+    Null values emit null.\n+\n+    This wraps the \"binary_length\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('binary_length')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'binary_length',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def binary_repeat(strings, num_repeats, *, memory_pool=None):\n+    \"\"\"Repeat a binary string.\n+\n+    For each binary string in `strings`, return a replicated version.\n+\n+    This wraps the \"binary_repeat\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    num_repeats : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('binary_repeat')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'binary_repeat',\n+            [strings, num_repeats]\n+        )\n+\n+    return (\n+        func.call([strings, num_repeats], memory_pool=memory_pool)\n+    )\n+\n+\n+def binary_replace_slice(strings, start=None, stop=None, replacement=None, *,\n+                         options=None,\n+                         memory_pool=None):\n+    \"\"\"Replace a slice of a binary string.\n+\n+    For each string in `strings`, replace a slice of the string defined by\n+        `start`\n+    and `stop` indices with the given `replacement`. `start` is inclusive\n+    and `stop` is exclusive, and both are measured in bytes.\n+    Null values emit null.\n+\n+    This wraps the \"binary_replace_slice\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    start : int\n+        Index to start slicing at (inclusive).\n+    stop : int\n+        Index to stop slicing at (exclusive).\n+    replacement : str\n+        What to replace the slice with.\n+    options : pyarrow.compute.ReplaceSliceOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'binary_replace_slice',\n+        pyarrow._compute.ReplaceSliceOptions,\n+        options,\n+        (),\n+        start=start,\n+        stop=stop,\n+        replacement=replacement\n+    )\n+    func = pyarrow._compute.get_function('binary_replace_slice')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'binary_replace_slice',\n+            [strings],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([strings], _computed_options, memory_pool)\n+    )\n+\n+\n+def binary_reverse(strings, *, memory_pool=None):\n+    \"\"\"Reverse binary input.\n+\n+    For each binary string in `strings`, return a reversed version.\n+\n+    This function reverses the binary data at a byte-level.\n+\n+    This wraps the \"binary_reverse\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('binary_reverse')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'binary_reverse',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def bit_wise_and(x, y, *, memory_pool=None):\n+    \"\"\"Bit-wise AND the arguments element-wise.\n+\n+    Null values return null.\n+\n+    This wraps the \"bit_wise_and\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('bit_wise_and')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'bit_wise_and',\n+            [x, y]\n+        )\n+\n+    return (\n+        func.call([x, y], memory_pool=memory_pool)\n+    )\n+\n+\n+def bit_wise_not(x, *, memory_pool=None):\n+    \"\"\"Bit-wise negate the arguments element-wise.\n+\n+    Null values return null.\n+\n+    This wraps the \"bit_wise_not\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('bit_wise_not')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'bit_wise_not',\n+            [x]\n+        )\n+\n+    return (\n+        func.call([x], memory_pool=memory_pool)\n+    )\n+\n+\n+def bit_wise_or(x, y, *, memory_pool=None):\n+    \"\"\"Bit-wise OR the arguments element-wise.\n+\n+    Null values return null.\n+\n+    This wraps the \"bit_wise_or\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('bit_wise_or')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'bit_wise_or',\n+            [x, y]\n+        )\n+\n+    return (\n+        func.call([x, y], memory_pool=memory_pool)\n+    )\n+\n+\n+def bit_wise_xor(x, y, *, memory_pool=None):\n+    \"\"\"Bit-wise XOR the arguments element-wise.\n+\n+    Null values return null.\n+\n+    This wraps the \"bit_wise_xor\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('bit_wise_xor')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'bit_wise_xor',\n+            [x, y]\n+        )\n+\n+    return (\n+        func.call([x, y], memory_pool=memory_pool)\n+    )\n+\n+\n+def case_when(cond, *cases, memory_pool=None):\n+    \"\"\"Choose values based on multiple conditions.\n+\n+    `cond` must be a struct of Boolean values. `cases` can be a mix\n+    of scalar and array arguments (of any type, but all must be the\n+    same type or castable to a common type), with either exactly one\n+    datum per child of `cond`, or one more `cases` than children of\n+    `cond` (in which case we have an \"else\" value).\n+\n+    Each row of the output will be the corresponding value of the\n+    first datum in `cases` for which the corresponding child of `cond`\n+    is true, or otherwise the \"else\" value (if given), or null.\n+\n+    Essentially, this implements a switch-case or if-else, if-else...\n+        statement.\n+\n+    This wraps the \"case_when\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    cond : Array-like or scalar-like\n+        Argument to compute function.\n+    *cases : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('case_when')\n+    return (\n+        func.call([cond, *cases], memory_pool=memory_pool)\n+    )\n+\n+\n+def cast(input, target_type=None, *, allow_int_overflow=None,\n+         allow_time_truncate=None, allow_time_overflow=None,\n+         allow_decimal_truncate=None, allow_float_truncate=None,\n+         allow_invalid_utf8=None, options=None, memory_pool=None):\n+    \"\"\"Cast values to another data type.\n+\n+    Behavior when values wouldn't fit in the target type\n+    can be controlled through CastOptions.\n+\n+    This wraps the \"cast\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    input : Array-like or scalar-like\n+        Argument to compute function.\n+    target_type : DataType, optional\n+        The PyArrow type to cast to.\n+    allow_int_overflow : bool, default False\n+        Whether integer overflow is allowed when casting.\n+    allow_time_truncate : bool, default False\n+        Whether time precision truncation is allowed when casting.\n+    allow_time_overflow : bool, default False\n+        Whether date/time range overflow is allowed when casting.\n+    allow_decimal_truncate : bool, default False\n+        Whether decimal precision truncation is allowed when casting.\n+    allow_float_truncate : bool, default False\n+        Whether floating-point precision truncation is allowed when casting.\n+    allow_invalid_utf8 : bool, default False\n+        Whether producing invalid utf8 data is allowed when casting.\n+    options : pyarrow.compute.CastOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'cast',\n+        pyarrow._compute.CastOptions,\n+        options,\n+        (),\n+        target_type=target_type,\n+        allow_int_overflow=allow_int_overflow,\n+        allow_time_truncate=allow_time_truncate,\n+        allow_time_overflow=allow_time_overflow,\n+        allow_decimal_truncate=allow_decimal_truncate,\n+        allow_float_truncate=allow_float_truncate,\n+        allow_invalid_utf8=allow_invalid_utf8\n+    )\n+    func = pyarrow._compute.get_function('cast')\n+\n+    if isinstance(input, Expression):\n+        return Expression._call(\n+            'cast',\n+            [input],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([input], _computed_options, memory_pool)\n+    )\n+\n+\n+def ceil(x, *, memory_pool=None):\n+    \"\"\"Round up to the nearest integer.\n+\n+    Compute the smallest integer value not less in magnitude than `x`.\n+\n+    This wraps the \"ceil\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ceil')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'ceil',\n+            [x]\n+        )\n+\n+    return (\n+        func.call([x], memory_pool=memory_pool)\n+    )\n+\n+\n+def ceil_temporal(timestamps, multiple=1, unit='day', *,\n+                  week_starts_monday=True,\n+                  ceil_is_strictly_greater=False,\n+                  calendar_based_origin=False, options=None,\n+                  memory_pool=None):\n+    \"\"\"Round temporal values up to nearest multiple of specified time unit.\n+\n+    Null values emit null.\n+    An error is returned if the values have a defined timezone but it\n+    cannot be found in the timezone database.\n+\n+    This wraps the \"ceil_temporal\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    timestamps : Array-like or scalar-like\n+        Argument to compute function.\n+    multiple : int, default 1\n+        Number of units to round to.\n+    unit : str, default \"day\"\n+        The unit in which `multiple` is expressed.\n+        Accepted values are \"year\", \"quarter\", \"month\", \"week\", \"day\",\n+        \"hour\", \"minute\", \"second\", \"millisecond\", \"microsecond\",\n+        \"nanosecond\".\n+    week_starts_monday : bool, default True\n+        If True, weeks start on Monday; if False, on Sunday.\n+    ceil_is_strictly_greater : bool, default False\n+        If True, ceil returns a rounded value that is strictly greater than\n+        the\n+        input. For example: ceiling 1970-01-01T00:00:00 to 3 hours would\n+        yield 1970-01-01T03:00:00 if set to True and 1970-01-01T00:00:00\n+        if set to False.\n+        This applies to the ceil_temporal function only.\n+    calendar_based_origin : bool, default False\n+        By default, the origin is 1970-01-01T00:00:00. By setting this to\n+        True,\n+        rounding origin will be beginning of one less precise calendar unit.\n+        E.g.: rounding to hours will use beginning of day as origin.\n+\n+        By default time is rounded to a multiple of units since\n+        1970-01-01T00:00:00. By setting calendar_based_origin to true,\n+        time will be rounded to number of units since the last greater\n+        calendar unit.\n+        For example: rounding to multiple of days since the beginning of the\n+        month or to hours since the beginning of the day.\n+        Exceptions: week and quarter are not used as greater units,\n+        therefore days will be rounded to the beginning of the month not\n+        week. Greater unit of week is a year.\n+        Note that ceiling and rounding might change sorting order of an array\n+        near greater unit change. For example rounding YYYY-mm-dd 23:00:00 to\n+        5 hours will ceil and round to YYYY-mm-dd+1 01:00:00 and floor to\n+        YYYY-mm-dd 20:00:00. On the other hand YYYY-mm-dd+1 00:00:00 will\n+        ceil, round and floor to YYYY-mm-dd+1 00:00:00. This can break the\n+        order of an already ordered array.\n+    options : pyarrow.compute.RoundTemporalOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'ceil_temporal',\n+        pyarrow._compute.RoundTemporalOptions,\n+        options,\n+        (),\n+        multiple=multiple,\n+        unit=unit,\n+        week_starts_monday=week_starts_monday,\n+        ceil_is_strictly_greater=ceil_is_strictly_greater,\n+        calendar_based_origin=calendar_based_origin\n+    )\n+    func = pyarrow._compute.get_function('ceil_temporal')\n+\n+    if isinstance(timestamps, Expression):\n+        return Expression._call(\n+            'ceil_temporal',\n+            [timestamps],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([timestamps], _computed_options, memory_pool)\n+    )\n+\n+\n+def choose(indices, *values, memory_pool=None):\n+    \"\"\"Choose values from several arrays.\n+\n+    For each row, the value of the first argument is used as a 0-based index\n+    into the list of `values` arrays (i.e. index 0 selects the first of the\n+    `values` arrays). The output value is the corresponding value of the\n+    selected argument.\n+\n+    If an index is null, the output will be null.\n+\n+    This wraps the \"choose\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    indices : Array-like or scalar-like\n+        Argument to compute function.\n+    *values : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('choose')\n+    return (\n+        func.call([indices, *values], memory_pool=memory_pool)\n+    )\n+\n+\n+def coalesce(*values, memory_pool=None):\n+    \"\"\"Select the first non-null value.\n+\n+    Each row of the output will be the value from the first corresponding\n+        input\n+    for which the value is not null. If all inputs are null in a row, the\n+        output\n+    will be null.\n\nReview Comment:\n   That's probably from trying to keep the line length within flake8 max? We might need to \"reflow\" the text then ... (or find a way to indicate to flake8 to ignore this file)\n\n\n\n",
                    "created": "2022-08-26T13:21:27.066+0000",
                    "updated": "2022-08-26T13:21:27.066+0000",
                    "started": "2022-08-26T13:21:27.066+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803960",
                    "issueId": "13374797"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/worklog/803961",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on PR #13126:\nURL: https://github.com/apache/arrow/pull/13126#issuecomment-1228497759\n\n   @krcrouse thanks for the updates! And sorry for the slow follow-up on your responses.\r\n   \r\n   > > As far as I understand, by using the full ability of docutils, we can override _any_ section of the docstring ...\r\n   > > Do we think we will really need that full ability? Or it might in almost all cases be sufficient to just append content?\r\n   > \r\n   > I think we would want both options. Since the default documentation is pulling from the C++ library code, I think you could browse the current [generated documentation](https://arrow.apache.org/docs/python/api/compute.html) and see sections that are not useful and could be entirely overwritten. I also think the hybrid approach of creating default documentation with options to append and/or overwrite is best because it will pull in changes to the core C++ function interface automatically while preserving the manually provided improved pythonic documentation.\r\n   \r\n   (yes, to be clear my question about the need for docutils was about this (do we think appending is sufficient, or do we want the more fine grained replacement), and not to question to use of restructuredtext)\r\n   \r\n   I am personally still a bit hesitant to go the full docutils way here. I certainly see the value of the flexibility it provides, but it also does introduce quite some additional code that needs to be maintained for this. And for now, all the doc additions are pure \"append\" ones, which could be implemented with much less code (although I know it's the goal to expand the set of doc additions, of course).\r\n   \r\n   > Take, for example, the parameter definitions of [`replace_with_mask`](https://arrow.apache.org/docs/python/generated/pyarrow.compute.replace_with_mask.html#pyarrow.compute.replace_with_mask) - in the context of the still not terribly verbose description, the parameter types are incorrect and the explanation of each parameter is useless ('Argument to compute function.\")\r\n   \r\n   Yes, fully agreed that's basically useless. Those are dummy auto-generated on the python side, and the more general solution might be to actually start including argument descriptions in the C++ docs, so we can pull that as well into the python docstrings. There is a TODO about this (cc @pitrou):\r\n   \r\n   https://github.com/apache/arrow/blob/b832853ba62171d5fe5077681083fc6ea49bfd44/cpp/src/arrow/compute/function.h#L132-L135\r\n   \r\n   Although of course, if only Python would make use of those extra descriptions, we could maybe as well keep them on the python side ..\r\n   \r\n   (to be clear, I am not saying that we certainly don't want the more advanced docutils-based approach, but some input from others would be welcome)\n\n\n",
                    "created": "2022-08-26T13:35:20.771+0000",
                    "updated": "2022-08-26T13:35:20.771+0000",
                    "started": "2022-08-26T13:35:20.770+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803961",
                    "issueId": "13374797"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/worklog/803962",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on PR #13126:\nURL: https://github.com/apache/arrow/pull/13126#issuecomment-1228499621\n\n   Would we need a check in CI that ensures the generated compute file is up-to-date? (I am not directly sure how we do that in other places with generated files)\n\n\n",
                    "created": "2022-08-26T13:36:57.180+0000",
                    "updated": "2022-08-26T13:36:57.180+0000",
                    "started": "2022-08-26T13:36:57.180+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803962",
                    "issueId": "13374797"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/worklog/805037",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "krcrouse commented on code in PR #13126:\nURL: https://github.com/apache/arrow/pull/13126#discussion_r959010642\n\n\n##########\npython/docs/additions/compute/all.rst:\n##########\n@@ -0,0 +1,24 @@\n+all\n+===\n+\n+Examples\n+--------\n+\n+.. code-block:: python\n\nReview Comment:\n   So it does! I didn't realize that.\n\n\n\n",
                    "created": "2022-08-30T23:21:22.971+0000",
                    "updated": "2022-08-30T23:21:22.971+0000",
                    "started": "2022-08-30T23:21:22.971+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "805037",
                    "issueId": "13374797"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/worklog/805044",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "krcrouse commented on code in PR #13126:\nURL: https://github.com/apache/arrow/pull/13126#discussion_r959021762\n\n\n##########\npython/pyarrow/_compute_generated.py:\n##########\n@@ -0,0 +1,9381 @@\n+# File GENERATED by scripts/generate_sources.py - DO NOT EDIT.\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import pyarrow\n+import pyarrow._compute\n+from pyarrow._compute import Expression\n+\n+\n+def _handle_options(name, options_class, options, args, **kwargs):\n+    if options is not None:\n+        if isinstance(options, dict):\n+            return options_class(**options)\n+        elif isinstance(options, options_class):\n+            return options\n+        raise TypeError(\n+            \"Function {!r} expected a {} parameter, got {}\"\n+            .format(name, options_class, type(options)))\n+\n+    if args or kwargs:\n+        # Note: This check is no longer permissable\n+        # Generating function code with real signatures means that\n+        # All of the keyword arguments have default values, and so\n+        # this would always be true. As the default for the options object\n+        # is always false, the options object takes precedence if provided.\n+        #\n+        # if options is not None:\n+        #    raise TypeError(\n+        #        \"Function {!r} called with both an 'options' argument \"\n+        #        \"and additional arguments\"\n+        #        .format(name))\n+\n+        return options_class(*args, **kwargs)\n+\n+    return None\n+\n+\n+def abs(x, *, memory_pool=None):\n+    \"\"\"Calculate the absolute value of the argument element-wise.\n+\n+    Results will wrap around on integer overflow.\n+    Use function \"abs_checked\" if you want overflow\n+    to return an error.\n+\n+    This wraps the \"abs\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('abs')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'abs',\n+            [x]\n+        )\n+\n+    return (\n+        func.call([x], memory_pool=memory_pool)\n+    )\n+\n+\n+def abs_checked(x, *, memory_pool=None):\n+    \"\"\"Calculate the absolute value of the argument element-wise.\n+\n+    This function returns an error on overflow.  For a variant that\n+    doesn't fail on overflow, use function \"abs\".\n+\n+    This wraps the \"abs_checked\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('abs_checked')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'abs_checked',\n+            [x]\n+        )\n+\n+    return (\n+        func.call([x], memory_pool=memory_pool)\n+    )\n+\n+\n+def acos(x, *, memory_pool=None):\n+    \"\"\"Compute the inverse cosine.\n+\n+    NaN is returned for invalid input values;\n+    to raise an error instead, see \"acos_checked\".\n+\n+    This wraps the \"acos\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('acos')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'acos',\n+            [x]\n+        )\n+\n+    return (\n+        func.call([x], memory_pool=memory_pool)\n+    )\n+\n+\n+def acos_checked(x, *, memory_pool=None):\n+    \"\"\"Compute the inverse cosine.\n+\n+    Invalid input values raise an error;\n+    to return NaN instead, see \"acos\".\n+\n+    This wraps the \"acos_checked\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('acos_checked')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'acos_checked',\n+            [x]\n+        )\n+\n+    return (\n+        func.call([x], memory_pool=memory_pool)\n+    )\n+\n+\n+def add(x, y, *, memory_pool=None):\n+    \"\"\"Add the arguments element-wise.\n+\n+    Results will wrap around on integer overflow.\n+    Use function \"add_checked\" if you want overflow\n+    to return an error.\n+\n+    This wraps the \"add\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('add')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'add',\n+            [x, y]\n+        )\n+\n+    return (\n+        func.call([x, y], memory_pool=memory_pool)\n+    )\n+\n+\n+def add_checked(x, y, *, memory_pool=None):\n+    \"\"\"Add the arguments element-wise.\n+\n+    This function returns an error on overflow.  For a variant that\n+    doesn't fail on overflow, use function \"add\".\n+\n+    This wraps the \"add_checked\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('add_checked')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'add_checked',\n+            [x, y]\n+        )\n+\n+    return (\n+        func.call([x, y], memory_pool=memory_pool)\n+    )\n+\n+\n+def all(array, *, skip_nulls=True, min_count=1, options=None,\n+        memory_pool=None):\n+    \"\"\"Test whether all elements in a boolean array evaluate to true.\n+\n+    Null values are ignored by default.\n+    If the `skip_nulls` option is set to false, then Kleene logic is used.\n+    See \"kleene_and\" for more details on Kleene logic.\n+\n+    This wraps the \"all\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    array : Array-like\n+        Argument to compute function.\n+    skip_nulls : bool, default True\n+        Whether to skip (ignore) nulls in the input.\n+        If False, any null in the input forces the output to null.\n+    min_count : int, default 1\n+        Minimum number of non-null values in the input.  If the number\n+        of non-null values is below `min_count`, the output is null.\n+    options : pyarrow.compute.ScalarAggregateOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+\n+\n+\n+    Examples\n+    --------\n+    >>> import pyarrow as pa\n+    >>> import pyarrow.compute as pc\n+    >>> arr = pa.array([True, True, None, False, True])\n+    >>> pc.all(arr)\n+    <pyarrow.BooleanScalar: False>\n+    >>> arr = pa.array([True, True, None, True, None, None])\n+    >>> pc.all(arr)\n+    <pyarrow.BooleanScalar: True>\n+    >>> pc.all(arr, skip_nulls = False)\n+    <pyarrow.BooleanScalar: None>\n+    >>> pc.all(arr, min_count = 4)\n+    <pyarrow.BooleanScalar: None>\n+    >>> pc.all(arr, min_count = 10)\n+    <pyarrow.BooleanScalar: None>\n+    >>> pc.all(arr, min_count = 2)\n+    <pyarrow.BooleanScalar: True>\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'all',\n+        pyarrow._compute.ScalarAggregateOptions,\n+        options,\n+        (),\n+        skip_nulls=skip_nulls,\n+        min_count=min_count\n+    )\n+    func = pyarrow._compute.get_function('all')\n+\n+    if isinstance(array, Expression):\n+        return Expression._call(\n+            'all',\n+            [array],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([array], _computed_options, memory_pool)\n+    )\n+\n+\n+def and_(x, y, *, memory_pool=None):\n+    \"\"\"Logical 'and' boolean values.\n+\n+    When a null is encountered in either input, a null is output.\n+    For a different null behavior, see function \"and_kleene\".\n+\n+    This wraps the \"and\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('and')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'and_',\n+            [x, y]\n+        )\n+\n+    return (\n+        func.call([x, y], memory_pool=memory_pool)\n+    )\n+\n+\n+def and_kleene(x, y, *, memory_pool=None):\n+    \"\"\"Logical 'and' boolean values (Kleene logic).\n+\n+    This function behaves as follows with nulls:\n+\n+    - true and null = null\n+    - null and true = null\n+    - false and null = false\n+    - null and false = false\n+    - null and null = null\n+\n+    In other words, in this context a null value really means \"unknown\",\n+    and an unknown value 'and' false is always false.\n+    For a different null behavior, see function \"and\".\n+\n+    This wraps the \"and_kleene\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('and_kleene')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'and_kleene',\n+            [x, y]\n+        )\n+\n+    return (\n+        func.call([x, y], memory_pool=memory_pool)\n+    )\n+\n+\n+def and_not(x, y, *, memory_pool=None):\n+    \"\"\"Logical 'and not' boolean values.\n+\n+    When a null is encountered in either input, a null is output.\n+    For a different null behavior, see function \"and_not_kleene\".\n+\n+    This wraps the \"and_not\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('and_not')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'and_not',\n+            [x, y]\n+        )\n+\n+    return (\n+        func.call([x, y], memory_pool=memory_pool)\n+    )\n+\n+\n+def and_not_kleene(x, y, *, memory_pool=None):\n+    \"\"\"Logical 'and not' boolean values (Kleene logic).\n+\n+    This function behaves as follows with nulls:\n+\n+    - true and null = null\n+    - null and false = null\n+    - false and null = false\n+    - null and true = false\n+    - null and null = null\n+\n+    In other words, in this context a null value really means \"unknown\",\n+    and an unknown value 'and not' true is always false, as is false\n+    'and not' an unknown value.\n+    For a different null behavior, see function \"and_not\".\n+\n+    This wraps the \"and_not_kleene\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('and_not_kleene')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'and_not_kleene',\n+            [x, y]\n+        )\n+\n+    return (\n+        func.call([x, y], memory_pool=memory_pool)\n+    )\n+\n+\n+def any(array, *, skip_nulls=True, min_count=1, options=None,\n+        memory_pool=None):\n+    \"\"\"Test whether any element in a boolean array evaluates to true.\n+\n+    Null values are ignored by default.\n+    If the `skip_nulls` option is set to false, then Kleene logic is used.\n+    See \"kleene_or\" for more details on Kleene logic.\n+\n+    This wraps the \"any\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    array : Array-like\n+        Argument to compute function.\n+    skip_nulls : bool, default True\n+        Whether to skip (ignore) nulls in the input.\n+        If False, any null in the input forces the output to null.\n+    min_count : int, default 1\n+        Minimum number of non-null values in the input.  If the number\n+        of non-null values is below `min_count`, the output is null.\n+    options : pyarrow.compute.ScalarAggregateOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+\n+\n+\n+    Examples\n+    --------\n+    >>> import pyarrow as pa\n+    >>> import pyarrow.compute as pc\n+    >>> arr = pa.array([True, True, None, False, True])\n+    >>> pc.any(arr)\n+    <pyarrow.BooleanScalar: True>\n+    >>> pc.any(arr, min_count = 4)\n+    <pyarrow.BooleanScalar: True>\n+    >>> pc.any(arr, min_count = len(arr))\n+    <pyarrow.BooleanScalar: None>\n+    >>> arr = pa.array([False, False, None, False, True])\n+    >>> pc.any(arr)\n+    <pyarrow.BooleanScalar: True>\n+    >>> pc.any(arr, min_count = 2)\n+    <pyarrow.BooleanScalar: True>\n+    >>> pc.any(arr, min_count = len(arr))\n+    <pyarrow.BooleanScalar: None>\n+    >>> pc.any(arr, skip_nulls = False)\n+    <pyarrow.BooleanScalar: True>\n+    >>> pc.any([False,None], skip_nulls = False)\n+    <pyarrow.BooleanScalar: None>\n+    >>> pc.any([False,None], skip_nulls = True)\n+    <pyarrow.BooleanScalar: False>\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'any',\n+        pyarrow._compute.ScalarAggregateOptions,\n+        options,\n+        (),\n+        skip_nulls=skip_nulls,\n+        min_count=min_count\n+    )\n+    func = pyarrow._compute.get_function('any')\n+\n+    if isinstance(array, Expression):\n+        return Expression._call(\n+            'any',\n+            [array],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([array], _computed_options, memory_pool)\n+    )\n+\n+\n+def approximate_median(array, *, skip_nulls=True, min_count=1, options=None,\n+                       memory_pool=None):\n+    \"\"\"Approximate median of a numeric array with T-Digest algorithm.\n+\n+    Nulls and NaNs are ignored.\n+    A null scalar is returned if there is no valid data point.\n+\n+    This wraps the \"approximate_median\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    array : Array-like\n+        Argument to compute function.\n+    skip_nulls : bool, default True\n+        Whether to skip (ignore) nulls in the input.\n+        If False, any null in the input forces the output to null.\n+    min_count : int, default 1\n+        Minimum number of non-null values in the input.  If the number\n+        of non-null values is below `min_count`, the output is null.\n+    options : pyarrow.compute.ScalarAggregateOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'approximate_median',\n+        pyarrow._compute.ScalarAggregateOptions,\n+        options,\n+        (),\n+        skip_nulls=skip_nulls,\n+        min_count=min_count\n+    )\n+    func = pyarrow._compute.get_function('approximate_median')\n+\n+    if isinstance(array, Expression):\n+        return Expression._call(\n+            'approximate_median',\n+            [array],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([array], _computed_options, memory_pool)\n+    )\n+\n+\n+def array_filter(array, selection_filter, null_selection_behavior='drop', *,\n+                 options=None, memory_pool=None):\n+    \"\"\"Filter with a boolean selection filter.\n+\n+    The output is populated with values from the input `array` at positions\n+    where the selection filter is non-zero.  Nulls in the selection filter\n+    are handled based on FilterOptions.\n+\n+    This wraps the \"array_filter\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    array : Array-like\n+        Argument to compute function.\n+    selection_filter : Array-like\n+        Argument to compute function.\n+    null_selection_behavior : str, default \"drop\"\n+        How to handle nulls in the selection filter.\n+        Accepted values are \"drop\", \"emit_null\".\n+    options : pyarrow.compute.FilterOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'array_filter',\n+        pyarrow._compute.FilterOptions,\n+        options,\n+        (),\n+        null_selection_behavior=null_selection_behavior\n+    )\n+    func = pyarrow._compute.get_function('array_filter')\n+\n+    if isinstance(array, Expression):\n+        return Expression._call(\n+            'array_filter',\n+            [array, selection_filter],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([array, selection_filter], _computed_options, memory_pool)\n+    )\n+\n+\n+def array_sort_indices(array, order='ascending', *, null_placement='at_end',\n+                       options=None, memory_pool=None):\n+    \"\"\"Return the indices that would sort an array.\n+\n+    This function computes an array of indices that define a stable sort\n+    of the input array.  By default, Null values are considered greater\n+    than any other value and are therefore sorted at the end of the array.\n+    For floating-point types, NaNs are considered greater than any\n+    other non-null value, but smaller than null values.\n+\n+    The handling of nulls and NaNs can be changed in ArraySortOptions.\n+\n+    This wraps the \"array_sort_indices\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    array : Array-like\n+        Argument to compute function.\n+    order : str, default \"ascending\"\n+        Which order to sort values in.\n+        Accepted values are \"ascending\", \"descending\".\n+    null_placement : str, default \"at_end\"\n+        Where nulls in the input should be sorted.\n+        Accepted values are \"at_start\", \"at_end\".\n+    options : pyarrow.compute.ArraySortOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'array_sort_indices',\n+        pyarrow._compute.ArraySortOptions,\n+        options,\n+        (),\n+        order=order,\n+        null_placement=null_placement\n+    )\n+    func = pyarrow._compute.get_function('array_sort_indices')\n+\n+    if isinstance(array, Expression):\n+        return Expression._call(\n+            'array_sort_indices',\n+            [array],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([array], _computed_options, memory_pool)\n+    )\n+\n+\n+def array_take(array, indices, *, boundscheck=True, options=None,\n+               memory_pool=None):\n+    \"\"\"Select values from an array based on indices from another array.\n+\n+    The output is populated with values from the input array at positions\n+    given by `indices`.  Nulls in `indices` emit null in the output.\n+\n+    This wraps the \"array_take\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    array : Array-like\n+        Argument to compute function.\n+    indices : Array-like\n+        Argument to compute function.\n+    boundscheck : boolean, default True\n+        Whether to check indices are within bounds. If False and an\n+        index is out of boundes, behavior is undefined (the process\n+        may crash).\n+    options : pyarrow.compute.TakeOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'array_take',\n+        pyarrow._compute.TakeOptions,\n+        options,\n+        (),\n+        boundscheck=boundscheck\n+    )\n+    func = pyarrow._compute.get_function('array_take')\n+\n+    if isinstance(array, Expression):\n+        return Expression._call(\n+            'array_take',\n+            [array, indices],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([array, indices], _computed_options, memory_pool)\n+    )\n+\n+\n+def ascii_capitalize(strings, *, memory_pool=None):\n+    \"\"\"Capitalize the first character of ASCII input.\n+\n+    For each string in `strings`, return a capitalized version.\n+\n+    This function assumes the input is fully ASCII.  If it may contain\n+    non-ASCII characters, use \"utf8_capitalize\" instead.\n+\n+    This wraps the \"ascii_capitalize\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_capitalize')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_capitalize',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_center(strings, width=None, padding=' ', *, options=None,\n+                 memory_pool=None):\n+    \"\"\"Center strings by padding with a given character.\n+\n+    For each string in `strings`, emit a centered string by padding both\n+        sides\n+    with the given ASCII character.\n+    Null values emit null.\n+\n+    This wraps the \"ascii_center\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    width : int\n+        Desired string length.\n+    padding : str, default \" \"\n+        What to pad the string with. Should be one byte or codepoint.\n+    options : pyarrow.compute.PadOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'ascii_center',\n+        pyarrow._compute.PadOptions,\n+        options,\n+        (),\n+        width=width,\n+        padding=padding\n+    )\n+    func = pyarrow._compute.get_function('ascii_center')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_center',\n+            [strings],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([strings], _computed_options, memory_pool)\n+    )\n+\n+\n+def ascii_is_alnum(strings, *, memory_pool=None):\n+    \"\"\"Classify strings as ASCII alphanumeric.\n+\n+    For each string in `strings`, emit true iff the string is non-empty\n+    and consists only of alphanumeric ASCII characters.  Null strings emit\n+        null.\n+\n+    This wraps the \"ascii_is_alnum\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_is_alnum')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_is_alnum',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_is_alpha(strings, *, memory_pool=None):\n+    \"\"\"Classify strings as ASCII alphabetic.\n+\n+    For each string in `strings`, emit true iff the string is non-empty\n+    and consists only of alphabetic ASCII characters.  Null strings emit\n+        null.\n+\n+    This wraps the \"ascii_is_alpha\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_is_alpha')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_is_alpha',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_is_decimal(strings, *, memory_pool=None):\n+    \"\"\"Classify strings as ASCII decimal.\n+\n+    For each string in `strings`, emit true iff the string is non-empty\n+    and consists only of decimal ASCII characters.  Null strings emit null.\n+\n+    This wraps the \"ascii_is_decimal\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_is_decimal')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_is_decimal',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_is_lower(strings, *, memory_pool=None):\n+    \"\"\"Classify strings as ASCII lowercase.\n+\n+    For each string in `strings`, emit true iff the string is non-empty\n+    and consists only of lowercase ASCII characters.  Null strings emit null.\n+\n+    This wraps the \"ascii_is_lower\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_is_lower')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_is_lower',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_is_printable(strings, *, memory_pool=None):\n+    \"\"\"Classify strings as ASCII printable.\n+\n+    For each string in `strings`, emit true iff the string is non-empty\n+    and consists only of printable ASCII characters.  Null strings emit null.\n+\n+    This wraps the \"ascii_is_printable\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_is_printable')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_is_printable',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_is_space(strings, *, memory_pool=None):\n+    \"\"\"Classify strings as ASCII whitespace.\n+\n+    For each string in `strings`, emit true iff the string is non-empty\n+    and consists only of whitespace ASCII characters.  Null strings emit\n+        null.\n+\n+    This wraps the \"ascii_is_space\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_is_space')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_is_space',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_is_title(strings, *, memory_pool=None):\n+    \"\"\"Classify strings as ASCII titlecase.\n+\n+    For each string in `strings`, emit true iff the string is title-cased,\n+    i.e. it has at least one cased character, each uppercase character\n+    follows an uncased character, and each lowercase character follows\n+    an uppercase character.\n+\n+    This wraps the \"ascii_is_title\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_is_title')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_is_title',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_is_upper(strings, *, memory_pool=None):\n+    \"\"\"Classify strings as ASCII uppercase.\n+\n+    For each string in `strings`, emit true iff the string is non-empty\n+    and consists only of uppercase ASCII characters.  Null strings emit null.\n+\n+    This wraps the \"ascii_is_upper\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_is_upper')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_is_upper',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_lower(strings, *, memory_pool=None):\n+    \"\"\"Transform ASCII input to lowercase.\n+\n+    For each string in `strings`, return a lowercase version.\n+\n+    This function assumes the input is fully ASCII.  If it may contain\n+    non-ASCII characters, use \"utf8_lower\" instead.\n+\n+    This wraps the \"ascii_lower\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_lower')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_lower',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_lpad(strings, width=None, padding=' ', *, options=None,\n+               memory_pool=None):\n+    \"\"\"Right-align strings by padding with a given character.\n+\n+    For each string in `strings`, emit a right-aligned string by prepending\n+    the given ASCII character.\n+    Null values emit null.\n+\n+    This wraps the \"ascii_lpad\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    width : int\n+        Desired string length.\n+    padding : str, default \" \"\n+        What to pad the string with. Should be one byte or codepoint.\n+    options : pyarrow.compute.PadOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'ascii_lpad',\n+        pyarrow._compute.PadOptions,\n+        options,\n+        (),\n+        width=width,\n+        padding=padding\n+    )\n+    func = pyarrow._compute.get_function('ascii_lpad')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_lpad',\n+            [strings],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([strings], _computed_options, memory_pool)\n+    )\n+\n+\n+def ascii_ltrim(strings, characters=None, *, options=None, memory_pool=None):\n+    \"\"\"Trim leading characters.\n+\n+    For each string in `strings`, remove any leading characters\n+    from the `characters` option (as given in TrimOptions).\n+    Null values emit null.\n+    Both the `strings` and the `characters` are interpreted as\n+    ASCII; to trim non-ASCII characters, use `utf8_ltrim`.\n+\n+    This wraps the \"ascii_ltrim\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    characters : str\n+        Individual characters to be trimmed from the string.\n+    options : pyarrow.compute.TrimOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'ascii_ltrim',\n+        pyarrow._compute.TrimOptions,\n+        options,\n+        (),\n+        characters=characters\n+    )\n+    func = pyarrow._compute.get_function('ascii_ltrim')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_ltrim',\n+            [strings],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([strings], _computed_options, memory_pool)\n+    )\n+\n+\n+def ascii_ltrim_whitespace(strings, *, memory_pool=None):\n+    \"\"\"Trim leading ASCII whitespace characters.\n+\n+    For each string in `strings`, emit a string with leading ASCII whitespace\n+    characters removed.  Use `utf8_ltrim_whitespace` to trim leading Unicode\n+    whitespace characters. Null values emit null.\n+\n+    This wraps the \"ascii_ltrim_whitespace\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_ltrim_whitespace')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_ltrim_whitespace',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_reverse(strings, *, memory_pool=None):\n+    \"\"\"Reverse ASCII input.\n+\n+    For each ASCII string in `strings`, return a reversed version.\n+\n+    This function assumes the input is fully ASCII.  If it may contain\n+    non-ASCII characters, use \"utf8_reverse\" instead.\n+\n+    This wraps the \"ascii_reverse\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_reverse')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_reverse',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_rpad(strings, width=None, padding=' ', *, options=None,\n+               memory_pool=None):\n+    \"\"\"Left-align strings by padding with a given character.\n+\n+    For each string in `strings`, emit a left-aligned string by appending\n+    the given ASCII character.\n+    Null values emit null.\n+\n+    This wraps the \"ascii_rpad\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    width : int\n+        Desired string length.\n+    padding : str, default \" \"\n+        What to pad the string with. Should be one byte or codepoint.\n+    options : pyarrow.compute.PadOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'ascii_rpad',\n+        pyarrow._compute.PadOptions,\n+        options,\n+        (),\n+        width=width,\n+        padding=padding\n+    )\n+    func = pyarrow._compute.get_function('ascii_rpad')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_rpad',\n+            [strings],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([strings], _computed_options, memory_pool)\n+    )\n+\n+\n+def ascii_rtrim(strings, characters=None, *, options=None, memory_pool=None):\n+    \"\"\"Trim trailing characters.\n+\n+    For each string in `strings`, remove any trailing characters\n+    from the `characters` option (as given in TrimOptions).\n+    Null values emit null.\n+    Both the `strings` and the `characters` are interpreted as\n+    ASCII; to trim non-ASCII characters, use `utf8_rtrim`.\n+\n+    This wraps the \"ascii_rtrim\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    characters : str\n+        Individual characters to be trimmed from the string.\n+    options : pyarrow.compute.TrimOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'ascii_rtrim',\n+        pyarrow._compute.TrimOptions,\n+        options,\n+        (),\n+        characters=characters\n+    )\n+    func = pyarrow._compute.get_function('ascii_rtrim')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_rtrim',\n+            [strings],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([strings], _computed_options, memory_pool)\n+    )\n+\n+\n+def ascii_rtrim_whitespace(strings, *, memory_pool=None):\n+    \"\"\"Trim trailing ASCII whitespace characters.\n+\n+    For each string in `strings`, emit a string with trailing ASCII\n+        whitespace\n+    characters removed. Use `utf8_rtrim_whitespace` to trim trailing Unicode\n+    whitespace characters. Null values emit null.\n+\n+    This wraps the \"ascii_rtrim_whitespace\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_rtrim_whitespace')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_rtrim_whitespace',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_split_whitespace(strings, *, max_splits=None, reverse=False,\n+                           options=None,\n+                           memory_pool=None):\n+    \"\"\"Split string according to any ASCII whitespace.\n+\n+    Split each string according any non-zero length sequence of ASCII\n+    whitespace characters.  The output for each string input is a list\n+    of strings.\n+\n+    The maximum number of splits and direction of splitting\n+    (forward, reverse) can optionally be defined in SplitOptions.\n+\n+    This wraps the \"ascii_split_whitespace\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    max_splits : int or None, default None\n+        Maximum number of splits for each input value (unlimited if None).\n+    reverse : bool, default False\n+        Whether to start splitting from the end of each input value.\n+        This only has an effect if `max_splits` is not None.\n+    options : pyarrow.compute.SplitOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'ascii_split_whitespace',\n+        pyarrow._compute.SplitOptions,\n+        options,\n+        (),\n+        max_splits=max_splits,\n+        reverse=reverse\n+    )\n+    func = pyarrow._compute.get_function('ascii_split_whitespace')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_split_whitespace',\n+            [strings],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([strings], _computed_options, memory_pool)\n+    )\n+\n+\n+def ascii_swapcase(strings, *, memory_pool=None):\n+    \"\"\"Transform ASCII input by inverting casing.\n+\n+    For each string in `strings`, return a string with opposite casing.\n+\n+    This function assumes the input is fully ASCII.  If it may contain\n+    non-ASCII characters, use \"utf8_swapcase\" instead.\n+\n+    This wraps the \"ascii_swapcase\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_swapcase')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_swapcase',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_title(strings, *, memory_pool=None):\n+    \"\"\"Titlecase each word of ASCII input.\n+\n+    For each string in `strings`, return a titlecased version.\n+    Each word in the output will start with an uppercase character and its\n+    remaining characters will be lowercase.\n+\n+    This function assumes the input is fully ASCII.  If it may contain\n+    non-ASCII characters, use \"utf8_title\" instead.\n+\n+    This wraps the \"ascii_title\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_title')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_title',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_trim(strings, characters=None, *, options=None, memory_pool=None):\n+    \"\"\"Trim leading and trailing characters.\n+\n+    For each string in `strings`, remove any leading or trailing characters\n+    from the `characters` option (as given in TrimOptions).\n+    Null values emit null.\n+    Both the `strings` and the `characters` are interpreted as\n+    ASCII; to trim non-ASCII characters, use `utf8_trim`.\n+\n+    This wraps the \"ascii_trim\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    characters : str\n+        Individual characters to be trimmed from the string.\n+    options : pyarrow.compute.TrimOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'ascii_trim',\n+        pyarrow._compute.TrimOptions,\n+        options,\n+        (),\n+        characters=characters\n+    )\n+    func = pyarrow._compute.get_function('ascii_trim')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_trim',\n+            [strings],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([strings], _computed_options, memory_pool)\n+    )\n+\n+\n+def ascii_trim_whitespace(strings, *, memory_pool=None):\n+    \"\"\"Trim leading and trailing ASCII whitespace characters.\n+\n+    For each string in `strings`, emit a string with leading and trailing\n+        ASCII\n+    whitespace characters removed. Use `utf8_trim_whitespace` to trim Unicode\n+    whitespace characters. Null values emit null.\n+\n+    This wraps the \"ascii_trim_whitespace\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_trim_whitespace')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_trim_whitespace',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def ascii_upper(strings, *, memory_pool=None):\n+    \"\"\"Transform ASCII input to uppercase.\n+\n+    For each string in `strings`, return an uppercase version.\n+\n+    This function assumes the input is fully ASCII.  It it may contain\n+    non-ASCII characters, use \"utf8_upper\" instead.\n+\n+    This wraps the \"ascii_upper\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ascii_upper')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'ascii_upper',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def asin(x, *, memory_pool=None):\n+    \"\"\"Compute the inverse sine.\n+\n+    NaN is returned for invalid input values;\n+    to raise an error instead, see \"asin_checked\".\n+\n+    This wraps the \"asin\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('asin')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'asin',\n+            [x]\n+        )\n+\n+    return (\n+        func.call([x], memory_pool=memory_pool)\n+    )\n+\n+\n+def asin_checked(x, *, memory_pool=None):\n+    \"\"\"Compute the inverse sine.\n+\n+    Invalid input values raise an error;\n+    to return NaN instead, see \"asin\".\n+\n+    This wraps the \"asin_checked\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('asin_checked')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'asin_checked',\n+            [x]\n+        )\n+\n+    return (\n+        func.call([x], memory_pool=memory_pool)\n+    )\n+\n+\n+def assume_timezone(timestamps, timezone=None, *, ambiguous='raise',\n+                    nonexistent='raise', options=None,\n+                    memory_pool=None):\n+    \"\"\"Convert naive timestamp to timezone-aware timestamp.\n+\n+    Input timestamps are assumed to be relative to the timezone given in the\n+    `timezone` option. They are converted to UTC-relative timestamps and\n+    the output type has its timezone set to the value of the `timezone`\n+    option. Null values emit null.\n+    This function is meant to be used when an external system produces\n+    \"timezone-naive\" timestamps which need to be converted to\n+    \"timezone-aware\" timestamps. An error is returned if the timestamps\n+    already have a defined timezone.\n+\n+    This wraps the \"assume_timezone\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    timestamps : Array-like or scalar-like\n+        Argument to compute function.\n+    timezone : str\n+        Timezone to assume for the input.\n+    ambiguous : str, default \"raise\"\n+        How to handle timestamps that are ambiguous in the assumed timezone.\n+        Accepted values are \"raise\", \"earliest\", \"latest\".\n+    nonexistent : str, default \"raise\"\n+        How to handle timestamps that don't exist in the assumed timezone.\n+        Accepted values are \"raise\", \"earliest\", \"latest\".\n+    options : pyarrow.compute.AssumeTimezoneOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'assume_timezone',\n+        pyarrow._compute.AssumeTimezoneOptions,\n+        options,\n+        (),\n+        timezone=timezone,\n+        ambiguous=ambiguous,\n+        nonexistent=nonexistent\n+    )\n+    func = pyarrow._compute.get_function('assume_timezone')\n+\n+    if isinstance(timestamps, Expression):\n+        return Expression._call(\n+            'assume_timezone',\n+            [timestamps],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([timestamps], _computed_options, memory_pool)\n+    )\n+\n+\n+def atan(x, *, memory_pool=None):\n+    \"\"\"Compute the inverse tangent of x.\n+\n+    The return value is in the range [-pi/2, pi/2];\n+    for a full return range [-pi, pi], see \"atan2\".\n+\n+    This wraps the \"atan\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('atan')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'atan',\n+            [x]\n+        )\n+\n+    return (\n+        func.call([x], memory_pool=memory_pool)\n+    )\n+\n+\n+def atan2(y, x, *, memory_pool=None):\n+    \"\"\"Compute the inverse tangent of y/x.\n+\n+    The return value is in the range [-pi, pi].\n+\n+    This wraps the \"atan2\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('atan2')\n+\n+    if isinstance(y, Expression):\n+        return Expression._call(\n+            'atan2',\n+            [y, x]\n+        )\n+\n+    return (\n+        func.call([y, x], memory_pool=memory_pool)\n+    )\n+\n+\n+def binary_join(strings, separator, *, memory_pool=None):\n+    \"\"\"Join a list of strings together with a separator.\n+\n+    Concatenate the strings in `list`. The `separator` is inserted\n+    between each given string.\n+    Any null input and any null `list` element emits a null output.\n+\n+    This wraps the \"binary_join\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    separator : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('binary_join')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'binary_join',\n+            [strings, separator]\n+        )\n+\n+    return (\n+        func.call([strings, separator], memory_pool=memory_pool)\n+    )\n+\n+\n+def binary_join_element_wise(*strings, null_handling='emit_null',\n+                             null_replacement='',\n+                             options=None,\n+                             memory_pool=None):\n+    \"\"\"Join string arguments together, with the last argument as separator.\n+\n+    Concatenate the `strings` except for the last one. The last argument\n+    in `strings` is inserted between each given string.\n+    Any null separator element emits a null output. Null elements either\n+    emit a null (the default), are skipped, or replaced with a given string.\n+\n+    This wraps the \"binary_join_element_wise\" compute function in the Arrow\n+        C++ library.\n+\n+    Parameters\n+    ----------\n+    *strings : Array-like or scalar-like\n+        Argument to compute function.\n+    null_handling : str, default \"emit_null\"\n+        How to handle null values in the inputs.\n+        Accepted values are \"emit_null\", \"skip\", \"replace\".\n+    null_replacement : str, default \"\"\n+        Replacement string to emit for null inputs if `null_handling`\n+        is \"replace\".\n+    options : pyarrow.compute.JoinOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'binary_join_element_wise',\n+        pyarrow._compute.JoinOptions,\n+        options,\n+        (),\n+        null_handling=null_handling,\n+        null_replacement=null_replacement\n+    )\n+    func = pyarrow._compute.get_function('binary_join_element_wise')\n+    return (\n+        func.call([*strings], _computed_options, memory_pool)\n+    )\n+\n+\n+def binary_length(strings, *, memory_pool=None):\n+    \"\"\"Compute string lengths.\n+\n+    For each string in `strings`, emit its length of bytes.\n+    Null values emit null.\n+\n+    This wraps the \"binary_length\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('binary_length')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'binary_length',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def binary_repeat(strings, num_repeats, *, memory_pool=None):\n+    \"\"\"Repeat a binary string.\n+\n+    For each binary string in `strings`, return a replicated version.\n+\n+    This wraps the \"binary_repeat\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    num_repeats : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('binary_repeat')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'binary_repeat',\n+            [strings, num_repeats]\n+        )\n+\n+    return (\n+        func.call([strings, num_repeats], memory_pool=memory_pool)\n+    )\n+\n+\n+def binary_replace_slice(strings, start=None, stop=None, replacement=None, *,\n+                         options=None,\n+                         memory_pool=None):\n+    \"\"\"Replace a slice of a binary string.\n+\n+    For each string in `strings`, replace a slice of the string defined by\n+        `start`\n+    and `stop` indices with the given `replacement`. `start` is inclusive\n+    and `stop` is exclusive, and both are measured in bytes.\n+    Null values emit null.\n+\n+    This wraps the \"binary_replace_slice\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    start : int\n+        Index to start slicing at (inclusive).\n+    stop : int\n+        Index to stop slicing at (exclusive).\n+    replacement : str\n+        What to replace the slice with.\n+    options : pyarrow.compute.ReplaceSliceOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'binary_replace_slice',\n+        pyarrow._compute.ReplaceSliceOptions,\n+        options,\n+        (),\n+        start=start,\n+        stop=stop,\n+        replacement=replacement\n+    )\n+    func = pyarrow._compute.get_function('binary_replace_slice')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'binary_replace_slice',\n+            [strings],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([strings], _computed_options, memory_pool)\n+    )\n+\n+\n+def binary_reverse(strings, *, memory_pool=None):\n+    \"\"\"Reverse binary input.\n+\n+    For each binary string in `strings`, return a reversed version.\n+\n+    This function reverses the binary data at a byte-level.\n+\n+    This wraps the \"binary_reverse\" compute function in the Arrow C++\n+        library.\n+\n+    Parameters\n+    ----------\n+    strings : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('binary_reverse')\n+\n+    if isinstance(strings, Expression):\n+        return Expression._call(\n+            'binary_reverse',\n+            [strings]\n+        )\n+\n+    return (\n+        func.call([strings], memory_pool=memory_pool)\n+    )\n+\n+\n+def bit_wise_and(x, y, *, memory_pool=None):\n+    \"\"\"Bit-wise AND the arguments element-wise.\n+\n+    Null values return null.\n+\n+    This wraps the \"bit_wise_and\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('bit_wise_and')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'bit_wise_and',\n+            [x, y]\n+        )\n+\n+    return (\n+        func.call([x, y], memory_pool=memory_pool)\n+    )\n+\n+\n+def bit_wise_not(x, *, memory_pool=None):\n+    \"\"\"Bit-wise negate the arguments element-wise.\n+\n+    Null values return null.\n+\n+    This wraps the \"bit_wise_not\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('bit_wise_not')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'bit_wise_not',\n+            [x]\n+        )\n+\n+    return (\n+        func.call([x], memory_pool=memory_pool)\n+    )\n+\n+\n+def bit_wise_or(x, y, *, memory_pool=None):\n+    \"\"\"Bit-wise OR the arguments element-wise.\n+\n+    Null values return null.\n+\n+    This wraps the \"bit_wise_or\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('bit_wise_or')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'bit_wise_or',\n+            [x, y]\n+        )\n+\n+    return (\n+        func.call([x, y], memory_pool=memory_pool)\n+    )\n+\n+\n+def bit_wise_xor(x, y, *, memory_pool=None):\n+    \"\"\"Bit-wise XOR the arguments element-wise.\n+\n+    Null values return null.\n+\n+    This wraps the \"bit_wise_xor\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    y : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('bit_wise_xor')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'bit_wise_xor',\n+            [x, y]\n+        )\n+\n+    return (\n+        func.call([x, y], memory_pool=memory_pool)\n+    )\n+\n+\n+def case_when(cond, *cases, memory_pool=None):\n+    \"\"\"Choose values based on multiple conditions.\n+\n+    `cond` must be a struct of Boolean values. `cases` can be a mix\n+    of scalar and array arguments (of any type, but all must be the\n+    same type or castable to a common type), with either exactly one\n+    datum per child of `cond`, or one more `cases` than children of\n+    `cond` (in which case we have an \"else\" value).\n+\n+    Each row of the output will be the corresponding value of the\n+    first datum in `cases` for which the corresponding child of `cond`\n+    is true, or otherwise the \"else\" value (if given), or null.\n+\n+    Essentially, this implements a switch-case or if-else, if-else...\n+        statement.\n+\n+    This wraps the \"case_when\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    cond : Array-like or scalar-like\n+        Argument to compute function.\n+    *cases : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('case_when')\n+    return (\n+        func.call([cond, *cases], memory_pool=memory_pool)\n+    )\n+\n+\n+def cast(input, target_type=None, *, allow_int_overflow=None,\n+         allow_time_truncate=None, allow_time_overflow=None,\n+         allow_decimal_truncate=None, allow_float_truncate=None,\n+         allow_invalid_utf8=None, options=None, memory_pool=None):\n+    \"\"\"Cast values to another data type.\n+\n+    Behavior when values wouldn't fit in the target type\n+    can be controlled through CastOptions.\n+\n+    This wraps the \"cast\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    input : Array-like or scalar-like\n+        Argument to compute function.\n+    target_type : DataType, optional\n+        The PyArrow type to cast to.\n+    allow_int_overflow : bool, default False\n+        Whether integer overflow is allowed when casting.\n+    allow_time_truncate : bool, default False\n+        Whether time precision truncation is allowed when casting.\n+    allow_time_overflow : bool, default False\n+        Whether date/time range overflow is allowed when casting.\n+    allow_decimal_truncate : bool, default False\n+        Whether decimal precision truncation is allowed when casting.\n+    allow_float_truncate : bool, default False\n+        Whether floating-point precision truncation is allowed when casting.\n+    allow_invalid_utf8 : bool, default False\n+        Whether producing invalid utf8 data is allowed when casting.\n+    options : pyarrow.compute.CastOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'cast',\n+        pyarrow._compute.CastOptions,\n+        options,\n+        (),\n+        target_type=target_type,\n+        allow_int_overflow=allow_int_overflow,\n+        allow_time_truncate=allow_time_truncate,\n+        allow_time_overflow=allow_time_overflow,\n+        allow_decimal_truncate=allow_decimal_truncate,\n+        allow_float_truncate=allow_float_truncate,\n+        allow_invalid_utf8=allow_invalid_utf8\n+    )\n+    func = pyarrow._compute.get_function('cast')\n+\n+    if isinstance(input, Expression):\n+        return Expression._call(\n+            'cast',\n+            [input],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([input], _computed_options, memory_pool)\n+    )\n+\n+\n+def ceil(x, *, memory_pool=None):\n+    \"\"\"Round up to the nearest integer.\n+\n+    Compute the smallest integer value not less in magnitude than `x`.\n+\n+    This wraps the \"ceil\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    x : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('ceil')\n+\n+    if isinstance(x, Expression):\n+        return Expression._call(\n+            'ceil',\n+            [x]\n+        )\n+\n+    return (\n+        func.call([x], memory_pool=memory_pool)\n+    )\n+\n+\n+def ceil_temporal(timestamps, multiple=1, unit='day', *,\n+                  week_starts_monday=True,\n+                  ceil_is_strictly_greater=False,\n+                  calendar_based_origin=False, options=None,\n+                  memory_pool=None):\n+    \"\"\"Round temporal values up to nearest multiple of specified time unit.\n+\n+    Null values emit null.\n+    An error is returned if the values have a defined timezone but it\n+    cannot be found in the timezone database.\n+\n+    This wraps the \"ceil_temporal\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    timestamps : Array-like or scalar-like\n+        Argument to compute function.\n+    multiple : int, default 1\n+        Number of units to round to.\n+    unit : str, default \"day\"\n+        The unit in which `multiple` is expressed.\n+        Accepted values are \"year\", \"quarter\", \"month\", \"week\", \"day\",\n+        \"hour\", \"minute\", \"second\", \"millisecond\", \"microsecond\",\n+        \"nanosecond\".\n+    week_starts_monday : bool, default True\n+        If True, weeks start on Monday; if False, on Sunday.\n+    ceil_is_strictly_greater : bool, default False\n+        If True, ceil returns a rounded value that is strictly greater than\n+        the\n+        input. For example: ceiling 1970-01-01T00:00:00 to 3 hours would\n+        yield 1970-01-01T03:00:00 if set to True and 1970-01-01T00:00:00\n+        if set to False.\n+        This applies to the ceil_temporal function only.\n+    calendar_based_origin : bool, default False\n+        By default, the origin is 1970-01-01T00:00:00. By setting this to\n+        True,\n+        rounding origin will be beginning of one less precise calendar unit.\n+        E.g.: rounding to hours will use beginning of day as origin.\n+\n+        By default time is rounded to a multiple of units since\n+        1970-01-01T00:00:00. By setting calendar_based_origin to true,\n+        time will be rounded to number of units since the last greater\n+        calendar unit.\n+        For example: rounding to multiple of days since the beginning of the\n+        month or to hours since the beginning of the day.\n+        Exceptions: week and quarter are not used as greater units,\n+        therefore days will be rounded to the beginning of the month not\n+        week. Greater unit of week is a year.\n+        Note that ceiling and rounding might change sorting order of an array\n+        near greater unit change. For example rounding YYYY-mm-dd 23:00:00 to\n+        5 hours will ceil and round to YYYY-mm-dd+1 01:00:00 and floor to\n+        YYYY-mm-dd 20:00:00. On the other hand YYYY-mm-dd+1 00:00:00 will\n+        ceil, round and floor to YYYY-mm-dd+1 00:00:00. This can break the\n+        order of an already ordered array.\n+    options : pyarrow.compute.RoundTemporalOptions, optional\n+        Alternative way of passing options.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    _computed_options = _handle_options(\n+        'ceil_temporal',\n+        pyarrow._compute.RoundTemporalOptions,\n+        options,\n+        (),\n+        multiple=multiple,\n+        unit=unit,\n+        week_starts_monday=week_starts_monday,\n+        ceil_is_strictly_greater=ceil_is_strictly_greater,\n+        calendar_based_origin=calendar_based_origin\n+    )\n+    func = pyarrow._compute.get_function('ceil_temporal')\n+\n+    if isinstance(timestamps, Expression):\n+        return Expression._call(\n+            'ceil_temporal',\n+            [timestamps],\n+            _computed_options\n+        )\n+\n+    return (\n+        func.call([timestamps], _computed_options, memory_pool)\n+    )\n+\n+\n+def choose(indices, *values, memory_pool=None):\n+    \"\"\"Choose values from several arrays.\n+\n+    For each row, the value of the first argument is used as a 0-based index\n+    into the list of `values` arrays (i.e. index 0 selects the first of the\n+    `values` arrays). The output value is the corresponding value of the\n+    selected argument.\n+\n+    If an index is null, the output will be null.\n+\n+    This wraps the \"choose\" compute function in the Arrow C++ library.\n+\n+    Parameters\n+    ----------\n+    indices : Array-like or scalar-like\n+        Argument to compute function.\n+    *values : Array-like or scalar-like\n+        Argument to compute function.\n+    memory_pool : pyarrow.MemoryPool, optional\n+        If not passed, will allocate memory from the default memory pool.\n+    \"\"\"\n+\n+    func = pyarrow._compute.get_function('choose')\n+    return (\n+        func.call([indices, *values], memory_pool=memory_pool)\n+    )\n+\n+\n+def coalesce(*values, memory_pool=None):\n+    \"\"\"Select the first non-null value.\n+\n+    Each row of the output will be the value from the first corresponding\n+        input\n+    for which the value is not null. If all inputs are null in a row, the\n+        output\n+    will be null.\n\nReview Comment:\n   Ah - I see where this is coming from.  This is because the cpp-derived doc [for coalesce, as linked](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/kernels/scalar_if_else.cc#L2739) has newlines which would be removed in the restructured text spec, but not before textwrap is being called. Let me work on this \r\n   \r\n   From the cpp source referenced:\r\n   \r\n   ```cpp\r\n   const FunctionDoc coalesce_doc{\r\n       \"Select the first non-null value\",\r\n       (\"Each row of the output will be the value from the first corresponding input\\n\"\r\n        \"for which the value is not null. If all inputs are null in a row, the output\\n\"\r\n        \"will be null.\"),\r\n       {\"*values\"}};\r\n   ```\r\n     \n\n\n\n",
                    "created": "2022-08-30T23:48:16.610+0000",
                    "updated": "2022-08-30T23:48:16.610+0000",
                    "started": "2022-08-30T23:48:16.609+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "805044",
                    "issueId": "13374797"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/worklog/805047",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "krcrouse commented on PR #13126:\nURL: https://github.com/apache/arrow/pull/13126#issuecomment-1232287180\n\n   > Would we need a check in CI that ensures the generated compute file is up-to-date? (I am not directly sure how we do that in other places with generated files)\r\n   \r\n   Yes. One straightforward (though arguably not terribly elegant) way to check this would be to have the CI task run `python scripts/generate_sources.py` with a flag to redirect output and ensure that the output was exactly the same as the `python/pyarrow/_compute_generated.py` file.  \n\n\n",
                    "created": "2022-08-30T23:52:49.374+0000",
                    "updated": "2022-08-30T23:52:49.374+0000",
                    "started": "2022-08-30T23:52:49.374+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "805047",
                    "issueId": "13374797"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/worklog/806031",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "krcrouse commented on PR #13126:\nURL: https://github.com/apache/arrow/pull/13126#issuecomment-1236365597\n\n   @jorisvandenbossche ,\r\n   \r\n   Here's the run down of the most recent push to the branch, which includes updates from upstream as of the end of last week:\r\n   \r\n   Quick Summary Points (many that condense prior one-off comments):\r\n   \r\n   * Based on your comment, I moved `python/pyarrow/_rstutils.py` into `python/scripts/lib/arrowdoc.py` as it is not needed. I don't love a sub-lib of `scripts`, but it's at least straightforward to then have the `generate_sources.py` script reference it.\r\n   * As I had replied earlier, there should eventually have a step added to the build or CI process that verifies the committed version of `python/pyarrow/_compute_generated.py` is the same thing that is output from the `generate_sources.py` script.\r\n   * The `archery lint --rat` test is failing because the rst files in `python/docs/additions/compute/` don't have license text and I do not know how do that in a sensible way and don't see it in docs or examples.  \r\n   \r\n   As for the points you brought up about `docutils` - I wonder if you are misunderstanding its role and how I use it in the PR. It's probably more straightforward with the reorganization in this round.  Now, the `docutils` modules is only used in the `scripts/lib/arrodoc.py` file, and there it is only used to parse the reST files in `python/docs/additions/compute/` into the document tree that is then merged/replaced/appended to the docs pulled from the C++ libraries. I did add it to the `requirements-build` and `requirements-wheel-build` files for the PR, but neither of those are really accurate. It's required solely to run the script, and so I felt that it would need to go into some sort of \"requirements,\" but if you're not regenerating the compute functions for python, it's not required for anything. \n\n\n",
                    "created": "2022-09-04T15:33:40.532+0000",
                    "updated": "2022-09-04T15:33:40.532+0000",
                    "started": "2022-09-04T15:33:40.532+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "806031",
                    "issueId": "13374797"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 10200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@1a5f82d4[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@78d1f4a5[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@9b944a8[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7ebafde6[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@48eae1ee[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@16b7b90d[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@55682377[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@7c14b1f1[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@63eeca0c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@483a68ad[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5c5d9946[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@51f2005[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 10200,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Jun 02 07:22:48 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": null,
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12526/watchers",
            "watchCount": 4,
            "isWatching": false
        },
        "created": "2021-04-24T10:30:15.000+0000",
        "updated": "2022-09-04T15:33:40.000+0000",
        "timeoriginalestimate": null,
        "description": "Static analysis tools (e.g. pylint) don't recognize simple members like pyarrow.compute.equal, they report is as _missing_. Generating file (well a file imported by this file I assume) [https://github.com/apache/arrow/blob/master/python/pyarrow/compute.py]\u00a0instead of runtime wrapping of the functions would improve the developer experience.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 10200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/attachment/13043373",
                "id": "13043373",
                "filename": "compute.py",
                "author": {
                    "self": "https://issues.apache.org/jira/rest/api/2/user?username=krcrouse",
                    "name": "krcrouse",
                    "key": "JIRAUSER286896",
                    "avatarUrls": {
                        "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34059",
                        "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34059",
                        "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34059",
                        "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34059"
                    },
                    "displayName": "Kevin Crouse",
                    "active": true,
                    "timeZone": "Etc/UTC"
                },
                "created": "2022-05-08T14:15:11.742+0000",
                "size": 260519,
                "mimeType": "text/x-python",
                "content": "https://issues.apache.org/jira/secure/attachment/13043373/compute.py"
            }
        ],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Python] Pre-generate  pyarrow.compute members",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/comment/17331193",
                    "id": "17331193",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alippai",
                        "name": "alippai",
                        "key": "alippai",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Adam Lippai",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "A quick question regarding this topic: if we generate code do we push it to the GitHub repo or do we just create it on the fly upon a release?\u00a0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alippai",
                        "name": "alippai",
                        "key": "alippai",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Adam Lippai",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2021-04-24T10:31:54.905+0000",
                    "updated": "2021-04-24T10:31:54.905+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/comment/17332510",
                    "id": "17332510",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "body": "In general, we commit generated code, I think.\r\n\r\nWondering, would something like ARROW-10316 also already help? Although I suppose not for static tools, that probably only makes the interactive use nicer.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "created": "2021-04-26T15:39:00.117+0000",
                    "updated": "2021-04-26T15:39:00.117+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/comment/17332511",
                    "id": "17332511",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "body": "cc [~apitrou]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "created": "2021-04-26T15:39:14.252+0000",
                    "updated": "2021-04-26T15:39:14.252+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/comment/17332560",
                    "id": "17332560",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "I would be fine with generating the file. We would need to commit it to the repository.\r\n\r\nGenerating the file would also allow generation to be more expensive without fear of growing import times.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-04-26T16:20:07.827+0000",
                    "updated": "2021-04-26T16:20:07.827+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/comment/17343185",
                    "id": "17343185",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "cc [~amol-]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-05-12T11:13:48.223+0000",
                    "updated": "2021-05-12T11:13:48.223+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/comment/17343188",
                    "id": "17343188",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alippai",
                        "name": "alippai",
                        "key": "alippai",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Adam Lippai",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Note: using *.pyi files would help the typing info and autocomplete, but not the import times. I assume we'd prefer full code generation, right?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alippai",
                        "name": "alippai",
                        "key": "alippai",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Adam Lippai",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2021-05-12T11:27:23.221+0000",
                    "updated": "2021-05-12T11:27:23.221+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/comment/17343189",
                    "id": "17343189",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Probably, yes.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-05-12T11:29:09.336+0000",
                    "updated": "2021-05-12T11:29:09.336+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/comment/17460958",
                    "id": "17460958",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "[~alippai] Can you show an example invocation of pylint or another such utility?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-12-16T18:39:11.055+0000",
                    "updated": "2021-12-16T18:39:11.055+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/comment/17533471",
                    "id": "17533471",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=krcrouse",
                        "name": "krcrouse",
                        "key": "JIRAUSER286896",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34059",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34059",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34059",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34059"
                        },
                        "displayName": "Kevin Crouse",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "I was pointed to this issue because I was similarly interested in allowing pythonic documentation to be written for functions in which docs are autogenerated from the Arrow C++ details. As a result, I've written out the code to do both of these things for the `pyarrow.compute` module: [https://github.com/krcrouse/arrow/compare/master...krcrouse:generate-pyarrow-compute-and-improve-docs]\u00a0\r\n\r\nMajor points:\r\n * creates `python/docs/additions` tree where the reStructrued text docs that include the sections to overwrite. Using raw reSt so that code block examples can be tested using doctest - see the README for more verbose details\r\n * `pyarrow.docutils` (or maybe should be _docutils) provides functions to processes `python/docs/additions` and return a data structure of the components per function.\r\n * `python/scripts/generate_sources.py` uses `pyarrow.docutils` and writes out the code for the compute functions in `pyarrow/generated/compute.py`. All of the logic from the release-branch `pyarrow.compute` module that dynamically generated the compute functions has been moved to this script.\r\n ** I didn't check the generated file into the repo because I generally do not include generated files that would be generated by the build process should be in source control, but I realize there are other perspectives on this\r\n * `pyarrow.compute` now imports from `pyarrow.generated.compute` for all of the autogenerated compute bindings. Override and custom functions are still defined here.\r\n * The old `pyarrow._compute_docstrings` is gone because its purpose is subsumed in the above.\r\n * I've updated the tests so that they work with the above changes.\r\n\r\n\u00a0\r\n\r\nBelow I've attached the `pyarrow/generated/compute.py` file that is currently created by `generate_source.py` as of commit [13c2b0e|https://github.com/krcrouse/arrow/commit/13c2b0e14fbfbc483bec559e610c2c222ae7d367]\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=krcrouse",
                        "name": "krcrouse",
                        "key": "JIRAUSER286896",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34059",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34059",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34059",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34059"
                        },
                        "displayName": "Kevin Crouse",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-05-08T14:11:41.734+0000",
                    "updated": "2022-05-08T14:18:13.890+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/comment/17534277",
                    "id": "17534277",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "[~krcrouse] Thank you for doing this! This is really interesting. May you perhaps open a draft PR with you changes, to make it easier to add questions and comments?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2022-05-10T10:19:18.211+0000",
                    "updated": "2022-05-10T10:19:18.211+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/comment/17545247",
                    "id": "17545247",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=krcrouse",
                        "name": "krcrouse",
                        "key": "JIRAUSER286896",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34059",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34059",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34059",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34059"
                        },
                        "displayName": "Kevin Crouse",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "I haven't seen any comments on the PR or here, so maybe they didn't get auto-linked? If so, sorry - I've used Jira in the past with Bitbucket but not Github.\r\n\r\nThe PR is here:\r\n\r\nhttps://github.com/apache/arrow/pull/13126",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=krcrouse",
                        "name": "krcrouse",
                        "key": "JIRAUSER286896",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34059",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34059",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34059",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34059"
                        },
                        "displayName": "Kevin Crouse",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-06-02T02:59:25.292+0000",
                    "updated": "2022-06-02T02:59:25.292+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374797/comment/17545305",
                    "id": "17545305",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Sorry Kevin. The PR was auto-linked above, it's just that noone got around to take a look yet.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2022-06-02T07:22:48.037+0000",
                    "updated": "2022-06-02T07:22:48.037+0000"
                }
            ],
            "maxResults": 12,
            "total": 12,
            "startAt": 0
        },
        "customfield_12311820": "0|z0qeow:",
        "customfield_12314139": null
    }
}