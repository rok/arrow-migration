{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13426654",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654",
    "key": "ARROW-15577",
    "fields": {
        "parent": {
            "id": "13418565",
            "key": "ARROW-15156",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13418565",
            "fields": {
                "summary": "[Doc] Implement Tutorials for the Java Documentation",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                    "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                    "name": "Resolved",
                    "id": "5",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                    "id": "4",
                    "description": "An improvement or enhancement to an existing feature or task.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                    "name": "Improvement",
                    "subtask": false,
                    "avatarId": 21140
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351051",
                "id": "12351051",
                "description": "",
                "name": "8.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-05-06"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=dsusanibara",
            "name": "dsusanibara",
            "key": "dsusanibara",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Dali Susanibar Arce",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12332532",
                "id": "12332532",
                "name": "Documentation"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=amol-",
            "name": "amol-",
            "key": "amol-",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=amol-&avatarId=46461",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=amol-&avatarId=46461",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=amol-&avatarId=46461",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=amol-&avatarId=46461"
            },
            "displayName": "Alessandro Molina",
            "active": true,
            "timeZone": "Europe/Rome"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=amol-",
            "name": "amol-",
            "key": "amol-",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=amol-&avatarId=46461",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=amol-&avatarId=46461",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=amol-&avatarId=46461",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=amol-&avatarId=46461"
            },
            "displayName": "Alessandro Molina",
            "active": true,
            "timeZone": "Europe/Rome"
        },
        "aggregateprogress": {
            "progress": 12600,
            "total": 12600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 12600,
            "total": 12600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15577/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 21,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/754869",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #12847:\nURL: https://github.com/apache/arrow/pull/12847#issuecomment-1093534029\n\n   https://issues.apache.org/jira/browse/ARROW-15577\n\n\n",
                    "created": "2022-04-09T00:48:40.901+0000",
                    "updated": "2022-04-09T00:48:40.901+0000",
                    "started": "2022-04-09T00:48:40.901+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "754869",
                    "issueId": "13426654"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/755202",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #12847:\nURL: https://github.com/apache/arrow/pull/12847#discussion_r847265336\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,302 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Arrow Flight is a development framework to offer to us the building blocks\n+to implement applications base on our needs.\n+\n+In this journey, you need to implement how do you are planning to expose\n+your business operations in base of RPC Methods and Request Patterns\n+provided by Flight.\n+\n+For Flight Server side operations you need to implement FlightProducer interface\n+methods.\n\nReview Comment:\n   ```suggestion\r\n   Flight servers implement the `FlightProducer`_ interface. For convenience,\r\n   they can subclass `NoOpFlightProducer`_ instead, which offers default\r\n   implementations of all the RPC methods.\r\n   ```\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,302 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Arrow Flight is a development framework to offer to us the building blocks\n+to implement applications base on our needs.\n+\n+In this journey, you need to implement how do you are planning to expose\n+your business operations in base of RPC Methods and Request Patterns\n+provided by Flight.\n+\n+For Flight Server side operations you need to implement FlightProducer interface\n+methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n\nReview Comment:\n   See #12815 where we explain ServerCallContext and errors here.\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,302 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Arrow Flight is a development framework to offer to us the building blocks\n+to implement applications base on our needs.\n+\n+In this journey, you need to implement how do you are planning to expose\n+your business operations in base of RPC Methods and Request Patterns\n+provided by Flight.\n+\n+For Flight Server side operations you need to implement FlightProducer interface\n+methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Also you need to specify where to listen for, let's combine producer and location\n+to create and start the Flight Server. This will start the server, but won't block\n+the rest of the program. Call `FlightServer.awaitTermination` to block until the\n+server stops.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.ActionType;\n+    import org.apache.arrow.flight.Criteria;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightInfo;\n+    import org.apache.arrow.flight.FlightProducer;\n+    import org.apache.arrow.flight.FlightServer;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.PutResult;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.flight.SchemaResult;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import org.apache.arrow.util.AutoCloseables;\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer tutorialFlightServer = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        tutorialFlightServer.start();\n+        System.out.println(\"Server listening on port \" + tutorialFlightServer.getPort());\n+\n+        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n+            try {\n+                System.out.println(\"\\nExiting command...\");\n+                AutoCloseables.close(tutorialFlightServer, allocator);\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }));\n+        tutorialFlightServer.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient.builder` with a location.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.FlightClient;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight Server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.CallOptions;\n+    import org.apache.arrow.flight.FlightClient;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+\n+    import java.util.Iterator;\n+    import java.util.concurrent.TimeUnit;\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.FlightClient;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import java.nio.charset.StandardCharsets;\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = tutorialFlightClient.getStream(new Ticket(\n+                FlightDescriptor.path(\"profiles\").getPath().get(0).getBytes(StandardCharsets.UTF_8)))) {\n\nReview Comment:\n   Er, just do `new byte[]{}` or something.\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,302 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Arrow Flight is a development framework to offer to us the building blocks\n+to implement applications base on our needs.\n+\n+In this journey, you need to implement how do you are planning to expose\n+your business operations in base of RPC Methods and Request Patterns\n+provided by Flight.\n+\n+For Flight Server side operations you need to implement FlightProducer interface\n+methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Also you need to specify where to listen for, let's combine producer and location\n+to create and start the Flight Server. This will start the server, but won't block\n+the rest of the program. Call `FlightServer.awaitTermination` to block until the\n+server stops.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.ActionType;\n+    import org.apache.arrow.flight.Criteria;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightInfo;\n+    import org.apache.arrow.flight.FlightProducer;\n+    import org.apache.arrow.flight.FlightServer;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.PutResult;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.flight.SchemaResult;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import org.apache.arrow.util.AutoCloseables;\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer tutorialFlightServer = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        tutorialFlightServer.start();\n+        System.out.println(\"Server listening on port \" + tutorialFlightServer.getPort());\n+\n+        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n+            try {\n+                System.out.println(\"\\nExiting command...\");\n+                AutoCloseables.close(tutorialFlightServer, allocator);\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }));\n+        tutorialFlightServer.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient.builder` with a location.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.FlightClient;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight Server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.CallOptions;\n+    import org.apache.arrow.flight.FlightClient;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+\n+    import java.util.Iterator;\n+    import java.util.concurrent.TimeUnit;\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.FlightClient;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import java.nio.charset.StandardCharsets;\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = tutorialFlightClient.getStream(new Ticket(\n+                FlightDescriptor.path(\"profiles\").getPath().get(0).getBytes(StandardCharsets.UTF_8)))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation opion!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a certificate and key pair to `FlightServer.builder.useTls`.\n+\n+On the client side, use `FlightClient.builder.trustedCertificates`.\n+\n+Enabling Authentication\n+=======================\n+\n+\n+\n+Custom Middleware\n+=================\n+\n+Servers and clients support custom middleware (or interceptors) that are called on every\n+request and can modify the request in a limited fashion. These can be implemented by implements\n\nReview Comment:\n   ```suggestion\r\n   request and can modify the request in a limited fashion. These can be implemented by implementing the\r\n   ```\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,302 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Arrow Flight is a development framework to offer to us the building blocks\n+to implement applications base on our needs.\n+\n+In this journey, you need to implement how do you are planning to expose\n+your business operations in base of RPC Methods and Request Patterns\n+provided by Flight.\n+\n+For Flight Server side operations you need to implement FlightProducer interface\n+methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Also you need to specify where to listen for, let's combine producer and location\n+to create and start the Flight Server. This will start the server, but won't block\n+the rest of the program. Call `FlightServer.awaitTermination` to block until the\n+server stops.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.ActionType;\n+    import org.apache.arrow.flight.Criteria;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightInfo;\n+    import org.apache.arrow.flight.FlightProducer;\n+    import org.apache.arrow.flight.FlightServer;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.PutResult;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.flight.SchemaResult;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import org.apache.arrow.util.AutoCloseables;\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer tutorialFlightServer = FlightServer.builder(\n\nReview Comment:\n   ```suggestion\r\n           FlightServer server = FlightServer.builder(\r\n   ```\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,302 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Arrow Flight is a development framework to offer to us the building blocks\n+to implement applications base on our needs.\n+\n+In this journey, you need to implement how do you are planning to expose\n+your business operations in base of RPC Methods and Request Patterns\n+provided by Flight.\n+\n+For Flight Server side operations you need to implement FlightProducer interface\n+methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Also you need to specify where to listen for, let's combine producer and location\n+to create and start the Flight Server. This will start the server, but won't block\n+the rest of the program. Call `FlightServer.awaitTermination` to block until the\n+server stops.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.ActionType;\n+    import org.apache.arrow.flight.Criteria;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightInfo;\n+    import org.apache.arrow.flight.FlightProducer;\n+    import org.apache.arrow.flight.FlightServer;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.PutResult;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.flight.SchemaResult;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import org.apache.arrow.util.AutoCloseables;\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer tutorialFlightServer = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        tutorialFlightServer.start();\n+        System.out.println(\"Server listening on port \" + tutorialFlightServer.getPort());\n+\n+        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n+            try {\n+                System.out.println(\"\\nExiting command...\");\n+                AutoCloseables.close(tutorialFlightServer, allocator);\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }));\n+        tutorialFlightServer.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient.builder` with a location.\n\nReview Comment:\n   Either use double-backticks or link to the javadocs.\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,302 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Arrow Flight is a development framework to offer to us the building blocks\n+to implement applications base on our needs.\n+\n+In this journey, you need to implement how do you are planning to expose\n+your business operations in base of RPC Methods and Request Patterns\n+provided by Flight.\n+\n+For Flight Server side operations you need to implement FlightProducer interface\n+methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Also you need to specify where to listen for, let's combine producer and location\n+to create and start the Flight Server. This will start the server, but won't block\n+the rest of the program. Call `FlightServer.awaitTermination` to block until the\n+server stops.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.ActionType;\n+    import org.apache.arrow.flight.Criteria;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightInfo;\n+    import org.apache.arrow.flight.FlightProducer;\n+    import org.apache.arrow.flight.FlightServer;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.PutResult;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.flight.SchemaResult;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import org.apache.arrow.util.AutoCloseables;\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer tutorialFlightServer = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        tutorialFlightServer.start();\n+        System.out.println(\"Server listening on port \" + tutorialFlightServer.getPort());\n+\n+        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n+            try {\n+                System.out.println(\"\\nExiting command...\");\n+                AutoCloseables.close(tutorialFlightServer, allocator);\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }));\n\nReview Comment:\n   The server/allocator are in the try-with-resources, why do we need this?\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,302 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Arrow Flight is a development framework to offer to us the building blocks\n+to implement applications base on our needs.\n+\n+In this journey, you need to implement how do you are planning to expose\n+your business operations in base of RPC Methods and Request Patterns\n+provided by Flight.\n+\n+For Flight Server side operations you need to implement FlightProducer interface\n+methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Also you need to specify where to listen for, let's combine producer and location\n+to create and start the Flight Server. This will start the server, but won't block\n+the rest of the program. Call `FlightServer.awaitTermination` to block until the\n+server stops.\n\nReview Comment:\n   ```suggestion\r\n   To start a server, create a `Location`_ to specify where to listen, and then create\r\n   a `FlightServer`_ with an instance of a producer. This will start the server, but\r\n   won't block the rest of the program. Call ``FlightServer.awaitTermination``\r\n   to block until the server stops.\r\n   ```\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,302 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Arrow Flight is a development framework to offer to us the building blocks\n+to implement applications base on our needs.\n+\n+In this journey, you need to implement how do you are planning to expose\n+your business operations in base of RPC Methods and Request Patterns\n+provided by Flight.\n+\n+For Flight Server side operations you need to implement FlightProducer interface\n+methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Also you need to specify where to listen for, let's combine producer and location\n+to create and start the Flight Server. This will start the server, but won't block\n+the rest of the program. Call `FlightServer.awaitTermination` to block until the\n+server stops.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.ActionType;\n+    import org.apache.arrow.flight.Criteria;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightInfo;\n+    import org.apache.arrow.flight.FlightProducer;\n+    import org.apache.arrow.flight.FlightServer;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.PutResult;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.flight.SchemaResult;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import org.apache.arrow.util.AutoCloseables;\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n\nReview Comment:\n   Either we should omit imports consistently, or include imports consistently. It looks like we've been omitting imports so far.\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,302 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Arrow Flight is a development framework to offer to us the building blocks\n+to implement applications base on our needs.\n+\n+In this journey, you need to implement how do you are planning to expose\n+your business operations in base of RPC Methods and Request Patterns\n+provided by Flight.\n+\n+For Flight Server side operations you need to implement FlightProducer interface\n+methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Also you need to specify where to listen for, let's combine producer and location\n+to create and start the Flight Server. This will start the server, but won't block\n+the rest of the program. Call `FlightServer.awaitTermination` to block until the\n+server stops.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.ActionType;\n+    import org.apache.arrow.flight.Criteria;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightInfo;\n+    import org.apache.arrow.flight.FlightProducer;\n+    import org.apache.arrow.flight.FlightServer;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.PutResult;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.flight.SchemaResult;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import org.apache.arrow.util.AutoCloseables;\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer tutorialFlightServer = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        tutorialFlightServer.start();\n+        System.out.println(\"Server listening on port \" + tutorialFlightServer.getPort());\n+\n+        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n+            try {\n+                System.out.println(\"\\nExiting command...\");\n+                AutoCloseables.close(tutorialFlightServer, allocator);\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }));\n+        tutorialFlightServer.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient.builder` with a location.\n\nReview Comment:\n   The same goes for below.\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,302 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Arrow Flight is a development framework to offer to us the building blocks\n+to implement applications base on our needs.\n+\n+In this journey, you need to implement how do you are planning to expose\n+your business operations in base of RPC Methods and Request Patterns\n+provided by Flight.\n+\n+For Flight Server side operations you need to implement FlightProducer interface\n+methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Also you need to specify where to listen for, let's combine producer and location\n+to create and start the Flight Server. This will start the server, but won't block\n+the rest of the program. Call `FlightServer.awaitTermination` to block until the\n+server stops.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.ActionType;\n+    import org.apache.arrow.flight.Criteria;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightInfo;\n+    import org.apache.arrow.flight.FlightProducer;\n+    import org.apache.arrow.flight.FlightServer;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.PutResult;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.flight.SchemaResult;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import org.apache.arrow.util.AutoCloseables;\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer tutorialFlightServer = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        tutorialFlightServer.start();\n+        System.out.println(\"Server listening on port \" + tutorialFlightServer.getPort());\n+\n+        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n+            try {\n+                System.out.println(\"\\nExiting command...\");\n+                AutoCloseables.close(tutorialFlightServer, allocator);\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }));\n+        tutorialFlightServer.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient.builder` with a location.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.FlightClient;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight Server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.CallOptions;\n+    import org.apache.arrow.flight.FlightClient;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+\n+    import java.util.Iterator;\n+    import java.util.concurrent.TimeUnit;\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.FlightClient;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import java.nio.charset.StandardCharsets;\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = tutorialFlightClient.getStream(new Ticket(\n+                FlightDescriptor.path(\"profiles\").getPath().get(0).getBytes(StandardCharsets.UTF_8)))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation opion!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a certificate and key pair to `FlightServer.builder.useTls`.\n+\n+On the client side, use `FlightClient.builder.trustedCertificates`.\n+\n+Enabling Authentication\n+=======================\n+\n+\n+\n+Custom Middleware\n+=================\n+\n+Servers and clients support custom middleware (or interceptors) that are called on every\n+request and can modify the request in a limited fashion. These can be implemented by implements\n+`FlightServerMiddleware` and `FlightClientMiddleware` interface methods.\n\nReview Comment:\n   ```suggestion\r\n   `FlightServerMiddleware` and `FlightClientMiddleware` interfaces.\r\n   ```\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,302 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Arrow Flight is a development framework to offer to us the building blocks\n+to implement applications base on our needs.\n+\n+In this journey, you need to implement how do you are planning to expose\n+your business operations in base of RPC Methods and Request Patterns\n+provided by Flight.\n+\n+For Flight Server side operations you need to implement FlightProducer interface\n+methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Also you need to specify where to listen for, let's combine producer and location\n+to create and start the Flight Server. This will start the server, but won't block\n+the rest of the program. Call `FlightServer.awaitTermination` to block until the\n+server stops.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.ActionType;\n+    import org.apache.arrow.flight.Criteria;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightInfo;\n+    import org.apache.arrow.flight.FlightProducer;\n+    import org.apache.arrow.flight.FlightServer;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.PutResult;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.flight.SchemaResult;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import org.apache.arrow.util.AutoCloseables;\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer tutorialFlightServer = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        tutorialFlightServer.start();\n+        System.out.println(\"Server listening on port \" + tutorialFlightServer.getPort());\n+\n+        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n+            try {\n+                System.out.println(\"\\nExiting command...\");\n+                AutoCloseables.close(tutorialFlightServer, allocator);\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }));\n+        tutorialFlightServer.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient.builder` with a location.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.FlightClient;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight Server\n\nReview Comment:\n   ```suggestion\r\n           // ... Consume operations exposed by Flight server\r\n   ```\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,302 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Arrow Flight is a development framework to offer to us the building blocks\n+to implement applications base on our needs.\n+\n+In this journey, you need to implement how do you are planning to expose\n+your business operations in base of RPC Methods and Request Patterns\n+provided by Flight.\n+\n+For Flight Server side operations you need to implement FlightProducer interface\n+methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Also you need to specify where to listen for, let's combine producer and location\n+to create and start the Flight Server. This will start the server, but won't block\n+the rest of the program. Call `FlightServer.awaitTermination` to block until the\n+server stops.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.ActionType;\n+    import org.apache.arrow.flight.Criteria;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightInfo;\n+    import org.apache.arrow.flight.FlightProducer;\n+    import org.apache.arrow.flight.FlightServer;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.PutResult;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.flight.SchemaResult;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import org.apache.arrow.util.AutoCloseables;\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer tutorialFlightServer = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        tutorialFlightServer.start();\n+        System.out.println(\"Server listening on port \" + tutorialFlightServer.getPort());\n+\n+        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n+            try {\n+                System.out.println(\"\\nExiting command...\");\n+                AutoCloseables.close(tutorialFlightServer, allocator);\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }));\n+        tutorialFlightServer.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient.builder` with a location.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.FlightClient;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight Server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.CallOptions;\n+    import org.apache.arrow.flight.FlightClient;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+\n+    import java.util.Iterator;\n+    import java.util.concurrent.TimeUnit;\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.FlightClient;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import java.nio.charset.StandardCharsets;\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = tutorialFlightClient.getStream(new Ticket(\n+                FlightDescriptor.path(\"profiles\").getPath().get(0).getBytes(StandardCharsets.UTF_8)))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation opion!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a certificate and key pair to `FlightServer.builder.useTls`.\n+\n+On the client side, use `FlightClient.builder.trustedCertificates`.\n+\n+Enabling Authentication\n+=======================\n+\n+\n+\n+Custom Middleware\n+=================\n+\n+Servers and clients support custom middleware (or interceptors) that are called on every\n+request and can modify the request in a limited fashion. These can be implemented by implements\n+`FlightServerMiddleware` and `FlightClientMiddleware` interface methods.\n+\n+Middleware are fairly limited, but they can add headers to a request/response.\n+\n+Example: Need to intercept Flight server headers at request and print values also for the response\n\nReview Comment:\n   We don't really add examples for this in the other docs, this would be better off in the cookbook\n\n\n\n",
                    "created": "2022-04-11T12:29:20.160+0000",
                    "updated": "2022-04-11T12:29:20.160+0000",
                    "started": "2022-04-11T12:29:20.160+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "755202",
                    "issueId": "13426654"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/755457",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on code in PR #12847:\nURL: https://github.com/apache/arrow/pull/12847#discussion_r847731406\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,296 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.ActionType;\n+    import org.apache.arrow.flight.Criteria;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightInfo;\n+    import org.apache.arrow.flight.FlightProducer;\n+    import org.apache.arrow.flight.FlightServer;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.PutResult;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.flight.SchemaResult;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import org.apache.arrow.util.AutoCloseables;\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n\nReview Comment:\n   Would it make sense to use the `FlightTestUtil.getStartedServer()`? \n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,296 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n\nReview Comment:\n   Maybe \"efficient transfer of Arrow data\" ?\n\n\n\n",
                    "created": "2022-04-11T22:03:01.719+0000",
                    "updated": "2022-04-11T22:03:01.719+0000",
                    "started": "2022-04-11T22:03:01.718+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "755457",
                    "issueId": "13426654"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/755468",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "davisusanibar commented on code in PR #12847:\nURL: https://github.com/apache/arrow/pull/12847#discussion_r847789324\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,302 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Arrow Flight is a development framework to offer to us the building blocks\n+to implement applications base on our needs.\n+\n+In this journey, you need to implement how do you are planning to expose\n+your business operations in base of RPC Methods and Request Patterns\n+provided by Flight.\n+\n+For Flight Server side operations you need to implement FlightProducer interface\n+methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n\nReview Comment:\n   Added\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,302 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Arrow Flight is a development framework to offer to us the building blocks\n+to implement applications base on our needs.\n+\n+In this journey, you need to implement how do you are planning to expose\n+your business operations in base of RPC Methods and Request Patterns\n+provided by Flight.\n+\n+For Flight Server side operations you need to implement FlightProducer interface\n+methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Also you need to specify where to listen for, let's combine producer and location\n+to create and start the Flight Server. This will start the server, but won't block\n+the rest of the program. Call `FlightServer.awaitTermination` to block until the\n+server stops.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.ActionType;\n+    import org.apache.arrow.flight.Criteria;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightInfo;\n+    import org.apache.arrow.flight.FlightProducer;\n+    import org.apache.arrow.flight.FlightServer;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.PutResult;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.flight.SchemaResult;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import org.apache.arrow.util.AutoCloseables;\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n\nReview Comment:\n   Deleted\n\n\n\n",
                    "created": "2022-04-11T22:26:05.025+0000",
                    "updated": "2022-04-11T22:26:05.025+0000",
                    "started": "2022-04-11T22:26:05.024+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "755468",
                    "issueId": "13426654"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/755469",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "davisusanibar commented on code in PR #12847:\nURL: https://github.com/apache/arrow/pull/12847#discussion_r847789468\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,302 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Arrow Flight is a development framework to offer to us the building blocks\n+to implement applications base on our needs.\n+\n+In this journey, you need to implement how do you are planning to expose\n+your business operations in base of RPC Methods and Request Patterns\n+provided by Flight.\n+\n+For Flight Server side operations you need to implement FlightProducer interface\n+methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Also you need to specify where to listen for, let's combine producer and location\n+to create and start the Flight Server. This will start the server, but won't block\n+the rest of the program. Call `FlightServer.awaitTermination` to block until the\n+server stops.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.ActionType;\n+    import org.apache.arrow.flight.Criteria;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightInfo;\n+    import org.apache.arrow.flight.FlightProducer;\n+    import org.apache.arrow.flight.FlightServer;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.PutResult;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.flight.SchemaResult;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import org.apache.arrow.util.AutoCloseables;\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer tutorialFlightServer = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        tutorialFlightServer.start();\n+        System.out.println(\"Server listening on port \" + tutorialFlightServer.getPort());\n+\n+        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n+            try {\n+                System.out.println(\"\\nExiting command...\");\n+                AutoCloseables.close(tutorialFlightServer, allocator);\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }));\n\nReview Comment:\n   Deleted\n\n\n\n",
                    "created": "2022-04-11T22:26:20.114+0000",
                    "updated": "2022-04-11T22:26:20.114+0000",
                    "started": "2022-04-11T22:26:20.112+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "755469",
                    "issueId": "13426654"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/755471",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "davisusanibar commented on code in PR #12847:\nURL: https://github.com/apache/arrow/pull/12847#discussion_r847789649\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,302 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Arrow Flight is a development framework to offer to us the building blocks\n+to implement applications base on our needs.\n+\n+In this journey, you need to implement how do you are planning to expose\n+your business operations in base of RPC Methods and Request Patterns\n+provided by Flight.\n+\n+For Flight Server side operations you need to implement FlightProducer interface\n+methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Also you need to specify where to listen for, let's combine producer and location\n+to create and start the Flight Server. This will start the server, but won't block\n+the rest of the program. Call `FlightServer.awaitTermination` to block until the\n+server stops.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.ActionType;\n+    import org.apache.arrow.flight.Criteria;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightInfo;\n+    import org.apache.arrow.flight.FlightProducer;\n+    import org.apache.arrow.flight.FlightServer;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.PutResult;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.flight.SchemaResult;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import org.apache.arrow.util.AutoCloseables;\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer tutorialFlightServer = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        tutorialFlightServer.start();\n+        System.out.println(\"Server listening on port \" + tutorialFlightServer.getPort());\n+\n+        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n+            try {\n+                System.out.println(\"\\nExiting command...\");\n+                AutoCloseables.close(tutorialFlightServer, allocator);\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }));\n+        tutorialFlightServer.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient.builder` with a location.\n\nReview Comment:\n   Added java docs link\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,302 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Arrow Flight is a development framework to offer to us the building blocks\n+to implement applications base on our needs.\n+\n+In this journey, you need to implement how do you are planning to expose\n+your business operations in base of RPC Methods and Request Patterns\n+provided by Flight.\n+\n+For Flight Server side operations you need to implement FlightProducer interface\n+methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Also you need to specify where to listen for, let's combine producer and location\n+to create and start the Flight Server. This will start the server, but won't block\n+the rest of the program. Call `FlightServer.awaitTermination` to block until the\n+server stops.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.ActionType;\n+    import org.apache.arrow.flight.Criteria;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightInfo;\n+    import org.apache.arrow.flight.FlightProducer;\n+    import org.apache.arrow.flight.FlightServer;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.PutResult;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.flight.SchemaResult;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import org.apache.arrow.util.AutoCloseables;\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer tutorialFlightServer = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        tutorialFlightServer.start();\n+        System.out.println(\"Server listening on port \" + tutorialFlightServer.getPort());\n+\n+        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n+            try {\n+                System.out.println(\"\\nExiting command...\");\n+                AutoCloseables.close(tutorialFlightServer, allocator);\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }));\n+        tutorialFlightServer.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient.builder` with a location.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.FlightClient;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight Server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.CallOptions;\n+    import org.apache.arrow.flight.FlightClient;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+\n+    import java.util.Iterator;\n+    import java.util.concurrent.TimeUnit;\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.FlightClient;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import java.nio.charset.StandardCharsets;\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = tutorialFlightClient.getStream(new Ticket(\n+                FlightDescriptor.path(\"profiles\").getPath().get(0).getBytes(StandardCharsets.UTF_8)))) {\n\nReview Comment:\n   Added\n\n\n\n",
                    "created": "2022-04-11T22:26:40.089+0000",
                    "updated": "2022-04-11T22:26:40.089+0000",
                    "started": "2022-04-11T22:26:40.088+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "755471",
                    "issueId": "13426654"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/755473",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "davisusanibar commented on code in PR #12847:\nURL: https://github.com/apache/arrow/pull/12847#discussion_r847789784\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,302 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Arrow Flight is a development framework to offer to us the building blocks\n+to implement applications base on our needs.\n+\n+In this journey, you need to implement how do you are planning to expose\n+your business operations in base of RPC Methods and Request Patterns\n+provided by Flight.\n+\n+For Flight Server side operations you need to implement FlightProducer interface\n+methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Also you need to specify where to listen for, let's combine producer and location\n+to create and start the Flight Server. This will start the server, but won't block\n+the rest of the program. Call `FlightServer.awaitTermination` to block until the\n+server stops.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.ActionType;\n+    import org.apache.arrow.flight.Criteria;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightInfo;\n+    import org.apache.arrow.flight.FlightProducer;\n+    import org.apache.arrow.flight.FlightServer;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.PutResult;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.flight.SchemaResult;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import org.apache.arrow.util.AutoCloseables;\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer tutorialFlightServer = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        tutorialFlightServer.start();\n+        System.out.println(\"Server listening on port \" + tutorialFlightServer.getPort());\n+\n+        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n+            try {\n+                System.out.println(\"\\nExiting command...\");\n+                AutoCloseables.close(tutorialFlightServer, allocator);\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }));\n+        tutorialFlightServer.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient.builder` with a location.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.FlightClient;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight Server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.CallOptions;\n+    import org.apache.arrow.flight.FlightClient;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+\n+    import java.util.Iterator;\n+    import java.util.concurrent.TimeUnit;\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.FlightClient;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import java.nio.charset.StandardCharsets;\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = tutorialFlightClient.getStream(new Ticket(\n+                FlightDescriptor.path(\"profiles\").getPath().get(0).getBytes(StandardCharsets.UTF_8)))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation opion!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a certificate and key pair to `FlightServer.builder.useTls`.\n+\n+On the client side, use `FlightClient.builder.trustedCertificates`.\n+\n+Enabling Authentication\n+=======================\n+\n+\n+\n+Custom Middleware\n+=================\n+\n+Servers and clients support custom middleware (or interceptors) that are called on every\n+request and can modify the request in a limited fashion. These can be implemented by implements\n+`FlightServerMiddleware` and `FlightClientMiddleware` interface methods.\n+\n+Middleware are fairly limited, but they can add headers to a request/response.\n+\n+Example: Need to intercept Flight server headers at request and print values also for the response\n\nReview Comment:\n   Deleted\n\n\n\n",
                    "created": "2022-04-11T22:26:55.114+0000",
                    "updated": "2022-04-11T22:26:55.114+0000",
                    "started": "2022-04-11T22:26:55.114+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "755473",
                    "issueId": "13426654"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/755474",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #12847:\nURL: https://github.com/apache/arrow/pull/12847#discussion_r847791578\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,296 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    import org.apache.arrow.flight.Action;\n+    import org.apache.arrow.flight.ActionType;\n+    import org.apache.arrow.flight.Criteria;\n+    import org.apache.arrow.flight.FlightDescriptor;\n+    import org.apache.arrow.flight.FlightInfo;\n+    import org.apache.arrow.flight.FlightProducer;\n+    import org.apache.arrow.flight.FlightServer;\n+    import org.apache.arrow.flight.FlightStream;\n+    import org.apache.arrow.flight.Location;\n+    import org.apache.arrow.flight.PutResult;\n+    import org.apache.arrow.flight.Result;\n+    import org.apache.arrow.flight.SchemaResult;\n+    import org.apache.arrow.flight.Ticket;\n+    import org.apache.arrow.memory.BufferAllocator;\n+    import org.apache.arrow.memory.RootAllocator;\n+    import org.apache.arrow.util.AutoCloseables;\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n\nReview Comment:\n   IMO not for these examples, we don't want to use unit test helpers\n\n\n\n",
                    "created": "2022-04-11T22:29:30.404+0000",
                    "updated": "2022-04-11T22:29:30.404+0000",
                    "started": "2022-04-11T22:29:30.404+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "755474",
                    "issueId": "13426654"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/755476",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "davisusanibar commented on code in PR #12847:\nURL: https://github.com/apache/arrow/pull/12847#discussion_r847793539\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,296 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Flight data\n\nReview Comment:\n   Added\n\n\n\n",
                    "created": "2022-04-11T22:33:45.881+0000",
                    "updated": "2022-04-11T22:33:45.881+0000",
                    "started": "2022-04-11T22:33:45.881+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "755476",
                    "issueId": "13426654"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/755711",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #12847:\nURL: https://github.com/apache/arrow/pull/12847#discussion_r848344036\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,216 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a `CallStatus` for common parameters. To indicate\n+failure, raise an exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation opion!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a\n+certificate and key pair to `FlightServer.builder.useTls`.\n\nReview Comment:\n   ```suggestion\r\n   certificate and key pair to ``FlightServer.Builder.useTls``.\r\n   ```\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,216 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a `CallStatus` for common parameters. To indicate\n+failure, raise an exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n\nReview Comment:\n   ```suggestion\r\n   On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\r\n   ``setOnCancelHandler`` or ``isCancelled`` to check if the client has cancelled the call,\r\n   and if so, break out of any processing the server is currently doing.\r\n   ```\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,216 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a `CallStatus` for common parameters. To indicate\n+failure, raise an exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation opion!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a\n+certificate and key pair to `FlightServer.builder.useTls`.\n+\n+On the client side, use `FlightClient.builder.trustedCertificates`.\n+\n+Enabling Authentication\n+=======================\n+\n+.. warning:: Authentication is insecure without enabling TLS.\n+\n+Handshake-based authentication can be enabled by implementing\n+`ServerAuthHandler`. Authentication consists of two parts: on\n+initial client connection, the server and client authentication\n+implementations can perform any negotiation needed; then, on each RPC\n+thereafter, the client provides a token. The server authentication\n+handler validates the token and provides the identity of the\n+client. This identity can be obtained from the\n+`CallContext.peerIdentity`.\n\nReview Comment:\n   ```suggestion\r\n   ``CallContext.peerIdentity``.\r\n   ```\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,216 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a `CallStatus` for common parameters. To indicate\n+failure, raise an exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation opion!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a\n+certificate and key pair to `FlightServer.builder.useTls`.\n+\n+On the client side, use `FlightClient.builder.trustedCertificates`.\n+\n+Enabling Authentication\n+=======================\n+\n+.. warning:: Authentication is insecure without enabling TLS.\n+\n+Handshake-based authentication can be enabled by implementing\n+`ServerAuthHandler`. Authentication consists of two parts: on\n+initial client connection, the server and client authentication\n+implementations can perform any negotiation needed; then, on each RPC\n+thereafter, the client provides a token. The server authentication\n+handler validates the token and provides the identity of the\n+client. This identity can be obtained from the\n+`CallContext.peerIdentity`.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    FlightClient client = FlightClient.builder().build();\n+    client.authenticateBasic(\"user\", \"password\");\n+    // Server\n+    FlightServer server = FlightServer.builder().authHandler(new BasicServerAuthHandler(validator)).build();\n+    // CallHeaders printed on the Flight Server:\n+    Metadata(content-type=application/grpc,user-agent=grpc-java-netty/1.44.1,auth-token-bin=bXlfdG9rZW4,grpc-accept-encoding=gzip)\n\nReview Comment:\n   I'd rather we omit this in favor of adding a full example to the Cookbook. Also because the server doesn't print that by default, *and* this is a different authentication method than what we just described.\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,216 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a `CallStatus` for common parameters. To indicate\n+failure, raise an exception.\n\nReview Comment:\n   ```suggestion\r\n   Each RPC method always takes a ``CallContext`` for common parameters. To indicate\r\n   failure, pass an exception to the \"listener\" if present, or else raise an\r\n   exception.\r\n   ```\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,216 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a `CallStatus` for common parameters. To indicate\n+failure, raise an exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient`_ with a location.\n\nReview Comment:\n   ```suggestion\r\n   To connect to a Flight service, create a `FlightClient`_ with a location.\r\n   ```\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,216 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a `CallStatus` for common parameters. To indicate\n+failure, raise an exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation opion!\"));\n\nReview Comment:\n   ```suggestion\r\n               flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation option!\"));\r\n   ```\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,216 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a `CallStatus` for common parameters. To indicate\n+failure, raise an exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation opion!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a\n+certificate and key pair to `FlightServer.builder.useTls`.\n+\n+On the client side, use `FlightClient.builder.trustedCertificates`.\n+\n+Enabling Authentication\n+=======================\n+\n+.. warning:: Authentication is insecure without enabling TLS.\n+\n+Handshake-based authentication can be enabled by implementing\n+`ServerAuthHandler`. Authentication consists of two parts: on\n+initial client connection, the server and client authentication\n+implementations can perform any negotiation needed; then, on each RPC\n+thereafter, the client provides a token. The server authentication\n\nReview Comment:\n   Can you look at the wording in #12815 again? This description is inaccurate\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,216 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a `CallStatus` for common parameters. To indicate\n+failure, raise an exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation opion!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a\n+certificate and key pair to `FlightServer.builder.useTls`.\n+\n+On the client side, use `FlightClient.builder.trustedCertificates`.\n+\n+Enabling Authentication\n+=======================\n+\n+.. warning:: Authentication is insecure without enabling TLS.\n+\n+Handshake-based authentication can be enabled by implementing\n+`ServerAuthHandler`. Authentication consists of two parts: on\n+initial client connection, the server and client authentication\n+implementations can perform any negotiation needed; then, on each RPC\n+thereafter, the client provides a token. The server authentication\n+handler validates the token and provides the identity of the\n+client. This identity can be obtained from the\n+`CallContext.peerIdentity`.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    FlightClient client = FlightClient.builder().build();\n+    client.authenticateBasic(\"user\", \"password\");\n+    // Server\n+    FlightServer server = FlightServer.builder().authHandler(new BasicServerAuthHandler(validator)).build();\n+    // CallHeaders printed on the Flight Server:\n+    Metadata(content-type=application/grpc,user-agent=grpc-java-netty/1.44.1,auth-token-bin=bXlfdG9rZW4,grpc-accept-encoding=gzip)\n+\n+\n+\n+Custom Middleware\n+=================\n+\n+Servers and clients support custom middleware (or interceptors) that are called on every\n+request and can modify the request in a limited fashion. These can be implemented by implementing the\n+`FlightServerMiddleware` and `FlightClientMiddleware` interfaces.\n\nReview Comment:\n   ```suggestion\r\n   ``FlightServerMiddleware`` and ``FlightClientMiddleware`` interfaces.\r\n   ```\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,216 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a `CallStatus` for common parameters. To indicate\n+failure, raise an exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation opion!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a\n+certificate and key pair to `FlightServer.builder.useTls`.\n+\n+On the client side, use `FlightClient.builder.trustedCertificates`.\n\nReview Comment:\n   ```suggestion\r\n   On the client side, use ``Location.forGrpcTls`` to create the Location for the client.\r\n   ```\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,216 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a `CallStatus` for common parameters. To indicate\n+failure, raise an exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation opion!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a\n+certificate and key pair to `FlightServer.builder.useTls`.\n+\n+On the client side, use `FlightClient.builder.trustedCertificates`.\n+\n+Enabling Authentication\n+=======================\n+\n+.. warning:: Authentication is insecure without enabling TLS.\n+\n+Handshake-based authentication can be enabled by implementing\n+`ServerAuthHandler`. Authentication consists of two parts: on\n+initial client connection, the server and client authentication\n+implementations can perform any negotiation needed; then, on each RPC\n+thereafter, the client provides a token. The server authentication\n+handler validates the token and provides the identity of the\n+client. This identity can be obtained from the\n+`CallContext.peerIdentity`.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    FlightClient client = FlightClient.builder().build();\n+    client.authenticateBasic(\"user\", \"password\");\n+    // Server\n+    FlightServer server = FlightServer.builder().authHandler(new BasicServerAuthHandler(validator)).build();\n+    // CallHeaders printed on the Flight Server:\n+    Metadata(content-type=application/grpc,user-agent=grpc-java-netty/1.44.1,auth-token-bin=bXlfdG9rZW4,grpc-accept-encoding=gzip)\n+\n+\n+\n+Custom Middleware\n+=================\n+\n+Servers and clients support custom middleware (or interceptors) that are called on every\n+request and can modify the request in a limited fashion. These can be implemented by implementing the\n+`FlightServerMiddleware` and `FlightClientMiddleware` interfaces.\n+\n+Middleware are fairly limited, but they can add headers to a request/response.\n\nReview Comment:\n   See #12815 which describes a little more about what middleware can do\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,216 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a `CallStatus` for common parameters. To indicate\n+failure, raise an exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation opion!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a\n+certificate and key pair to `FlightServer.builder.useTls`.\n+\n+On the client side, use `FlightClient.builder.trustedCertificates`.\n+\n+Enabling Authentication\n+=======================\n+\n+.. warning:: Authentication is insecure without enabling TLS.\n+\n+Handshake-based authentication can be enabled by implementing\n+`ServerAuthHandler`. Authentication consists of two parts: on\n\nReview Comment:\n   ```suggestion\r\n   ``ServerAuthHandler``. Authentication consists of two parts: on\r\n   ```\n\n\n\n",
                    "created": "2022-04-12T11:54:44.158+0000",
                    "updated": "2022-04-12T11:54:44.158+0000",
                    "started": "2022-04-12T11:54:44.158+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "755711",
                    "issueId": "13426654"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/755787",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "davisusanibar commented on code in PR #12847:\nURL: https://github.com/apache/arrow/pull/12847#discussion_r848513677\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,216 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a `CallStatus` for common parameters. To indicate\n+failure, raise an exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation opion!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a\n+certificate and key pair to `FlightServer.builder.useTls`.\n+\n+On the client side, use `FlightClient.builder.trustedCertificates`.\n+\n+Enabling Authentication\n+=======================\n+\n+.. warning:: Authentication is insecure without enabling TLS.\n+\n+Handshake-based authentication can be enabled by implementing\n+`ServerAuthHandler`. Authentication consists of two parts: on\n+initial client connection, the server and client authentication\n+implementations can perform any negotiation needed; then, on each RPC\n+thereafter, the client provides a token. The server authentication\n\nReview Comment:\n   Changed\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,216 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a `CallStatus` for common parameters. To indicate\n+failure, raise an exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation opion!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a\n+certificate and key pair to `FlightServer.builder.useTls`.\n+\n+On the client side, use `FlightClient.builder.trustedCertificates`.\n+\n+Enabling Authentication\n+=======================\n+\n+.. warning:: Authentication is insecure without enabling TLS.\n+\n+Handshake-based authentication can be enabled by implementing\n+`ServerAuthHandler`. Authentication consists of two parts: on\n+initial client connection, the server and client authentication\n+implementations can perform any negotiation needed; then, on each RPC\n+thereafter, the client provides a token. The server authentication\n+handler validates the token and provides the identity of the\n+client. This identity can be obtained from the\n+`CallContext.peerIdentity`.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    FlightClient client = FlightClient.builder().build();\n+    client.authenticateBasic(\"user\", \"password\");\n+    // Server\n+    FlightServer server = FlightServer.builder().authHandler(new BasicServerAuthHandler(validator)).build();\n+    // CallHeaders printed on the Flight Server:\n+    Metadata(content-type=application/grpc,user-agent=grpc-java-netty/1.44.1,auth-token-bin=bXlfdG9rZW4,grpc-accept-encoding=gzip)\n+\n+\n+\n+Custom Middleware\n+=================\n+\n+Servers and clients support custom middleware (or interceptors) that are called on every\n+request and can modify the request in a limited fashion. These can be implemented by implementing the\n+`FlightServerMiddleware` and `FlightClientMiddleware` interfaces.\n+\n+Middleware are fairly limited, but they can add headers to a request/response.\n\nReview Comment:\n   Added\n\n\n\n",
                    "created": "2022-04-12T14:35:18.430+0000",
                    "updated": "2022-04-12T14:35:18.430+0000",
                    "started": "2022-04-12T14:35:18.430+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "755787",
                    "issueId": "13426654"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/755788",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "davisusanibar commented on code in PR #12847:\nURL: https://github.com/apache/arrow/pull/12847#discussion_r848513939\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,216 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a `CallStatus` for common parameters. To indicate\n+failure, raise an exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation opion!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a\n+certificate and key pair to `FlightServer.builder.useTls`.\n+\n+On the client side, use `FlightClient.builder.trustedCertificates`.\n+\n+Enabling Authentication\n+=======================\n+\n+.. warning:: Authentication is insecure without enabling TLS.\n+\n+Handshake-based authentication can be enabled by implementing\n+`ServerAuthHandler`. Authentication consists of two parts: on\n+initial client connection, the server and client authentication\n+implementations can perform any negotiation needed; then, on each RPC\n+thereafter, the client provides a token. The server authentication\n+handler validates the token and provides the identity of the\n+client. This identity can be obtained from the\n+`CallContext.peerIdentity`.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    FlightClient client = FlightClient.builder().build();\n+    client.authenticateBasic(\"user\", \"password\");\n+    // Server\n+    FlightServer server = FlightServer.builder().authHandler(new BasicServerAuthHandler(validator)).build();\n+    // CallHeaders printed on the Flight Server:\n+    Metadata(content-type=application/grpc,user-agent=grpc-java-netty/1.44.1,auth-token-bin=bXlfdG9rZW4,grpc-accept-encoding=gzip)\n\nReview Comment:\n   Deleted\n\n\n\n",
                    "created": "2022-04-12T14:35:33.390+0000",
                    "updated": "2022-04-12T14:35:33.390+0000",
                    "started": "2022-04-12T14:35:33.390+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "755788",
                    "issueId": "13426654"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/755863",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #12847:\nURL: https://github.com/apache/arrow/pull/12847#discussion_r848632282\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,216 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a `CallStatus` for common parameters. To indicate\n+failure, raise an exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation opion!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a\n+certificate and key pair to `FlightServer.builder.useTls`.\n+\n+On the client side, use `FlightClient.builder.trustedCertificates`.\n+\n+Enabling Authentication\n+=======================\n+\n+.. warning:: Authentication is insecure without enabling TLS.\n+\n+Handshake-based authentication can be enabled by implementing\n+`ServerAuthHandler`. Authentication consists of two parts: on\n+initial client connection, the server and client authentication\n+implementations can perform any negotiation needed; then, on each RPC\n+thereafter, the client provides a token. The server authentication\n\nReview Comment:\n   This is still different - this doesn't describe where the client token comes from.\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,215 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a ``CallContext`` for common parameters. To indicate\n+failure, pass an exception to the \"listener\" if present, or else raise an\n+exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, create a `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+``setOnCancelHandler`` or ``isCancelled`` to check if the client has cancelled the call,\n+and if so, break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation option!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a\n+certificate and key pair to ``FlightServer.Builder.useTls``.\n+\n+On the client side, use ``Location.forGrpcTls`` to create the Location for the client.\n+\n+Enabling Authentication\n+=======================\n+\n+.. warning:: Authentication is insecure without enabling TLS.\n+\n+Handshake-based authentication can be enabled by implementing\n+on the client side through authenticates against the Flight service\n+``FlightClient.authenticate``, or by authenticates with a username\n+and password through ``FlightClient.authenticateBasic`` and\n+``FlightClient.authenticateBasicToken``. And on the server side\n+through ``FlightServer.Builder().authHandler`` or by\n+``FlightServer.Builder().headerAuthenticator``.\n\nReview Comment:\n   This mixes up several different things. Can we just stick to the wording already shown? We can add the descriptions of the other auth methods later and frankly they are all not very usable.\n\n\n\n",
                    "created": "2022-04-12T16:23:11.800+0000",
                    "updated": "2022-04-12T16:23:11.800+0000",
                    "started": "2022-04-12T16:23:11.800+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "755863",
                    "issueId": "13426654"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/755950",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "davisusanibar commented on code in PR #12847:\nURL: https://github.com/apache/arrow/pull/12847#discussion_r848772739\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,215 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a ``CallContext`` for common parameters. To indicate\n+failure, pass an exception to the \"listener\" if present, or else raise an\n+exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, create a `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+``setOnCancelHandler`` or ``isCancelled`` to check if the client has cancelled the call,\n+and if so, break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation option!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a\n+certificate and key pair to ``FlightServer.Builder.useTls``.\n+\n+On the client side, use ``Location.forGrpcTls`` to create the Location for the client.\n+\n+Enabling Authentication\n+=======================\n+\n+.. warning:: Authentication is insecure without enabling TLS.\n+\n+Handshake-based authentication can be enabled by implementing\n+on the client side through authenticates against the Flight service\n+``FlightClient.authenticate``, or by authenticates with a username\n+and password through ``FlightClient.authenticateBasic`` and\n+``FlightClient.authenticateBasicToken``. And on the server side\n+through ``FlightServer.Builder().authHandler`` or by\n+``FlightServer.Builder().headerAuthenticator``.\n\nReview Comment:\n   Updated\n\n\n\n",
                    "created": "2022-04-12T18:56:20.602+0000",
                    "updated": "2022-04-12T18:56:20.602+0000",
                    "started": "2022-04-12T18:56:20.602+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "755950",
                    "issueId": "13426654"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/755951",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "davisusanibar commented on code in PR #12847:\nURL: https://github.com/apache/arrow/pull/12847#discussion_r848772957\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,216 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a `CallStatus` for common parameters. To indicate\n+failure, raise an exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, call `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+`setOnCancelHandler` or `isCancelled` to check if the client has cancelled the call, and if so,\n+break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation opion!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a\n+certificate and key pair to `FlightServer.builder.useTls`.\n+\n+On the client side, use `FlightClient.builder.trustedCertificates`.\n+\n+Enabling Authentication\n+=======================\n+\n+.. warning:: Authentication is insecure without enabling TLS.\n+\n+Handshake-based authentication can be enabled by implementing\n+`ServerAuthHandler`. Authentication consists of two parts: on\n+initial client connection, the server and client authentication\n+implementations can perform any negotiation needed; then, on each RPC\n+thereafter, the client provides a token. The server authentication\n\nReview Comment:\n   Added where the token comes from\n\n\n\n",
                    "created": "2022-04-12T18:56:35.534+0000",
                    "updated": "2022-04-12T18:56:35.534+0000",
                    "started": "2022-04-12T18:56:35.533+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "755951",
                    "issueId": "13426654"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/755977",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #12847:\nURL: https://github.com/apache/arrow/pull/12847#discussion_r848788087\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,213 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a ``CallContext`` for common parameters. To indicate\n+failure, pass an exception to the \"listener\" if present, or else raise an\n+exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, create a `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+``setOnCancelHandler`` or ``isCancelled`` to check if the client has cancelled the call,\n+and if so, break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation option!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a\n+certificate and key pair to ``FlightServer.Builder.useTls``.\n+\n+On the client side, use ``Location.forGrpcTls`` to create the Location for the client.\n+\n+Enabling Authentication\n+=======================\n+\n+.. warning:: Authentication is insecure without enabling TLS.\n+\n+Handshake-based authentication can be enabled by implementing\n+Handlers on the client and server side (i.e.: ``ServerAuthHandler``).\n+There are two options available user/password and token.\n\nReview Comment:\n   Both user/password and token authentication are separate - IMO let's not talk about them here, there's some work needed to document all the auth methods available in Flight and explain why you might need to use each, and I don't want to make this confusing.\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,213 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a ``CallContext`` for common parameters. To indicate\n+failure, pass an exception to the \"listener\" if present, or else raise an\n+exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, create a `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+``setOnCancelHandler`` or ``isCancelled`` to check if the client has cancelled the call,\n+and if so, break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation option!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a\n+certificate and key pair to ``FlightServer.Builder.useTls``.\n+\n+On the client side, use ``Location.forGrpcTls`` to create the Location for the client.\n+\n+Enabling Authentication\n+=======================\n+\n+.. warning:: Authentication is insecure without enabling TLS.\n+\n+Handshake-based authentication can be enabled by implementing\n+Handlers on the client and server side (i.e.: ``ServerAuthHandler``).\n+There are two options available user/password and token.\n+\n+Authentication consists of two parts: on\n+initial client connection, the server and client authentication\n+implementations can perform any negotiation needed; then, on each RPC\n+thereafter, the client provides a token. The client set an ID result\n+of user/password through ``CallHeaders`` / ``Metadata`` these IDs is\n+recovered by the server side to do validation. The server authentication\n+handler validates the token and provides the identity of the\n+client. This identity can be obtained from the\n+``CallContext.peerIdentity``.\n+\n\nReview Comment:\n   As evidence of what I mean, this is mixing up how different authentication schemes work. Again, the other PR already explains the basic, handshake-based authentication - let's stick to just explaining that instead of trying to explain all three schemes at once.\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,213 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a ``CallContext`` for common parameters. To indicate\n+failure, pass an exception to the \"listener\" if present, or else raise an\n+exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, create a `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n\nReview Comment:\n   ```suggestion\r\n   When making a call, clients can optionally provide ``CallOptions``. This allows\r\n   ```\n\n\n\n",
                    "created": "2022-04-12T19:16:12.046+0000",
                    "updated": "2022-04-12T19:16:12.046+0000",
                    "started": "2022-04-12T19:16:12.046+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "755977",
                    "issueId": "13426654"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/756031",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "davisusanibar commented on code in PR #12847:\nURL: https://github.com/apache/arrow/pull/12847#discussion_r848866834\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,213 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a ``CallContext`` for common parameters. To indicate\n+failure, pass an exception to the \"listener\" if present, or else raise an\n+exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, create a `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+``setOnCancelHandler`` or ``isCancelled`` to check if the client has cancelled the call,\n+and if so, break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation option!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a\n+certificate and key pair to ``FlightServer.Builder.useTls``.\n+\n+On the client side, use ``Location.forGrpcTls`` to create the Location for the client.\n+\n+Enabling Authentication\n+=======================\n+\n+.. warning:: Authentication is insecure without enabling TLS.\n+\n+Handshake-based authentication can be enabled by implementing\n+Handlers on the client and server side (i.e.: ``ServerAuthHandler``).\n+There are two options available user/password and token.\n\nReview Comment:\n   Thank you for the clarification. Updated.\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -0,0 +1,213 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+================\n+Arrow Flight RPC\n+================\n+\n+Arrow Flight is an RPC framework for efficient transfer of Arrow data\n+over the network.\n+\n+.. contents::\n+\n+.. seealso::\n+\n+   :doc:`Flight protocol documentation <../format/Flight>`\n+        Documentation of the Flight protocol, including how to use\n+        Flight conceptually.\n+\n+   `Java Cookbook <https://arrow.apache.org/cookbook/java/flight.html>`_\n+        Recipes for using Arrow Flight in Java.\n+\n+Writing a Flight Service\n+========================\n+\n+Flight servers implement the `FlightProducer`_ interface. For convenience,\n+they can subclass `NoOpFlightProducer`_ instead, which offers default\n+implementations of all the RPC methods.\n+\n+.. code-block:: Java\n+\n+    public class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+Each RPC method always takes a ``CallContext`` for common parameters. To indicate\n+failure, pass an exception to the \"listener\" if present, or else raise an\n+exception.\n+\n+.. code-block:: Java\n+\n+    // Server\n+    @Override\n+    public void listFlights(CallContext context, Criteria criteria, StreamListener<FlightInfo> listener) {\n+        // ...\n+        listener.onError(\n+            CallStatus.UNAUTHENTICATED.withDescription(\n+                \"Custom UNAUTHENTICATED description message.\").toRuntimeException());\n+        // ...\n+    }\n+\n+    // Client\n+    try{\n+        Iterable<FlightInfo> flightInfosBefore = flightClient.listFlights(Criteria.ALL);\n+        // ...\n+    } catch (FlightRuntimeException e){\n+        // Catch UNAUTHENTICATED exception\n+    }\n+\n+To start a server, create a `Location`_ to specify where to listen, and then create\n+a `FlightServer`_ with an instance of a producer. This will start the server, but\n+won't block the rest of the program. Call ``FlightServer.awaitTermination``\n+to block until the server stops.\n+\n+.. code-block:: Java\n+\n+    class TutorialFlightProducer implements FlightProducer {\n+        @Override\n+        // Override methods or use NoOpFlightProducer for only methods needed\n+    }\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 0);\n+    try(\n+        BufferAllocator allocator = new RootAllocator();\n+        FlightServer server = FlightServer.builder(\n+                allocator,\n+                location,\n+                new TutorialFlightProducer()\n+        ).build();\n+    ){\n+        server.start();\n+        System.out.println(\"Server listening on port \" + server.getPort());\n+        server.awaitTermination();\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+.. code-block:: shell\n+\n+    Server listening on port 58104\n+\n+Using the Flight Client\n+=======================\n+\n+To connect to a Flight service, create a `FlightClient`_ with a location.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58104);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient client = FlightClient.builder(allocator, location).build()){\n+        // ... Consume operations exposed by Flight server\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+Cancellation and Timeouts\n+=========================\n+\n+When making a call, clients can optionally provide `CallOptions`. This allows\n+clients to set a timeout on calls. Also, some objects returned by client RPC calls\n+expose a cancel method which allows terminating a call early.\n+\n+.. code-block:: Java\n+\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+\n+        Iterator<Result> resultIterator = tutorialFlightClient.doAction(\n+                new Action(\"test-timeout\"),\n+                CallOptions.timeout(2, TimeUnit.SECONDS)\n+        );\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+On the server side, timeouts are transparent. For cancellation, the server needs to manually poll\n+``setOnCancelHandler`` or ``isCancelled`` to check if the client has cancelled the call,\n+and if so, break out of any processing the server is currently doing.\n+\n+.. code-block:: Java\n+\n+    // Client\n+    Location location = Location.forGrpcInsecure(\"0.0.0.0\", 58609);\n+    try(BufferAllocator allocator = new RootAllocator();\n+        FlightClient tutorialFlightClient = FlightClient.builder(allocator, location).build()){\n+        try(FlightStream flightStream = flightClient.getStream(new Ticket(new byte[]{}))) {\n+            // ...\n+            flightStream.cancel(\"tutorial-cancel\", new Exception(\"Testing cancellation option!\"));\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    // Server\n+    @Override\n+    public void getStream(CallContext context, Ticket ticket, ServerStreamListener listener) {\n+        // ...\n+        listener.setOnCancelHandler(()->{\n+                    // Implement logic to handle cancellation option\n+                });\n+    }\n+\n+Enabling TLS\n+============\n+\n+TLS can be enabled when setting up a server by providing a\n+certificate and key pair to ``FlightServer.Builder.useTls``.\n+\n+On the client side, use ``Location.forGrpcTls`` to create the Location for the client.\n+\n+Enabling Authentication\n+=======================\n+\n+.. warning:: Authentication is insecure without enabling TLS.\n+\n+Handshake-based authentication can be enabled by implementing\n+Handlers on the client and server side (i.e.: ``ServerAuthHandler``).\n+There are two options available user/password and token.\n+\n+Authentication consists of two parts: on\n+initial client connection, the server and client authentication\n+implementations can perform any negotiation needed; then, on each RPC\n+thereafter, the client provides a token. The client set an ID result\n+of user/password through ``CallHeaders`` / ``Metadata`` these IDs is\n+recovered by the server side to do validation. The server authentication\n+handler validates the token and provides the identity of the\n+client. This identity can be obtained from the\n+``CallContext.peerIdentity``.\n+\n\nReview Comment:\n   Thank you for the clarification. Updated.\n\n\n\n",
                    "created": "2022-04-12T21:02:53.331+0000",
                    "updated": "2022-04-12T21:02:53.331+0000",
                    "started": "2022-04-12T21:02:53.330+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "756031",
                    "issueId": "13426654"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/756039",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #12847:\nURL: https://github.com/apache/arrow/pull/12847#discussion_r848888395\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -181,18 +181,16 @@ Enabling Authentication\n .. warning:: Authentication is insecure without enabling TLS.\n \n Handshake-based authentication can be enabled by implementing\n-Handlers on the client and server side (i.e.: ``ServerAuthHandler``).\n-There are two options available user/password and token.\n-\n-Authentication consists of two parts: on\n+``ServerAuthHandler``. Authentication consists of two parts: on\n initial client connection, the server and client authentication\n implementations can perform any negotiation needed; then, on each RPC\n\nReview Comment:\n   ```suggestion\r\n   implementations can perform any negotiation needed. The client authentication\r\n   handler then provides a token that will be attached to future calls. \r\n   ```\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -181,18 +181,16 @@ Enabling Authentication\n .. warning:: Authentication is insecure without enabling TLS.\n \n Handshake-based authentication can be enabled by implementing\n-Handlers on the client and server side (i.e.: ``ServerAuthHandler``).\n-There are two options available user/password and token.\n-\n-Authentication consists of two parts: on\n+``ServerAuthHandler``. Authentication consists of two parts: on\n initial client connection, the server and client authentication\n implementations can perform any negotiation needed; then, on each RPC\n-thereafter, the client provides a token. The client set an ID result\n-of user/password through ``CallHeaders`` / ``Metadata`` these IDs is\n-recovered by the server side to do validation. The server authentication\n-handler validates the token and provides the identity of the\n-client. This identity can be obtained from the\n-``CallContext.peerIdentity``.\n+thereafter, the client provides a token.\n+\n+The client send data to be validated through ``ClientAuthHandler.authenticate``\n+The server validate data received through ``ServerAuthHandler.authenticate``.\n+After validations, the client and server use a key value to pass/read the token\n+through ``Auth-Token-bin``, then the server use ``ServerAuthInterceptor``\n+to validate token received from.\n\nReview Comment:\n   Let's not talk about how it's implemented, this is not relevant to users.\n\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -181,18 +181,16 @@ Enabling Authentication\n .. warning:: Authentication is insecure without enabling TLS.\n \n Handshake-based authentication can be enabled by implementing\n-Handlers on the client and server side (i.e.: ``ServerAuthHandler``).\n-There are two options available user/password and token.\n-\n-Authentication consists of two parts: on\n+``ServerAuthHandler``. Authentication consists of two parts: on\n initial client connection, the server and client authentication\n implementations can perform any negotiation needed; then, on each RPC\n-thereafter, the client provides a token. The client set an ID result\n-of user/password through ``CallHeaders`` / ``Metadata`` these IDs is\n-recovered by the server side to do validation. The server authentication\n-handler validates the token and provides the identity of the\n-client. This identity can be obtained from the\n-``CallContext.peerIdentity``.\n+thereafter, the client provides a token.\n\nReview Comment:\n   ```suggestion\r\n   ```\n\n\n\n",
                    "created": "2022-04-12T21:33:45.979+0000",
                    "updated": "2022-04-12T21:33:45.979+0000",
                    "started": "2022-04-12T21:33:45.979+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "756039",
                    "issueId": "13426654"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/756040",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "davisusanibar commented on code in PR #12847:\nURL: https://github.com/apache/arrow/pull/12847#discussion_r848892448\n\n\n##########\ndocs/source/java/flight.rst:\n##########\n@@ -181,18 +181,16 @@ Enabling Authentication\n .. warning:: Authentication is insecure without enabling TLS.\n \n Handshake-based authentication can be enabled by implementing\n-Handlers on the client and server side (i.e.: ``ServerAuthHandler``).\n-There are two options available user/password and token.\n-\n-Authentication consists of two parts: on\n+``ServerAuthHandler``. Authentication consists of two parts: on\n initial client connection, the server and client authentication\n implementations can perform any negotiation needed; then, on each RPC\n-thereafter, the client provides a token. The client set an ID result\n-of user/password through ``CallHeaders`` / ``Metadata`` these IDs is\n-recovered by the server side to do validation. The server authentication\n-handler validates the token and provides the identity of the\n-client. This identity can be obtained from the\n-``CallContext.peerIdentity``.\n+thereafter, the client provides a token.\n+\n+The client send data to be validated through ``ClientAuthHandler.authenticate``\n+The server validate data received through ``ServerAuthHandler.authenticate``.\n+After validations, the client and server use a key value to pass/read the token\n+through ``Auth-Token-bin``, then the server use ``ServerAuthInterceptor``\n+to validate token received from.\n\nReview Comment:\n   Deleted\n\n\n\n",
                    "created": "2022-04-12T21:37:11.384+0000",
                    "updated": "2022-04-12T21:37:11.384+0000",
                    "started": "2022-04-12T21:37:11.384+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "756040",
                    "issueId": "13426654"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/worklog/756053",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm closed pull request #12847: ARROW-15577: [Java][Doc] Add Arrow Flight documentation\nURL: https://github.com/apache/arrow/pull/12847\n\n\n",
                    "created": "2022-04-12T22:03:09.170+0000",
                    "updated": "2022-04-12T22:03:09.170+0000",
                    "started": "2022-04-12T22:03:09.170+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "756053",
                    "issueId": "13426654"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 12600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@16d9aad[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2cbc6299[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3a66da35[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7581df4a[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1e0989f9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@5525075e[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@599ec8bd[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@229e374b[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@708a34a0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@de8d218[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@229c2838[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@716b774f[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 12600,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Apr 12 22:03:10 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-04-12T22:03:10.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15577/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2022-02-04T15:47:41.000+0000",
        "updated": "2022-04-13T05:21:00.000+0000",
        "timeoriginalestimate": null,
        "description": "Tutorial on how to use Arrow Flight in Java",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "3.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 12600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Java][Doc] Apache Arrow Flight",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426654/comment/17521353",
                    "id": "17521353",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 12847\n[https://github.com/apache/arrow/pull/12847]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2022-04-12T22:03:10.558+0000",
                    "updated": "2022-04-12T22:03:10.558+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0z9l4:",
        "customfield_12314139": null
    }
}