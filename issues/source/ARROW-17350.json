{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13475821",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821",
    "key": "ARROW-17350",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351947",
                "id": "12351947",
                "description": "",
                "name": "10.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-10-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": null,
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 10800,
            "total": 10800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 10800,
            "total": 10800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17350/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 18,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821/worklog/801631",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on PR #13912:\nURL: https://github.com/apache/arrow/pull/13912#issuecomment-1219247965\n\n   This is a draft, there is still a flaky test and a deadlock in the exec plans but those should be pretty straightforward to address.  I was able to replace the dataset writer's scheduling with the new AsyncTaskScheduler and all dataset writer tests are passing so I think the scheduler itself is getting pretty solid.\n\n\n",
                    "created": "2022-08-18T09:26:36.691+0000",
                    "updated": "2022-08-18T09:26:36.691+0000",
                    "started": "2022-08-18T09:26:36.691+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "801631",
                    "issueId": "13475821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821/worklog/801637",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13912:\nURL: https://github.com/apache/arrow/pull/13912#issuecomment-1219286932\n\n   https://issues.apache.org/jira/browse/ARROW-17350\n\n\n",
                    "created": "2022-08-18T09:52:09.923+0000",
                    "updated": "2022-08-18T09:52:09.923+0000",
                    "started": "2022-08-18T09:52:09.923+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "801637",
                    "issueId": "13475821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821/worklog/801638",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13912:\nURL: https://github.com/apache/arrow/pull/13912#issuecomment-1219286957\n\n   :warning: Ticket **has not been started in JIRA**, please click 'Start Progress'.\n\n\n",
                    "created": "2022-08-18T09:52:11.338+0000",
                    "updated": "2022-08-18T09:52:11.338+0000",
                    "started": "2022-08-18T09:52:11.338+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "801638",
                    "issueId": "13475821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821/worklog/802080",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #13912:\nURL: https://github.com/apache/arrow/pull/13912#discussion_r950404825\n\n\n##########\ncpp/src/arrow/util/async_util.cc:\n##########\n@@ -19,186 +19,334 @@\n \n #include \"arrow/util/future.h\"\n #include \"arrow/util/logging.h\"\n+#include \"arrow/util/make_unique.h\"\n+\n+#include <deque>\n+#include <iostream>\n+#include <list>\n+#include <mutex>\n \n namespace arrow {\n-namespace util {\n \n-AsyncDestroyable::AsyncDestroyable() : on_closed_(Future<>::Make()) {}\n+using internal::make_unique;\n \n-#ifndef NDEBUG\n-AsyncDestroyable::~AsyncDestroyable() {\n-  DCHECK(constructed_correctly_) << \"An instance of AsyncDestroyable must be created by \"\n-                                    \"MakeSharedAsync or MakeUniqueAsync\";\n-}\n-#else\n-AsyncDestroyable::~AsyncDestroyable() = default;\n-#endif\n-\n-void AsyncDestroyable::Destroy() {\n-  DoDestroy().AddCallback([this](const Status& st) {\n-    on_closed_.MarkFinished(st);\n-    delete this;\n-  });\n-}\n+namespace util {\n \n-Status AsyncTaskGroup::AddTask(std::function<Result<Future<>>()> task) {\n-  auto guard = mutex_.Lock();\n-  if (finished_adding_) {\n-    return Status::Cancelled(\"Ignoring task added after the task group has been ended\");\n-  }\n-  if (!err_.ok()) {\n-    return err_;\n-  }\n-  Result<Future<>> maybe_task_fut = task();\n-  if (!maybe_task_fut.ok()) {\n-    err_ = maybe_task_fut.status();\n-    return err_;\n-  }\n-  return AddTaskUnlocked(*maybe_task_fut, std::move(guard));\n-}\n+class ThrottleImpl : public AsyncTaskScheduler::Throttle {\n+ public:\n+  ThrottleImpl(int max_concurrent_cost) : available_cost_(max_concurrent_cost) {}\n \n-Result<bool> AsyncTaskGroup::AddTaskIfNotEnded(std::function<Result<Future<>>()> task) {\n-  auto guard = mutex_.Lock();\n-  if (finished_adding_) {\n-    return false;\n-  }\n-  if (!err_.ok()) {\n-    return err_;\n-  }\n-  Result<Future<>> maybe_task_fut = task();\n-  if (!maybe_task_fut.ok()) {\n-    err_ = maybe_task_fut.status();\n-    return err_;\n+  util::optional<Future<>> TryAcquire(int amt) override {\n+    std::lock_guard<std::mutex> lk(mutex_);\n+    if (backoff_.is_valid()) {\n+      return backoff_;\n+    }\n+    if (amt <= available_cost_) {\n+      available_cost_ -= amt;\n+      return nullopt;\n+    }\n+    backoff_ = Future<>::Make();\n+    return backoff_;\n   }\n-  ARROW_RETURN_NOT_OK(AddTaskUnlocked(*maybe_task_fut, std::move(guard)));\n-  return true;\n-}\n \n-Status AsyncTaskGroup::AddTaskUnlocked(const Future<>& task_fut,\n-                                       util::Mutex::Guard guard) {\n-  // If the task is already finished there is nothing to track so lets save\n-  // some work and return early\n-  if (task_fut.is_finished()) {\n-    err_ &= task_fut.status();\n-    return err_;\n+  void Release(int amt) override {\n+    Future<> backoff_to_fulfill;\n+    {\n+      std::lock_guard<std::mutex> lk(mutex_);\n+      available_cost_ += amt;\n+      if (backoff_.is_valid()) {\n+        backoff_to_fulfill = std::move(backoff_);\n+      }\n+    }\n+    if (backoff_to_fulfill.is_valid()) {\n+      backoff_to_fulfill.MarkFinished();\n+    }\n   }\n-  running_tasks_++;\n-  guard.Unlock();\n-  task_fut.AddCallback([this](const Status& st) {\n-    auto guard = mutex_.Lock();\n-    err_ &= st;\n-    if (--running_tasks_ == 0 && finished_adding_) {\n-      guard.Unlock();\n-      all_tasks_done_.MarkFinished(err_);\n-    }\n-  });\n-  return Status::OK();\n+\n+ private:\n+  std::mutex mutex_;\n+  int available_cost_;\n+  Future<> backoff_;\n+};\n+\n+std::unique_ptr<AsyncTaskScheduler::Throttle> AsyncTaskScheduler::MakeThrottle(\n+    int max_concurrent_cost) {\n+  return make_unique<ThrottleImpl>(max_concurrent_cost);\n }\n \n-Status AsyncTaskGroup::AddTask(const Future<>& task_fut) {\n-  auto guard = mutex_.Lock();\n-  if (finished_adding_) {\n-    return Status::Cancelled(\"Ignoring task added after the task group has been ended\");\n-  }\n-  if (!err_.ok()) {\n-    return err_;\n+namespace {\n+\n+// Very basic FIFO queue\n+class FifoQueue : public AsyncTaskScheduler::Queue {\n+  using Task = AsyncTaskScheduler::Task;\n+  void Push(std::unique_ptr<Task> task) override { tasks_.push_back(std::move(task)); }\n+\n+  std::unique_ptr<Task> Pop() override {\n+    std::unique_ptr<Task> task = std::move(tasks_.front());\n+    tasks_.pop_front();\n+    return task;\n   }\n-  return AddTaskUnlocked(task_fut, std::move(guard));\n-}\n \n-Result<bool> AsyncTaskGroup::AddTaskIfNotEnded(const Future<>& task_fut) {\n-  auto guard = mutex_.Lock();\n-  if (finished_adding_) {\n-    return false;\n+  const Task& Peek() override { return *tasks_.front(); }\n+\n+  bool Empty() override { return tasks_.empty(); }\n+\n+  void Purge() override { tasks_.clear(); }\n+\n+ private:\n+  std::list<std::unique_ptr<Task>> tasks_;\n\nReview Comment:\n   nit: use a `std::deque` instead of a linked list?\n\n\n\n##########\ncpp/src/arrow/util/async_util.h:\n##########\n@@ -147,70 +207,42 @@ class ARROW_EXPORT AsyncTaskGroup {\n   ///\n   /// This is a utility method for workflows where the finish future needs to be\n   /// referenced before all top level tasks have been queued.\n-  Future<> OnFinished() const;\n+  virtual Future<> OnFinished() const = 0;\n \n- private:\n-  Status AddTaskUnlocked(const Future<>& task, util::Mutex::Guard guard);\n-\n-  bool finished_adding_ = false;\n-  int running_tasks_ = 0;\n-  Status err_;\n-  Future<> all_tasks_done_ = Future<>::Make();\n-  util::Mutex mutex_;\n-};\n-\n-/// A task group which serializes asynchronous tasks in a push-based workflow\n-///\n-/// Tasks will be executed in the order they are added\n-///\n-/// This will buffer results in an unlimited fashion so it should be combined\n-/// with some kind of backpressure\n-class ARROW_EXPORT SerializedAsyncTaskGroup {\n- public:\n-  SerializedAsyncTaskGroup();\n-  /// Push an item into the serializer and (eventually) into the consumer\n+  /// Create a sub-scheduler for tracking a subset of tasks\n   ///\n-  /// The item will not be delivered to the consumer until all previous items have been\n-  /// consumed.\n+  /// The parent scheduler will manage the lifetime of the sub-scheduler.  It will\n+  /// be destroyed once it is finished.\n   ///\n-  /// If the consumer returns an error then this serializer will go into an error state\n-  /// and all subsequent pushes will fail with that error.  Pushes that have been queued\n-  /// but not delivered will be silently dropped.\n+  /// Often some state needs to be associated with a subset of tasks.\n+  /// For example, when scanning a dataset we need to keep a file reader\n+  /// alive for all of the read tasks for each file. A sub-scheduler can be used to do\n+  /// this.\n   ///\n-  /// \\return True if the item was pushed immediately to the consumer, false if it was\n-  /// queued\n-  Status AddTask(std::function<Result<Future<>>()> task);\n-\n-  /// Signal that all top level tasks have been added\n+  /// The parent scheduler may be ended before all of its sub-schedulers\n+  /// are ended.\n   ///\n-  /// The returned future that will finish when all tasks have been consumed.\n-  Future<> End();\n-\n-  /// Abort a task group\n+  /// If either the parent scheduler or the sub-scheduler encounter an error\n+  /// then they will both enter an aborted state (this is a shared state).\n+  /// Finish callbacks will not be run when the scheduler is aborted.\n   ///\n-  /// Tasks that have not been started will be discarded\n+  /// The parent scheduler will not complete until the sub-scheduler's\n+  /// tasks (and finish callback) have all executed.\n   ///\n-  /// The returned future will finish when all running tasks have finished.\n-  Future<> Abort(Status err);\n+  /// A sub-scheduler can share the same throttle as its parent but it\n+  /// can also have its own unique throttle.\n\nReview Comment:\n   This means a sub-scheduler can schedule more tasks even if the parent wouldn't normally be able to?\n\n\n\n##########\ncpp/src/arrow/dataset/file_base.cc:\n##########\n@@ -488,13 +504,15 @@ class TeeNode : public compute::MapNode {\n   const char* kind_name() const override { return \"TeeNode\"; }\n \n   void Finish(Status finish_st) override {\n-    dataset_writer_->Finish().AddCallback([this, finish_st](const Status& dw_status) {\n-      // Need to wait for the task group to complete regardless of dw_status\n-      task_group_.End().AddCallback(\n-          [this, dw_status, finish_st](const Status& tg_status) {\n-            finished_.MarkFinished(dw_status & finish_st & tg_status);\n-          });\n-    });\n+    if (!finish_st.ok()) {\n+      MapNode::Finish(std::move(finish_st));\n+    }\n+    Status writer_finish_st = dataset_writer_->Finish();\n+    if (!writer_finish_st.ok()) {\n+      MapNode::Finish(std::move(writer_finish_st));\n+    }\n+    serial_scheduler_->End();\n+    MapNode::Finish(Status::OK());\n\nReview Comment:\n   Doesn't this potentially call MapNode::Finish multiple times?\n\n\n\n##########\ncpp/src/arrow/util/async_util.h:\n##########\n@@ -17,128 +17,188 @@\n \n #pragma once\n \n-#include <queue>\n-\n #include \"arrow/result.h\"\n #include \"arrow/status.h\"\n+#include \"arrow/util/functional.h\"\n #include \"arrow/util/future.h\"\n+#include \"arrow/util/make_unique.h\"\n #include \"arrow/util/mutex.h\"\n \n namespace arrow {\n-namespace util {\n \n-/// Custom deleter for AsyncDestroyable objects\n-template <typename T>\n-struct DestroyingDeleter {\n-  void operator()(T* p) {\n-    if (p) {\n-      p->Destroy();\n-    }\n-  }\n-};\n+using internal::FnOnce;\n+using internal::make_unique;\n \n-/// An object which should be asynchronously closed before it is destroyed\n+namespace util {\n+\n+/// A utility which keeps tracks of, and schedules, asynchronous tasks\n ///\n-/// Classes can extend this to ensure that the close method is called and completed\n-/// before the instance is deleted.  This provides smart_ptr / delete semantics for\n-/// objects with an asynchronous destructor.\n+/// An asynchronous task has a synchronous component and an asynchronous component.\n+/// The synchronous component typically schedules some kind of work on an external\n+/// resource (e.g. the I/O thread pool or some kind of kernel-based asynchronous\n+/// resource like io_uring).  The asynchronous part represents the work\n+/// done on that external resource.  Executing the synchronous part will be referred\n+/// to as \"submitting the task\" since this usually includes submitting the asynchronous\n+/// portion to the external thread pool.\n ///\n-/// Classes which extend this must be constructed using MakeSharedAsync or MakeUniqueAsync\n-class ARROW_EXPORT AsyncDestroyable {\n- public:\n-  AsyncDestroyable();\n-  virtual ~AsyncDestroyable();\n-\n-  /// A future which will complete when the AsyncDestroyable has finished and is ready\n-  /// to be deleted.\n-  ///\n-  /// This can be used to ensure all work done by this object has been completed before\n-  /// proceeding.\n-  Future<> on_closed() { return on_closed_; }\n-\n- protected:\n-  /// Subclasses should override this and perform any cleanup.  Once the future returned\n-  /// by this method finishes then this object is eligible for destruction and any\n-  /// reference to `this` will be invalid\n-  virtual Future<> DoDestroy() = 0;\n-\n- private:\n-  void Destroy();\n-\n-  Future<> on_closed_;\n-#ifndef NDEBUG\n-  bool constructed_correctly_ = false;\n-#endif\n-\n-  template <typename T>\n-  friend struct DestroyingDeleter;\n-  template <typename T, typename... Args>\n-  friend std::shared_ptr<T> MakeSharedAsync(Args&&... args);\n-  template <typename T, typename... Args>\n-  friend std::unique_ptr<T, DestroyingDeleter<T>> MakeUniqueAsync(Args&&... args);\n-};\n-\n-template <typename T, typename... Args>\n-std::shared_ptr<T> MakeSharedAsync(Args&&... args) {\n-  static_assert(std::is_base_of<AsyncDestroyable, T>::value,\n-                \"Nursery::MakeSharedCloseable only works with AsyncDestroyable types\");\n-  std::shared_ptr<T> ptr(new T(std::forward<Args&&>(args)...), DestroyingDeleter<T>());\n-#ifndef NDEBUG\n-  ptr->constructed_correctly_ = true;\n-#endif\n-  return ptr;\n-}\n-\n-template <typename T, typename... Args>\n-std::unique_ptr<T, DestroyingDeleter<T>> MakeUniqueAsync(Args&&... args) {\n-  static_assert(std::is_base_of<AsyncDestroyable, T>::value,\n-                \"Nursery::MakeUniqueCloseable only works with AsyncDestroyable types\");\n-  std::unique_ptr<T, DestroyingDeleter<T>> ptr(new T(std::forward<Args>(args)...),\n-                                               DestroyingDeleter<T>());\n-#ifndef NDEBUG\n-  ptr->constructed_correctly_ = true;\n-#endif\n-  return ptr;\n-}\n-\n-/// A utility which keeps track of a collection of asynchronous tasks\n+/// By default the scheduler will submit the task (execute the synchronous part) as\n+/// soon as it is added, assuming the underlying thread pool hasn't terminated or the\n+/// scheduler hasn't aborted.  In this mode the scheduler is simply acting as\n+/// a task group, keeping track of the ongoing work.\n ///\n /// This can be used to provide structured concurrency for asynchronous development.\n /// A task group created at a high level can be distributed amongst low level components\n /// which register work to be completed.  The high level job can then wait for all work\n /// to be completed before cleaning up.\n-class ARROW_EXPORT AsyncTaskGroup {\n+///\n+/// A task scheduler must eventually be ended when all tasks have been added.  Once the\n+/// scheduler has been ended it is an error to add further tasks.  Note, it is not an\n+/// error to add additional tasks after a scheduler has aborted (though these tasks\n+/// will be ignored and never submitted).  The scheduler has a futuer which will complete\n+/// once the scheduler has been ended AND all remaining tasks have finished executing.\n+/// Ending a scheduler will NOT cause the scheduler to flush existing tasks.\n+///\n+/// Task failure (either the synchronous portion or the asynchronous portion) will cause\n+/// the scheduler to enter an aborted state.  The first such failure will be reported in\n+/// the final task future.\n+///\n+/// The scheduler can also be manually aborted.  A cancellation status will be reported as\n+/// the final task future.\n+///\n+/// It is also possible to limit the number of concurrent tasks the scheduler will\n+/// execute. This is done by setting a task limit.  The task limit initially assumes all\n+/// tasks are equal but a custom cost can be supplied when scheduling a task (e.g. based\n+/// on the total I/O cost of the task, or the expected RAM utilization of the task)\n+///\n+/// When the total number of running tasks is limited then scheduler priority may also\n+/// become a consideration.  By default the scheduler runs with a FIFO queue but a custom\n+/// task queue can be provided.  One could, for example, use a priority queue to control\n+/// the order in which tasks are executed.\n+///\n+/// It is common to have multiple stages of execution.  For example, when scanning, we\n+/// first inspect each fragment (the inspect stage) to figure out the row groups and then\n+/// we scan row groups (the scan stage) to read in the data.  This sort of multi-stage\n+/// execution should be represented as two seperate task groups.  The first task group can\n+/// then have a custom finish callback which ends the second task group.\n+class ARROW_EXPORT AsyncTaskScheduler {\n  public:\n-  /// Add a task to be tracked by this task group\n-  ///\n-  /// If a previous task has failed then adding a task will fail\n-  ///\n-  /// If WaitForTasksToFinish has been called and the returned future has been marked\n-  /// completed then adding a task will fail.\n-  Status AddTask(std::function<Result<Future<>>()> task);\n-  /// Same as AddTask but doesn't add the task if End() has been called.\n-  ///\n-  /// \\return true if the task was started, false if the group had already ended\n-  Result<bool> AddTaskIfNotEnded(std::function<Result<Future<>>()> task);\n-  /// Add a task that has already been started\n-  Status AddTask(const Future<>& task);\n-  /// \\brief Attempt to add a task that has already been started to this group's tracking\n-  ///\n-  /// The return value must be paid attention to.  If the return value is false then the\n-  /// task could not be added because the group had already ended and so the caller must\n-  /// track the external task some other way.\n-  Result<bool> AddTaskIfNotEnded(const Future<>& task);\n-  /// Signal that top level tasks are done being added\n+  /// Destructor for AsyncTaskScheduler\n+  ///\n+  /// If a scheduler is not in the ended state when it is destroyed then it\n+  /// will enter an aborted state.\n+  ///\n+  /// The destructor will block until all submitted tasks have finished.\n+  virtual ~AsyncTaskScheduler() = default;\n+  /// An interface for a task\n+  ///\n+  /// Users may want to override this, for example, to add priority\n+  /// information for use by a queue.\n+  class Task {\n+   public:\n+    virtual ~Task() = default;\n+    /// Submit the task\n+    ///\n+    /// This will be called by the scheduler at most once when there\n+    /// is space to run the task.  This is expected to be a fairly quick\n+    /// function that simply submits the actual task work to an external\n+    /// resource (e.g. I/O thread pool).\n+    ///\n+    /// If this call fails then the scheduler will enter an aborted state.\n+    virtual Result<Future<>> operator()(AsyncTaskScheduler* scheduler) = 0;\n+    /// The cost of the task\n+    ///\n+    /// The scheduler limits the total number of concurrent tasks based\n+    /// on cost.  A custom cost may be used, for example, if you would like\n+    /// to limit the number of tasks based on the total expected RAM usage of\n+    /// the tasks (this is done in the scanner)\n+    virtual int cost() const { return 1; }\n+  };\n+\n+  /// An interface for a task queue\n+  ///\n+  /// A queue's methods will not be called concurrently\n+  class Queue {\n+   public:\n+    virtual ~Queue() = default;\n+    /// Push a task to the queue\n+    virtual void Push(std::unique_ptr<Task> task) = 0;\n+    /// Pop the next task from the queue\n+    virtual std::unique_ptr<Task> Pop() = 0;\n+    /// Peek the next task in the queue\n+    virtual const Task& Peek() = 0;\n+    /// Check if the queue is empty\n+    virtual bool Empty() = 0;\n+    /// Purge the queue of all items\n+    virtual void Purge() = 0;\n+  };\n+\n+  class Throttle {\n+   public:\n+    virtual ~Throttle() = default;\n+    /// Acquire amt permits\n+    ///\n+    /// If nullopt is returned then the permits were immediately\n+    /// acquired and the caller can proceed.  If a future is returned then the caller\n+    /// should wait for the future to complete first.  When the returned future completes\n+    /// the permits have NOT been acquired and the caller must call Acquire again\n+    virtual util::optional<Future<>> TryAcquire(int amt) = 0;\n+    /// Release amt permits\n+    ///\n+    /// This will possibly complete waiting futures and should probably not be\n+    /// called while holding locks.\n+    virtual void Release(int amt) = 0;\n+  };\n+  /// Create a throttle\n+  ///\n+  /// This throttle is used to limit how many tasks can run at once.  The\n+  /// user should keep the throttle alive for the lifetime of the scheduler.\n+  /// The same throttle can be used in multiple schedulers.\n+  static std::unique_ptr<Throttle> MakeThrottle(int max_concurrent_cost);\n+\n+  /// Add a task to the scheduler\n+  ///\n+  /// If the scheduler is in an aborted state this call will return false and the task\n+  /// will never be run.  This is harmless and does not need to be guarded against.\n+  ///\n+  /// If the scheduler is in an ended state then this call will cause an abort.  This\n+  /// represents a logic error in the program and should be avoidable.\n\nReview Comment:\n   I wonder if we should error instead just so that a bug doesn't, say, tear down a notebook kernel or crash the R interpreter?\n\n\n\n",
                    "created": "2022-08-19T17:27:38.659+0000",
                    "updated": "2022-08-19T17:27:38.659+0000",
                    "started": "2022-08-19T17:27:38.659+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "802080",
                    "issueId": "13475821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821/worklog/802084",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13912:\nURL: https://github.com/apache/arrow/pull/13912#discussion_r950423621\n\n\n##########\ncpp/src/arrow/util/async_util.h:\n##########\n@@ -17,128 +17,188 @@\n \n #pragma once\n \n-#include <queue>\n-\n #include \"arrow/result.h\"\n #include \"arrow/status.h\"\n+#include \"arrow/util/functional.h\"\n #include \"arrow/util/future.h\"\n+#include \"arrow/util/make_unique.h\"\n #include \"arrow/util/mutex.h\"\n \n namespace arrow {\n-namespace util {\n \n-/// Custom deleter for AsyncDestroyable objects\n-template <typename T>\n-struct DestroyingDeleter {\n-  void operator()(T* p) {\n-    if (p) {\n-      p->Destroy();\n-    }\n-  }\n-};\n+using internal::FnOnce;\n+using internal::make_unique;\n \n-/// An object which should be asynchronously closed before it is destroyed\n+namespace util {\n+\n+/// A utility which keeps tracks of, and schedules, asynchronous tasks\n ///\n-/// Classes can extend this to ensure that the close method is called and completed\n-/// before the instance is deleted.  This provides smart_ptr / delete semantics for\n-/// objects with an asynchronous destructor.\n+/// An asynchronous task has a synchronous component and an asynchronous component.\n+/// The synchronous component typically schedules some kind of work on an external\n+/// resource (e.g. the I/O thread pool or some kind of kernel-based asynchronous\n+/// resource like io_uring).  The asynchronous part represents the work\n+/// done on that external resource.  Executing the synchronous part will be referred\n+/// to as \"submitting the task\" since this usually includes submitting the asynchronous\n+/// portion to the external thread pool.\n ///\n-/// Classes which extend this must be constructed using MakeSharedAsync or MakeUniqueAsync\n-class ARROW_EXPORT AsyncDestroyable {\n- public:\n-  AsyncDestroyable();\n-  virtual ~AsyncDestroyable();\n-\n-  /// A future which will complete when the AsyncDestroyable has finished and is ready\n-  /// to be deleted.\n-  ///\n-  /// This can be used to ensure all work done by this object has been completed before\n-  /// proceeding.\n-  Future<> on_closed() { return on_closed_; }\n-\n- protected:\n-  /// Subclasses should override this and perform any cleanup.  Once the future returned\n-  /// by this method finishes then this object is eligible for destruction and any\n-  /// reference to `this` will be invalid\n-  virtual Future<> DoDestroy() = 0;\n-\n- private:\n-  void Destroy();\n-\n-  Future<> on_closed_;\n-#ifndef NDEBUG\n-  bool constructed_correctly_ = false;\n-#endif\n-\n-  template <typename T>\n-  friend struct DestroyingDeleter;\n-  template <typename T, typename... Args>\n-  friend std::shared_ptr<T> MakeSharedAsync(Args&&... args);\n-  template <typename T, typename... Args>\n-  friend std::unique_ptr<T, DestroyingDeleter<T>> MakeUniqueAsync(Args&&... args);\n-};\n-\n-template <typename T, typename... Args>\n-std::shared_ptr<T> MakeSharedAsync(Args&&... args) {\n-  static_assert(std::is_base_of<AsyncDestroyable, T>::value,\n-                \"Nursery::MakeSharedCloseable only works with AsyncDestroyable types\");\n-  std::shared_ptr<T> ptr(new T(std::forward<Args&&>(args)...), DestroyingDeleter<T>());\n-#ifndef NDEBUG\n-  ptr->constructed_correctly_ = true;\n-#endif\n-  return ptr;\n-}\n-\n-template <typename T, typename... Args>\n-std::unique_ptr<T, DestroyingDeleter<T>> MakeUniqueAsync(Args&&... args) {\n-  static_assert(std::is_base_of<AsyncDestroyable, T>::value,\n-                \"Nursery::MakeUniqueCloseable only works with AsyncDestroyable types\");\n-  std::unique_ptr<T, DestroyingDeleter<T>> ptr(new T(std::forward<Args>(args)...),\n-                                               DestroyingDeleter<T>());\n-#ifndef NDEBUG\n-  ptr->constructed_correctly_ = true;\n-#endif\n-  return ptr;\n-}\n-\n-/// A utility which keeps track of a collection of asynchronous tasks\n+/// By default the scheduler will submit the task (execute the synchronous part) as\n+/// soon as it is added, assuming the underlying thread pool hasn't terminated or the\n+/// scheduler hasn't aborted.  In this mode the scheduler is simply acting as\n+/// a task group, keeping track of the ongoing work.\n ///\n /// This can be used to provide structured concurrency for asynchronous development.\n /// A task group created at a high level can be distributed amongst low level components\n /// which register work to be completed.  The high level job can then wait for all work\n /// to be completed before cleaning up.\n-class ARROW_EXPORT AsyncTaskGroup {\n+///\n+/// A task scheduler must eventually be ended when all tasks have been added.  Once the\n+/// scheduler has been ended it is an error to add further tasks.  Note, it is not an\n+/// error to add additional tasks after a scheduler has aborted (though these tasks\n+/// will be ignored and never submitted).  The scheduler has a futuer which will complete\n+/// once the scheduler has been ended AND all remaining tasks have finished executing.\n+/// Ending a scheduler will NOT cause the scheduler to flush existing tasks.\n+///\n+/// Task failure (either the synchronous portion or the asynchronous portion) will cause\n+/// the scheduler to enter an aborted state.  The first such failure will be reported in\n+/// the final task future.\n+///\n+/// The scheduler can also be manually aborted.  A cancellation status will be reported as\n+/// the final task future.\n+///\n+/// It is also possible to limit the number of concurrent tasks the scheduler will\n+/// execute. This is done by setting a task limit.  The task limit initially assumes all\n+/// tasks are equal but a custom cost can be supplied when scheduling a task (e.g. based\n+/// on the total I/O cost of the task, or the expected RAM utilization of the task)\n+///\n+/// When the total number of running tasks is limited then scheduler priority may also\n+/// become a consideration.  By default the scheduler runs with a FIFO queue but a custom\n+/// task queue can be provided.  One could, for example, use a priority queue to control\n+/// the order in which tasks are executed.\n+///\n+/// It is common to have multiple stages of execution.  For example, when scanning, we\n+/// first inspect each fragment (the inspect stage) to figure out the row groups and then\n+/// we scan row groups (the scan stage) to read in the data.  This sort of multi-stage\n+/// execution should be represented as two seperate task groups.  The first task group can\n+/// then have a custom finish callback which ends the second task group.\n+class ARROW_EXPORT AsyncTaskScheduler {\n  public:\n-  /// Add a task to be tracked by this task group\n-  ///\n-  /// If a previous task has failed then adding a task will fail\n-  ///\n-  /// If WaitForTasksToFinish has been called and the returned future has been marked\n-  /// completed then adding a task will fail.\n-  Status AddTask(std::function<Result<Future<>>()> task);\n-  /// Same as AddTask but doesn't add the task if End() has been called.\n-  ///\n-  /// \\return true if the task was started, false if the group had already ended\n-  Result<bool> AddTaskIfNotEnded(std::function<Result<Future<>>()> task);\n-  /// Add a task that has already been started\n-  Status AddTask(const Future<>& task);\n-  /// \\brief Attempt to add a task that has already been started to this group's tracking\n-  ///\n-  /// The return value must be paid attention to.  If the return value is false then the\n-  /// task could not be added because the group had already ended and so the caller must\n-  /// track the external task some other way.\n-  Result<bool> AddTaskIfNotEnded(const Future<>& task);\n-  /// Signal that top level tasks are done being added\n+  /// Destructor for AsyncTaskScheduler\n+  ///\n+  /// If a scheduler is not in the ended state when it is destroyed then it\n+  /// will enter an aborted state.\n+  ///\n+  /// The destructor will block until all submitted tasks have finished.\n+  virtual ~AsyncTaskScheduler() = default;\n+  /// An interface for a task\n+  ///\n+  /// Users may want to override this, for example, to add priority\n+  /// information for use by a queue.\n+  class Task {\n+   public:\n+    virtual ~Task() = default;\n+    /// Submit the task\n+    ///\n+    /// This will be called by the scheduler at most once when there\n+    /// is space to run the task.  This is expected to be a fairly quick\n+    /// function that simply submits the actual task work to an external\n+    /// resource (e.g. I/O thread pool).\n+    ///\n+    /// If this call fails then the scheduler will enter an aborted state.\n+    virtual Result<Future<>> operator()(AsyncTaskScheduler* scheduler) = 0;\n+    /// The cost of the task\n+    ///\n+    /// The scheduler limits the total number of concurrent tasks based\n+    /// on cost.  A custom cost may be used, for example, if you would like\n+    /// to limit the number of tasks based on the total expected RAM usage of\n+    /// the tasks (this is done in the scanner)\n+    virtual int cost() const { return 1; }\n+  };\n+\n+  /// An interface for a task queue\n+  ///\n+  /// A queue's methods will not be called concurrently\n+  class Queue {\n+   public:\n+    virtual ~Queue() = default;\n+    /// Push a task to the queue\n+    virtual void Push(std::unique_ptr<Task> task) = 0;\n+    /// Pop the next task from the queue\n+    virtual std::unique_ptr<Task> Pop() = 0;\n+    /// Peek the next task in the queue\n+    virtual const Task& Peek() = 0;\n+    /// Check if the queue is empty\n+    virtual bool Empty() = 0;\n+    /// Purge the queue of all items\n+    virtual void Purge() = 0;\n+  };\n+\n+  class Throttle {\n+   public:\n+    virtual ~Throttle() = default;\n+    /// Acquire amt permits\n+    ///\n+    /// If nullopt is returned then the permits were immediately\n+    /// acquired and the caller can proceed.  If a future is returned then the caller\n+    /// should wait for the future to complete first.  When the returned future completes\n+    /// the permits have NOT been acquired and the caller must call Acquire again\n+    virtual util::optional<Future<>> TryAcquire(int amt) = 0;\n+    /// Release amt permits\n+    ///\n+    /// This will possibly complete waiting futures and should probably not be\n+    /// called while holding locks.\n+    virtual void Release(int amt) = 0;\n+  };\n+  /// Create a throttle\n+  ///\n+  /// This throttle is used to limit how many tasks can run at once.  The\n+  /// user should keep the throttle alive for the lifetime of the scheduler.\n+  /// The same throttle can be used in multiple schedulers.\n+  static std::unique_ptr<Throttle> MakeThrottle(int max_concurrent_cost);\n+\n+  /// Add a task to the scheduler\n+  ///\n+  /// If the scheduler is in an aborted state this call will return false and the task\n+  /// will never be run.  This is harmless and does not need to be guarded against.\n+  ///\n+  /// If the scheduler is in an ended state then this call will cause an abort.  This\n+  /// represents a logic error in the program and should be avoidable.\n\nReview Comment:\n   I can change it to a warning.  It is \"pretty safe\" to just ignore the task.  However, once a scheduler has ended the scheduler, and any resources tied to it, are effectively available for deletion.  So even if we don't abort here it is likely that there will be some dangling references/pointers that will explode later on.\n\n\n\n",
                    "created": "2022-08-19T17:32:19.354+0000",
                    "updated": "2022-08-19T17:32:19.354+0000",
                    "started": "2022-08-19T17:32:19.353+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "802084",
                    "issueId": "13475821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821/worklog/802086",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #13912:\nURL: https://github.com/apache/arrow/pull/13912#discussion_r950424748\n\n\n##########\ncpp/src/arrow/util/async_util.h:\n##########\n@@ -17,128 +17,188 @@\n \n #pragma once\n \n-#include <queue>\n-\n #include \"arrow/result.h\"\n #include \"arrow/status.h\"\n+#include \"arrow/util/functional.h\"\n #include \"arrow/util/future.h\"\n+#include \"arrow/util/make_unique.h\"\n #include \"arrow/util/mutex.h\"\n \n namespace arrow {\n-namespace util {\n \n-/// Custom deleter for AsyncDestroyable objects\n-template <typename T>\n-struct DestroyingDeleter {\n-  void operator()(T* p) {\n-    if (p) {\n-      p->Destroy();\n-    }\n-  }\n-};\n+using internal::FnOnce;\n+using internal::make_unique;\n \n-/// An object which should be asynchronously closed before it is destroyed\n+namespace util {\n+\n+/// A utility which keeps tracks of, and schedules, asynchronous tasks\n ///\n-/// Classes can extend this to ensure that the close method is called and completed\n-/// before the instance is deleted.  This provides smart_ptr / delete semantics for\n-/// objects with an asynchronous destructor.\n+/// An asynchronous task has a synchronous component and an asynchronous component.\n+/// The synchronous component typically schedules some kind of work on an external\n+/// resource (e.g. the I/O thread pool or some kind of kernel-based asynchronous\n+/// resource like io_uring).  The asynchronous part represents the work\n+/// done on that external resource.  Executing the synchronous part will be referred\n+/// to as \"submitting the task\" since this usually includes submitting the asynchronous\n+/// portion to the external thread pool.\n ///\n-/// Classes which extend this must be constructed using MakeSharedAsync or MakeUniqueAsync\n-class ARROW_EXPORT AsyncDestroyable {\n- public:\n-  AsyncDestroyable();\n-  virtual ~AsyncDestroyable();\n-\n-  /// A future which will complete when the AsyncDestroyable has finished and is ready\n-  /// to be deleted.\n-  ///\n-  /// This can be used to ensure all work done by this object has been completed before\n-  /// proceeding.\n-  Future<> on_closed() { return on_closed_; }\n-\n- protected:\n-  /// Subclasses should override this and perform any cleanup.  Once the future returned\n-  /// by this method finishes then this object is eligible for destruction and any\n-  /// reference to `this` will be invalid\n-  virtual Future<> DoDestroy() = 0;\n-\n- private:\n-  void Destroy();\n-\n-  Future<> on_closed_;\n-#ifndef NDEBUG\n-  bool constructed_correctly_ = false;\n-#endif\n-\n-  template <typename T>\n-  friend struct DestroyingDeleter;\n-  template <typename T, typename... Args>\n-  friend std::shared_ptr<T> MakeSharedAsync(Args&&... args);\n-  template <typename T, typename... Args>\n-  friend std::unique_ptr<T, DestroyingDeleter<T>> MakeUniqueAsync(Args&&... args);\n-};\n-\n-template <typename T, typename... Args>\n-std::shared_ptr<T> MakeSharedAsync(Args&&... args) {\n-  static_assert(std::is_base_of<AsyncDestroyable, T>::value,\n-                \"Nursery::MakeSharedCloseable only works with AsyncDestroyable types\");\n-  std::shared_ptr<T> ptr(new T(std::forward<Args&&>(args)...), DestroyingDeleter<T>());\n-#ifndef NDEBUG\n-  ptr->constructed_correctly_ = true;\n-#endif\n-  return ptr;\n-}\n-\n-template <typename T, typename... Args>\n-std::unique_ptr<T, DestroyingDeleter<T>> MakeUniqueAsync(Args&&... args) {\n-  static_assert(std::is_base_of<AsyncDestroyable, T>::value,\n-                \"Nursery::MakeUniqueCloseable only works with AsyncDestroyable types\");\n-  std::unique_ptr<T, DestroyingDeleter<T>> ptr(new T(std::forward<Args>(args)...),\n-                                               DestroyingDeleter<T>());\n-#ifndef NDEBUG\n-  ptr->constructed_correctly_ = true;\n-#endif\n-  return ptr;\n-}\n-\n-/// A utility which keeps track of a collection of asynchronous tasks\n+/// By default the scheduler will submit the task (execute the synchronous part) as\n+/// soon as it is added, assuming the underlying thread pool hasn't terminated or the\n+/// scheduler hasn't aborted.  In this mode the scheduler is simply acting as\n+/// a task group, keeping track of the ongoing work.\n ///\n /// This can be used to provide structured concurrency for asynchronous development.\n /// A task group created at a high level can be distributed amongst low level components\n /// which register work to be completed.  The high level job can then wait for all work\n /// to be completed before cleaning up.\n-class ARROW_EXPORT AsyncTaskGroup {\n+///\n+/// A task scheduler must eventually be ended when all tasks have been added.  Once the\n+/// scheduler has been ended it is an error to add further tasks.  Note, it is not an\n+/// error to add additional tasks after a scheduler has aborted (though these tasks\n+/// will be ignored and never submitted).  The scheduler has a futuer which will complete\n+/// once the scheduler has been ended AND all remaining tasks have finished executing.\n+/// Ending a scheduler will NOT cause the scheduler to flush existing tasks.\n+///\n+/// Task failure (either the synchronous portion or the asynchronous portion) will cause\n+/// the scheduler to enter an aborted state.  The first such failure will be reported in\n+/// the final task future.\n+///\n+/// The scheduler can also be manually aborted.  A cancellation status will be reported as\n+/// the final task future.\n+///\n+/// It is also possible to limit the number of concurrent tasks the scheduler will\n+/// execute. This is done by setting a task limit.  The task limit initially assumes all\n+/// tasks are equal but a custom cost can be supplied when scheduling a task (e.g. based\n+/// on the total I/O cost of the task, or the expected RAM utilization of the task)\n+///\n+/// When the total number of running tasks is limited then scheduler priority may also\n+/// become a consideration.  By default the scheduler runs with a FIFO queue but a custom\n+/// task queue can be provided.  One could, for example, use a priority queue to control\n+/// the order in which tasks are executed.\n+///\n+/// It is common to have multiple stages of execution.  For example, when scanning, we\n+/// first inspect each fragment (the inspect stage) to figure out the row groups and then\n+/// we scan row groups (the scan stage) to read in the data.  This sort of multi-stage\n+/// execution should be represented as two seperate task groups.  The first task group can\n+/// then have a custom finish callback which ends the second task group.\n+class ARROW_EXPORT AsyncTaskScheduler {\n  public:\n-  /// Add a task to be tracked by this task group\n-  ///\n-  /// If a previous task has failed then adding a task will fail\n-  ///\n-  /// If WaitForTasksToFinish has been called and the returned future has been marked\n-  /// completed then adding a task will fail.\n-  Status AddTask(std::function<Result<Future<>>()> task);\n-  /// Same as AddTask but doesn't add the task if End() has been called.\n-  ///\n-  /// \\return true if the task was started, false if the group had already ended\n-  Result<bool> AddTaskIfNotEnded(std::function<Result<Future<>>()> task);\n-  /// Add a task that has already been started\n-  Status AddTask(const Future<>& task);\n-  /// \\brief Attempt to add a task that has already been started to this group's tracking\n-  ///\n-  /// The return value must be paid attention to.  If the return value is false then the\n-  /// task could not be added because the group had already ended and so the caller must\n-  /// track the external task some other way.\n-  Result<bool> AddTaskIfNotEnded(const Future<>& task);\n-  /// Signal that top level tasks are done being added\n+  /// Destructor for AsyncTaskScheduler\n+  ///\n+  /// If a scheduler is not in the ended state when it is destroyed then it\n+  /// will enter an aborted state.\n+  ///\n+  /// The destructor will block until all submitted tasks have finished.\n+  virtual ~AsyncTaskScheduler() = default;\n+  /// An interface for a task\n+  ///\n+  /// Users may want to override this, for example, to add priority\n+  /// information for use by a queue.\n+  class Task {\n+   public:\n+    virtual ~Task() = default;\n+    /// Submit the task\n+    ///\n+    /// This will be called by the scheduler at most once when there\n+    /// is space to run the task.  This is expected to be a fairly quick\n+    /// function that simply submits the actual task work to an external\n+    /// resource (e.g. I/O thread pool).\n+    ///\n+    /// If this call fails then the scheduler will enter an aborted state.\n+    virtual Result<Future<>> operator()(AsyncTaskScheduler* scheduler) = 0;\n+    /// The cost of the task\n+    ///\n+    /// The scheduler limits the total number of concurrent tasks based\n+    /// on cost.  A custom cost may be used, for example, if you would like\n+    /// to limit the number of tasks based on the total expected RAM usage of\n+    /// the tasks (this is done in the scanner)\n+    virtual int cost() const { return 1; }\n+  };\n+\n+  /// An interface for a task queue\n+  ///\n+  /// A queue's methods will not be called concurrently\n+  class Queue {\n+   public:\n+    virtual ~Queue() = default;\n+    /// Push a task to the queue\n+    virtual void Push(std::unique_ptr<Task> task) = 0;\n+    /// Pop the next task from the queue\n+    virtual std::unique_ptr<Task> Pop() = 0;\n+    /// Peek the next task in the queue\n+    virtual const Task& Peek() = 0;\n+    /// Check if the queue is empty\n+    virtual bool Empty() = 0;\n+    /// Purge the queue of all items\n+    virtual void Purge() = 0;\n+  };\n+\n+  class Throttle {\n+   public:\n+    virtual ~Throttle() = default;\n+    /// Acquire amt permits\n+    ///\n+    /// If nullopt is returned then the permits were immediately\n+    /// acquired and the caller can proceed.  If a future is returned then the caller\n+    /// should wait for the future to complete first.  When the returned future completes\n+    /// the permits have NOT been acquired and the caller must call Acquire again\n+    virtual util::optional<Future<>> TryAcquire(int amt) = 0;\n+    /// Release amt permits\n+    ///\n+    /// This will possibly complete waiting futures and should probably not be\n+    /// called while holding locks.\n+    virtual void Release(int amt) = 0;\n+  };\n+  /// Create a throttle\n+  ///\n+  /// This throttle is used to limit how many tasks can run at once.  The\n+  /// user should keep the throttle alive for the lifetime of the scheduler.\n+  /// The same throttle can be used in multiple schedulers.\n+  static std::unique_ptr<Throttle> MakeThrottle(int max_concurrent_cost);\n+\n+  /// Add a task to the scheduler\n+  ///\n+  /// If the scheduler is in an aborted state this call will return false and the task\n+  /// will never be run.  This is harmless and does not need to be guarded against.\n+  ///\n+  /// If the scheduler is in an ended state then this call will cause an abort.  This\n+  /// represents a logic error in the program and should be avoidable.\n\nReview Comment:\n   Hmm, in that case it might be better to crash in a controlled fashion. Maybe adding a message to the DCHECK to give some context would help?\n\n\n\n",
                    "created": "2022-08-19T17:33:53.565+0000",
                    "updated": "2022-08-19T17:33:53.565+0000",
                    "started": "2022-08-19T17:33:53.565+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "802086",
                    "issueId": "13475821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821/worklog/802089",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13912:\nURL: https://github.com/apache/arrow/pull/13912#discussion_r950426026\n\n\n##########\ncpp/src/arrow/util/async_util.h:\n##########\n@@ -147,70 +207,42 @@ class ARROW_EXPORT AsyncTaskGroup {\n   ///\n   /// This is a utility method for workflows where the finish future needs to be\n   /// referenced before all top level tasks have been queued.\n-  Future<> OnFinished() const;\n+  virtual Future<> OnFinished() const = 0;\n \n- private:\n-  Status AddTaskUnlocked(const Future<>& task, util::Mutex::Guard guard);\n-\n-  bool finished_adding_ = false;\n-  int running_tasks_ = 0;\n-  Status err_;\n-  Future<> all_tasks_done_ = Future<>::Make();\n-  util::Mutex mutex_;\n-};\n-\n-/// A task group which serializes asynchronous tasks in a push-based workflow\n-///\n-/// Tasks will be executed in the order they are added\n-///\n-/// This will buffer results in an unlimited fashion so it should be combined\n-/// with some kind of backpressure\n-class ARROW_EXPORT SerializedAsyncTaskGroup {\n- public:\n-  SerializedAsyncTaskGroup();\n-  /// Push an item into the serializer and (eventually) into the consumer\n+  /// Create a sub-scheduler for tracking a subset of tasks\n   ///\n-  /// The item will not be delivered to the consumer until all previous items have been\n-  /// consumed.\n+  /// The parent scheduler will manage the lifetime of the sub-scheduler.  It will\n+  /// be destroyed once it is finished.\n   ///\n-  /// If the consumer returns an error then this serializer will go into an error state\n-  /// and all subsequent pushes will fail with that error.  Pushes that have been queued\n-  /// but not delivered will be silently dropped.\n+  /// Often some state needs to be associated with a subset of tasks.\n+  /// For example, when scanning a dataset we need to keep a file reader\n+  /// alive for all of the read tasks for each file. A sub-scheduler can be used to do\n+  /// this.\n   ///\n-  /// \\return True if the item was pushed immediately to the consumer, false if it was\n-  /// queued\n-  Status AddTask(std::function<Result<Future<>>()> task);\n-\n-  /// Signal that all top level tasks have been added\n+  /// The parent scheduler may be ended before all of its sub-schedulers\n+  /// are ended.\n   ///\n-  /// The returned future that will finish when all tasks have been consumed.\n-  Future<> End();\n-\n-  /// Abort a task group\n+  /// If either the parent scheduler or the sub-scheduler encounter an error\n+  /// then they will both enter an aborted state (this is a shared state).\n+  /// Finish callbacks will not be run when the scheduler is aborted.\n   ///\n-  /// Tasks that have not been started will be discarded\n+  /// The parent scheduler will not complete until the sub-scheduler's\n+  /// tasks (and finish callback) have all executed.\n   ///\n-  /// The returned future will finish when all running tasks have finished.\n-  Future<> Abort(Status err);\n+  /// A sub-scheduler can share the same throttle as its parent but it\n+  /// can also have its own unique throttle.\n\nReview Comment:\n   I suppose it does.  In practice the real cases I have are doing the opposite.  When writing datasets we create a sub-scheduler per file and that sub-scheduler is only allowed to run one task at a time to prevent concurrent writes.  In the scanner there is a sub scheduler for each input file.  All of the input file sub-schedulers share a common throttle.  There is also a fragment scanner which has its own independent throttle (maybe, just to control how many open files there are, but fragment readahead will be less critical I think).  I don't think the fragment scanner is the parent of the file scanners (I think they will be siblings) but it might be.\n\n\n\n",
                    "created": "2022-08-19T17:35:03.677+0000",
                    "updated": "2022-08-19T17:35:03.677+0000",
                    "started": "2022-08-19T17:35:03.677+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "802089",
                    "issueId": "13475821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821/worklog/802090",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13912:\nURL: https://github.com/apache/arrow/pull/13912#discussion_r950427174\n\n\n##########\ncpp/src/arrow/dataset/file_base.cc:\n##########\n@@ -488,13 +504,15 @@ class TeeNode : public compute::MapNode {\n   const char* kind_name() const override { return \"TeeNode\"; }\n \n   void Finish(Status finish_st) override {\n-    dataset_writer_->Finish().AddCallback([this, finish_st](const Status& dw_status) {\n-      // Need to wait for the task group to complete regardless of dw_status\n-      task_group_.End().AddCallback(\n-          [this, dw_status, finish_st](const Status& tg_status) {\n-            finished_.MarkFinished(dw_status & finish_st & tg_status);\n-          });\n-    });\n+    if (!finish_st.ok()) {\n+      MapNode::Finish(std::move(finish_st));\n+    }\n+    Status writer_finish_st = dataset_writer_->Finish();\n+    if (!writer_finish_st.ok()) {\n+      MapNode::Finish(std::move(writer_finish_st));\n+    }\n+    serial_scheduler_->End();\n+    MapNode::Finish(Status::OK());\n\nReview Comment:\n   Oops, good catch.  I should return after that first call to `MapNode::Finish`.\n\n\n\n",
                    "created": "2022-08-19T17:36:28.851+0000",
                    "updated": "2022-08-19T17:36:28.851+0000",
                    "started": "2022-08-19T17:36:28.851+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "802090",
                    "issueId": "13475821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821/worklog/803049",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13912:\nURL: https://github.com/apache/arrow/pull/13912#discussion_r953189589\n\n\n##########\ncpp/src/arrow/util/async_util.cc:\n##########\n@@ -19,186 +19,334 @@\n \n #include \"arrow/util/future.h\"\n #include \"arrow/util/logging.h\"\n+#include \"arrow/util/make_unique.h\"\n+\n+#include <deque>\n+#include <iostream>\n+#include <list>\n+#include <mutex>\n \n namespace arrow {\n-namespace util {\n \n-AsyncDestroyable::AsyncDestroyable() : on_closed_(Future<>::Make()) {}\n+using internal::make_unique;\n \n-#ifndef NDEBUG\n-AsyncDestroyable::~AsyncDestroyable() {\n-  DCHECK(constructed_correctly_) << \"An instance of AsyncDestroyable must be created by \"\n-                                    \"MakeSharedAsync or MakeUniqueAsync\";\n-}\n-#else\n-AsyncDestroyable::~AsyncDestroyable() = default;\n-#endif\n-\n-void AsyncDestroyable::Destroy() {\n-  DoDestroy().AddCallback([this](const Status& st) {\n-    on_closed_.MarkFinished(st);\n-    delete this;\n-  });\n-}\n+namespace util {\n \n-Status AsyncTaskGroup::AddTask(std::function<Result<Future<>>()> task) {\n-  auto guard = mutex_.Lock();\n-  if (finished_adding_) {\n-    return Status::Cancelled(\"Ignoring task added after the task group has been ended\");\n-  }\n-  if (!err_.ok()) {\n-    return err_;\n-  }\n-  Result<Future<>> maybe_task_fut = task();\n-  if (!maybe_task_fut.ok()) {\n-    err_ = maybe_task_fut.status();\n-    return err_;\n-  }\n-  return AddTaskUnlocked(*maybe_task_fut, std::move(guard));\n-}\n+class ThrottleImpl : public AsyncTaskScheduler::Throttle {\n+ public:\n+  ThrottleImpl(int max_concurrent_cost) : available_cost_(max_concurrent_cost) {}\n \n-Result<bool> AsyncTaskGroup::AddTaskIfNotEnded(std::function<Result<Future<>>()> task) {\n-  auto guard = mutex_.Lock();\n-  if (finished_adding_) {\n-    return false;\n-  }\n-  if (!err_.ok()) {\n-    return err_;\n-  }\n-  Result<Future<>> maybe_task_fut = task();\n-  if (!maybe_task_fut.ok()) {\n-    err_ = maybe_task_fut.status();\n-    return err_;\n+  util::optional<Future<>> TryAcquire(int amt) override {\n+    std::lock_guard<std::mutex> lk(mutex_);\n+    if (backoff_.is_valid()) {\n+      return backoff_;\n+    }\n+    if (amt <= available_cost_) {\n+      available_cost_ -= amt;\n+      return nullopt;\n+    }\n+    backoff_ = Future<>::Make();\n+    return backoff_;\n   }\n-  ARROW_RETURN_NOT_OK(AddTaskUnlocked(*maybe_task_fut, std::move(guard)));\n-  return true;\n-}\n \n-Status AsyncTaskGroup::AddTaskUnlocked(const Future<>& task_fut,\n-                                       util::Mutex::Guard guard) {\n-  // If the task is already finished there is nothing to track so lets save\n-  // some work and return early\n-  if (task_fut.is_finished()) {\n-    err_ &= task_fut.status();\n-    return err_;\n+  void Release(int amt) override {\n+    Future<> backoff_to_fulfill;\n+    {\n+      std::lock_guard<std::mutex> lk(mutex_);\n+      available_cost_ += amt;\n+      if (backoff_.is_valid()) {\n+        backoff_to_fulfill = std::move(backoff_);\n+      }\n+    }\n+    if (backoff_to_fulfill.is_valid()) {\n+      backoff_to_fulfill.MarkFinished();\n+    }\n   }\n-  running_tasks_++;\n-  guard.Unlock();\n-  task_fut.AddCallback([this](const Status& st) {\n-    auto guard = mutex_.Lock();\n-    err_ &= st;\n-    if (--running_tasks_ == 0 && finished_adding_) {\n-      guard.Unlock();\n-      all_tasks_done_.MarkFinished(err_);\n-    }\n-  });\n-  return Status::OK();\n+\n+ private:\n+  std::mutex mutex_;\n+  int available_cost_;\n+  Future<> backoff_;\n+};\n+\n+std::unique_ptr<AsyncTaskScheduler::Throttle> AsyncTaskScheduler::MakeThrottle(\n+    int max_concurrent_cost) {\n+  return make_unique<ThrottleImpl>(max_concurrent_cost);\n }\n \n-Status AsyncTaskGroup::AddTask(const Future<>& task_fut) {\n-  auto guard = mutex_.Lock();\n-  if (finished_adding_) {\n-    return Status::Cancelled(\"Ignoring task added after the task group has been ended\");\n-  }\n-  if (!err_.ok()) {\n-    return err_;\n+namespace {\n+\n+// Very basic FIFO queue\n+class FifoQueue : public AsyncTaskScheduler::Queue {\n+  using Task = AsyncTaskScheduler::Task;\n+  void Push(std::unique_ptr<Task> task) override { tasks_.push_back(std::move(task)); }\n+\n+  std::unique_ptr<Task> Pop() override {\n+    std::unique_ptr<Task> task = std::move(tasks_.front());\n+    tasks_.pop_front();\n+    return task;\n   }\n-  return AddTaskUnlocked(task_fut, std::move(guard));\n-}\n \n-Result<bool> AsyncTaskGroup::AddTaskIfNotEnded(const Future<>& task_fut) {\n-  auto guard = mutex_.Lock();\n-  if (finished_adding_) {\n-    return false;\n+  const Task& Peek() override { return *tasks_.front(); }\n+\n+  bool Empty() override { return tasks_.empty(); }\n+\n+  void Purge() override { tasks_.clear(); }\n+\n+ private:\n+  std::list<std::unique_ptr<Task>> tasks_;\n\nReview Comment:\n   I can use `std::deque` here but it's not clear to me why I should.  Is there some advantage I am missing?\n\n\n\n",
                    "created": "2022-08-23T23:34:41.495+0000",
                    "updated": "2022-08-23T23:34:41.495+0000",
                    "started": "2022-08-23T23:34:41.494+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803049",
                    "issueId": "13475821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821/worklog/803057",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13912:\nURL: https://github.com/apache/arrow/pull/13912#discussion_r953203592\n\n\n##########\ncpp/src/arrow/dataset/file_base.cc:\n##########\n@@ -488,13 +504,15 @@ class TeeNode : public compute::MapNode {\n   const char* kind_name() const override { return \"TeeNode\"; }\n \n   void Finish(Status finish_st) override {\n-    dataset_writer_->Finish().AddCallback([this, finish_st](const Status& dw_status) {\n-      // Need to wait for the task group to complete regardless of dw_status\n-      task_group_.End().AddCallback(\n-          [this, dw_status, finish_st](const Status& tg_status) {\n-            finished_.MarkFinished(dw_status & finish_st & tg_status);\n-          });\n-    });\n+    if (!finish_st.ok()) {\n+      MapNode::Finish(std::move(finish_st));\n+    }\n+    Status writer_finish_st = dataset_writer_->Finish();\n+    if (!writer_finish_st.ok()) {\n+      MapNode::Finish(std::move(writer_finish_st));\n+    }\n+    serial_scheduler_->End();\n+    MapNode::Finish(Status::OK());\n\nReview Comment:\n   I added the return statement.\n\n\n\n",
                    "created": "2022-08-24T00:10:20.336+0000",
                    "updated": "2022-08-24T00:10:20.336+0000",
                    "started": "2022-08-24T00:10:20.335+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803057",
                    "issueId": "13475821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821/worklog/803061",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13912:\nURL: https://github.com/apache/arrow/pull/13912#discussion_r953206180\n\n\n##########\ncpp/src/arrow/util/async_util.h:\n##########\n@@ -17,128 +17,188 @@\n \n #pragma once\n \n-#include <queue>\n-\n #include \"arrow/result.h\"\n #include \"arrow/status.h\"\n+#include \"arrow/util/functional.h\"\n #include \"arrow/util/future.h\"\n+#include \"arrow/util/make_unique.h\"\n #include \"arrow/util/mutex.h\"\n \n namespace arrow {\n-namespace util {\n \n-/// Custom deleter for AsyncDestroyable objects\n-template <typename T>\n-struct DestroyingDeleter {\n-  void operator()(T* p) {\n-    if (p) {\n-      p->Destroy();\n-    }\n-  }\n-};\n+using internal::FnOnce;\n+using internal::make_unique;\n \n-/// An object which should be asynchronously closed before it is destroyed\n+namespace util {\n+\n+/// A utility which keeps tracks of, and schedules, asynchronous tasks\n ///\n-/// Classes can extend this to ensure that the close method is called and completed\n-/// before the instance is deleted.  This provides smart_ptr / delete semantics for\n-/// objects with an asynchronous destructor.\n+/// An asynchronous task has a synchronous component and an asynchronous component.\n+/// The synchronous component typically schedules some kind of work on an external\n+/// resource (e.g. the I/O thread pool or some kind of kernel-based asynchronous\n+/// resource like io_uring).  The asynchronous part represents the work\n+/// done on that external resource.  Executing the synchronous part will be referred\n+/// to as \"submitting the task\" since this usually includes submitting the asynchronous\n+/// portion to the external thread pool.\n ///\n-/// Classes which extend this must be constructed using MakeSharedAsync or MakeUniqueAsync\n-class ARROW_EXPORT AsyncDestroyable {\n- public:\n-  AsyncDestroyable();\n-  virtual ~AsyncDestroyable();\n-\n-  /// A future which will complete when the AsyncDestroyable has finished and is ready\n-  /// to be deleted.\n-  ///\n-  /// This can be used to ensure all work done by this object has been completed before\n-  /// proceeding.\n-  Future<> on_closed() { return on_closed_; }\n-\n- protected:\n-  /// Subclasses should override this and perform any cleanup.  Once the future returned\n-  /// by this method finishes then this object is eligible for destruction and any\n-  /// reference to `this` will be invalid\n-  virtual Future<> DoDestroy() = 0;\n-\n- private:\n-  void Destroy();\n-\n-  Future<> on_closed_;\n-#ifndef NDEBUG\n-  bool constructed_correctly_ = false;\n-#endif\n-\n-  template <typename T>\n-  friend struct DestroyingDeleter;\n-  template <typename T, typename... Args>\n-  friend std::shared_ptr<T> MakeSharedAsync(Args&&... args);\n-  template <typename T, typename... Args>\n-  friend std::unique_ptr<T, DestroyingDeleter<T>> MakeUniqueAsync(Args&&... args);\n-};\n-\n-template <typename T, typename... Args>\n-std::shared_ptr<T> MakeSharedAsync(Args&&... args) {\n-  static_assert(std::is_base_of<AsyncDestroyable, T>::value,\n-                \"Nursery::MakeSharedCloseable only works with AsyncDestroyable types\");\n-  std::shared_ptr<T> ptr(new T(std::forward<Args&&>(args)...), DestroyingDeleter<T>());\n-#ifndef NDEBUG\n-  ptr->constructed_correctly_ = true;\n-#endif\n-  return ptr;\n-}\n-\n-template <typename T, typename... Args>\n-std::unique_ptr<T, DestroyingDeleter<T>> MakeUniqueAsync(Args&&... args) {\n-  static_assert(std::is_base_of<AsyncDestroyable, T>::value,\n-                \"Nursery::MakeUniqueCloseable only works with AsyncDestroyable types\");\n-  std::unique_ptr<T, DestroyingDeleter<T>> ptr(new T(std::forward<Args>(args)...),\n-                                               DestroyingDeleter<T>());\n-#ifndef NDEBUG\n-  ptr->constructed_correctly_ = true;\n-#endif\n-  return ptr;\n-}\n-\n-/// A utility which keeps track of a collection of asynchronous tasks\n+/// By default the scheduler will submit the task (execute the synchronous part) as\n+/// soon as it is added, assuming the underlying thread pool hasn't terminated or the\n+/// scheduler hasn't aborted.  In this mode the scheduler is simply acting as\n+/// a task group, keeping track of the ongoing work.\n ///\n /// This can be used to provide structured concurrency for asynchronous development.\n /// A task group created at a high level can be distributed amongst low level components\n /// which register work to be completed.  The high level job can then wait for all work\n /// to be completed before cleaning up.\n-class ARROW_EXPORT AsyncTaskGroup {\n+///\n+/// A task scheduler must eventually be ended when all tasks have been added.  Once the\n+/// scheduler has been ended it is an error to add further tasks.  Note, it is not an\n+/// error to add additional tasks after a scheduler has aborted (though these tasks\n+/// will be ignored and never submitted).  The scheduler has a futuer which will complete\n+/// once the scheduler has been ended AND all remaining tasks have finished executing.\n+/// Ending a scheduler will NOT cause the scheduler to flush existing tasks.\n+///\n+/// Task failure (either the synchronous portion or the asynchronous portion) will cause\n+/// the scheduler to enter an aborted state.  The first such failure will be reported in\n+/// the final task future.\n+///\n+/// The scheduler can also be manually aborted.  A cancellation status will be reported as\n+/// the final task future.\n+///\n+/// It is also possible to limit the number of concurrent tasks the scheduler will\n+/// execute. This is done by setting a task limit.  The task limit initially assumes all\n+/// tasks are equal but a custom cost can be supplied when scheduling a task (e.g. based\n+/// on the total I/O cost of the task, or the expected RAM utilization of the task)\n+///\n+/// When the total number of running tasks is limited then scheduler priority may also\n+/// become a consideration.  By default the scheduler runs with a FIFO queue but a custom\n+/// task queue can be provided.  One could, for example, use a priority queue to control\n+/// the order in which tasks are executed.\n+///\n+/// It is common to have multiple stages of execution.  For example, when scanning, we\n+/// first inspect each fragment (the inspect stage) to figure out the row groups and then\n+/// we scan row groups (the scan stage) to read in the data.  This sort of multi-stage\n+/// execution should be represented as two seperate task groups.  The first task group can\n+/// then have a custom finish callback which ends the second task group.\n+class ARROW_EXPORT AsyncTaskScheduler {\n  public:\n-  /// Add a task to be tracked by this task group\n-  ///\n-  /// If a previous task has failed then adding a task will fail\n-  ///\n-  /// If WaitForTasksToFinish has been called and the returned future has been marked\n-  /// completed then adding a task will fail.\n-  Status AddTask(std::function<Result<Future<>>()> task);\n-  /// Same as AddTask but doesn't add the task if End() has been called.\n-  ///\n-  /// \\return true if the task was started, false if the group had already ended\n-  Result<bool> AddTaskIfNotEnded(std::function<Result<Future<>>()> task);\n-  /// Add a task that has already been started\n-  Status AddTask(const Future<>& task);\n-  /// \\brief Attempt to add a task that has already been started to this group's tracking\n-  ///\n-  /// The return value must be paid attention to.  If the return value is false then the\n-  /// task could not be added because the group had already ended and so the caller must\n-  /// track the external task some other way.\n-  Result<bool> AddTaskIfNotEnded(const Future<>& task);\n-  /// Signal that top level tasks are done being added\n+  /// Destructor for AsyncTaskScheduler\n+  ///\n+  /// If a scheduler is not in the ended state when it is destroyed then it\n+  /// will enter an aborted state.\n+  ///\n+  /// The destructor will block until all submitted tasks have finished.\n+  virtual ~AsyncTaskScheduler() = default;\n+  /// An interface for a task\n+  ///\n+  /// Users may want to override this, for example, to add priority\n+  /// information for use by a queue.\n+  class Task {\n+   public:\n+    virtual ~Task() = default;\n+    /// Submit the task\n+    ///\n+    /// This will be called by the scheduler at most once when there\n+    /// is space to run the task.  This is expected to be a fairly quick\n+    /// function that simply submits the actual task work to an external\n+    /// resource (e.g. I/O thread pool).\n+    ///\n+    /// If this call fails then the scheduler will enter an aborted state.\n+    virtual Result<Future<>> operator()(AsyncTaskScheduler* scheduler) = 0;\n+    /// The cost of the task\n+    ///\n+    /// The scheduler limits the total number of concurrent tasks based\n+    /// on cost.  A custom cost may be used, for example, if you would like\n+    /// to limit the number of tasks based on the total expected RAM usage of\n+    /// the tasks (this is done in the scanner)\n+    virtual int cost() const { return 1; }\n+  };\n+\n+  /// An interface for a task queue\n+  ///\n+  /// A queue's methods will not be called concurrently\n+  class Queue {\n+   public:\n+    virtual ~Queue() = default;\n+    /// Push a task to the queue\n+    virtual void Push(std::unique_ptr<Task> task) = 0;\n+    /// Pop the next task from the queue\n+    virtual std::unique_ptr<Task> Pop() = 0;\n+    /// Peek the next task in the queue\n+    virtual const Task& Peek() = 0;\n+    /// Check if the queue is empty\n+    virtual bool Empty() = 0;\n+    /// Purge the queue of all items\n+    virtual void Purge() = 0;\n+  };\n+\n+  class Throttle {\n+   public:\n+    virtual ~Throttle() = default;\n+    /// Acquire amt permits\n+    ///\n+    /// If nullopt is returned then the permits were immediately\n+    /// acquired and the caller can proceed.  If a future is returned then the caller\n+    /// should wait for the future to complete first.  When the returned future completes\n+    /// the permits have NOT been acquired and the caller must call Acquire again\n+    virtual util::optional<Future<>> TryAcquire(int amt) = 0;\n+    /// Release amt permits\n+    ///\n+    /// This will possibly complete waiting futures and should probably not be\n+    /// called while holding locks.\n+    virtual void Release(int amt) = 0;\n+  };\n+  /// Create a throttle\n+  ///\n+  /// This throttle is used to limit how many tasks can run at once.  The\n+  /// user should keep the throttle alive for the lifetime of the scheduler.\n+  /// The same throttle can be used in multiple schedulers.\n+  static std::unique_ptr<Throttle> MakeThrottle(int max_concurrent_cost);\n+\n+  /// Add a task to the scheduler\n+  ///\n+  /// If the scheduler is in an aborted state this call will return false and the task\n+  /// will never be run.  This is harmless and does not need to be guarded against.\n+  ///\n+  /// If the scheduler is in an ended state then this call will cause an abort.  This\n+  /// represents a logic error in the program and should be avoidable.\n\nReview Comment:\n   I added a message to the dcheck and added a lengthier explanation in a comment before the dcheck which will hopefully assist future developers.\r\n   \r\n   There is potentially one scenario where adding a task after the scheduler has ended is ok and this is where the code doing the task-adding is a task on the scheduler itself.  This scenario popped up in the tpc-h generator but I was able to work around it.  For the moment I'd like to keep things as they are but I'm open to possibly softening this requirement down the road.\r\n   \r\n   It's may be possible to get of `End` entirely by requiring that all tasks are added by existing tasks.  Creating the initial scheduler would then require supplying an \"initial_task\".  In that case we would know that a scheduler is finished when it runs out of tasks and would never need an `End` call.  I'll leave that for a follow-up (ARROW-17509)\n\n\n\n",
                    "created": "2022-08-24T00:17:21.072+0000",
                    "updated": "2022-08-24T00:17:21.072+0000",
                    "started": "2022-08-24T00:17:21.072+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803061",
                    "issueId": "13475821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821/worklog/803079",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on PR #13912:\nURL: https://github.com/apache/arrow/pull/13912#issuecomment-1225087434\n\n   The ASAN error seems legitimate but I believe I've addressed review comments and fixed most of the bugs.  This is probably ready for another review while I work through this issue.\n\n\n",
                    "created": "2022-08-24T02:07:07.553+0000",
                    "updated": "2022-08-24T02:07:07.553+0000",
                    "started": "2022-08-24T02:07:07.552+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803079",
                    "issueId": "13475821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821/worklog/803227",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #13912:\nURL: https://github.com/apache/arrow/pull/13912#discussion_r953686946\n\n\n##########\ncpp/src/arrow/util/async_util.cc:\n##########\n@@ -19,186 +19,334 @@\n \n #include \"arrow/util/future.h\"\n #include \"arrow/util/logging.h\"\n+#include \"arrow/util/make_unique.h\"\n+\n+#include <deque>\n+#include <iostream>\n+#include <list>\n+#include <mutex>\n \n namespace arrow {\n-namespace util {\n \n-AsyncDestroyable::AsyncDestroyable() : on_closed_(Future<>::Make()) {}\n+using internal::make_unique;\n \n-#ifndef NDEBUG\n-AsyncDestroyable::~AsyncDestroyable() {\n-  DCHECK(constructed_correctly_) << \"An instance of AsyncDestroyable must be created by \"\n-                                    \"MakeSharedAsync or MakeUniqueAsync\";\n-}\n-#else\n-AsyncDestroyable::~AsyncDestroyable() = default;\n-#endif\n-\n-void AsyncDestroyable::Destroy() {\n-  DoDestroy().AddCallback([this](const Status& st) {\n-    on_closed_.MarkFinished(st);\n-    delete this;\n-  });\n-}\n+namespace util {\n \n-Status AsyncTaskGroup::AddTask(std::function<Result<Future<>>()> task) {\n-  auto guard = mutex_.Lock();\n-  if (finished_adding_) {\n-    return Status::Cancelled(\"Ignoring task added after the task group has been ended\");\n-  }\n-  if (!err_.ok()) {\n-    return err_;\n-  }\n-  Result<Future<>> maybe_task_fut = task();\n-  if (!maybe_task_fut.ok()) {\n-    err_ = maybe_task_fut.status();\n-    return err_;\n-  }\n-  return AddTaskUnlocked(*maybe_task_fut, std::move(guard));\n-}\n+class ThrottleImpl : public AsyncTaskScheduler::Throttle {\n+ public:\n+  ThrottleImpl(int max_concurrent_cost) : available_cost_(max_concurrent_cost) {}\n \n-Result<bool> AsyncTaskGroup::AddTaskIfNotEnded(std::function<Result<Future<>>()> task) {\n-  auto guard = mutex_.Lock();\n-  if (finished_adding_) {\n-    return false;\n-  }\n-  if (!err_.ok()) {\n-    return err_;\n-  }\n-  Result<Future<>> maybe_task_fut = task();\n-  if (!maybe_task_fut.ok()) {\n-    err_ = maybe_task_fut.status();\n-    return err_;\n+  util::optional<Future<>> TryAcquire(int amt) override {\n+    std::lock_guard<std::mutex> lk(mutex_);\n+    if (backoff_.is_valid()) {\n+      return backoff_;\n+    }\n+    if (amt <= available_cost_) {\n+      available_cost_ -= amt;\n+      return nullopt;\n+    }\n+    backoff_ = Future<>::Make();\n+    return backoff_;\n   }\n-  ARROW_RETURN_NOT_OK(AddTaskUnlocked(*maybe_task_fut, std::move(guard)));\n-  return true;\n-}\n \n-Status AsyncTaskGroup::AddTaskUnlocked(const Future<>& task_fut,\n-                                       util::Mutex::Guard guard) {\n-  // If the task is already finished there is nothing to track so lets save\n-  // some work and return early\n-  if (task_fut.is_finished()) {\n-    err_ &= task_fut.status();\n-    return err_;\n+  void Release(int amt) override {\n+    Future<> backoff_to_fulfill;\n+    {\n+      std::lock_guard<std::mutex> lk(mutex_);\n+      available_cost_ += amt;\n+      if (backoff_.is_valid()) {\n+        backoff_to_fulfill = std::move(backoff_);\n+      }\n+    }\n+    if (backoff_to_fulfill.is_valid()) {\n+      backoff_to_fulfill.MarkFinished();\n+    }\n   }\n-  running_tasks_++;\n-  guard.Unlock();\n-  task_fut.AddCallback([this](const Status& st) {\n-    auto guard = mutex_.Lock();\n-    err_ &= st;\n-    if (--running_tasks_ == 0 && finished_adding_) {\n-      guard.Unlock();\n-      all_tasks_done_.MarkFinished(err_);\n-    }\n-  });\n-  return Status::OK();\n+\n+ private:\n+  std::mutex mutex_;\n+  int available_cost_;\n+  Future<> backoff_;\n+};\n+\n+std::unique_ptr<AsyncTaskScheduler::Throttle> AsyncTaskScheduler::MakeThrottle(\n+    int max_concurrent_cost) {\n+  return make_unique<ThrottleImpl>(max_concurrent_cost);\n }\n \n-Status AsyncTaskGroup::AddTask(const Future<>& task_fut) {\n-  auto guard = mutex_.Lock();\n-  if (finished_adding_) {\n-    return Status::Cancelled(\"Ignoring task added after the task group has been ended\");\n-  }\n-  if (!err_.ok()) {\n-    return err_;\n+namespace {\n+\n+// Very basic FIFO queue\n+class FifoQueue : public AsyncTaskScheduler::Queue {\n+  using Task = AsyncTaskScheduler::Task;\n+  void Push(std::unique_ptr<Task> task) override { tasks_.push_back(std::move(task)); }\n+\n+  std::unique_ptr<Task> Pop() override {\n+    std::unique_ptr<Task> task = std::move(tasks_.front());\n+    tasks_.pop_front();\n+    return task;\n   }\n-  return AddTaskUnlocked(task_fut, std::move(guard));\n-}\n \n-Result<bool> AsyncTaskGroup::AddTaskIfNotEnded(const Future<>& task_fut) {\n-  auto guard = mutex_.Lock();\n-  if (finished_adding_) {\n-    return false;\n+  const Task& Peek() override { return *tasks_.front(); }\n+\n+  bool Empty() override { return tasks_.empty(); }\n+\n+  void Purge() override { tasks_.clear(); }\n+\n+ private:\n+  std::list<std::unique_ptr<Task>> tasks_;\n\nReview Comment:\n   Not a big deal, I just prefer to avoid the linked list unless we need the pointer stability it provides. \n\n\n\n##########\ncpp/src/arrow/util/async_util_benchmark.cc:\n##########\n@@ -0,0 +1,19 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include \"benchmark/benchmark.h\"\n+\n+#include \"arrow/util/async_util.h\"\n\nReview Comment:\n   Do you mean to fill in the benchmark?\n\n\n\n",
                    "created": "2022-08-24T13:20:01.671+0000",
                    "updated": "2022-08-24T13:20:01.671+0000",
                    "started": "2022-08-24T13:20:01.671+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803227",
                    "issueId": "13475821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821/worklog/803405",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13912:\nURL: https://github.com/apache/arrow/pull/13912#discussion_r954381924\n\n\n##########\ncpp/src/arrow/util/async_util_benchmark.cc:\n##########\n@@ -0,0 +1,19 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include \"benchmark/benchmark.h\"\n+\n+#include \"arrow/util/async_util.h\"\n\nReview Comment:\n   Oops.  I'll leave that for a future exercise.  Good catch.\n\n\n\n",
                    "created": "2022-08-24T23:37:49.664+0000",
                    "updated": "2022-08-24T23:37:49.664+0000",
                    "started": "2022-08-24T23:37:49.664+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803405",
                    "issueId": "13475821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821/worklog/804556",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on PR #13912:\nURL: https://github.com/apache/arrow/pull/13912#issuecomment-1230896267\n\n   Sorry, let this linger a bit, I'm going to rebase and then merge if still green.\n\n\n",
                    "created": "2022-08-29T21:46:21.899+0000",
                    "updated": "2022-08-29T21:46:21.899+0000",
                    "started": "2022-08-29T21:46:21.899+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "804556",
                    "issueId": "13475821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821/worklog/805660",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace merged PR #13912:\nURL: https://github.com/apache/arrow/pull/13912\n\n\n",
                    "created": "2022-09-02T00:33:27.936+0000",
                    "updated": "2022-09-02T00:33:27.936+0000",
                    "started": "2022-09-02T00:33:27.936+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "805660",
                    "issueId": "13475821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821/worklog/805701",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot commented on PR #13912:\nURL: https://github.com/apache/arrow/pull/13912#issuecomment-1235291965\n\n   Benchmark runs are scheduled for baseline = a8bb7f4b2f3c646b3fa0885dc3bab9c7a25b6e3e and contender = 0527197c0f26d5b65678cd63573583165cf645f1. 0527197c0f26d5b65678cd63573583165cf645f1 is a master commit associated with this PR. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Failed :arrow_down:0.0% :arrow_up:0.0%] [ec2-t3-xlarge-us-east-2](https://conbench.ursa.dev/compare/runs/002e6a6cfdcd43b3b7e040099db4bcd7...bf96c9c90bd14627be464a9ef511a891/)\n   [Failed] [test-mac-arm](https://conbench.ursa.dev/compare/runs/2f9b34fc01784d6a9397969001784da7...0c7c1fb5f0194c25ac448b265581e2b4/)\n   [Failed :arrow_down:0.55% :arrow_up:0.0%] [ursa-i9-9960x](https://conbench.ursa.dev/compare/runs/3bf16567d86c4b249fad22342a8ea66d...45f6742893ae456abfccc3a34a60b6e3/)\n   [Finished :arrow_down:1.74% :arrow_up:0.46%] [ursa-thinkcentre-m75q](https://conbench.ursa.dev/compare/runs/19ec6336b9d24d4bb450fd8b9e48f6ca...da38152ad09f4b5d85058a59bfd563a7/)\n   Buildkite builds:\n   [Finished] [`0527197c` ec2-t3-xlarge-us-east-2](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ec2-t3-xlarge-us-east-2/builds/1409)\n   [Failed] [`0527197c` test-mac-arm](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-test-mac-arm/builds/1426)\n   [Failed] [`0527197c` ursa-i9-9960x](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-i9-9960x/builds/1410)\n   [Finished] [`0527197c` ursa-thinkcentre-m75q](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-thinkcentre-m75q/builds/1424)\n   [Failed] [`a8bb7f4b` ec2-t3-xlarge-us-east-2](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ec2-t3-xlarge-us-east-2/builds/1408)\n   [Failed] [`a8bb7f4b` test-mac-arm](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-test-mac-arm/builds/1425)\n   [Failed] [`a8bb7f4b` ursa-i9-9960x](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-i9-9960x/builds/1409)\n   [Finished] [`a8bb7f4b` ursa-thinkcentre-m75q](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-thinkcentre-m75q/builds/1423)\n   Supported benchmarks:\n   ec2-t3-xlarge-us-east-2: Supported benchmark langs: Python, R. Runs only benchmarks with cloud = True\n   test-mac-arm: Supported benchmark langs: C++, Python, R\n   ursa-i9-9960x: Supported benchmark langs: Python, R, JavaScript\n   ursa-thinkcentre-m75q: Supported benchmark langs: C++, Java\n   \n\n\n",
                    "created": "2022-09-02T09:42:24.760+0000",
                    "updated": "2022-09-02T09:42:24.760+0000",
                    "started": "2022-09-02T09:42:24.760+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "805701",
                    "issueId": "13475821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821/worklog/805702",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot commented on PR #13912:\nURL: https://github.com/apache/arrow/pull/13912#issuecomment-1235292236\n\n   ['Python', 'R'] benchmarks have high level of regressions.\n   [ursa-i9-9960x](https://conbench.ursa.dev/compare/runs/3bf16567d86c4b249fad22342a8ea66d...45f6742893ae456abfccc3a34a60b6e3/)\n   \n\n\n",
                    "created": "2022-09-02T09:42:41.989+0000",
                    "updated": "2022-09-02T09:42:41.989+0000",
                    "started": "2022-09-02T09:42:41.988+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "805702",
                    "issueId": "13475821"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
            "id": "1",
            "description": "A problem which impairs or prevents the functions of the product.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
            "name": "Bug",
            "subtask": false,
            "avatarId": 21133
        },
        "timespent": 10800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@3b807117[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@798a1804[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5cef0c1f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@750c75be[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@29412be6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@330eea85[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@17a5870f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@192b1c0[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@21acb40f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@6532287d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5e14562b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4a9cf098[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 10800,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Sep 02 00:33:31 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-09-02T00:33:31.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17350/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2022-08-09T00:38:09.000+0000",
        "updated": "2022-09-02T09:42:42.000+0000",
        "timeoriginalestimate": null,
        "description": "Note, in the interest of keeping things simple, this ideally replaces the AsyncTaskGroup.  This is needed to simplify the logic in ARROW-17287.\r\n\r\nThe format and implementation will likely be inspired by the synchronous schedulers, TaskScheduler and TaskGroup but it will remain a separate implementation.  In the future, when we dedicate time to improving our synchronous scheduler, we can decide if it makes sense to merge these two types.\r\n\r\n{noformat}\r\n/// A utility which keeps tracks of, and schedules, asynchronous tasks\r\n///\r\n/// An asynchronous task has a synchronous component and an asynchronous component.\r\n/// The synchronous component typically schedules some kind of work on an external\r\n/// resource (e.g. the I/O thread pool or some kind of kernel-based asynchronous\r\n/// resource like io_uring).  The asynchronous part represents the work\r\n/// done on that external resource.  Executing the synchronous part will be referred\r\n/// to as \"submitting the task\" since this usually includes submitting the asynchronous\r\n/// portion to the external thread pool.\r\n///\r\n/// By default the scheduler will submit the task (execute the synchronous part) as\r\n/// soon as it is added, assuming the underlying thread pool hasn't terminated or the\r\n/// scheduler hasn't aborted.  In this mode the scheduler is simply acting as\r\n/// a task group, keeping track of the ongoing work.\r\n///\r\n/// This can be used to provide structured concurrency for asynchronous development.\r\n/// A task group created at a high level can be distributed amongst low level components\r\n/// which register work to be completed.  The high level job can then wait for all work\r\n/// to be completed before cleaning up.\r\n///\r\n/// A task scheduler must eventually be ended when all tasks have been added.  Once the\r\n/// scheduler has been ended it is an error to add further tasks.  Note, it is not an\r\n/// error to add additional tasks after a scheduler has aborted (though these tasks\r\n/// will be ignored and never submitted).  The scheduler has a futuer which will complete\r\n/// once the scheduler has been ended AND all remaining tasks have finished executing.\r\n/// Ending a scheduler will NOT cause the scheduler to flush existing tasks.\r\n///\r\n/// Task failure (either the synchronous portion or the asynchronous portion) will cause\r\n/// the scheduler to enter an aborted state.  The first such failure will be reported in\r\n/// the final task future.\r\n///\r\n/// The scheduler can also be manually aborted.  A cancellation status will be reported as\r\n/// the final task future.\r\n///\r\n/// It is also possible to limit the number of concurrent tasks the scheduler will\r\n/// execute. This is done by setting a task limit.  The task limit initially assumes all\r\n/// tasks are equal but a custom cost can be supplied when scheduling a task (e.g. based\r\n/// on the total I/O cost of the task, or the expected RAM utilization of the task)\r\n///\r\n/// When the total number of running tasks is limited then scheduler priority may also\r\n/// become a consideration.  By default the scheduler runs with a FIFO queue but a custom\r\n/// task queue can be provided.  One could, for example, use a priority queue to control\r\n/// the order in which tasks are executed.\r\n///\r\n/// It is common to have multiple stages of execution.  For example, when scanning, we\r\n/// first inspect each fragment (the inspect stage) to figure out the row groups and then\r\n/// we scan row groups (the scan stage) to read in the data.  This sort of multi-stage\r\n/// execution should be represented as two seperate task groups.  The first task group can\r\n/// then have a custom finish callback which ends the second task group.\r\n{noformat}",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "3h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 10800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Create a scheduler for asynchronous work",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475821/comment/17599205",
                    "id": "17599205",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 13912\n[https://github.com/apache/arrow/pull/13912]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-09-02T00:33:31.458+0000",
                    "updated": "2022-09-02T00:33:31.458+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z17l5s:",
        "customfield_12314139": null
    }
}