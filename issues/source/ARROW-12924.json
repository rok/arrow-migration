{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13381562",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381562",
    "key": "ARROW-12924",
    "fields": {
        "fixVersions": [],
        "resolution": null,
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
            "name": "Minor",
            "id": "4"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": null,
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
            "description": "The issue is open and ready for the assignee to start work on it.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
            "name": "Open",
            "id": "1",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                "id": 2,
                "key": "new",
                "colorName": "blue-gray",
                "name": "To Do"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12334626",
                "id": "12334626",
                "name": "C++ - Gandiva"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=vitor004",
            "name": "vitor004",
            "key": "vitor004",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Jo\u00e3o Victor Huguenin",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=vitor004",
            "name": "vitor004",
            "key": "vitor004",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Jo\u00e3o Victor Huguenin",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 6600,
            "total": 6600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 6600,
            "total": 6600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12924/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 11,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381562/worklog/604804",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvictorhuguenin opened a new pull request #10432:\nURL: https://github.com/apache/arrow/pull/10432\n\n\n   Converts timestamp to specified timezone. If the sourceTimezone parameter is not present, Dremio assumes the timestamp provided in the third parameter is in UTC format. The sourceTimezone and destinationTimezone parameters accept any of the following values: timezone name from sys.timezone_names, timezone abbreviation from sys.timezone_abbrevs, and offset, such as +02:00.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-01T22:08:23.847+0000",
                    "updated": "2021-06-01T22:08:23.847+0000",
                    "started": "2021-06-01T22:08:23.846+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604804",
                    "issueId": "13381562"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381562/worklog/604805",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10432:\nURL: https://github.com/apache/arrow/pull/10432#issuecomment-852494029\n\n\n   https://issues.apache.org/jira/browse/ARROW-12924\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-01T22:08:37.415+0000",
                    "updated": "2021-06-01T22:08:37.415+0000",
                    "started": "2021-06-01T22:08:37.415+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "604805",
                    "issueId": "13381562"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381562/worklog/686043",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10432:\nURL: https://github.com/apache/arrow/pull/10432#issuecomment-978140366\n\n\n   :warning: Ticket **has not been started in JIRA**, please click 'Start Progress'.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-24T18:52:38.034+0000",
                    "updated": "2021-11-24T18:52:38.034+0000",
                    "started": "2021-11-24T18:52:38.034+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "686043",
                    "issueId": "13381562"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381562/worklog/729320",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #10432:\nURL: https://github.com/apache/arrow/pull/10432#discussion_r809527803\n\n\n\n##########\nFile path: cpp/src/gandiva/convert_timezone_holder.h\n##########\n@@ -0,0 +1,282 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+\n+#include \"arrow/vendored/datetime/date.h\"\n+#include \"arrow/vendored/datetime/tz.h\"\n+#include \"gandiva/function_holder.h\"\n+#include \"gandiva/node.h\"\n+#include \"gandiva/visibility.h\"\n+\n+using arrow_vendored::date::local_time;\n+using arrow_vendored::date::locate_zone;\n+using arrow_vendored::date::make_zoned;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::time_zone;\n+using std::chrono::milliseconds;\n+\n+namespace gandiva {\n+\n+class OffsetZone {\n+  std::chrono::seconds offset_;\n+\n+ public:\n+  explicit OffsetZone(std::chrono::seconds offset) : offset_(offset) {}\n+\n+  template <class Duration>\n+  auto to_local(arrow_vendored::date::sys_time<Duration> tp) const {\n+    using std::common_type_t;\n+    using std::chrono::seconds;\n+    using LT = local_time<std::common_type_t<Duration, seconds>>;\n+    return LT((tp + offset_).time_since_epoch());\n+  }\n+\n+  template <class Duration>\n+  auto to_sys(arrow_vendored::date::local_time<Duration> tp) const {\n+    using std::chrono::seconds;\n+    using ST = sys_time<std::common_type_t<Duration, seconds>>;\n+    return ST((tp - offset_).time_since_epoch());\n+  }\n+};\n+\n+/// Function Holder for SQL 'CONVERT_TIMEZONE'\n+class GANDIVA_EXPORT ConvertTimezoneHolder : public FunctionHolder {\n+ public:\n+  ~ConvertTimezoneHolder() override = default;\n+\n+  static Status Make(const FunctionNode& node,\n+                     std::shared_ptr<ConvertTimezoneHolder>* holder);\n+\n+  static Status Make(const std::string& srcTz, const std::string& destTz,\n+                     std::shared_ptr<ConvertTimezoneHolder>* holder);\n+\n+  /// Return the converted timestamp\n+  int64_t convert(const int64_t src_timestamp) {\n+    using std::chrono::seconds;\n+\n+    if (dest_timezone != NULLPTR && src_timezone == NULLPTR) {\n+      return dest_timezone\n+          ->to_local(src_offset_tz->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else if (dest_timezone == NULLPTR && src_timezone != NULLPTR) {\n+      return dest_offset_tz\n+          ->to_local(src_timezone->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else if (dest_timezone == NULLPTR && src_timezone == NULLPTR) {\n+      return dest_offset_tz\n+          ->to_local(src_offset_tz->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else {\n+      return dest_timezone\n+          ->to_local(src_timezone->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    }\n+  }\n+\n+  // Tracks if the timezones given could be found in IANA Timezone DB.\n+  bool ok = true;\n+\n+ private:\n+  explicit ConvertTimezoneHolder(const std::string& srcTz, const std::string& destTz) {\n+    auto srcTz_abbrv_offset = abbrv_tz.find(srcTz);\n+    auto destTz_abbrv_offset = abbrv_tz.find(destTz);\n+\n+    try {\n+      if (srcTz_abbrv_offset != abbrv_tz.end()) {\n+        auto secs = convert_offset_to_seconds(srcTz_abbrv_offset->second);\n+        src_offset_tz = std::make_shared<OffsetZone>(secs);\n+      } else {\n+        if (is_timezone_shift(srcTz) ||\n+            is_timezone_offset(const_cast<std::string&>(srcTz))) {\n+          auto secs = convert_offset_to_seconds(srcTz);\n+          src_offset_tz = std::make_shared<OffsetZone>(secs);\n+        } else {\n+          src_timezone = locate_zone(srcTz);\n+        }\n+      }\n+\n+      if (destTz_abbrv_offset != abbrv_tz.end()) {\n+        auto secs = convert_offset_to_seconds(destTz_abbrv_offset->second);\n+        dest_offset_tz = std::make_shared<OffsetZone>(secs);\n+      } else {\n+        if (is_timezone_shift(destTz) ||\n+            is_timezone_offset(const_cast<std::string&>(destTz))) {\n+          auto secs = convert_offset_to_seconds(destTz);\n+          dest_offset_tz = std::make_shared<OffsetZone>(secs);\n+        } else {\n+          dest_timezone = locate_zone(destTz);\n+        }\n+      }\n+    } catch (...) {\n+      ok = false;\n+    }\n+  }\n+\n+  static bool is_timezone_offset(std::string& offset) {\n+    if ((offset.rfind(\"-\") == 0 || offset.rfind(\"+\") == 0) && offset.length() == 6) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  std::chrono::seconds convert_offset_to_seconds(std::string string_offset) {\n+    int32_t prefix_offset_length = is_timezone_shift(string_offset);\n+    if (prefix_offset_length != 0) {\n+      auto abbrv_offset = abbrv_tz.find(string_offset.substr(0, prefix_offset_length));\n+      auto abbrv_seconds = off_set_to_seconds(abbrv_offset->second);\n+      auto shift_seconds = off_set_to_seconds(string_offset.substr(prefix_offset_length));\n+      return abbrv_seconds + shift_seconds;\n+    } else {\n+      return off_set_to_seconds(string_offset);\n+    }\n+  }\n+\n+  static int32_t parse_number(std::string& string_offset, int32_t pos,\n+                              bool preceded_by_colon) {\n+    if (preceded_by_colon && string_offset[pos - 1] != ':') {\n+      throw \"Invalid ID for ZoneOffset, colon not found when expected: \" + string_offset;\n+    }\n+    char ch1 = string_offset[pos];\n+    char ch2 = string_offset[pos + 1];\n+    if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {\n+      throw \"Invalid ID for ZoneOffset, non numeric characters found: \" + string_offset;\n+    }\n+\n+    return (ch1 - 48) * 10 + (ch2 - 48);\n+  }\n+\n+  std::chrono::seconds off_set_to_seconds(std::string string_offset) {\n+    // parse - +h, +hh, +hhmm, +hh:mm, +hhmmss, +hh:mm:ss\n+    int32_t hours, minutes, seconds;\n+    std::string sub_minus, sub_plus;\n+    switch (string_offset.length()) {\n+      case 2:\n+        sub_minus = string_offset.substr(string_offset.find(\"-\") + 1);\n+        if (sub_minus.length() == 1) {\n+          string_offset = \"-0\" + sub_minus;  // fallthru\n+        }\n+        sub_plus = string_offset.substr(string_offset.find(\"+\") + 1);\n+        if (sub_plus.length() == 1) {\n+          string_offset = \"+0\" + sub_plus;  // fallthru\n+        }\n+      case 3:\n+        hours = parse_number(string_offset, 1, false);\n+        minutes = 0;\n+        seconds = 0;\n+        break;\n+      case 5:\n+        hours = parse_number(string_offset, 1, false);\n+        minutes = parse_number(string_offset, 3, false);\n+        seconds = 0;\n+        break;\n+      case 6:\n+        hours = parse_number(string_offset, 1, false);\n+        minutes = parse_number(string_offset, 4, true);\n+        seconds = 0;\n+        break;\n+      case 7:\n+        hours = parse_number(string_offset, 1, false);\n+        minutes = parse_number(string_offset, 3, false);\n+        seconds = parse_number(string_offset, 5, false);\n+        break;\n+      case 9:\n+        hours = parse_number(string_offset, 1, false);\n+        minutes = parse_number(string_offset, 4, true);\n+        seconds = parse_number(string_offset, 7, true);\n+        break;\n+      default:\n+        break;\n+    }\n+    char first = string_offset.at(0);\n+    if (first != '+' && first != '-') {\n+      throw \"Invalid ID for ZoneOffset, plus/minus not found when expected: \" +\n+          string_offset;\n+    }\n+    if (first == '-') {\n+      return seconds_from_minutes_hours(-hours, -minutes, -seconds);\n+    } else {\n+      return seconds_from_minutes_hours(hours, minutes, seconds);\n+    }\n+  }\n+\n+  void validate(int32_t hours, int32_t minutes, int32_t seconds) {\n+    if (hours < -18 || hours > 18) {\n+      throw \"Zone offset hours not in valid range\";\n+    }\n+    if (hours > 0) {\n+      if (minutes < 0 || seconds < 0) {\n+        throw \"Zone offset minutes and seconds must be positive because hours is \"\n+              \"positive\";\n+      }\n+    } else if (hours < 0) {\n+      if (minutes > 0 || seconds > 0) {\n+        throw \"Zone offset minutes and seconds must be negative because hours is \"\n+              \"negative\";\n+      }\n+    } else if ((minutes > 0 && seconds < 0) || (minutes < 0 && seconds > 0)) {\n+      throw \"Zone offset minutes and seconds must have the same sign\";\n+    }\n+    if (minutes < -59 || minutes > 59) {\n+      throw \"Zone offset minutes not in valid range\";\n+    }\n+    if (seconds < -59 || seconds > 59) {\n+      throw \"Zone offset seconds not in valid range\";\n+    }\n+    if (abs(hours) == 18 && (minutes | seconds) != 0) {\n+      throw \"Zone offset not in valid range: -18:00 to +18:00\";\n+    }\n+  }\n+\n+  std::chrono::seconds seconds_from_minutes_hours(int32_t hours, int32_t minutes,\n+                                                  int32_t seconds) {\n+    validate(hours, minutes, seconds);\n+    int32_t total_seconds = hours * 3600 + minutes * 60 + seconds;\n+    return std::chrono::seconds(total_seconds);\n+  }\n+\n+  int32_t is_timezone_shift(const std::string& string_offset) {\n+    if (string_offset.rfind(\"UTC\") == 0 || string_offset.rfind(\"GMT\") == 0) {\n+      return 3;\n+    } else if (string_offset.rfind(\"UT\") == 0) {\n+      return 2;\n+    }\n+    return 0;\n+  }\n+\n+  std::shared_ptr<OffsetZone> src_offset_tz = NULLPTR;\n+  std::shared_ptr<OffsetZone> dest_offset_tz = NULLPTR;\n+\n+  const time_zone* src_timezone = NULLPTR;\n+  const time_zone* dest_timezone = NULLPTR;\n\nReview comment:\n       Could you use a shared pointer here? Because I think it is dangerous to use plain pointers as they may be not deallocated\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.h\n##########\n@@ -120,6 +120,9 @@ const char* gdv_fn_sha1_decimal128(int64_t context, int64_t x_high, uint64_t x_l\n                                    int32_t x_precision, int32_t x_scale,\n                                    gdv_boolean x_isvalid, int32_t* out_length);\n \n+int gdv_fn_utctime_to_zone(int* time_fields, const char* zone, int zone_len,\n\nReview comment:\n       I looked for that function inside the gdv_stubs, but I did not find it\n\n##########\nFile path: cpp/src/gandiva/convert_timezone_holder_test.cc\n##########\n@@ -0,0 +1,144 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/convert_timezone_holder.h\"\n+\n+#include <gtest/gtest.h>\n+#include \"gandiva/precompiled/testing.h\"\n+\n+#include <memory>\n+#include <vector>\n+\n+namespace gandiva {\n+class TestConvertTimezone : public ::testing::Test {\n+ public:\n+  FunctionNode BuildConvert(std::string srcTz, std::string dstTz) {\n+    auto field = std::make_shared<FieldNode>(arrow::field(\"times\", arrow::int64()));\n+    auto srcTz_node =\n+        std::make_shared<LiteralNode>(arrow::utf8(), LiteralHolder(srcTz), false);\n+    auto dstTz_node =\n+        std::make_shared<LiteralNode>(arrow::utf8(), LiteralHolder(dstTz), false);\n+    return FunctionNode(\"convert_timezone\", {field, srcTz_node, dstTz_node},\n+                        arrow::int64());\n+  }\n+};\n+\n+TEST_F(TestConvertTimezone, TestConvertTimezoneName) {\n+  std::shared_ptr<ConvertTimezoneHolder> convert_holder;\n+\n+  auto status =\n+      ConvertTimezoneHolder::Make(\"Canada/Pacific\", \"Asia/Kolkata\", &convert_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  EXPECT_EQ(convert_holder->convert(StringToTimestamp(\"2016-02-01 08:29:00\")),\n+            StringToTimestamp(\"2016-02-01 21:59:00\"));\n+  EXPECT_EQ(convert_holder->convert(StringToTimestamp(\"2016-10-01 08:29:00\")),\n+            StringToTimestamp(\"2016-10-01 20:59:00\"));  // Checks if it considers Daylight\n+                                                        // saving time periods.\n+  EXPECT_EQ(convert_holder->convert(StringToTimestamp(\"2016-02-28 23:59:59\")),\n+            StringToTimestamp(\"2016-02-29 13:29:59\"));\n+  EXPECT_EQ(convert_holder->convert(StringToTimestamp(\"2015-02-28 23:59:59\")),\n+            StringToTimestamp(\"2015-03-01 13:29:59\"));\n+  EXPECT_EQ(convert_holder->convert(StringToTimestamp(\"1969-01-01 08:29:00\")),\n+            StringToTimestamp(\"1969-01-01 21:59:00\"));\n+  EXPECT_EQ(convert_holder->convert(StringToTimestamp(\"1950-10-01 08:29:00\")),\n+            StringToTimestamp(\"1950-10-01 21:59:00\"));  // Checks if it considers Daylight\n+                                                        // saving time periods.\n+}\n+\n+TEST_F(TestConvertTimezone, TestConvertTimezoneAbbreviations) {\n\nReview comment:\n       Add some tests with error cases, like a timezone that does not exist\n\n##########\nFile path: cpp/src/gandiva/convert_timezone_holder.h\n##########\n@@ -0,0 +1,282 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+\n+#include \"arrow/vendored/datetime/date.h\"\n+#include \"arrow/vendored/datetime/tz.h\"\n+#include \"gandiva/function_holder.h\"\n+#include \"gandiva/node.h\"\n+#include \"gandiva/visibility.h\"\n+\n+using arrow_vendored::date::local_time;\n+using arrow_vendored::date::locate_zone;\n+using arrow_vendored::date::make_zoned;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::time_zone;\n+using std::chrono::milliseconds;\n+\n+namespace gandiva {\n+\n+class OffsetZone {\n+  std::chrono::seconds offset_;\n+\n+ public:\n+  explicit OffsetZone(std::chrono::seconds offset) : offset_(offset) {}\n+\n+  template <class Duration>\n+  auto to_local(arrow_vendored::date::sys_time<Duration> tp) const {\n+    using std::common_type_t;\n+    using std::chrono::seconds;\n+    using LT = local_time<std::common_type_t<Duration, seconds>>;\n+    return LT((tp + offset_).time_since_epoch());\n+  }\n+\n+  template <class Duration>\n+  auto to_sys(arrow_vendored::date::local_time<Duration> tp) const {\n+    using std::chrono::seconds;\n+    using ST = sys_time<std::common_type_t<Duration, seconds>>;\n+    return ST((tp - offset_).time_since_epoch());\n+  }\n+};\n+\n+/// Function Holder for SQL 'CONVERT_TIMEZONE'\n+class GANDIVA_EXPORT ConvertTimezoneHolder : public FunctionHolder {\n+ public:\n+  ~ConvertTimezoneHolder() override = default;\n+\n+  static Status Make(const FunctionNode& node,\n+                     std::shared_ptr<ConvertTimezoneHolder>* holder);\n+\n+  static Status Make(const std::string& srcTz, const std::string& destTz,\n+                     std::shared_ptr<ConvertTimezoneHolder>* holder);\n+\n+  /// Return the converted timestamp\n+  int64_t convert(const int64_t src_timestamp) {\n+    using std::chrono::seconds;\n+\n+    if (dest_timezone != NULLPTR && src_timezone == NULLPTR) {\n+      return dest_timezone\n+          ->to_local(src_offset_tz->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else if (dest_timezone == NULLPTR && src_timezone != NULLPTR) {\n+      return dest_offset_tz\n+          ->to_local(src_timezone->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else if (dest_timezone == NULLPTR && src_timezone == NULLPTR) {\n+      return dest_offset_tz\n+          ->to_local(src_offset_tz->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else {\n+      return dest_timezone\n+          ->to_local(src_timezone->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    }\n+  }\n+\n+  // Tracks if the timezones given could be found in IANA Timezone DB.\n+  bool ok = true;\n+\n+ private:\n+  explicit ConvertTimezoneHolder(const std::string& srcTz, const std::string& destTz) {\n+    auto srcTz_abbrv_offset = abbrv_tz.find(srcTz);\n+    auto destTz_abbrv_offset = abbrv_tz.find(destTz);\n+\n+    try {\n+      if (srcTz_abbrv_offset != abbrv_tz.end()) {\n+        auto secs = convert_offset_to_seconds(srcTz_abbrv_offset->second);\n+        src_offset_tz = std::make_shared<OffsetZone>(secs);\n+      } else {\n+        if (is_timezone_shift(srcTz) ||\n+            is_timezone_offset(const_cast<std::string&>(srcTz))) {\n\nReview comment:\n       You can put that condition as an else-if and the other as else\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -183,6 +184,18 @@ bool gdv_fn_in_expr_lookup_utf8(int64_t ptr, const char* data, int data_len,\n   return holder->HasValue(arrow::util::string_view(data, data_len));\n }\n \n+int64_t gdv_fn_convert_timezone(int64_t ptr, const char* src_tz, int src_tz_len,\n+                                const char* dst_tz, int dst_tz_len, int64_t src_millis,\n+                                bool validity) {\n\nReview comment:\n       Why you add that last validity parameter?\n\n##########\nFile path: cpp/src/gandiva/convert_timezone_holder.h\n##########\n@@ -0,0 +1,282 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+\n+#include \"arrow/vendored/datetime/date.h\"\n+#include \"arrow/vendored/datetime/tz.h\"\n+#include \"gandiva/function_holder.h\"\n+#include \"gandiva/node.h\"\n+#include \"gandiva/visibility.h\"\n+\n+using arrow_vendored::date::local_time;\n+using arrow_vendored::date::locate_zone;\n+using arrow_vendored::date::make_zoned;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::time_zone;\n+using std::chrono::milliseconds;\n+\n+namespace gandiva {\n+\n+class OffsetZone {\n+  std::chrono::seconds offset_;\n+\n+ public:\n+  explicit OffsetZone(std::chrono::seconds offset) : offset_(offset) {}\n+\n+  template <class Duration>\n+  auto to_local(arrow_vendored::date::sys_time<Duration> tp) const {\n+    using std::common_type_t;\n+    using std::chrono::seconds;\n+    using LT = local_time<std::common_type_t<Duration, seconds>>;\n\nReview comment:\n       You add `using std::common_type_t` in the first line, but you repeat the std:: again. Remove the first line or remove the std:: in the last one\n\n##########\nFile path: cpp/src/gandiva/convert_timezone_holder.h\n##########\n@@ -0,0 +1,282 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+\n+#include \"arrow/vendored/datetime/date.h\"\n+#include \"arrow/vendored/datetime/tz.h\"\n+#include \"gandiva/function_holder.h\"\n+#include \"gandiva/node.h\"\n+#include \"gandiva/visibility.h\"\n+\n+using arrow_vendored::date::local_time;\n+using arrow_vendored::date::locate_zone;\n+using arrow_vendored::date::make_zoned;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::time_zone;\n+using std::chrono::milliseconds;\n+\n+namespace gandiva {\n+\n+class OffsetZone {\n+  std::chrono::seconds offset_;\n+\n+ public:\n+  explicit OffsetZone(std::chrono::seconds offset) : offset_(offset) {}\n+\n+  template <class Duration>\n+  auto to_local(arrow_vendored::date::sys_time<Duration> tp) const {\n+    using std::common_type_t;\n+    using std::chrono::seconds;\n+    using LT = local_time<std::common_type_t<Duration, seconds>>;\n+    return LT((tp + offset_).time_since_epoch());\n+  }\n+\n+  template <class Duration>\n+  auto to_sys(arrow_vendored::date::local_time<Duration> tp) const {\n+    using std::chrono::seconds;\n+    using ST = sys_time<std::common_type_t<Duration, seconds>>;\n+    return ST((tp - offset_).time_since_epoch());\n+  }\n+};\n+\n+/// Function Holder for SQL 'CONVERT_TIMEZONE'\n+class GANDIVA_EXPORT ConvertTimezoneHolder : public FunctionHolder {\n+ public:\n+  ~ConvertTimezoneHolder() override = default;\n+\n+  static Status Make(const FunctionNode& node,\n+                     std::shared_ptr<ConvertTimezoneHolder>* holder);\n+\n+  static Status Make(const std::string& srcTz, const std::string& destTz,\n+                     std::shared_ptr<ConvertTimezoneHolder>* holder);\n+\n+  /// Return the converted timestamp\n+  int64_t convert(const int64_t src_timestamp) {\n+    using std::chrono::seconds;\n+\n+    if (dest_timezone != NULLPTR && src_timezone == NULLPTR) {\n+      return dest_timezone\n+          ->to_local(src_offset_tz->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else if (dest_timezone == NULLPTR && src_timezone != NULLPTR) {\n+      return dest_offset_tz\n+          ->to_local(src_timezone->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else if (dest_timezone == NULLPTR && src_timezone == NULLPTR) {\n+      return dest_offset_tz\n+          ->to_local(src_offset_tz->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else {\n+      return dest_timezone\n+          ->to_local(src_timezone->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    }\n+  }\n+\n+  // Tracks if the timezones given could be found in IANA Timezone DB.\n+  bool ok = true;\n\nReview comment:\n       Use a more descriptive name for the variabke\n\n##########\nFile path: cpp/src/gandiva/function_holder_registry.h\n##########\n@@ -64,7 +65,8 @@ class FunctionHolderRegistry {\n     static map_type maker_map = {{\"like\", LAMBDA_MAKER(LikeHolder)},\n                                  {\"ilike\", LAMBDA_MAKER(LikeHolder)},\n                                  {\"to_date\", LAMBDA_MAKER(ToDateHolder)},\n-                                 {\"random\", LAMBDA_MAKER(RandomGeneratorHolder)},\n+                                 {\"convert_timezone\", LAMBDA_MAKER(ConvertTimezoneHolder)},\n+        {\"random\", LAMBDA_MAKER(RandomGeneratorHolder)},\n\nReview comment:\n       Check that format style, it is strange\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-17T22:58:52.496+0000",
                    "updated": "2022-02-17T22:58:52.496+0000",
                    "started": "2022-02-17T22:58:52.496+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "729320",
                    "issueId": "13381562"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381562/worklog/729325",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvictorhuguenin commented on a change in pull request #10432:\nURL: https://github.com/apache/arrow/pull/10432#discussion_r809545369\n\n\n\n##########\nFile path: cpp/src/gandiva/convert_timezone_holder.h\n##########\n@@ -0,0 +1,282 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+\n+#include \"arrow/vendored/datetime/date.h\"\n+#include \"arrow/vendored/datetime/tz.h\"\n+#include \"gandiva/function_holder.h\"\n+#include \"gandiva/node.h\"\n+#include \"gandiva/visibility.h\"\n+\n+using arrow_vendored::date::local_time;\n+using arrow_vendored::date::locate_zone;\n+using arrow_vendored::date::make_zoned;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::time_zone;\n+using std::chrono::milliseconds;\n+\n+namespace gandiva {\n+\n+class OffsetZone {\n+  std::chrono::seconds offset_;\n+\n+ public:\n+  explicit OffsetZone(std::chrono::seconds offset) : offset_(offset) {}\n+\n+  template <class Duration>\n+  auto to_local(arrow_vendored::date::sys_time<Duration> tp) const {\n+    using std::common_type_t;\n+    using std::chrono::seconds;\n+    using LT = local_time<std::common_type_t<Duration, seconds>>;\n\nReview comment:\n       done\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-17T23:13:55.547+0000",
                    "updated": "2022-02-17T23:13:55.547+0000",
                    "started": "2022-02-17T23:13:55.547+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "729325",
                    "issueId": "13381562"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381562/worklog/732243",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvictorhuguenin commented on a change in pull request #10432:\nURL: https://github.com/apache/arrow/pull/10432#discussion_r813812685\n\n\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.h\n##########\n@@ -120,6 +120,9 @@ const char* gdv_fn_sha1_decimal128(int64_t context, int64_t x_high, uint64_t x_l\n                                    int32_t x_precision, int32_t x_scale,\n                                    gdv_boolean x_isvalid, int32_t* out_length);\n \n+int gdv_fn_utctime_to_zone(int* time_fields, const char* zone, int zone_len,\n\nReview comment:\n       removed it\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-24T12:01:03.836+0000",
                    "updated": "2022-02-24T12:01:03.836+0000",
                    "started": "2022-02-24T12:01:03.835+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "732243",
                    "issueId": "13381562"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381562/worklog/732245",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvictorhuguenin commented on a change in pull request #10432:\nURL: https://github.com/apache/arrow/pull/10432#discussion_r813813893\n\n\n\n##########\nFile path: cpp/src/gandiva/convert_timezone_holder.h\n##########\n@@ -0,0 +1,282 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+\n+#include \"arrow/vendored/datetime/date.h\"\n+#include \"arrow/vendored/datetime/tz.h\"\n+#include \"gandiva/function_holder.h\"\n+#include \"gandiva/node.h\"\n+#include \"gandiva/visibility.h\"\n+\n+using arrow_vendored::date::local_time;\n+using arrow_vendored::date::locate_zone;\n+using arrow_vendored::date::make_zoned;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::time_zone;\n+using std::chrono::milliseconds;\n+\n+namespace gandiva {\n+\n+class OffsetZone {\n+  std::chrono::seconds offset_;\n+\n+ public:\n+  explicit OffsetZone(std::chrono::seconds offset) : offset_(offset) {}\n+\n+  template <class Duration>\n+  auto to_local(arrow_vendored::date::sys_time<Duration> tp) const {\n+    using std::common_type_t;\n+    using std::chrono::seconds;\n+    using LT = local_time<std::common_type_t<Duration, seconds>>;\n+    return LT((tp + offset_).time_since_epoch());\n+  }\n+\n+  template <class Duration>\n+  auto to_sys(arrow_vendored::date::local_time<Duration> tp) const {\n+    using std::chrono::seconds;\n+    using ST = sys_time<std::common_type_t<Duration, seconds>>;\n+    return ST((tp - offset_).time_since_epoch());\n+  }\n+};\n+\n+/// Function Holder for SQL 'CONVERT_TIMEZONE'\n+class GANDIVA_EXPORT ConvertTimezoneHolder : public FunctionHolder {\n+ public:\n+  ~ConvertTimezoneHolder() override = default;\n+\n+  static Status Make(const FunctionNode& node,\n+                     std::shared_ptr<ConvertTimezoneHolder>* holder);\n+\n+  static Status Make(const std::string& srcTz, const std::string& destTz,\n+                     std::shared_ptr<ConvertTimezoneHolder>* holder);\n+\n+  /// Return the converted timestamp\n+  int64_t convert(const int64_t src_timestamp) {\n+    using std::chrono::seconds;\n+\n+    if (dest_timezone != NULLPTR && src_timezone == NULLPTR) {\n+      return dest_timezone\n+          ->to_local(src_offset_tz->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else if (dest_timezone == NULLPTR && src_timezone != NULLPTR) {\n+      return dest_offset_tz\n+          ->to_local(src_timezone->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else if (dest_timezone == NULLPTR && src_timezone == NULLPTR) {\n+      return dest_offset_tz\n+          ->to_local(src_offset_tz->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else {\n+      return dest_timezone\n+          ->to_local(src_timezone->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    }\n+  }\n+\n+  // Tracks if the timezones given could be found in IANA Timezone DB.\n+  bool ok = true;\n+\n+ private:\n+  explicit ConvertTimezoneHolder(const std::string& srcTz, const std::string& destTz) {\n+    auto srcTz_abbrv_offset = abbrv_tz.find(srcTz);\n+    auto destTz_abbrv_offset = abbrv_tz.find(destTz);\n+\n+    try {\n+      if (srcTz_abbrv_offset != abbrv_tz.end()) {\n+        auto secs = convert_offset_to_seconds(srcTz_abbrv_offset->second);\n+        src_offset_tz = std::make_shared<OffsetZone>(secs);\n+      } else {\n+        if (is_timezone_shift(srcTz) ||\n+            is_timezone_offset(const_cast<std::string&>(srcTz))) {\n+          auto secs = convert_offset_to_seconds(srcTz);\n+          src_offset_tz = std::make_shared<OffsetZone>(secs);\n+        } else {\n+          src_timezone = locate_zone(srcTz);\n+        }\n+      }\n+\n+      if (destTz_abbrv_offset != abbrv_tz.end()) {\n+        auto secs = convert_offset_to_seconds(destTz_abbrv_offset->second);\n+        dest_offset_tz = std::make_shared<OffsetZone>(secs);\n+      } else {\n+        if (is_timezone_shift(destTz) ||\n+            is_timezone_offset(const_cast<std::string&>(destTz))) {\n+          auto secs = convert_offset_to_seconds(destTz);\n+          dest_offset_tz = std::make_shared<OffsetZone>(secs);\n+        } else {\n+          dest_timezone = locate_zone(destTz);\n+        }\n+      }\n+    } catch (...) {\n+      ok = false;\n+    }\n+  }\n+\n+  static bool is_timezone_offset(std::string& offset) {\n+    if ((offset.rfind(\"-\") == 0 || offset.rfind(\"+\") == 0) && offset.length() == 6) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  std::chrono::seconds convert_offset_to_seconds(std::string string_offset) {\n+    int32_t prefix_offset_length = is_timezone_shift(string_offset);\n+    if (prefix_offset_length != 0) {\n+      auto abbrv_offset = abbrv_tz.find(string_offset.substr(0, prefix_offset_length));\n+      auto abbrv_seconds = off_set_to_seconds(abbrv_offset->second);\n+      auto shift_seconds = off_set_to_seconds(string_offset.substr(prefix_offset_length));\n+      return abbrv_seconds + shift_seconds;\n+    } else {\n+      return off_set_to_seconds(string_offset);\n+    }\n+  }\n+\n+  static int32_t parse_number(std::string& string_offset, int32_t pos,\n+                              bool preceded_by_colon) {\n+    if (preceded_by_colon && string_offset[pos - 1] != ':') {\n+      throw \"Invalid ID for ZoneOffset, colon not found when expected: \" + string_offset;\n+    }\n+    char ch1 = string_offset[pos];\n+    char ch2 = string_offset[pos + 1];\n+    if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {\n+      throw \"Invalid ID for ZoneOffset, non numeric characters found: \" + string_offset;\n+    }\n+\n+    return (ch1 - 48) * 10 + (ch2 - 48);\n+  }\n+\n+  std::chrono::seconds off_set_to_seconds(std::string string_offset) {\n+    // parse - +h, +hh, +hhmm, +hh:mm, +hhmmss, +hh:mm:ss\n+    int32_t hours, minutes, seconds;\n+    std::string sub_minus, sub_plus;\n+    switch (string_offset.length()) {\n+      case 2:\n+        sub_minus = string_offset.substr(string_offset.find(\"-\") + 1);\n+        if (sub_minus.length() == 1) {\n+          string_offset = \"-0\" + sub_minus;  // fallthru\n+        }\n+        sub_plus = string_offset.substr(string_offset.find(\"+\") + 1);\n+        if (sub_plus.length() == 1) {\n+          string_offset = \"+0\" + sub_plus;  // fallthru\n+        }\n+      case 3:\n+        hours = parse_number(string_offset, 1, false);\n+        minutes = 0;\n+        seconds = 0;\n+        break;\n+      case 5:\n+        hours = parse_number(string_offset, 1, false);\n+        minutes = parse_number(string_offset, 3, false);\n+        seconds = 0;\n+        break;\n+      case 6:\n+        hours = parse_number(string_offset, 1, false);\n+        minutes = parse_number(string_offset, 4, true);\n+        seconds = 0;\n+        break;\n+      case 7:\n+        hours = parse_number(string_offset, 1, false);\n+        minutes = parse_number(string_offset, 3, false);\n+        seconds = parse_number(string_offset, 5, false);\n+        break;\n+      case 9:\n+        hours = parse_number(string_offset, 1, false);\n+        minutes = parse_number(string_offset, 4, true);\n+        seconds = parse_number(string_offset, 7, true);\n+        break;\n+      default:\n+        break;\n+    }\n+    char first = string_offset.at(0);\n+    if (first != '+' && first != '-') {\n+      throw \"Invalid ID for ZoneOffset, plus/minus not found when expected: \" +\n+          string_offset;\n+    }\n+    if (first == '-') {\n+      return seconds_from_minutes_hours(-hours, -minutes, -seconds);\n+    } else {\n+      return seconds_from_minutes_hours(hours, minutes, seconds);\n+    }\n+  }\n+\n+  void validate(int32_t hours, int32_t minutes, int32_t seconds) {\n+    if (hours < -18 || hours > 18) {\n+      throw \"Zone offset hours not in valid range\";\n+    }\n+    if (hours > 0) {\n+      if (minutes < 0 || seconds < 0) {\n+        throw \"Zone offset minutes and seconds must be positive because hours is \"\n+              \"positive\";\n+      }\n+    } else if (hours < 0) {\n+      if (minutes > 0 || seconds > 0) {\n+        throw \"Zone offset minutes and seconds must be negative because hours is \"\n+              \"negative\";\n+      }\n+    } else if ((minutes > 0 && seconds < 0) || (minutes < 0 && seconds > 0)) {\n+      throw \"Zone offset minutes and seconds must have the same sign\";\n+    }\n+    if (minutes < -59 || minutes > 59) {\n+      throw \"Zone offset minutes not in valid range\";\n+    }\n+    if (seconds < -59 || seconds > 59) {\n+      throw \"Zone offset seconds not in valid range\";\n+    }\n+    if (abs(hours) == 18 && (minutes | seconds) != 0) {\n+      throw \"Zone offset not in valid range: -18:00 to +18:00\";\n+    }\n+  }\n+\n+  std::chrono::seconds seconds_from_minutes_hours(int32_t hours, int32_t minutes,\n+                                                  int32_t seconds) {\n+    validate(hours, minutes, seconds);\n+    int32_t total_seconds = hours * 3600 + minutes * 60 + seconds;\n+    return std::chrono::seconds(total_seconds);\n+  }\n+\n+  int32_t is_timezone_shift(const std::string& string_offset) {\n+    if (string_offset.rfind(\"UTC\") == 0 || string_offset.rfind(\"GMT\") == 0) {\n+      return 3;\n+    } else if (string_offset.rfind(\"UT\") == 0) {\n+      return 2;\n+    }\n+    return 0;\n+  }\n+\n+  std::shared_ptr<OffsetZone> src_offset_tz = NULLPTR;\n+  std::shared_ptr<OffsetZone> dest_offset_tz = NULLPTR;\n+\n+  const time_zone* src_timezone = NULLPTR;\n+  const time_zone* dest_timezone = NULLPTR;\n\nReview comment:\n       It's not possible because of the class used\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-24T12:02:49.804+0000",
                    "updated": "2022-02-24T12:02:49.804+0000",
                    "started": "2022-02-24T12:02:49.804+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "732245",
                    "issueId": "13381562"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381562/worklog/732246",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvictorhuguenin commented on a change in pull request #10432:\nURL: https://github.com/apache/arrow/pull/10432#discussion_r813813893\n\n\n\n##########\nFile path: cpp/src/gandiva/convert_timezone_holder.h\n##########\n@@ -0,0 +1,282 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+\n+#include \"arrow/vendored/datetime/date.h\"\n+#include \"arrow/vendored/datetime/tz.h\"\n+#include \"gandiva/function_holder.h\"\n+#include \"gandiva/node.h\"\n+#include \"gandiva/visibility.h\"\n+\n+using arrow_vendored::date::local_time;\n+using arrow_vendored::date::locate_zone;\n+using arrow_vendored::date::make_zoned;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::time_zone;\n+using std::chrono::milliseconds;\n+\n+namespace gandiva {\n+\n+class OffsetZone {\n+  std::chrono::seconds offset_;\n+\n+ public:\n+  explicit OffsetZone(std::chrono::seconds offset) : offset_(offset) {}\n+\n+  template <class Duration>\n+  auto to_local(arrow_vendored::date::sys_time<Duration> tp) const {\n+    using std::common_type_t;\n+    using std::chrono::seconds;\n+    using LT = local_time<std::common_type_t<Duration, seconds>>;\n+    return LT((tp + offset_).time_since_epoch());\n+  }\n+\n+  template <class Duration>\n+  auto to_sys(arrow_vendored::date::local_time<Duration> tp) const {\n+    using std::chrono::seconds;\n+    using ST = sys_time<std::common_type_t<Duration, seconds>>;\n+    return ST((tp - offset_).time_since_epoch());\n+  }\n+};\n+\n+/// Function Holder for SQL 'CONVERT_TIMEZONE'\n+class GANDIVA_EXPORT ConvertTimezoneHolder : public FunctionHolder {\n+ public:\n+  ~ConvertTimezoneHolder() override = default;\n+\n+  static Status Make(const FunctionNode& node,\n+                     std::shared_ptr<ConvertTimezoneHolder>* holder);\n+\n+  static Status Make(const std::string& srcTz, const std::string& destTz,\n+                     std::shared_ptr<ConvertTimezoneHolder>* holder);\n+\n+  /// Return the converted timestamp\n+  int64_t convert(const int64_t src_timestamp) {\n+    using std::chrono::seconds;\n+\n+    if (dest_timezone != NULLPTR && src_timezone == NULLPTR) {\n+      return dest_timezone\n+          ->to_local(src_offset_tz->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else if (dest_timezone == NULLPTR && src_timezone != NULLPTR) {\n+      return dest_offset_tz\n+          ->to_local(src_timezone->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else if (dest_timezone == NULLPTR && src_timezone == NULLPTR) {\n+      return dest_offset_tz\n+          ->to_local(src_offset_tz->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else {\n+      return dest_timezone\n+          ->to_local(src_timezone->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    }\n+  }\n+\n+  // Tracks if the timezones given could be found in IANA Timezone DB.\n+  bool ok = true;\n+\n+ private:\n+  explicit ConvertTimezoneHolder(const std::string& srcTz, const std::string& destTz) {\n+    auto srcTz_abbrv_offset = abbrv_tz.find(srcTz);\n+    auto destTz_abbrv_offset = abbrv_tz.find(destTz);\n+\n+    try {\n+      if (srcTz_abbrv_offset != abbrv_tz.end()) {\n+        auto secs = convert_offset_to_seconds(srcTz_abbrv_offset->second);\n+        src_offset_tz = std::make_shared<OffsetZone>(secs);\n+      } else {\n+        if (is_timezone_shift(srcTz) ||\n+            is_timezone_offset(const_cast<std::string&>(srcTz))) {\n+          auto secs = convert_offset_to_seconds(srcTz);\n+          src_offset_tz = std::make_shared<OffsetZone>(secs);\n+        } else {\n+          src_timezone = locate_zone(srcTz);\n+        }\n+      }\n+\n+      if (destTz_abbrv_offset != abbrv_tz.end()) {\n+        auto secs = convert_offset_to_seconds(destTz_abbrv_offset->second);\n+        dest_offset_tz = std::make_shared<OffsetZone>(secs);\n+      } else {\n+        if (is_timezone_shift(destTz) ||\n+            is_timezone_offset(const_cast<std::string&>(destTz))) {\n+          auto secs = convert_offset_to_seconds(destTz);\n+          dest_offset_tz = std::make_shared<OffsetZone>(secs);\n+        } else {\n+          dest_timezone = locate_zone(destTz);\n+        }\n+      }\n+    } catch (...) {\n+      ok = false;\n+    }\n+  }\n+\n+  static bool is_timezone_offset(std::string& offset) {\n+    if ((offset.rfind(\"-\") == 0 || offset.rfind(\"+\") == 0) && offset.length() == 6) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  std::chrono::seconds convert_offset_to_seconds(std::string string_offset) {\n+    int32_t prefix_offset_length = is_timezone_shift(string_offset);\n+    if (prefix_offset_length != 0) {\n+      auto abbrv_offset = abbrv_tz.find(string_offset.substr(0, prefix_offset_length));\n+      auto abbrv_seconds = off_set_to_seconds(abbrv_offset->second);\n+      auto shift_seconds = off_set_to_seconds(string_offset.substr(prefix_offset_length));\n+      return abbrv_seconds + shift_seconds;\n+    } else {\n+      return off_set_to_seconds(string_offset);\n+    }\n+  }\n+\n+  static int32_t parse_number(std::string& string_offset, int32_t pos,\n+                              bool preceded_by_colon) {\n+    if (preceded_by_colon && string_offset[pos - 1] != ':') {\n+      throw \"Invalid ID for ZoneOffset, colon not found when expected: \" + string_offset;\n+    }\n+    char ch1 = string_offset[pos];\n+    char ch2 = string_offset[pos + 1];\n+    if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {\n+      throw \"Invalid ID for ZoneOffset, non numeric characters found: \" + string_offset;\n+    }\n+\n+    return (ch1 - 48) * 10 + (ch2 - 48);\n+  }\n+\n+  std::chrono::seconds off_set_to_seconds(std::string string_offset) {\n+    // parse - +h, +hh, +hhmm, +hh:mm, +hhmmss, +hh:mm:ss\n+    int32_t hours, minutes, seconds;\n+    std::string sub_minus, sub_plus;\n+    switch (string_offset.length()) {\n+      case 2:\n+        sub_minus = string_offset.substr(string_offset.find(\"-\") + 1);\n+        if (sub_minus.length() == 1) {\n+          string_offset = \"-0\" + sub_minus;  // fallthru\n+        }\n+        sub_plus = string_offset.substr(string_offset.find(\"+\") + 1);\n+        if (sub_plus.length() == 1) {\n+          string_offset = \"+0\" + sub_plus;  // fallthru\n+        }\n+      case 3:\n+        hours = parse_number(string_offset, 1, false);\n+        minutes = 0;\n+        seconds = 0;\n+        break;\n+      case 5:\n+        hours = parse_number(string_offset, 1, false);\n+        minutes = parse_number(string_offset, 3, false);\n+        seconds = 0;\n+        break;\n+      case 6:\n+        hours = parse_number(string_offset, 1, false);\n+        minutes = parse_number(string_offset, 4, true);\n+        seconds = 0;\n+        break;\n+      case 7:\n+        hours = parse_number(string_offset, 1, false);\n+        minutes = parse_number(string_offset, 3, false);\n+        seconds = parse_number(string_offset, 5, false);\n+        break;\n+      case 9:\n+        hours = parse_number(string_offset, 1, false);\n+        minutes = parse_number(string_offset, 4, true);\n+        seconds = parse_number(string_offset, 7, true);\n+        break;\n+      default:\n+        break;\n+    }\n+    char first = string_offset.at(0);\n+    if (first != '+' && first != '-') {\n+      throw \"Invalid ID for ZoneOffset, plus/minus not found when expected: \" +\n+          string_offset;\n+    }\n+    if (first == '-') {\n+      return seconds_from_minutes_hours(-hours, -minutes, -seconds);\n+    } else {\n+      return seconds_from_minutes_hours(hours, minutes, seconds);\n+    }\n+  }\n+\n+  void validate(int32_t hours, int32_t minutes, int32_t seconds) {\n+    if (hours < -18 || hours > 18) {\n+      throw \"Zone offset hours not in valid range\";\n+    }\n+    if (hours > 0) {\n+      if (minutes < 0 || seconds < 0) {\n+        throw \"Zone offset minutes and seconds must be positive because hours is \"\n+              \"positive\";\n+      }\n+    } else if (hours < 0) {\n+      if (minutes > 0 || seconds > 0) {\n+        throw \"Zone offset minutes and seconds must be negative because hours is \"\n+              \"negative\";\n+      }\n+    } else if ((minutes > 0 && seconds < 0) || (minutes < 0 && seconds > 0)) {\n+      throw \"Zone offset minutes and seconds must have the same sign\";\n+    }\n+    if (minutes < -59 || minutes > 59) {\n+      throw \"Zone offset minutes not in valid range\";\n+    }\n+    if (seconds < -59 || seconds > 59) {\n+      throw \"Zone offset seconds not in valid range\";\n+    }\n+    if (abs(hours) == 18 && (minutes | seconds) != 0) {\n+      throw \"Zone offset not in valid range: -18:00 to +18:00\";\n+    }\n+  }\n+\n+  std::chrono::seconds seconds_from_minutes_hours(int32_t hours, int32_t minutes,\n+                                                  int32_t seconds) {\n+    validate(hours, minutes, seconds);\n+    int32_t total_seconds = hours * 3600 + minutes * 60 + seconds;\n+    return std::chrono::seconds(total_seconds);\n+  }\n+\n+  int32_t is_timezone_shift(const std::string& string_offset) {\n+    if (string_offset.rfind(\"UTC\") == 0 || string_offset.rfind(\"GMT\") == 0) {\n+      return 3;\n+    } else if (string_offset.rfind(\"UT\") == 0) {\n+      return 2;\n+    }\n+    return 0;\n+  }\n+\n+  std::shared_ptr<OffsetZone> src_offset_tz = NULLPTR;\n+  std::shared_ptr<OffsetZone> dest_offset_tz = NULLPTR;\n+\n+  const time_zone* src_timezone = NULLPTR;\n+  const time_zone* dest_timezone = NULLPTR;\n\nReview comment:\n       It's not possible because of the function used to create the timezone object\n\n##########\nFile path: cpp/src/gandiva/convert_timezone_holder.h\n##########\n@@ -0,0 +1,282 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+\n+#include \"arrow/vendored/datetime/date.h\"\n+#include \"arrow/vendored/datetime/tz.h\"\n+#include \"gandiva/function_holder.h\"\n+#include \"gandiva/node.h\"\n+#include \"gandiva/visibility.h\"\n+\n+using arrow_vendored::date::local_time;\n+using arrow_vendored::date::locate_zone;\n+using arrow_vendored::date::make_zoned;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::time_zone;\n+using std::chrono::milliseconds;\n+\n+namespace gandiva {\n+\n+class OffsetZone {\n+  std::chrono::seconds offset_;\n+\n+ public:\n+  explicit OffsetZone(std::chrono::seconds offset) : offset_(offset) {}\n+\n+  template <class Duration>\n+  auto to_local(arrow_vendored::date::sys_time<Duration> tp) const {\n+    using std::common_type_t;\n+    using std::chrono::seconds;\n+    using LT = local_time<std::common_type_t<Duration, seconds>>;\n+    return LT((tp + offset_).time_since_epoch());\n+  }\n+\n+  template <class Duration>\n+  auto to_sys(arrow_vendored::date::local_time<Duration> tp) const {\n+    using std::chrono::seconds;\n+    using ST = sys_time<std::common_type_t<Duration, seconds>>;\n+    return ST((tp - offset_).time_since_epoch());\n+  }\n+};\n+\n+/// Function Holder for SQL 'CONVERT_TIMEZONE'\n+class GANDIVA_EXPORT ConvertTimezoneHolder : public FunctionHolder {\n+ public:\n+  ~ConvertTimezoneHolder() override = default;\n+\n+  static Status Make(const FunctionNode& node,\n+                     std::shared_ptr<ConvertTimezoneHolder>* holder);\n+\n+  static Status Make(const std::string& srcTz, const std::string& destTz,\n+                     std::shared_ptr<ConvertTimezoneHolder>* holder);\n+\n+  /// Return the converted timestamp\n+  int64_t convert(const int64_t src_timestamp) {\n+    using std::chrono::seconds;\n+\n+    if (dest_timezone != NULLPTR && src_timezone == NULLPTR) {\n+      return dest_timezone\n+          ->to_local(src_offset_tz->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else if (dest_timezone == NULLPTR && src_timezone != NULLPTR) {\n+      return dest_offset_tz\n+          ->to_local(src_timezone->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else if (dest_timezone == NULLPTR && src_timezone == NULLPTR) {\n+      return dest_offset_tz\n+          ->to_local(src_offset_tz->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else {\n+      return dest_timezone\n+          ->to_local(src_timezone->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    }\n+  }\n+\n+  // Tracks if the timezones given could be found in IANA Timezone DB.\n+  bool ok = true;\n\nReview comment:\n       done\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-24T12:03:26.784+0000",
                    "updated": "2022-02-24T12:03:26.784+0000",
                    "started": "2022-02-24T12:03:26.784+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "732246",
                    "issueId": "13381562"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381562/worklog/732248",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvictorhuguenin commented on a change in pull request #10432:\nURL: https://github.com/apache/arrow/pull/10432#discussion_r813816522\n\n\n\n##########\nFile path: cpp/src/gandiva/convert_timezone_holder.h\n##########\n@@ -0,0 +1,282 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+\n+#include \"arrow/vendored/datetime/date.h\"\n+#include \"arrow/vendored/datetime/tz.h\"\n+#include \"gandiva/function_holder.h\"\n+#include \"gandiva/node.h\"\n+#include \"gandiva/visibility.h\"\n+\n+using arrow_vendored::date::local_time;\n+using arrow_vendored::date::locate_zone;\n+using arrow_vendored::date::make_zoned;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::time_zone;\n+using std::chrono::milliseconds;\n+\n+namespace gandiva {\n+\n+class OffsetZone {\n+  std::chrono::seconds offset_;\n+\n+ public:\n+  explicit OffsetZone(std::chrono::seconds offset) : offset_(offset) {}\n+\n+  template <class Duration>\n+  auto to_local(arrow_vendored::date::sys_time<Duration> tp) const {\n+    using std::common_type_t;\n+    using std::chrono::seconds;\n+    using LT = local_time<std::common_type_t<Duration, seconds>>;\n+    return LT((tp + offset_).time_since_epoch());\n+  }\n+\n+  template <class Duration>\n+  auto to_sys(arrow_vendored::date::local_time<Duration> tp) const {\n+    using std::chrono::seconds;\n+    using ST = sys_time<std::common_type_t<Duration, seconds>>;\n+    return ST((tp - offset_).time_since_epoch());\n+  }\n+};\n+\n+/// Function Holder for SQL 'CONVERT_TIMEZONE'\n+class GANDIVA_EXPORT ConvertTimezoneHolder : public FunctionHolder {\n+ public:\n+  ~ConvertTimezoneHolder() override = default;\n+\n+  static Status Make(const FunctionNode& node,\n+                     std::shared_ptr<ConvertTimezoneHolder>* holder);\n+\n+  static Status Make(const std::string& srcTz, const std::string& destTz,\n+                     std::shared_ptr<ConvertTimezoneHolder>* holder);\n+\n+  /// Return the converted timestamp\n+  int64_t convert(const int64_t src_timestamp) {\n+    using std::chrono::seconds;\n+\n+    if (dest_timezone != NULLPTR && src_timezone == NULLPTR) {\n+      return dest_timezone\n+          ->to_local(src_offset_tz->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else if (dest_timezone == NULLPTR && src_timezone != NULLPTR) {\n+      return dest_offset_tz\n+          ->to_local(src_timezone->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else if (dest_timezone == NULLPTR && src_timezone == NULLPTR) {\n+      return dest_offset_tz\n+          ->to_local(src_offset_tz->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    } else {\n+      return dest_timezone\n+          ->to_local(src_timezone->to_sys<milliseconds>(\n+              local_time<milliseconds>(milliseconds(src_timestamp))))\n+          .time_since_epoch()\n+          .count();\n+    }\n+  }\n+\n+  // Tracks if the timezones given could be found in IANA Timezone DB.\n+  bool ok = true;\n+\n+ private:\n+  explicit ConvertTimezoneHolder(const std::string& srcTz, const std::string& destTz) {\n+    auto srcTz_abbrv_offset = abbrv_tz.find(srcTz);\n+    auto destTz_abbrv_offset = abbrv_tz.find(destTz);\n+\n+    try {\n+      if (srcTz_abbrv_offset != abbrv_tz.end()) {\n+        auto secs = convert_offset_to_seconds(srcTz_abbrv_offset->second);\n+        src_offset_tz = std::make_shared<OffsetZone>(secs);\n+      } else {\n+        if (is_timezone_shift(srcTz) ||\n+            is_timezone_offset(const_cast<std::string&>(srcTz))) {\n\nReview comment:\n       done\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-24T12:06:48.489+0000",
                    "updated": "2022-02-24T12:06:48.489+0000",
                    "started": "2022-02-24T12:06:48.488+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "732248",
                    "issueId": "13381562"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381562/worklog/734107",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvictorhuguenin commented on a change in pull request #10432:\nURL: https://github.com/apache/arrow/pull/10432#discussion_r816173076\n\n\n\n##########\nFile path: cpp/src/gandiva/function_holder_registry.h\n##########\n@@ -64,7 +65,8 @@ class FunctionHolderRegistry {\n     static map_type maker_map = {{\"like\", LAMBDA_MAKER(LikeHolder)},\n                                  {\"ilike\", LAMBDA_MAKER(LikeHolder)},\n                                  {\"to_date\", LAMBDA_MAKER(ToDateHolder)},\n-                                 {\"random\", LAMBDA_MAKER(RandomGeneratorHolder)},\n+                                 {\"convert_timezone\", LAMBDA_MAKER(ConvertTimezoneHolder)},\n+        {\"random\", LAMBDA_MAKER(RandomGeneratorHolder)},\n\nReview comment:\n       done\n\n##########\nFile path: cpp/src/gandiva/convert_timezone_holder_test.cc\n##########\n@@ -0,0 +1,144 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/convert_timezone_holder.h\"\n+\n+#include <gtest/gtest.h>\n+#include \"gandiva/precompiled/testing.h\"\n+\n+#include <memory>\n+#include <vector>\n+\n+namespace gandiva {\n+class TestConvertTimezone : public ::testing::Test {\n+ public:\n+  FunctionNode BuildConvert(std::string srcTz, std::string dstTz) {\n+    auto field = std::make_shared<FieldNode>(arrow::field(\"times\", arrow::int64()));\n+    auto srcTz_node =\n+        std::make_shared<LiteralNode>(arrow::utf8(), LiteralHolder(srcTz), false);\n+    auto dstTz_node =\n+        std::make_shared<LiteralNode>(arrow::utf8(), LiteralHolder(dstTz), false);\n+    return FunctionNode(\"convert_timezone\", {field, srcTz_node, dstTz_node},\n+                        arrow::int64());\n+  }\n+};\n+\n+TEST_F(TestConvertTimezone, TestConvertTimezoneName) {\n+  std::shared_ptr<ConvertTimezoneHolder> convert_holder;\n+\n+  auto status =\n+      ConvertTimezoneHolder::Make(\"Canada/Pacific\", \"Asia/Kolkata\", &convert_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  EXPECT_EQ(convert_holder->convert(StringToTimestamp(\"2016-02-01 08:29:00\")),\n+            StringToTimestamp(\"2016-02-01 21:59:00\"));\n+  EXPECT_EQ(convert_holder->convert(StringToTimestamp(\"2016-10-01 08:29:00\")),\n+            StringToTimestamp(\"2016-10-01 20:59:00\"));  // Checks if it considers Daylight\n+                                                        // saving time periods.\n+  EXPECT_EQ(convert_holder->convert(StringToTimestamp(\"2016-02-28 23:59:59\")),\n+            StringToTimestamp(\"2016-02-29 13:29:59\"));\n+  EXPECT_EQ(convert_holder->convert(StringToTimestamp(\"2015-02-28 23:59:59\")),\n+            StringToTimestamp(\"2015-03-01 13:29:59\"));\n+  EXPECT_EQ(convert_holder->convert(StringToTimestamp(\"1969-01-01 08:29:00\")),\n+            StringToTimestamp(\"1969-01-01 21:59:00\"));\n+  EXPECT_EQ(convert_holder->convert(StringToTimestamp(\"1950-10-01 08:29:00\")),\n+            StringToTimestamp(\"1950-10-01 21:59:00\"));  // Checks if it considers Daylight\n+                                                        // saving time periods.\n+}\n+\n+TEST_F(TestConvertTimezone, TestConvertTimezoneAbbreviations) {\n\nReview comment:\n       done\r\n   \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-28T19:07:11.029+0000",
                    "updated": "2022-02-28T19:07:11.029+0000",
                    "started": "2022-02-28T19:07:11.029+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "734107",
                    "issueId": "13381562"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381562/worklog/734111",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvictorhuguenin commented on a change in pull request #10432:\nURL: https://github.com/apache/arrow/pull/10432#discussion_r816178933\n\n\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -183,6 +184,18 @@ bool gdv_fn_in_expr_lookup_utf8(int64_t ptr, const char* data, int data_len,\n   return holder->HasValue(arrow::util::string_view(data, data_len));\n }\n \n+int64_t gdv_fn_convert_timezone(int64_t ptr, const char* src_tz, int src_tz_len,\n+                                const char* dst_tz, int dst_tz_len, int64_t src_millis,\n+                                bool validity) {\n\nReview comment:\n       I uncommented the lines below\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-28T19:16:12.924+0000",
                    "updated": "2022-02-28T19:16:12.924+0000",
                    "started": "2022-02-28T19:16:12.923+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "734111",
                    "issueId": "13381562"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 6600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@59849f56[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@53afbaf2[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@72fd055e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@5c2b59d9[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@dc7e194[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@70eaa5e1[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6aa79957[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@6cc4e04b[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5ebd7706[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@7bdd149d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2de64790[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@66eb2cdf[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 6600,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Jul 12 14:04:50 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": null,
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12924/watchers",
            "watchCount": 2,
            "isWatching": true
        },
        "created": "2021-06-01T22:07:31.000+0000",
        "updated": "2022-07-12T14:04:50.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 6600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Gandiva][C++] Implement CONVERT_TIMEZONE SQL function in Gandiva",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381562/comment/17565781",
                    "id": "17565781",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=toddfarmer",
                        "name": "toddfarmer",
                        "key": "JIRAUSER288796",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=39935",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=39935",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=39935",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=39935"
                        },
                        "displayName": "Todd Farmer",
                        "active": true,
                        "timeZone": "America/Boise"
                    },
                    "body": "This issue was last updated over 90 days ago, which may be an indication it is no longer being actively worked. To better reflect the current state, the issue is being unassigned. Please feel free to re-take assignment of the issue if it is being actively worked, or if you plan to start that work soon.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=toddfarmer",
                        "name": "toddfarmer",
                        "key": "JIRAUSER288796",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=39935",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=39935",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=39935",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=39935"
                        },
                        "displayName": "Todd Farmer",
                        "active": true,
                        "timeZone": "America/Boise"
                    },
                    "created": "2022-07-12T14:04:50.326+0000",
                    "updated": "2022-07-12T14:04:50.326+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0rkc0:",
        "customfield_12314139": null
    }
}