{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13475027",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027",
    "key": "ARROW-17301",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12352360",
                "id": "12352360",
                "description": "",
                "name": "11.0.0",
                "archived": false,
                "released": false
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12352081",
                "id": "12352081",
                "description": "",
                "name": "8.0.1",
                "archived": false,
                "released": true,
                "releaseDate": "2022-07-19"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=kshitij12345",
            "name": "kshitij12345",
            "key": "JIRAUSER289998",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Kshiteej K",
            "active": true,
            "timeZone": "Asia/Kolkata"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=chenbaggio",
            "name": "chenbaggio",
            "key": "JIRAUSER293896",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "ChenTsing",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=chenbaggio",
            "name": "chenbaggio",
            "key": "JIRAUSER293896",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "ChenTsing",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 14400,
            "total": 14400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 14400,
            "total": 14400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17301/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 24,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/821704",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kshitij12345 opened a new pull request, #14550:\nURL: https://github.com/apache/arrow/pull/14550\n\n   Implements `binary_slice_bytes` similar to `utf8_slice_codeunits`.\r\n   \r\n   TODO:\r\n   * [ ] Tests\n\n\n",
                    "created": "2022-10-29T16:31:37.521+0000",
                    "updated": "2022-10-29T16:31:37.521+0000",
                    "started": "2022-10-29T16:31:37.521+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "821704",
                    "issueId": "13475027"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/821705",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #14550:\nURL: https://github.com/apache/arrow/pull/14550#issuecomment-1295893049\n\n   https://issues.apache.org/jira/browse/ARROW-17301\n\n\n",
                    "created": "2022-10-29T16:31:55.048+0000",
                    "updated": "2022-10-29T16:31:55.048+0000",
                    "started": "2022-10-29T16:31:55.048+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "821705",
                    "issueId": "13475027"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/821706",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #14550:\nURL: https://github.com/apache/arrow/pull/14550#issuecomment-1295893057\n\n   :warning: Ticket **has not been started in JIRA**, please click 'Start Progress'.\n\n\n",
                    "created": "2022-10-29T16:31:56.264+0000",
                    "updated": "2022-10-29T16:31:56.264+0000",
                    "started": "2022-10-29T16:31:56.264+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "821706",
                    "issueId": "13475027"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/821796",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kshitij12345 commented on PR #14550:\nURL: https://github.com/apache/arrow/pull/14550#issuecomment-1296264889\n\n   cc: @AlenkaF @jorisvandenbossche \n\n\n",
                    "created": "2022-10-30T13:51:20.973+0000",
                    "updated": "2022-10-30T13:51:20.973+0000",
                    "started": "2022-10-30T13:51:20.972+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "821796",
                    "issueId": "13475027"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/821865",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kshitij12345 commented on code in PR #14550:\nURL: https://github.com/apache/arrow/pull/14550#discussion_r1009064077\n\n\n##########\ncpp/src/arrow/compute/kernels/scalar_string_test.cc:\n##########\n@@ -2119,6 +2119,96 @@ TYPED_TEST(TestStringKernels, SliceCodeunitsNegPos) {\n \n #endif  // ARROW_WITH_UTF8PROC\n \n+TYPED_TEST(TestBaseBinaryKernels, SliceBytesBasic) {\n\nReview Comment:\n   Inspired from `utf8_slice_codeunits` tests\r\n   \r\n   https://github.com/apache/arrow/blob/884e81bf2ffd410cbffac9727b94617532c8d915/cpp/src/arrow/compute/kernels/scalar_string_test.cc#L2013\n\n\n\n",
                    "created": "2022-10-31T06:22:54.456+0000",
                    "updated": "2022-10-31T06:22:54.456+0000",
                    "started": "2022-10-31T06:22:54.455+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "821865",
                    "issueId": "13475027"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/821867",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kshitij12345 commented on code in PR #14550:\nURL: https://github.com/apache/arrow/pull/14550#discussion_r1009064514\n\n\n##########\npython/pyarrow/tests/test_compute.py:\n##########\n@@ -536,6 +537,24 @@ def test_slice_compatibility():\n                                                start, stop, step) == result\n \n \n+def test_binary_slice_compatibility():\n\nReview Comment:\n   Inspired from `utf8_slice_codeunits` test\r\n   \r\n   https://github.com/apache/arrow/blob/884e81bf2ffd410cbffac9727b94617532c8d915/python/pyarrow/tests/test_compute.py#L525-L537\n\n\n\n",
                    "created": "2022-10-31T06:23:54.524+0000",
                    "updated": "2022-10-31T06:23:54.524+0000",
                    "started": "2022-10-31T06:23:54.524+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "821867",
                    "issueId": "13475027"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/823896",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kshitij12345 commented on PR #14550:\nURL: https://github.com/apache/arrow/pull/14550#issuecomment-1305513770\n\n   Gentle ping @AlenkaF @jorisvandenbossche :)\n\n\n",
                    "created": "2022-11-07T12:08:59.388+0000",
                    "updated": "2022-11-07T12:08:59.388+0000",
                    "started": "2022-11-07T12:08:59.388+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "823896",
                    "issueId": "13475027"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/823959",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "AlenkaF commented on PR #14550:\nURL: https://github.com/apache/arrow/pull/14550#issuecomment-1305873429\n\n   Thank you for the PR @kshitij12345!\r\n   @pitrou @rok would you mind having a look at this PR?\n\n\n",
                    "created": "2022-11-07T16:33:29.953+0000",
                    "updated": "2022-11-07T16:33:29.953+0000",
                    "started": "2022-11-07T16:33:29.952+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "823959",
                    "issueId": "13475027"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/824988",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #14550:\nURL: https://github.com/apache/arrow/pull/14550#discussion_r1019355193\n\n\n##########\ncpp/src/arrow/compute/kernels/scalar_string_ascii.cc:\n##########\n@@ -2409,6 +2409,172 @@ void AddAsciiStringReplaceSlice(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// ----------------------------------------------------------------------\n+// Slice\n+\n+namespace {\n+struct SliceBytesTransform : StringSliceTransformBase {\n+  int64_t MaxCodeunits(int64_t ninputs, int64_t input_bytes) override {\n+    const SliceOptions& opt = *this->options;\n+    if ((opt.start >= 0) != (opt.stop >= 0)) {\n+      // If start and stop don't have the same sign, we can't guess an upper bound\n+      // on the resulting slice lengths, so return a worst case estimate.\n+      return input_bytes;\n+    }\n+    int64_t max_slice_bytes = (opt.stop - opt.start + opt.step - 1) / opt.step;\n+    return std::min(input_bytes, ninputs * std::max<int64_t>(0, max_slice_bytes));\n+  }\n+\n+  int64_t Transform(const uint8_t* input, int64_t input_string_bytes, uint8_t* output) {\n+    if (options->step >= 1) {\n+      return SliceForward(input, input_string_bytes, output);\n+    }\n+    return SliceBackward(input, input_string_bytes, output);\n+  }\n+\n+  int64_t SliceForward(const uint8_t* input, int64_t input_string_bytes,\n+                       uint8_t* output) {\n+    // Slice in forward order (step > 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced;\n+    const uint8_t* end_sliced;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+    // First, compute begin_sliced and end_sliced\n+    if (opt.start >= 0) {\n+      // start counting from the left\n+      begin_sliced = std::min(begin + opt.start, end);\n+      if (opt.stop > opt.start) {\n+        // continue counting from begin_sliced\n+        const int64_t length = opt.stop - opt.start;\n+        end_sliced = std::min(begin_sliced + length, end);\n+      } else if (opt.stop < 0) {\n+        // from the end\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    } else {\n+      // start counting from the right\n+      begin_sliced = std::max(end + opt.start, begin);\n+      if (opt.stop > 0) {\n+        // continue counting from the left, we cannot start from begin_sliced because we\n+        // don't know how many bytes are between begin and begin_sliced\n+        end_sliced = std::min(begin + opt.stop, end);\n+        // and therefore we also needs this\n+        if (end_sliced <= begin_sliced) {\n+          // zero length slice\n+          return 0;\n+        }\n+      } else if ((opt.stop < 0) && (opt.stop > opt.start)) {\n+        // stop is negative, but larger than start, so we count again from the right\n+        // in some cases we can optimize this, depending on the shortest path (from end\n+        // or begin_sliced), but begin_sliced and opt.start can be 'out of sync',\n+        // for instance when start=-100, when the string length is only 10.\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    }\n+\n+    // Second, copy computed slice to output\n+    DCHECK(begin_sliced <= end_sliced);\n+    if (opt.step == 1) {\n+      // fast case, where we simply can finish with a memcpy\n+      std::copy(begin_sliced, end_sliced, output);\n+      return end_sliced - begin_sliced;\n+    }\n+\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+\n+    while (i < end_sliced) {\n+      *dest = *i;\n+      // skip step codeunits\n+      i += opt.step;\n+      dest++;\n+    }\n+    return dest - output;\n+  }\n+\n+  int64_t SliceBackward(const uint8_t* input, int64_t input_string_bytes,\n+                        uint8_t* output) {\n+    // Slice in reverse order (step < 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced = begin;\n+    const uint8_t* end_sliced = end;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+\n+    if (opt.start >= 0) {\n+      // +1 because begin_sliced acts as as the end of a reverse iterator\n+      begin_sliced = std::min(begin + opt.start + 1, end);\n+    } else {\n+      // -1 because start=-1 means the last byte, which is 0 advances\n+      begin_sliced = std::max(end + opt.start + 1, begin);\n+    }\n+    begin_sliced--;\n+\n+    // similar to opt.start\n+    if (opt.stop >= 0) {\n+      end_sliced = std::min(begin + opt.stop + 1, end);\n+    } else {\n+      end_sliced = std::max(end + opt.stop + 1, begin);\n+    }\n+    end_sliced--;\n+\n+    // Copy computed slice to output\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+    while (i > end_sliced) {\n+      // write a single codepoint\n+      *dest = *i;\n+      // and skip the remainder\n+      i += opt.step;\n+      dest++;\n+    }\n+\n+    return dest - output;\n+  }\n+};\n+\n+template <typename Type>\n+using SliceBytes = StringTransformExec<Type, SliceBytesTransform>;\n+\n+}  // namespace\n+\n+const FunctionDoc binary_slice_bytes_doc(\n+    \"Slice string\",\n\nReview Comment:\n   ```suggestion\r\n       \"Slice binary string\",\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/kernels/scalar_string_ascii.cc:\n##########\n@@ -2409,6 +2409,172 @@ void AddAsciiStringReplaceSlice(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// ----------------------------------------------------------------------\n+// Slice\n+\n+namespace {\n+struct SliceBytesTransform : StringSliceTransformBase {\n+  int64_t MaxCodeunits(int64_t ninputs, int64_t input_bytes) override {\n+    const SliceOptions& opt = *this->options;\n+    if ((opt.start >= 0) != (opt.stop >= 0)) {\n+      // If start and stop don't have the same sign, we can't guess an upper bound\n+      // on the resulting slice lengths, so return a worst case estimate.\n+      return input_bytes;\n+    }\n+    int64_t max_slice_bytes = (opt.stop - opt.start + opt.step - 1) / opt.step;\n+    return std::min(input_bytes, ninputs * std::max<int64_t>(0, max_slice_bytes));\n+  }\n+\n+  int64_t Transform(const uint8_t* input, int64_t input_string_bytes, uint8_t* output) {\n+    if (options->step >= 1) {\n+      return SliceForward(input, input_string_bytes, output);\n+    }\n+    return SliceBackward(input, input_string_bytes, output);\n+  }\n+\n+  int64_t SliceForward(const uint8_t* input, int64_t input_string_bytes,\n+                       uint8_t* output) {\n+    // Slice in forward order (step > 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced;\n+    const uint8_t* end_sliced;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+    // First, compute begin_sliced and end_sliced\n+    if (opt.start >= 0) {\n+      // start counting from the left\n+      begin_sliced = std::min(begin + opt.start, end);\n+      if (opt.stop > opt.start) {\n+        // continue counting from begin_sliced\n+        const int64_t length = opt.stop - opt.start;\n+        end_sliced = std::min(begin_sliced + length, end);\n+      } else if (opt.stop < 0) {\n+        // from the end\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    } else {\n+      // start counting from the right\n+      begin_sliced = std::max(end + opt.start, begin);\n+      if (opt.stop > 0) {\n+        // continue counting from the left, we cannot start from begin_sliced because we\n+        // don't know how many bytes are between begin and begin_sliced\n+        end_sliced = std::min(begin + opt.stop, end);\n+        // and therefore we also needs this\n+        if (end_sliced <= begin_sliced) {\n+          // zero length slice\n+          return 0;\n+        }\n+      } else if ((opt.stop < 0) && (opt.stop > opt.start)) {\n+        // stop is negative, but larger than start, so we count again from the right\n+        // in some cases we can optimize this, depending on the shortest path (from end\n+        // or begin_sliced), but begin_sliced and opt.start can be 'out of sync',\n+        // for instance when start=-100, when the string length is only 10.\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    }\n+\n+    // Second, copy computed slice to output\n+    DCHECK(begin_sliced <= end_sliced);\n+    if (opt.step == 1) {\n+      // fast case, where we simply can finish with a memcpy\n+      std::copy(begin_sliced, end_sliced, output);\n+      return end_sliced - begin_sliced;\n+    }\n+\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+\n+    while (i < end_sliced) {\n+      *dest = *i;\n+      // skip step codeunits\n+      i += opt.step;\n+      dest++;\n+    }\n+    return dest - output;\n+  }\n+\n+  int64_t SliceBackward(const uint8_t* input, int64_t input_string_bytes,\n+                        uint8_t* output) {\n+    // Slice in reverse order (step < 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced = begin;\n+    const uint8_t* end_sliced = end;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+\n+    if (opt.start >= 0) {\n+      // +1 because begin_sliced acts as as the end of a reverse iterator\n+      begin_sliced = std::min(begin + opt.start + 1, end);\n+    } else {\n+      // -1 because start=-1 means the last byte, which is 0 advances\n+      begin_sliced = std::max(end + opt.start + 1, begin);\n+    }\n+    begin_sliced--;\n+\n+    // similar to opt.start\n+    if (opt.stop >= 0) {\n+      end_sliced = std::min(begin + opt.stop + 1, end);\n+    } else {\n+      end_sliced = std::max(end + opt.stop + 1, begin);\n+    }\n+    end_sliced--;\n+\n+    // Copy computed slice to output\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+    while (i > end_sliced) {\n+      // write a single codepoint\n+      *dest = *i;\n+      // and skip the remainder\n+      i += opt.step;\n+      dest++;\n+    }\n+\n+    return dest - output;\n+  }\n+};\n+\n+template <typename Type>\n+using SliceBytes = StringTransformExec<Type, SliceBytesTransform>;\n+\n+}  // namespace\n+\n+const FunctionDoc binary_slice_bytes_doc(\n+    \"Slice string\",\n+    (\"For each string in `strings`, emit the substring defined by\\n\"\n+     \"(`start`, `stop`, `step`) as given by `SliceOptions` where `start` is\\n\"\n+     \"inclusive and `stop` is exclusive. All three values are measured in\\n\"\n+     \"bytes.\\n\"\n+     \"If `step` is negative, the string will be advanced in reversed order.\\n\"\n+     \"An error is raised if `step` is zero.\\n\"\n+     \"Null inputs emit null.\"),\n+    {\"strings\"}, \"SliceOptions\", /*options_required=*/true);\n+\n+void AddAsciiStringSlice(FunctionRegistry* registry) {\n+  auto func = std::make_shared<ScalarFunction>(\"binary_slice_bytes\", Arity::Unary(),\n\nReview Comment:\n   I think `binary_slice` is explanatory enough.\n\n\n\n##########\ncpp/src/arrow/compute/kernels/scalar_string_test.cc:\n##########\n@@ -2119,6 +2119,96 @@ TYPED_TEST(TestStringKernels, SliceCodeunitsNegPos) {\n \n #endif  // ARROW_WITH_UTF8PROC\n \n+TYPED_TEST(TestBaseBinaryKernels, SliceBytesBasic) {\n+  SliceOptions options{2, 4};\n+  this->CheckUnary(\"binary_slice_bytes\", R\"([\"foo\", \"fo\", null, \"foo \"])\", this->type(),\n+                   R\"([\"o\", \"\", null, \"o \"])\", &options);\n+\n+  // end is beyond 0, but before start (hence empty)\n+  SliceOptions options_edgecase_1{-3, 1};\n+  this->CheckUnary(\"binary_slice_bytes\", R\"([\"foods\"])\", this->type(), R\"([\"\"])\",\n+                   &options_edgecase_1);\n+\n+  // this is a safeguard agains an optimization path possible, but actually a tricky case\n+  SliceOptions options_edgecase_2{-6, -2};\n+  this->CheckUnary(\"binary_slice_bytes\", R\"([\"foods\"])\", this->type(), R\"([\"foo\"])\",\n+                   &options_edgecase_2);\n+\n+  auto input = ArrayFromJSON(this->type(), R\"([\"foods\"])\");\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid,\n+      testing::HasSubstr(\n+          \"Function 'binary_slice_bytes' cannot be called without options\"),\n+      CallFunction(\"binary_slice_bytes\", {input}));\n+\n+  SliceOptions options_invalid{2, 4, 0};\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid, testing::HasSubstr(\"Slice step cannot be zero\"),\n+      CallFunction(\"binary_slice_bytes\", {input}, &options_invalid));\n+}\n+\n+TYPED_TEST(TestBaseBinaryKernels, SliceBytesPosPos) {\n+  SliceOptions options{2, 4};\n+  this->CheckUnary(\"binary_slice_bytes\", R\"([\"\", \"f\", \"fo\", \"foo\", \"food\", \"foods\"])\",\n+                   this->type(), R\"([\"\", \"\", \"\", \"o\", \"od\", \"od\"])\", &options);\n+  SliceOptions options_step{1, 5, 2};\n+  this->CheckUnary(\"binary_slice_bytes\", R\"([\"\", \"f\", \"fo\", \"foo\", \"food\", \"foods\"])\",\n+                   this->type(), R\"([\"\", \"\", \"o\", \"o\", \"od\", \"od\"])\", &options_step);\n+  SliceOptions options_step_neg{5, 1, -2};\n+  this->CheckUnary(\"binary_slice_bytes\", R\"([\"\", \"f\", \"fo\", \"foo\", \"food\", \"foods\"])\",\n+                   this->type(), R\"([\"\", \"\", \"\", \"o\", \"d\", \"so\"])\", &options_step_neg);\n+  options_step_neg.stop = 0;\n+  this->CheckUnary(\"binary_slice_bytes\", R\"([\"\", \"f\", \"fo\", \"foo\", \"food\",\"foods\"])\",\n+                   this->type(), R\"([\"\", \"\", \"o\", \"o\", \"do\", \"so\"])\", &options_step_neg);\n+}\n+\n+TYPED_TEST(TestBaseBinaryKernels, SliceBytesPosNeg) {\n+  SliceOptions options{2, -1};\n+  this->CheckUnary(\"binary_slice_bytes\", R\"([\"\", \"f\", \"fo\", \"foo\", \"food\", \"foods\"])\",\n\nReview Comment:\n   These tests would be better without any letter repetition in the source values. Otherwise the results might end up correct even with an incorrect implementation.\n\n\n\n##########\nr/src/compute.cpp:\n##########\n@@ -449,7 +449,7 @@ std::shared_ptr<arrow::compute::FunctionOptions> make_compute_options(\n     return std::make_shared<Options>(cpp11::as_cpp<std::string>(options[\"characters\"]));\n   }\n \n-  if (func_name == \"utf8_slice_codeunits\") {\n+  if (func_name == \"utf8_slice_codeunits\" || func_name == \"binary_slice_bytes\") {\n\nReview Comment:\n   Should a test be created on the R side?\r\n   @thisisnic @paleolimbot Perhaps one of you can help.\n\n\n\n##########\npython/pyarrow/tests/test_compute.py:\n##########\n@@ -536,6 +537,24 @@ def test_slice_compatibility():\n                                                start, stop, step) == result\n \n \n+def test_binary_slice_compatibility():\n+    arr = pa.array((el.encode('ascii')\n+                   for el in [\"\", \"a\", \"ab\", \"abc\", \"abcd\", \"abcde\"]))\n\nReview Comment:\n   Can write this in more idiomatic way. Also, it's nicer with some non-ASCII data:\r\n   ```suggestion\r\n       arr = pa.array([b\"\", b\"a\", b\"a\\xff\", b\"a\\xffc\", b\"a\\xffcd\", b\"a\\xffcde\"])\r\n   ```\r\n   \n\n\n\n##########\ncpp/src/arrow/compute/kernels/scalar_string_ascii.cc:\n##########\n@@ -2409,6 +2409,172 @@ void AddAsciiStringReplaceSlice(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// ----------------------------------------------------------------------\n+// Slice\n+\n+namespace {\n+struct SliceBytesTransform : StringSliceTransformBase {\n+  int64_t MaxCodeunits(int64_t ninputs, int64_t input_bytes) override {\n+    const SliceOptions& opt = *this->options;\n+    if ((opt.start >= 0) != (opt.stop >= 0)) {\n+      // If start and stop don't have the same sign, we can't guess an upper bound\n+      // on the resulting slice lengths, so return a worst case estimate.\n+      return input_bytes;\n+    }\n+    int64_t max_slice_bytes = (opt.stop - opt.start + opt.step - 1) / opt.step;\n+    return std::min(input_bytes, ninputs * std::max<int64_t>(0, max_slice_bytes));\n+  }\n+\n+  int64_t Transform(const uint8_t* input, int64_t input_string_bytes, uint8_t* output) {\n+    if (options->step >= 1) {\n+      return SliceForward(input, input_string_bytes, output);\n+    }\n+    return SliceBackward(input, input_string_bytes, output);\n+  }\n+\n+  int64_t SliceForward(const uint8_t* input, int64_t input_string_bytes,\n+                       uint8_t* output) {\n+    // Slice in forward order (step > 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced;\n+    const uint8_t* end_sliced;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+    // First, compute begin_sliced and end_sliced\n+    if (opt.start >= 0) {\n+      // start counting from the left\n+      begin_sliced = std::min(begin + opt.start, end);\n+      if (opt.stop > opt.start) {\n+        // continue counting from begin_sliced\n+        const int64_t length = opt.stop - opt.start;\n+        end_sliced = std::min(begin_sliced + length, end);\n+      } else if (opt.stop < 0) {\n+        // from the end\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    } else {\n+      // start counting from the right\n+      begin_sliced = std::max(end + opt.start, begin);\n+      if (opt.stop > 0) {\n+        // continue counting from the left, we cannot start from begin_sliced because we\n+        // don't know how many bytes are between begin and begin_sliced\n+        end_sliced = std::min(begin + opt.stop, end);\n+        // and therefore we also needs this\n\nReview Comment:\n   ```suggestion\r\n           // and therefore we also need this\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/kernels/scalar_string_test.cc:\n##########\n@@ -2119,6 +2119,96 @@ TYPED_TEST(TestStringKernels, SliceCodeunitsNegPos) {\n \n #endif  // ARROW_WITH_UTF8PROC\n \n+TYPED_TEST(TestBaseBinaryKernels, SliceBytesBasic) {\n+  SliceOptions options{2, 4};\n+  this->CheckUnary(\"binary_slice_bytes\", R\"([\"foo\", \"fo\", null, \"foo \"])\", this->type(),\n+                   R\"([\"o\", \"\", null, \"o \"])\", &options);\n+\n+  // end is beyond 0, but before start (hence empty)\n+  SliceOptions options_edgecase_1{-3, 1};\n+  this->CheckUnary(\"binary_slice_bytes\", R\"([\"foods\"])\", this->type(), R\"([\"\"])\",\n+                   &options_edgecase_1);\n+\n+  // this is a safeguard agains an optimization path possible, but actually a tricky case\n+  SliceOptions options_edgecase_2{-6, -2};\n+  this->CheckUnary(\"binary_slice_bytes\", R\"([\"foods\"])\", this->type(), R\"([\"foo\"])\",\n+                   &options_edgecase_2);\n+\n+  auto input = ArrayFromJSON(this->type(), R\"([\"foods\"])\");\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid,\n+      testing::HasSubstr(\n+          \"Function 'binary_slice_bytes' cannot be called without options\"),\n+      CallFunction(\"binary_slice_bytes\", {input}));\n+\n+  SliceOptions options_invalid{2, 4, 0};\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid, testing::HasSubstr(\"Slice step cannot be zero\"),\n+      CallFunction(\"binary_slice_bytes\", {input}, &options_invalid));\n+}\n+\n+TYPED_TEST(TestBaseBinaryKernels, SliceBytesPosPos) {\n+  SliceOptions options{2, 4};\n+  this->CheckUnary(\"binary_slice_bytes\", R\"([\"\", \"f\", \"fo\", \"foo\", \"food\", \"foods\"])\",\n+                   this->type(), R\"([\"\", \"\", \"\", \"o\", \"od\", \"od\"])\", &options);\n+  SliceOptions options_step{1, 5, 2};\n+  this->CheckUnary(\"binary_slice_bytes\", R\"([\"\", \"f\", \"fo\", \"foo\", \"food\", \"foods\"])\",\n+                   this->type(), R\"([\"\", \"\", \"o\", \"o\", \"od\", \"od\"])\", &options_step);\n+  SliceOptions options_step_neg{5, 1, -2};\n+  this->CheckUnary(\"binary_slice_bytes\", R\"([\"\", \"f\", \"fo\", \"foo\", \"food\", \"foods\"])\",\n+                   this->type(), R\"([\"\", \"\", \"\", \"o\", \"d\", \"so\"])\", &options_step_neg);\n+  options_step_neg.stop = 0;\n+  this->CheckUnary(\"binary_slice_bytes\", R\"([\"\", \"f\", \"fo\", \"foo\", \"food\",\"foods\"])\",\n+                   this->type(), R\"([\"\", \"\", \"o\", \"o\", \"do\", \"so\"])\", &options_step_neg);\n+}\n+\n+TYPED_TEST(TestBaseBinaryKernels, SliceBytesPosNeg) {\n+  SliceOptions options{2, -1};\n+  this->CheckUnary(\"binary_slice_bytes\", R\"([\"\", \"f\", \"fo\", \"foo\", \"food\", \"foods\"])\",\n\nReview Comment:\n   Also, it would be nice to put some non-ASCII bytes in there as well, to check that slicing is really byte-wise.\n\n\n\n##########\ncpp/src/arrow/compute/kernels/scalar_string_ascii.cc:\n##########\n@@ -2409,6 +2409,172 @@ void AddAsciiStringReplaceSlice(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// ----------------------------------------------------------------------\n+// Slice\n+\n+namespace {\n+struct SliceBytesTransform : StringSliceTransformBase {\n+  int64_t MaxCodeunits(int64_t ninputs, int64_t input_bytes) override {\n+    const SliceOptions& opt = *this->options;\n+    if ((opt.start >= 0) != (opt.stop >= 0)) {\n+      // If start and stop don't have the same sign, we can't guess an upper bound\n+      // on the resulting slice lengths, so return a worst case estimate.\n+      return input_bytes;\n+    }\n+    int64_t max_slice_bytes = (opt.stop - opt.start + opt.step - 1) / opt.step;\n+    return std::min(input_bytes, ninputs * std::max<int64_t>(0, max_slice_bytes));\n+  }\n+\n+  int64_t Transform(const uint8_t* input, int64_t input_string_bytes, uint8_t* output) {\n+    if (options->step >= 1) {\n+      return SliceForward(input, input_string_bytes, output);\n+    }\n+    return SliceBackward(input, input_string_bytes, output);\n+  }\n+\n+  int64_t SliceForward(const uint8_t* input, int64_t input_string_bytes,\n+                       uint8_t* output) {\n+    // Slice in forward order (step > 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced;\n+    const uint8_t* end_sliced;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+    // First, compute begin_sliced and end_sliced\n+    if (opt.start >= 0) {\n+      // start counting from the left\n+      begin_sliced = std::min(begin + opt.start, end);\n+      if (opt.stop > opt.start) {\n+        // continue counting from begin_sliced\n+        const int64_t length = opt.stop - opt.start;\n+        end_sliced = std::min(begin_sliced + length, end);\n+      } else if (opt.stop < 0) {\n+        // from the end\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    } else {\n+      // start counting from the right\n+      begin_sliced = std::max(end + opt.start, begin);\n+      if (opt.stop > 0) {\n+        // continue counting from the left, we cannot start from begin_sliced because we\n+        // don't know how many bytes are between begin and begin_sliced\n+        end_sliced = std::min(begin + opt.stop, end);\n+        // and therefore we also needs this\n+        if (end_sliced <= begin_sliced) {\n+          // zero length slice\n+          return 0;\n+        }\n+      } else if ((opt.stop < 0) && (opt.stop > opt.start)) {\n+        // stop is negative, but larger than start, so we count again from the right\n+        // in some cases we can optimize this, depending on the shortest path (from end\n+        // or begin_sliced), but begin_sliced and opt.start can be 'out of sync',\n+        // for instance when start=-100, when the string length is only 10.\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    }\n+\n+    // Second, copy computed slice to output\n+    DCHECK(begin_sliced <= end_sliced);\n+    if (opt.step == 1) {\n+      // fast case, where we simply can finish with a memcpy\n+      std::copy(begin_sliced, end_sliced, output);\n+      return end_sliced - begin_sliced;\n+    }\n+\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+\n+    while (i < end_sliced) {\n+      *dest = *i;\n+      // skip step codeunits\n+      i += opt.step;\n+      dest++;\n+    }\n+    return dest - output;\n+  }\n+\n+  int64_t SliceBackward(const uint8_t* input, int64_t input_string_bytes,\n+                        uint8_t* output) {\n+    // Slice in reverse order (step < 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced = begin;\n+    const uint8_t* end_sliced = end;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+\n+    if (opt.start >= 0) {\n+      // +1 because begin_sliced acts as as the end of a reverse iterator\n+      begin_sliced = std::min(begin + opt.start + 1, end);\n+    } else {\n+      // -1 because start=-1 means the last byte, which is 0 advances\n+      begin_sliced = std::max(end + opt.start + 1, begin);\n+    }\n+    begin_sliced--;\n+\n+    // similar to opt.start\n+    if (opt.stop >= 0) {\n+      end_sliced = std::min(begin + opt.stop + 1, end);\n+    } else {\n+      end_sliced = std::max(end + opt.stop + 1, begin);\n+    }\n+    end_sliced--;\n+\n+    // Copy computed slice to output\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+    while (i > end_sliced) {\n+      // write a single codepoint\n+      *dest = *i;\n+      // and skip the remainder\n+      i += opt.step;\n+      dest++;\n+    }\n+\n+    return dest - output;\n+  }\n+};\n+\n+template <typename Type>\n+using SliceBytes = StringTransformExec<Type, SliceBytesTransform>;\n+\n+}  // namespace\n+\n+const FunctionDoc binary_slice_bytes_doc(\n+    \"Slice string\",\n+    (\"For each string in `strings`, emit the substring defined by\\n\"\n\nReview Comment:\n   ```suggestion\r\n       (\"For each binary string in `strings`, emit the substring defined by\\n\"\r\n   ```\n\n\n\n",
                    "created": "2022-11-10T16:37:56.952+0000",
                    "updated": "2022-11-10T16:37:56.952+0000",
                    "started": "2022-11-10T16:37:56.952+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824988",
                    "issueId": "13475027"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/824990",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kshitij12345 commented on PR #14550:\nURL: https://github.com/apache/arrow/pull/14550#issuecomment-1310599207\n\n   @pitrou Thanks for the review. Will address them over the weekend. \n\n\n",
                    "created": "2022-11-10T16:57:05.857+0000",
                    "updated": "2022-11-10T16:57:05.857+0000",
                    "started": "2022-11-10T16:57:05.857+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824990",
                    "issueId": "13475027"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/825484",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kshitij12345 commented on code in PR #14550:\nURL: https://github.com/apache/arrow/pull/14550#discussion_r1020725816\n\n\n##########\ncpp/src/arrow/compute/kernels/scalar_string_ascii.cc:\n##########\n@@ -2409,6 +2409,172 @@ void AddAsciiStringReplaceSlice(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// ----------------------------------------------------------------------\n+// Slice\n+\n+namespace {\n+struct SliceBytesTransform : StringSliceTransformBase {\n+  int64_t MaxCodeunits(int64_t ninputs, int64_t input_bytes) override {\n+    const SliceOptions& opt = *this->options;\n+    if ((opt.start >= 0) != (opt.stop >= 0)) {\n+      // If start and stop don't have the same sign, we can't guess an upper bound\n+      // on the resulting slice lengths, so return a worst case estimate.\n+      return input_bytes;\n+    }\n+    int64_t max_slice_bytes = (opt.stop - opt.start + opt.step - 1) / opt.step;\n+    return std::min(input_bytes, ninputs * std::max<int64_t>(0, max_slice_bytes));\n+  }\n+\n+  int64_t Transform(const uint8_t* input, int64_t input_string_bytes, uint8_t* output) {\n+    if (options->step >= 1) {\n+      return SliceForward(input, input_string_bytes, output);\n+    }\n+    return SliceBackward(input, input_string_bytes, output);\n+  }\n+\n+  int64_t SliceForward(const uint8_t* input, int64_t input_string_bytes,\n+                       uint8_t* output) {\n+    // Slice in forward order (step > 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced;\n+    const uint8_t* end_sliced;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+    // First, compute begin_sliced and end_sliced\n+    if (opt.start >= 0) {\n+      // start counting from the left\n+      begin_sliced = std::min(begin + opt.start, end);\n+      if (opt.stop > opt.start) {\n+        // continue counting from begin_sliced\n+        const int64_t length = opt.stop - opt.start;\n+        end_sliced = std::min(begin_sliced + length, end);\n+      } else if (opt.stop < 0) {\n+        // from the end\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    } else {\n+      // start counting from the right\n+      begin_sliced = std::max(end + opt.start, begin);\n+      if (opt.stop > 0) {\n+        // continue counting from the left, we cannot start from begin_sliced because we\n+        // don't know how many bytes are between begin and begin_sliced\n+        end_sliced = std::min(begin + opt.stop, end);\n+        // and therefore we also needs this\n+        if (end_sliced <= begin_sliced) {\n+          // zero length slice\n+          return 0;\n+        }\n+      } else if ((opt.stop < 0) && (opt.stop > opt.start)) {\n+        // stop is negative, but larger than start, so we count again from the right\n+        // in some cases we can optimize this, depending on the shortest path (from end\n+        // or begin_sliced), but begin_sliced and opt.start can be 'out of sync',\n+        // for instance when start=-100, when the string length is only 10.\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    }\n+\n+    // Second, copy computed slice to output\n+    DCHECK(begin_sliced <= end_sliced);\n+    if (opt.step == 1) {\n+      // fast case, where we simply can finish with a memcpy\n+      std::copy(begin_sliced, end_sliced, output);\n+      return end_sliced - begin_sliced;\n+    }\n+\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+\n+    while (i < end_sliced) {\n+      *dest = *i;\n+      // skip step codeunits\n+      i += opt.step;\n+      dest++;\n+    }\n+    return dest - output;\n+  }\n+\n+  int64_t SliceBackward(const uint8_t* input, int64_t input_string_bytes,\n+                        uint8_t* output) {\n+    // Slice in reverse order (step < 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced = begin;\n+    const uint8_t* end_sliced = end;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+\n+    if (opt.start >= 0) {\n+      // +1 because begin_sliced acts as as the end of a reverse iterator\n+      begin_sliced = std::min(begin + opt.start + 1, end);\n+    } else {\n+      // -1 because start=-1 means the last byte, which is 0 advances\n+      begin_sliced = std::max(end + opt.start + 1, begin);\n+    }\n+    begin_sliced--;\n+\n+    // similar to opt.start\n+    if (opt.stop >= 0) {\n+      end_sliced = std::min(begin + opt.stop + 1, end);\n+    } else {\n+      end_sliced = std::max(end + opt.stop + 1, begin);\n+    }\n+    end_sliced--;\n+\n+    // Copy computed slice to output\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+    while (i > end_sliced) {\n+      // write a single codepoint\n+      *dest = *i;\n+      // and skip the remainder\n+      i += opt.step;\n+      dest++;\n+    }\n+\n+    return dest - output;\n+  }\n+};\n+\n+template <typename Type>\n+using SliceBytes = StringTransformExec<Type, SliceBytesTransform>;\n+\n+}  // namespace\n+\n+const FunctionDoc binary_slice_bytes_doc(\n+    \"Slice string\",\n+    (\"For each string in `strings`, emit the substring defined by\\n\"\n+     \"(`start`, `stop`, `step`) as given by `SliceOptions` where `start` is\\n\"\n+     \"inclusive and `stop` is exclusive. All three values are measured in\\n\"\n+     \"bytes.\\n\"\n+     \"If `step` is negative, the string will be advanced in reversed order.\\n\"\n+     \"An error is raised if `step` is zero.\\n\"\n+     \"Null inputs emit null.\"),\n+    {\"strings\"}, \"SliceOptions\", /*options_required=*/true);\n+\n+void AddAsciiStringSlice(FunctionRegistry* registry) {\n+  auto func = std::make_shared<ScalarFunction>(\"binary_slice_bytes\", Arity::Unary(),\n+                                               binary_slice_bytes_doc);\n+  for (const auto& ty : BaseBinaryTypes()) {\n\nReview Comment:\n   I don't think Binary Slice should support UTF-8 strings as slicing them incorrectly will return invalid UTF-8 string\r\n   \r\n   Eg. `\\\"\\xc2\\xa2\\\"` slicing this [0:1] will return ``\\\"\\xc2\\\"` which is invalid UTF. \r\n   \r\n   I think this should just support Binary types. Wdyt @pitrou ?\r\n   \r\n   Thanks!\n\n\n\n",
                    "created": "2022-11-12T08:46:18.667+0000",
                    "updated": "2022-11-12T08:46:18.667+0000",
                    "started": "2022-11-12T08:46:18.667+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "825484",
                    "issueId": "13475027"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/825754",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #14550:\nURL: https://github.com/apache/arrow/pull/14550#discussion_r1021545816\n\n\n##########\ncpp/src/arrow/compute/kernels/scalar_string_ascii.cc:\n##########\n@@ -2409,6 +2409,172 @@ void AddAsciiStringReplaceSlice(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// ----------------------------------------------------------------------\n+// Slice\n+\n+namespace {\n+struct SliceBytesTransform : StringSliceTransformBase {\n+  int64_t MaxCodeunits(int64_t ninputs, int64_t input_bytes) override {\n+    const SliceOptions& opt = *this->options;\n+    if ((opt.start >= 0) != (opt.stop >= 0)) {\n+      // If start and stop don't have the same sign, we can't guess an upper bound\n+      // on the resulting slice lengths, so return a worst case estimate.\n+      return input_bytes;\n+    }\n+    int64_t max_slice_bytes = (opt.stop - opt.start + opt.step - 1) / opt.step;\n+    return std::min(input_bytes, ninputs * std::max<int64_t>(0, max_slice_bytes));\n+  }\n+\n+  int64_t Transform(const uint8_t* input, int64_t input_string_bytes, uint8_t* output) {\n+    if (options->step >= 1) {\n+      return SliceForward(input, input_string_bytes, output);\n+    }\n+    return SliceBackward(input, input_string_bytes, output);\n+  }\n+\n+  int64_t SliceForward(const uint8_t* input, int64_t input_string_bytes,\n+                       uint8_t* output) {\n+    // Slice in forward order (step > 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced;\n+    const uint8_t* end_sliced;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+    // First, compute begin_sliced and end_sliced\n+    if (opt.start >= 0) {\n+      // start counting from the left\n+      begin_sliced = std::min(begin + opt.start, end);\n+      if (opt.stop > opt.start) {\n+        // continue counting from begin_sliced\n+        const int64_t length = opt.stop - opt.start;\n+        end_sliced = std::min(begin_sliced + length, end);\n+      } else if (opt.stop < 0) {\n+        // from the end\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    } else {\n+      // start counting from the right\n+      begin_sliced = std::max(end + opt.start, begin);\n+      if (opt.stop > 0) {\n+        // continue counting from the left, we cannot start from begin_sliced because we\n+        // don't know how many bytes are between begin and begin_sliced\n+        end_sliced = std::min(begin + opt.stop, end);\n+        // and therefore we also needs this\n+        if (end_sliced <= begin_sliced) {\n+          // zero length slice\n+          return 0;\n+        }\n+      } else if ((opt.stop < 0) && (opt.stop > opt.start)) {\n+        // stop is negative, but larger than start, so we count again from the right\n+        // in some cases we can optimize this, depending on the shortest path (from end\n+        // or begin_sliced), but begin_sliced and opt.start can be 'out of sync',\n+        // for instance when start=-100, when the string length is only 10.\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    }\n+\n+    // Second, copy computed slice to output\n+    DCHECK(begin_sliced <= end_sliced);\n+    if (opt.step == 1) {\n+      // fast case, where we simply can finish with a memcpy\n+      std::copy(begin_sliced, end_sliced, output);\n+      return end_sliced - begin_sliced;\n+    }\n+\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+\n+    while (i < end_sliced) {\n+      *dest = *i;\n+      // skip step codeunits\n+      i += opt.step;\n+      dest++;\n+    }\n+    return dest - output;\n+  }\n+\n+  int64_t SliceBackward(const uint8_t* input, int64_t input_string_bytes,\n+                        uint8_t* output) {\n+    // Slice in reverse order (step < 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced = begin;\n+    const uint8_t* end_sliced = end;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+\n+    if (opt.start >= 0) {\n+      // +1 because begin_sliced acts as as the end of a reverse iterator\n+      begin_sliced = std::min(begin + opt.start + 1, end);\n+    } else {\n+      // -1 because start=-1 means the last byte, which is 0 advances\n+      begin_sliced = std::max(end + opt.start + 1, begin);\n+    }\n+    begin_sliced--;\n+\n+    // similar to opt.start\n+    if (opt.stop >= 0) {\n+      end_sliced = std::min(begin + opt.stop + 1, end);\n+    } else {\n+      end_sliced = std::max(end + opt.stop + 1, begin);\n+    }\n+    end_sliced--;\n+\n+    // Copy computed slice to output\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+    while (i > end_sliced) {\n+      // write a single codepoint\n+      *dest = *i;\n+      // and skip the remainder\n+      i += opt.step;\n+      dest++;\n+    }\n+\n+    return dest - output;\n+  }\n+};\n+\n+template <typename Type>\n+using SliceBytes = StringTransformExec<Type, SliceBytesTransform>;\n+\n+}  // namespace\n+\n+const FunctionDoc binary_slice_bytes_doc(\n+    \"Slice string\",\n+    (\"For each string in `strings`, emit the substring defined by\\n\"\n+     \"(`start`, `stop`, `step`) as given by `SliceOptions` where `start` is\\n\"\n+     \"inclusive and `stop` is exclusive. All three values are measured in\\n\"\n+     \"bytes.\\n\"\n+     \"If `step` is negative, the string will be advanced in reversed order.\\n\"\n+     \"An error is raised if `step` is zero.\\n\"\n+     \"Null inputs emit null.\"),\n+    {\"strings\"}, \"SliceOptions\", /*options_required=*/true);\n+\n+void AddAsciiStringSlice(FunctionRegistry* registry) {\n+  auto func = std::make_shared<ScalarFunction>(\"binary_slice_bytes\", Arity::Unary(),\n+                                               binary_slice_bytes_doc);\n+  for (const auto& ty : BaseBinaryTypes()) {\n\nReview Comment:\n   @kshitij12345 I agree with that.\r\n   \r\n   For the record, currently it's a bit of a mixed bag: `binary_reverse` doesn't support string input, but `binary_replace_slice` can... and can produce invalid output, for example:\r\n   ```python\r\n   >>> pc.binary_replace_slice([\"h\u00e9\"], 1, 2, \"x\")\r\n   <pyarrow.lib.StringArray object at 0x7fdbc09937c0>\r\n   [\r\n     \"hx\ufffd\"\r\n   ]\r\n   >>> pc.binary_replace_slice([\"h\u00e9\"], 1, 2, \"x\").validate(full=True)\r\n   Traceback (most recent call last):\r\n     ...\r\n   ArrowInvalid: Invalid UTF8 sequence at string index 0\r\n   ```\r\n   \n\n\n\n",
                    "created": "2022-11-14T13:30:26.664+0000",
                    "updated": "2022-11-14T13:30:26.664+0000",
                    "started": "2022-11-14T13:30:26.664+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "825754",
                    "issueId": "13475027"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/825755",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kshitij12345 commented on code in PR #14550:\nURL: https://github.com/apache/arrow/pull/14550#discussion_r1021548927\n\n\n##########\ncpp/src/arrow/compute/kernels/scalar_string_ascii.cc:\n##########\n@@ -2409,6 +2409,172 @@ void AddAsciiStringReplaceSlice(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// ----------------------------------------------------------------------\n+// Slice\n+\n+namespace {\n+struct SliceBytesTransform : StringSliceTransformBase {\n+  int64_t MaxCodeunits(int64_t ninputs, int64_t input_bytes) override {\n+    const SliceOptions& opt = *this->options;\n+    if ((opt.start >= 0) != (opt.stop >= 0)) {\n+      // If start and stop don't have the same sign, we can't guess an upper bound\n+      // on the resulting slice lengths, so return a worst case estimate.\n+      return input_bytes;\n+    }\n+    int64_t max_slice_bytes = (opt.stop - opt.start + opt.step - 1) / opt.step;\n+    return std::min(input_bytes, ninputs * std::max<int64_t>(0, max_slice_bytes));\n+  }\n+\n+  int64_t Transform(const uint8_t* input, int64_t input_string_bytes, uint8_t* output) {\n+    if (options->step >= 1) {\n+      return SliceForward(input, input_string_bytes, output);\n+    }\n+    return SliceBackward(input, input_string_bytes, output);\n+  }\n+\n+  int64_t SliceForward(const uint8_t* input, int64_t input_string_bytes,\n+                       uint8_t* output) {\n+    // Slice in forward order (step > 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced;\n+    const uint8_t* end_sliced;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+    // First, compute begin_sliced and end_sliced\n+    if (opt.start >= 0) {\n+      // start counting from the left\n+      begin_sliced = std::min(begin + opt.start, end);\n+      if (opt.stop > opt.start) {\n+        // continue counting from begin_sliced\n+        const int64_t length = opt.stop - opt.start;\n+        end_sliced = std::min(begin_sliced + length, end);\n+      } else if (opt.stop < 0) {\n+        // from the end\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    } else {\n+      // start counting from the right\n+      begin_sliced = std::max(end + opt.start, begin);\n+      if (opt.stop > 0) {\n+        // continue counting from the left, we cannot start from begin_sliced because we\n+        // don't know how many bytes are between begin and begin_sliced\n+        end_sliced = std::min(begin + opt.stop, end);\n+        // and therefore we also needs this\n+        if (end_sliced <= begin_sliced) {\n+          // zero length slice\n+          return 0;\n+        }\n+      } else if ((opt.stop < 0) && (opt.stop > opt.start)) {\n+        // stop is negative, but larger than start, so we count again from the right\n+        // in some cases we can optimize this, depending on the shortest path (from end\n+        // or begin_sliced), but begin_sliced and opt.start can be 'out of sync',\n+        // for instance when start=-100, when the string length is only 10.\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    }\n+\n+    // Second, copy computed slice to output\n+    DCHECK(begin_sliced <= end_sliced);\n+    if (opt.step == 1) {\n+      // fast case, where we simply can finish with a memcpy\n+      std::copy(begin_sliced, end_sliced, output);\n+      return end_sliced - begin_sliced;\n+    }\n+\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+\n+    while (i < end_sliced) {\n+      *dest = *i;\n+      // skip step codeunits\n+      i += opt.step;\n+      dest++;\n+    }\n+    return dest - output;\n+  }\n+\n+  int64_t SliceBackward(const uint8_t* input, int64_t input_string_bytes,\n+                        uint8_t* output) {\n+    // Slice in reverse order (step < 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced = begin;\n+    const uint8_t* end_sliced = end;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+\n+    if (opt.start >= 0) {\n+      // +1 because begin_sliced acts as as the end of a reverse iterator\n+      begin_sliced = std::min(begin + opt.start + 1, end);\n+    } else {\n+      // -1 because start=-1 means the last byte, which is 0 advances\n+      begin_sliced = std::max(end + opt.start + 1, begin);\n+    }\n+    begin_sliced--;\n+\n+    // similar to opt.start\n+    if (opt.stop >= 0) {\n+      end_sliced = std::min(begin + opt.stop + 1, end);\n+    } else {\n+      end_sliced = std::max(end + opt.stop + 1, begin);\n+    }\n+    end_sliced--;\n+\n+    // Copy computed slice to output\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+    while (i > end_sliced) {\n+      // write a single codepoint\n+      *dest = *i;\n+      // and skip the remainder\n+      i += opt.step;\n+      dest++;\n+    }\n+\n+    return dest - output;\n+  }\n+};\n+\n+template <typename Type>\n+using SliceBytes = StringTransformExec<Type, SliceBytesTransform>;\n+\n+}  // namespace\n+\n+const FunctionDoc binary_slice_bytes_doc(\n+    \"Slice string\",\n+    (\"For each string in `strings`, emit the substring defined by\\n\"\n+     \"(`start`, `stop`, `step`) as given by `SliceOptions` where `start` is\\n\"\n+     \"inclusive and `stop` is exclusive. All three values are measured in\\n\"\n+     \"bytes.\\n\"\n+     \"If `step` is negative, the string will be advanced in reversed order.\\n\"\n+     \"An error is raised if `step` is zero.\\n\"\n+     \"Null inputs emit null.\"),\n+    {\"strings\"}, \"SliceOptions\", /*options_required=*/true);\n+\n+void AddAsciiStringSlice(FunctionRegistry* registry) {\n+  auto func = std::make_shared<ScalarFunction>(\"binary_slice_bytes\", Arity::Unary(),\n+                                               binary_slice_bytes_doc);\n+  for (const auto& ty : BaseBinaryTypes()) {\n\nReview Comment:\n   Thanks! The updated code only works with `binary` types.\n\n\n\n",
                    "created": "2022-11-14T13:33:11.943+0000",
                    "updated": "2022-11-14T13:33:11.943+0000",
                    "started": "2022-11-14T13:33:11.943+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "825755",
                    "issueId": "13475027"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/825758",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kshitij12345 commented on code in PR #14550:\nURL: https://github.com/apache/arrow/pull/14550#discussion_r1021551561\n\n\n##########\ncpp/src/arrow/compute/kernels/scalar_string_ascii.cc:\n##########\n@@ -2409,6 +2409,172 @@ void AddAsciiStringReplaceSlice(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// ----------------------------------------------------------------------\n+// Slice\n+\n+namespace {\n+struct SliceBytesTransform : StringSliceTransformBase {\n+  int64_t MaxCodeunits(int64_t ninputs, int64_t input_bytes) override {\n+    const SliceOptions& opt = *this->options;\n+    if ((opt.start >= 0) != (opt.stop >= 0)) {\n+      // If start and stop don't have the same sign, we can't guess an upper bound\n+      // on the resulting slice lengths, so return a worst case estimate.\n+      return input_bytes;\n+    }\n+    int64_t max_slice_bytes = (opt.stop - opt.start + opt.step - 1) / opt.step;\n+    return std::min(input_bytes, ninputs * std::max<int64_t>(0, max_slice_bytes));\n+  }\n+\n+  int64_t Transform(const uint8_t* input, int64_t input_string_bytes, uint8_t* output) {\n+    if (options->step >= 1) {\n+      return SliceForward(input, input_string_bytes, output);\n+    }\n+    return SliceBackward(input, input_string_bytes, output);\n+  }\n+\n+  int64_t SliceForward(const uint8_t* input, int64_t input_string_bytes,\n+                       uint8_t* output) {\n+    // Slice in forward order (step > 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced;\n+    const uint8_t* end_sliced;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+    // First, compute begin_sliced and end_sliced\n+    if (opt.start >= 0) {\n+      // start counting from the left\n+      begin_sliced = std::min(begin + opt.start, end);\n+      if (opt.stop > opt.start) {\n+        // continue counting from begin_sliced\n+        const int64_t length = opt.stop - opt.start;\n+        end_sliced = std::min(begin_sliced + length, end);\n+      } else if (opt.stop < 0) {\n+        // from the end\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    } else {\n+      // start counting from the right\n+      begin_sliced = std::max(end + opt.start, begin);\n+      if (opt.stop > 0) {\n+        // continue counting from the left, we cannot start from begin_sliced because we\n+        // don't know how many bytes are between begin and begin_sliced\n+        end_sliced = std::min(begin + opt.stop, end);\n+        // and therefore we also needs this\n+        if (end_sliced <= begin_sliced) {\n+          // zero length slice\n+          return 0;\n+        }\n+      } else if ((opt.stop < 0) && (opt.stop > opt.start)) {\n+        // stop is negative, but larger than start, so we count again from the right\n+        // in some cases we can optimize this, depending on the shortest path (from end\n+        // or begin_sliced), but begin_sliced and opt.start can be 'out of sync',\n+        // for instance when start=-100, when the string length is only 10.\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    }\n+\n+    // Second, copy computed slice to output\n+    DCHECK(begin_sliced <= end_sliced);\n+    if (opt.step == 1) {\n+      // fast case, where we simply can finish with a memcpy\n+      std::copy(begin_sliced, end_sliced, output);\n+      return end_sliced - begin_sliced;\n+    }\n+\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+\n+    while (i < end_sliced) {\n+      *dest = *i;\n+      // skip step codeunits\n+      i += opt.step;\n+      dest++;\n+    }\n+    return dest - output;\n+  }\n+\n+  int64_t SliceBackward(const uint8_t* input, int64_t input_string_bytes,\n+                        uint8_t* output) {\n+    // Slice in reverse order (step < 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced = begin;\n+    const uint8_t* end_sliced = end;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+\n+    if (opt.start >= 0) {\n+      // +1 because begin_sliced acts as as the end of a reverse iterator\n+      begin_sliced = std::min(begin + opt.start + 1, end);\n+    } else {\n+      // -1 because start=-1 means the last byte, which is 0 advances\n+      begin_sliced = std::max(end + opt.start + 1, begin);\n+    }\n+    begin_sliced--;\n+\n+    // similar to opt.start\n+    if (opt.stop >= 0) {\n+      end_sliced = std::min(begin + opt.stop + 1, end);\n+    } else {\n+      end_sliced = std::max(end + opt.stop + 1, begin);\n+    }\n+    end_sliced--;\n+\n+    // Copy computed slice to output\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+    while (i > end_sliced) {\n+      // write a single codepoint\n+      *dest = *i;\n+      // and skip the remainder\n+      i += opt.step;\n+      dest++;\n+    }\n+\n+    return dest - output;\n+  }\n+};\n+\n+template <typename Type>\n+using SliceBytes = StringTransformExec<Type, SliceBytesTransform>;\n+\n+}  // namespace\n+\n+const FunctionDoc binary_slice_bytes_doc(\n+    \"Slice string\",\n+    (\"For each string in `strings`, emit the substring defined by\\n\"\n+     \"(`start`, `stop`, `step`) as given by `SliceOptions` where `start` is\\n\"\n+     \"inclusive and `stop` is exclusive. All three values are measured in\\n\"\n+     \"bytes.\\n\"\n+     \"If `step` is negative, the string will be advanced in reversed order.\\n\"\n+     \"An error is raised if `step` is zero.\\n\"\n+     \"Null inputs emit null.\"),\n+    {\"strings\"}, \"SliceOptions\", /*options_required=*/true);\n+\n+void AddAsciiStringSlice(FunctionRegistry* registry) {\n+  auto func = std::make_shared<ScalarFunction>(\"binary_slice_bytes\", Arity::Unary(),\n+                                               binary_slice_bytes_doc);\n+  for (const auto& ty : BaseBinaryTypes()) {\n\nReview Comment:\n   Also, I think `binary_replace_slice` should only work with `binary` types (as there is `utf8_replace_slice` for string types). And if user wants to actually play with byte data then they must manually cast it to that.\r\n   \r\n   Probably worth an issue?\n\n\n\n",
                    "created": "2022-11-14T13:35:33.079+0000",
                    "updated": "2022-11-14T13:35:33.079+0000",
                    "started": "2022-11-14T13:35:33.078+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "825758",
                    "issueId": "13475027"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/825759",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #14550:\nURL: https://github.com/apache/arrow/pull/14550#discussion_r1021552048\n\n\n##########\ncpp/src/arrow/compute/kernels/scalar_string_ascii.cc:\n##########\n@@ -2409,6 +2409,172 @@ void AddAsciiStringReplaceSlice(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// ----------------------------------------------------------------------\n+// Slice\n+\n+namespace {\n+struct SliceBytesTransform : StringSliceTransformBase {\n+  int64_t MaxCodeunits(int64_t ninputs, int64_t input_bytes) override {\n+    const SliceOptions& opt = *this->options;\n+    if ((opt.start >= 0) != (opt.stop >= 0)) {\n+      // If start and stop don't have the same sign, we can't guess an upper bound\n+      // on the resulting slice lengths, so return a worst case estimate.\n+      return input_bytes;\n+    }\n+    int64_t max_slice_bytes = (opt.stop - opt.start + opt.step - 1) / opt.step;\n+    return std::min(input_bytes, ninputs * std::max<int64_t>(0, max_slice_bytes));\n+  }\n+\n+  int64_t Transform(const uint8_t* input, int64_t input_string_bytes, uint8_t* output) {\n+    if (options->step >= 1) {\n+      return SliceForward(input, input_string_bytes, output);\n+    }\n+    return SliceBackward(input, input_string_bytes, output);\n+  }\n+\n+  int64_t SliceForward(const uint8_t* input, int64_t input_string_bytes,\n+                       uint8_t* output) {\n+    // Slice in forward order (step > 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced;\n+    const uint8_t* end_sliced;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+    // First, compute begin_sliced and end_sliced\n+    if (opt.start >= 0) {\n+      // start counting from the left\n+      begin_sliced = std::min(begin + opt.start, end);\n+      if (opt.stop > opt.start) {\n+        // continue counting from begin_sliced\n+        const int64_t length = opt.stop - opt.start;\n+        end_sliced = std::min(begin_sliced + length, end);\n+      } else if (opt.stop < 0) {\n+        // from the end\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    } else {\n+      // start counting from the right\n+      begin_sliced = std::max(end + opt.start, begin);\n+      if (opt.stop > 0) {\n+        // continue counting from the left, we cannot start from begin_sliced because we\n+        // don't know how many bytes are between begin and begin_sliced\n+        end_sliced = std::min(begin + opt.stop, end);\n+        // and therefore we also needs this\n+        if (end_sliced <= begin_sliced) {\n+          // zero length slice\n+          return 0;\n+        }\n+      } else if ((opt.stop < 0) && (opt.stop > opt.start)) {\n+        // stop is negative, but larger than start, so we count again from the right\n+        // in some cases we can optimize this, depending on the shortest path (from end\n+        // or begin_sliced), but begin_sliced and opt.start can be 'out of sync',\n+        // for instance when start=-100, when the string length is only 10.\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    }\n+\n+    // Second, copy computed slice to output\n+    DCHECK(begin_sliced <= end_sliced);\n+    if (opt.step == 1) {\n+      // fast case, where we simply can finish with a memcpy\n+      std::copy(begin_sliced, end_sliced, output);\n+      return end_sliced - begin_sliced;\n+    }\n+\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+\n+    while (i < end_sliced) {\n+      *dest = *i;\n+      // skip step codeunits\n+      i += opt.step;\n+      dest++;\n+    }\n+    return dest - output;\n+  }\n+\n+  int64_t SliceBackward(const uint8_t* input, int64_t input_string_bytes,\n+                        uint8_t* output) {\n+    // Slice in reverse order (step < 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced = begin;\n+    const uint8_t* end_sliced = end;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+\n+    if (opt.start >= 0) {\n+      // +1 because begin_sliced acts as as the end of a reverse iterator\n+      begin_sliced = std::min(begin + opt.start + 1, end);\n+    } else {\n+      // -1 because start=-1 means the last byte, which is 0 advances\n+      begin_sliced = std::max(end + opt.start + 1, begin);\n+    }\n+    begin_sliced--;\n+\n+    // similar to opt.start\n+    if (opt.stop >= 0) {\n+      end_sliced = std::min(begin + opt.stop + 1, end);\n+    } else {\n+      end_sliced = std::max(end + opt.stop + 1, begin);\n+    }\n+    end_sliced--;\n+\n+    // Copy computed slice to output\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+    while (i > end_sliced) {\n+      // write a single codepoint\n+      *dest = *i;\n+      // and skip the remainder\n+      i += opt.step;\n+      dest++;\n+    }\n+\n+    return dest - output;\n+  }\n+};\n+\n+template <typename Type>\n+using SliceBytes = StringTransformExec<Type, SliceBytesTransform>;\n+\n+}  // namespace\n+\n+const FunctionDoc binary_slice_bytes_doc(\n+    \"Slice string\",\n+    (\"For each string in `strings`, emit the substring defined by\\n\"\n+     \"(`start`, `stop`, `step`) as given by `SliceOptions` where `start` is\\n\"\n+     \"inclusive and `stop` is exclusive. All three values are measured in\\n\"\n+     \"bytes.\\n\"\n+     \"If `step` is negative, the string will be advanced in reversed order.\\n\"\n+     \"An error is raised if `step` is zero.\\n\"\n+     \"Null inputs emit null.\"),\n+    {\"strings\"}, \"SliceOptions\", /*options_required=*/true);\n+\n+void AddAsciiStringSlice(FunctionRegistry* registry) {\n+  auto func = std::make_shared<ScalarFunction>(\"binary_slice_bytes\", Arity::Unary(),\n+                                               binary_slice_bytes_doc);\n+  for (const auto& ty : BaseBinaryTypes()) {\n\nReview Comment:\n   Ok, please ping me when this is ready for review again.\n\n\n\n",
                    "created": "2022-11-14T13:36:02.247+0000",
                    "updated": "2022-11-14T13:36:02.247+0000",
                    "started": "2022-11-14T13:36:02.247+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "825759",
                    "issueId": "13475027"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/825760",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #14550:\nURL: https://github.com/apache/arrow/pull/14550#discussion_r1021552449\n\n\n##########\ncpp/src/arrow/compute/kernels/scalar_string_ascii.cc:\n##########\n@@ -2409,6 +2409,172 @@ void AddAsciiStringReplaceSlice(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// ----------------------------------------------------------------------\n+// Slice\n+\n+namespace {\n+struct SliceBytesTransform : StringSliceTransformBase {\n+  int64_t MaxCodeunits(int64_t ninputs, int64_t input_bytes) override {\n+    const SliceOptions& opt = *this->options;\n+    if ((opt.start >= 0) != (opt.stop >= 0)) {\n+      // If start and stop don't have the same sign, we can't guess an upper bound\n+      // on the resulting slice lengths, so return a worst case estimate.\n+      return input_bytes;\n+    }\n+    int64_t max_slice_bytes = (opt.stop - opt.start + opt.step - 1) / opt.step;\n+    return std::min(input_bytes, ninputs * std::max<int64_t>(0, max_slice_bytes));\n+  }\n+\n+  int64_t Transform(const uint8_t* input, int64_t input_string_bytes, uint8_t* output) {\n+    if (options->step >= 1) {\n+      return SliceForward(input, input_string_bytes, output);\n+    }\n+    return SliceBackward(input, input_string_bytes, output);\n+  }\n+\n+  int64_t SliceForward(const uint8_t* input, int64_t input_string_bytes,\n+                       uint8_t* output) {\n+    // Slice in forward order (step > 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced;\n+    const uint8_t* end_sliced;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+    // First, compute begin_sliced and end_sliced\n+    if (opt.start >= 0) {\n+      // start counting from the left\n+      begin_sliced = std::min(begin + opt.start, end);\n+      if (opt.stop > opt.start) {\n+        // continue counting from begin_sliced\n+        const int64_t length = opt.stop - opt.start;\n+        end_sliced = std::min(begin_sliced + length, end);\n+      } else if (opt.stop < 0) {\n+        // from the end\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    } else {\n+      // start counting from the right\n+      begin_sliced = std::max(end + opt.start, begin);\n+      if (opt.stop > 0) {\n+        // continue counting from the left, we cannot start from begin_sliced because we\n+        // don't know how many bytes are between begin and begin_sliced\n+        end_sliced = std::min(begin + opt.stop, end);\n+        // and therefore we also needs this\n+        if (end_sliced <= begin_sliced) {\n+          // zero length slice\n+          return 0;\n+        }\n+      } else if ((opt.stop < 0) && (opt.stop > opt.start)) {\n+        // stop is negative, but larger than start, so we count again from the right\n+        // in some cases we can optimize this, depending on the shortest path (from end\n+        // or begin_sliced), but begin_sliced and opt.start can be 'out of sync',\n+        // for instance when start=-100, when the string length is only 10.\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    }\n+\n+    // Second, copy computed slice to output\n+    DCHECK(begin_sliced <= end_sliced);\n+    if (opt.step == 1) {\n+      // fast case, where we simply can finish with a memcpy\n+      std::copy(begin_sliced, end_sliced, output);\n+      return end_sliced - begin_sliced;\n+    }\n+\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+\n+    while (i < end_sliced) {\n+      *dest = *i;\n+      // skip step codeunits\n+      i += opt.step;\n+      dest++;\n+    }\n+    return dest - output;\n+  }\n+\n+  int64_t SliceBackward(const uint8_t* input, int64_t input_string_bytes,\n+                        uint8_t* output) {\n+    // Slice in reverse order (step < 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced = begin;\n+    const uint8_t* end_sliced = end;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+\n+    if (opt.start >= 0) {\n+      // +1 because begin_sliced acts as as the end of a reverse iterator\n+      begin_sliced = std::min(begin + opt.start + 1, end);\n+    } else {\n+      // -1 because start=-1 means the last byte, which is 0 advances\n+      begin_sliced = std::max(end + opt.start + 1, begin);\n+    }\n+    begin_sliced--;\n+\n+    // similar to opt.start\n+    if (opt.stop >= 0) {\n+      end_sliced = std::min(begin + opt.stop + 1, end);\n+    } else {\n+      end_sliced = std::max(end + opt.stop + 1, begin);\n+    }\n+    end_sliced--;\n+\n+    // Copy computed slice to output\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+    while (i > end_sliced) {\n+      // write a single codepoint\n+      *dest = *i;\n+      // and skip the remainder\n+      i += opt.step;\n+      dest++;\n+    }\n+\n+    return dest - output;\n+  }\n+};\n+\n+template <typename Type>\n+using SliceBytes = StringTransformExec<Type, SliceBytesTransform>;\n+\n+}  // namespace\n+\n+const FunctionDoc binary_slice_bytes_doc(\n+    \"Slice string\",\n+    (\"For each string in `strings`, emit the substring defined by\\n\"\n+     \"(`start`, `stop`, `step`) as given by `SliceOptions` where `start` is\\n\"\n+     \"inclusive and `stop` is exclusive. All three values are measured in\\n\"\n+     \"bytes.\\n\"\n+     \"If `step` is negative, the string will be advanced in reversed order.\\n\"\n+     \"An error is raised if `step` is zero.\\n\"\n+     \"Null inputs emit null.\"),\n+    {\"strings\"}, \"SliceOptions\", /*options_required=*/true);\n+\n+void AddAsciiStringSlice(FunctionRegistry* registry) {\n+  auto func = std::make_shared<ScalarFunction>(\"binary_slice_bytes\", Arity::Unary(),\n+                                               binary_slice_bytes_doc);\n+  for (const auto& ty : BaseBinaryTypes()) {\n\nReview Comment:\n   Yes, I think you can open an issue about `binary_replace_slice`.\n\n\n\n",
                    "created": "2022-11-14T13:36:22.311+0000",
                    "updated": "2022-11-14T13:36:22.311+0000",
                    "started": "2022-11-14T13:36:22.311+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "825760",
                    "issueId": "13475027"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/825761",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kshitij12345 commented on code in PR #14550:\nURL: https://github.com/apache/arrow/pull/14550#discussion_r1021554672\n\n\n##########\ncpp/src/arrow/compute/kernels/scalar_string_ascii.cc:\n##########\n@@ -2409,6 +2409,172 @@ void AddAsciiStringReplaceSlice(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// ----------------------------------------------------------------------\n+// Slice\n+\n+namespace {\n+struct SliceBytesTransform : StringSliceTransformBase {\n+  int64_t MaxCodeunits(int64_t ninputs, int64_t input_bytes) override {\n+    const SliceOptions& opt = *this->options;\n+    if ((opt.start >= 0) != (opt.stop >= 0)) {\n+      // If start and stop don't have the same sign, we can't guess an upper bound\n+      // on the resulting slice lengths, so return a worst case estimate.\n+      return input_bytes;\n+    }\n+    int64_t max_slice_bytes = (opt.stop - opt.start + opt.step - 1) / opt.step;\n+    return std::min(input_bytes, ninputs * std::max<int64_t>(0, max_slice_bytes));\n+  }\n+\n+  int64_t Transform(const uint8_t* input, int64_t input_string_bytes, uint8_t* output) {\n+    if (options->step >= 1) {\n+      return SliceForward(input, input_string_bytes, output);\n+    }\n+    return SliceBackward(input, input_string_bytes, output);\n+  }\n+\n+  int64_t SliceForward(const uint8_t* input, int64_t input_string_bytes,\n+                       uint8_t* output) {\n+    // Slice in forward order (step > 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced;\n+    const uint8_t* end_sliced;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+    // First, compute begin_sliced and end_sliced\n+    if (opt.start >= 0) {\n+      // start counting from the left\n+      begin_sliced = std::min(begin + opt.start, end);\n+      if (opt.stop > opt.start) {\n+        // continue counting from begin_sliced\n+        const int64_t length = opt.stop - opt.start;\n+        end_sliced = std::min(begin_sliced + length, end);\n+      } else if (opt.stop < 0) {\n+        // from the end\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    } else {\n+      // start counting from the right\n+      begin_sliced = std::max(end + opt.start, begin);\n+      if (opt.stop > 0) {\n+        // continue counting from the left, we cannot start from begin_sliced because we\n+        // don't know how many bytes are between begin and begin_sliced\n+        end_sliced = std::min(begin + opt.stop, end);\n+        // and therefore we also needs this\n+        if (end_sliced <= begin_sliced) {\n+          // zero length slice\n+          return 0;\n+        }\n+      } else if ((opt.stop < 0) && (opt.stop > opt.start)) {\n+        // stop is negative, but larger than start, so we count again from the right\n+        // in some cases we can optimize this, depending on the shortest path (from end\n+        // or begin_sliced), but begin_sliced and opt.start can be 'out of sync',\n+        // for instance when start=-100, when the string length is only 10.\n+        end_sliced = std::max(end + opt.stop, begin_sliced);\n+      } else {\n+        // zero length slice\n+        return 0;\n+      }\n+    }\n+\n+    // Second, copy computed slice to output\n+    DCHECK(begin_sliced <= end_sliced);\n+    if (opt.step == 1) {\n+      // fast case, where we simply can finish with a memcpy\n+      std::copy(begin_sliced, end_sliced, output);\n+      return end_sliced - begin_sliced;\n+    }\n+\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+\n+    while (i < end_sliced) {\n+      *dest = *i;\n+      // skip step codeunits\n+      i += opt.step;\n+      dest++;\n+    }\n+    return dest - output;\n+  }\n+\n+  int64_t SliceBackward(const uint8_t* input, int64_t input_string_bytes,\n+                        uint8_t* output) {\n+    // Slice in reverse order (step < 0)\n+    const SliceOptions& opt = *this->options;\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_bytes;\n+    const uint8_t* begin_sliced = begin;\n+    const uint8_t* end_sliced = end;\n+\n+    if (!input_string_bytes) {\n+      return 0;\n+    }\n+\n+    if (opt.start >= 0) {\n+      // +1 because begin_sliced acts as as the end of a reverse iterator\n+      begin_sliced = std::min(begin + opt.start + 1, end);\n+    } else {\n+      // -1 because start=-1 means the last byte, which is 0 advances\n+      begin_sliced = std::max(end + opt.start + 1, begin);\n+    }\n+    begin_sliced--;\n+\n+    // similar to opt.start\n+    if (opt.stop >= 0) {\n+      end_sliced = std::min(begin + opt.stop + 1, end);\n+    } else {\n+      end_sliced = std::max(end + opt.stop + 1, begin);\n+    }\n+    end_sliced--;\n+\n+    // Copy computed slice to output\n+    uint8_t* dest = output;\n+    const uint8_t* i = begin_sliced;\n+    while (i > end_sliced) {\n+      // write a single codepoint\n+      *dest = *i;\n+      // and skip the remainder\n+      i += opt.step;\n+      dest++;\n+    }\n+\n+    return dest - output;\n+  }\n+};\n+\n+template <typename Type>\n+using SliceBytes = StringTransformExec<Type, SliceBytesTransform>;\n+\n+}  // namespace\n+\n+const FunctionDoc binary_slice_bytes_doc(\n+    \"Slice string\",\n+    (\"For each string in `strings`, emit the substring defined by\\n\"\n+     \"(`start`, `stop`, `step`) as given by `SliceOptions` where `start` is\\n\"\n+     \"inclusive and `stop` is exclusive. All three values are measured in\\n\"\n+     \"bytes.\\n\"\n+     \"If `step` is negative, the string will be advanced in reversed order.\\n\"\n+     \"An error is raised if `step` is zero.\\n\"\n+     \"Null inputs emit null.\"),\n+    {\"strings\"}, \"SliceOptions\", /*options_required=*/true);\n+\n+void AddAsciiStringSlice(FunctionRegistry* registry) {\n+  auto func = std::make_shared<ScalarFunction>(\"binary_slice_bytes\", Arity::Unary(),\n+                                               binary_slice_bytes_doc);\n+  for (const auto& ty : BaseBinaryTypes()) {\n\nReview Comment:\n   The PR is ready for review. Have updated the tests to include non-ascii characters and updated the function names.\r\n   \r\n   Except for `R` related testing comment, PR is ready. \r\n   \r\n   (Also will open an issue on JIRA soon)\r\n   \r\n   Thanks!\n\n\n\n",
                    "created": "2022-11-14T13:38:32.497+0000",
                    "updated": "2022-11-14T13:38:32.497+0000",
                    "started": "2022-11-14T13:38:32.497+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "825761",
                    "issueId": "13475027"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/825764",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #14550:\nURL: https://github.com/apache/arrow/pull/14550#discussion_r1021566058\n\n\n##########\nr/src/compute.cpp:\n##########\n@@ -449,7 +449,7 @@ std::shared_ptr<arrow::compute::FunctionOptions> make_compute_options(\n     return std::make_shared<Options>(cpp11::as_cpp<std::string>(options[\"characters\"]));\n   }\n \n-  if (func_name == \"utf8_slice_codeunits\") {\n+  if (func_name == \"utf8_slice_codeunits\" || func_name == \"binary_slice\") {\n\nReview Comment:\n   @rok @AlenkaF  Would one of you have to time to help @kshitij12345 write some R test here?\n\n\n\n",
                    "created": "2022-11-14T13:49:13.777+0000",
                    "updated": "2022-11-14T13:49:13.777+0000",
                    "started": "2022-11-14T13:49:13.776+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "825764",
                    "issueId": "13475027"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/825778",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on code in PR #14550:\nURL: https://github.com/apache/arrow/pull/14550#discussion_r1021630921\n\n\n##########\nr/src/compute.cpp:\n##########\n@@ -449,7 +449,7 @@ std::shared_ptr<arrow::compute::FunctionOptions> make_compute_options(\n     return std::make_shared<Options>(cpp11::as_cpp<std::string>(options[\"characters\"]));\n   }\n \n-  if (func_name == \"utf8_slice_codeunits\") {\n+  if (func_name == \"utf8_slice_codeunits\" || func_name == \"binary_slice\") {\n\nReview Comment:\n   Sorry I missed this ping on Thursday...I'm happy to do this but it's slightly easier to do on a separate PR.\n\n\n\n",
                    "created": "2022-11-14T14:45:48.922+0000",
                    "updated": "2022-11-14T14:45:48.922+0000",
                    "started": "2022-11-14T14:45:48.921+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "825778",
                    "issueId": "13475027"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/worklog/825794",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #14550:\nURL: https://github.com/apache/arrow/pull/14550#discussion_r1021663802\n\n\n##########\nr/src/compute.cpp:\n##########\n@@ -449,7 +449,7 @@ std::shared_ptr<arrow::compute::FunctionOptions> make_compute_options(\n     return std::make_shared<Options>(cpp11::as_cpp<std::string>(options[\"characters\"]));\n   }\n \n-  if (func_name == \"utf8_slice_codeunits\") {\n+  if (func_name == \"utf8_slice_codeunits\" || func_name == \"binary_slice\") {\n\nReview Comment:\n   It's ok for me if done on a separate PR.\n\n\n\n",
                    "created": "2022-11-14T15:12:36.974+0000",
                    "updated": "2022-11-14T15:12:36.974+0000",
                    "started": "2022-11-14T15:12:36.973+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "825794",
                    "issueId": "13475027"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 14400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@145c1bb4[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3cf8c6be[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4c12889[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7ef6c399[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@20ed59fe[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@706d81ef[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7d656a0b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@35479435[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7faf19ca[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@63d19d29[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3532866a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@3cdd5ac5[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 14400,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Nov 15 11:27:28 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": [
            "C++"
        ],
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-11-15T11:27:28.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17301/watchers",
            "watchCount": 5,
            "isWatching": false
        },
        "created": "2022-08-04T07:25:17.000+0000",
        "updated": "2022-11-15T17:23:07.000+0000",
        "timeoriginalestimate": null,
        "description": "In some situations, may\u00a0 request an access method to get binary or sting likes array one or some continuous bytes , for example start 1 end 3 step 1,\u00a0 the two bytes, it seems like \"{{{}binary_replace_slice{}}} \" function, provide byte and code two measurement unit\r\n\r\n\u00a0\r\n\r\n\u00a0\r\nh1. *application case:*\r\n\r\n\u00a0\r\nhere, I can give one example to descirbe why need a function to extract binary in byte unit:\r\n\u00a0\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 In distribute database, data has distribute policy and relatived hash algorithm for different data type, here we just discuss string-like and binary type, the hash algorithm need detach string-like or binary in bytes to calculating, for example , take 1-4 byte cast to integer and shift-left 16 bits, then take 5-6byte cast to integer and the result from last step, and so on, the\u00a0 'utf8_slice_codeunits' function can partly meet the require if all are ascii,\u00a0 but if the string-like contain chinese, one chinese may occupied three bytes,\u00a0 start 1 to end 3, three utf8 character\r\n\u00a0 may take nine bytes, but it not meet the hash algorithm, it only need 3 bytes, so if provide a function but not cast, the same\u00a0function arguments like 'utf8_slice_codeunits', it may called 'binary_slice_byteunit'",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 14400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Implement compute function \"binary_slice\"",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/comment/17575111",
                    "id": "17575111",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "So, the need is really for a slicing function on binary and string types.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2022-08-04T08:22:48.632+0000",
                    "updated": "2022-08-04T08:22:48.632+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/comment/17575113",
                    "id": "17575113",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "bq. In distribute database, data has distribute policy and relatived hash algorithm for different data type, here we just discuss string-like and binary type, the hash algorithm need detach string-like or binary in bytes to calculating, for example , take 1-4 byte cast to integer and shift-left 16 bits, then take 5-6byte cast to integer and the result from last step, and so on, the  'utf8_slice_codeunits' function can partly meet the require if all are ascii,  but if the string-like contain chinese, one chinese may occupied three bytes,  start 1 to end 3, three utf8 character\r\nbq. \r\n\r\nI'm not sure I understand what you're saying here, but if you need to compute the hash of some values, then it's certainly counter-productive to produce physical slices (copies) of the data. Just iterate on the data and produce the hash values directly.\r\n\r\nAlso cc [~lidavidm] who might have a better opinion.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2022-08-04T08:24:23.399+0000",
                    "updated": "2022-08-04T08:24:31.578+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/comment/17575260",
                    "id": "17575260",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Hmm, we don't have a {{binary_slice}}. But if we did, the way to do this would be to cast utf8 to binary, then slice - I don't think it makes sense to have a direct utf8->binary slice.\r\n\r\nHowever, I think the 'right' way to do this is to just implement the hash directly as Antoine suggests, instead of repeatedly calling a compute function to extract slices.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2022-08-04T13:10:29.975+0000",
                    "updated": "2022-08-04T13:10:29.975+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/comment/17575292",
                    "id": "17575292",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=edponce",
                        "name": "edponce",
                        "key": "edponce",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=edponce&avatarId=45496",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=edponce&avatarId=45496",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=edponce&avatarId=45496",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=edponce&avatarId=45496"
                        },
                        "displayName": "Eduardo Ponce",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Asides from the use case of using a {{binary_slice}} for a hash algorithm, I consider it is a reasonable compute function to add given that some string/binary functions come in multiple variants (ascii, utf8, binary). For example, currently there are related functions {{binary_replace_slice}} and {{utf8_replace_slice}} that support both the byte-oriented and encoded forms of data.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=edponce",
                        "name": "edponce",
                        "key": "edponce",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=edponce&avatarId=45496",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=edponce&avatarId=45496",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=edponce&avatarId=45496",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=edponce&avatarId=45496"
                        },
                        "displayName": "Eduardo Ponce",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2022-08-04T14:29:31.017+0000",
                    "updated": "2022-08-04T14:29:31.017+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/comment/17576387",
                    "id": "17576387",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=chenbaggio",
                        "name": "chenbaggio",
                        "key": "JIRAUSER293896",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ChenTsing",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Dear Antonie:\n                       Is there exist round-shift function provided by arrow lib, in the document only could find shift_left and shift right etc, out hash algorithm need the round\n shift, for example 10000000, shift-left one bit, then change into 00000001 and not 00000000, if the function has exits, please tell me, thank you! \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=chenbaggio",
                        "name": "chenbaggio",
                        "key": "JIRAUSER293896",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ChenTsing",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-08-07T13:51:00.022+0000",
                    "updated": "2022-08-07T13:51:00.022+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/comment/17576401",
                    "id": "17576401",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "[~chenbaggio] It would be much more efficient to implement your hash function yourself instead of combining compute functions (which will create intermediate copies).\r\n\r\nAlso, if a compute function is not listed, then it doesn't exist.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2022-08-07T15:03:56.635+0000",
                    "updated": "2022-08-07T15:03:56.635+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/comment/17576452",
                    "id": "17576452",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=chenbaggio",
                        "name": "chenbaggio",
                        "key": "JIRAUSER293896",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ChenTsing",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "[~edponce]\u00a0 how do you think about round -shift mentioned above",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=chenbaggio",
                        "name": "chenbaggio",
                        "key": "JIRAUSER293896",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ChenTsing",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-08-07T22:33:02.181+0000",
                    "updated": "2022-08-07T22:33:02.181+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/comment/17576583",
                    "id": "17576583",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "[~chenbaggio] Please, don't use this JIRA for off-topic questions. This is about \"binary_slice\". If you want to suggest another compute function, please open another JIRA.\r\n\r\nAlso, it's frustrating that you ask questions and then don't even read or acknowledge the responses being made.\r\n\r\nIf you continue I will have to delete your messages here.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2022-08-08T07:06:47.348+0000",
                    "updated": "2022-08-08T07:06:47.348+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/comment/17576983",
                    "id": "17576983",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=edponce",
                        "name": "edponce",
                        "key": "edponce",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=edponce&avatarId=45496",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=edponce&avatarId=45496",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=edponce&avatarId=45496",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=edponce&avatarId=45496"
                        },
                        "displayName": "Eduardo Ponce",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "I think a binary_slice function would be used solely with binary data, so no casting necessary (but up to the user). I do not consider worthwhile to take binary input and cast to UTF-8 and then slice, nor vice-versa.\r\n\r\nIf this is OK, then we can leave this ticket open.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=edponce",
                        "name": "edponce",
                        "key": "edponce",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=edponce&avatarId=45496",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=edponce&avatarId=45496",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=edponce&avatarId=45496",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=edponce&avatarId=45496"
                        },
                        "displayName": "Eduardo Ponce",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2022-08-08T21:01:06.258+0000",
                    "updated": "2022-08-08T21:01:06.258+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/comment/17626023",
                    "id": "17626023",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kshitij12345",
                        "name": "kshitij12345",
                        "key": "JIRAUSER289998",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Kshiteej K",
                        "active": true,
                        "timeZone": "Asia/Kolkata"
                    },
                    "body": "IIUC, the new function will be binary equivalent of existing `utf8_slice_codeunits` which takes `start`, `stop` and `step` and returns slices.\r\n\r\nIs my understanding correct?\r\n\r\nRef:\u00a0[https://arrow.apache.org/docs/cpp/compute.html#string-slicing]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kshitij12345",
                        "name": "kshitij12345",
                        "key": "JIRAUSER289998",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Kshiteej K",
                        "active": true,
                        "timeZone": "Asia/Kolkata"
                    },
                    "created": "2022-10-29T08:57:04.273+0000",
                    "updated": "2022-10-29T08:57:04.273+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/comment/17626030",
                    "id": "17626030",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=chenbaggio",
                        "name": "chenbaggio",
                        "key": "JIRAUSER293896",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ChenTsing",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "It is right and the step unit is byte\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=chenbaggio",
                        "name": "chenbaggio",
                        "key": "JIRAUSER293896",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ChenTsing",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-10-29T09:59:00.022+0000",
                    "updated": "2022-10-29T09:59:00.022+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/comment/17626082",
                    "id": "17626082",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kshitij12345",
                        "name": "kshitij12345",
                        "key": "JIRAUSER289998",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Kshiteej K",
                        "active": true,
                        "timeZone": "Asia/Kolkata"
                    },
                    "body": "[~chenbaggio]\u00a0Thanks for confirming!",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kshitij12345",
                        "name": "kshitij12345",
                        "key": "JIRAUSER289998",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Kshiteej K",
                        "active": true,
                        "timeZone": "Asia/Kolkata"
                    },
                    "created": "2022-10-29T16:32:33.540+0000",
                    "updated": "2022-10-29T16:32:33.540+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13475027/comment/17634317",
                    "id": "17634317",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 14550\n[https://github.com/apache/arrow/pull/14550]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2022-11-15T11:27:28.488+0000",
                    "updated": "2022-11-15T11:27:28.488+0000"
                }
            ],
            "maxResults": 13,
            "total": 13,
            "startAt": 0
        },
        "customfield_12311820": "0|z17gao:",
        "customfield_12314139": null
    }
}