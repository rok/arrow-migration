{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13099860",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860",
    "key": "ARROW-1463",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12341707",
                "id": "12341707",
                "description": "",
                "name": "0.9.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-03-19"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": null,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12514015",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12514015",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13047147",
                    "key": "ARROW-590",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13047147",
                    "fields": {
                        "summary": "[Integration] Add integration tests for Union types",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/1",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/blocker.svg",
                            "name": "Blocker",
                            "id": "1"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12514016",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12514016",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13056314",
                    "key": "ARROW-633",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13056314",
                    "fields": {
                        "summary": "[Java] Add support for FixedSizeBinary type",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=siddteotia",
            "name": "siddteotia",
            "key": "siddteotia",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=siddteotia&avatarId=32343",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=siddteotia&avatarId=32343",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=siddteotia&avatarId=32343",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=siddteotia&avatarId=32343"
            },
            "displayName": "Siddharth Teotia",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328933",
                "id": "12328933",
                "name": "Java"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": null,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
            "name": "jnadeau",
            "key": "jnadeau",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Jacques Nadeau",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [
            {
                "id": "13100184",
                "key": "ARROW-1471",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13100184",
                "fields": {
                    "summary": "[JAVA] Document requirements and non/requirements for ValueVector updates",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                        "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                        "name": "Resolved",
                        "id": "5",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                            "id": 3,
                            "key": "done",
                            "colorName": "green",
                            "name": "Done"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            },
            {
                "id": "13100185",
                "key": "ARROW-1472",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13100185",
                "fields": {
                    "summary": "[JAVA] Design updated ValueVector Object Hierarchy",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                        "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                        "name": "Resolved",
                        "id": "5",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                            "id": 3,
                            "key": "done",
                            "colorName": "green",
                            "name": "Done"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            },
            {
                "id": "13100186",
                "key": "ARROW-1473",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13100186",
                "fields": {
                    "summary": "[JAVA] Create Prototype Code Hierarchy (Implementation Phase 1)",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                        "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                        "name": "Resolved",
                        "id": "5",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                            "id": 3,
                            "key": "done",
                            "colorName": "green",
                            "name": "Done"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            },
            {
                "id": "13100187",
                "key": "ARROW-1474",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13100187",
                "fields": {
                    "summary": "[JAVA] ValueVector hierarchy (Implementation Phase 2)",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                        "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                        "name": "Resolved",
                        "id": "5",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                            "id": 3,
                            "key": "done",
                            "colorName": "green",
                            "name": "Done"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            },
            {
                "id": "13100188",
                "key": "ARROW-1475",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13100188",
                "fields": {
                    "summary": "[JAVA] Create Benchmarking Suite for prototypes",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                        "description": "The issue is open and ready for the assignee to start work on it.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                        "name": "Open",
                        "id": "1",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                            "id": 2,
                            "key": "new",
                            "colorName": "blue-gray",
                            "name": "To Do"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            },
            {
                "id": "13100189",
                "key": "ARROW-1476",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13100189",
                "fields": {
                    "summary": "[JAVA] Implement final ValueVector updates",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                        "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                        "name": "Resolved",
                        "id": "5",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                            "id": 3,
                            "key": "done",
                            "colorName": "green",
                            "name": "Done"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            },
            {
                "id": "13100190",
                "key": "ARROW-1477",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13100190",
                "fields": {
                    "summary": "[JAVA] Create Benchmarking Suite for final ValueVector updates",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                        "description": "The issue is open and ready for the assignee to start work on it.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                        "name": "Open",
                        "id": "1",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                            "id": 2,
                            "key": "new",
                            "colorName": "blue-gray",
                            "name": "To Do"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            },
            {
                "id": "13111269",
                "key": "ARROW-1710",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269",
                "fields": {
                    "summary": "[Java] Remove non-nullable vectors in new vector class hierarchy ",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                        "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                        "name": "Resolved",
                        "id": "5",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                            "id": 3,
                            "key": "done",
                            "colorName": "green",
                            "name": "Done"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            },
            {
                "id": "13111558",
                "key": "ARROW-1717",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13111558",
                "fields": {
                    "summary": "[Java] Remove public static helper method in vector classes for JSONReader/Writer",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                        "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                        "name": "Resolved",
                        "id": "5",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                            "id": 3,
                            "key": "done",
                            "colorName": "green",
                            "name": "Done"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            },
            {
                "id": "13111560",
                "key": "ARROW-1719",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13111560",
                "fields": {
                    "summary": "[Java] Remove accessor/mutator ",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                        "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                        "name": "Resolved",
                        "id": "5",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                            "id": 3,
                            "key": "done",
                            "colorName": "green",
                            "name": "Done"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            },
            {
                "id": "13116838",
                "key": "ARROW-1779",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13116838",
                "fields": {
                    "summary": "[Java] Integration test breaks without zeroing out validity vectors",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                        "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                        "name": "Resolved",
                        "id": "5",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                            "id": 3,
                            "key": "done",
                            "colorName": "green",
                            "name": "Done"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            },
            {
                "id": "13118602",
                "key": "ARROW-1815",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13118602",
                "fields": {
                    "summary": "[Java] Rename MapVector to StructVector",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                        "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                        "name": "Resolved",
                        "id": "5",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                            "id": 3,
                            "key": "done",
                            "colorName": "green",
                            "name": "Done"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            },
            {
                "id": "13118606",
                "key": "ARROW-1816",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13118606",
                "fields": {
                    "summary": "[Java] Resolve new vector classes structure for timestamp, date and maybe interval",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                        "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                        "name": "Closed",
                        "id": "6",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                            "id": 3,
                            "key": "done",
                            "colorName": "green",
                            "name": "Done"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            },
            {
                "id": "13118647",
                "key": "ARROW-1819",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13118647",
                "fields": {
                    "summary": "[Java] Remove legacy vector classes",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                        "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                        "name": "Resolved",
                        "id": "5",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                            "id": 3,
                            "key": "done",
                            "colorName": "green",
                            "name": "Done"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            },
            {
                "id": "13121385",
                "key": "ARROW-1866",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13121385",
                "fields": {
                    "summary": "[Java] Combine MapVector and NonNullableMapVector Classes",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                        "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                        "name": "Closed",
                        "id": "6",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                            "id": 3,
                            "key": "done",
                            "colorName": "green",
                            "name": "Done"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            },
            {
                "id": "13121388",
                "key": "ARROW-1867",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13121388",
                "fields": {
                    "summary": "[Java] Add BitVector APIs from old vector class",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                        "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                        "name": "Resolved",
                        "id": "5",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                            "id": 3,
                            "key": "done",
                            "colorName": "green",
                            "name": "Done"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            },
            {
                "id": "13121390",
                "key": "ARROW-1868",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13121390",
                "fields": {
                    "summary": "[Java] Change vector getMinorType to use MinorType instead of Types.MinorType",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                        "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                        "name": "Resolved",
                        "id": "5",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                            "id": 3,
                            "key": "done",
                            "colorName": "green",
                            "name": "Done"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            },
            {
                "id": "13122643",
                "key": "ARROW-1885",
                "self": "https://issues.apache.org/jira/rest/api/2/issue/13122643",
                "fields": {
                    "summary": "[Java] Restore previous MapVector class names",
                    "status": {
                        "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                        "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                        "name": "Resolved",
                        "id": "5",
                        "statusCategory": {
                            "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                            "id": 3,
                            "key": "done",
                            "colorName": "green",
                            "name": "Done"
                        }
                    },
                    "priority": {
                        "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                        "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                        "name": "Major",
                        "id": "3"
                    },
                    "issuetype": {
                        "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                        "id": "7",
                        "description": "The sub-task of the issue",
                        "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                        "name": "Sub-task",
                        "subtask": true,
                        "avatarId": 21146
                    }
                }
            }
        ],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
            "name": "jnadeau",
            "key": "jnadeau",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Jacques Nadeau",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1463/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 0,
            "worklogs": []
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": null,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@16f64ec4[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3e15b280[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@58ab7036[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@4b395811[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@31518fbe[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@31d6f7e0[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@327f1b2c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@338724a2[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@e966113[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@879eed6[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4295328e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@48bdac4a[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": null,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Apr 04 23:29:55 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-02-22T21:00:36.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1463/watchers",
            "watchCount": 11,
            "isWatching": false
        },
        "created": "2017-09-05T14:46:49.000+0000",
        "updated": "2018-07-08T14:24:41.000+0000",
        "timeoriginalestimate": null,
        "description": "The templates used in the java package are very high mainteance and the if conditions are hard to track. As started in the discussion here: https://github.com/apache/arrow/pull/1012, I'd like to propose that we modify the structure of the internal value vectors and code generation dynamics.\n\nCreate new abstract base vectors:\n\nBaseFixedVector\nBaseVariableVector\nBaseNullableVector\n\nFor each of these, implement all the basic functionality of a vector without using templating.\n\nEvaluate whether to use code generation to generate specific specializations of this functionality for each type where needed for performance purposes (probably constrained to mutator and accessor set/get methods). Giant and complex if conditions in the templates are actually worse from my perspective than a small amount of hand written duplicated code since templates are much harder to work with. ",
        "customfield_10010": null,
        "timetracking": {},
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[JAVA] Restructure ValueVector hierarchy to minimize compile-time generated code",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16153793",
                    "id": "16153793",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "+1, my outside perspective looking at patches that touch the templates is that it seems a recipe for brittleness that makes refactoring difficult. It would make the codebase easier for newcomers, too",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-09-05T15:05:41.048+0000",
                    "updated": "2017-09-05T15:05:41.048+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16153861",
                    "id": "16153861",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=icexelloss",
                        "name": "icexelloss",
                        "key": "icexelloss",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Li Jin",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "+1, the complexity of those templates is bothering me as well.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=icexelloss",
                        "name": "icexelloss",
                        "key": "icexelloss",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Li Jin",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-09-05T15:40:07.773+0000",
                    "updated": "2017-09-05T15:40:07.773+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16154471",
                    "id": "16154471",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
                        "name": "bryanc",
                        "key": "bryanc",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
                        },
                        "displayName": "Bryan Cutler",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "+1 on fixing this up also, however there are already quite a lot of base classes and interfaces.  [~jnadeau], following our other discussion from ARROW-1361, would it be possible to make {{FixedVector}} and {{VariableVector}} generic classes that take a ArrowType as type parameter and then specialize for types as needed?  {{NullableValueVectors}} could remain a template, possibly simplified, or use a base class as mentioned above.  I'm not entirely sure how feasible this is though..",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
                        "name": "bryanc",
                        "key": "bryanc",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
                        },
                        "displayName": "Bryan Cutler",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2017-09-05T22:20:41.956+0000",
                    "updated": "2017-09-05T22:20:41.956+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16154499",
                    "id": "16154499",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
                        "name": "jnadeau",
                        "key": "jnadeau",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Jacques Nadeau",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "It seems like there a milestone here that we should figure out.\n\n# Come up with a set of goals (we can use this jira to describe potential places for improvement)\n# Propose an object hierarchy (I think there may be a jira that Julien wrote that covers this.)\n# Prototype a couple vectors to evaluate against goals (I suggest having maybe two people do this in parallel to see what different ideas people come up).\n# Implement the updated vectors.\n\nI see [~siddteotia] assigned this to himself. I'd like to also make sure we have others involved in these subtasks and would like to break them out here. Other opinions on subtasks we should have? [~bryanc] and/or [~icexelloss] either of you interested in working on pieces of this? Definitely think it is overdue.\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
                        "name": "jnadeau",
                        "key": "jnadeau",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Jacques Nadeau",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2017-09-05T22:43:00.665+0000",
                    "updated": "2017-09-05T22:43:00.665+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16154502",
                    "id": "16154502",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
                        "name": "jnadeau",
                        "key": "jnadeau",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Jacques Nadeau",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Some initial thoughts on requirements:\n\n- Existing consumers should have minimal changes to continue to leverage the FieldVectors.\n- No performance loss on hot paths.\n- Minimize or remove use of code templates except where very simple/easy to maintain.\n- Rationalize object hiearchy\n- Continue to make engines that use code generation on top of vectors have predictable interfaces.\n- Better Javadocs on interfaces/base classes.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
                        "name": "jnadeau",
                        "key": "jnadeau",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Jacques Nadeau",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2017-09-05T22:44:45.909+0000",
                    "updated": "2017-09-05T22:44:45.909+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16154533",
                    "id": "16154533",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "I think [~alphalfalfa] may be interested in helping, since he has dug through the templates a couple of times for adding more logical types to the hierarchy. It'll be worthwhile to harden the object hierarchy before we accumulate a lot more downstream users and risk unpleasant disruption. Certainly this should take place before a 1.0.0 release. Feedback from other active users like [~elahrvivaz] will be helpful",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-09-05T23:09:01.989+0000",
                    "updated": "2017-09-05T23:09:01.989+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16154874",
                    "id": "16154874",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=gortizja",
                        "name": "gortizja",
                        "key": "gortizja",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Gonzalo Ortiz",
                        "active": true,
                        "timeZone": "Europe/Madrid"
                    },
                    "body": "+1\n\nI have found that the current hierarchy and heavily use of delegation makes implementations like IntVector very slow compared to ByteBuffer. I have some JMH benchmarks where I iterate on a buffer, reading the content as ints to accumulate them. When using ByteBuffer it takes 17us to execute an iteration. With IntVector.Accessor it gets 100 us!",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=gortizja",
                        "name": "gortizja",
                        "key": "gortizja",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Gonzalo Ortiz",
                        "active": true,
                        "timeZone": "Europe/Madrid"
                    },
                    "created": "2017-09-06T06:28:06.058+0000",
                    "updated": "2017-09-06T06:28:06.058+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16155303",
                    "id": "16155303",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=elahrvivaz",
                        "name": "elahrvivaz",
                        "key": "elahrvivaz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Emilio Lahr-Vivaz",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "+1 agree with everything said so far. I'd prefer not to have any code generation at all, unless it provides some performance gains.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=elahrvivaz",
                        "name": "elahrvivaz",
                        "key": "elahrvivaz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Emilio Lahr-Vivaz",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-09-06T13:10:19.478+0000",
                    "updated": "2017-09-06T13:10:19.478+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16155425",
                    "id": "16155425",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alphalfalfa",
                        "name": "alphalfalfa",
                        "key": "alphalfalfa",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Jingyuan Wang",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "I would certainly like to help. We should probably consider to add a benchmark suite to measure both the performance of assembling and retrieval of value vectors. ",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alphalfalfa",
                        "name": "alphalfalfa",
                        "key": "alphalfalfa",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Jingyuan Wang",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-09-06T14:21:27.970+0000",
                    "updated": "2017-09-06T14:21:27.970+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16155589",
                    "id": "16155589",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
                        "name": "jnadeau",
                        "key": "jnadeau",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Jacques Nadeau",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "I've created an initial list of subtasks. Who wants to work on what?\n\nthx",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
                        "name": "jnadeau",
                        "key": "jnadeau",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Jacques Nadeau",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2017-09-06T16:01:11.925+0000",
                    "updated": "2017-09-06T16:01:11.925+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16155611",
                    "id": "16155611",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=icexelloss",
                        "name": "icexelloss",
                        "key": "icexelloss",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Li Jin",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "[~jacques@dremio.com] Thank much for putting this together. I will be out next week so I will avoid being on any critical path. But I'd like to check status and see what I can help when I get back.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=icexelloss",
                        "name": "icexelloss",
                        "key": "icexelloss",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Li Jin",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-09-06T16:23:23.678+0000",
                    "updated": "2017-09-06T16:23:23.678+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16155685",
                    "id": "16155685",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "This might be a good opportunity to remove non-nullable container types. Nullability in C++ is a property of the metadata only, and computationally non-null arrays and nullable arrays with 0 null count are semantically equal. It would make the code simpler to maintain",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-09-06T17:01:30.351+0000",
                    "updated": "2017-09-06T17:01:30.351+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16156598",
                    "id": "16156598",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=gortizja",
                        "name": "gortizja",
                        "key": "gortizja",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Gonzalo Ortiz",
                        "active": true,
                        "timeZone": "Europe/Madrid"
                    },
                    "body": "On the one hand, what [~wesmckinn] is right. They could be the same structure. On the other, they are not exactly semantically equal. Non nullable structures doesn't return nulls, which can be used by some static checkers or languages like Kotlin. \n\nThere are also two performance issues, one on each model. They are just a theoretical reasoning (that may be wrong!), we would need to verify that some JMH test (and it can change from one JVM to another):\n* A structure that doesn't need to check the nullable array would have shorter and simpler methods (without branches) and therefore it is more probable that the JVM can optimize that. So this is a point on having two implementations: one with nulls and one without them.\n* If there are two structures (a nullable and a non nullable) and the nullable is just a decoration/delegation on the non-nullable, nullable structures may behave quite worst than we expect for the same reason. As soon as the methods get complex (calling the delegate class) the JVM may or may not optimize them.\n\nTL;RD: From the library developer perspective, I would like to have only one implementation. From a user perspective, I would like to have both implementations, ideally without delegation (which means repeated code on nullable-structure)",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=gortizja",
                        "name": "gortizja",
                        "key": "gortizja",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Gonzalo Ortiz",
                        "active": true,
                        "timeZone": "Europe/Madrid"
                    },
                    "created": "2017-09-07T07:13:55.630+0000",
                    "updated": "2017-09-07T07:13:55.630+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16156928",
                    "id": "16156928",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "[~gortizja] this is probably a discussion for a whole separate JIRA. A couple points:\n\n> Non nullable structures doesn't return nulls, which can be used by some static checkers or languages like Kotlin.\n\nThis is true, hypothetically, but I question whether this benefit can only be reaped by doubling the size of the type hierarchy. In the instances where you can choose an optimized code path for non-null data, you could elect to invoke that same code path when the null count is zero (which you will want to do regardless of the nullability). This is sort of a \"composition over inheritance\" argument -- it's not to say that we can have some helper interfaces that specialize based on metadata, but as a property of the type hierarchy I am not sure if it's worth the increased code size. \n\n> So this is a point on having two implementations: one with nulls and one without them.\n\nSince you can branch at the vector level, the performance implications are less obvious (benchmarks could help settle it). Somewhere you must dynamic dispatch to the correct kernel function for some analytical operation, and the dispatch could be based on null count. \n\n> [if] the nullable is just a decoration/delegation on the non-nullable, nullable structures may behave quite worst than we expect for the same reason\n\nThe performance issues you cite would appear mostly in non-vectorized code. If you're doing something performance sensitive, you're more likely to be working directly with the buffers, and selecting kernel functions based on the dynamic metadata (which can include nullability / null count). So if you implement Sum, you will want to have a sum with nulls and a sum without. Somewhere you have to decide which one to call. You will want to elect to call the SumWithoutNulls when you have a nullable vector but with zero null count anyway, so this actually makes your kernel dispatch more complex. ",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-09-07T13:05:36.268+0000",
                    "updated": "2017-09-07T13:05:36.268+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16156968",
                    "id": "16156968",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=gortizja",
                        "name": "gortizja",
                        "key": "gortizja",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Gonzalo Ortiz",
                        "active": true,
                        "timeZone": "Europe/Madrid"
                    },
                    "body": "From a Java developer perspective, I can only implement a SumWithIntVector and prey to the JIT lord, hoping that the JVM discovers it can use vectorization... and JVM 8 it is not very good at it. But you are right. This sounds a little bit offtopic.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=gortizja",
                        "name": "gortizja",
                        "key": "gortizja",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Gonzalo Ortiz",
                        "active": true,
                        "timeZone": "Europe/Madrid"
                    },
                    "created": "2017-09-07T13:48:21.974+0000",
                    "updated": "2017-09-07T13:48:21.974+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16157046",
                    "id": "16157046",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
                        "name": "jnadeau",
                        "key": "jnadeau",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Jacques Nadeau",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "There have been cases where we have found the existence of non-nullable vectors useful when doing decomposed calculations. For example, it makes things easier to manage if we want to do a tree assuming no nulls and then use a word intersection pattern to implement SQL's null output if any input is null semantic. This could be done without the separate classes but is probably easier with them. On the flipside, if we push to a fractured subclasses model for vectors, I think it is necessary to avoid composite vectors since that would make address management and allocation fairly challenging.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
                        "name": "jnadeau",
                        "key": "jnadeau",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Jacques Nadeau",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2017-09-07T14:59:22.927+0000",
                    "updated": "2017-09-07T14:59:22.927+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16162231",
                    "id": "16162231",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
                        "name": "bryanc",
                        "key": "bryanc",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
                        },
                        "displayName": "Bryan Cutler",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "I just have a couple of questions regarding these changes, apologies if these have been answered previously\n\n1) Are there any guidelines as far as doing public API breaking changes?  Should things be deprecated or is this something that is a little more open until Arrow 1.0 is released?\n\n2) How exactly does performance play into the class hierarchies or code gen?  Is it to make sure the data can be vectorized or are there more things to consider?  I just would like to make sure I know what not to do from a performance standpoint.  Is this something that would be described in the document in ARROW-1471?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
                        "name": "bryanc",
                        "key": "bryanc",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
                        },
                        "displayName": "Bryan Cutler",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2017-09-11T23:30:20.677+0000",
                    "updated": "2017-09-11T23:30:20.677+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16162361",
                    "id": "16162361",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "API stability is not guaranteed at the moment. We have been trying to deprecate things gracefully in C++. Since development efforts in Java have been fairly limited since the Arrow project started I think we need to gather a critical mass of active Java developers before declaring API stability.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-09-12T01:56:49.281+0000",
                    "updated": "2017-09-12T01:56:59.084+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16166899",
                    "id": "16166899",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
                        "name": "bryanc",
                        "key": "bryanc",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
                        },
                        "displayName": "Bryan Cutler",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "That sounds fine to me in regards to API stability, thanks [~wesmckinn].",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
                        "name": "bryanc",
                        "key": "bryanc",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
                        },
                        "displayName": "Bryan Cutler",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2017-09-14T20:00:46.656+0000",
                    "updated": "2017-09-14T20:01:13.949+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16177237",
                    "id": "16177237",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=laurent",
                        "name": "laurent",
                        "key": "laurentgo",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=laurentgo&avatarId=18552",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=laurentgo&avatarId=18552",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=laurentgo&avatarId=18552",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=laurentgo&avatarId=18552"
                        },
                        "displayName": "Laurent Goujon",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "There's a Java effort to come up with a vector API to help with vectorization (as part of the Panama project). May be worth having a look at it.\n\nThe latest version (by John Rose) is available at http://cr.openjdk.java.net/~jrose/arrays/vector/Vector.java\nThere are also some slides from Intel folks giving some insights about it might help vectorization inside the JVM: www.oracle.com/technetwork/java/jvmls2016-graves-3125549.pptx",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=laurent",
                        "name": "laurent",
                        "key": "laurentgo",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=laurentgo&avatarId=18552",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=laurentgo&avatarId=18552",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=laurentgo&avatarId=18552",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=laurentgo&avatarId=18552"
                        },
                        "displayName": "Laurent Goujon",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2017-09-22T22:06:19.900+0000",
                    "updated": "2017-09-22T22:06:19.900+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16178694",
                    "id": "16178694",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=gortizja",
                        "name": "gortizja",
                        "key": "gortizja",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Gonzalo Ortiz",
                        "active": true,
                        "timeZone": "Europe/Madrid"
                    },
                    "body": "[~laurentgo] is great to have that in mind. I'm really interested in how to be sure that operations on Arrow Vectors are, indeed, vectorized at CPU level and once Panama is released, we will be able to control that. But AFAIK they don't have a clear API (yet) that Arrow can try to get close to. They just have a proposal that it is very likely to change.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=gortizja",
                        "name": "gortizja",
                        "key": "gortizja",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Gonzalo Ortiz",
                        "active": true,
                        "timeZone": "Europe/Madrid"
                    },
                    "created": "2017-09-25T08:00:38.876+0000",
                    "updated": "2017-09-25T08:00:38.876+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16250857",
                    "id": "16250857",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia closed pull request #1164: ARROW-1463: [JAVA - WIP] refactoring\nURL: https://github.com/apache/arrow/pull/1164\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/java/vector/src/main/codegen/templates/ComplexReaders.java b/java/vector/src/main/codegen/templates/ComplexReaders.java\nindex 38cd1bfde..791064905 100644\n--- a/java/vector/src/main/codegen/templates/ComplexReaders.java\n+++ b/java/vector/src/main/codegen/templates/ComplexReaders.java\n@@ -70,7 +70,11 @@ public Field getField(){\n   \n   public boolean isSet(){\n     <#if nullMode == \"Nullable\">\n-    return !vector.getAccessor().isNull(idx());\n+      <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n+        return !vector.getAccessor().isNull(idx());\n+      <#else>\n+        return !vector.isNull(idx());\n+      </#if>\n     <#else>\n     return true;\n     </#if>\n@@ -93,11 +97,19 @@ public void read(${minor.class?cap_first}Holder h){\n   </#if>\n \n   public void read(Nullable${minor.class?cap_first}Holder h){\n-    vector.getAccessor().get(idx(), h);\n+    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n+      vector.getAccessor().get(idx(), h);\n+    <#else>\n+      vector.get(idx(), h);\n+    </#if>\n   }\n   \n   public ${friendlyType} read${safeType}(){\n-    return vector.getAccessor().getObject(idx());\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+      return vector.getObject(idx());\n+    <#else>\n+      return vector.getAccessor().getObject(idx());\n+    </#if>\n   }\n \n   <#if minor.class == \"TimeStampSec\" ||\n@@ -115,7 +127,11 @@ public void copyValue(FieldWriter w){\n   }\n   \n   public Object readObject(){\n-    return vector.getAccessor().getObject(idx());\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+      return (Object)vector.getObject(idx());\n+    <#else>\n+      return vector.getAccessor().getObject(idx());\n+    </#if>\n   }\n }\n </#if>\ndiff --git a/java/vector/src/main/codegen/templates/ComplexWriters.java b/java/vector/src/main/codegen/templates/ComplexWriters.java\nindex fe099bede..77f6594a0 100644\n--- a/java/vector/src/main/codegen/templates/ComplexWriters.java\n+++ b/java/vector/src/main/codegen/templates/ComplexWriters.java\n@@ -39,11 +39,16 @@\n @SuppressWarnings(\"unused\")\n public class ${eName}WriterImpl extends AbstractFieldWriter {\n \n-  private final Nullable${name}Vector.Mutator mutator;\n+  <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n+    private final Nullable${name}Vector.Mutator mutator;\n+  </#if>\n+\n   final Nullable${name}Vector vector;\n \n   public ${eName}WriterImpl(Nullable${name}Vector vector) {\n-    this.mutator = vector.getMutator();\n+    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n+      this.mutator = vector.getMutator();\n+    </#if>\n     this.vector = vector;\n   }\n \n@@ -103,18 +108,33 @@ public void setPosition(int idx) {\n   <#else>\n \n   public void write(${minor.class}Holder h) {\n-    mutator.setSafe(idx(), h);\n-    vector.getMutator().setValueCount(idx()+1);\n+    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n+      mutator.setSafe(idx(), h);\n+      vector.getMutator().setValueCount(idx()+1);\n+    <#else>\n+        vector.setSafe(idx(), h);\n+        vector.setValueCount(idx()+1);\n+    </#if>\n   }\n \n   public void write(Nullable${minor.class}Holder h) {\n-    mutator.setSafe(idx(), h);\n-    vector.getMutator().setValueCount(idx()+1);\n+    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n+      mutator.setSafe(idx(), h);\n+      vector.getMutator().setValueCount(idx()+1);\n+    <#else>\n+      vector.setSafe(idx(), h);\n+      vector.setValueCount(idx()+1);\n+    </#if>\n   }\n \n   public void write${minor.class}(<#list fields as field>${field.type} ${field.name}<#if field_has_next>, </#if></#list>) {\n-    mutator.setSafe(idx()<#if mode == \"Nullable\">, 1</#if><#list fields as field><#if field.include!true >, ${field.name}</#if></#list>);\n-    vector.getMutator().setValueCount(idx()+1);\n+    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n+      mutator.setSafe(idx()<#if mode == \"Nullable\">, 1</#if><#list fields as field><#if field.include!true >, ${field.name}</#if></#list>);\n+      vector.getMutator().setValueCount(idx()+1);\n+    <#else>\n+      vector.setSafe(idx()<#if mode == \"Nullable\">, 1</#if><#list fields as field><#if field.include!true >, ${field.name}</#if></#list>);\n+      vector.setValueCount(idx()+1);\n+    </#if>\n   }\n   <#if minor.class == \"Decimal\">\n \n@@ -126,8 +146,13 @@ public void write(Nullable${minor.class}Holder h) {\n   <#if mode == \"Nullable\">\n \n   public void writeNull() {\n-    mutator.setNull(idx());\n-    vector.getMutator().setValueCount(idx()+1);\n+    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n+        mutator.setNull(idx());\n+        vector.getMutator().setValueCount(idx()+1);\n+    <#else>\n+        vector.setNull(idx());\n+        vector.setValueCount(idx()+1);\n+    </#if>\n   }\n   </#if>\n   </#if>\ndiff --git a/java/vector/src/main/codegen/templates/NullableValueVectors.java b/java/vector/src/main/codegen/templates/NullableValueVectors.java\nindex 122cd2364..5d1f5a33b 100644\n--- a/java/vector/src/main/codegen/templates/NullableValueVectors.java\n+++ b/java/vector/src/main/codegen/templates/NullableValueVectors.java\n@@ -19,8 +19,14 @@\n <#list vv.types as type>\n <#list type.minor as minor>\n \n+<#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+<#assign className = \"LegacyNullable${minor.class}Vector\" />\n+<#assign valuesName = \"Nullable${minor.class}Vector\" />\n+<#else>\n <#assign className = \"Nullable${minor.class}Vector\" />\n <#assign valuesName = \"${minor.class}Vector\" />\n+</#if>\n+\n <#assign friendlyType = (minor.friendlyType!minor.boxedType!type.boxedType) />\n \n <@pp.changeOutputFile name=\"/org/apache/arrow/vector/${className}.java\" />\n@@ -44,15 +50,24 @@\n  * NB: this class is automatically generated from ${.template_name} and ValueVectorTypes.tdd using FreeMarker.\n  */\n @SuppressWarnings(\"unused\")\n-public final class ${className} extends BaseValueVector implements <#if type.major == \"VarLen\">VariableWidth<#else>FixedWidth</#if>Vector, NullableVector, FieldVector {\n+<#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+@Deprecated\n+</#if>\n+public final class ${className} extends BaseValueVector implements <#if type.major == \"VarLen\">VariableWidth<#else>FixedWidth</#if>Vector, FieldVector {\n   private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(${className}.class);\n \n protected final static byte[] emptyByteArray = new byte[]{};\n+\n+  <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n   private final FieldReader reader = new ${minor.class}ReaderImpl(${className}.this);\n+  </#if>\n \n   private final String bitsField = \"$bits$\";\n   private final String valuesField = \"$values$\";\n+\n+  <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n   private final Field field;\n+  </#if>\n \n   final BitVector bits = new BitVector(bitsField, allocator);\n   final ${valuesName} values;\n@@ -60,7 +75,9 @@\n   private final Mutator mutator;\n   private final Accessor accessor;\n \n+  <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n   private final List<BufferBacked> innerVectors;\n+  </#if>\n \n   <#if minor.typeParams??>\n     <#assign typeParams = minor.typeParams?reverse>\n@@ -105,6 +122,7 @@\n     </#if>\n     this.mutator = new Mutator();\n     this.accessor = new Accessor();\n+    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n     this.field = new Field(name, fieldType, null);\n     innerVectors = Collections.unmodifiableList(Arrays.<BufferBacked>asList(\n         bits,\n@@ -113,16 +131,24 @@\n         </#if>\n         values\n     ));\n+    </#if>\n   }\n \n-  @Override\n+  <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n+  /* not needed for new vectors */\n   public BitVector getValidityVector() {\n     return bits;\n   }\n+  </#if>\n \n   @Override\n   public List<BufferBacked> getFieldInnerVectors() {\n-    return innerVectors;\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.getFieldInnerVectors();\n+    <#else>\n+        return innerVectors;\n+    </#if>\n   }\n \n   @Override\n@@ -139,6 +165,10 @@ public void initializeChildrenFromFields(List<Field> children) {\n \n   @Override\n   public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        values.loadFieldBuffers(fieldNode, ownBuffers);\n+    <#else>\n     <#if type.major = \"VarLen\">\n     // variable width values: truncate offset vector buffer to size (#1)\n     org.apache.arrow.vector.BaseDataValueVector.truncateBufferBasedOnSize(ownBuffers, 1,\n@@ -151,34 +181,64 @@ public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers\n     </#if>\n     org.apache.arrow.vector.BaseDataValueVector.load(fieldNode, getFieldInnerVectors(), ownBuffers);\n     bits.valueCount = fieldNode.getLength();\n+    </#if>\n   }\n \n   public List<ArrowBuf> getFieldBuffers() {\n-    return org.apache.arrow.vector.BaseDataValueVector.unload(getFieldInnerVectors());\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.getFieldBuffers();\n+    <#else>\n+        return org.apache.arrow.vector.BaseDataValueVector.unload(getFieldInnerVectors());\n+    </#if>\n   }\n \n   @Override\n   public Field getField() {\n-    return field;\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.getField();\n+    <#else>\n+      return field;\n+    </#if>\n   }\n \n   @Override\n   public MinorType getMinorType() {\n-    return MinorType.${minor.class?upper_case};\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.getMinorType();\n+    <#else>\n+        return MinorType.${minor.class?upper_case};\n+    </#if>\n   }\n \n   @Override\n   public FieldReader getReader(){\n-    return reader;\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.getReader();\n+    <#else>\n+        return reader;\n+    </#if>\n   }\n \n   @Override\n   public int getValueCapacity(){\n-    return Math.min(bits.getValueCapacity(), values.getValueCapacity());\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.getValueCapacity();\n+    <#else>\n+        return Math.min(bits.getValueCapacity(), values.getValueCapacity());\n+    </#if>\n   }\n \n   @Override\n   public ArrowBuf[] getBuffers(boolean clear) {\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.getBuffers(clear);\n+    <#else>\n     final ArrowBuf[] buffers = ObjectArrays.concat(bits.getBuffers(false), values.getBuffers(false), ArrowBuf.class);\n     if (clear) {\n       for (final ArrowBuf buffer:buffers) {\n@@ -187,25 +247,41 @@ public int getValueCapacity(){\n       clear();\n     }\n     return buffers;\n+    </#if>\n   }\n \n   @Override\n   public void close() {\n-    bits.close();\n-    values.close();\n-    super.close();\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        values.close();\n+    <#else>\n+        bits.close();\n+        values.close();\n+        super.close();\n+    </#if>\n   }\n \n   @Override\n   public void clear() {\n-    bits.clear();\n-    values.clear();\n-    super.clear();\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        values.clear();\n+    <#else>\n+        bits.clear();\n+        values.clear();\n+        super.clear();\n+    </#if>\n   }\n \n   @Override\n   public int getBufferSize(){\n-    return values.getBufferSize() + bits.getBufferSize();\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.getBufferSize();\n+    <#else>\n+        return values.getBufferSize() + bits.getBufferSize();\n+    </#if>\n   }\n \n   @Override\n@@ -214,34 +290,52 @@ public int getBufferSizeFor(final int valueCount) {\n       return 0;\n     }\n \n-    return values.getBufferSizeFor(valueCount)\n-        + bits.getBufferSizeFor(valueCount);\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.getBufferSizeFor(valueCount);\n+    <#else>\n+        return values.getBufferSizeFor(valueCount)\n+          + bits.getBufferSizeFor(valueCount);\n+    </#if>\n   }\n \n   public ArrowBuf getBuffer() {\n     return values.getDataBuffer();\n   }\n \n-  @Override\n   public ${valuesName} getValuesVector() {\n     return values;\n   }\n \n   @Override\n   public void setInitialCapacity(int numRecords) {\n-    bits.setInitialCapacity(numRecords);\n-    values.setInitialCapacity(numRecords);\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        values.setInitialCapacity(numRecords);\n+    <#else>\n+        bits.setInitialCapacity(numRecords);\n+        values.setInitialCapacity(numRecords);\n+    </#if>\n   }\n \n   @Override\n   public void allocateNew() {\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        values.allocateNew();\n+    <#else>\n     if(!allocateNewSafe()){\n       throw new OutOfMemoryException(\"Failure while allocating buffer.\");\n     }\n+    </#if>\n   }\n \n   @Override\n   public boolean allocateNewSafe() {\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.allocateNewSafe();\n+    <#else>\n     /* Boolean to keep track if all the memory allocations were successful\n      * Used in the case of composite vectors when we need to allocate multiple\n      * buffers for multiple vectors. If one of the allocations failed we need to\n@@ -259,23 +353,38 @@ public boolean allocateNewSafe() {\n     mutator.reset();\n     accessor.reset();\n     return success;\n+    </#if>\n   }\n \n   @Override\n   public void reAlloc() {\n-    bits.reAlloc();\n-    values.reAlloc();\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        values.reAlloc();\n+    <#else>\n+        bits.reAlloc();\n+        values.reAlloc();\n+    </#if>\n   }\n \n   public void reset() {\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        values.reset();\n+    <#else>\n     bits.zeroVector();\n     mutator.reset();\n     accessor.reset();\n+    </#if>\n   }\n \n   <#if type.major == \"VarLen\">\n   @Override\n   public void allocateNew(int totalBytes, int valueCount) {\n+    <#if minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        values.allocateNew(totalBytes, valueCount);\n+    <#else>\n     try {\n       values.allocateNew(totalBytes, valueCount);\n       bits.allocateNew(valueCount);\n@@ -286,6 +395,7 @@ public void allocateNew(int totalBytes, int valueCount) {\n     bits.zeroVector();\n     mutator.reset();\n     accessor.reset();\n+    </#if>\n   }\n \n   @Override\n@@ -301,6 +411,10 @@ public int getCurrentSizeInBytes(){\n   <#else>\n   @Override\n   public void allocateNew(int valueCount) {\n+    <#if minor.class == \"Int\">\n+        /* DELEGATE TO NEW VECTOR */\n+        values.allocateNew(valueCount);\n+    <#else>\n     try {\n       values.allocateNew(valueCount);\n       bits.allocateNew(valueCount);\n@@ -311,6 +425,7 @@ public void allocateNew(int valueCount) {\n     bits.zeroVector();\n     mutator.reset();\n     accessor.reset();\n+    </#if>\n   }\n \n   /**\n@@ -318,32 +433,86 @@ public void allocateNew(int valueCount) {\n    */\n   @Override\n   public void zeroVector() {\n-    bits.zeroVector();\n-    values.zeroVector();\n+    <#if minor.class == \"Int\">\n+        /* DELEGATE TO NEW VECTOR */\n+        values.zeroVector();\n+    <#else>\n+        bits.zeroVector();\n+        values.zeroVector();\n+    </#if>\n   }\n   </#if>\n \n+\n+\n   @Override\n   public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.getTransferPair(ref, allocator, callBack);\n+    <#else>\n         return getTransferPair(ref, allocator);\n+    </#if>\n   }\n \n+\n+\n   @Override\n   public TransferPair getTransferPair(BufferAllocator allocator){\n-    return new TransferImpl(name, allocator);\n-\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.getTransferPair(allocator);\n+    <#else>\n+        return new TransferImpl(name, allocator);\n+    </#if>\n   }\n \n+\n+\n   @Override\n   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n-    return new TransferImpl(ref, allocator);\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.getTransferPair(ref, allocator);\n+    <#else>\n+        return new TransferImpl(ref, allocator);\n+    </#if>\n   }\n \n+\n+\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((${className}) to);\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.makeTransferPair(to);\n+    <#else>\n+        return new TransferImpl((${className}) to);\n+    </#if>\n+  }\n+\n+\n+\n+  <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+  public void transferTo(${valuesName} target) {\n+    /* DELEGATE TO NEW VECTOR */\n+    <#if type.major == \"VarLen\">\n+        values.transferTo((BaseNullableVariableWidthVector) target);\n+    <#else>\n+        values.transferTo((BaseNullableFixedWidthVector) target);\n+    </#if>\n+  }\n+\n+  public void splitAndTransferTo(int startIndex, int length, ${valuesName} target) {\n+    /* DELEGATE TO NEW VECTOR */\n+    <#if type.major == \"VarLen\">\n+        values.splitAndTransferTo(startIndex, length, (BaseNullableVariableWidthVector) target);\n+    <#else>\n+        values.splitAndTransferTo(startIndex, length, (BaseNullableFixedWidthVector) target);\n+    </#if>\n   }\n \n+  <#else>\n   public void transferTo(${className} target){\n     bits.transferTo(target.bits);\n     values.transferTo(target.values);\n@@ -360,7 +529,11 @@ public void splitAndTransferTo(int startIndex, int length, ${className} target)\n     target.mutator.lastSet = length - 1;\n     </#if>\n   }\n+  </#if>\n \n+\n+\n+  <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n   private class TransferImpl implements TransferPair {\n     ${className} to;\n \n@@ -392,6 +565,9 @@ public void copyValueSafe(int fromIndex, int toIndex) {\n       to.copyFromSafe(fromIndex, toIndex, ${className}.this);\n     }\n   }\n+  </#if>\n+\n+\n \n   @Override\n   public Accessor getAccessor(){\n@@ -403,7 +579,20 @@ public Mutator getMutator(){\n     return mutator;\n   }\n \n-  public void copyFrom(int fromIndex, int thisIndex, ${className} from){\n+\n+\n+  <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+  public void copyFrom(int fromIndex, int thisIndex, ${valuesName} from) {\n+    /* DELEGATE TO NEW VECTOR */\n+    values.copyFrom(fromIndex, thisIndex, from);\n+  }\n+\n+  public void copyFromSafe(int fromIndex, int thisIndex, ${valuesName} from) {\n+    /* DELEGATE TO NEW VECTOR */\n+    values.copyFromSafe(fromIndex, thisIndex, from);\n+  }\n+  <#else>\n+  public void copyFrom(int fromIndex, int thisIndex, ${className} from) {\n     final Accessor fromAccessor = from.getAccessor();\n     if (!fromAccessor.isNull(fromIndex)) {\n       mutator.set(thisIndex, fromAccessor.get(fromIndex));\n@@ -428,17 +617,28 @@ public void copyFromSafe(int fromIndex, int thisIndex, ${className} from){\n     values.copyFromSafe(fromIndex, thisIndex, from.values);\n     <#if type.major == \"VarLen\">mutator.lastSet = thisIndex;</#if>\n   }\n+  </#if>\n \n   @Override\n   public long getValidityBufferAddress() {\n     /* address of the databuffer associated with the bitVector */\n-    return (bits.getDataBuffer().memoryAddress());\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.getValidityBufferAddress();\n+    <#else>\n+        return (bits.getDataBuffer().memoryAddress());\n+    </#if>\n   }\n \n   @Override\n   public long getDataBufferAddress() {\n     /* address of the dataBuffer associated with the valueVector */\n-    return (values.getDataBuffer().memoryAddress());\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+          /* DELEGATE TO NEW VECTOR */\n+          return values.getDataBufferAddress();\n+    <#else>\n+          return (bits.getDataBuffer().memoryAddress());\n+    </#if>\n   }\n \n   @Override\n@@ -446,17 +646,26 @@ public long getOffsetBufferAddress() {\n     /* address of the dataBuffer associated with the offsetVector\n      * this operation is not supported for fixed-width vector types.\n      */\n-    <#if type.major != \"VarLen\">\n-        throw new UnsupportedOperationException();\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+          /* DELEGATE TO NEW VECTOR */\n+          return values.getOffsetBufferAddress();\n     <#else>\n-        return (values.getOffsetAddr());\n+        <#if type.major != \"VarLen\">\n+          throw new UnsupportedOperationException();\n+        <#else>\n+          return (values.getOffsetAddr());\n+        </#if>\n     </#if>\n   }\n \n   @Override\n   public ArrowBuf getValidityBuffer() {\n-    /* dataBuffer associated with the bitVector */\n-    return (bits.getDataBuffer());\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+          /* DELEGATE TO NEW VECTOR */\n+          return values.getValidityBuffer();\n+    <#else>\n+          return (bits.getDataBuffer());\n+    </#if>\n   }\n \n   @Override\n@@ -468,10 +677,15 @@ public ArrowBuf getDataBuffer() {\n   @Override\n   public ArrowBuf getOffsetBuffer() {\n     /* dataBuffer associated with the offsetVector of the valueVector */\n-    <#if type.major != \"VarLen\">\n-        throw new UnsupportedOperationException();\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.getOffsetBuffer();\n     <#else>\n-        return (values.getOffsetBuffer());\n+        <#if type.major != \"VarLen\">\n+          throw new UnsupportedOperationException();\n+        <#else>\n+          return (values.getOffsetBuffer());\n+        </#if>\n     </#if>\n   }\n \n@@ -485,38 +699,80 @@ public ArrowBuf getOffsetBuffer() {\n      * @param  index   position of the value\n      * @return value of the element, if not null\n      */\n-    public <#if type.major == \"VarLen\">byte[]<#else>${minor.javaType!type.javaType}</#if> get(int index) {\n-      if (isNull(index)) {\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+      public <#if type.major == \"VarLen\">byte[]<#else>${minor.javaType!type.javaType}</#if> get(int index) {\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.get(index);\n+      }\n+    <#else>\n+\n+      public <#if type.major == \"VarLen\">byte[]<#else>${minor.javaType!type.javaType}</#if> get(int index) {\n+        if (isNull(index)) {\n           throw new IllegalStateException(\"Can't get a null value\");\n+        }\n+        return vAccessor.get(index);\n       }\n-      return vAccessor.get(index);\n-    }\n+    </#if>\n \n     @Override\n     public boolean isNull(int index) {\n-      return isSet(index) == 0;\n+      <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.isNull(index);\n+      <#else>\n+        return isSet(index) == 0;\n+      </#if>\n     }\n \n     public int isSet(int index){\n-      return bAccessor.get(index);\n+      <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.isSet(index);\n+      <#else>\n+        return bAccessor.get(index);\n+      </#if>\n     }\n \n     <#if type.major == \"VarLen\">\n     public long getStartEnd(int index){\n-      return vAccessor.getStartEnd(index);\n+      <#if minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.getStartEnd(index);\n+      <#else>\n+        return vAccessor.getStartEnd(index);\n+      </#if>\n     }\n \n     @Override\n     public int getValueLength(int index) {\n-      return values.getAccessor().getValueLength(index);\n+      <#if minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.getValueLength(index);\n+      <#else>\n+        return values.getAccessor().getValueLength(index);\n+      </#if>\n     }\n     </#if>\n \n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+    public void get(int index, Nullable${minor.class}Holder holder){\n+        /* DELEGATE TO NEW VECTOR */\n+        values.get(index, holder);\n+    }\n+    <#else>\n     public void get(int index, Nullable${minor.class}Holder holder){\n       vAccessor.get(index, holder);\n       holder.isSet = bAccessor.get(index);\n     }\n+    </#if>\n \n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+    @Override\n+    public ${friendlyType} getObject(int index) {\n+      /* DELEGATE TO NEW VECTOR */\n+      return values.getObject(index);\n+    }\n+    <#else>\n     @Override\n     public ${friendlyType} getObject(int index) {\n       if (isNull(index)) {\n@@ -525,6 +781,7 @@ public void get(int index, Nullable${minor.class}Holder holder){\n         return vAccessor.getObject(index);\n       }\n     }\n+    </#if>\n \n     <#if minor.class == \"IntervalYear\" || minor.class == \"IntervalDay\">\n     public StringBuilder getAsStringBuilder(int index) {\n@@ -538,7 +795,12 @@ public StringBuilder getAsStringBuilder(int index) {\n \n     @Override\n     public int getValueCount(){\n-      return bits.getAccessor().getValueCount();\n+      <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+        /* DELEGATE TO NEW VECTOR */\n+        return values.getValueCount();\n+      <#else>\n+        return bits.getAccessor().getValueCount();\n+      </#if>\n     }\n \n     public void reset(){}\n@@ -551,21 +813,35 @@ public void reset(){}\n     private Mutator(){\n     }\n \n-    public ${valuesName} getVectorWithValues(){\n+    public ${valuesName} getVectorWithValues() {\n       return values;\n     }\n \n+\n     @Override\n     public void setIndexDefined(int index){\n+      <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+      values.setIndexDefined(index);\n+      <#else>\n       bits.getMutator().setToOne(index);\n+      </#if>\n     }\n \n+\n+\n     /**\n      * Set the variable length element at the specified index to the supplied byte array.\n      *\n      * @param index   position of the bit to set\n      * @param value   array of bytes (or int if smaller than 4 bytes) to write\n      */\n+\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+    public void set(int index, <#if type.major == \"VarLen\">byte[]<#elseif (type.width < 4)>int<#else>${minor.javaType!type.javaType}</#if> value) {\n+       /* DELEGATE TO NEW VECTOR */\n+       values.set(index, value);\n+    }\n+    <#else>\n     public void set(int index, <#if type.major == \"VarLen\">byte[]<#elseif (type.width < 4)>int<#else>${minor.javaType!type.javaType}</#if> value) {\n       setCount++;\n       final ${valuesName}.Mutator valuesMutator = values.getMutator();\n@@ -579,9 +855,24 @@ public void set(int index, <#if type.major == \"VarLen\">byte[]<#elseif (type.widt\n       valuesMutator.set(index, value);\n       <#if type.major == \"VarLen\">lastSet = index;</#if>\n     }\n+    </#if>\n+\n+\n \n     <#if type.major == \"VarLen\">\n+    <#if minor.class == \"VarChar\">\n+    public void fillEmpties(int index) {\n+      /* DELEGATE TO NEW VECTOR */\n+      values.fillEmpties(index);\n+    }\n \n+    @Override\n+    public void setValueLengthSafe(int index, int length) {\n+      /* DELEGATE TO NEW VECTOR */\n+      values.setValueLengthSafe(index, length);\n+    }\n+\n+    <#else>\n     public void fillEmpties(int index){\n       final ${valuesName}.Mutator valuesMutator = values.getMutator();\n       for (int i = lastSet + 1; i < index; i++) {\n@@ -599,7 +890,16 @@ public void setValueLengthSafe(int index, int length) {\n       lastSet = index;\n     }\n     </#if>\n+    </#if>\n \n+\n+\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+    public void setSafe(int index, byte[] value, int start, int length) {\n+       /* DELEGATE TO NEW VECTOR */\n+      values.setSafe(index, value, start, length);\n+    }\n+    <#else>\n     public void setSafe(int index, byte[] value, int start, int length) {\n       <#if type.major != \"VarLen\">\n       throw new UnsupportedOperationException();\n@@ -612,7 +912,16 @@ public void setSafe(int index, byte[] value, int start, int length) {\n       <#if type.major == \"VarLen\">lastSet = index;</#if>\n       </#if>\n     }\n+    </#if>\n+\n+\n \n+    <#if minor.class == \"VarChar\">\n+    public void setSafe(int index, ByteBuffer value, int start, int length) {\n+       /* DELEGATE TO NEW VECTOR */\n+       values.setSafe(index, value, start, length);\n+    }\n+    <#else>\n     public void setSafe(int index, ByteBuffer value, int start, int length) {\n       <#if type.major != \"VarLen\">\n       throw new UnsupportedOperationException();\n@@ -625,11 +934,25 @@ public void setSafe(int index, ByteBuffer value, int start, int length) {\n       <#if type.major == \"VarLen\">lastSet = index;</#if>\n       </#if>\n     }\n+    </#if>\n \n+\n+\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+    public void setNull(int index) {\n+       /* DELEGATE TO NEW VECTOR */\n+       values.setNull(index);\n+    }\n+    <#else>\n     public void setNull(int index){\n       bits.getMutator().setSafe(index, 0);\n     }\n+    </#if>\n+\n+\n \n+    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n+    /* these methods are probably not needed */\n     public void setSkipNull(int index, ${minor.class}Holder holder){\n       values.getMutator().set(index, holder);\n     }\n@@ -637,8 +960,17 @@ public void setSkipNull(int index, ${minor.class}Holder holder){\n     public void setSkipNull(int index, Nullable${minor.class}Holder holder){\n       values.getMutator().set(index, holder);\n     }\n+    </#if>\n+\n \n-    public void set(int index, Nullable${minor.class}Holder holder){\n+\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+    public void set(int index, Nullable${minor.class}Holder holder) {\n+      /* DELEGATE TO NEW VECTOR */\n+      values.set(index, holder);\n+    }\n+    <#else>\n+    public void set(int index, Nullable${minor.class}Holder holder) {\n       final ${valuesName}.Mutator valuesMutator = values.getMutator();\n       <#if type.major == \"VarLen\">\n       for (int i = lastSet + 1; i < index; i++) {\n@@ -649,8 +981,17 @@ public void set(int index, Nullable${minor.class}Holder holder){\n       valuesMutator.set(index, holder);\n       <#if type.major == \"VarLen\">lastSet = index;</#if>\n     }\n+    </#if>\n+\n+\n \n-    public void set(int index, ${minor.class}Holder holder){\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+    public void set(int index, ${minor.class}Holder holder) {\n+        /* DELEGATE TO NEW VECTOR */\n+        values.set(index, holder);\n+    }\n+    <#else>\n+    public void set(int index, ${minor.class}Holder holder) {\n       final ${valuesName}.Mutator valuesMutator = values.getMutator();\n       <#if type.major == \"VarLen\">\n       for (int i = lastSet + 1; i < index; i++) {\n@@ -661,11 +1002,45 @@ public void set(int index, ${minor.class}Holder holder){\n       valuesMutator.set(index, holder);\n       <#if type.major == \"VarLen\">lastSet = index;</#if>\n     }\n+    </#if>\n \n+\n+\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+    public boolean isSafe(int outIndex) {\n+       /* DELEGATE TO NEW VECTOR */\n+       return values.isSafe(outIndex);\n+    }\n+    <#else>\n     public boolean isSafe(int outIndex) {\n       return outIndex < ${className}.this.getValueCapacity();\n     }\n+    </#if>\n+\n+\n \n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+    <#if minor.class == \"Int\">\n+    public void set(int index, int isSet, int valueField) {\n+      /* DELEGATE TO NEW VECTOR */\n+      values.set(index, isSet, valueField);\n+    }\n+    public void setSafe(int index, int isSet, int valueField) {\n+      /* DELEGATE TO NEW VECTOR */\n+      values.setSafe(index, isSet, valueField);\n+    }\n+    </#if>\n+    <#if minor.class == \"VarChar\">\n+    public void set(int index, int isSet, int startField, int endField, ArrowBuf bufferField ) {\n+      /* DELEGATE TO NEW VECTOR */\n+      values.set(index, isSet, startField, endField, bufferField);\n+    }\n+    public void setSafe(int index, int isSet, int startField, int endField, ArrowBuf bufferField ) {\n+        /* DELEGATE TO NEW VECTOR */\n+        values.setSafe(index, isSet, startField, endField, bufferField);\n+    }\n+    </#if>\n+    <#else>\n     <#assign fields = minor.fields!type.fields />\n     public void set(int index, int isSet<#list fields as field>, ${field.type} ${field.name}Field</#list> ){\n       final ${valuesName}.Mutator valuesMutator = values.getMutator();\n@@ -688,8 +1063,21 @@ public void setSafe(int index, int isSet<#list fields as field><#if field.includ\n       setCount++;\n       <#if type.major == \"VarLen\">lastSet = index;</#if>\n     }\n+    </#if>\n+\n \n \n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+    public void setSafe(int index, Nullable${minor.class}Holder value) {\n+      /* DELEGATE TO NEW VECTOR */\n+      values.setSafe(index, value);\n+    }\n+\n+    public void setSafe(int index, ${minor.class}Holder value) {\n+      /* DELEGATE TO NEW VECTOR */\n+      values.setSafe(index, value);\n+    }\n+    <#else>\n     public void setSafe(int index, Nullable${minor.class}Holder value) {\n       <#if type.major == \"VarLen\">\n       fillEmpties(index);\n@@ -709,15 +1097,25 @@ public void setSafe(int index, ${minor.class}Holder value) {\n       setCount++;\n       <#if type.major == \"VarLen\">lastSet = index;</#if>\n     }\n+    </#if>\n+\n+\n \n     <#if !(type.major == \"VarLen\" || minor.class == \"IntervalDay\")>\n     public void setSafe(int index, ${minor.javaType!type.javaType} value) {\n+      <#if minor.class == \"Int\">\n+        /* DELEGATE TO NEW VECTOR */\n+        values.setSafe(index, value);\n+      <#else>\n       bits.getMutator().setSafeToOne(index);\n       values.getMutator().setSafe(index, value);\n       setCount++;\n+      </#if>\n     }\n-\n     </#if>\n+\n+\n+\n     <#if minor.class == \"Decimal\">\n     public void set(int index, ${friendlyType} value) {\n       bits.getMutator().setToOne(index);\n@@ -729,8 +1127,17 @@ public void setSafe(int index, ${friendlyType} value) {\n       values.getMutator().setSafe(index, value);\n       setCount++;\n     }\n-\n     </#if>\n+\n+\n+\n+    <#if minor.class == \"Int\" || minor.class == \"VarChar\">\n+    @Override\n+    public void setValueCount(int valueCount) {\n+      /* DELEGATE TO NEW VECTOR */\n+      values.setValueCount(valueCount);\n+    }\n+    <#else>\n     @Override\n     public void setValueCount(int valueCount) {\n       assert valueCount >= 0;\n@@ -740,7 +1147,12 @@ public void setValueCount(int valueCount) {\n       values.getMutator().setValueCount(valueCount);\n       bits.getMutator().setValueCount(valueCount);\n     }\n+    </#if>\n+\n \n+\n+    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n+    /* THIS METHOD IS PROBABLY NOT NEEDED FOR NEW VECTORS */\n     @Override\n     public void generateTestData(int valueCount){\n       bits.getMutator().generateTestDataAlt(valueCount);\n@@ -748,13 +1160,27 @@ public void generateTestData(int valueCount){\n       <#if type.major = \"VarLen\">lastSet = valueCount;</#if>\n       setValueCount(valueCount);\n     }\n+    </#if>\n+\n \n+\n+    <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n+    /* MUTATOR RESET IS NOT NEEDED FOR NEW VECTORS */\n     @Override\n     public void reset(){\n       setCount = 0;\n       <#if type.major = \"VarLen\">lastSet = -1;</#if>\n     }\n+    </#if>\n+\n+\n \n+    <#if minor.class == \"VarChar\">\n+    public void setLastSet(int value) {\n+      /* DELEGATE TO NEW VECTOR */\n+      values.setLastSet(value);\n+    }\n+    <#else>\n     public void setLastSet(int value) {\n       <#if type.major = \"VarLen\">\n         lastSet = value;\n@@ -762,7 +1188,16 @@ public void setLastSet(int value) {\n         throw new UnsupportedOperationException();\n       </#if>\n     }\n+    </#if>\n+\n \n+\n+    <#if minor.class == \"VarChar\">\n+    public int getLastSet() {\n+      /* DELEGATE TO NEW VECTOR */\n+      return values.getLastSet();\n+    }\n+    <#else>\n     public int getLastSet() {\n       <#if type.major != \"VarLen\">\n         throw new UnsupportedOperationException();\n@@ -770,6 +1205,7 @@ public int getLastSet() {\n         return lastSet;\n       </#if>\n     }\n+    </#if>\n   }\n }\n </#list>\ndiff --git a/java/vector/src/main/codegen/templates/UnionVector.java b/java/vector/src/main/codegen/templates/UnionVector.java\nindex fe24a8674..3c7ed0190 100644\n--- a/java/vector/src/main/codegen/templates/UnionVector.java\n+++ b/java/vector/src/main/codegen/templates/UnionVector.java\n@@ -436,7 +436,11 @@ public Object getObject(int index) {\n           <#assign uncappedName = name?uncap_first/>\n           <#if !minor.typeParams?? >\n       case ${name?upper_case}:\n-        return get${name}Vector().getAccessor().getObject(index);\n+        <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n+          return get${name}Vector().getAccessor().getObject(index);\n+        <#else>\n+          return get${name}Vector().getObject(index);\n+        </#if>\n           </#if>\n         </#list>\n       </#list>\n@@ -530,7 +534,11 @@ public void setSafe(int index, UnionHolder holder) {\n         <#if !minor.typeParams?? >\n     public void setSafe(int index, Nullable${name}Holder holder) {\n       setType(index, MinorType.${name?upper_case});\n-      get${name}Vector().getMutator().setSafe(index, holder);\n+      <#if minor.class != \"Int\" && minor.class != \"VarChar\">\n+        get${name}Vector().getMutator().setSafe(index, holder);\n+      <#else>\n+        get${name}Vector().setSafe(index, holder);\n+      </#if>\n     }\n \n         </#if>\n@@ -547,4 +555,10 @@ public void reset() { }\n     @Override\n     public void generateTestData(int values) { }\n   }\n+\n+  public int getValueCount() { return 0; }\n+\n+  public void setValueCount(int valueCount) { }\n+\n+  public Object getObject(int index) { return null; }\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java b/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java\nnew file mode 100644\nindex 000000000..c5f781000\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java\n@@ -0,0 +1,701 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+public abstract class BaseNullableFixedWidthVector extends BaseValueVector\n+        implements FixedWidthVector, FieldVector {\n+   private final byte typeWidth;\n+\n+   private int valueAllocationSizeInBytes;\n+   private int validityAllocationSizeInBytes;\n+\n+   protected final Field field;\n+   private int allocationMonitor;\n+   protected ArrowBuf validityBuffer;\n+   protected ArrowBuf valueBuffer;\n+   protected int valueCount;\n+\n+   public BaseNullableFixedWidthVector(final String name, final BufferAllocator allocator,\n+                                       FieldType fieldType, final byte typeWidth) {\n+      super(name, allocator);\n+      this.typeWidth = typeWidth;\n+      valueAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * typeWidth;\n+      validityAllocationSizeInBytes = getSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+      field = new Field(name, fieldType, null);\n+      valueCount = 0;\n+      allocationMonitor = 0;\n+      validityBuffer = allocator.getEmpty();\n+      valueBuffer = allocator.getEmpty();\n+   }\n+\n+   /* TODO:\n+    * Determine how writerIndex and readerIndex need to be used. Right now we\n+    * are setting the writerIndex and readerIndex in the call to getFieldBuffers\n+    * using the valueCount -- this assumes that the caller of getFieldBuffers\n+    * on the vector has already invoked setValueCount.\n+    *\n+    * Do we need to set them during vector transfer and splitAndTransfer?\n+    */\n+\n+   /* TODO:\n+    *\n+    * see if getNullCount() can be made faster -- O(1)\n+    */\n+\n+   /* TODO:\n+    * Once the entire hierarchy has been refactored, move common functions\n+    * like getNullCount(), splitAndTransferValidityBuffer to top level\n+    * base class BaseValueVector.\n+    *\n+    * Along with this, some class members (validityBuffer) can also be\n+    * abstracted out to top level base class.\n+    *\n+    * Right now BaseValueVector is the top level base class for other\n+    * vector types in ValueVector hierarchy and those vectors have not\n+    * yet been refactored so moving things to the top class as of now\n+    * is not a good idea.\n+    */\n+\n+   /* TODO:\n+    * See if we need logger -- unnecessary object probably\n+    */\n+\n+   protected abstract org.slf4j.Logger getLogger();\n+\n+   @Override\n+   public Mutator getMutator() {\n+      throw new  UnsupportedOperationException(\"Mutator is not needed to write into vector\");\n+   }\n+\n+   @Override\n+   public Accessor getAccessor() {\n+      throw new UnsupportedOperationException(\"Accessor is not needed to read from vector\");\n+   }\n+\n+   @Override\n+   public long getValidityBufferAddress() {\n+      return (validityBuffer.memoryAddress());\n+   }\n+\n+   @Override\n+   public long getDataBufferAddress() {\n+      return (valueBuffer.memoryAddress());\n+   }\n+\n+   @Override\n+   public long getOffsetBufferAddress() {\n+      throw new UnsupportedOperationException(\"not supported for fixed-width vectors\");\n+   }\n+\n+   @Override\n+   public ArrowBuf getValidityBuffer() {\n+      return validityBuffer;\n+   }\n+\n+   @Override\n+   public ArrowBuf getDataBuffer() {\n+      return valueBuffer;\n+   }\n+\n+   @Override\n+   public ArrowBuf getOffsetBuffer() {\n+      throw new UnsupportedOperationException(\"not supported for fixed-width vectors\");\n+   }\n+\n+   @Override\n+   public void setInitialCapacity(int valueCount) {\n+      final long size = (long)valueCount * typeWidth;\n+      if (size > MAX_ALLOCATION_SIZE) {\n+         throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+      }\n+      valueAllocationSizeInBytes = (int)size;\n+      validityAllocationSizeInBytes = getSizeFromCount(valueCount);\n+   }\n+\n+   @Override\n+   public int getValueCapacity(){\n+      return Math.min(getValueBufferValueCapacity(), getValidityBufferValueCapacity());\n+   }\n+\n+   /* for test purposes */\n+   private int getValueBufferValueCapacity() {\n+      return (int)((valueBuffer.capacity() * 1.0)/typeWidth);\n+   }\n+\n+   /* for test purposes */\n+   private int getValidityBufferValueCapacity() {\n+      return (int)(validityBuffer.capacity() * 8L);\n+   }\n+\n+   /* number of bytes for the validity buffer for the given valueCount */\n+   protected int getSizeFromCount(int valueCount) {\n+      return (int) Math.ceil(valueCount / 8.0);\n+   }\n+\n+   @Override\n+   public void zeroVector() {\n+      initValidityBuffer();\n+      initValueBuffer();\n+   }\n+\n+   private void initValidityBuffer() {\n+      validityBuffer.setZero(0, validityBuffer.capacity());\n+   }\n+\n+   private void initValueBuffer() {\n+      valueBuffer.setZero(0, valueBuffer.capacity());\n+   }\n+\n+   public void reset() {\n+      zeroVector();\n+   }\n+\n+   @Override\n+   public void close() { clear(); }\n+\n+   @Override\n+   public void clear() {\n+      validityBuffer = releaseBuffer(validityBuffer);\n+      valueBuffer = releaseBuffer(valueBuffer);\n+   }\n+\n+   /* used to step down the memory allocation */\n+   protected void incrementAllocationMonitor() {\n+      if (allocationMonitor < 0) {\n+         allocationMonitor = 0;\n+      }\n+      allocationMonitor++;\n+   }\n+\n+   /* used to step up the memory allocation */\n+   protected void decrementAllocationMonitor() {\n+      if (allocationMonitor > 0) {\n+         allocationMonitor = 0;\n+      }\n+      allocationMonitor--;\n+   }\n+\n+   @Override\n+   public void allocateNew() {\n+      if(!allocateNewSafe()){\n+         throw new OutOfMemoryException(\"Failure while allocating memory.\");\n+      }\n+   }\n+\n+   public boolean allocateNewSafe() {\n+      long curAllocationSizeValue = valueAllocationSizeInBytes;\n+      long curAllocationSizeValidity = validityAllocationSizeInBytes;\n+\n+      if (curAllocationSizeValue > MAX_ALLOCATION_SIZE) {\n+         throw new OversizedAllocationException(\"Requested amount of memory exceeds limit\");\n+      }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+\n+      try{\n+         allocateBytes(curAllocationSizeValue, curAllocationSizeValidity);\n+      } catch (Exception e) {\n+         getLogger().error(\"ERROR: Failure in allocateNewSafe\");\n+         getLogger().error(e.getMessage());\n+         clear();\n+         return false;\n+      }\n+\n+      return true;\n+   }\n+\n+   public void allocateNew(int valueCount) {\n+      long valueBufferSize = valueCount * typeWidth;\n+      long validityBufferSize = getSizeFromCount(valueCount);\n+\n+      if (allocationMonitor > 10) {\n+         /* step down the default memory allocation since we have observed\n+          * multiple times that provisioned value capacity was much larger than\n+          * actually needed. see setValueCount for more details.\n+          */\n+         valueBufferSize = Math.max(8, valueBufferSize / 2);\n+         validityBufferSize = Math.max(8, validityBufferSize / 2);\n+         allocationMonitor = 0;\n+      } else if (allocationMonitor < -2) {\n+         valueBufferSize = valueBufferSize * 2L;\n+         validityBufferSize = validityBufferSize * 2L;\n+         allocationMonitor = 0;\n+      }\n+\n+      if (valueBufferSize > MAX_ALLOCATION_SIZE) {\n+         throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+      }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+\n+      try {\n+         allocateBytes(valueBufferSize, validityBufferSize);\n+      } catch(Exception e) {\n+         getLogger().error(\"ERROR: Failure in allocateNew\");\n+         getLogger().error(e.getMessage());\n+         clear();\n+         throw e;\n+      }\n+   }\n+\n+   /**\n+    * Actual memory allocation is done by this function. All the calculations\n+    * and knowledge about what size to allocate is upto the callers of this\n+    * method.\n+    * Callers appropriately handle errors if memory allocation fails here.\n+    * Callers should also take care of determining that desired size is\n+    * within the bounds of max allocation allowed and any other error\n+    * conditions.\n+    */\n+   private void allocateBytes(final long valueBufferSize, final long validityBufferSize) {\n+      /* allocate data buffer */\n+      int curSize = (int)valueBufferSize;\n+      valueBuffer = allocator.buffer(curSize);\n+      valueBuffer.readerIndex(0);\n+      valueAllocationSizeInBytes = curSize;\n+\n+      /* allocate validity buffer */\n+      allocateValidityBuffer((int)validityBufferSize);\n+      initValidityBuffer();\n+   }\n+\n+   /*\n+    * during splitAndTransfer, if we splitting from a random position within a byte,\n+    * we can't just slice the source buffer so we have to explicitly allocate the\n+    * validityBuffer of the target vector. This is unlike the databuffer which we can\n+    * always slice for the target vector.\n+    */\n+   private void allocateValidityBuffer(final int validityBufferSize) {\n+      validityBuffer = allocator.buffer(validityBufferSize);\n+      validityBuffer.readerIndex(0);\n+      validityAllocationSizeInBytes = validityBufferSize;\n+      initValidityBuffer();\n+   }\n+\n+   @Override\n+   public int getBufferSizeFor(final int count) {\n+      if (count == 0) { return 0; }\n+      return (count * typeWidth) + getSizeFromCount(count);\n+   }\n+\n+   @Override\n+   public int getBufferSize() {\n+      if (valueCount == 0) { return 0; }\n+      return (valueCount * typeWidth) + getSizeFromCount(valueCount);\n+   }\n+\n+   @Override\n+   public Field getField() {\n+      return field;\n+   }\n+\n+   @Override\n+   public ArrowBuf[] getBuffers(boolean clear) {\n+      final ArrowBuf[] buffers = new ArrowBuf[2];\n+      buffers[0] = validityBuffer;\n+      buffers[1] = valueBuffer;\n+      if (clear) {\n+         for (final ArrowBuf buffer:buffers) {\n+            buffer.retain(1);\n+         }\n+         clear();\n+      }\n+      return buffers;\n+   }\n+\n+   @Override\n+   public void reAlloc() {\n+      valueBuffer = reallocBufferHelper(valueBuffer, true);\n+      validityBuffer = reallocBufferHelper(validityBuffer, false);\n+   }\n+\n+   private ArrowBuf reallocBufferHelper(ArrowBuf buffer, final boolean dataBuffer) {\n+      final int currentBufferCapacity = buffer.capacity();\n+      long baseSize  = (dataBuffer ? valueAllocationSizeInBytes\n+                                   : validityAllocationSizeInBytes);\n+\n+      if (baseSize < (long)currentBufferCapacity) {\n+         baseSize = (long)currentBufferCapacity;\n+      }\n+\n+      long newAllocationSize = baseSize * 2L;\n+      newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+      if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+         throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+      }\n+\n+      getLogger().debug(\"Reallocating vector [{}]. # of bytes: [{}] -> [{}]\",\n+              name, (dataBuffer ? valueAllocationSizeInBytes : validityAllocationSizeInBytes),\n+              newAllocationSize);\n+\n+      final ArrowBuf newBuf = allocator.buffer((int)newAllocationSize);\n+      newBuf.setBytes(0, buffer, 0, currentBufferCapacity);\n+      final int halfNewCapacity = newBuf.capacity() / 2;\n+      newBuf.setZero(halfNewCapacity, halfNewCapacity);\n+      buffer.release(1);\n+      buffer = newBuf;\n+      if (dataBuffer) {\n+         valueAllocationSizeInBytes = (int)newAllocationSize;\n+      }\n+      else {\n+         validityAllocationSizeInBytes = (int)newAllocationSize;\n+      }\n+\n+      return buffer;\n+   }\n+\n+   @Override\n+   public List<BufferBacked> getFieldInnerVectors() { throw new UnsupportedOperationException(); }\n+\n+   @Override\n+   public void initializeChildrenFromFields(List<Field> children) {\n+      if (!children.isEmpty()) {\n+         throw new IllegalArgumentException(\"primitive type vector can not have children\");\n+      }\n+   }\n+\n+   @Override\n+   public List<FieldVector> getChildrenFromFields() {\n+      return Collections.emptyList();\n+   }\n+\n+   @Override\n+   public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+      if (ownBuffers.size() != 2) {\n+         throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+      }\n+\n+      ArrowBuf bitBuffer = ownBuffers.get(0);\n+      ArrowBuf dataBuffer = ownBuffers.get(1);\n+\n+      validityBuffer.release();\n+      validityBuffer = bitBuffer.retain(allocator);\n+      valueBuffer.release();\n+      valueBuffer = dataBuffer.retain(allocator);\n+\n+      valueCount = fieldNode.getLength();\n+\n+      valueAllocationSizeInBytes = valueBuffer.capacity();\n+      validityAllocationSizeInBytes = validityBuffer.capacity();\n+   }\n+\n+   public List<ArrowBuf> getFieldBuffers() {\n+      List<ArrowBuf> result = new ArrayList<>(2);\n+\n+      validityBuffer.readerIndex(0);\n+      validityBuffer.writerIndex(getSizeFromCount(valueCount));\n+      valueBuffer.readerIndex(0);\n+      valueBuffer.writerIndex(valueCount * typeWidth);\n+\n+      result.add(validityBuffer);\n+      result.add(valueBuffer);\n+\n+      return result;\n+   }\n+\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+      return getTransferPair(ref, allocator);\n+   }\n+\n+   @Override\n+   public TransferPair getTransferPair(BufferAllocator allocator){\n+      return getTransferPair(name, allocator);\n+   }\n+\n+   public abstract TransferPair getTransferPair(String ref, BufferAllocator allocator);\n+\n+   public void transferTo(BaseNullableFixedWidthVector target){\n+      compareTypes(target, \"transferTo\");\n+      target.clear();\n+      target.validityBuffer = validityBuffer.transferOwnership(target.allocator).buffer;\n+      target.valueBuffer = valueBuffer.transferOwnership(target.allocator).buffer;\n+      target.valueCount = valueCount;\n+      clear();\n+   }\n+\n+   public void splitAndTransferTo(int startIndex, int length,\n+                                  BaseNullableFixedWidthVector target) {\n+      compareTypes(target, \"splitAndTransferTo\");\n+      target.clear();\n+      splitAndTransferValidityBuffer(startIndex, length, target);\n+      splitAndTransferValueBuffer(startIndex, length, target);\n+      target.setValueCount(length);\n+   }\n+\n+   private void splitAndTransferValueBuffer(int startIndex, int length,\n+                                            BaseNullableFixedWidthVector target) {\n+      final int startPoint = startIndex * typeWidth;\n+      final int sliceLength = length * typeWidth;\n+      target.valueBuffer = valueBuffer.slice(startPoint, sliceLength).transferOwnership(target.allocator).buffer;\n+   }\n+\n+   private void splitAndTransferValidityBuffer(int startIndex, int length,\n+                                               BaseNullableFixedWidthVector target) {\n+      assert startIndex + length <= valueCount;\n+      int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+      int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+      int byteSizeTarget = getSizeFromCount(length);\n+      int offset = startIndex % 8;\n+\n+      if (length > 0) {\n+         if (offset == 0) {\n+            // slice\n+            if (target.validityBuffer != null) {\n+               target.validityBuffer.release();\n+            }\n+            target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+            target.validityBuffer.retain(1);\n+         }\n+         else {\n+            /* Copy data\n+             * When the first bit starts from the middle of a byte (offset != 0),\n+             * copy data from src BitVector.\n+             * Each byte in the target is composed by a part in i-th byte,\n+             * another part in (i+1)-th byte.\n+             */\n+            target.allocateValidityBuffer(byteSizeTarget);\n+\n+            for (int i = 0; i < byteSizeTarget - 1; i++) {\n+               byte b1 = getBitsFromCurrentByte(this.validityBuffer, firstByteSource + i, offset);\n+               byte b2 = getBitsFromNextByte(this.validityBuffer, firstByteSource + i + 1, offset);\n+\n+               target.validityBuffer.setByte(i, (b1 + b2));\n+            }\n+\n+            /* Copying the last piece is done in the following manner:\n+             * if the source vector has 1 or more bytes remaining, we copy\n+             * the last piece as a byte formed by shifting data\n+             * from the current byte and the next byte.\n+             *\n+             * if the source vector has no more bytes remaining\n+             * (we are at the last byte), we copy the last piece as a byte\n+             * by shifting data from the current byte.\n+             */\n+            if((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+               byte b1 = getBitsFromCurrentByte(this.validityBuffer,\n+                       firstByteSource + byteSizeTarget - 1, offset);\n+               byte b2 = getBitsFromNextByte(this.validityBuffer,\n+                       firstByteSource + byteSizeTarget, offset);\n+\n+               target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+            }\n+            else {\n+               byte b1 = getBitsFromCurrentByte(this.validityBuffer,\n+                       firstByteSource + byteSizeTarget - 1, offset);\n+               target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+            }\n+         }\n+      }\n+   }\n+\n+   private static byte getBitsFromCurrentByte(ArrowBuf data, int index, int offset) {\n+      return (byte)((data.getByte(index) & 0xFF) >>> offset);\n+   }\n+\n+   private static byte getBitsFromNextByte(ArrowBuf data, int index, int offset) {\n+      return (byte)((data.getByte(index) << (8 - offset)));\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          common getters and setters                            *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the number of elements that are null in the vector\n+    *\n+    * @return the number of null elements.\n+    */\n+   public int getNullCount() {\n+      int count = 0;\n+      final int sizeInBytes = getSizeFromCount(valueCount);\n+\n+      for (int i = 0; i < sizeInBytes; ++i) {\n+         final byte byteValue = validityBuffer.getByte(i);\n+         /* Java uses two's complement binary representation, hence 11111111_b which is -1\n+          * when converted to Int will have 32bits set to 1. Masking the MSB and then\n+          * adding it back solves the issue.\n+          */\n+         count += Integer.bitCount(byteValue & 0x7F) - (byteValue >> 7);\n+      }\n+      int nullCount = (sizeInBytes * 8) - count;\n+      /* if the valueCount is not a multiple of 8,\n+       * the bits on the right were counted as null bits.\n+       */\n+      int remainder = valueCount % 8;\n+      nullCount -= remainder == 0 ? 0 : 8 - remainder;\n+      return nullCount;\n+   }\n+\n+\n+   /**\n+    * Get the value count of vector. This will always be zero unless\n+    * {@link #setValueCount(int)} has been called prior to calling this.\n+    *\n+    * @return valueCount for the vector\n+    */\n+   public int getValueCount(){\n+      return valueCount;\n+   }\n+\n+\n+   /**\n+    * Set value count for the vector.\n+    *\n+    * @param valueCount  value count to set\n+    */\n+   public void setValueCount(int valueCount) {\n+      this.valueCount = valueCount;\n+      final int currentValueCapacity = getValueCapacity();\n+      while (valueCount > getValueCapacity()) {\n+         reAlloc();\n+      }\n+      /*\n+       * We are trying to understand the pattern of memory allocation.\n+       * If initially, the user did vector.allocateNew(), we would have\n+       * allocated memory of default size (4096 * type width).\n+       * Later on user invokes setValueCount(count).\n+       *\n+       * If the existing value capacity is twice as large as the\n+       * valueCount, we know that we over-provisioned memory in the\n+       * first place when default memory allocation was done because user\n+       * really needs a much less value count in the vector.\n+       *\n+       * We record this by bumping up the allocationMonitor. If this pattern\n+       * happens for certain number of times and allocationMonitor\n+       * reaches the threshold (internal hardcoded) value, subsequent\n+       * call to allocateNew() will take care of stepping down the\n+       * default memory allocation size.\n+       *\n+       * Another case would be under-provisioning the initial memory and\n+       * thus going through a lot of realloc(). Here the goal is to\n+       * see if we can minimize the number of reallocations. Again the\n+       * state is recorded in allocationMonitor by decrementing it\n+       * (negative value). If a threshold is hit, realloc will try to\n+       * allocate more memory in order to possibly avoid a future realloc.\n+       * This case is also applicable to setSafe() methods which can trigger\n+       * a realloc() and thus we record the state there as well.\n+       */\n+      if (valueCount > 0) {\n+         if (currentValueCapacity >= (valueCount * 2)) {\n+            incrementAllocationMonitor();\n+         } else if (currentValueCapacity <= (valueCount/2)) {\n+            decrementAllocationMonitor();\n+         }\n+      }\n+   }\n+\n+\n+   /**\n+    * Check if the given index is within the current value capacity\n+    * of the vector\n+    *\n+    * @param index  position to check\n+    * @return true if index is within the current value capacity\n+    */\n+   public boolean isSafe(int index) {\n+      return index < getValueCapacity();\n+   }\n+\n+\n+   /**\n+    * Check if element at given index is null.\n+    *\n+    * @param index  position of element\n+    * @return true if element at given index is null, false otherwise\n+    */\n+   public boolean isNull(int index) {\n+      return (isSet(index) == 0);\n+   }\n+\n+\n+   /**\n+    * Same as {@link #isNull(int)}.\n+    *\n+    * @param index  position of element\n+    * @return 1 if element at given index is not null, 0 otherwise\n+    */\n+   public int isSet(int index) {\n+      final int byteIndex = index >> 3;\n+      final byte b = validityBuffer.getByte(byteIndex);\n+      final int bitIndex = index & 7;\n+      return Long.bitCount(b & (1L << bitIndex));\n+   }\n+\n+   public void setIndexDefined(int index) {\n+      handleSafe(index);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+   }\n+\n+   public void set(int index, byte[] value, int start, int length) {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   public void setSafe(int index, byte[] value, int start, int length) {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   public void set(int index, ByteBuffer value, int start, int length) {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   public void setSafe(int index, ByteBuffer value, int start, int length) {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                helper methods for setters                      *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+\n+   protected void handleSafe(int index) {\n+      while (index >= getValueCapacity()) {\n+         decrementAllocationMonitor();\n+         reAlloc();\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java b/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\nnew file mode 100644\nindex 000000000..a79709da4\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n@@ -0,0 +1,764 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public abstract class BaseNullableVariableWidthVector extends BaseValueVector\n+        implements VariableWidthVector, FieldVector {\n+   private static final int DEFAULT_RECORD_BYTE_COUNT = 8;\n+   private static final int INITIAL_BYTE_COUNT = INITIAL_VALUE_ALLOCATION * DEFAULT_RECORD_BYTE_COUNT;\n+\n+   private int valueAllocationSizeInBytes;\n+   private int validityAllocationSizeInBytes;\n+   private int offsetAllocationSizeInBytes;\n+\n+   /* protected members */\n+   protected static final int OFFSET_WIDTH = 4; /* 4 byte unsigned int to track offsets */\n+   protected static final byte[] emptyByteArray = new byte[]{};\n+   protected ArrowBuf validityBuffer;\n+   protected ArrowBuf valueBuffer;\n+   protected ArrowBuf offsetBuffer;\n+   protected int valueCount;\n+   protected int lastSet;\n+   protected final Field field;\n+   private boolean cleared;\n+\n+   public BaseNullableVariableWidthVector(final String name, final BufferAllocator allocator,\n+                                          FieldType fieldType) {\n+      super(name, allocator);\n+      valueAllocationSizeInBytes = INITIAL_BYTE_COUNT;\n+      validityAllocationSizeInBytes = getSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+      offsetAllocationSizeInBytes = (INITIAL_VALUE_ALLOCATION) * OFFSET_WIDTH;\n+      field = new Field(name, fieldType, null);\n+      valueCount = 0;\n+      lastSet = -1;\n+      offsetBuffer = allocator.getEmpty();\n+      validityBuffer = allocator.getEmpty();\n+      valueBuffer = allocator.getEmpty();\n+      cleared = false;\n+   }\n+\n+  /* TODO:\n+    * Determine how writerIndex and readerIndex need to be used. Right now we\n+    * are setting the writerIndex and readerIndex in the call to getFieldBuffers\n+    * using the valueCount -- this assumes that the caller of getFieldBuffers\n+    * on the vector has already invoked setValueCount.\n+    *\n+    * Do we need to set them during vector transfer and splitAndTransfer?\n+    */\n+\n+   /* TODO:\n+    *\n+    * see if getNullCount() can be made faster -- O(1)\n+    */\n+\n+   /* TODO:\n+    * Once the entire hierarchy has been refactored, move common functions\n+    * like getNullCount(), splitAndTransferValidityBuffer to top level\n+    * base class BaseValueVector.\n+    *\n+    * Along with this, some class members (validityBuffer) can also be\n+    * abstracted out to top level base class.\n+    *\n+    * Right now BaseValueVector is the top level base class for other\n+    * vector types in ValueVector hierarchy and those vectors have not\n+    * yet been refactored so moving things to the top class as of now\n+    * is not a good idea.\n+    */\n+\n+   /* TODO:\n+    * See if we need logger -- unnecessary object probably\n+    */\n+\n+   /* TODO:\n+    * Implement getBufferSize(), getCurrentSizeInBytes().\n+    */\n+\n+   protected abstract org.slf4j.Logger getLogger();\n+\n+   public VariableWidthMutator getMutator() {\n+      throw new  UnsupportedOperationException(\"Mutator is not needed to write into vector\");\n+   }\n+\n+   public VariableWidthAccessor getAccessor() {\n+      throw new UnsupportedOperationException(\"Accessor is not needed to read from vector\");\n+   }\n+\n+   @Override\n+   public ArrowBuf getValidityBuffer() {\n+      return validityBuffer;\n+   }\n+\n+   @Override\n+   public ArrowBuf getDataBuffer() {\n+      return valueBuffer;\n+   }\n+\n+   @Override\n+   public ArrowBuf getOffsetBuffer() {\n+      return offsetBuffer;\n+   }\n+\n+   @Override\n+   public long getOffsetBufferAddress() {\n+      return offsetBuffer.memoryAddress();\n+   }\n+\n+   @Override\n+   public long getValidityBufferAddress() {\n+      return validityBuffer.memoryAddress();\n+   }\n+\n+   @Override\n+   public long getDataBufferAddress() {\n+      return valueBuffer.memoryAddress();\n+   }\n+\n+   @Override\n+   public void setInitialCapacity(int valueCount) {\n+      final long size = (long)valueCount * DEFAULT_RECORD_BYTE_COUNT;\n+      if (size > MAX_ALLOCATION_SIZE) {\n+         throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+      }\n+      valueAllocationSizeInBytes = (int)size;\n+      validityAllocationSizeInBytes = getSizeFromCount(valueCount);\n+      /* to track the end offset of last data element in vector, we need\n+       * an additional slot in offset buffer.\n+       */\n+      offsetAllocationSizeInBytes = (valueCount + 1) * OFFSET_WIDTH;\n+   }\n+\n+   @Override\n+   public int getValueCapacity(){\n+      final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+      return Math.min(offsetValueCapacity, getValidityBufferValueCapacity());\n+   }\n+\n+   /* for test purposes */\n+   private int getValidityBufferValueCapacity() {\n+      return (int)(validityBuffer.capacity() * 8L);\n+   }\n+\n+   /* for test purposes */\n+   private int getOffsetBufferValueCapacity() {\n+      return (int)((offsetBuffer.capacity() * 1.0)/OFFSET_WIDTH);\n+   }\n+\n+   /* number of bytes for the validity buffer for a given valueCount */\n+   protected int getSizeFromCount(int valueCount) {\n+      return (int) Math.ceil(valueCount / 8.0);\n+   }\n+\n+   public void zeroVector() {\n+      initValidityBuffer();\n+      initOffsetBuffer();\n+   }\n+\n+   private void initValidityBuffer() {\n+      validityBuffer.setZero(0, validityBuffer.capacity());\n+   }\n+\n+   private void initOffsetBuffer() {\n+      offsetBuffer.setZero(0, offsetBuffer.capacity());\n+   }\n+\n+   public void reset() {\n+      zeroVector();\n+      lastSet = -1;\n+   }\n+\n+   @Override\n+   public void close() {\n+      clear();\n+   }\n+\n+   @Override\n+   public void clear() {\n+      validityBuffer = releaseBuffer(validityBuffer);\n+      valueBuffer = releaseBuffer(valueBuffer);\n+      offsetBuffer = releaseBuffer(offsetBuffer);\n+      cleared = true;\n+      lastSet = -1;\n+      valueCount = 0;\n+   }\n+\n+   @Override\n+   public List<BufferBacked> getFieldInnerVectors() { throw new UnsupportedOperationException(); }\n+\n+   @Override\n+   public void initializeChildrenFromFields(List<Field> children) {\n+      if (!children.isEmpty()) {\n+         throw new IllegalArgumentException(\"primitive type vector can not have children\");\n+      }\n+   }\n+\n+   @Override\n+   public List<FieldVector> getChildrenFromFields() {\n+      return Collections.emptyList();\n+   }\n+\n+   @Override\n+   public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+      ArrowBuf bitBuffer = ownBuffers.get(0);\n+      ArrowBuf offBuffer = ownBuffers.get(1);\n+      ArrowBuf dataBuffer = ownBuffers.get(2);\n+\n+      validityBuffer.release();\n+      validityBuffer = bitBuffer.retain(allocator);\n+      offsetBuffer.release();\n+      offsetBuffer = offBuffer.retain(allocator);\n+      valueBuffer.release();\n+      valueBuffer = dataBuffer.retain(allocator);\n+\n+      lastSet = fieldNode.getLength() - 1;\n+      valueCount = fieldNode.getLength();\n+   }\n+\n+   public List<ArrowBuf> getFieldBuffers() {\n+      List<ArrowBuf> result = new ArrayList<>(3);\n+      final int lastDataOffset = getstartOffset(valueCount);\n+      validityBuffer.readerIndex(0);\n+      validityBuffer.writerIndex(getSizeFromCount(valueCount));\n+      offsetBuffer.readerIndex(0);\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+      valueBuffer.readerIndex(0);\n+      valueBuffer.writerIndex(lastDataOffset);\n+\n+      result.add(validityBuffer);\n+      result.add(offsetBuffer);\n+      result.add(valueBuffer);\n+\n+      return result;\n+   }\n+\n+   @Override\n+   public void allocateNew() {\n+      if(!allocateNewSafe()){\n+         throw new OutOfMemoryException(\"Failure while allocating memory.\");\n+      }\n+   }\n+\n+   @Override\n+   public boolean allocateNewSafe() {\n+      long curAllocationSizeValue = valueAllocationSizeInBytes;\n+      long curAllocationSizeValidity = validityAllocationSizeInBytes;\n+      long curAllocationSizeOffset = offsetAllocationSizeInBytes;\n+\n+      if (curAllocationSizeValue > MAX_ALLOCATION_SIZE ||\n+              curAllocationSizeOffset > MAX_ALLOCATION_SIZE) {\n+         throw new OversizedAllocationException(\"Requested amount of memory exceeds limit\");\n+      }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+\n+      try {\n+         allocateBytes(curAllocationSizeValue, curAllocationSizeValidity, curAllocationSizeOffset);\n+      } catch (Exception e) {\n+         getLogger().error(\"ERROR: Failure in allocateNewSafe\");\n+         getLogger().error(e.getMessage());\n+         clear();\n+         return false;\n+      }\n+\n+      return true;\n+   }\n+\n+   @Override\n+   public void allocateNew(int totalBytes, int valueCount) {\n+      assert totalBytes >= 0;\n+      final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+      final int validityBufferSize = getSizeFromCount(valueCount);\n+\n+      if (totalBytes > MAX_ALLOCATION_SIZE ||\n+              offsetBufferSize > MAX_ALLOCATION_SIZE) {\n+         throw new OversizedAllocationException(\"Requested amount of memory exceeds limit\");\n+      }\n+\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+\n+      try {\n+         allocateBytes(totalBytes, validityBufferSize, offsetBufferSize);\n+      } catch (Exception e) {\n+         getLogger().error(\"ERROR: Failure in allocateNewSafe\");\n+         getLogger().error(e.getMessage());\n+         clear();\n+      }\n+   }\n+\n+   private void allocateBytes(final long valueBufferSize, final long validityBufferSize,\n+                              final long offsetBufferSize) {\n+      /* allocate data buffer */\n+      int curSize = (int)valueBufferSize;\n+      valueBuffer = allocator.buffer(curSize);\n+      valueBuffer.readerIndex(0);\n+      valueAllocationSizeInBytes = curSize;\n+      allocateValidityBuffer(validityBufferSize);\n+      allocateOffsetBuffer(offsetBufferSize);\n+   }\n+\n+   private void allocateOffsetBuffer(final long size) {\n+      final int curSize = (int)size;\n+      offsetBuffer = allocator.buffer(curSize);\n+      offsetBuffer.readerIndex(0);\n+      offsetAllocationSizeInBytes = curSize;\n+      initOffsetBuffer();\n+   }\n+\n+   private void allocateValidityBuffer(final long size) {\n+      final int curSize = (int)size;\n+      validityBuffer = allocator.buffer(curSize);\n+      validityBuffer.readerIndex(0);\n+      validityAllocationSizeInBytes = curSize;\n+      initValidityBuffer();\n+   }\n+\n+   public void reAlloc() {\n+      reallocValueBuffer();\n+      reallocValidityAndOffsetBuffers();\n+   }\n+\n+   protected void reallocValueBuffer() {\n+      long baseSize = valueAllocationSizeInBytes;\n+      final int currentBufferCapacity = valueBuffer.capacity();\n+\n+      if (baseSize < (long)currentBufferCapacity) {\n+         baseSize = (long)currentBufferCapacity;\n+      }\n+\n+      long newAllocationSize = baseSize * 2L;\n+      newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+      if (newAllocationSize > MAX_ALLOCATION_SIZE)  {\n+         throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+      }\n+\n+      final ArrowBuf newBuf = allocator.buffer((int)newAllocationSize);\n+      newBuf.setBytes(0, valueBuffer, 0, currentBufferCapacity);\n+      valueBuffer.release();\n+      valueBuffer = newBuf;\n+      valueAllocationSizeInBytes = (int)newAllocationSize;\n+   }\n+\n+   protected void reallocValidityAndOffsetBuffers() {\n+      offsetBuffer = reallocBufferHelper(offsetBuffer, true);\n+      validityBuffer = reallocBufferHelper(validityBuffer, false);\n+   }\n+\n+   /* need to refactor this to keep the logic in an single place and make callers\n+    * more intelligent. see handleSafe() for more comments on realloc\n+    */\n+\n+   private ArrowBuf reallocBufferHelper(ArrowBuf buffer, final boolean offsetBuffer) {\n+      final int currentBufferCapacity = buffer.capacity();\n+      long baseSize  = (offsetBuffer ? offsetAllocationSizeInBytes\n+              : validityAllocationSizeInBytes);\n+\n+      if (baseSize < (long)currentBufferCapacity) {\n+         baseSize = (long)currentBufferCapacity;\n+      }\n+\n+      long newAllocationSize = baseSize * 2L;\n+      newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+      if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+         throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+      }\n+\n+      getLogger().debug(\"Reallocating vector [{}]. # of bytes: [{}] -> [{}]\",\n+              name, (offsetBuffer ? offsetAllocationSizeInBytes : validityAllocationSizeInBytes),\n+              newAllocationSize);\n+\n+      final ArrowBuf newBuf = allocator.buffer((int)newAllocationSize);\n+      newBuf.setBytes(0, buffer, 0, currentBufferCapacity);\n+      final int halfNewCapacity = newBuf.capacity() / 2;\n+      newBuf.setZero(halfNewCapacity, halfNewCapacity);\n+      buffer.release(1);\n+      buffer = newBuf;\n+      if (offsetBuffer) {\n+         offsetAllocationSizeInBytes = (int)newAllocationSize;\n+      }\n+      else {\n+         validityAllocationSizeInBytes = (int)newAllocationSize;\n+      }\n+\n+      return buffer;\n+   }\n+\n+   @Override\n+   public int getByteCapacity(){\n+      return valueBuffer.capacity();\n+   }\n+\n+   @Override\n+   public int getCurrentSizeInBytes(){\n+      /* TODO */\n+      return 0;\n+   }\n+\n+   @Override\n+   public int getBufferSize() {\n+      /* TODO */\n+      return 0;\n+   }\n+\n+   @Override\n+   public int getBufferSizeFor(final int valueCount) {\n+      if (valueCount == 0) {\n+         return 0;\n+      }\n+\n+      final int validityBufferSize = getSizeFromCount(valueCount);\n+      final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+      /* get the end offset for this valueCount */\n+      final int dataBufferSize = offsetBuffer.getInt(valueCount * OFFSET_WIDTH);\n+      return validityBufferSize + offsetBufferSize + dataBufferSize;\n+   }\n+\n+   @Override\n+   public Field getField() {\n+      return field;\n+   }\n+\n+   @Override\n+   public ArrowBuf[] getBuffers(boolean clear) {\n+      final ArrowBuf[] buffers = new ArrowBuf[3];\n+      buffers[0] = validityBuffer;\n+      buffers[1] = offsetBuffer;\n+      buffers[1] = valueBuffer;\n+      if (clear) {\n+         for (final ArrowBuf buffer:buffers) {\n+            buffer.retain(1);\n+         }\n+         clear();\n+      }\n+      return buffers;\n+   }\n+\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+      return getTransferPair(ref, allocator);\n+   }\n+\n+   @Override\n+   public TransferPair getTransferPair(BufferAllocator allocator){\n+      return getTransferPair(name, allocator);\n+   }\n+\n+   public abstract TransferPair getTransferPair(String ref, BufferAllocator allocator);\n+\n+   public void transferTo(BaseNullableVariableWidthVector target){\n+      compareTypes(target, \"transferTo\");\n+      target.clear();\n+      target.validityBuffer = validityBuffer.transferOwnership(target.allocator).buffer;\n+      target.valueBuffer = valueBuffer.transferOwnership(target.allocator).buffer;\n+      target.offsetBuffer = offsetBuffer.transferOwnership(target.allocator).buffer;\n+      target.valueCount = valueCount;\n+      target.setLastSet(lastSet);\n+      clear();\n+   }\n+\n+   public void splitAndTransferTo(int startIndex, int length,\n+                                  BaseNullableVariableWidthVector target) {\n+      compareTypes(target, \"splitAndTransferTo\");\n+      target.clear();\n+      splitAndTransferValidityBuffer(startIndex, length, target);\n+      splitAndTransferOffsetBuffer(startIndex, length, target);\n+      target.setLastSet(length - 1);\n+      target.setValueCount(length);\n+   }\n+\n+   /*\n+    * transfer the offsets along with data\n+    */\n+   private void splitAndTransferOffsetBuffer(int startIndex, int length, BaseNullableVariableWidthVector target) {\n+      final int start = offsetBuffer.getInt(startIndex * OFFSET_WIDTH);\n+      final int end = offsetBuffer.getInt((startIndex + length) * OFFSET_WIDTH);\n+      final int dataLength = end - start;\n+      target.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+      for (int i = 0; i < length + 1; i++) {\n+         final int relativeSourceOffset = offsetBuffer.getInt((startIndex + i) * OFFSET_WIDTH) - start;\n+         target.offsetBuffer.setInt(i * OFFSET_WIDTH, relativeSourceOffset);\n+      }\n+      target.valueBuffer = valueBuffer.slice(start, dataLength).transferOwnership(target.allocator).buffer;\n+   }\n+\n+   /*\n+    * transfer the validity.\n+    */\n+   private void splitAndTransferValidityBuffer(int startIndex, int length,\n+                                               BaseNullableVariableWidthVector target) {\n+      assert startIndex + length <= valueCount;\n+      int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+      int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+      int byteSizeTarget = getSizeFromCount(length);\n+      int offset = startIndex % 8;\n+\n+      if (length > 0) {\n+         if (offset == 0) {\n+            // slice\n+            if (target.validityBuffer != null) {\n+               target.validityBuffer.release();\n+            }\n+            target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+            target.validityBuffer.retain(1);\n+         }\n+         else {\n+            /* Copy data\n+             * When the first bit starts from the middle of a byte (offset != 0),\n+             * copy data from src BitVector.\n+             * Each byte in the target is composed by a part in i-th byte,\n+             * another part in (i+1)-th byte.\n+             */\n+            target.allocateValidityBuffer(byteSizeTarget);\n+\n+            for (int i = 0; i < byteSizeTarget - 1; i++) {\n+               byte b1 = getBitsFromCurrentByte(this.validityBuffer, firstByteSource + i, offset);\n+               byte b2 = getBitsFromNextByte(this.validityBuffer, firstByteSource + i + 1, offset);\n+\n+               target.validityBuffer.setByte(i, (b1 + b2));\n+            }\n+\n+            /* Copying the last piece is done in the following manner:\n+             * if the source vector has 1 or more bytes remaining, we copy\n+             * the last piece as a byte formed by shifting data\n+             * from the current byte and the next byte.\n+             *\n+             * if the source vector has no more bytes remaining\n+             * (we are at the last byte), we copy the last piece as a byte\n+             * by shifting data from the current byte.\n+             */\n+            if((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+               byte b1 = getBitsFromCurrentByte(this.validityBuffer,\n+                       firstByteSource + byteSizeTarget - 1, offset);\n+               byte b2 = getBitsFromNextByte(this.validityBuffer,\n+                       firstByteSource + byteSizeTarget, offset);\n+\n+               target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+            }\n+            else {\n+               byte b1 = getBitsFromCurrentByte(this.validityBuffer,\n+                       firstByteSource + byteSizeTarget - 1, offset);\n+               target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+            }\n+         }\n+      }\n+   }\n+\n+   private static byte getBitsFromCurrentByte(ArrowBuf data, int index, int offset) {\n+      return (byte)((data.getByte(index) & 0xFF) >>> offset);\n+   }\n+\n+   private static byte getBitsFromNextByte(ArrowBuf data, int index, int offset) {\n+      return (byte)((data.getByte(index) << (8 - offset)));\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                common getters and setters                      *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the number of elements that are null in the vector\n+    *\n+    * @return the number of null elements.\n+    */\n+   public int getNullCount() {\n+      int count = 0;\n+      final int sizeInBytes = getSizeFromCount(valueCount);\n+\n+      for (int i = 0; i < sizeInBytes; ++i) {\n+         final byte byteValue = validityBuffer.getByte(i);\n+         /* Java uses two's complement binary representation, hence 11111111_b which is -1\n+          * when converted to Int will have 32bits set to 1. Masking the MSB and then\n+          * adding it back solves the issue.\n+          */\n+         count += Integer.bitCount(byteValue & 0x7F) - (byteValue >> 7);\n+      }\n+      int nullCount = (sizeInBytes * 8) - count;\n+      /* if the valueCount is not a multiple of 8,\n+       * the bits on the right were counted as null bits.\n+       */\n+      int remainder = valueCount % 8;\n+      nullCount -= remainder == 0 ? 0 : 8 - remainder;\n+      return nullCount;\n+   }\n+\n+   /**\n+    * Check if the given index is within the current value capacity\n+    * of the vector\n+    *\n+    * @param index  position to check\n+    * @return true if index is within the current value capacity\n+    */\n+   public boolean isSafe(int index) {\n+      return index < getValueCapacity();\n+   }\n+\n+   /**\n+    * Check if element at given index is null.\n+    *\n+    * @param index  position of element\n+    * @return true if element at given index is null\n+    */\n+   public boolean isNull(int index) {\n+      return (isSet(index) == 0);\n+   }\n+\n+   /**\n+    * Same as {@link #isNull(int)}.\n+    *\n+    * @param index  position of element\n+    * @return 1 if element at given index is not null, 0 otherwise\n+    */\n+   public int isSet(int index) {\n+      final int byteIndex = index >> 3;\n+      final byte b = validityBuffer.getByte(byteIndex);\n+      final int bitIndex = index & 7;\n+      return Long.bitCount(b & (1L << bitIndex));\n+   }\n+\n+   /**\n+    * Get the value count of vector. This will always be zero unless\n+    * setValueCount(int) has been called prior to calling this.\n+    *\n+    * @return valueCount for the vector\n+    */\n+   public int getValueCount(){\n+      return valueCount;\n+   }\n+\n+   /**\n+    * Sets the value count for the vector\n+    *\n+    * @param valueCount   value count\n+    */\n+   public void setValueCount(int valueCount) {\n+      assert valueCount >= 0;\n+      this.valueCount = valueCount;\n+      while (valueCount > getValueCapacity()) {\n+         reallocValidityAndOffsetBuffers();\n+      }\n+      fillHoles(valueCount);\n+      lastSet = valueCount - 1;\n+   }\n+\n+   public void fillEmpties(int index) {\n+      handleSafe(index, emptyByteArray.length);\n+      fillHoles(index);\n+      lastSet = index - 1;\n+   }\n+\n+   public void setLastSet(int value) {\n+      lastSet = value;\n+   }\n+\n+   public int getLastSet() {\n+      return lastSet;\n+   }\n+\n+   public long getStartEnd(int index) {\n+      return (long)offsetBuffer.getInt(index * OFFSET_WIDTH);\n+   }\n+\n+   public void setIndexDefined(int index) {\n+      handleSafe(index, 0);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                helper methods for setters                      *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   protected final void fillHoles(int index) {\n+      for (int i = lastSet + 1; i < index; i++) {\n+         setBytes(i, emptyByteArray, 0, emptyByteArray.length);\n+      }\n+      lastSet = index - 1;\n+   }\n+\n+   protected final void setBytes(int index, byte[] value, int start, int length) {\n+      /* end offset of current last element in the vector. this will\n+       * be the start offset of new element we are trying to store.\n+       */\n+      final int startOffset = getstartOffset(index);\n+      /* set new end offset */\n+      offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + length);\n+      /* store the var length data in value buffer */\n+      valueBuffer.setBytes(startOffset, value, start, length);\n+   }\n+\n+   protected final int getstartOffset(int index) {\n+      return offsetBuffer.getInt(index * OFFSET_WIDTH);\n+   }\n+\n+   protected final void handleSafe(int index, int dataLength) {\n+      /*\n+       * IMPORTANT:\n+       * value buffer for variable length vectors moves independent\n+       * of the companion validity and offset buffers. This is in\n+       * contrast to what we have for fixed width vectors.\n+       *\n+       * Here there is no concept of getValueCapacity() in the\n+       * data stream. getValueCapacity() is applicable only to validity\n+       * and offset buffers.\n+       *\n+       * So even though we may have setup an initial capacity of 1024\n+       * elements in the vector, it is quite possible\n+       * that we need to reAlloc() the data buffer when we are setting\n+       * the 5th element in the vector simply because previous\n+       * variable length elements have exhausted the buffer capacity.\n+       * However, we really don't need to reAlloc() validity and\n+       * offset buffers until we try to set the 1025th element\n+       * This is why we do a separate check for safe methods to\n+       * determine which buffer needs reallocation.\n+       */\n+      while (index >= getValueCapacity()) {\n+         reallocValidityAndOffsetBuffers();\n+      }\n+      final int startOffset = getstartOffset(index);\n+      while (valueBuffer.capacity() < (startOffset + dataLength)) {\n+         reallocValueBuffer();\n+      }\n+   }\n+}\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BaseValueVector.java b/java/vector/src/main/java/org/apache/arrow/vector/BaseValueVector.java\nindex 598e578e5..1db962464 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/BaseValueVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BaseValueVector.java\n@@ -18,8 +18,10 @@\n \n package org.apache.arrow.vector;\n \n+import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Iterator;\n+import java.util.List;\n \n import com.google.flatbuffers.FlatBufferBuilder;\n import org.apache.arrow.memory.BufferAllocator;\n@@ -122,5 +124,23 @@ public static boolean checkBufRefs(final ValueVector vv) {\n   public BufferAllocator getAllocator() {\n     return allocator;\n   }\n+\n+  protected void compareTypes(BaseValueVector target, String caller) {\n+    if (this.getMinorType() != target.getMinorType()) {\n+      throw new UnsupportedOperationException(caller + \" should have vectors of exact same type\");\n+    }\n+  }\n+\n+  protected ArrowBuf releaseBuffer(ArrowBuf buffer) {\n+    buffer.release();\n+    buffer = allocator.getEmpty();\n+    return buffer;\n+  }\n+\n+  public int getValueCount() { return 0; }\n+\n+  public void setValueCount(int valueCount) { }\n+\n+  public Object getObject(int index) { return null; }\n }\n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BitVectorHelper.java b/java/vector/src/main/java/org/apache/arrow/vector/BitVectorHelper.java\nnew file mode 100644\nindex 000000000..2439bd26e\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BitVectorHelper.java\n@@ -0,0 +1,60 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+class BitVectorHelper {\n+\n+   /**\n+    * Get the index of byte corresponding to bit index in validity buffer\n+    */\n+   protected static int byteIndex(int absoluteBitIndex) {\n+      return absoluteBitIndex >> 3;\n+   }\n+\n+   /**\n+    * Get the relative index of bit within the byte in validity buffer\n+    */\n+   private static int bitIndex(int absoluteBitIndex) {\n+      return absoluteBitIndex & 7;\n+   }\n+\n+   protected static void setValidityBitToOne(ArrowBuf validityBuffer, int index) {\n+      final int byteIndex = byteIndex(index);\n+      final int bitIndex = bitIndex(index);\n+      byte currentByte = validityBuffer.getByte(byteIndex);\n+      final byte bitMask = (byte) (1L << bitIndex);\n+      currentByte |= bitMask;\n+      validityBuffer.setByte(byteIndex, currentByte);\n+   }\n+\n+   protected static void setValidityBit(ArrowBuf validityBuffer, int index, int value) {\n+      final int byteIndex = byteIndex(index);\n+      final int bitIndex = bitIndex(index);\n+      byte currentByte = validityBuffer.getByte(byteIndex);\n+      final byte bitMask = (byte) (1L << bitIndex);\n+      if (value != 0) {\n+         currentByte |= bitMask;\n+      } else {\n+         currentByte -= (bitMask & currentByte);\n+      }\n+      validityBuffer.setByte(byteIndex, currentByte);\n+   }\n+}\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableIntVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableIntVector.java\nnew file mode 100644\nindex 000000000..26b19fa7b\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableIntVector.java\n@@ -0,0 +1,299 @@\n+/*******************************************************************************\n+\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ ******************************************************************************/\n+\n+package org.apache.arrow.vector;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.IntReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.IntHolder;\n+import org.apache.arrow.vector.holders.NullableIntHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.slf4j.Logger;\n+\n+/**\n+ * NullableIntVector implements a fixed width vector of values which could\n+ * be null. A validity buffer (bit vector) is maintained to track which\n+ * elements in the vector are null.\n+ */\n+public class NullableIntVector extends BaseNullableFixedWidthVector {\n+   private static final org.slf4j.Logger logger =\n+           org.slf4j.LoggerFactory.getLogger(NullableIntVector.class);\n+   private static final byte TYPE_WIDTH = 4;\n+   private final FieldReader reader;\n+\n+   public NullableIntVector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.INT.getType()),\n+              allocator);\n+   }\n+\n+   public NullableIntVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType, TYPE_WIDTH);\n+      reader = new IntReaderImpl(NullableIntVector.this);\n+   }\n+\n+   @Override\n+   protected org.slf4j.Logger getLogger() {\n+      return logger;\n+   }\n+\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.INT;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value retrieval methods                        *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the element at the given index from the vector.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public int get(int index) throws IllegalStateException {\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      return valueBuffer.getInt(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Get the element at the given index from the vector and\n+    * sets the state in holder. If element at given index\n+    * is null, holder.isSet will be zero.\n+    *\n+    * @param index   position of element\n+    */\n+   public void get(int index, NullableIntHolder holder){\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      holder.isSet = 1;\n+      holder.value = valueBuffer.getInt(index * TYPE_WIDTH);\n+   }\n+\n+   /**\n+    * Same as {@link #get(int)}.\n+    *\n+    * @param index   position of element\n+    * @return element at given index\n+    */\n+   public Integer getObject(int index) {\n+      if (isSet(index) == 0) {\n+         return null;\n+      } else {\n+         return get(index);\n+      }\n+   }\n+\n+   public void copyFrom(int fromIndex, int thisIndex, NullableIntVector from) {\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+      }\n+   }\n+\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableIntVector from) {\n+      handleSafe(thisIndex);\n+      copyFrom(fromIndex, thisIndex, from);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   private void setValue(int index, int value) {\n+      valueBuffer.setInt(index * TYPE_WIDTH, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the given value.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void set(int index, int value) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, value);\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    * If the value in holder is not indicated as set, element in the\n+    * at the given index will be null.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void set(int index, NullableIntHolder holder) throws IllegalArgumentException {\n+      if(holder.isSet < 0) {\n+         throw new IllegalArgumentException();\n+      }\n+      else if(holder.isSet > 0) {\n+         BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+         setValue(index, holder.value);\n+      }\n+      else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   /**\n+    * Set the element at the given index to the value set in data holder.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void set(int index, IntHolder holder){\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setValue(index, holder.value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, int)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param value   value of element\n+    */\n+   public void setSafe(int index, int value) {\n+      handleSafe(index);\n+      set(index, value);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableIntHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  nullable data holder for value of element\n+    */\n+   public void setSafe(int index, NullableIntHolder holder) throws IllegalArgumentException {\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, IntHolder)} except that it handles the\n+    * case when index is greater than or equal to existing\n+    * value capacity {@link #getValueCapacity()}.\n+    *\n+    * @param index   position of element\n+    * @param holder  data holder for value of element\n+    */\n+   public void setSafe(int index, IntHolder holder){\n+      handleSafe(index);\n+      set(index, holder);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   public void set(int index, int isSet, int valueField ) {\n+      if (isSet > 0) {\n+         set(index, valueField);\n+      } else {\n+         BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+      }\n+   }\n+\n+   public void setSafe(int index, int isSet, int valueField ) {\n+      handleSafe(index);\n+      set(index, isSet, valueField);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableIntVector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableIntVector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableIntVector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableIntVector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableIntVector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableIntVector.this);\n+      }\n+   }\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableVarCharVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableVarCharVector.java\nnew file mode 100644\nindex 000000000..b9021544b\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/NullableVarCharVector.java\n@@ -0,0 +1,451 @@\n+/*******************************************************************************\n+\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ ******************************************************************************/\n+\n+package org.apache.arrow.vector;\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.complex.impl.VarCharReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.VarCharHolder;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.Text;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+import java.nio.ByteBuffer;\n+\n+public class NullableVarCharVector extends BaseNullableVariableWidthVector {\n+   private static final org.slf4j.Logger logger =\n+           org.slf4j.LoggerFactory.getLogger(NullableIntVector.class);\n+   private final FieldReader reader;\n+\n+   public NullableVarCharVector(String name, BufferAllocator allocator) {\n+      this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.VARCHAR.getType()), allocator);\n+   }\n+\n+   public NullableVarCharVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+      super(name, allocator, fieldType);\n+      reader = new VarCharReaderImpl(NullableVarCharVector.this);\n+   }\n+\n+   @Override\n+   protected org.slf4j.Logger getLogger() {\n+      return logger;\n+   }\n+\n+   @Override\n+   public FieldReader getReader(){\n+      return reader;\n+   }\n+\n+   @Override\n+   public Types.MinorType getMinorType() {\n+      return Types.MinorType.VARCHAR;\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value getter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+   /**\n+    * Get the variable length element at specified index as byte array.\n+    *\n+    * @param index   position of element to get\n+    * @return array of bytes for non-null element, null otherwise\n+    */\n+   public byte[] get(int index) {\n+      assert index >= 0;\n+      if(isSet(index) == 0) {\n+         throw new IllegalStateException(\"Value at index is null\");\n+      }\n+      final int startOffset = getstartOffset(index);\n+      final int dataLength =\n+              offsetBuffer.getInt((index + 1) * OFFSET_WIDTH) - startOffset;\n+      final byte[] result = new byte[dataLength];\n+      valueBuffer.getBytes(startOffset, result, 0, dataLength);\n+      return result;\n+   }\n+\n+   /**\n+    * Get the variable length element at specified index as Text.\n+    *\n+    * @param index   position of element to get\n+    * @return Text object for non-null element, null otherwise\n+    */\n+   public Text getObject(int index) {\n+      Text result = new Text();\n+      byte[] b;\n+      try {\n+         b = get(index);\n+      } catch (IllegalStateException e) {\n+         return null;\n+      }\n+      result.set(b);\n+      return result;\n+   }\n+\n+   /**\n+    * Get the variable length element at specified index as Text.\n+    *\n+    * @param index   position of element to get\n+    * @return greater than 0 length for non-null element, 0 otherwise\n+    */\n+   public int getValueLength(int index) {\n+      assert index >= 0;\n+      if(isSet(index) == 0) {\n+         return 0;\n+      }\n+      final int startOffset = getstartOffset(index);\n+      final int dataLength =\n+              offsetBuffer.getInt((index + 1) * OFFSET_WIDTH) - startOffset;\n+      return dataLength;\n+   }\n+\n+   /**\n+    * Get the variable length element at specified index and sets the state\n+    * in provided holder.\n+    *\n+    * @param index   position of element to get\n+    * @param holder  data holder to be populated by this function\n+    */\n+   public void get(int index, NullableVarCharHolder holder){\n+      assert index >= 0;\n+      if(isSet(index) == 0) {\n+         holder.isSet = 0;\n+         return;\n+      }\n+      final int startOffset = getstartOffset(index);\n+      final int dataLength =\n+              offsetBuffer.getInt((index + 1) * OFFSET_WIDTH) - startOffset;\n+      holder.isSet = 1;\n+      holder.start = startOffset;\n+      holder.end = dataLength;\n+      holder.buffer = valueBuffer;\n+   }\n+\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *          vector value setter methods                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+\n+\n+   public void copyFrom(int fromIndex, int thisIndex, NullableVarCharVector from) {\n+      fillHoles(thisIndex);\n+      if (from.isSet(fromIndex) != 0) {\n+         set(thisIndex, from.get(fromIndex));\n+         lastSet = thisIndex;\n+      }\n+   }\n+\n+   public void copyFromSafe(int fromIndex, int thisIndex, NullableVarCharVector from) {\n+      fillEmpties(thisIndex);\n+      if (from.isSet(fromIndex) != 0) {\n+         setSafe(thisIndex, from.get(fromIndex));\n+         lastSet = thisIndex;\n+      }\n+   }\n+\n+\n+   /**\n+    * Set the variable length element at the specified index to the supplied\n+    * byte array. This is same as using {@link #set(int, byte[], int, int)}\n+    * with start as 0 and length as value.length\n+    *\n+    * @param index   position of the element to set\n+    * @param value   array of bytes to write\n+    */\n+   public void set(int index, byte[] value) {\n+      assert index >= 0;\n+      fillHoles(index);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setBytes(index, value, 0, value.length);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, byte[])} except that it handles the\n+    * case where index and length of new element are beyond the existing\n+    * capacity of the vector.\n+    *\n+    * @param index   position of the element to set\n+    * @param value   array of bytes to write\n+    */\n+   public void setSafe(int index, byte[] value) {\n+      assert index >= 0;\n+      fillEmpties(index);\n+      handleSafe(index, value.length);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setBytes(index, value, 0, value.length);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Set the variable length element at the specified index to the supplied\n+    * byte array.\n+    *\n+    * @param index   position of the element to set\n+    * @param value   array of bytes to write\n+    * @param start   start index in array of bytes\n+    * @param length  length of data in array of bytes\n+    */\n+   public void set(int index, byte[] value, int start, int length) {\n+      assert index >= 0;\n+      fillHoles(index);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setBytes(index, value, start, length);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, byte[], int, int)} except that it handles the\n+    * case where index and length of new element are beyond the existing\n+    * capacity of the vector.\n+    *\n+    * @param index   position of the element to set\n+    * @param value   array of bytes to write\n+    * @param start   start index in array of bytes\n+    * @param length  length of data in array of bytes\n+    */\n+   public void setSafe(int index, byte[] value, int start, int length) {\n+      assert index >= 0;\n+      fillEmpties(index);\n+      handleSafe(index, length);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      setBytes(index, value, start, length);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Set the variable length element at the specified index to the\n+    * content in supplied ByteBuffer\n+    *\n+    * @param index   position of the element to set\n+    * @param value   ByteBuffer with data\n+    * @param start   start index in ByteBuffer\n+    * @param length  length of data in ByteBuffer\n+    */\n+   public void set(int index, ByteBuffer value, int start, int length) {\n+      assert index >= 0;\n+      fillHoles(index);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      final int startOffset = getstartOffset(index);\n+      offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + length);\n+      valueBuffer.setBytes(startOffset, value, start, length);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, ByteBuffer, int, int)} except that it handles the\n+    * case where index and length of new element are beyond the existing\n+    * capacity of the vector.\n+    *\n+    * @param index   position of the element to set\n+    * @param value   ByteBuffer with data\n+    * @param start   start index in ByteBuffer\n+    * @param length  length of data in ByteBuffer\n+    */\n+   public void setSafe(int index, ByteBuffer value, int start, int length) {\n+      assert index >= 0;\n+      fillEmpties(index);\n+      handleSafe(index, length);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      final int startOffset = getstartOffset(index);\n+      offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + length);\n+      valueBuffer.setBytes(startOffset, value, start, length);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Set the variable length element at the specified index to the data\n+    * buffer supplied in the holder\n+    *\n+    * @param index   position of the element to set\n+    * @param holder  holder that carries data buffer.\n+    */\n+   public void set(int index, VarCharHolder holder) {\n+      assert index >= 0;\n+      fillHoles(index);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      final int dataLength = holder.end - holder.start;\n+      final int startOffset = getstartOffset(index);\n+      offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + dataLength);\n+      valueBuffer.setBytes(startOffset, holder.buffer, holder.start, dataLength);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, VarCharHolder)} except that it handles the\n+    * case where index and length of new element are beyond the existing\n+    * capacity of the vector.\n+    *\n+    * @param index   position of the element to set\n+    * @param holder  holder that carries data buffer.\n+    */\n+   public void setSafe(int index, VarCharHolder holder) {\n+      assert index >= 0;\n+      final int dataLength = holder.end - holder.start;\n+      fillEmpties(index);\n+      handleSafe(index, dataLength);\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      final int startOffset = getstartOffset(index);\n+      offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + dataLength);\n+      valueBuffer.setBytes(startOffset, holder.buffer, holder.start, dataLength);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Set the variable length element at the specified index to the data\n+    * buffer supplied in the holder\n+    *\n+    * @param index   position of the element to set\n+    * @param holder  holder that carries data buffer.\n+    */\n+   public void set(int index, NullableVarCharHolder holder) {\n+      assert index >= 0;\n+      fillHoles(index);\n+      BitVectorHelper.setValidityBit(validityBuffer, index, holder.isSet);\n+      final int dataLength = holder.end - holder.start;\n+      final int startOffset = getstartOffset(index);\n+      offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + dataLength);\n+      valueBuffer.setBytes(startOffset, holder.buffer, holder.start, dataLength);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Same as {@link #set(int, NullableVarCharHolder)} except that it handles the\n+    * case where index and length of new element are beyond the existing\n+    * capacity of the vector.\n+    *\n+    * @param index   position of the element to set\n+    * @param holder  holder that carries data buffer.\n+    */\n+   public void setSafe(int index, NullableVarCharHolder holder) {\n+      assert index >= 0;\n+      final int dataLength = holder.end - holder.start;\n+      fillEmpties(index);\n+      handleSafe(index, dataLength);\n+      BitVectorHelper.setValidityBit(validityBuffer, index, holder.isSet);\n+      final int startOffset = getstartOffset(index);\n+      offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + dataLength);\n+      valueBuffer.setBytes(startOffset, holder.buffer, holder.start, dataLength);\n+      lastSet = index;\n+   }\n+\n+   /**\n+    * Sets the value length for an element.\n+    *\n+    * @param index   position of the element to set\n+    * @param length  length of the element\n+    */\n+   public void setValueLengthSafe(int index, int length) {\n+      assert index >= 0;\n+      handleSafe(index, length);\n+      final int startOffset = getstartOffset(index);\n+      offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + length);\n+   }\n+\n+   /**\n+    * Set the element at the given index to null.\n+    *\n+    * @param index   position of element\n+    */\n+   public void setNull(int index){\n+      handleSafe(index, 0);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+   }\n+\n+   public void set(int index, int isSet, int startField, int endField, ArrowBuf bufferField ) {\n+      assert index >= 0;\n+      fillHoles(index);\n+      BitVectorHelper.setValidityBit(validityBuffer, index, isSet);\n+      final int startOffset = offsetBuffer.getInt(index * OFFSET_WIDTH);\n+      offsetBuffer.setInt((index + 1) * OFFSET_WIDTH, startOffset + endField);\n+      final ArrowBuf bb = bufferField.slice(startField, endField);\n+      valueBuffer.setBytes(startOffset, bb);\n+      lastSet = index;\n+   }\n+\n+   public void setSafe(int index, int isSet, int startField, int endField, ArrowBuf bufferField ) {\n+      assert index >= 0;\n+      handleSafe(index, endField);\n+      set(index, isSet, startField, endField, bufferField);\n+   }\n+\n+\n+   /******************************************************************\n+    *                                                                *\n+    *                      vector transfer                           *\n+    *                                                                *\n+    ******************************************************************/\n+\n+   @Override\n+   public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n+      return new TransferImpl(ref, allocator);\n+   }\n+\n+   @Override\n+   public TransferPair makeTransferPair(ValueVector to) {\n+      return new TransferImpl((NullableVarCharVector)to);\n+   }\n+\n+   private class TransferImpl implements TransferPair {\n+      NullableVarCharVector to;\n+\n+      public TransferImpl(String ref, BufferAllocator allocator){\n+         to = new NullableVarCharVector(ref, field.getFieldType(), allocator);\n+      }\n+\n+      public TransferImpl(NullableVarCharVector to){\n+         this.to = to;\n+      }\n+\n+      @Override\n+      public NullableVarCharVector getTo(){\n+         return to;\n+      }\n+\n+      @Override\n+      public void transfer(){\n+         transferTo(to);\n+      }\n+\n+      @Override\n+      public void splitAndTransfer(int startIndex, int length) {\n+         splitAndTransferTo(startIndex, length, to);\n+      }\n+\n+      @Override\n+      public void copyValueSafe(int fromIndex, int toIndex) {\n+         to.copyFromSafe(fromIndex, toIndex, NullableVarCharVector.this);\n+      }\n+   }\n+}\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/ValueVector.java b/java/vector/src/main/java/org/apache/arrow/vector/ValueVector.java\nindex fb7286f85..e6048b4b5 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/ValueVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/ValueVector.java\n@@ -255,4 +255,10 @@\n    * @return buffer\n    */\n   public ArrowBuf getOffsetBuffer();\n+\n+  public int getValueCount();\n+\n+  public void setValueCount(int valueCount);\n+\n+  public Object getObject(int index);\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/VectorUnloader.java b/java/vector/src/main/java/org/apache/arrow/vector/VectorUnloader.java\nindex f8385a726..96243eb58 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/VectorUnloader.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/VectorUnloader.java\n@@ -27,6 +27,8 @@\n import org.apache.arrow.vector.schema.ArrowRecordBatch;\n import org.apache.arrow.vector.schema.ArrowVectorType;\n \n+import javax.annotation.Nullable;\n+\n public class VectorUnloader {\n \n   private final VectorSchemaRoot root;\n@@ -53,8 +55,17 @@ public ArrowRecordBatch getRecordBatch() {\n   }\n \n   private void appendNodes(FieldVector vector, List<ArrowFieldNode> nodes, List<ArrowBuf> buffers) {\n-    Accessor accessor = vector.getAccessor();\n-    nodes.add(new ArrowFieldNode(accessor.getValueCount(), includeNullCount ? accessor.getNullCount() : -1));\n+    Accessor accessor = null;\n+    if (vector instanceof NullableIntVector) {\n+      nodes.add(new ArrowFieldNode(((NullableIntVector)vector).getValueCount(),\n+                includeNullCount ? ((NullableIntVector)vector).getNullCount() : -1));\n+    } else if (vector instanceof NullableVarCharVector) {\n+      nodes.add(new ArrowFieldNode(((NullableVarCharVector)vector).getValueCount(),\n+                includeNullCount ? ((NullableVarCharVector)vector).getNullCount() : -1));\n+    } else {\n+      accessor = vector.getAccessor();\n+      nodes.add(new ArrowFieldNode(accessor.getValueCount(), includeNullCount ? accessor.getNullCount() : -1));\n+    }\n     List<ArrowBuf> fieldBuffers = vector.getFieldBuffers();\n     List<ArrowVectorType> expectedBuffers = vector.getField().getTypeLayout().getVectorTypes();\n     if (fieldBuffers.size() != expectedBuffers.size()) {\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/ZeroVector.java b/java/vector/src/main/java/org/apache/arrow/vector/ZeroVector.java\nindex b267b2087..804e00174 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/ZeroVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/ZeroVector.java\n@@ -259,4 +259,13 @@ public ArrowBuf getDataBuffer() {\n   public ArrowBuf getOffsetBuffer() {\n     throw new UnsupportedOperationException();\n   }\n+\n+  @Override\n+  public int getValueCount() { return 0; }\n+\n+  @Override\n+  public void setValueCount(int valueCount) { }\n+\n+  @Override\n+  public Object getObject(int index) { return null; }\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/FixedSizeListVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/FixedSizeListVector.java\nindex b3be37541..e95442acf 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/FixedSizeListVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/FixedSizeListVector.java\n@@ -34,14 +34,7 @@\n import io.netty.buffer.ArrowBuf;\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.memory.OutOfMemoryException;\n-import org.apache.arrow.vector.AddOrGetResult;\n-import org.apache.arrow.vector.BaseDataValueVector;\n-import org.apache.arrow.vector.BaseValueVector;\n-import org.apache.arrow.vector.BitVector;\n-import org.apache.arrow.vector.BufferBacked;\n-import org.apache.arrow.vector.FieldVector;\n-import org.apache.arrow.vector.ValueVector;\n-import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.*;\n import org.apache.arrow.vector.complex.impl.UnionFixedSizeListReader;\n import org.apache.arrow.vector.schema.ArrowFieldNode;\n import org.apache.arrow.vector.types.Types.MinorType;\n@@ -331,9 +324,15 @@ public Object getObject(int index) {\n         return null;\n       }\n       final List<Object> vals = new JsonStringArrayList<>(listSize);\n-      final ValueVector.Accessor valuesAccessor = vector.getAccessor();\n-      for (int i = 0; i < listSize; i++) {\n-        vals.add(valuesAccessor.getObject(index * listSize + i));\n+      if (vector instanceof NullableIntVector || vector instanceof NullableVarCharVector) {\n+        for (int i = 0; i < listSize; i++) {\n+          vals.add(vector.getObject(index * listSize + i));\n+        }\n+      } else {\n+        final ValueVector.Accessor valuesAccessor = vector.getAccessor();\n+        for (int i = 0; i < listSize; i++) {\n+          vals.add(valuesAccessor.getObject(index * listSize + i));\n+        }\n       }\n       return vals;\n     }\n@@ -367,7 +366,11 @@ public void setNotNull(int index) {\n     @Override\n     public void setValueCount(int valueCount) {\n       bits.getMutator().setValueCount(valueCount);\n-      vector.getMutator().setValueCount(valueCount * listSize);\n+      if (vector instanceof  NullableIntVector || vector instanceof NullableVarCharVector) {\n+        vector.setValueCount(valueCount * listSize);\n+      } else {\n+        vector.getMutator().setValueCount(valueCount * listSize);\n+      }\n     }\n   }\n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\nindex 6511efcb7..258a46f55 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/ListVector.java\n@@ -32,15 +32,7 @@\n import io.netty.buffer.ArrowBuf;\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.memory.OutOfMemoryException;\n-import org.apache.arrow.vector.AddOrGetResult;\n-import org.apache.arrow.vector.BaseDataValueVector;\n-import org.apache.arrow.vector.BitVector;\n-import org.apache.arrow.vector.BufferBacked;\n-import org.apache.arrow.vector.FieldVector;\n-import org.apache.arrow.vector.UInt4Vector;\n-import org.apache.arrow.vector.ValueVector;\n-import org.apache.arrow.vector.VarCharVector;\n-import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.*;\n import org.apache.arrow.vector.complex.impl.ComplexCopier;\n import org.apache.arrow.vector.complex.impl.UnionListReader;\n import org.apache.arrow.vector.complex.impl.UnionListWriter;\n@@ -381,10 +373,18 @@ public Object getObject(int index) {\n       final UInt4Vector.Accessor offsetsAccessor = offsets.getAccessor();\n       final int start = offsetsAccessor.get(index);\n       final int end = offsetsAccessor.get(index + 1);\n-      final ValueVector.Accessor valuesAccessor = getDataVector().getAccessor();\n-      for (int i = start; i < end; i++) {\n-        vals.add(valuesAccessor.getObject(i));\n+      final ValueVector vv = getDataVector();\n+      if (vv instanceof  NullableIntVector || vv instanceof NullableVarCharVector) {\n+        for (int i = start; i < end; i++) {\n+          vals.add(vv.getObject(i));\n+        }\n+      } else {\n+        final ValueVector.Accessor valuesAccessor = vv.getAccessor();\n+        for (int i = start; i < end; i++) {\n+          vals.add(valuesAccessor.getObject(i));\n+        }\n       }\n+\n       return vals;\n     }\n \n@@ -437,7 +437,12 @@ public void setValueCount(int valueCount) {\n         offsets.getMutator().setValueCount(valueCount + 1);\n       }\n       final int childValueCount = valueCount == 0 ? 0 : offsets.getAccessor().get(valueCount);\n-      vector.getMutator().setValueCount(childValueCount);\n+      if (vector instanceof NullableIntVector || vector instanceof NullableVarCharVector) {\n+        vector.setValueCount(childValueCount);\n+      } else {\n+        vector.getMutator().setValueCount(childValueCount);\n+      }\n+\n       bits.getMutator().setValueCount(valueCount);\n     }\n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\nindex f46635ad7..95efa6087 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n@@ -35,9 +35,7 @@\n import io.netty.buffer.ArrowBuf;\n \n import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.vector.BaseValueVector;\n-import org.apache.arrow.vector.FieldVector;\n-import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.*;\n import org.apache.arrow.vector.complex.impl.SingleMapReaderImpl;\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.ComplexHolder;\n@@ -272,10 +270,19 @@ public Object getObject(int index) {\n       Map<String, Object> vv = new JsonStringHashMap<>();\n       for (String child : getChildFieldNames()) {\n         ValueVector v = getChild(child);\n-        if (v != null && index < v.getAccessor().getValueCount()) {\n-          Object value = v.getAccessor().getObject(index);\n-          if (value != null) {\n-            vv.put(child, value);\n+        if (v instanceof  NullableVarCharVector || v instanceof  NullableIntVector) {\n+          if (v != null && index < v.getValueCount()) {\n+            Object value = v.getObject(index);\n+            if (value != null) {\n+              vv.put(child, value);\n+            }\n+          }\n+        } else {\n+          if (v != null && index < v.getAccessor().getValueCount()) {\n+            Object value = v.getAccessor().getObject(index);\n+            if (value != null) {\n+              vv.put(child, value);\n+            }\n           }\n         }\n       }\n@@ -302,7 +309,11 @@ public ValueVector getVectorById(int id) {\n     @Override\n     public void setValueCount(int valueCount) {\n       for (final ValueVector v : getChildren()) {\n-        v.getMutator().setValueCount(valueCount);\n+        if (v instanceof NullableIntVector || v instanceof NullableVarCharVector) {\n+          v.setValueCount(valueCount);\n+        } else {\n+          v.getMutator().setValueCount(valueCount);\n+        }\n       }\n       MapVector.this.valueCount = valueCount;\n     }\n@@ -362,4 +373,10 @@ public void initializeChildrenFromFields(List<Field> children) {\n     return getChildren();\n   }\n \n+  public int getValueCount() { return 0; }\n+\n+  public void setValueCount(int valueCount) { }\n+\n+  public Object getObject(int index) { return null; }\n+\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileReader.java b/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileReader.java\nindex c6ebd61aa..27781f577 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileReader.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/file/json/JsonFileReader.java\n@@ -263,7 +263,7 @@ private void readVector(Field field, FieldVector vector) throws JsonParseExcepti\n           ((NullableVarBinaryVector) vector).getMutator().setLastSet(count - 1);\n           break;\n         case VARCHAR:\n-          ((NullableVarCharVector) vector).getMutator().setLastSet(count - 1);\n+          ((NullableVarCharVector) vector).setLastSet(count - 1);\n           break;\n       }\n       vector.getMutator().setValueCount(count);\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestBufferOwnershipTransfer.java b/java/vector/src/test/java/org/apache/arrow/vector/TestBufferOwnershipTransfer.java\nindex 1a801a63e..4fe286145 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestBufferOwnershipTransfer.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestBufferOwnershipTransfer.java\n@@ -40,7 +40,7 @@ public void testTransferFixedWidth() {\n \n     NullableIntVector v1 = new NullableIntVector(\"v1\", childAllocator1);\n     v1.allocateNew();\n-    v1.getMutator().setValueCount(4095);\n+    v1.setValueCount(4095);\n \n     NullableIntVector v2 = new NullableIntVector(\"v2\", childAllocator2);\n \n@@ -60,8 +60,8 @@ public void testTransferVariableidth() {\n \n     NullableVarCharVector v1 = new NullableVarCharVector(\"v1\", childAllocator1);\n     v1.allocateNew();\n-    v1.getMutator().setSafe(4094, \"hello world\".getBytes(), 0, 11);\n-    v1.getMutator().setValueCount(4001);\n+    v1.setSafe(4094, \"hello world\".getBytes(), 0, 11);\n+    v1.setValueCount(4001);\n \n     NullableVarCharVector v2 = new NullableVarCharVector(\"v2\", childAllocator2);\n \ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestDictionaryVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestDictionaryVector.java\nindex f8c16e7fc..1185246f8 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestDictionaryVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestDictionaryVector.java\n@@ -56,24 +56,22 @@ public void testEncodeStrings() {\n     // Create a new value vector\n     try (final NullableVarCharVector vector = newNullableVarCharVector(\"foo\", allocator);\n          final NullableVarCharVector dictionaryVector = newNullableVarCharVector(\"dict\", allocator);) {\n-      final NullableVarCharVector.Mutator m = vector.getMutator();\n       vector.allocateNew(512, 5);\n \n       // set some values\n-      m.setSafe(0, zero, 0, zero.length);\n-      m.setSafe(1, one, 0, one.length);\n-      m.setSafe(2, one, 0, one.length);\n-      m.setSafe(3, two, 0, two.length);\n-      m.setSafe(4, zero, 0, zero.length);\n-      m.setValueCount(5);\n+      vector.setSafe(0, zero, 0, zero.length);\n+      vector.setSafe(1, one, 0, one.length);\n+      vector.setSafe(2, one, 0, one.length);\n+      vector.setSafe(3, two, 0, two.length);\n+      vector.setSafe(4, zero, 0, zero.length);\n+      vector.setValueCount(5);\n \n       // set some dictionary values\n-      final NullableVarCharVector.Mutator m2 = dictionaryVector.getMutator();\n       dictionaryVector.allocateNew(512, 3);\n-      m2.setSafe(0, zero, 0, zero.length);\n-      m2.setSafe(1, one, 0, one.length);\n-      m2.setSafe(2, two, 0, two.length);\n-      m2.setValueCount(3);\n+      dictionaryVector.setSafe(0, zero, 0, zero.length);\n+      dictionaryVector.setSafe(1, one, 0, one.length);\n+      dictionaryVector.setSafe(2, two, 0, two.length);\n+      dictionaryVector.setValueCount(3);\n \n       Dictionary dictionary = new Dictionary(dictionaryVector, new DictionaryEncoding(1L, false, null));\n \n@@ -81,20 +79,20 @@ public void testEncodeStrings() {\n         // verify indices\n         assertEquals(NullableIntVector.class, encoded.getClass());\n \n-        NullableIntVector.Accessor indexAccessor = ((NullableIntVector) encoded).getAccessor();\n-        assertEquals(5, indexAccessor.getValueCount());\n-        assertEquals(0, indexAccessor.get(0));\n-        assertEquals(1, indexAccessor.get(1));\n-        assertEquals(1, indexAccessor.get(2));\n-        assertEquals(2, indexAccessor.get(3));\n-        assertEquals(0, indexAccessor.get(4));\n+        NullableIntVector index = ((NullableIntVector)encoded);\n+        assertEquals(5, index.getValueCount());\n+        assertEquals(0, index.get(0));\n+        assertEquals(1, index.get(1));\n+        assertEquals(1, index.get(2));\n+        assertEquals(2, index.get(3));\n+        assertEquals(0, index.get(4));\n \n         // now run through the decoder and verify we get the original back\n         try (ValueVector decoded = DictionaryEncoder.decode(encoded, dictionary)) {\n           assertEquals(vector.getClass(), decoded.getClass());\n-          assertEquals(vector.getAccessor().getValueCount(), decoded.getAccessor().getValueCount());\n+          assertEquals(vector.getValueCount(), ((NullableVarCharVector)decoded).getValueCount());\n           for (int i = 0; i < 5; i++) {\n-            assertEquals(vector.getAccessor().getObject(i), decoded.getAccessor().getObject(i));\n+            assertEquals(vector.getObject(i), ((NullableVarCharVector)decoded).getObject(i));\n           }\n         }\n       }\n@@ -106,21 +104,20 @@ public void testEncodeLargeVector() {\n     // Create a new value vector\n     try (final NullableVarCharVector vector = newNullableVarCharVector(\"foo\", allocator);\n          final NullableVarCharVector dictionaryVector = newNullableVarCharVector(\"dict\", allocator);) {\n-      final NullableVarCharVector.Mutator m = vector.getMutator();\n       vector.allocateNew();\n \n       int count = 10000;\n \n       for (int i = 0; i < 10000; ++i) {\n-        vector.getMutator().setSafe(i, data[i % 3], 0, data[i % 3].length);\n+        vector.setSafe(i, data[i % 3], 0, data[i % 3].length);\n       }\n-      vector.getMutator().setValueCount(count);\n+      vector.setValueCount(count);\n \n       dictionaryVector.allocateNew(512, 3);\n-      dictionaryVector.getMutator().setSafe(0, zero, 0, zero.length);\n-      dictionaryVector.getMutator().setSafe(1, one, 0, one.length);\n-      dictionaryVector.getMutator().setSafe(2, two, 0, two.length);\n-      dictionaryVector.getMutator().setValueCount(3);\n+      dictionaryVector.setSafe(0, zero, 0, zero.length);\n+      dictionaryVector.setSafe(1, one, 0, one.length);\n+      dictionaryVector.setSafe(2, two, 0, two.length);\n+      dictionaryVector.setValueCount(3);\n \n       Dictionary dictionary = new Dictionary(dictionaryVector, new DictionaryEncoding(1L, false, null));\n \n@@ -129,10 +126,10 @@ public void testEncodeLargeVector() {\n         // verify indices\n         assertEquals(NullableIntVector.class, encoded.getClass());\n \n-        NullableIntVector.Accessor indexAccessor = ((NullableIntVector) encoded).getAccessor();\n-        assertEquals(count, indexAccessor.getValueCount());\n+        NullableIntVector index = ((NullableIntVector) encoded);\n+        assertEquals(count, index.getValueCount());\n         for (int i = 0; i < count; ++i) {\n-          assertEquals(i % 3, indexAccessor.get(i));\n+          assertEquals(i % 3, index.get(i));\n         }\n \n         // now run through the decoder and verify we get the original back\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java\nindex 5677f2566..11cd62da5 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java\n@@ -53,15 +53,14 @@ public void terminate() throws Exception {\n   public void testIntType() {\n     try (FixedSizeListVector vector = FixedSizeListVector.empty(\"list\", 2, allocator)) {\n       NullableIntVector nested = (NullableIntVector) vector.addOrGetVector(FieldType.nullable(MinorType.INT.getType())).getVector();\n-      NullableIntVector.Mutator mutator = nested.getMutator();\n       vector.allocateNew();\n \n       for (int i = 0; i < 10; i++) {\n         vector.getMutator().setNotNull(i);\n-        mutator.set(i * 2, i);\n-        mutator.set(i * 2 + 1, i + 10);\n+        nested.set(i * 2, i);\n+        nested.set(i * 2 + 1, i + 10);\n       }\n-      vector.getMutator().setValueCount(10);\n+      vector.setValueCount(10);\n \n       UnionFixedSizeListReader reader = vector.getReader();\n       for (int i = 0; i < 10; i++) {\n@@ -118,7 +117,7 @@ public void testNestedInList() {\n       ListVector.Mutator mutator = vector.getMutator();\n       FixedSizeListVector tuples = (FixedSizeListVector) vector.addOrGetVector(FieldType.nullable(new ArrowType.FixedSizeList(2))).getVector();\n       FixedSizeListVector.Mutator tupleMutator = tuples.getMutator();\n-      NullableIntVector.Mutator innerMutator = (NullableIntVector.Mutator) tuples.addOrGetVector(FieldType.nullable(MinorType.INT.getType())).getVector().getMutator();\n+      NullableIntVector innerVector = (NullableIntVector) tuples.addOrGetVector(FieldType.nullable(MinorType.INT.getType())).getVector();\n       vector.allocateNew();\n \n       for (int i = 0; i < 10; i++) {\n@@ -126,8 +125,8 @@ public void testNestedInList() {\n           int position = mutator.startNewValue(i);\n           for (int j = 0; j < i % 7; j++) {\n             tupleMutator.setNotNull(position + j);\n-            innerMutator.set((position + j) * 2, j);\n-            innerMutator.set((position + j) * 2 + 1, j + 1);\n+            innerVector.set((position + j) * 2, j);\n+            innerVector.set((position + j) * 2 + 1, j + 1);\n           }\n           mutator.endValue(i, i % 7);\n         }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestSplitAndTransfer.java b/java/vector/src/test/java/org/apache/arrow/vector/TestSplitAndTransfer.java\nindex 66e5375e3..7de3bcb33 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestSplitAndTransfer.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestSplitAndTransfer.java\n@@ -25,7 +25,6 @@\n import org.apache.arrow.memory.RootAllocator;\n \n import org.apache.arrow.vector.NullableVarCharVector;\n-import org.apache.arrow.vector.NullableVarCharVector.Accessor;\n import org.apache.arrow.vector.util.TransferPair;\n \n import org.junit.After;\n@@ -54,32 +53,30 @@ public void test() throws Exception {\n             final int valueCount = 500;\n             final String[] compareArray = new String[valueCount];\n \n-            final NullableVarCharVector.Mutator mutator = varCharVector.getMutator();\n             for (int i = 0; i < valueCount; i += 3) {\n                 final String s = String.format(\"%010d\", i);\n-                mutator.set(i, s.getBytes());\n+                varCharVector.set(i, s.getBytes());\n                 compareArray[i] = s;\n             }\n-            mutator.setValueCount(valueCount);\n+            varCharVector.setValueCount(valueCount);\n \n             final TransferPair tp = varCharVector.getTransferPair(allocator);\n             final NullableVarCharVector newVarCharVector = (NullableVarCharVector) tp.getTo();\n-            final Accessor accessor = newVarCharVector.getAccessor();\n             final int[][] startLengths = {{0, 201}, {201, 200}, {401, 99}};\n \n             for (final int[] startLength : startLengths) {\n                 final int start = startLength[0];\n                 final int length = startLength[1];\n                 tp.splitAndTransfer(start, length);\n-                newVarCharVector.getMutator().setValueCount(length);\n+                newVarCharVector.setValueCount(length);\n                 for (int i = 0; i < length; i++) {\n                     final boolean expectedSet = ((start + i) % 3) == 0;\n                     if (expectedSet) {\n                         final byte[] expectedValue = compareArray[start + i].getBytes();\n-                        assertFalse(accessor.isNull(i));\n-                        assertArrayEquals(expectedValue, accessor.get(i));\n+                        assertFalse(newVarCharVector.isNull(i));\n+                        assertArrayEquals(expectedValue, newVarCharVector.get(i));\n                     } else {\n-                        assertTrue(accessor.isNull(i));\n+                        assertTrue(newVarCharVector.isNull(i));\n                     }\n                 }\n                 newVarCharVector.clear();\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestValueVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestValueVector.java\nindex a239861d9..b7f88c3ba 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestValueVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestValueVector.java\n@@ -694,8 +694,6 @@ public void testNullableFixedType2() {\n   public void testNullableFixedType3() {\n     // Create a new value vector for 1024 integers\n     try (final NullableIntVector vector = newVector(NullableIntVector.class, EMPTY_SCHEMA_PATH, MinorType.INT, allocator)) {\n-      final NullableIntVector.Mutator mutator = vector.getMutator();\n-      final NullableIntVector.Accessor accessor = vector.getAccessor();\n       boolean error = false;\n       int initialCapacity = 1024;\n \n@@ -706,26 +704,26 @@ public void testNullableFixedType3() {\n       /* underlying buffer should be able to store 16 values */\n       assertEquals(initialCapacity, vector.getValueCapacity());\n \n-      mutator.set(0, 1);\n-      mutator.set(1, 2);\n-      mutator.set(100, 3);\n-      mutator.set(1022, 4);\n-      mutator.set(1023, 5);\n+      vector.set(0, 1);\n+      vector.set(1, 2);\n+      vector.set(100, 3);\n+      vector.set(1022, 4);\n+      vector.set(1023, 5);\n \n       /* check vector contents */\n       int j = 1;\n       for(int i = 0; i <= 1023; i++) {\n         if((i >= 2 && i <= 99) || (i >= 101 && i <= 1021)) {\n-          assertTrue(\"non-null data not expected at index: \" + i, accessor.isNull(i));\n+          assertTrue(\"non-null data not expected at index: \" + i, vector.isNull(i));\n         }\n         else {\n-          assertFalse(\"null data not expected at index: \" + i, accessor.isNull(i));\n-          assertEquals(\"unexpected value at index: \" + i, j, accessor.get(i));\n+          assertFalse(\"null data not expected at index: \" + i, vector.isNull(i));\n+          assertEquals(\"unexpected value at index: \" + i, j, vector.get(i));\n           j++;\n         }\n       }\n \n-      mutator.setValueCount(1024);\n+      vector.setValueCount(1024);\n       Field field = vector.getField();\n       TypeLayout typeLayout = field.getTypeLayout();\n \n@@ -749,7 +747,7 @@ public void testNullableFixedType3() {\n       assertEquals(-64, validityVectorBuf.getByte(127)); // 1022nd and 1023rd bit defined\n \n       /* this should trigger a realloc() */\n-      mutator.setSafe(1024, 6);\n+      vector.setSafe(1024, 6);\n \n       /* underlying buffer should now be able to store double the number of values */\n       assertEquals(initialCapacity * 2, vector.getValueCapacity());\n@@ -758,11 +756,11 @@ public void testNullableFixedType3() {\n       j = 1;\n       for(int i = 0; i < (initialCapacity * 2); i++) {\n         if((i > 1024) || (i >= 2 && i <= 99) || (i >= 101 && i <= 1021)) {\n-          assertTrue(\"non-null data not expected at index: \" + i, accessor.isNull(i));\n+          assertTrue(\"non-null data not expected at index: \" + i, vector.isNull(i));\n         }\n         else {\n-          assertFalse(\"null data not expected at index: \" + i, accessor.isNull(i));\n-          assertEquals(\"unexpected value at index: \" + i, j, accessor.get(i));\n+          assertFalse(\"null data not expected at index: \" + i, vector.isNull(i));\n+          assertEquals(\"unexpected value at index: \" + i, j, vector.get(i));\n           j++;\n         }\n       }\n@@ -775,13 +773,101 @@ public void testNullableFixedType3() {\n \n       /* vector data should have been zeroed out */\n       for(int i = 0; i < (initialCapacity * 2); i++) {\n-        assertTrue(\"non-null data not expected at index: \" + i, accessor.isNull(i));\n+        assertTrue(\"non-null data not expected at index: \" + i, vector.isNull(i));\n       }\n \n       vector.allocateNew(4096);\n       // vector has been erased\n       for(int i = 0; i < 4096; i++) {\n-        assertTrue(\"non-null data not expected at index: \" + i, accessor.isNull(i));\n+        assertTrue(\"non-null data not expected at index: \" + i, vector.isNull(i));\n+      }\n+    }\n+  }\n+\n+  @Test /* NullableIntVector */\n+  public void testNullableFixedType4() {\n+    try (final NullableIntVector vector = newVector(NullableIntVector.class, EMPTY_SCHEMA_PATH, MinorType.INT, allocator)) {\n+\n+      /* no memory allocation has happened yet */\n+      assertEquals(0, vector.getValueCapacity());\n+\n+      vector.allocateNew();\n+      int valueCapacity = vector.getValueCapacity();\n+      assertEquals(vector.INITIAL_VALUE_ALLOCATION, valueCapacity);\n+\n+      int baseValue = 20000;\n+\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 1) {\n+          vector.set(i, baseValue + i);\n+        }\n+      }\n+\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 1) {\n+          assertFalse(\"unexpected null value at index: \" + i, vector.isNull(i));\n+          assertEquals(\"unexpected value at index: \" + i, (baseValue + i), vector.get(i));\n+        } else {\n+          assertTrue(\"unexpected non-null value at index: \" + i, vector.isNull(i));\n+        }\n+      }\n+\n+      vector.setSafe(valueCapacity, 20000000);\n+      assertEquals(valueCapacity * 2, vector.getValueCapacity());\n+\n+      for (int i = 0; i < vector.getValueCapacity(); i++) {\n+        if (i == valueCapacity) {\n+          assertFalse(\"unexpected null value at index: \" + i, vector.isNull(i));\n+          assertEquals(\"unexpected value at index: \" + i, 20000000, vector.get(i));\n+        } else if (i < valueCapacity) {\n+          if ((i & 1) == 1) {\n+            assertFalse(\"unexpected null value at index: \" + i, vector.isNull(i));\n+            assertEquals(\"unexpected value at index: \" + i, (baseValue + i), vector.get(i));\n+          }\n+        } else {\n+          assertTrue(\"unexpected non-null value at index: \" + i, vector.isNull(i));\n+        }\n+      }\n+\n+      vector.zeroVector();\n+\n+      for (int i = 0; i < vector.getValueCapacity(); i+=2) {\n+          vector.set(i, baseValue + i);\n+      }\n+\n+      for (int i = 0; i < vector.getValueCapacity(); i++) {\n+        if (i%2 == 0) {\n+          assertFalse(\"unexpected null value at index: \" + i, vector.isNull(i));\n+          assertEquals(\"unexpected value at index: \" + i, (baseValue + i), vector.get(i));\n+        } else {\n+          assertTrue(\"unexpected non-null value at index: \" + i, vector.isNull(i));\n+        }\n+      }\n+\n+      vector.setSafe((valueCapacity *  2) + 1000, 400000000);\n+      assertEquals(valueCapacity * 4, vector.getValueCapacity());\n+\n+      for (int i = 0; i < vector.getValueCapacity(); i++) {\n+        if (i == (valueCapacity*2 + 1000)) {\n+          assertFalse(\"unexpected null value at index: \" + i, vector.isNull(i));\n+          assertEquals(\"unexpected value at index: \" + i, 400000000, vector.get(i));\n+        } else if (i < valueCapacity*2 && (i%2) == 0) {\n+          assertFalse(\"unexpected null value at index: \" + i, vector.isNull(i));\n+          assertEquals(\"unexpected value at index: \" + i, baseValue + i, vector.get(i));\n+        } else {\n+          assertTrue(\"unexpected non-null value at index: \" + i, vector.isNull(i));\n+        }\n+      }\n+\n+      /* reset the vector */\n+      vector.reset();\n+\n+       /* capacity shouldn't change after reset */\n+      assertEquals(valueCapacity * 4, vector.getValueCapacity());\n+\n+      /* vector data should be zeroed out */\n+      for(int i = 0; i < (valueCapacity * 4); i++) {\n+        assertTrue(\"non-null data not expected at index: \" + i, vector.isNull(i));\n       }\n     }\n   }\n@@ -805,32 +891,30 @@ public void testNullableVarType1() {\n \n     // Create a new value vector for 1024 integers.\n     try (final NullableVarCharVector vector = newNullableVarCharVector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final NullableVarCharVector.Mutator m = vector.getMutator();\n       vector.allocateNew(1024 * 10, 1024);\n \n-      m.set(0, STR1);\n-      m.set(1, STR2);\n-      m.set(2, STR3);\n-      m.setSafe(3, STR3, 1, STR3.length - 1);\n-      m.setSafe(4, STR3, 2, STR3.length - 2);\n+      vector.set(0, STR1);\n+      vector.set(1, STR2);\n+      vector.set(2, STR3);\n+      vector.setSafe(3, STR3, 1, STR3.length - 1);\n+      vector.setSafe(4, STR3, 2, STR3.length - 2);\n       ByteBuffer STR3ByteBuffer = ByteBuffer.wrap(STR3);\n-      m.setSafe(5, STR3ByteBuffer, 1, STR3.length - 1);\n-      m.setSafe(6, STR3ByteBuffer, 2, STR3.length - 2);\n+      vector.setSafe(5, STR3ByteBuffer, 1, STR3.length - 1);\n+      vector.setSafe(6, STR3ByteBuffer, 2, STR3.length - 2);\n \n       // Check the sample strings.\n-      final NullableVarCharVector.Accessor accessor = vector.getAccessor();\n-      assertArrayEquals(STR1, accessor.get(0));\n-      assertArrayEquals(STR2, accessor.get(1));\n-      assertArrayEquals(STR3, accessor.get(2));\n-      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), accessor.get(3));\n-      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), accessor.get(4));\n-      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), accessor.get(5));\n-      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), accessor.get(6));\n+      assertArrayEquals(STR1, vector.get(0));\n+      assertArrayEquals(STR2, vector.get(1));\n+      assertArrayEquals(STR3, vector.get(2));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), vector.get(3));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), vector.get(4));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), vector.get(5));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), vector.get(6));\n \n       // Ensure null value throws.\n       boolean b = false;\n       try {\n-        vector.getAccessor().get(7);\n+        vector.get(7);\n       } catch (IllegalStateException e) {\n         b = true;\n       } finally {\n@@ -1070,43 +1154,42 @@ public void testReallocAfterVectorTransfer2() {\n   @Test /* NullableVarCharVector */\n   public void testReallocAfterVectorTransfer3() {\n     try (final NullableVarCharVector vector = new NullableVarCharVector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final NullableVarCharVector.Mutator mutator = vector.getMutator();\n-      final NullableVarCharVector.Accessor accessor = vector.getAccessor();\n-\n       /* 4096 values with 10 byte per record */\n       vector.allocateNew(4096 * 10, 4096);\n       int valueCapacity = vector.getValueCapacity();\n+      assertEquals(4096, valueCapacity);\n \n       /* populate the vector */\n       for (int i = 0; i < valueCapacity; i++) {\n         if ((i & 1) == 1) {\n-          mutator.set(i, STR1);\n+          vector.set(i, STR1);\n         }\n         else {\n-          mutator.set(i, STR2);\n+          vector.set(i, STR2);\n         }\n       }\n \n       /* Check the vector output */\n       for (int i = 0; i < valueCapacity; i++) {\n         if ((i & 1) == 1) {\n-          assertArrayEquals(STR1, accessor.get(i));\n+          assertArrayEquals(STR1, vector.get(i));\n         }\n         else {\n-          assertArrayEquals(STR2, accessor.get(i));\n+          assertArrayEquals(STR2, vector.get(i));\n         }\n       }\n \n       /* trigger first realloc */\n-      mutator.setSafe(valueCapacity, STR2, 0, STR2.length);\n+      vector.setSafe(valueCapacity, STR2, 0, STR2.length);\n+      assertEquals(valueCapacity * 2, vector.getValueCapacity());\n \n       /* populate the remaining vector */\n       for (int i = valueCapacity; i < vector.getValueCapacity(); i++) {\n         if ((i & 1) == 1) {\n-          mutator.set(i, STR1);\n+          vector.set(i, STR1);\n         }\n         else {\n-          mutator.set(i, STR2);\n+          vector.set(i, STR2);\n         }\n       }\n \n@@ -1114,23 +1197,24 @@ public void testReallocAfterVectorTransfer3() {\n       valueCapacity = vector.getValueCapacity();\n       for (int i = 0; i < valueCapacity; i++) {\n         if ((i & 1) == 1) {\n-          assertArrayEquals(STR1, accessor.get(i));\n+          assertArrayEquals(STR1, vector.get(i));\n         }\n         else {\n-          assertArrayEquals(STR2, accessor.get(i));\n+          assertArrayEquals(STR2, vector.get(i));\n         }\n       }\n \n       /* trigger second realloc */\n-      mutator.setSafe(valueCapacity + 10, STR2, 0, STR2.length);\n+      vector.setSafe(valueCapacity + 10, STR2, 0, STR2.length);\n+      assertEquals(valueCapacity * 2, vector.getValueCapacity());\n \n       /* populate the remaining vector */\n       for (int i = valueCapacity; i < vector.getValueCapacity(); i++) {\n         if ((i & 1) == 1) {\n-          mutator.set(i, STR1);\n+          vector.set(i, STR1);\n         }\n         else {\n-          mutator.set(i, STR2);\n+          vector.set(i, STR2);\n         }\n       }\n \n@@ -1138,10 +1222,10 @@ public void testReallocAfterVectorTransfer3() {\n       valueCapacity = vector.getValueCapacity();\n       for (int i = 0; i < valueCapacity; i++) {\n         if ((i & 1) == 1) {\n-          assertArrayEquals(STR1, accessor.get(i));\n+          assertArrayEquals(STR1, vector.get(i));\n         }\n         else {\n-          assertArrayEquals(STR2, accessor.get(i));\n+          assertArrayEquals(STR2, vector.get(i));\n         }\n       }\n \n@@ -1152,13 +1236,112 @@ public void testReallocAfterVectorTransfer3() {\n       TransferPair transferPair = vector.getTransferPair(allocator);\n       transferPair.transfer();\n       NullableVarCharVector toVector = (NullableVarCharVector)transferPair.getTo();\n-      NullableVarCharVector.Mutator toMutator = toVector.getMutator();\n-      NullableVarCharVector.Accessor toAccessor = toVector.getAccessor();\n-\n       valueCapacity = toVector.getValueCapacity();\n \n-      /* trigger a realloc of this toVector */\n-      toMutator.setSafe(valueCapacity + 10, STR2, 0, STR2.length);\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 1) {\n+          assertArrayEquals(STR1, toVector.get(i));\n+        }\n+        else {\n+          assertArrayEquals(STR2, toVector.get(i));\n+        }\n+      }\n+\n+      toVector.close();\n+    }\n+  }\n+\n+  @Test /* NullableIntVector */\n+  public void testReallocAfterVectorTransfer4() {\n+    try (final NullableIntVector vector = new NullableIntVector(EMPTY_SCHEMA_PATH, allocator)) {\n+\n+      /* 4096 values  */\n+      vector.allocateNew(4096);\n+      int valueCapacity = vector.getValueCapacity();\n+      assertEquals(4096, valueCapacity);\n+\n+      /* populate the vector */\n+      int baseValue = 1000;\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 0) {\n+          vector.set(i, 1000 + i);\n+        }\n+      }\n+\n+      /* Check the vector output */\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 0) {\n+          assertEquals(1000 + i, vector.get(i));\n+        }\n+        else {\n+          assertTrue(vector.isNull(i));\n+        }\n+      }\n+\n+      /* trigger first realloc */\n+      vector.setSafe(valueCapacity, 10000000);\n+      assertEquals(valueCapacity * 2, vector.getValueCapacity());\n+\n+      /* populate the remaining vector */\n+      for (int i = valueCapacity; i < vector.getValueCapacity(); i++) {\n+        if ((i & 1) == 0) {\n+          vector.set(i, 1000 + i);\n+        }\n+      }\n+\n+      /* Check the vector output */\n+      valueCapacity = vector.getValueCapacity();\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 0) {\n+          assertEquals(1000 + i, vector.get(i));\n+        }\n+        else {\n+          assertTrue(vector.isNull(i));\n+        }\n+      }\n+\n+      /* trigger second realloc */\n+      vector.setSafe(valueCapacity, 10000000);\n+      assertEquals(valueCapacity * 2, vector.getValueCapacity());\n+\n+      /* populate the remaining vector */\n+      for (int i = valueCapacity; i < vector.getValueCapacity(); i++) {\n+        if ((i & 1) == 0) {\n+          vector.set(i, 1000 + i);\n+        }\n+      }\n+\n+      /* Check the vector output */\n+      valueCapacity = vector.getValueCapacity();\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 0) {\n+          assertEquals(1000 + i, vector.get(i));\n+        }\n+        else {\n+          assertTrue(vector.isNull(i));\n+        }\n+      }\n+\n+      /* we are potentially working with 4x the size of vector buffer\n+       * that we initially started with. Now let's transfer the vector.\n+       */\n+\n+      TransferPair transferPair = vector.getTransferPair(allocator);\n+      transferPair.transfer();\n+      NullableIntVector toVector = (NullableIntVector)transferPair.getTo();\n+      /* value capacity of source and target vectors should be same after\n+       * the transfer.\n+       */\n+      assertEquals(valueCapacity, toVector.getValueCapacity());\n+\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 0) {\n+          assertEquals(1000 + i, toVector.get(i));\n+        }\n+        else {\n+          assertTrue(toVector.isNull(i));\n+        }\n+      }\n \n       toVector.close();\n     }\n@@ -1199,31 +1382,33 @@ public void testReAllocNullableFixedWidthVector() {\n \n   @Test\n   public void testReAllocNullableVariableWidthVector() {\n-    // Create a new value vector for 1024 integers\n     try (final NullableVarCharVector vector = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n-      final NullableVarCharVector.Mutator m = vector.getMutator();\n       vector.allocateNew();\n \n       int initialCapacity = vector.getValueCapacity();\n+      assertEquals(4095, initialCapacity);\n \n-      // Put values in indexes that fall within the initial allocation\n-      m.setSafe(0, STR1, 0, STR1.length);\n-      m.setSafe(initialCapacity - 1, STR2, 0, STR2.length);\n+      /* Put values in indexes that fall within the initial allocation */\n+      vector.setSafe(0, STR1, 0, STR1.length);\n+      vector.setSafe(initialCapacity - 1, STR2, 0, STR2.length);\n \n-      // Now try to put values in space that falls beyond the initial allocation\n-      m.setSafe(initialCapacity + 200, STR3, 0, STR3.length);\n+      /* the above set calls should NOT have triggered a realloc */\n+      initialCapacity = vector.getValueCapacity();\n+      assertEquals(4095, initialCapacity);\n \n-      // Check valueCapacity is more than initial allocation\n-      assertEquals((initialCapacity + 1) * 2 - 1, vector.getValueCapacity());\n+      /* Now try to put values in space that falls beyond the initial allocation */\n+      vector.setSafe(initialCapacity + 200, STR3, 0, STR3.length);\n \n-      final NullableVarCharVector.Accessor accessor = vector.getAccessor();\n-      assertArrayEquals(STR1, accessor.get(0));\n-      assertArrayEquals(STR2, accessor.get(initialCapacity - 1));\n-      assertArrayEquals(STR3, accessor.get(initialCapacity + 200));\n+      /* Check valueCapacity is more than initial allocation */\n+      assertEquals(((initialCapacity + 1) * 2) - 1, vector.getValueCapacity());\n+\n+      assertArrayEquals(STR1, vector.get(0));\n+      assertArrayEquals(STR2, vector.get(initialCapacity - 1));\n+      assertArrayEquals(STR3, vector.get(initialCapacity + 200));\n \n       // Set the valueCount to be more than valueCapacity of current allocation. This is possible for NullableValueVectors\n       // as we don't call setSafe for null values, but we do call setValueCount when the current batch is processed.\n-      m.setValueCount(vector.getValueCapacity() + 200);\n+      vector.setValueCount(vector.getValueCapacity() + 200);\n     }\n   }\n \n@@ -1232,10 +1417,18 @@ public void testFillEmptiesNotOverfill() {\n     try (final NullableVarCharVector vector = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n       vector.allocateNew();\n \n-      vector.getMutator().setSafe(4094, \"hello\".getBytes(), 0, 5);\n-      vector.getMutator().setValueCount(4095);\n+      int initialCapacity = vector.getValueCapacity();\n+      assertEquals(4095, initialCapacity);\n+\n+      vector.setSafe(4094, \"hello\".getBytes(), 0, 5);\n+      /* the above set method should NOT have trigerred a realloc */\n+      initialCapacity = vector.getValueCapacity();\n+      assertEquals(4095, initialCapacity);\n \n-      assertEquals(4096 * 4, vector.getFieldBuffers().get(1).capacity());\n+      vector.setValueCount(4095);\n+      assertEquals(4096 * vector.OFFSET_WIDTH, vector.getFieldBuffers().get(1).capacity());\n+      initialCapacity = vector.getValueCapacity();\n+      assertEquals(4095, initialCapacity);\n     }\n   }\n \n@@ -1243,42 +1436,129 @@ public void testFillEmptiesNotOverfill() {\n   public void testCopyFromWithNulls() {\n     try (final NullableVarCharVector vector = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator);\n          final NullableVarCharVector vector2 = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n+\n       vector.allocateNew();\n+      int capacity = vector.getValueCapacity();\n+      assertEquals(4095, capacity);\n \n       for (int i = 0; i < 4095; i++) {\n         if (i % 3 == 0) {\n           continue;\n         }\n         byte[] b = Integer.toString(i).getBytes();\n-        vector.getMutator().setSafe(i, b, 0, b.length);\n+        vector.setSafe(i, b, 0, b.length);\n       }\n \n-      vector.getMutator().setValueCount(4095);\n+      /* NO reAlloc() should have happened in setSafe() */\n+      capacity = vector.getValueCapacity();\n+      assertEquals(4095, capacity);\n+\n+      vector.setValueCount(4095);\n+\n+      for (int i = 0; i < 4095; i++) {\n+        if (i % 3 == 0) {\n+          assertNull(vector.getObject(i));\n+        } else {\n+          assertEquals(\"unexpected value at index: \" + i, Integer.toString(i), vector.getObject(i).toString());\n+        }\n+      }\n \n       vector2.allocateNew();\n+      capacity = vector2.getValueCapacity();\n+      assertEquals(4095, capacity);\n \n       for (int i = 0; i < 4095; i++) {\n         vector2.copyFromSafe(i, i, vector);\n+        if (i % 3 == 0) {\n+          assertNull(vector2.getObject(i));\n+        } else {\n+          assertEquals(\"unexpected value at index: \" + i, Integer.toString(i), vector2.getObject(i).toString());\n+        }\n       }\n \n-      vector2.getMutator().setValueCount(4095);\n+      /* NO reAlloc() should have happened in copyFrom */\n+      capacity = vector2.getValueCapacity();\n+      assertEquals(4095, capacity);\n+\n+      vector2.setValueCount(4095);\n \n       for (int i = 0; i < 4095; i++) {\n         if (i % 3 == 0) {\n-          assertNull(vector2.getAccessor().getObject(i));\n+          assertNull(vector2.getObject(i));\n         } else {\n-          assertEquals(Integer.toString(i), vector2.getAccessor().getObject(i).toString());\n+          assertEquals(\"unexpected value at index: \" + i, Integer.toString(i), vector2.getObject(i).toString());\n         }\n       }\n     }\n   }\n \n   @Test\n-  public void testSetLastSetUsage() {\n-    try (final NullableVarCharVector vector = new NullableVarCharVector(\"myvector\", allocator)) {\n+  public void testCopyFromWithNulls1() {\n+    try (final NullableVarCharVector vector = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator);\n+         final NullableVarCharVector vector2 = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n \n-      final NullableVarCharVector.Mutator mutator = vector.getMutator();\n+      vector.allocateNew();\n+      int capacity = vector.getValueCapacity();\n+      assertEquals(4095, capacity);\n \n+      for (int i = 0; i < 4095; i++) {\n+        if (i % 3 == 0) {\n+          continue;\n+        }\n+        byte[] b = Integer.toString(i).getBytes();\n+        vector.setSafe(i, b, 0, b.length);\n+      }\n+\n+      /* NO reAlloc() should have happened in setSafe() */\n+      capacity = vector.getValueCapacity();\n+      assertEquals(4095, capacity);\n+\n+      vector.setValueCount(4095);\n+\n+      for (int i = 0; i < 4095; i++) {\n+        if (i % 3 == 0) {\n+          assertNull(vector.getObject(i));\n+        } else {\n+          assertEquals(\"unexpected value at index: \" + i, Integer.toString(i), vector.getObject(i).toString());\n+        }\n+      }\n+\n+      /* set lesser initial capacity than actually needed\n+       * to trigger reallocs in copyFromSafe()\n+       */\n+      vector2.allocateNew(1024 * 10, 1024);\n+\n+      capacity = vector2.getValueCapacity();\n+      assertEquals(1024, capacity);\n+\n+      for (int i = 0; i < 4095; i++) {\n+        vector2.copyFromSafe(i, i, vector);\n+        if (i % 3 == 0) {\n+          assertNull(vector2.getObject(i));\n+        } else {\n+          assertEquals(\"unexpected value at index: \" + i, Integer.toString(i), vector2.getObject(i).toString());\n+        }\n+      }\n+\n+      /* 2 reAllocs should have happened in copyFromSafe() */\n+      capacity = vector2.getValueCapacity();\n+      assertEquals(4096, capacity);\n+\n+      vector2.setValueCount(4095);\n+\n+      for (int i = 0; i < 4095; i++) {\n+        if (i % 3 == 0) {\n+          assertNull(vector2.getObject(i));\n+        } else {\n+          assertEquals(\"unexpected value at index: \" + i, Integer.toString(i), vector2.getObject(i).toString());\n+        }\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSetLastSetUsage() {\n+    try (final NullableVarCharVector vector = new NullableVarCharVector(\"myvector\", allocator)) {\n       vector.allocateNew(1024 * 10, 1024);\n \n       setBytes(0, STR1, vector);\n@@ -1289,32 +1569,102 @@ public void testSetLastSetUsage() {\n       setBytes(5, STR6, vector);\n \n       /* Check current lastSet */\n-      assertEquals(Integer.toString(-1), Integer.toString(mutator.getLastSet()));\n+      assertEquals(Integer.toString(-1), Integer.toString(vector.getLastSet()));\n \n       /* Check the vector output */\n-      final NullableVarCharVector.Accessor accessor = vector.getAccessor();\n-      assertArrayEquals(STR1, accessor.get(0));\n-      assertArrayEquals(STR2, accessor.get(1));\n-      assertArrayEquals(STR3, accessor.get(2));\n-      assertArrayEquals(STR4, accessor.get(3));\n-      assertArrayEquals(STR5, accessor.get(4));\n-      assertArrayEquals(STR6, accessor.get(5));\n+      assertArrayEquals(STR1, vector.get(0));\n+      assertArrayEquals(STR2, vector.get(1));\n+      assertArrayEquals(STR3, vector.get(2));\n+      assertArrayEquals(STR4, vector.get(3));\n+      assertArrayEquals(STR5, vector.get(4));\n+      assertArrayEquals(STR6, vector.get(5));\n \n       /*\n        * If we don't do setLastSe(5) before setValueCount(), then the latter will corrupt\n        * the value vector by filling in all positions [0,valuecount-1] will empty byte arrays.\n        * Run the test by commenting out next line and we should see incorrect vector output.\n        */\n-      mutator.setLastSet(5);\n-      mutator.setValueCount(20);\n+      vector.setLastSet(5);\n+      vector.setValueCount(20);\n+\n+      /* Check current lastSet */\n+      assertEquals(Integer.toString(19), Integer.toString(vector.getLastSet()));\n \n       /* Check the vector output again */\n-      assertArrayEquals(STR1, accessor.get(0));\n-      assertArrayEquals(STR2, accessor.get(1));\n-      assertArrayEquals(STR3, accessor.get(2));\n-      assertArrayEquals(STR4, accessor.get(3));\n-      assertArrayEquals(STR5, accessor.get(4));\n-      assertArrayEquals(STR6, accessor.get(5));\n+      assertArrayEquals(STR1, vector.get(0));\n+      assertArrayEquals(STR2, vector.get(1));\n+      assertArrayEquals(STR3, vector.get(2));\n+      assertArrayEquals(STR4, vector.get(3));\n+      assertArrayEquals(STR5, vector.get(4));\n+      assertArrayEquals(STR6, vector.get(5));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(6)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(7)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(8)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(9)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(10)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(11)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(12)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(13)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(14)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(15)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(16)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(17)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(18)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(19)));\n+\n+      /* Check offsets */\n+      assertEquals(Integer.toString(0),\n+              Integer.toString(vector.offsetBuffer.getInt(0 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(6),\n+              Integer.toString(vector.offsetBuffer.getInt(1 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(16),\n+              Integer.toString(vector.offsetBuffer.getInt(2 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(21),\n+              Integer.toString(vector.offsetBuffer.getInt(3 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(30),\n+              Integer.toString(vector.offsetBuffer.getInt(4 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(34),\n+              Integer.toString(vector.offsetBuffer.getInt(5 * vector.OFFSET_WIDTH)));\n+\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(6 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(7 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(8 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(9 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(10 * vector.OFFSET_WIDTH)));\n+\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(11 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(12 * vector.OFFSET_WIDTH)));\n+\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(13 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(14 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(15 * vector.OFFSET_WIDTH)));\n+\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(16 * vector.OFFSET_WIDTH)));\n+\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(17 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(18 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(19 * vector.OFFSET_WIDTH)));\n+\n+      vector.set(19, STR6);\n+      assertArrayEquals(STR6, vector.get(19));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(19 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(46),\n+              Integer.toString(vector.offsetBuffer.getInt(20 * vector.OFFSET_WIDTH)));\n     }\n   }\n \n@@ -1322,29 +1672,25 @@ public void testSetLastSetUsage() {\n   public void testVectorLoadUnload() {\n \n     try (final NullableVarCharVector vector1 = new NullableVarCharVector(\"myvector\", allocator)) {\n-\n-      final NullableVarCharVector.Mutator mutator1 = vector1.getMutator();\n-\n       vector1.allocateNew(1024 * 10, 1024);\n \n-      mutator1.set(0, STR1);\n-      mutator1.set(1, STR2);\n-      mutator1.set(2, STR3);\n-      mutator1.set(3, STR4);\n-      mutator1.set(4, STR5);\n-      mutator1.set(5, STR6);\n-      assertEquals(Integer.toString(5), Integer.toString(mutator1.getLastSet()));\n-      mutator1.setValueCount(15);\n-      assertEquals(Integer.toString(14), Integer.toString(mutator1.getLastSet()));\n+      vector1.set(0, STR1);\n+      vector1.set(1, STR2);\n+      vector1.set(2, STR3);\n+      vector1.set(3, STR4);\n+      vector1.set(4, STR5);\n+      vector1.set(5, STR6);\n+      assertEquals(Integer.toString(5), Integer.toString(vector1.getLastSet()));\n+      vector1.setValueCount(15);\n+      assertEquals(Integer.toString(14), Integer.toString(vector1.getLastSet()));\n \n       /* Check the vector output */\n-      final NullableVarCharVector.Accessor accessor1 = vector1.getAccessor();\n-      assertArrayEquals(STR1, accessor1.get(0));\n-      assertArrayEquals(STR2, accessor1.get(1));\n-      assertArrayEquals(STR3, accessor1.get(2));\n-      assertArrayEquals(STR4, accessor1.get(3));\n-      assertArrayEquals(STR5, accessor1.get(4));\n-      assertArrayEquals(STR6, accessor1.get(5));\n+      assertArrayEquals(STR1, vector1.get(0));\n+      assertArrayEquals(STR2, vector1.get(1));\n+      assertArrayEquals(STR3, vector1.get(2));\n+      assertArrayEquals(STR4, vector1.get(3));\n+      assertArrayEquals(STR5, vector1.get(4));\n+      assertArrayEquals(STR6, vector1.get(5));\n \n       Field field = vector1.getField();\n       String fieldName = field.getName();\n@@ -1357,7 +1703,7 @@ public void testVectorLoadUnload() {\n \n       Schema schema = new Schema(fields);\n \n-      VectorSchemaRoot schemaRoot1 = new VectorSchemaRoot(schema, fieldVectors, accessor1.getValueCount());\n+      VectorSchemaRoot schemaRoot1 = new VectorSchemaRoot(schema, fieldVectors, vector1.getValueCount());\n       VectorUnloader vectorUnloader = new VectorUnloader(schemaRoot1);\n \n       try (\n@@ -1370,24 +1716,21 @@ public void testVectorLoadUnload() {\n         vectorLoader.load(recordBatch);\n \n         NullableVarCharVector vector2 = (NullableVarCharVector) schemaRoot2.getVector(fieldName);\n-        NullableVarCharVector.Mutator mutator2 = vector2.getMutator();\n-\n         /*\n          * lastSet would have internally been set by VectorLoader.load() when it invokes\n          * loadFieldBuffers.\n          */\n-        assertEquals(Integer.toString(14), Integer.toString(mutator2.getLastSet()));\n-        mutator2.setValueCount(25);\n-        assertEquals(Integer.toString(24), Integer.toString(mutator2.getLastSet()));\n+        assertEquals(Integer.toString(14), Integer.toString(vector2.getLastSet()));\n+        vector2.setValueCount(25);\n+        assertEquals(Integer.toString(24), Integer.toString(vector2.getLastSet()));\n \n         /* Check the vector output */\n-        final NullableVarCharVector.Accessor accessor2 = vector2.getAccessor();\n-        assertArrayEquals(STR1, accessor2.get(0));\n-        assertArrayEquals(STR2, accessor2.get(1));\n-        assertArrayEquals(STR3, accessor2.get(2));\n-        assertArrayEquals(STR4, accessor2.get(3));\n-        assertArrayEquals(STR5, accessor2.get(4));\n-        assertArrayEquals(STR6, accessor2.get(5));\n+        assertArrayEquals(STR1, vector2.get(0));\n+        assertArrayEquals(STR2, vector2.get(1));\n+        assertArrayEquals(STR3, vector2.get(2));\n+        assertArrayEquals(STR4, vector2.get(3));\n+        assertArrayEquals(STR5, vector2.get(4));\n+        assertArrayEquals(STR6, vector2.get(5));\n       }\n     }\n   }\n@@ -1396,8 +1739,6 @@ public void testVectorLoadUnload() {\n   public void testFillEmptiesUsage() {\n     try (final NullableVarCharVector vector = new NullableVarCharVector(\"myvector\", allocator)) {\n \n-      final NullableVarCharVector.Mutator mutator = vector.getMutator();\n-\n       vector.allocateNew(1024 * 10, 1024);\n \n       setBytes(0, STR1, vector);\n@@ -1408,84 +1749,98 @@ public void testFillEmptiesUsage() {\n       setBytes(5, STR6, vector);\n \n       /* Check current lastSet */\n-      assertEquals(Integer.toString(-1), Integer.toString(mutator.getLastSet()));\n+      assertEquals(Integer.toString(-1), Integer.toString(vector.getLastSet()));\n \n       /* Check the vector output */\n-      final NullableVarCharVector.Accessor accessor = vector.getAccessor();\n-      assertArrayEquals(STR1, accessor.get(0));\n-      assertArrayEquals(STR2, accessor.get(1));\n-      assertArrayEquals(STR3, accessor.get(2));\n-      assertArrayEquals(STR4, accessor.get(3));\n-      assertArrayEquals(STR5, accessor.get(4));\n-      assertArrayEquals(STR6, accessor.get(5));\n-\n-      mutator.setLastSet(5);\n+      assertArrayEquals(STR1, vector.get(0));\n+      assertArrayEquals(STR2, vector.get(1));\n+      assertArrayEquals(STR3, vector.get(2));\n+      assertArrayEquals(STR4, vector.get(3));\n+      assertArrayEquals(STR5, vector.get(4));\n+      assertArrayEquals(STR6, vector.get(5));\n+\n+      vector.setLastSet(5);\n       /* fill empty byte arrays from index [6, 9] */\n-      mutator.fillEmpties(10);\n+      vector.fillEmpties(10);\n \n       /* Check current lastSet */\n-      assertEquals(Integer.toString(9), Integer.toString(mutator.getLastSet()));\n+      assertEquals(Integer.toString(9), Integer.toString(vector.getLastSet()));\n \n       /* Check the vector output */\n-      assertArrayEquals(STR1, accessor.get(0));\n-      assertArrayEquals(STR2, accessor.get(1));\n-      assertArrayEquals(STR3, accessor.get(2));\n-      assertArrayEquals(STR4, accessor.get(3));\n-      assertArrayEquals(STR5, accessor.get(4));\n-      assertArrayEquals(STR6, accessor.get(5));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(6)));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(7)));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(8)));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(9)));\n+      assertArrayEquals(STR1, vector.get(0));\n+      assertArrayEquals(STR2, vector.get(1));\n+      assertArrayEquals(STR3, vector.get(2));\n+      assertArrayEquals(STR4, vector.get(3));\n+      assertArrayEquals(STR5, vector.get(4));\n+      assertArrayEquals(STR6, vector.get(5));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(6)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(7)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(8)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(9)));\n \n       setBytes(10, STR1, vector);\n       setBytes(11, STR2, vector);\n \n-      mutator.setLastSet(11);\n+      vector.setLastSet(11);\n       /* fill empty byte arrays from index [12, 14] */\n-      mutator.setValueCount(15);\n+      vector.setValueCount(15);\n \n       /* Check current lastSet */\n-      assertEquals(Integer.toString(14), Integer.toString(mutator.getLastSet()));\n+      assertEquals(Integer.toString(14), Integer.toString(vector.getLastSet()));\n \n       /* Check the vector output */\n-      assertArrayEquals(STR1, accessor.get(0));\n-      assertArrayEquals(STR2, accessor.get(1));\n-      assertArrayEquals(STR3, accessor.get(2));\n-      assertArrayEquals(STR4, accessor.get(3));\n-      assertArrayEquals(STR5, accessor.get(4));\n-      assertArrayEquals(STR6, accessor.get(5));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(6)));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(7)));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(8)));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(9)));\n-      assertArrayEquals(STR1, accessor.get(10));\n-      assertArrayEquals(STR2, accessor.get(11));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(12)));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(13)));\n-      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(14)));\n+      assertArrayEquals(STR1, vector.get(0));\n+      assertArrayEquals(STR2, vector.get(1));\n+      assertArrayEquals(STR3, vector.get(2));\n+      assertArrayEquals(STR4, vector.get(3));\n+      assertArrayEquals(STR5, vector.get(4));\n+      assertArrayEquals(STR6, vector.get(5));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(6)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(7)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(8)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(9)));\n+      assertArrayEquals(STR1, vector.get(10));\n+      assertArrayEquals(STR2, vector.get(11));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(12)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(13)));\n+      assertEquals(Integer.toString(0), Integer.toString(vector.getValueLength(14)));\n \n       /* Check offsets */\n-      final UInt4Vector.Accessor offsetAccessor = vector.values.offsetVector.getAccessor();\n-      assertEquals(Integer.toString(0), Integer.toString(offsetAccessor.get(0)));\n-      assertEquals(Integer.toString(6), Integer.toString(offsetAccessor.get(1)));\n-      assertEquals(Integer.toString(16), Integer.toString(offsetAccessor.get(2)));\n-      assertEquals(Integer.toString(21), Integer.toString(offsetAccessor.get(3)));\n-      assertEquals(Integer.toString(30), Integer.toString(offsetAccessor.get(4)));\n-      assertEquals(Integer.toString(34), Integer.toString(offsetAccessor.get(5)));\n-\n-      assertEquals(Integer.toString(40), Integer.toString(offsetAccessor.get(6)));\n-      assertEquals(Integer.toString(40), Integer.toString(offsetAccessor.get(7)));\n-      assertEquals(Integer.toString(40), Integer.toString(offsetAccessor.get(8)));\n-      assertEquals(Integer.toString(40), Integer.toString(offsetAccessor.get(9)));\n-      assertEquals(Integer.toString(40), Integer.toString(offsetAccessor.get(10)));\n-\n-      assertEquals(Integer.toString(46), Integer.toString(offsetAccessor.get(11)));\n-      assertEquals(Integer.toString(56), Integer.toString(offsetAccessor.get(12)));\n-\n-      assertEquals(Integer.toString(56), Integer.toString(offsetAccessor.get(13)));\n-      assertEquals(Integer.toString(56), Integer.toString(offsetAccessor.get(14)));\n-      assertEquals(Integer.toString(56), Integer.toString(offsetAccessor.get(15)));\n+      assertEquals(Integer.toString(0),\n+              Integer.toString(vector.offsetBuffer.getInt(0 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(6),\n+              Integer.toString(vector.offsetBuffer.getInt(1 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(16),\n+              Integer.toString(vector.offsetBuffer.getInt(2 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(21),\n+              Integer.toString(vector.offsetBuffer.getInt(3 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(30),\n+              Integer.toString(vector.offsetBuffer.getInt(4 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(34),\n+              Integer.toString(vector.offsetBuffer.getInt(5 * vector.OFFSET_WIDTH)));\n+\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(6 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(7 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(8 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(9 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(40),\n+              Integer.toString(vector.offsetBuffer.getInt(10 * vector.OFFSET_WIDTH)));\n+\n+      assertEquals(Integer.toString(46),\n+              Integer.toString(vector.offsetBuffer.getInt(11 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(56),\n+              Integer.toString(vector.offsetBuffer.getInt(12 * vector.OFFSET_WIDTH)));\n+\n+      assertEquals(Integer.toString(56),\n+              Integer.toString(vector.offsetBuffer.getInt(13 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(56),\n+              Integer.toString(vector.offsetBuffer.getInt(14 * vector.OFFSET_WIDTH)));\n+      assertEquals(Integer.toString(56),\n+              Integer.toString(vector.offsetBuffer.getInt(15 * vector.OFFSET_WIDTH)));\n     }\n   }\n \n@@ -1493,29 +1848,25 @@ public void testFillEmptiesUsage() {\n   public void testGetBufferAddress1() {\n \n     try (final NullableVarCharVector vector = new NullableVarCharVector(\"myvector\", allocator)) {\n-\n-      final NullableVarCharVector.Mutator mutator = vector.getMutator();\n-      final NullableVarCharVector.Accessor accessor = vector.getAccessor();\n-\n       vector.allocateNew(1024 * 10, 1024);\n \n       /* populate the vector */\n-      mutator.set(0, STR1);\n-      mutator.set(1, STR2);\n-      mutator.set(2, STR3);\n-      mutator.set(3, STR4);\n-      mutator.set(4, STR5);\n-      mutator.set(5, STR6);\n+      vector.set(0, STR1);\n+      vector.set(1, STR2);\n+      vector.set(2, STR3);\n+      vector.set(3, STR4);\n+      vector.set(4, STR5);\n+      vector.set(5, STR6);\n \n-      mutator.setValueCount(15);\n+      vector.setValueCount(15);\n \n       /* check the vector output */\n-      assertArrayEquals(STR1, accessor.get(0));\n-      assertArrayEquals(STR2, accessor.get(1));\n-      assertArrayEquals(STR3, accessor.get(2));\n-      assertArrayEquals(STR4, accessor.get(3));\n-      assertArrayEquals(STR5, accessor.get(4));\n-      assertArrayEquals(STR6, accessor.get(5));\n+      assertArrayEquals(STR1, vector.get(0));\n+      assertArrayEquals(STR2, vector.get(1));\n+      assertArrayEquals(STR3, vector.get(2));\n+      assertArrayEquals(STR4, vector.get(3));\n+      assertArrayEquals(STR5, vector.get(4));\n+      assertArrayEquals(STR6, vector.get(5));\n \n       List<ArrowBuf> buffers = vector.getFieldBuffers();\n       long bitAddress = vector.getValidityBufferAddress();\n@@ -1531,23 +1882,18 @@ public void testGetBufferAddress1() {\n \n   @Test /* NullableIntVector */\n   public void testGetBufferAddress2() {\n-\n     try (final NullableIntVector vector = new NullableIntVector(\"myvector\", allocator)) {\n-\n-      final NullableIntVector.Mutator mutator = vector.getMutator();\n-      final NullableIntVector.Accessor accessor = vector.getAccessor();\n       boolean error = false;\n-\n       vector.allocateNew(16);\n \n       /* populate the vector */\n       for(int i = 0; i < 16; i += 2) {\n-        mutator.set(i, i+10);\n+        vector.set(i, i+10);\n       }\n \n       /* check the vector output */\n       for(int i = 0; i < 16; i += 2) {\n-        assertEquals(i+10, accessor.get(i));\n+        assertEquals(i+10, vector.get(i));\n       }\n \n       List<ArrowBuf> buffers = vector.getFieldBuffers();\n@@ -1580,11 +1926,15 @@ public void testMultipleClose() {\n     vectorAllocator.close();\n   }\n \n+  /* this method is used by the tests to bypass the vector set methods that manipulate\n+   * lastSet. The method is to test the lastSet property and that's why we load the vector\n+   * in a way that lastSet is not set automatically.\n+   */\n   public static void setBytes(int index, byte[] bytes, NullableVarCharVector vector) {\n-    final int currentOffset = vector.values.offsetVector.getAccessor().get(index);\n+    final int currentOffset = vector.offsetBuffer.getInt(index * vector.OFFSET_WIDTH);\n \n-    vector.bits.getMutator().setToOne(index);\n-    vector.values.offsetVector.getMutator().set(index + 1, currentOffset + bytes.length);\n-    vector.values.data.setBytes(currentOffset, bytes, 0, bytes.length);\n+    BitVectorHelper.setValidityBitToOne(vector.validityBuffer, index);\n+    vector.offsetBuffer.setInt((index + 1) * vector.OFFSET_WIDTH, currentOffset + bytes.length);\n+    vector.valueBuffer.setBytes(currentOffset, bytes, 0, bytes.length);\n   }\n }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java\nindex 4ac7536c0..531a46c27 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java\n@@ -76,24 +76,23 @@ public void testFixedType() {\n   @Test\n   public void testNullableType() {\n     try (final NullableVarCharVector vector = new NullableVarCharVector(\"\", allocator)) {\n-      final NullableVarCharVector.Mutator m = vector.getMutator();\n       vector.setInitialCapacity(512);\n       vector.allocateNew();\n \n       assertEquals(512, vector.getValueCapacity());\n \n       try {\n-        m.set(512, \"foo\".getBytes(StandardCharsets.UTF_8));\n+        vector.set(512, \"foo\".getBytes(StandardCharsets.UTF_8));\n         Assert.fail(\"Expected out of bounds exception\");\n       } catch (Exception e) {\n         // ok\n       }\n \n       vector.reAlloc();\n-      assertEquals(1023, vector.getValueCapacity());\n+      assertEquals(1024, vector.getValueCapacity());\n \n-      m.set(512, \"foo\".getBytes(StandardCharsets.UTF_8));\n-      assertEquals(\"foo\", new String(vector.getAccessor().get(512), StandardCharsets.UTF_8));\n+      vector.set(512, \"foo\".getBytes(StandardCharsets.UTF_8));\n+      assertEquals(\"foo\", new String(vector.get(512), StandardCharsets.UTF_8));\n     }\n   }\n \n@@ -105,7 +104,7 @@ public void testListType() {\n       vector.setInitialCapacity(512);\n       vector.allocateNew();\n \n-      assertEquals(1023, vector.getValueCapacity()); // TODO this doubles for some reason...\n+      assertEquals(1023, vector.getValueCapacity());\n \n       try {\n         vector.getOffsetVector().getAccessor().get(2014);\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorUnloadLoad.java b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorUnloadLoad.java\nindex 7facf73f5..0b7928dca 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorUnloadLoad.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorUnloadLoad.java\n@@ -45,13 +45,21 @@\n import org.apache.arrow.vector.types.pojo.Field;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.types.pojo.Schema;\n-import org.junit.AfterClass;\n-import org.junit.Assert;\n-import org.junit.Test;\n+import org.junit.*;\n \n public class TestVectorUnloadLoad {\n \n-  static final BufferAllocator allocator = new RootAllocator(Integer.MAX_VALUE);\n+  private BufferAllocator allocator;\n+\n+  @Before\n+  public void init() {\n+    allocator = new RootAllocator(Long.MAX_VALUE);\n+  }\n+\n+  @After\n+  public void terminate() throws Exception {\n+    allocator.close();\n+  }\n \n   @Test\n   public void testUnloadLoad() throws IOException {\n@@ -183,24 +191,40 @@ public void testUnloadLoadAddPadding() throws IOException {\n    * @throws IOException\n    */\n   @Test\n-  public void testLoadEmptyValidityBuffer() throws IOException {\n+  public void testLoadValidityBuffer() throws IOException {\n     Schema schema = new Schema(asList(\n         new Field(\"intDefined\", FieldType.nullable(new ArrowType.Int(32, true)), Collections.<Field>emptyList()),\n         new Field(\"intNull\", FieldType.nullable(new ArrowType.Int(32, true)), Collections.<Field>emptyList())\n     ));\n     int count = 10;\n-    ArrowBuf validity = allocator.buffer(10).slice(0, 0);\n-    ArrowBuf[] values = new ArrowBuf[2];\n-    for (int i = 0; i < values.length; i++) {\n-      ArrowBuf arrowBuf = allocator.buffer(count * 4); // integers\n-      values[i] = arrowBuf;\n+    ArrowBuf[] values = new ArrowBuf[4];\n+    for (int i = 0; i < 4; i+=2) {\n+      ArrowBuf buf1 = allocator.buffer((int)Math.ceil(count / 8.0));\n+      ArrowBuf buf2 = allocator.buffer(count * 4); // integers\n+      values[i] = buf1;\n+      values[i+1] = buf2;\n       for (int j = 0; j < count; j++) {\n-        arrowBuf.setInt(j * 4, j);\n+        if (i == 2) {\n+          BitVectorHelper.setValidityBit(buf1, j, 0);\n+        } else {\n+          BitVectorHelper.setValidityBitToOne(buf1, j);\n+        }\n+\n+        buf2.setInt(j * 4, j);\n       }\n-      arrowBuf.writerIndex(count * 4);\n+      buf1.writerIndex((int)Math.ceil(count / 8));\n+      buf2.writerIndex(count * 4);\n     }\n+\n+    /*\n+     * values[0] - validity buffer for first vector\n+     * values[1] - data buffer for first vector\n+     * values[2] - validity buffer for second vector\n+     * values[3] - data buffer for second vector\n+     */\n+\n     try (\n-        ArrowRecordBatch recordBatch = new ArrowRecordBatch(count, asList(new ArrowFieldNode(count, 0), new ArrowFieldNode(count, count)), asList(validity, values[0], validity, values[1]));\n+        ArrowRecordBatch recordBatch = new ArrowRecordBatch(count, asList(new ArrowFieldNode(count, 0), new ArrowFieldNode(count, count)), asList(values[0], values[1], values[2], values[3]));\n         BufferAllocator finalVectorsAllocator = allocator.newChildAllocator(\"final vectors\", 0, Integer.MAX_VALUE);\n         VectorSchemaRoot newRoot = VectorSchemaRoot.create(schema, finalVectorsAllocator);\n     ) {\n@@ -213,32 +237,31 @@ public void testLoadEmptyValidityBuffer() throws IOException {\n       NullableIntVector intDefinedVector = (NullableIntVector) newRoot.getVector(\"intDefined\");\n       NullableIntVector intNullVector = (NullableIntVector) newRoot.getVector(\"intNull\");\n       for (int i = 0; i < count; i++) {\n-        assertFalse(\"#\" + i, intDefinedVector.getAccessor().isNull(i));\n-        assertEquals(\"#\" + i, i, intDefinedVector.getAccessor().get(i));\n-        assertTrue(\"#\" + i, intNullVector.getAccessor().isNull(i));\n+        assertFalse(\"#\" + i, intDefinedVector.isNull(i));\n+        assertEquals(\"#\" + i, i, intDefinedVector.get(i));\n+        assertTrue(\"#\" + i, intNullVector.isNull(i));\n       }\n-      intDefinedVector.getMutator().setSafe(count + 10, 1234);\n-      assertTrue(intDefinedVector.getAccessor().isNull(count + 1));\n+      intDefinedVector.setSafe(count + 10, 1234);\n+      assertTrue(intDefinedVector.isNull(count + 1));\n       // empty slots should still default to unset\n-      intDefinedVector.getMutator().setSafe(count + 1, 789);\n-      assertFalse(intDefinedVector.getAccessor().isNull(count + 1));\n-      assertEquals(789, intDefinedVector.getAccessor().get(count + 1));\n-      assertTrue(intDefinedVector.getAccessor().isNull(count));\n-      assertTrue(intDefinedVector.getAccessor().isNull(count + 2));\n-      assertTrue(intDefinedVector.getAccessor().isNull(count + 3));\n-      assertTrue(intDefinedVector.getAccessor().isNull(count + 4));\n-      assertTrue(intDefinedVector.getAccessor().isNull(count + 5));\n-      assertTrue(intDefinedVector.getAccessor().isNull(count + 6));\n-      assertTrue(intDefinedVector.getAccessor().isNull(count + 7));\n-      assertTrue(intDefinedVector.getAccessor().isNull(count + 8));\n-      assertTrue(intDefinedVector.getAccessor().isNull(count + 9));\n-      assertFalse(intDefinedVector.getAccessor().isNull(count + 10));\n-      assertEquals(1234, intDefinedVector.getAccessor().get(count + 10));\n+      intDefinedVector.setSafe(count + 1, 789);\n+      assertFalse(intDefinedVector.isNull(count + 1));\n+      assertEquals(789, intDefinedVector.get(count + 1));\n+      assertTrue(intDefinedVector.isNull(count));\n+      assertTrue(intDefinedVector.isNull(count + 2));\n+      assertTrue(intDefinedVector.isNull(count + 3));\n+      assertTrue(intDefinedVector.isNull(count + 4));\n+      assertTrue(intDefinedVector.isNull(count + 5));\n+      assertTrue(intDefinedVector.isNull(count + 6));\n+      assertTrue(intDefinedVector.isNull(count + 7));\n+      assertTrue(intDefinedVector.isNull(count + 8));\n+      assertTrue(intDefinedVector.isNull(count + 9));\n+      assertFalse(intDefinedVector.isNull(count + 10));\n+      assertEquals(1234, intDefinedVector.get(count + 10));\n     } finally {\n       for (ArrowBuf arrowBuf : values) {\n         arrowBuf.release();\n       }\n-      validity.release();\n     }\n   }\n \n@@ -258,11 +281,11 @@ public void testUnloadLoadDuplicates() throws IOException {\n         FieldVector vector = field.createVector(originalVectorsAllocator);\n         vector.allocateNew();\n         sources.add(vector);\n-        NullableIntVector.Mutator mutator = (NullableIntVector.Mutator) vector.getMutator();\n+        NullableIntVector intVector = (NullableIntVector)vector;\n         for (int i = 0; i < count; i++) {\n-          mutator.set(i, i);\n+          intVector.set(i, i);\n         }\n-        mutator.setValueCount(count);\n+        intVector.setValueCount(count);\n       }\n \n       try (VectorSchemaRoot root = new VectorSchemaRoot(schema.getFields(), sources, count)) {\n@@ -277,8 +300,8 @@ public void testUnloadLoadDuplicates() throws IOException {\n           List<FieldVector> targets = newRoot.getFieldVectors();\n           Assert.assertEquals(sources.size(), targets.size());\n           for (int k = 0; k < sources.size(); k++) {\n-            NullableIntVector.Accessor src = (NullableIntVector.Accessor) sources.get(k).getAccessor();\n-            NullableIntVector.Accessor tgt = (NullableIntVector.Accessor) targets.get(k).getAccessor();\n+            NullableIntVector src = (NullableIntVector) sources.get(k);\n+            NullableIntVector tgt = (NullableIntVector) targets.get(k);\n             Assert.assertEquals(src.getValueCount(), tgt.getValueCount());\n             for (int i = 0; i < count; i++) {\n               Assert.assertEquals(src.get(i), tgt.get(i));\n@@ -296,9 +319,4 @@ public static VectorUnloader newVectorUnloader(FieldVector root) {\n     VectorSchemaRoot vsr = new VectorSchemaRoot(schema.getFields(), fields, valueCount);\n     return new VectorUnloader(vsr);\n   }\n-\n-  @AfterClass\n-  public static void afterClass() {\n-    allocator.close();\n-  }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/file/BaseFileTest.java b/java/vector/src/test/java/org/apache/arrow/vector/file/BaseFileTest.java\nindex ba62de0a6..60009b0a4 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/file/BaseFileTest.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/file/BaseFileTest.java\n@@ -97,8 +97,14 @@ public void tearDown() {\n \n   protected void validateContent(int count, VectorSchemaRoot root) {\n     for (int i = 0; i < count; i++) {\n-      Assert.assertEquals(i, root.getVector(\"int\").getAccessor().getObject(i));\n-      Assert.assertEquals(Long.valueOf(i), root.getVector(\"bigInt\").getAccessor().getObject(i));\n+      FieldVector fv = root.getVector(\"int\");\n+      if (fv instanceof NullableIntVector) {\n+        Assert.assertEquals(i, fv.getObject(i));\n+        Assert.assertEquals(Integer.valueOf(i), fv.getObject(i));\n+      } else {\n+        Assert.assertEquals(i, fv.getAccessor().getObject(i));\n+        Assert.assertEquals(Long.valueOf(i), fv.getAccessor().getObject(i));\n+      }\n     }\n   }\n \n@@ -152,6 +158,7 @@ protected void validateComplexContent(int count, VectorSchemaRoot root) {\n     Assert.assertEquals(count, root.getRowCount());\n     printVectors(root.getFieldVectors());\n     for (int i = 0; i < count; i++) {\n+\n       Object intVal = root.getVector(\"int\").getAccessor().getObject(i);\n       if (i % 5 != 3) {\n         Assert.assertEquals(i, intVal);\n@@ -220,22 +227,20 @@ protected VectorSchemaRoot writeFlatDictionaryData(BufferAllocator bufferAllocat\n     // Define dictionaries and add to provider\n     NullableVarCharVector dictionary1Vector = newNullableVarCharVector(\"D1\", bufferAllocator);\n     dictionary1Vector.allocateNewSafe();\n-    NullableVarCharVector.Mutator mutator = dictionary1Vector.getMutator();\n-    mutator.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(2, \"baz\".getBytes(StandardCharsets.UTF_8));\n-    mutator.setValueCount(3);\n+    dictionary1Vector.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n+    dictionary1Vector.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n+    dictionary1Vector.set(2, \"baz\".getBytes(StandardCharsets.UTF_8));\n+    dictionary1Vector.setValueCount(3);\n \n     Dictionary dictionary1 = new Dictionary(dictionary1Vector, new DictionaryEncoding(1L, false, null));\n     provider.put(dictionary1);\n \n     NullableVarCharVector dictionary2Vector = newNullableVarCharVector(\"D2\", bufferAllocator);\n     dictionary2Vector.allocateNewSafe();\n-    mutator = dictionary2Vector.getMutator();\n-    mutator.set(0, \"micro\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(1, \"small\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(2, \"large\".getBytes(StandardCharsets.UTF_8));\n-    mutator.setValueCount(3);\n+    dictionary2Vector.set(0, \"micro\".getBytes(StandardCharsets.UTF_8));\n+    dictionary2Vector.set(1, \"small\".getBytes(StandardCharsets.UTF_8));\n+    dictionary2Vector.set(2, \"large\".getBytes(StandardCharsets.UTF_8));\n+    dictionary2Vector.setValueCount(3);\n \n     Dictionary dictionary2 = new Dictionary(dictionary2Vector, new DictionaryEncoding(2L, false, null));\n     provider.put(dictionary2);\n@@ -243,13 +248,12 @@ protected VectorSchemaRoot writeFlatDictionaryData(BufferAllocator bufferAllocat\n     // Populate the vectors\n     NullableVarCharVector vector1A = newNullableVarCharVector(\"varcharA\", bufferAllocator);\n     vector1A.allocateNewSafe();\n-    mutator = vector1A.getMutator();\n-    mutator.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(3, \"baz\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(4, \"bar\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(5, \"baz\".getBytes(StandardCharsets.UTF_8));\n-    mutator.setValueCount(6);\n+    vector1A.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n+    vector1A.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n+    vector1A.set(3, \"baz\".getBytes(StandardCharsets.UTF_8));\n+    vector1A.set(4, \"bar\".getBytes(StandardCharsets.UTF_8));\n+    vector1A.set(5, \"baz\".getBytes(StandardCharsets.UTF_8));\n+    vector1A.setValueCount(6);\n \n     FieldVector encodedVector1A = (FieldVector) DictionaryEncoder.encode(vector1A, dictionary1);\n     vector1A.close();  // Done with this vector after encoding\n@@ -257,22 +261,20 @@ protected VectorSchemaRoot writeFlatDictionaryData(BufferAllocator bufferAllocat\n     // Write this vector using indices instead of encoding\n     NullableIntVector encodedVector1B = new NullableIntVector(\"varcharB\", bufferAllocator);\n     encodedVector1B.allocateNewSafe();\n-    NullableIntVector.Mutator mutator1B = encodedVector1B.getMutator();\n-    mutator1B.set(0, 2);  // \"baz\"\n-    mutator1B.set(1, 1);  // \"bar\"\n-    mutator1B.set(2, 2);  // \"baz\"\n-    mutator1B.set(4, 1);  // \"bar\"\n-    mutator1B.set(5, 0);  // \"foo\"\n-    mutator1B.setValueCount(6);\n+    encodedVector1B.set(0, 2);  // \"baz\"\n+    encodedVector1B.set(1, 1);  // \"bar\"\n+    encodedVector1B.set(2, 2);  // \"baz\"\n+    encodedVector1B.set(4, 1);  // \"bar\"\n+    encodedVector1B.set(5, 0);  // \"foo\"\n+    encodedVector1B.setValueCount(6);\n \n     NullableVarCharVector vector2 = newNullableVarCharVector(\"sizes\", bufferAllocator);\n     vector2.allocateNewSafe();\n-    mutator = vector2.getMutator();\n-    mutator.set(1, \"large\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(2, \"small\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(3, \"small\".getBytes(StandardCharsets.UTF_8));\n-    mutator.set(4, \"large\".getBytes(StandardCharsets.UTF_8));\n-    mutator.setValueCount(6);\n+    vector2.set(1, \"large\".getBytes(StandardCharsets.UTF_8));\n+    vector2.set(2, \"small\".getBytes(StandardCharsets.UTF_8));\n+    vector2.set(3, \"small\".getBytes(StandardCharsets.UTF_8));\n+    vector2.set(4, \"large\".getBytes(StandardCharsets.UTF_8));\n+    vector2.setValueCount(6);\n \n     FieldVector encodedVector2 = (FieldVector) DictionaryEncoder.encode(vector2, dictionary2);\n     vector2.close();  // Done with this vector after encoding\n@@ -355,8 +357,8 @@ protected VectorSchemaRoot writeNestedDictionaryData(BufferAllocator bufferAlloc\n     // Define the dictionary and add to the provider\n     NullableVarCharVector dictionaryVector = newNullableVarCharVector(\"D2\", bufferAllocator);\n     dictionaryVector.allocateNewSafe();\n-    dictionaryVector.getMutator().set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n-    dictionaryVector.getMutator().set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n+    dictionaryVector.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n+    dictionaryVector.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n     dictionaryVector.getMutator().setValueCount(2);\n \n     Dictionary dictionary = new Dictionary(dictionaryVector, new DictionaryEncoding(2L, false, null));\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowFile.java b/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowFile.java\nindex 81e58989f..feae08ea2 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowFile.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/file/TestArrowFile.java\n@@ -581,7 +581,7 @@ public void testWriteReadFixedSizeList() throws IOException {\n         tuples.getMutator().setNotNull(i);\n         floats.getMutator().set(i * 2, i + 0.1f);\n         floats.getMutator().set(i * 2 + 1, i + 10.1f);\n-        ints.getMutator().set(i, i);\n+        ints.set(i, i);\n       }\n \n       parent.getMutator().setValueCount(10);\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T04:55:53.237+0000",
                    "updated": "2017-11-14T04:55:53.237+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16250858",
                    "id": "16250858",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1164: ARROW-1463: [JAVA - WIP] refactoring\nURL: https://github.com/apache/arrow/pull/1164#issuecomment-344146534\n \n \n   Closing this one.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-14T04:55:53.855+0000",
                    "updated": "2017-11-14T04:55:53.855+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16284095",
                    "id": "16284095",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Since there are more child JIRAs here I'm moving this to 0.9.0 to close out remaining items in the next release",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-12-08T19:34:32.114+0000",
                    "updated": "2017-12-08T19:34:32.114+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16371949",
                    "id": "16371949",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Where does this work stand?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-02-21T20:19:29.248+0000",
                    "updated": "2018-02-21T20:19:29.248+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16373438",
                    "id": "16373438",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=siddteotia",
                        "name": "siddteotia",
                        "key": "siddteotia",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=siddteotia&avatarId=32343",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=siddteotia&avatarId=32343",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=siddteotia&avatarId=32343",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=siddteotia&avatarId=32343"
                        },
                        "displayName": "Siddharth Teotia",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "This work and all the follow-up refactoring is complete. I am marking it as resolved. Setting the fix-version as 0.9.0 although some of the tasks were completed in 0.8.0.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=siddteotia",
                        "name": "siddteotia",
                        "key": "siddteotia",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=siddteotia&avatarId=32343",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=siddteotia&avatarId=32343",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=siddteotia&avatarId=32343",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=siddteotia&avatarId=32343"
                        },
                        "displayName": "Siddharth Teotia",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-02-22T21:00:18.450+0000",
                    "updated": "2018-02-22T21:00:18.450+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16424547",
                    "id": "16424547",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler opened a new pull request #1831: ARROW-1463: [Java] Cleanup usage of Types.MinorType to MinorType\nURL: https://github.com/apache/arrow/pull/1831\n \n \n   Cleanup usage specifying Types.MinorType to just MinorType in vector classes and tests, and removed unused imports.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-03T20:25:59.821+0000",
                    "updated": "2018-04-03T20:25:59.821+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16424570",
                    "id": "16424570",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1831: ARROW-1463: [Java] Cleanup usage of Types.MinorType to MinorType\nURL: https://github.com/apache/arrow/pull/1831#issuecomment-378392269\n \n \n   Thanks @icexelloss!  Does this cleanup look ok from your end @siddharthteotia ?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-03T20:41:44.985+0000",
                    "updated": "2018-04-03T20:41:44.985+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16426144",
                    "id": "16426144",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1831: ARROW-1463: [Java] Cleanup usage of Types.MinorType to MinorType\nURL: https://github.com/apache/arrow/pull/1831#issuecomment-378738148\n \n \n   I'll commit this later today if no more comments\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T20:41:20.548+0000",
                    "updated": "2018-04-04T20:41:20.548+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860/comment/16426324",
                    "id": "16426324",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler closed pull request #1831: ARROW-1463: [Java] Cleanup usage of Types.MinorType to MinorType\nURL: https://github.com/apache/arrow/pull/1831\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/java/vector/src/main/codegen/templates/AbstractPromotableFieldWriter.java b/java/vector/src/main/codegen/templates/AbstractPromotableFieldWriter.java\nindex 5b8cfa910..f2aefd122 100644\n--- a/java/vector/src/main/codegen/templates/AbstractPromotableFieldWriter.java\n+++ b/java/vector/src/main/codegen/templates/AbstractPromotableFieldWriter.java\n@@ -86,7 +86,7 @@ public void write(${name}Holder holder) {\n \n   <#if minor.class == \"Decimal\">\n   public void writeBigEndianBytesToDecimal(byte[] value) {\n-    getWriter(Types.MinorType.DECIMAL).writeBigEndianBytesToDecimal(value);\n+    getWriter(MinorType.DECIMAL).writeBigEndianBytesToDecimal(value);\n   }\n   </#if>\n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BigIntVector.java b/java/vector/src/main/java/org/apache/arrow/vector/BigIntVector.java\nindex ccf0c3067..6ff49fa9a 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/BigIntVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BigIntVector.java\n@@ -24,7 +24,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.BigIntHolder;\n import org.apache.arrow.vector.holders.NullableBigIntHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n \n@@ -44,8 +44,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public BigIntVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.BIGINT.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.BIGINT.getType()), allocator);\n   }\n \n   /**\n@@ -75,8 +74,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.BIGINT;\n+  public MinorType getMinorType() {\n+    return MinorType.BIGINT;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BitVector.java b/java/vector/src/main/java/org/apache/arrow/vector/BitVector.java\nindex b7b7b9906..f43444c67 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/BitVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BitVector.java\n@@ -24,7 +24,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.BitHolder;\n import org.apache.arrow.vector.holders.NullableBitHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.OversizedAllocationException;\n import org.apache.arrow.vector.util.TransferPair;\n@@ -45,8 +45,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public BitVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.BIT.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.BIT.getType()), allocator);\n   }\n \n   /**\n@@ -79,8 +78,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.BIT;\n+  public MinorType getMinorType() {\n+    return MinorType.BIT;\n   }\n \n   /**\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/DateDayVector.java b/java/vector/src/main/java/org/apache/arrow/vector/DateDayVector.java\nindex ed8956c1e..22f0aa16e 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/DateDayVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/DateDayVector.java\n@@ -24,10 +24,9 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.DateDayHolder;\n import org.apache.arrow.vector.holders.NullableDateDayHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n-import org.slf4j.Logger;\n \n /**\n  * DateDayVector implements a fixed width (4 bytes) vector of\n@@ -45,8 +44,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public DateDayVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.DATEDAY.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.DATEDAY.getType()), allocator);\n   }\n \n   /**\n@@ -76,8 +74,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.DATEDAY;\n+  public MinorType getMinorType() {\n+    return MinorType.DATEDAY;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/DateMilliVector.java b/java/vector/src/main/java/org/apache/arrow/vector/DateMilliVector.java\nindex f21b58f85..2e3264656 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/DateMilliVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/DateMilliVector.java\n@@ -24,12 +24,10 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.DateMilliHolder;\n import org.apache.arrow.vector.holders.NullableDateMilliHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n import org.joda.time.LocalDateTime;\n-import org.joda.time.LocalDateTimes;\n-import org.slf4j.Logger;\n \n /**\n  * DateMilliVector implements a fixed width vector (8 bytes) of\n@@ -47,8 +45,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public DateMilliVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.DATEMILLI.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.DATEMILLI.getType()), allocator);\n   }\n \n   /**\n@@ -78,8 +75,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.DATEMILLI;\n+  public MinorType getMinorType() {\n+    return MinorType.DATEMILLI;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/DecimalVector.java b/java/vector/src/main/java/org/apache/arrow/vector/DecimalVector.java\nindex db5af51a7..6e9d647ad 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/DecimalVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/DecimalVector.java\n@@ -24,7 +24,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.DecimalHolder;\n import org.apache.arrow.vector.holders.NullableDecimalHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.DecimalUtility;\n import org.apache.arrow.vector.util.TransferPair;\n@@ -85,8 +85,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.DECIMAL;\n+  public MinorType getMinorType() {\n+    return MinorType.DECIMAL;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/FixedSizeBinaryVector.java b/java/vector/src/main/java/org/apache/arrow/vector/FixedSizeBinaryVector.java\nindex 232e6564a..87fdf6dab 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/FixedSizeBinaryVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/FixedSizeBinaryVector.java\n@@ -24,7 +24,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.FixedSizeBinaryHolder;\n import org.apache.arrow.vector.holders.NullableFixedSizeBinaryHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.ArrowType.FixedSizeBinary;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n@@ -82,8 +82,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.FIXEDSIZEBINARY;\n+  public MinorType getMinorType() {\n+    return MinorType.FIXEDSIZEBINARY;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/Float4Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/Float4Vector.java\nindex dc78bfde2..11286e38f 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/Float4Vector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/Float4Vector.java\n@@ -24,7 +24,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.Float4Holder;\n import org.apache.arrow.vector.holders.NullableFloat4Holder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n \n@@ -44,8 +44,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public Float4Vector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.FLOAT4.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.FLOAT4.getType()), allocator);\n   }\n \n   /**\n@@ -75,8 +74,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.FLOAT4;\n+  public MinorType getMinorType() {\n+    return MinorType.FLOAT4;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/Float8Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/Float8Vector.java\nindex 1b410b868..d499c8341 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/Float8Vector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/Float8Vector.java\n@@ -24,7 +24,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.Float8Holder;\n import org.apache.arrow.vector.holders.NullableFloat8Holder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n \n@@ -44,8 +44,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public Float8Vector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.FLOAT8.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.FLOAT8.getType()), allocator);\n   }\n \n   /**\n@@ -75,8 +74,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.FLOAT8;\n+  public MinorType getMinorType() {\n+    return MinorType.FLOAT8;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/IntVector.java b/java/vector/src/main/java/org/apache/arrow/vector/IntVector.java\nindex 2364310e6..ffa07f956 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/IntVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/IntVector.java\n@@ -24,7 +24,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.IntHolder;\n import org.apache.arrow.vector.holders.NullableIntHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n \n@@ -45,8 +45,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public IntVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.INT.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.INT.getType()), allocator);\n   }\n \n   /**\n@@ -79,8 +78,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.INT;\n+  public MinorType getMinorType() {\n+    return MinorType.INT;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/IntervalDayVector.java b/java/vector/src/main/java/org/apache/arrow/vector/IntervalDayVector.java\nindex 481a66f4e..0142dd54f 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/IntervalDayVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/IntervalDayVector.java\n@@ -24,7 +24,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.IntervalDayHolder;\n import org.apache.arrow.vector.holders.NullableIntervalDayHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n import org.joda.time.Period;\n@@ -47,8 +47,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public IntervalDayVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.INTERVALDAY.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.INTERVALDAY.getType()), allocator);\n   }\n \n   /**\n@@ -78,8 +77,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.INTERVALDAY;\n+  public MinorType getMinorType() {\n+    return MinorType.INTERVALDAY;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/IntervalYearVector.java b/java/vector/src/main/java/org/apache/arrow/vector/IntervalYearVector.java\nindex 2aa728f3d..ed627bbc7 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/IntervalYearVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/IntervalYearVector.java\n@@ -23,7 +23,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.IntervalYearHolder;\n import org.apache.arrow.vector.holders.NullableIntervalYearHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n import org.joda.time.Period;\n@@ -44,8 +44,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public IntervalYearVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.INTERVALYEAR.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.INTERVALYEAR.getType()), allocator);\n   }\n \n   /**\n@@ -75,8 +74,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.INTERVALYEAR;\n+  public MinorType getMinorType() {\n+    return MinorType.INTERVALYEAR;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/SmallIntVector.java b/java/vector/src/main/java/org/apache/arrow/vector/SmallIntVector.java\nindex 859e62dbb..29194ae7f 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/SmallIntVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/SmallIntVector.java\n@@ -24,7 +24,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.SmallIntHolder;\n import org.apache.arrow.vector.holders.NullableSmallIntHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n \n@@ -44,8 +44,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public SmallIntVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.SMALLINT.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.SMALLINT.getType()), allocator);\n   }\n \n   /**\n@@ -75,8 +74,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.SMALLINT;\n+  public MinorType getMinorType() {\n+    return MinorType.SMALLINT;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/TimeMicroVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeMicroVector.java\nindex 604cedffd..a704bfd7a 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/TimeMicroVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeMicroVector.java\n@@ -24,10 +24,9 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.TimeMicroHolder;\n import org.apache.arrow.vector.holders.NullableTimeMicroHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n-import org.slf4j.Logger;\n \n /**\n  * TimeMicroVector implements a fixed width vector (8 bytes) of\n@@ -46,8 +45,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public TimeMicroVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.TIMEMICRO.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.TIMEMICRO.getType()), allocator);\n   }\n \n   /**\n@@ -77,8 +75,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.TIMEMICRO;\n+  public MinorType getMinorType() {\n+    return MinorType.TIMEMICRO;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/TimeMilliVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeMilliVector.java\nindex c3d100c5b..bc61def6b 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/TimeMilliVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeMilliVector.java\n@@ -24,7 +24,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.TimeMilliHolder;\n import org.apache.arrow.vector.holders.NullableTimeMilliHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n import org.joda.time.LocalDateTime;\n@@ -46,8 +46,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public TimeMilliVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.TIMEMILLI.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.TIMEMILLI.getType()), allocator);\n   }\n \n   /**\n@@ -77,8 +76,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.TIMEMILLI;\n+  public MinorType getMinorType() {\n+    return MinorType.TIMEMILLI;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/TimeNanoVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeNanoVector.java\nindex 97401ec8a..b31797c5e 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/TimeNanoVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeNanoVector.java\n@@ -24,7 +24,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.TimeNanoHolder;\n import org.apache.arrow.vector.holders.NullableTimeNanoHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n \n@@ -44,8 +44,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public TimeNanoVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.TIMENANO.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.TIMENANO.getType()), allocator);\n   }\n \n   /**\n@@ -75,8 +74,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.TIMENANO;\n+  public MinorType getMinorType() {\n+    return MinorType.TIMENANO;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/TimeSecVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeSecVector.java\nindex a7823a916..407238e47 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/TimeSecVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeSecVector.java\n@@ -24,7 +24,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.TimeSecHolder;\n import org.apache.arrow.vector.holders.NullableTimeSecHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n \n@@ -44,8 +44,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public TimeSecVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.TIMESEC.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.TIMESEC.getType()), allocator);\n   }\n \n   /**\n@@ -75,8 +74,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.TIMESEC;\n+  public MinorType getMinorType() {\n+    return MinorType.TIMESEC;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMicroTZVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMicroTZVector.java\nindex bfe330a1e..d7ada2eb3 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMicroTZVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMicroTZVector.java\n@@ -24,7 +24,7 @@\n import org.apache.arrow.vector.holders.TimeStampMicroTZHolder;\n import org.apache.arrow.vector.holders.NullableTimeStampMicroTZHolder;\n import org.apache.arrow.vector.types.TimeUnit;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n \n@@ -77,8 +77,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.TIMESTAMPMICROTZ;\n+  public MinorType getMinorType() {\n+    return MinorType.TIMESTAMPMICROTZ;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMicroVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMicroVector.java\nindex 85b615d8f..e689627cf 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMicroVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMicroVector.java\n@@ -23,7 +23,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.TimeStampMicroHolder;\n import org.apache.arrow.vector.holders.NullableTimeStampMicroHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n import org.joda.time.LocalDateTime;\n@@ -43,8 +43,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public TimeStampMicroVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.TIMESTAMPMICRO.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.TIMESTAMPMICRO.getType()), allocator);\n   }\n \n   /**\n@@ -74,8 +73,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.TIMESTAMPMICRO;\n+  public MinorType getMinorType() {\n+    return MinorType.TIMESTAMPMICRO;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMilliTZVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMilliTZVector.java\nindex 9d68b5644..2f9fc8820 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMilliTZVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMilliTZVector.java\n@@ -24,7 +24,7 @@\n import org.apache.arrow.vector.holders.TimeStampMilliTZHolder;\n import org.apache.arrow.vector.holders.NullableTimeStampMilliTZHolder;\n import org.apache.arrow.vector.types.TimeUnit;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n \n@@ -77,8 +77,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.TIMESTAMPMILLITZ;\n+  public MinorType getMinorType() {\n+    return MinorType.TIMESTAMPMILLITZ;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMilliVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMilliVector.java\nindex 7e8a1d0e2..75493a942 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMilliVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMilliVector.java\n@@ -23,7 +23,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.TimeStampMilliHolder;\n import org.apache.arrow.vector.holders.NullableTimeStampMilliHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n import org.joda.time.LocalDateTime;\n@@ -43,8 +43,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public TimeStampMilliVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.TIMESTAMPMILLI.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.TIMESTAMPMILLI.getType()), allocator);\n   }\n \n   /**\n@@ -74,8 +73,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.TIMESTAMPMILLI;\n+  public MinorType getMinorType() {\n+    return MinorType.TIMESTAMPMILLI;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/TimeStampNanoTZVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampNanoTZVector.java\nindex e03618201..d62e14a0d 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/TimeStampNanoTZVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampNanoTZVector.java\n@@ -24,7 +24,7 @@\n import org.apache.arrow.vector.holders.TimeStampNanoTZHolder;\n import org.apache.arrow.vector.holders.NullableTimeStampNanoTZHolder;\n import org.apache.arrow.vector.types.TimeUnit;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n \n@@ -77,8 +77,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.TIMESTAMPNANOTZ;\n+  public MinorType getMinorType() {\n+    return MinorType.TIMESTAMPNANOTZ;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/TimeStampNanoVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampNanoVector.java\nindex fdf5d2694..d13445213 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/TimeStampNanoVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampNanoVector.java\n@@ -23,7 +23,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.TimeStampNanoHolder;\n import org.apache.arrow.vector.holders.NullableTimeStampNanoHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n import org.joda.time.LocalDateTime;\n@@ -43,8 +43,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public TimeStampNanoVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.TIMESTAMPNANO.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.TIMESTAMPNANO.getType()), allocator);\n   }\n \n   /**\n@@ -74,8 +73,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.TIMESTAMPNANO;\n+  public MinorType getMinorType() {\n+    return MinorType.TIMESTAMPNANO;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/TimeStampSecTZVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampSecTZVector.java\nindex 201f1c317..dabfb1e6e 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/TimeStampSecTZVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampSecTZVector.java\n@@ -23,7 +23,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.TimeStampSecTZHolder;\n import org.apache.arrow.vector.holders.NullableTimeStampSecTZHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n \n@@ -76,8 +76,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.TIMESTAMPSECTZ;\n+  public MinorType getMinorType() {\n+    return MinorType.TIMESTAMPSECTZ;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/TimeStampSecVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampSecVector.java\nindex 4bcd4f7bf..91733c707 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/TimeStampSecVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampSecVector.java\n@@ -23,7 +23,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.TimeStampSecHolder;\n import org.apache.arrow.vector.holders.NullableTimeStampSecHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n import org.joda.time.LocalDateTime;\n@@ -43,8 +43,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public TimeStampSecVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.TIMESTAMPSEC.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.TIMESTAMPSEC.getType()), allocator);\n   }\n \n   /**\n@@ -74,8 +73,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.TIMESTAMPSEC;\n+  public MinorType getMinorType() {\n+    return MinorType.TIMESTAMPSEC;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/TinyIntVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TinyIntVector.java\nindex 306437f0f..25404ff45 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/TinyIntVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TinyIntVector.java\n@@ -24,7 +24,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.TinyIntHolder;\n import org.apache.arrow.vector.holders.NullableTinyIntHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n \n@@ -44,8 +44,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public TinyIntVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.TINYINT.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.TINYINT.getType()), allocator);\n   }\n \n   /**\n@@ -75,8 +74,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.TINYINT;\n+  public MinorType getMinorType() {\n+    return MinorType.TINYINT;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/UInt1Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/UInt1Vector.java\nindex 6901a889a..2c57b64e8 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/UInt1Vector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/UInt1Vector.java\n@@ -23,7 +23,7 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.UInt1Holder;\n import org.apache.arrow.vector.holders.NullableUInt1Holder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n \n@@ -37,8 +37,7 @@\n   private final FieldReader reader;\n \n   public UInt1Vector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.UINT1.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.UINT1.getType()), allocator);\n   }\n \n   public UInt1Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n@@ -52,8 +51,8 @@ public FieldReader getReader() {\n   }\n \n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.UINT1;\n+  public MinorType getMinorType() {\n+    return MinorType.UINT1;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/UInt2Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/UInt2Vector.java\nindex 968ce9151..6c83ae8b3 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/UInt2Vector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/UInt2Vector.java\n@@ -23,10 +23,9 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.UInt2Holder;\n import org.apache.arrow.vector.holders.NullableUInt2Holder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n-import org.slf4j.Logger;\n \n /**\n  * UInt2Vector implements a fixed width (2 bytes) vector of\n@@ -38,8 +37,7 @@\n   private final FieldReader reader;\n \n   public UInt2Vector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.UINT2.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.UINT2.getType()), allocator);\n   }\n \n   public UInt2Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n@@ -53,8 +51,8 @@ public FieldReader getReader() {\n   }\n \n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.UINT2;\n+  public MinorType getMinorType() {\n+    return MinorType.UINT2;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/UInt4Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/UInt4Vector.java\nindex af219cb06..de078f191 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/UInt4Vector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/UInt4Vector.java\n@@ -23,10 +23,9 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.UInt4Holder;\n import org.apache.arrow.vector.holders.NullableUInt4Holder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n-import org.slf4j.Logger;\n \n /**\n  * UInt4Vector implements a fixed width (4 bytes) vector of\n@@ -38,8 +37,7 @@\n   private final FieldReader reader;\n \n   public UInt4Vector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.UINT4.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.UINT4.getType()), allocator);\n   }\n \n   public UInt4Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n@@ -53,8 +51,8 @@ public FieldReader getReader() {\n   }\n \n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.UINT4;\n+  public MinorType getMinorType() {\n+    return MinorType.UINT4;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/UInt8Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/UInt8Vector.java\nindex eae4a3172..7440c278e 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/UInt8Vector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/UInt8Vector.java\n@@ -23,10 +23,9 @@\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.UInt8Holder;\n import org.apache.arrow.vector.holders.NullableUInt8Holder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n-import org.slf4j.Logger;\n \n /**\n  * UInt8Vector implements a fixed width vector (8 bytes) of\n@@ -38,8 +37,7 @@\n   private final FieldReader reader;\n \n   public UInt8Vector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.UINT8.getType()),\n-            allocator);\n+    this(name, FieldType.nullable(MinorType.UINT8.getType()), allocator);\n   }\n \n   public UInt8Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n@@ -53,8 +51,8 @@ public FieldReader getReader() {\n   }\n \n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.UINT8;\n+  public MinorType getMinorType() {\n+    return MinorType.UINT8;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/VarBinaryVector.java b/java/vector/src/main/java/org/apache/arrow/vector/VarBinaryVector.java\nindex 893ad7cb5..ec0e53d0e 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/VarBinaryVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/VarBinaryVector.java\n@@ -18,18 +18,15 @@\n \n package org.apache.arrow.vector;\n \n-import io.netty.buffer.ArrowBuf;\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.complex.impl.VarBinaryReaderImpl;\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.VarBinaryHolder;\n import org.apache.arrow.vector.holders.NullableVarBinaryHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n \n-import java.nio.ByteBuffer;\n-\n /**\n  * VarBinaryVector implements a variable width vector of binary\n  * values which could be NULL. A validity buffer (bit vector) is maintained\n@@ -45,7 +42,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public VarBinaryVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.VARBINARY.getType()), allocator);\n+    this(name, FieldType.nullable(MinorType.VARBINARY.getType()), allocator);\n   }\n \n   /**\n@@ -75,8 +72,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.VARBINARY;\n+  public MinorType getMinorType() {\n+    return MinorType.VARBINARY;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/VarCharVector.java b/java/vector/src/main/java/org/apache/arrow/vector/VarCharVector.java\nindex 8a38b1d45..9bfb56c2e 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/VarCharVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/VarCharVector.java\n@@ -18,19 +18,16 @@\n \n package org.apache.arrow.vector;\n \n-import io.netty.buffer.ArrowBuf;\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.complex.impl.VarCharReaderImpl;\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.VarCharHolder;\n import org.apache.arrow.vector.holders.NullableVarCharHolder;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.Text;\n import org.apache.arrow.vector.util.TransferPair;\n \n-import java.nio.ByteBuffer;\n-\n /**\n  * VarCharVector implements a variable width vector of VARCHAR\n  * values which could be NULL. A validity buffer (bit vector) is maintained\n@@ -46,7 +43,7 @@\n    * @param allocator allocator for memory management.\n    */\n   public VarCharVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.VARCHAR.getType()), allocator);\n+    this(name, FieldType.nullable(MinorType.VARCHAR.getType()), allocator);\n   }\n \n   /**\n@@ -76,8 +73,8 @@ public FieldReader getReader() {\n    * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n    */\n   @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.VARCHAR;\n+  public MinorType getMinorType() {\n+    return MinorType.VARCHAR;\n   }\n \n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/ipc/JsonFileWriter.java b/java/vector/src/main/java/org/apache/arrow/vector/ipc/JsonFileWriter.java\nindex ad56d573b..80b8c4788 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/ipc/JsonFileWriter.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/ipc/JsonFileWriter.java\n@@ -35,7 +35,7 @@\n import org.apache.arrow.vector.dictionary.DictionaryProvider;\n import org.apache.arrow.vector.BufferLayout.BufferType;\n import org.apache.arrow.vector.TypeLayout;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.Field;\n import org.apache.arrow.vector.types.pojo.Schema;\n \n@@ -170,8 +170,8 @@ private void writeFromVectorIntoJson(Field field, FieldVector vector) throws IOE\n         generator.writeArrayFieldStart(bufferType.getName());\n         final int bufferValueCount = (bufferType.equals(OFFSET)) ? valueCount + 1 : valueCount;\n         for (int i = 0; i < bufferValueCount; i++) {\n-          if (bufferType.equals(DATA) && (vector.getMinorType() == Types.MinorType.VARCHAR ||\n-                  vector.getMinorType() == Types.MinorType.VARBINARY)) {\n+          if (bufferType.equals(DATA) && (vector.getMinorType() == MinorType.VARCHAR ||\n+                  vector.getMinorType() == MinorType.VARBINARY)) {\n             writeValueToGenerator(bufferType, vectorBuffer, vectorBuffers.get(v-1), vector, i);\n           } else {\n             writeValueToGenerator(bufferType, vectorBuffer, null, vector, i);\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestCopyFrom.java b/java/vector/src/test/java/org/apache/arrow/vector/TestCopyFrom.java\nindex 87ffcafec..7f3f548eb 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestCopyFrom.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestCopyFrom.java\n@@ -20,7 +20,7 @@\n \n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.memory.RootAllocator;\n-import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.Types.MinorType;\n import org.joda.time.Period;\n import org.junit.After;\n import org.junit.Before;\n@@ -70,8 +70,8 @@ public void terminate() throws Exception {\n \n   @Test /* NullableVarChar */\n   public void testCopyFromWithNulls() {\n-    try (final VarCharVector vector = newVector(VarCharVector.class, EMPTY_SCHEMA_PATH, Types.MinorType.VARCHAR, allocator);\n-         final VarCharVector vector2 = newVector(VarCharVector.class, EMPTY_SCHEMA_PATH, Types.MinorType.VARCHAR, allocator)) {\n+    try (final VarCharVector vector = newVector(VarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator);\n+         final VarCharVector vector2 = newVector(VarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n \n       vector.allocateNew();\n       int capacity = vector.getValueCapacity();\n@@ -130,8 +130,8 @@ public void testCopyFromWithNulls() {\n \n   @Test /* NullableVarChar */\n   public void testCopyFromWithNulls1() {\n-    try (final VarCharVector vector = newVector(VarCharVector.class, EMPTY_SCHEMA_PATH, Types.MinorType.VARCHAR, allocator);\n-         final VarCharVector vector2 = newVector(VarCharVector.class, EMPTY_SCHEMA_PATH, Types.MinorType.VARCHAR, allocator)) {\n+    try (final VarCharVector vector = newVector(VarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator);\n+         final VarCharVector vector2 = newVector(VarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n \n       vector.allocateNew();\n       int capacity = vector.getValueCapacity();\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java\nindex 50438ce11..d419c86c5 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java\n@@ -26,7 +26,6 @@\n import org.apache.arrow.vector.complex.impl.UnionFixedSizeListReader;\n import org.apache.arrow.vector.complex.impl.UnionListReader;\n import org.apache.arrow.vector.complex.reader.FieldReader;\n-import org.apache.arrow.vector.types.Types;\n import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.ArrowType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n@@ -224,7 +223,7 @@ public void testConsistentChildName() throws Exception {\n       String emptyListStr = listVector.getField().toString();\n       Assert.assertTrue(emptyListStr.contains(ListVector.DATA_VECTOR_NAME));\n \n-      listVector.addOrGetVector(FieldType.nullable(Types.MinorType.INT.getType()));\n+      listVector.addOrGetVector(FieldType.nullable(MinorType.INT.getType()));\n       String emptyVectorStr = listVector.getField().toString();\n       Assert.assertTrue(emptyVectorStr.contains(ListVector.DATA_VECTOR_NAME));\n     }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestListVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestListVector.java\nindex d12586ecc..aea7caf8e 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestListVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestListVector.java\n@@ -27,7 +27,6 @@\n import org.apache.arrow.vector.complex.ListVector;\n import org.apache.arrow.vector.complex.impl.UnionListWriter;\n import org.apache.arrow.vector.complex.reader.FieldReader;\n-import org.apache.arrow.vector.types.Types;\n import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.TransferPair;\n@@ -759,7 +758,7 @@ public void testConsistentChildName() throws Exception {\n       String emptyListStr = listVector.getField().toString();\n       assertTrue(emptyListStr.contains(ListVector.DATA_VECTOR_NAME));\n \n-      listVector.addOrGetVector(FieldType.nullable(Types.MinorType.INT.getType()));\n+      listVector.addOrGetVector(FieldType.nullable(MinorType.INT.getType()));\n       String emptyVectorStr = listVector.getField().toString();\n       assertTrue(emptyVectorStr.contains(ListVector.DATA_VECTOR_NAME));\n     }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestUnionVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestUnionVector.java\nindex aec7d0f32..56cff203e 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestUnionVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestUnionVector.java\n@@ -30,7 +30,6 @@\n import org.apache.arrow.vector.holders.NullableIntHolder;\n import org.apache.arrow.vector.holders.NullableUInt4Holder;\n import org.apache.arrow.vector.holders.NullableFloat4Holder;\n-import org.apache.arrow.vector.types.Types;\n import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.util.TransferPair;\n import org.junit.After;\n@@ -65,9 +64,9 @@ public void testUnionVector() throws Exception {\n       unionVector.allocateNew();\n \n       // write some data\n-      unionVector.setType(0, Types.MinorType.UINT4);\n+      unionVector.setType(0, MinorType.UINT4);\n       unionVector.setSafe(0, uInt4Holder);\n-      unionVector.setType(2, Types.MinorType.UINT4);\n+      unionVector.setType(2, MinorType.UINT4);\n       unionVector.setSafe(2, uInt4Holder);\n       unionVector.setValueCount(4);\n \n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T23:29:55.934+0000",
                    "updated": "2018-04-04T23:29:55.934+0000"
                }
            ],
            "maxResults": 30,
            "total": 30,
            "startAt": 0
        },
        "customfield_12311820": "0|i3jnrz:",
        "customfield_12314139": null
    }
}