{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13447175",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175",
    "key": "ARROW-16677",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351550",
                "id": "12351550",
                "name": "9.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-08-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12641889",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12641889",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "inwardIssue": {
                    "id": "13449783",
                    "key": "ARROW-16823",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449783",
                    "fields": {
                        "summary": "[C++] Arrow Substrait enhancements for UDF",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rtpsw",
            "name": "rtpsw",
            "key": "JIRAUSER284707",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=JIRAUSER284707&avatarId=49322",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=JIRAUSER284707&avatarId=49322",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=JIRAUSER284707&avatarId=49322",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=JIRAUSER284707&avatarId=49322"
            },
            "displayName": "Yaron Gvili",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rtpsw",
            "name": "rtpsw",
            "key": "JIRAUSER284707",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=JIRAUSER284707&avatarId=49322",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=JIRAUSER284707&avatarId=49322",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=JIRAUSER284707&avatarId=49322",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=JIRAUSER284707&avatarId=49322"
            },
            "displayName": "Yaron Gvili",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rtpsw",
            "name": "rtpsw",
            "key": "JIRAUSER284707",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=JIRAUSER284707&avatarId=49322",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=JIRAUSER284707&avatarId=49322",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=JIRAUSER284707&avatarId=49322",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=JIRAUSER284707&avatarId=49322"
            },
            "displayName": "Yaron Gvili",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 10800,
            "total": 10800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 10800,
            "total": 10800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16677/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 18,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175/worklog/775437",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw opened a new pull request, #13252:\nURL: https://github.com/apache/arrow/pull/13252\n\n   Currently, only a default function-registry is supported. Modifying this registry has global effects, which is often undesirable. Support for nesting function-registries will provide scoping for such modifications.\n\n\n",
                    "created": "2022-05-27T09:07:40.296+0000",
                    "updated": "2022-05-27T09:07:40.296+0000",
                    "started": "2022-05-27T09:07:40.295+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "775437",
                    "issueId": "13447175"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175/worklog/775438",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13252:\nURL: https://github.com/apache/arrow/pull/13252#issuecomment-1139429542\n\n   https://issues.apache.org/jira/browse/ARROW-16677\n\n\n",
                    "created": "2022-05-27T09:08:01.872+0000",
                    "updated": "2022-05-27T09:08:01.872+0000",
                    "started": "2022-05-27T09:08:01.872+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "775438",
                    "issueId": "13447175"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175/worklog/775439",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13252:\nURL: https://github.com/apache/arrow/pull/13252#issuecomment-1139429563\n\n   :warning: Ticket **has not been started in JIRA**, please click 'Start Progress'.\n\n\n",
                    "created": "2022-05-27T09:08:03.702+0000",
                    "updated": "2022-05-27T09:08:03.702+0000",
                    "started": "2022-05-27T09:08:03.702+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "775439",
                    "issueId": "13447175"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175/worklog/775440",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #13252:\nURL: https://github.com/apache/arrow/pull/13252#issuecomment-1139429871\n\n   cc @icexelloss\n\n\n",
                    "created": "2022-05-27T09:08:25.791+0000",
                    "updated": "2022-05-27T09:08:25.791+0000",
                    "started": "2022-05-27T09:08:25.791+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "775440",
                    "issueId": "13447175"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175/worklog/775441",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #13252:\nURL: https://github.com/apache/arrow/pull/13252#issuecomment-1139431222\n\n   This proposed feature, along with the one in https://github.com/apache/arrow/pull/13232 , would enable scoping for all registries used for UDFs.\n\n\n",
                    "created": "2022-05-27T09:10:11.926+0000",
                    "updated": "2022-05-27T09:10:11.926+0000",
                    "started": "2022-05-27T09:10:11.925+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "775441",
                    "issueId": "13447175"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175/worklog/777582",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #13252:\nURL: https://github.com/apache/arrow/pull/13252#issuecomment-1144909608\n\n   @westonpace - could you review?\n\n\n",
                    "created": "2022-06-02T14:07:08.600+0000",
                    "updated": "2022-06-02T14:07:08.600+0000",
                    "started": "2022-06-02T14:07:08.599+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "777582",
                    "issueId": "13447175"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175/worklog/777896",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13252:\nURL: https://github.com/apache/arrow/pull/13252#discussion_r888518121\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,7 +34,20 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n+  virtual ~FunctionRegistryImpl() {}\n+\n+ private:\n\nReview Comment:\n   Instead of switching back and forth between public and private can we group the public and private functions together?\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -48,23 +61,56 @@ class FunctionRegistry::FunctionRegistryImpl {\n     if (it != name_to_function_.end() && !allow_overwrite) {\n       return Status::KeyError(\"Already have a function registered with name: \", name);\n     }\n-    name_to_function_[name] = std::move(function);\n+    add(name, std::move(function));\n\nReview Comment:\n   ```suggestion\r\n       if (do_add) {\r\n         name_to_function_[name] = std::move(function);\r\n       }\r\n   ```\r\n   If we change `add` to `bool do_add` I think this is a bit easier to follow.  If performance is a concern (I don't think it would be as this isn't really in a critical section) you could use a template...\r\n   \r\n   ```\r\n   template <bool kDoAdd>\r\n   Status DoAddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\r\n     ...\r\n     if (kDoAdd) {\r\n       name_to_function_[name] = std::move(function);\r\n     }\r\n   }\r\n   virtual Status CanAddFunction(std::shared_ptr<Function> function,\r\n                                 bool allow_overwrite) {\r\n     return DoAddFunction<false>(function, allow_overwrite);\r\n   }\r\n   ...\r\n   \r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry_test.cc:\n##########\n@@ -27,37 +27,44 @@\n #include \"arrow/status.h\"\n #include \"arrow/testing/gtest_util.h\"\n #include \"arrow/util/macros.h\"\n+#include \"arrow/util/make_unique.h\"\n \n namespace arrow {\n namespace compute {\n \n-class TestRegistry : public ::testing::Test {\n- public:\n-  void SetUp() { registry_ = FunctionRegistry::Make(); }\n+using MakeFunctionRegistry = std::function<std::unique_ptr<FunctionRegistry>()>;\n+using GetNumFunctions = std::function<int()>;\n+using GetFunctionNames = std::function<std::vector<std::string>()>;\n+using TestRegistryParams =\n+    std::tuple<MakeFunctionRegistry, GetNumFunctions, GetFunctionNames, std::string>;\n \n- protected:\n-  std::unique_ptr<FunctionRegistry> registry_;\n-};\n+struct TestRegistry : public ::testing::TestWithParam<TestRegistryParams> {};\n \n-TEST_F(TestRegistry, CreateBuiltInRegistry) {\n+TEST(TestRegistry, CreateBuiltInRegistry) {\n\nReview Comment:\n   TEST_P? (I might be wrong here.  I can't remember if it's ok to mix parameterized and non-parameterized tests)\n\n\n\n##########\ncpp/src/arrow/compute/registry_test.cc:\n##########\n@@ -27,37 +27,44 @@\n #include \"arrow/status.h\"\n #include \"arrow/testing/gtest_util.h\"\n #include \"arrow/util/macros.h\"\n+#include \"arrow/util/make_unique.h\"\n \n namespace arrow {\n namespace compute {\n \n-class TestRegistry : public ::testing::Test {\n- public:\n-  void SetUp() { registry_ = FunctionRegistry::Make(); }\n+using MakeFunctionRegistry = std::function<std::unique_ptr<FunctionRegistry>()>;\n+using GetNumFunctions = std::function<int()>;\n+using GetFunctionNames = std::function<std::vector<std::string>()>;\n+using TestRegistryParams =\n+    std::tuple<MakeFunctionRegistry, GetNumFunctions, GetFunctionNames, std::string>;\n \n- protected:\n-  std::unique_ptr<FunctionRegistry> registry_;\n-};\n+struct TestRegistry : public ::testing::TestWithParam<TestRegistryParams> {};\n \n-TEST_F(TestRegistry, CreateBuiltInRegistry) {\n+TEST(TestRegistry, CreateBuiltInRegistry) {\n   // This does DCHECK_OK internally for now so this will fail in debug builds\n   // if there is a problem initializing the global function registry\n   FunctionRegistry* registry = GetFunctionRegistry();\n   ARROW_UNUSED(registry);\n }\n \n-TEST_F(TestRegistry, Basics) {\n-  ASSERT_EQ(0, registry_->num_functions());\n+TEST_P(TestRegistry, Basics) {\n+  auto registry_factory = std::get<0>(GetParam());\n+  auto registry_ = registry_factory();\n+  auto get_num_funcs = std::get<1>(GetParam());\n+  int n_funcs = get_num_funcs();\n+  auto get_func_names = std::get<2>(GetParam());\n+  std::vector<std::string> func_names = get_func_names();\n+  ASSERT_EQ(n_funcs + 0, registry_->num_functions());\n\nReview Comment:\n   ```suggestion\r\n     ASSERT_EQ(n_funcs, registry_->num_functions());\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry.h:\n##########\n@@ -84,6 +106,11 @@ class ARROW_EXPORT FunctionRegistry {\n   // Use PIMPL pattern to not have std::unordered_map here\n   class FunctionRegistryImpl;\n   std::unique_ptr<FunctionRegistryImpl> impl_;\n+\n+  explicit FunctionRegistry(FunctionRegistryImpl* impl);\n+\n+  class NestedFunctionRegistryImpl;\n+  friend class NestedFunctionRegistryImpl;\n\nReview Comment:\n   I'm not sure this friend declaration is needed.\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -48,23 +61,56 @@ class FunctionRegistry::FunctionRegistryImpl {\n     if (it != name_to_function_.end() && !allow_overwrite) {\n       return Status::KeyError(\"Already have a function registered with name: \", name);\n     }\n-    name_to_function_[name] = std::move(function);\n+    add(name, std::move(function));\n     return Status::OK();\n   }\n \n-  Status AddAlias(const std::string& target_name, const std::string& source_name) {\n+ public:\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n+                                bool allow_overwrite) {\n+    return DoAddFunction(function, allow_overwrite, kFuncAddNoOp);\n+  }\n+\n+  virtual Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n+    return DoAddFunction(function, allow_overwrite, kFuncAddDo);\n+  }\n+\n+ private:\n+  Status DoAddAlias(const std::string& target_name, const std::string& source_name,\n+                    FuncAdd add) {\n     std::lock_guard<std::mutex> mutation_guard(lock_);\n \n-    auto it = name_to_function_.find(source_name);\n-    if (it == name_to_function_.end()) {\n+    auto func_res = GetFunction(source_name);  // must not acquire the mutex\n+    if (!func_res.ok()) {\n       return Status::KeyError(\"No function registered with name: \", source_name);\n     }\n-    name_to_function_[target_name] = it->second;\n+    add(target_name, func_res.ValueOrDie());\n     return Status::OK();\n   }\n \n-  Status AddFunctionOptionsType(const FunctionOptionsType* options_type,\n-                                bool allow_overwrite = false) {\n+ public:\n+  virtual Status CanAddAlias(const std::string& target_name,\n+                             const std::string& source_name) {\n+    return DoAddAlias(target_name, source_name, kFuncAddNoOp);\n+  }\n+\n+  virtual Status AddAlias(const std::string& target_name,\n+                          const std::string& source_name) {\n+    return DoAddAlias(target_name, source_name, kFuncAddDo);\n+  }\n+\n+ private:\n+  using FuncOptTypeAdd = std::function<void(const FunctionOptionsType* options_type)>;\n+\n+  const FuncOptTypeAdd kFuncOptTypeAddNoOp = [](const FunctionOptionsType* options_type) {\n+  };\n+  const FuncOptTypeAdd kFuncOptTypeAddDo =\n+      [this](const FunctionOptionsType* options_type) {\n+        name_to_options_type_[options_type->type_name()] = options_type;\n+      };\n\nReview Comment:\n   Same thing here.  Replace with a boolean.\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -48,23 +61,56 @@ class FunctionRegistry::FunctionRegistryImpl {\n     if (it != name_to_function_.end() && !allow_overwrite) {\n       return Status::KeyError(\"Already have a function registered with name: \", name);\n     }\n-    name_to_function_[name] = std::move(function);\n+    add(name, std::move(function));\n     return Status::OK();\n   }\n \n-  Status AddAlias(const std::string& target_name, const std::string& source_name) {\n+ public:\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n+                                bool allow_overwrite) {\n+    return DoAddFunction(function, allow_overwrite, kFuncAddNoOp);\n+  }\n+\n+  virtual Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n+    return DoAddFunction(function, allow_overwrite, kFuncAddDo);\n+  }\n+\n+ private:\n+  Status DoAddAlias(const std::string& target_name, const std::string& source_name,\n+                    FuncAdd add) {\n     std::lock_guard<std::mutex> mutation_guard(lock_);\n \n-    auto it = name_to_function_.find(source_name);\n-    if (it == name_to_function_.end()) {\n+    auto func_res = GetFunction(source_name);  // must not acquire the mutex\n+    if (!func_res.ok()) {\n       return Status::KeyError(\"No function registered with name: \", source_name);\n     }\n\nReview Comment:\n   ```suggestion\r\n       ARROW_ASSIGN_OR_RAISE(auto func_res, GetFunction(source_name));\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -103,32 +160,140 @@ class FunctionRegistry::FunctionRegistryImpl {\n     return it->second;\n   }\n \n-  int num_functions() const { return static_cast<int>(name_to_function_.size()); }\n+  virtual int num_functions() const { return static_cast<int>(name_to_function_.size()); }\n \n  private:\n   std::mutex lock_;\n   std::unordered_map<std::string, std::shared_ptr<Function>> name_to_function_;\n   std::unordered_map<std::string, const FunctionOptionsType*> name_to_options_type_;\n };\n \n+class FunctionRegistry::NestedFunctionRegistryImpl\n+    : public FunctionRegistry::FunctionRegistryImpl {\n\nReview Comment:\n   It's a little bit odd to have a pimpl pattern combined with inheritance.  If we want this inheritance chain we might be better off converting `FunctionRegistry` to a pure virtual class like we have with `ExtensionIdRegistry`.\r\n   \r\n   On the other hand, would it make sense to simple change the base `FunctionRegistryImpl` to always have a parent pointer that is sometimes `nullptr` (i.e. no parent == `nullptr`)?\r\n   \r\n   Then the lookup can just be...\r\n   \r\n   ```\r\n     Result<std::shared_ptr<Function>> GetFunction(const std::string& name) const override {\r\n       auto it = name_to_function_.find(name);\r\n       if (it == name_to_function_.end()) {\r\n         if (parent_ == nullptr) {\r\n           return Status::KeyError(\"No function registered with name: \", name);\r\n         }\r\n         return parent_->GetFunction(name);\r\n       }\r\n       return it->second;\r\n     }\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry_test.cc:\n##########\n@@ -85,5 +95,137 @@ TEST_F(TestRegistry, Basics) {\n   ASSERT_EQ(func, f2);\n }\n \n+INSTANTIATE_TEST_SUITE_P(\n+    TestRegistry, TestRegistry,\n+    testing::Values(\n+        std::make_tuple(\n+            static_cast<MakeFunctionRegistry>([]() { return FunctionRegistry::Make(); }),\n+            []() { return 0; }, []() { return std::vector<std::string>{}; }, \"default\"),\n+        std::make_tuple(\n+            static_cast<MakeFunctionRegistry>([]() {\n+              return FunctionRegistry::Make(GetFunctionRegistry());\n+            }),\n+            []() { return GetFunctionRegistry()->num_functions(); },\n+            []() { return GetFunctionRegistry()->GetFunctionNames(); }, \"nested\")));\n+\n+TEST(TestRegistry, RegisterTempFunctions) {\n+  auto default_registry = GetFunctionRegistry();\n+  constexpr int rounds = 3;\n+  for (int i = 0; i < rounds; i++) {\n+    auto registry = FunctionRegistry::Make(default_registry);\n+    for (std::string func_name : {\"f1\", \"f2\"}) {\n+      std::shared_ptr<Function> func = std::make_shared<ScalarFunction>(\n+          func_name, Arity::Unary(), /*doc=*/FunctionDoc::Empty());\n+      ASSERT_OK(registry->CanAddFunction(func));\n+      ASSERT_OK(registry->AddFunction(func));\n+      ASSERT_RAISES(KeyError, registry->CanAddFunction(func));\n+      ASSERT_RAISES(KeyError, registry->AddFunction(func));\n+      ASSERT_OK(default_registry->CanAddFunction(func));\n+    }\n+  }\n+}\n+\n+TEST(TestRegistry, RegisterTempAliases) {\n+  auto default_registry = GetFunctionRegistry();\n+  std::vector<std::string> func_names = default_registry->GetFunctionNames();\n+  constexpr int rounds = 3;\n+  for (int i = 0; i < rounds; i++) {\n+    auto registry = FunctionRegistry::Make(default_registry);\n+    for (std::string func_name : func_names) {\n+      std::string alias_name = \"alias_of_\" + func_name;\n+      std::shared_ptr<Function> func = std::make_shared<ScalarFunction>(\n+          func_name, Arity::Unary(), /*doc=*/FunctionDoc::Empty());\n+      ASSERT_RAISES(KeyError, registry->GetFunction(alias_name));\n+      ASSERT_OK(registry->CanAddAlias(alias_name, func_name));\n+      ASSERT_OK(registry->AddAlias(alias_name, func_name));\n+      ASSERT_OK(registry->GetFunction(alias_name));\n+      ASSERT_OK(default_registry->GetFunction(func_name));\n+      ASSERT_RAISES(KeyError, default_registry->GetFunction(alias_name));\n+    }\n+  }\n+}\n+\n+template <int N>\n\nReview Comment:\n   Instead of `N` can we call this `kTypeNameSuffix`?\n\n\n\n",
                    "created": "2022-06-03T01:30:29.295+0000",
                    "updated": "2022-06-03T01:30:29.295+0000",
                    "started": "2022-06-03T01:30:29.295+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "777896",
                    "issueId": "13447175"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175/worklog/777930",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on code in PR #13252:\nURL: https://github.com/apache/arrow/pull/13252#discussion_r888612056\n\n\n##########\ncpp/src/arrow/compute/registry_test.cc:\n##########\n@@ -27,37 +27,44 @@\n #include \"arrow/status.h\"\n #include \"arrow/testing/gtest_util.h\"\n #include \"arrow/util/macros.h\"\n+#include \"arrow/util/make_unique.h\"\n \n namespace arrow {\n namespace compute {\n \n-class TestRegistry : public ::testing::Test {\n- public:\n-  void SetUp() { registry_ = FunctionRegistry::Make(); }\n+using MakeFunctionRegistry = std::function<std::unique_ptr<FunctionRegistry>()>;\n+using GetNumFunctions = std::function<int()>;\n+using GetFunctionNames = std::function<std::vector<std::string>()>;\n+using TestRegistryParams =\n+    std::tuple<MakeFunctionRegistry, GetNumFunctions, GetFunctionNames, std::string>;\n \n- protected:\n-  std::unique_ptr<FunctionRegistry> registry_;\n-};\n+struct TestRegistry : public ::testing::TestWithParam<TestRegistryParams> {};\n \n-TEST_F(TestRegistry, CreateBuiltInRegistry) {\n+TEST(TestRegistry, CreateBuiltInRegistry) {\n\nReview Comment:\n   I observed that gtest generates separate test-name patterns for `TEST` and `TEST_P`, so there is no conflict.\n\n\n\n",
                    "created": "2022-06-03T05:04:52.556+0000",
                    "updated": "2022-06-03T05:04:52.556+0000",
                    "started": "2022-06-03T05:04:52.556+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "777930",
                    "issueId": "13447175"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175/worklog/777948",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on code in PR #13252:\nURL: https://github.com/apache/arrow/pull/13252#discussion_r888658433\n\n\n##########\ncpp/src/arrow/compute/registry_test.cc:\n##########\n@@ -85,5 +95,137 @@ TEST_F(TestRegistry, Basics) {\n   ASSERT_EQ(func, f2);\n }\n \n+INSTANTIATE_TEST_SUITE_P(\n+    TestRegistry, TestRegistry,\n+    testing::Values(\n+        std::make_tuple(\n+            static_cast<MakeFunctionRegistry>([]() { return FunctionRegistry::Make(); }),\n+            []() { return 0; }, []() { return std::vector<std::string>{}; }, \"default\"),\n+        std::make_tuple(\n+            static_cast<MakeFunctionRegistry>([]() {\n+              return FunctionRegistry::Make(GetFunctionRegistry());\n+            }),\n+            []() { return GetFunctionRegistry()->num_functions(); },\n+            []() { return GetFunctionRegistry()->GetFunctionNames(); }, \"nested\")));\n+\n+TEST(TestRegistry, RegisterTempFunctions) {\n+  auto default_registry = GetFunctionRegistry();\n+  constexpr int rounds = 3;\n+  for (int i = 0; i < rounds; i++) {\n+    auto registry = FunctionRegistry::Make(default_registry);\n+    for (std::string func_name : {\"f1\", \"f2\"}) {\n+      std::shared_ptr<Function> func = std::make_shared<ScalarFunction>(\n+          func_name, Arity::Unary(), /*doc=*/FunctionDoc::Empty());\n+      ASSERT_OK(registry->CanAddFunction(func));\n+      ASSERT_OK(registry->AddFunction(func));\n+      ASSERT_RAISES(KeyError, registry->CanAddFunction(func));\n+      ASSERT_RAISES(KeyError, registry->AddFunction(func));\n+      ASSERT_OK(default_registry->CanAddFunction(func));\n+    }\n+  }\n+}\n+\n+TEST(TestRegistry, RegisterTempAliases) {\n+  auto default_registry = GetFunctionRegistry();\n+  std::vector<std::string> func_names = default_registry->GetFunctionNames();\n+  constexpr int rounds = 3;\n+  for (int i = 0; i < rounds; i++) {\n+    auto registry = FunctionRegistry::Make(default_registry);\n+    for (std::string func_name : func_names) {\n+      std::string alias_name = \"alias_of_\" + func_name;\n+      std::shared_ptr<Function> func = std::make_shared<ScalarFunction>(\n+          func_name, Arity::Unary(), /*doc=*/FunctionDoc::Empty());\n+      ASSERT_RAISES(KeyError, registry->GetFunction(alias_name));\n+      ASSERT_OK(registry->CanAddAlias(alias_name, func_name));\n+      ASSERT_OK(registry->AddAlias(alias_name, func_name));\n+      ASSERT_OK(registry->GetFunction(alias_name));\n+      ASSERT_OK(default_registry->GetFunction(func_name));\n+      ASSERT_RAISES(KeyError, default_registry->GetFunction(alias_name));\n+    }\n+  }\n+}\n+\n+template <int N>\n\nReview Comment:\n   I'll use `kExampleSeqNum`.\n\n\n\n",
                    "created": "2022-06-03T06:42:57.430+0000",
                    "updated": "2022-06-03T06:42:57.430+0000",
                    "started": "2022-06-03T06:42:57.430+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "777948",
                    "issueId": "13447175"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175/worklog/777949",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on code in PR #13252:\nURL: https://github.com/apache/arrow/pull/13252#discussion_r888669276\n\n\n##########\ncpp/src/arrow/compute/registry.h:\n##########\n@@ -84,6 +106,11 @@ class ARROW_EXPORT FunctionRegistry {\n   // Use PIMPL pattern to not have std::unordered_map here\n   class FunctionRegistryImpl;\n   std::unique_ptr<FunctionRegistryImpl> impl_;\n+\n+  explicit FunctionRegistry(FunctionRegistryImpl* impl);\n+\n+  class NestedFunctionRegistryImpl;\n+  friend class NestedFunctionRegistryImpl;\n\nReview Comment:\n   Right, it was a leftover.\n\n\n\n",
                    "created": "2022-06-03T07:00:54.245+0000",
                    "updated": "2022-06-03T07:00:54.245+0000",
                    "started": "2022-06-03T07:00:54.244+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "777949",
                    "issueId": "13447175"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175/worklog/778102",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #13252:\nURL: https://github.com/apache/arrow/pull/13252#issuecomment-1146006722\n\n   Looks like the failed jobs are not due to the changes here.\n\n\n",
                    "created": "2022-06-03T14:13:10.044+0000",
                    "updated": "2022-06-03T14:13:10.044+0000",
                    "started": "2022-06-03T14:13:10.044+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "778102",
                    "issueId": "13447175"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175/worklog/779006",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #13252:\nURL: https://github.com/apache/arrow/pull/13252#issuecomment-1148553454\n\n   @westonpace, is this good to go? \n\n\n",
                    "created": "2022-06-07T11:42:23.161+0000",
                    "updated": "2022-06-07T11:42:23.161+0000",
                    "started": "2022-06-07T11:42:23.160+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "779006",
                    "issueId": "13447175"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175/worklog/779201",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13252:\nURL: https://github.com/apache/arrow/pull/13252#discussion_r891490267\n\n\n##########\ncpp/src/arrow/compute/registry.h:\n##########\n@@ -45,20 +45,42 @@ class FunctionOptionsType;\n /// lower-level function execution.\n class ARROW_EXPORT FunctionRegistry {\n  public:\n-  ~FunctionRegistry();\n+  virtual ~FunctionRegistry();\n\nReview Comment:\n   A destructor should not be the only virtual method.  If no methods are virtual then the destructor does not need to be virtual.\n\n\n\n##########\ncpp/src/arrow/compute/registry.h:\n##########\n@@ -45,20 +45,42 @@ class FunctionOptionsType;\n /// lower-level function execution.\n class ARROW_EXPORT FunctionRegistry {\n  public:\n-  ~FunctionRegistry();\n+  virtual ~FunctionRegistry();\n \n   /// \\brief Construct a new registry. Most users only need to use the global\n   /// registry\n   static std::unique_ptr<FunctionRegistry> Make();\n \n+  /// \\brief Construct a new nested registry with the given parent. Most users only need\n+  /// to use the global registry\n+  static std::unique_ptr<FunctionRegistry> Make(FunctionRegistry* parent);\n+\n+  /// \\brief Construct a new nested registry with the given parent. Most users only need\n+  /// to use the global registry\n+  static std::unique_ptr<FunctionRegistry> Make(std::unique_ptr<FunctionRegistry> parent);\n\nReview Comment:\n   A function that accepts a unique_ptr should take ownership of that unique pointer.  That does not seem to be what we are doing here.  In this case I think we should probably get rid of this overload.\r\n   \r\n   There is a \"maybe owned\" pattern we use in a few places where we have a constructor that takes a raw pointer and one that takes a shared_ptr but in that case we have two member variables (e.g. https://github.com/apache/arrow/blob/master/cpp/src/arrow/io/caching.cc#L147)\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,78 +34,144 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n-#ifndef NDEBUG\n-    // This validates docstrings extensively, so don't waste time on it\n-    // in release builds.\n-    RETURN_NOT_OK(function->Validate());\n-#endif\n-\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  explicit FunctionRegistryImpl(FunctionRegistryImpl* parent = NULLPTR)\n+      : parent_(parent) {}\n+  virtual ~FunctionRegistryImpl() {}\n+\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n+                                bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/false);\n\nReview Comment:\n   ```suggestion\r\n       if (parent_ != nullptr) {\r\n           RETURN_NOT_OK(parent_->CanAddFunction(function, allow_overwrite)));\r\n       }\r\n       return DoAddFunction(function, allow_overwrite, /*add=*/false);\r\n   ```\r\n   \r\n   Now that it seems we won't be able to use `&&` we should probably move away from this more compact pattern and more explicitly short-circuit.\n\n\n\n##########\ncpp/src/arrow/compute/registry.h:\n##########\n@@ -45,20 +45,42 @@ class FunctionOptionsType;\n /// lower-level function execution.\n class ARROW_EXPORT FunctionRegistry {\n  public:\n-  ~FunctionRegistry();\n+  virtual ~FunctionRegistry();\n \n   /// \\brief Construct a new registry. Most users only need to use the global\n   /// registry\n   static std::unique_ptr<FunctionRegistry> Make();\n \n+  /// \\brief Construct a new nested registry with the given parent. Most users only need\n+  /// to use the global registry\n+  static std::unique_ptr<FunctionRegistry> Make(FunctionRegistry* parent);\n+\n+  /// \\brief Construct a new nested registry with the given parent. Most users only need\n+  /// to use the global registry\n+  static std::unique_ptr<FunctionRegistry> Make(std::unique_ptr<FunctionRegistry> parent);\n+\n+  /// \\brief Checks whether a new function can be added to the registry. Returns\n+  /// Status::KeyError if a function with the same name is already registered\n+  Status CanAddFunction(std::shared_ptr<Function> function, bool allow_overwrite = false);\n+\n   /// \\brief Add a new function to the registry. Returns Status::KeyError if a\n   /// function with the same name is already registered\n   Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite = false);\n \n-  /// \\brief Add aliases for the given function name. Returns Status::KeyError if the\n+  /// \\brief Checks whether an alias can be added for the given function name. Returns\n+  /// Status::KeyError if the function with the given name is not registered\n+  Status CanAddAlias(const std::string& target_name, const std::string& source_name);\n+\n+  /// \\brief Add alias for the given function name. Returns Status::KeyError if the\n   /// function with the given name is not registered\n   Status AddAlias(const std::string& target_name, const std::string& source_name);\n \n+  /// \\brief Checks whether a new function options type can be added to the registry.\n+  /// Returns Status::KeyError if a function options type with the same name is already\n+  /// registered\n\nReview Comment:\n   ```suggestion\r\n     /// \\brief Check whether a new function options type can be added to the registry.\r\n     /// \\return Status::KeyError if a function options type with the same name is already\r\n     ///     registered\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,78 +34,144 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n-#ifndef NDEBUG\n-    // This validates docstrings extensively, so don't waste time on it\n-    // in release builds.\n-    RETURN_NOT_OK(function->Validate());\n-#endif\n-\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  explicit FunctionRegistryImpl(FunctionRegistryImpl* parent = NULLPTR)\n+      : parent_(parent) {}\n+  virtual ~FunctionRegistryImpl() {}\n+\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n+                                bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string& name = function->name();\n-    auto it = name_to_function_.find(name);\n-    if (it != name_to_function_.end() && !allow_overwrite) {\n-      return Status::KeyError(\"Already have a function registered with name: \", name);\n-    }\n-    name_to_function_[name] = std::move(function);\n-    return Status::OK();\n+  virtual Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/true);\n   }\n \n-  Status AddAlias(const std::string& target_name, const std::string& source_name) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddAlias(const std::string& target_name,\n+                             const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/false);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->CanAddAlias(target_name, source_name);\n+  }\n \n-    auto it = name_to_function_.find(source_name);\n-    if (it == name_to_function_.end()) {\n-      return Status::KeyError(\"No function registered with name: \", source_name);\n-    }\n-    name_to_function_[target_name] = it->second;\n-    return Status::OK();\n+  virtual Status AddAlias(const std::string& target_name,\n\nReview Comment:\n   ```suggestion\r\n     Status AddAlias(const std::string& target_name,\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,78 +34,144 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n-#ifndef NDEBUG\n-    // This validates docstrings extensively, so don't waste time on it\n-    // in release builds.\n-    RETURN_NOT_OK(function->Validate());\n-#endif\n-\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  explicit FunctionRegistryImpl(FunctionRegistryImpl* parent = NULLPTR)\n+      : parent_(parent) {}\n+  virtual ~FunctionRegistryImpl() {}\n+\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n+                                bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string& name = function->name();\n-    auto it = name_to_function_.find(name);\n-    if (it != name_to_function_.end() && !allow_overwrite) {\n-      return Status::KeyError(\"Already have a function registered with name: \", name);\n-    }\n-    name_to_function_[name] = std::move(function);\n-    return Status::OK();\n+  virtual Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/true);\n   }\n \n-  Status AddAlias(const std::string& target_name, const std::string& source_name) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddAlias(const std::string& target_name,\n+                             const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/false);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->CanAddAlias(target_name, source_name);\n+  }\n \n-    auto it = name_to_function_.find(source_name);\n-    if (it == name_to_function_.end()) {\n-      return Status::KeyError(\"No function registered with name: \", source_name);\n-    }\n-    name_to_function_[target_name] = it->second;\n-    return Status::OK();\n+  virtual Status AddAlias(const std::string& target_name,\n+                          const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/true);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->AddAlias(target_name, source_name);\n   }\n \n-  Status AddFunctionOptionsType(const FunctionOptionsType* options_type,\n-                                bool allow_overwrite = false) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddFunctionOptionsType(const FunctionOptionsType* options_type,\n\nReview Comment:\n   ```suggestion\r\n     Status CanAddFunctionOptionsType(const FunctionOptionsType* options_type,\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,78 +34,144 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n-#ifndef NDEBUG\n-    // This validates docstrings extensively, so don't waste time on it\n-    // in release builds.\n-    RETURN_NOT_OK(function->Validate());\n-#endif\n-\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  explicit FunctionRegistryImpl(FunctionRegistryImpl* parent = NULLPTR)\n+      : parent_(parent) {}\n+  virtual ~FunctionRegistryImpl() {}\n+\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n+                                bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string& name = function->name();\n-    auto it = name_to_function_.find(name);\n-    if (it != name_to_function_.end() && !allow_overwrite) {\n-      return Status::KeyError(\"Already have a function registered with name: \", name);\n-    }\n-    name_to_function_[name] = std::move(function);\n-    return Status::OK();\n+  virtual Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/true);\n   }\n \n-  Status AddAlias(const std::string& target_name, const std::string& source_name) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddAlias(const std::string& target_name,\n+                             const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/false);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->CanAddAlias(target_name, source_name);\n+  }\n \n-    auto it = name_to_function_.find(source_name);\n-    if (it == name_to_function_.end()) {\n-      return Status::KeyError(\"No function registered with name: \", source_name);\n-    }\n-    name_to_function_[target_name] = it->second;\n-    return Status::OK();\n+  virtual Status AddAlias(const std::string& target_name,\n+                          const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/true);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->AddAlias(target_name, source_name);\n   }\n \n-  Status AddFunctionOptionsType(const FunctionOptionsType* options_type,\n-                                bool allow_overwrite = false) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddFunctionOptionsType(const FunctionOptionsType* options_type,\n+                                           bool allow_overwrite = false) {\n+    return (parent_ == nullptr\n+                ? Status::OK()\n+                : parent_->CanAddFunctionOptionsType(options_type, allow_overwrite)) &\n+           DoAddFunctionOptionsType(options_type, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string name = options_type->type_name();\n-    auto it = name_to_options_type_.find(name);\n-    if (it != name_to_options_type_.end() && !allow_overwrite) {\n-      return Status::KeyError(\n-          \"Already have a function options type registered with name: \", name);\n-    }\n-    name_to_options_type_[name] = options_type;\n-    return Status::OK();\n+  virtual Status AddFunctionOptionsType(const FunctionOptionsType* options_type,\n+                                        bool allow_overwrite = false) {\n+    return (parent_ == nullptr\n+                ? Status::OK()\n+                : parent_->CanAddFunctionOptionsType(options_type, allow_overwrite)) &\n+           DoAddFunctionOptionsType(options_type, allow_overwrite, /*add=*/true);\n\nReview Comment:\n   ```suggestion\r\n       if (parent_ != nullptr) {\r\n           RETURN_NOT_OK(parent_->CanAddFunctionOptionsType(options_type, allow_overwrite));\r\n       }\r\n       return DoAddFunctionOptionsType(options_type, allow_overwrite, /*add=*/true);\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -115,20 +181,47 @@ std::unique_ptr<FunctionRegistry> FunctionRegistry::Make() {\n   return std::unique_ptr<FunctionRegistry>(new FunctionRegistry());\n }\n \n-FunctionRegistry::FunctionRegistry() { impl_.reset(new FunctionRegistryImpl()); }\n+std::unique_ptr<FunctionRegistry> FunctionRegistry::Make(FunctionRegistry* parent) {\n+  return std::unique_ptr<FunctionRegistry>(\n+      new FunctionRegistry(new FunctionRegistry::FunctionRegistryImpl(&*parent->impl_)));\n\nReview Comment:\n   ```suggestion\r\n         new FunctionRegistry(parent->impl_.get());\r\n   ```\r\n   The way it is currently will create a copy of the parent.  This pointer leaks but, more importantly, if you did something like...\r\n   \r\n   ```\r\n   auto parent = GetFunctionRegistry();\r\n   auto nested = FunctionRegistry::Make(parent);\r\n   // The function added here (using parent) will not be visible by nested\r\n   // and, if I'm understanding the purpose correctly, we would want that\r\n   parent->AddFunction(...);\r\n   ```\r\n   \r\n   Instead we should just take a non-owning \"view\" pointer to the parent.  If the parent is deleted before the nested registry is deleted then bad things will happen but that is to be expected.\n\n\n\n##########\ncpp/src/arrow/compute/registry.h:\n##########\n@@ -45,20 +45,42 @@ class FunctionOptionsType;\n /// lower-level function execution.\n class ARROW_EXPORT FunctionRegistry {\n  public:\n-  ~FunctionRegistry();\n+  virtual ~FunctionRegistry();\n \n   /// \\brief Construct a new registry. Most users only need to use the global\n   /// registry\n   static std::unique_ptr<FunctionRegistry> Make();\n \n+  /// \\brief Construct a new nested registry with the given parent. Most users only need\n+  /// to use the global registry\n\nReview Comment:\n   ```suggestion\r\n     /// \\brief Construct a new nested registry with the given parent.\r\n     ///\r\n     /// Most users only need to use the global registry\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry.h:\n##########\n@@ -45,20 +45,42 @@ class FunctionOptionsType;\n /// lower-level function execution.\n class ARROW_EXPORT FunctionRegistry {\n  public:\n-  ~FunctionRegistry();\n+  virtual ~FunctionRegistry();\n \n   /// \\brief Construct a new registry. Most users only need to use the global\n   /// registry\n   static std::unique_ptr<FunctionRegistry> Make();\n \n+  /// \\brief Construct a new nested registry with the given parent. Most users only need\n+  /// to use the global registry\n+  static std::unique_ptr<FunctionRegistry> Make(FunctionRegistry* parent);\n+\n+  /// \\brief Construct a new nested registry with the given parent. Most users only need\n+  /// to use the global registry\n+  static std::unique_ptr<FunctionRegistry> Make(std::unique_ptr<FunctionRegistry> parent);\n+\n+  /// \\brief Checks whether a new function can be added to the registry. Returns\n+  /// Status::KeyError if a function with the same name is already registered\n+  Status CanAddFunction(std::shared_ptr<Function> function, bool allow_overwrite = false);\n+\n   /// \\brief Add a new function to the registry. Returns Status::KeyError if a\n   /// function with the same name is already registered\n   Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite = false);\n \n-  /// \\brief Add aliases for the given function name. Returns Status::KeyError if the\n+  /// \\brief Checks whether an alias can be added for the given function name. Returns\n+  /// Status::KeyError if the function with the given name is not registered\n\nReview Comment:\n   ```suggestion\r\n     /// \\brief Check whether an alias can be added for the given function name.\r\n     /// \\return Status::KeyError if a function with the\r\n     ///    given source_name is not registered\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,78 +34,144 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n-#ifndef NDEBUG\n-    // This validates docstrings extensively, so don't waste time on it\n-    // in release builds.\n-    RETURN_NOT_OK(function->Validate());\n-#endif\n-\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  explicit FunctionRegistryImpl(FunctionRegistryImpl* parent = NULLPTR)\n+      : parent_(parent) {}\n+  virtual ~FunctionRegistryImpl() {}\n+\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n+                                bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string& name = function->name();\n-    auto it = name_to_function_.find(name);\n-    if (it != name_to_function_.end() && !allow_overwrite) {\n-      return Status::KeyError(\"Already have a function registered with name: \", name);\n-    }\n-    name_to_function_[name] = std::move(function);\n-    return Status::OK();\n+  virtual Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/true);\n   }\n \n-  Status AddAlias(const std::string& target_name, const std::string& source_name) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddAlias(const std::string& target_name,\n+                             const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/false);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->CanAddAlias(target_name, source_name);\n+  }\n \n-    auto it = name_to_function_.find(source_name);\n-    if (it == name_to_function_.end()) {\n-      return Status::KeyError(\"No function registered with name: \", source_name);\n-    }\n-    name_to_function_[target_name] = it->second;\n-    return Status::OK();\n+  virtual Status AddAlias(const std::string& target_name,\n+                          const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/true);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->AddAlias(target_name, source_name);\n   }\n \n-  Status AddFunctionOptionsType(const FunctionOptionsType* options_type,\n-                                bool allow_overwrite = false) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddFunctionOptionsType(const FunctionOptionsType* options_type,\n+                                           bool allow_overwrite = false) {\n+    return (parent_ == nullptr\n+                ? Status::OK()\n+                : parent_->CanAddFunctionOptionsType(options_type, allow_overwrite)) &\n+           DoAddFunctionOptionsType(options_type, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string name = options_type->type_name();\n-    auto it = name_to_options_type_.find(name);\n-    if (it != name_to_options_type_.end() && !allow_overwrite) {\n-      return Status::KeyError(\n-          \"Already have a function options type registered with name: \", name);\n-    }\n-    name_to_options_type_[name] = options_type;\n-    return Status::OK();\n+  virtual Status AddFunctionOptionsType(const FunctionOptionsType* options_type,\n+                                        bool allow_overwrite = false) {\n+    return (parent_ == nullptr\n+                ? Status::OK()\n+                : parent_->CanAddFunctionOptionsType(options_type, allow_overwrite)) &\n+           DoAddFunctionOptionsType(options_type, allow_overwrite, /*add=*/true);\n   }\n \n-  Result<std::shared_ptr<Function>> GetFunction(const std::string& name) const {\n+  virtual Result<std::shared_ptr<Function>> GetFunction(const std::string& name) const {\n     auto it = name_to_function_.find(name);\n     if (it == name_to_function_.end()) {\n+      if (parent_ != nullptr) {\n+        return parent_->GetFunction(name);\n+      }\n       return Status::KeyError(\"No function registered with name: \", name);\n     }\n     return it->second;\n   }\n \n-  std::vector<std::string> GetFunctionNames() const {\n+  virtual std::vector<std::string> GetFunctionNames() const {\n     std::vector<std::string> results;\n+    if (parent_ != nullptr) {\n+      results = parent_->GetFunctionNames();\n+    }\n     for (auto it : name_to_function_) {\n       results.push_back(it.first);\n     }\n     std::sort(results.begin(), results.end());\n     return results;\n   }\n \n-  Result<const FunctionOptionsType*> GetFunctionOptionsType(\n+  virtual Result<const FunctionOptionsType*> GetFunctionOptionsType(\n       const std::string& name) const {\n     auto it = name_to_options_type_.find(name);\n     if (it == name_to_options_type_.end()) {\n+      if (parent_ != nullptr) {\n+        return parent_->GetFunctionOptionsType(name);\n+      }\n       return Status::KeyError(\"No function options type registered with name: \", name);\n     }\n     return it->second;\n   }\n \n-  int num_functions() const { return static_cast<int>(name_to_function_.size()); }\n+  virtual int num_functions() const {\n+    return (parent_ == nullptr ? 0 : parent_->num_functions()) +\n+           static_cast<int>(name_to_function_.size());\n+  }\n \n  private:\n+  Status DoAddFunction(std::shared_ptr<Function> function, bool allow_overwrite,\n+                       bool add) {\n+#ifndef NDEBUG\n+    // This validates docstrings extensively, so don't waste time on it\n+    // in release builds.\n+    RETURN_NOT_OK(function->Validate());\n+#endif\n+\n+    std::lock_guard<std::mutex> mutation_guard(lock_);\n+\n+    const std::string& name = function->name();\n+    auto it = name_to_function_.find(name);\n+    if (it != name_to_function_.end() && !allow_overwrite) {\n+      return Status::KeyError(\"Already have a function registered with name: \", name);\n+    }\n+    if (add) {\n+      name_to_function_[name] = std::move(function);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status DoAddAlias(const std::string& target_name, const std::string& source_name,\n+                    bool add) {\n+    std::lock_guard<std::mutex> mutation_guard(lock_);\n+\n+    // following invocation must not acquire the mutex\n+    ARROW_ASSIGN_OR_RAISE(auto func, GetFunction(source_name));\n+    if (add) {\n\nReview Comment:\n   Should we be doing a check here to see if a function with `target_name` is already registered (would probably also necessitate `allow_overwrite`)?\n\n\n\n##########\ncpp/src/arrow/compute/registry.h:\n##########\n@@ -45,20 +45,42 @@ class FunctionOptionsType;\n /// lower-level function execution.\n class ARROW_EXPORT FunctionRegistry {\n  public:\n-  ~FunctionRegistry();\n+  virtual ~FunctionRegistry();\n \n   /// \\brief Construct a new registry. Most users only need to use the global\n   /// registry\n   static std::unique_ptr<FunctionRegistry> Make();\n \n+  /// \\brief Construct a new nested registry with the given parent. Most users only need\n+  /// to use the global registry\n+  static std::unique_ptr<FunctionRegistry> Make(FunctionRegistry* parent);\n+\n+  /// \\brief Construct a new nested registry with the given parent. Most users only need\n+  /// to use the global registry\n+  static std::unique_ptr<FunctionRegistry> Make(std::unique_ptr<FunctionRegistry> parent);\n+\n+  /// \\brief Checks whether a new function can be added to the registry. Returns\n+  /// Status::KeyError if a function with the same name is already registered\n\nReview Comment:\n   ```suggestion\r\n     /// \\brief Check whether a new function can be added to the registry.\r\n     /// \\return Status::KeyError if a function with the same name is already registered\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry.h:\n##########\n@@ -45,20 +45,42 @@ class FunctionOptionsType;\n /// lower-level function execution.\n class ARROW_EXPORT FunctionRegistry {\n  public:\n-  ~FunctionRegistry();\n+  virtual ~FunctionRegistry();\n \n   /// \\brief Construct a new registry. Most users only need to use the global\n   /// registry\n   static std::unique_ptr<FunctionRegistry> Make();\n \n+  /// \\brief Construct a new nested registry with the given parent. Most users only need\n+  /// to use the global registry\n+  static std::unique_ptr<FunctionRegistry> Make(FunctionRegistry* parent);\n+\n+  /// \\brief Construct a new nested registry with the given parent. Most users only need\n+  /// to use the global registry\n+  static std::unique_ptr<FunctionRegistry> Make(std::unique_ptr<FunctionRegistry> parent);\n+\n+  /// \\brief Checks whether a new function can be added to the registry. Returns\n+  /// Status::KeyError if a function with the same name is already registered\n+  Status CanAddFunction(std::shared_ptr<Function> function, bool allow_overwrite = false);\n+\n   /// \\brief Add a new function to the registry. Returns Status::KeyError if a\n   /// function with the same name is already registered\n   Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite = false);\n \n-  /// \\brief Add aliases for the given function name. Returns Status::KeyError if the\n+  /// \\brief Checks whether an alias can be added for the given function name. Returns\n+  /// Status::KeyError if the function with the given name is not registered\n+  Status CanAddAlias(const std::string& target_name, const std::string& source_name);\n+\n+  /// \\brief Add alias for the given function name. Returns Status::KeyError if the\n   /// function with the given name is not registered\n\nReview Comment:\n   ```suggestion\r\n     /// \\brief Add alias for the given function name.\r\n     /// \\return Status::KeyError if the\r\n     ///     function with the given source_name is not registered\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,78 +34,144 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n-#ifndef NDEBUG\n-    // This validates docstrings extensively, so don't waste time on it\n-    // in release builds.\n-    RETURN_NOT_OK(function->Validate());\n-#endif\n-\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  explicit FunctionRegistryImpl(FunctionRegistryImpl* parent = NULLPTR)\n+      : parent_(parent) {}\n+  virtual ~FunctionRegistryImpl() {}\n+\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n+                                bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string& name = function->name();\n-    auto it = name_to_function_.find(name);\n-    if (it != name_to_function_.end() && !allow_overwrite) {\n-      return Status::KeyError(\"Already have a function registered with name: \", name);\n-    }\n-    name_to_function_[name] = std::move(function);\n-    return Status::OK();\n+  virtual Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/true);\n\nReview Comment:\n   ```suggestion\r\n       if (parent_ != nullptr) {\r\n           RETURN_NOT_OK(parent_->CanAddFunction(function, allow_overwrite));\r\n       }\r\n       return DoAddFunction(function, allow_overwrite, /*add=*/true);\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,78 +34,144 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n-#ifndef NDEBUG\n-    // This validates docstrings extensively, so don't waste time on it\n-    // in release builds.\n-    RETURN_NOT_OK(function->Validate());\n-#endif\n-\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  explicit FunctionRegistryImpl(FunctionRegistryImpl* parent = NULLPTR)\n+      : parent_(parent) {}\n+  virtual ~FunctionRegistryImpl() {}\n+\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n\nReview Comment:\n   ```suggestion\r\n     Status CanAddFunction(std::shared_ptr<Function> function,\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,78 +34,144 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n-#ifndef NDEBUG\n-    // This validates docstrings extensively, so don't waste time on it\n-    // in release builds.\n-    RETURN_NOT_OK(function->Validate());\n-#endif\n-\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  explicit FunctionRegistryImpl(FunctionRegistryImpl* parent = NULLPTR)\n+      : parent_(parent) {}\n+  virtual ~FunctionRegistryImpl() {}\n+\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n+                                bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string& name = function->name();\n-    auto it = name_to_function_.find(name);\n-    if (it != name_to_function_.end() && !allow_overwrite) {\n-      return Status::KeyError(\"Already have a function registered with name: \", name);\n-    }\n-    name_to_function_[name] = std::move(function);\n-    return Status::OK();\n+  virtual Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/true);\n   }\n \n-  Status AddAlias(const std::string& target_name, const std::string& source_name) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddAlias(const std::string& target_name,\n+                             const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/false);\n\nReview Comment:\n   ```suggestion\r\n       RETURN_NOT_OK(DoAddAlias(target_name, source_name, /*add=*/false));\r\n       if (parent_ != nullptr) {\r\n           return parent_->CanAddAlias(target_name, source_name);\r\n       }\r\n       return Status::OK();\r\n   ```\r\n   Hmm...I think we want to:\r\n   \r\n    * Check if source_name exists in this and fail otherwise\r\n    * Check if target_name exists in parent_ and fail otherwise\r\n    * Actually try and add to this (may fail if target_name exists)\r\n    \r\n    I might be confused though.\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,78 +34,144 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n-#ifndef NDEBUG\n-    // This validates docstrings extensively, so don't waste time on it\n-    // in release builds.\n-    RETURN_NOT_OK(function->Validate());\n-#endif\n-\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  explicit FunctionRegistryImpl(FunctionRegistryImpl* parent = NULLPTR)\n+      : parent_(parent) {}\n+  virtual ~FunctionRegistryImpl() {}\n+\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n+                                bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string& name = function->name();\n-    auto it = name_to_function_.find(name);\n-    if (it != name_to_function_.end() && !allow_overwrite) {\n-      return Status::KeyError(\"Already have a function registered with name: \", name);\n-    }\n-    name_to_function_[name] = std::move(function);\n-    return Status::OK();\n+  virtual Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n\nReview Comment:\n   ```suggestion\r\n     Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,78 +34,144 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n-#ifndef NDEBUG\n-    // This validates docstrings extensively, so don't waste time on it\n-    // in release builds.\n-    RETURN_NOT_OK(function->Validate());\n-#endif\n-\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  explicit FunctionRegistryImpl(FunctionRegistryImpl* parent = NULLPTR)\n+      : parent_(parent) {}\n+  virtual ~FunctionRegistryImpl() {}\n+\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n+                                bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string& name = function->name();\n-    auto it = name_to_function_.find(name);\n-    if (it != name_to_function_.end() && !allow_overwrite) {\n-      return Status::KeyError(\"Already have a function registered with name: \", name);\n-    }\n-    name_to_function_[name] = std::move(function);\n-    return Status::OK();\n+  virtual Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/true);\n   }\n \n-  Status AddAlias(const std::string& target_name, const std::string& source_name) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddAlias(const std::string& target_name,\n\nReview Comment:\n   ```suggestion\r\n     Status CanAddAlias(const std::string& target_name,\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,78 +34,144 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n-#ifndef NDEBUG\n-    // This validates docstrings extensively, so don't waste time on it\n-    // in release builds.\n-    RETURN_NOT_OK(function->Validate());\n-#endif\n-\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  explicit FunctionRegistryImpl(FunctionRegistryImpl* parent = NULLPTR)\n+      : parent_(parent) {}\n+  virtual ~FunctionRegistryImpl() {}\n\nReview Comment:\n   ```suggestion\r\n     ~FunctionRegistryImpl() {}\r\n   ```\r\n   Now that we aren't using inheritance these do not need to be virtual.\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,78 +34,144 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n-#ifndef NDEBUG\n-    // This validates docstrings extensively, so don't waste time on it\n-    // in release builds.\n-    RETURN_NOT_OK(function->Validate());\n-#endif\n-\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  explicit FunctionRegistryImpl(FunctionRegistryImpl* parent = NULLPTR)\n+      : parent_(parent) {}\n+  virtual ~FunctionRegistryImpl() {}\n+\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n+                                bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string& name = function->name();\n-    auto it = name_to_function_.find(name);\n-    if (it != name_to_function_.end() && !allow_overwrite) {\n-      return Status::KeyError(\"Already have a function registered with name: \", name);\n-    }\n-    name_to_function_[name] = std::move(function);\n-    return Status::OK();\n+  virtual Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/true);\n   }\n \n-  Status AddAlias(const std::string& target_name, const std::string& source_name) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddAlias(const std::string& target_name,\n+                             const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/false);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->CanAddAlias(target_name, source_name);\n+  }\n \n-    auto it = name_to_function_.find(source_name);\n-    if (it == name_to_function_.end()) {\n-      return Status::KeyError(\"No function registered with name: \", source_name);\n-    }\n-    name_to_function_[target_name] = it->second;\n-    return Status::OK();\n+  virtual Status AddAlias(const std::string& target_name,\n+                          const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/true);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->AddAlias(target_name, source_name);\n\nReview Comment:\n   I'm a little confused here. Why are we adding the alias to `parent_` as well?\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,78 +34,144 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n-#ifndef NDEBUG\n-    // This validates docstrings extensively, so don't waste time on it\n-    // in release builds.\n-    RETURN_NOT_OK(function->Validate());\n-#endif\n-\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  explicit FunctionRegistryImpl(FunctionRegistryImpl* parent = NULLPTR)\n+      : parent_(parent) {}\n+  virtual ~FunctionRegistryImpl() {}\n+\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n+                                bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string& name = function->name();\n-    auto it = name_to_function_.find(name);\n-    if (it != name_to_function_.end() && !allow_overwrite) {\n-      return Status::KeyError(\"Already have a function registered with name: \", name);\n-    }\n-    name_to_function_[name] = std::move(function);\n-    return Status::OK();\n+  virtual Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/true);\n   }\n \n-  Status AddAlias(const std::string& target_name, const std::string& source_name) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddAlias(const std::string& target_name,\n+                             const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/false);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->CanAddAlias(target_name, source_name);\n+  }\n \n-    auto it = name_to_function_.find(source_name);\n-    if (it == name_to_function_.end()) {\n-      return Status::KeyError(\"No function registered with name: \", source_name);\n-    }\n-    name_to_function_[target_name] = it->second;\n-    return Status::OK();\n+  virtual Status AddAlias(const std::string& target_name,\n+                          const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/true);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->AddAlias(target_name, source_name);\n   }\n \n-  Status AddFunctionOptionsType(const FunctionOptionsType* options_type,\n-                                bool allow_overwrite = false) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddFunctionOptionsType(const FunctionOptionsType* options_type,\n+                                           bool allow_overwrite = false) {\n+    return (parent_ == nullptr\n+                ? Status::OK()\n+                : parent_->CanAddFunctionOptionsType(options_type, allow_overwrite)) &\n+           DoAddFunctionOptionsType(options_type, allow_overwrite, /*add=*/false);\n\nReview Comment:\n   ```suggestion\r\n       if (parent_ != nullptr) {\r\n           RETURN_NOT_OK(parent_->CanAddFunctionOptionsType(options_type, allow_overwrite));\r\n       }\r\n       return DoAddFunctionsType(options_type, allow_overwrite, /*add=*/false);\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,78 +34,144 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n-#ifndef NDEBUG\n-    // This validates docstrings extensively, so don't waste time on it\n-    // in release builds.\n-    RETURN_NOT_OK(function->Validate());\n-#endif\n-\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  explicit FunctionRegistryImpl(FunctionRegistryImpl* parent = NULLPTR)\n+      : parent_(parent) {}\n+  virtual ~FunctionRegistryImpl() {}\n+\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n+                                bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string& name = function->name();\n-    auto it = name_to_function_.find(name);\n-    if (it != name_to_function_.end() && !allow_overwrite) {\n-      return Status::KeyError(\"Already have a function registered with name: \", name);\n-    }\n-    name_to_function_[name] = std::move(function);\n-    return Status::OK();\n+  virtual Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/true);\n   }\n \n-  Status AddAlias(const std::string& target_name, const std::string& source_name) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddAlias(const std::string& target_name,\n+                             const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/false);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->CanAddAlias(target_name, source_name);\n+  }\n \n-    auto it = name_to_function_.find(source_name);\n-    if (it == name_to_function_.end()) {\n-      return Status::KeyError(\"No function registered with name: \", source_name);\n-    }\n-    name_to_function_[target_name] = it->second;\n-    return Status::OK();\n+  virtual Status AddAlias(const std::string& target_name,\n+                          const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/true);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->AddAlias(target_name, source_name);\n   }\n \n-  Status AddFunctionOptionsType(const FunctionOptionsType* options_type,\n-                                bool allow_overwrite = false) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddFunctionOptionsType(const FunctionOptionsType* options_type,\n+                                           bool allow_overwrite = false) {\n+    return (parent_ == nullptr\n+                ? Status::OK()\n+                : parent_->CanAddFunctionOptionsType(options_type, allow_overwrite)) &\n+           DoAddFunctionOptionsType(options_type, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string name = options_type->type_name();\n-    auto it = name_to_options_type_.find(name);\n-    if (it != name_to_options_type_.end() && !allow_overwrite) {\n-      return Status::KeyError(\n-          \"Already have a function options type registered with name: \", name);\n-    }\n-    name_to_options_type_[name] = options_type;\n-    return Status::OK();\n+  virtual Status AddFunctionOptionsType(const FunctionOptionsType* options_type,\n+                                        bool allow_overwrite = false) {\n+    return (parent_ == nullptr\n+                ? Status::OK()\n+                : parent_->CanAddFunctionOptionsType(options_type, allow_overwrite)) &\n+           DoAddFunctionOptionsType(options_type, allow_overwrite, /*add=*/true);\n   }\n \n-  Result<std::shared_ptr<Function>> GetFunction(const std::string& name) const {\n+  virtual Result<std::shared_ptr<Function>> GetFunction(const std::string& name) const {\n\nReview Comment:\n   ```suggestion\r\n     Result<std::shared_ptr<Function>> GetFunction(const std::string& name) const {\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,78 +34,144 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n-#ifndef NDEBUG\n-    // This validates docstrings extensively, so don't waste time on it\n-    // in release builds.\n-    RETURN_NOT_OK(function->Validate());\n-#endif\n-\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  explicit FunctionRegistryImpl(FunctionRegistryImpl* parent = NULLPTR)\n+      : parent_(parent) {}\n+  virtual ~FunctionRegistryImpl() {}\n+\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n+                                bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string& name = function->name();\n-    auto it = name_to_function_.find(name);\n-    if (it != name_to_function_.end() && !allow_overwrite) {\n-      return Status::KeyError(\"Already have a function registered with name: \", name);\n-    }\n-    name_to_function_[name] = std::move(function);\n-    return Status::OK();\n+  virtual Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/true);\n   }\n \n-  Status AddAlias(const std::string& target_name, const std::string& source_name) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddAlias(const std::string& target_name,\n+                             const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/false);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->CanAddAlias(target_name, source_name);\n+  }\n \n-    auto it = name_to_function_.find(source_name);\n-    if (it == name_to_function_.end()) {\n-      return Status::KeyError(\"No function registered with name: \", source_name);\n-    }\n-    name_to_function_[target_name] = it->second;\n-    return Status::OK();\n+  virtual Status AddAlias(const std::string& target_name,\n+                          const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/true);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->AddAlias(target_name, source_name);\n   }\n \n-  Status AddFunctionOptionsType(const FunctionOptionsType* options_type,\n-                                bool allow_overwrite = false) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddFunctionOptionsType(const FunctionOptionsType* options_type,\n+                                           bool allow_overwrite = false) {\n+    return (parent_ == nullptr\n+                ? Status::OK()\n+                : parent_->CanAddFunctionOptionsType(options_type, allow_overwrite)) &\n+           DoAddFunctionOptionsType(options_type, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string name = options_type->type_name();\n-    auto it = name_to_options_type_.find(name);\n-    if (it != name_to_options_type_.end() && !allow_overwrite) {\n-      return Status::KeyError(\n-          \"Already have a function options type registered with name: \", name);\n-    }\n-    name_to_options_type_[name] = options_type;\n-    return Status::OK();\n+  virtual Status AddFunctionOptionsType(const FunctionOptionsType* options_type,\n\nReview Comment:\n   ```suggestion\r\n     Status AddFunctionOptionsType(const FunctionOptionsType* options_type,\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -115,20 +181,47 @@ std::unique_ptr<FunctionRegistry> FunctionRegistry::Make() {\n   return std::unique_ptr<FunctionRegistry>(new FunctionRegistry());\n }\n \n-FunctionRegistry::FunctionRegistry() { impl_.reset(new FunctionRegistryImpl()); }\n+std::unique_ptr<FunctionRegistry> FunctionRegistry::Make(FunctionRegistry* parent) {\n+  return std::unique_ptr<FunctionRegistry>(\n+      new FunctionRegistry(new FunctionRegistry::FunctionRegistryImpl(&*parent->impl_)));\n+}\n+\n+std::unique_ptr<FunctionRegistry> FunctionRegistry::Make(\n+    std::unique_ptr<FunctionRegistry> parent) {\n+  return FunctionRegistry::Make(&*parent);\n+}\n+\n\nReview Comment:\n   ```suggestion\r\n   ```\r\n   \r\n   As explained in the header file.\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,78 +34,144 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n-#ifndef NDEBUG\n-    // This validates docstrings extensively, so don't waste time on it\n-    // in release builds.\n-    RETURN_NOT_OK(function->Validate());\n-#endif\n-\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  explicit FunctionRegistryImpl(FunctionRegistryImpl* parent = NULLPTR)\n+      : parent_(parent) {}\n+  virtual ~FunctionRegistryImpl() {}\n+\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n+                                bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string& name = function->name();\n-    auto it = name_to_function_.find(name);\n-    if (it != name_to_function_.end() && !allow_overwrite) {\n-      return Status::KeyError(\"Already have a function registered with name: \", name);\n-    }\n-    name_to_function_[name] = std::move(function);\n-    return Status::OK();\n+  virtual Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/true);\n   }\n \n-  Status AddAlias(const std::string& target_name, const std::string& source_name) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddAlias(const std::string& target_name,\n+                             const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/false);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->CanAddAlias(target_name, source_name);\n+  }\n \n-    auto it = name_to_function_.find(source_name);\n-    if (it == name_to_function_.end()) {\n-      return Status::KeyError(\"No function registered with name: \", source_name);\n-    }\n-    name_to_function_[target_name] = it->second;\n-    return Status::OK();\n+  virtual Status AddAlias(const std::string& target_name,\n+                          const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/true);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->AddAlias(target_name, source_name);\n   }\n \n-  Status AddFunctionOptionsType(const FunctionOptionsType* options_type,\n-                                bool allow_overwrite = false) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddFunctionOptionsType(const FunctionOptionsType* options_type,\n+                                           bool allow_overwrite = false) {\n+    return (parent_ == nullptr\n+                ? Status::OK()\n+                : parent_->CanAddFunctionOptionsType(options_type, allow_overwrite)) &\n+           DoAddFunctionOptionsType(options_type, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string name = options_type->type_name();\n-    auto it = name_to_options_type_.find(name);\n-    if (it != name_to_options_type_.end() && !allow_overwrite) {\n-      return Status::KeyError(\n-          \"Already have a function options type registered with name: \", name);\n-    }\n-    name_to_options_type_[name] = options_type;\n-    return Status::OK();\n+  virtual Status AddFunctionOptionsType(const FunctionOptionsType* options_type,\n+                                        bool allow_overwrite = false) {\n+    return (parent_ == nullptr\n+                ? Status::OK()\n+                : parent_->CanAddFunctionOptionsType(options_type, allow_overwrite)) &\n+           DoAddFunctionOptionsType(options_type, allow_overwrite, /*add=*/true);\n   }\n \n-  Result<std::shared_ptr<Function>> GetFunction(const std::string& name) const {\n+  virtual Result<std::shared_ptr<Function>> GetFunction(const std::string& name) const {\n     auto it = name_to_function_.find(name);\n     if (it == name_to_function_.end()) {\n+      if (parent_ != nullptr) {\n+        return parent_->GetFunction(name);\n+      }\n       return Status::KeyError(\"No function registered with name: \", name);\n     }\n     return it->second;\n   }\n \n-  std::vector<std::string> GetFunctionNames() const {\n+  virtual std::vector<std::string> GetFunctionNames() const {\n     std::vector<std::string> results;\n+    if (parent_ != nullptr) {\n+      results = parent_->GetFunctionNames();\n+    }\n     for (auto it : name_to_function_) {\n       results.push_back(it.first);\n     }\n     std::sort(results.begin(), results.end());\n     return results;\n   }\n \n-  Result<const FunctionOptionsType*> GetFunctionOptionsType(\n+  virtual Result<const FunctionOptionsType*> GetFunctionOptionsType(\n\nReview Comment:\n   ```suggestion\r\n     Result<const FunctionOptionsType*> GetFunctionOptionsType(\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,78 +34,144 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n-#ifndef NDEBUG\n-    // This validates docstrings extensively, so don't waste time on it\n-    // in release builds.\n-    RETURN_NOT_OK(function->Validate());\n-#endif\n-\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  explicit FunctionRegistryImpl(FunctionRegistryImpl* parent = NULLPTR)\n+      : parent_(parent) {}\n+  virtual ~FunctionRegistryImpl() {}\n+\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n+                                bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string& name = function->name();\n-    auto it = name_to_function_.find(name);\n-    if (it != name_to_function_.end() && !allow_overwrite) {\n-      return Status::KeyError(\"Already have a function registered with name: \", name);\n-    }\n-    name_to_function_[name] = std::move(function);\n-    return Status::OK();\n+  virtual Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/true);\n   }\n \n-  Status AddAlias(const std::string& target_name, const std::string& source_name) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddAlias(const std::string& target_name,\n+                             const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/false);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->CanAddAlias(target_name, source_name);\n+  }\n \n-    auto it = name_to_function_.find(source_name);\n-    if (it == name_to_function_.end()) {\n-      return Status::KeyError(\"No function registered with name: \", source_name);\n-    }\n-    name_to_function_[target_name] = it->second;\n-    return Status::OK();\n+  virtual Status AddAlias(const std::string& target_name,\n+                          const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/true);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->AddAlias(target_name, source_name);\n   }\n \n-  Status AddFunctionOptionsType(const FunctionOptionsType* options_type,\n-                                bool allow_overwrite = false) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddFunctionOptionsType(const FunctionOptionsType* options_type,\n+                                           bool allow_overwrite = false) {\n+    return (parent_ == nullptr\n+                ? Status::OK()\n+                : parent_->CanAddFunctionOptionsType(options_type, allow_overwrite)) &\n+           DoAddFunctionOptionsType(options_type, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string name = options_type->type_name();\n-    auto it = name_to_options_type_.find(name);\n-    if (it != name_to_options_type_.end() && !allow_overwrite) {\n-      return Status::KeyError(\n-          \"Already have a function options type registered with name: \", name);\n-    }\n-    name_to_options_type_[name] = options_type;\n-    return Status::OK();\n+  virtual Status AddFunctionOptionsType(const FunctionOptionsType* options_type,\n+                                        bool allow_overwrite = false) {\n+    return (parent_ == nullptr\n+                ? Status::OK()\n+                : parent_->CanAddFunctionOptionsType(options_type, allow_overwrite)) &\n+           DoAddFunctionOptionsType(options_type, allow_overwrite, /*add=*/true);\n   }\n \n-  Result<std::shared_ptr<Function>> GetFunction(const std::string& name) const {\n+  virtual Result<std::shared_ptr<Function>> GetFunction(const std::string& name) const {\n     auto it = name_to_function_.find(name);\n     if (it == name_to_function_.end()) {\n+      if (parent_ != nullptr) {\n+        return parent_->GetFunction(name);\n+      }\n       return Status::KeyError(\"No function registered with name: \", name);\n     }\n     return it->second;\n   }\n \n-  std::vector<std::string> GetFunctionNames() const {\n+  virtual std::vector<std::string> GetFunctionNames() const {\n     std::vector<std::string> results;\n+    if (parent_ != nullptr) {\n+      results = parent_->GetFunctionNames();\n+    }\n     for (auto it : name_to_function_) {\n       results.push_back(it.first);\n     }\n     std::sort(results.begin(), results.end());\n     return results;\n   }\n \n-  Result<const FunctionOptionsType*> GetFunctionOptionsType(\n+  virtual Result<const FunctionOptionsType*> GetFunctionOptionsType(\n       const std::string& name) const {\n     auto it = name_to_options_type_.find(name);\n     if (it == name_to_options_type_.end()) {\n+      if (parent_ != nullptr) {\n+        return parent_->GetFunctionOptionsType(name);\n+      }\n       return Status::KeyError(\"No function options type registered with name: \", name);\n     }\n     return it->second;\n   }\n \n-  int num_functions() const { return static_cast<int>(name_to_function_.size()); }\n+  virtual int num_functions() const {\n\nReview Comment:\n   ```suggestion\r\n     int num_functions() const {\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,78 +34,144 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n-#ifndef NDEBUG\n-    // This validates docstrings extensively, so don't waste time on it\n-    // in release builds.\n-    RETURN_NOT_OK(function->Validate());\n-#endif\n-\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  explicit FunctionRegistryImpl(FunctionRegistryImpl* parent = NULLPTR)\n+      : parent_(parent) {}\n+  virtual ~FunctionRegistryImpl() {}\n+\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n+                                bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string& name = function->name();\n-    auto it = name_to_function_.find(name);\n-    if (it != name_to_function_.end() && !allow_overwrite) {\n-      return Status::KeyError(\"Already have a function registered with name: \", name);\n-    }\n-    name_to_function_[name] = std::move(function);\n-    return Status::OK();\n+  virtual Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/true);\n   }\n \n-  Status AddAlias(const std::string& target_name, const std::string& source_name) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddAlias(const std::string& target_name,\n+                             const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/false);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->CanAddAlias(target_name, source_name);\n+  }\n \n-    auto it = name_to_function_.find(source_name);\n-    if (it == name_to_function_.end()) {\n-      return Status::KeyError(\"No function registered with name: \", source_name);\n-    }\n-    name_to_function_[target_name] = it->second;\n-    return Status::OK();\n+  virtual Status AddAlias(const std::string& target_name,\n+                          const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/true);\n+    return st.ok() || parent_ == nullptr ? st\n+                                         : parent_->AddAlias(target_name, source_name);\n   }\n \n-  Status AddFunctionOptionsType(const FunctionOptionsType* options_type,\n-                                bool allow_overwrite = false) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddFunctionOptionsType(const FunctionOptionsType* options_type,\n+                                           bool allow_overwrite = false) {\n+    return (parent_ == nullptr\n+                ? Status::OK()\n+                : parent_->CanAddFunctionOptionsType(options_type, allow_overwrite)) &\n+           DoAddFunctionOptionsType(options_type, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string name = options_type->type_name();\n-    auto it = name_to_options_type_.find(name);\n-    if (it != name_to_options_type_.end() && !allow_overwrite) {\n-      return Status::KeyError(\n-          \"Already have a function options type registered with name: \", name);\n-    }\n-    name_to_options_type_[name] = options_type;\n-    return Status::OK();\n+  virtual Status AddFunctionOptionsType(const FunctionOptionsType* options_type,\n+                                        bool allow_overwrite = false) {\n+    return (parent_ == nullptr\n+                ? Status::OK()\n+                : parent_->CanAddFunctionOptionsType(options_type, allow_overwrite)) &\n+           DoAddFunctionOptionsType(options_type, allow_overwrite, /*add=*/true);\n   }\n \n-  Result<std::shared_ptr<Function>> GetFunction(const std::string& name) const {\n+  virtual Result<std::shared_ptr<Function>> GetFunction(const std::string& name) const {\n     auto it = name_to_function_.find(name);\n     if (it == name_to_function_.end()) {\n+      if (parent_ != nullptr) {\n+        return parent_->GetFunction(name);\n+      }\n       return Status::KeyError(\"No function registered with name: \", name);\n     }\n     return it->second;\n   }\n \n-  std::vector<std::string> GetFunctionNames() const {\n+  virtual std::vector<std::string> GetFunctionNames() const {\n\nReview Comment:\n   ```suggestion\r\n     std::vector<std::string> GetFunctionNames() const {\r\n   ```\n\n\n\n",
                    "created": "2022-06-07T17:43:57.736+0000",
                    "updated": "2022-06-07T17:43:57.736+0000",
                    "started": "2022-06-07T17:43:57.735+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "779201",
                    "issueId": "13447175"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175/worklog/779840",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on code in PR #13252:\nURL: https://github.com/apache/arrow/pull/13252#discussion_r893307324\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -34,78 +34,144 @@ namespace compute {\n \n class FunctionRegistry::FunctionRegistryImpl {\n  public:\n-  Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n-#ifndef NDEBUG\n-    // This validates docstrings extensively, so don't waste time on it\n-    // in release builds.\n-    RETURN_NOT_OK(function->Validate());\n-#endif\n-\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  explicit FunctionRegistryImpl(FunctionRegistryImpl* parent = NULLPTR)\n+      : parent_(parent) {}\n+  virtual ~FunctionRegistryImpl() {}\n+\n+  virtual Status CanAddFunction(std::shared_ptr<Function> function,\n+                                bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/false);\n+  }\n \n-    const std::string& name = function->name();\n-    auto it = name_to_function_.find(name);\n-    if (it != name_to_function_.end() && !allow_overwrite) {\n-      return Status::KeyError(\"Already have a function registered with name: \", name);\n-    }\n-    name_to_function_[name] = std::move(function);\n-    return Status::OK();\n+  virtual Status AddFunction(std::shared_ptr<Function> function, bool allow_overwrite) {\n+    return (parent_ == nullptr ? Status::OK()\n+                               : parent_->CanAddFunction(function, allow_overwrite)) &\n+           DoAddFunction(function, allow_overwrite, /*add=*/true);\n   }\n \n-  Status AddAlias(const std::string& target_name, const std::string& source_name) {\n-    std::lock_guard<std::mutex> mutation_guard(lock_);\n+  virtual Status CanAddAlias(const std::string& target_name,\n+                             const std::string& source_name) {\n+    Status st = DoAddAlias(target_name, source_name, /*add=*/false);\n\nReview Comment:\n   Almost right. The first point should be: check if source_name exists in this or parent and fail otherwise. An alias can be to the a function existing only in the parent.\n\n\n\n",
                    "created": "2022-06-09T09:53:53.313+0000",
                    "updated": "2022-06-09T09:53:53.313+0000",
                    "started": "2022-06-09T09:53:53.313+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "779840",
                    "issueId": "13447175"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175/worklog/779843",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on code in PR #13252:\nURL: https://github.com/apache/arrow/pull/13252#discussion_r893315827\n\n\n##########\ncpp/src/arrow/compute/registry.cc:\n##########\n@@ -115,20 +181,47 @@ std::unique_ptr<FunctionRegistry> FunctionRegistry::Make() {\n   return std::unique_ptr<FunctionRegistry>(new FunctionRegistry());\n }\n \n-FunctionRegistry::FunctionRegistry() { impl_.reset(new FunctionRegistryImpl()); }\n+std::unique_ptr<FunctionRegistry> FunctionRegistry::Make(FunctionRegistry* parent) {\n+  return std::unique_ptr<FunctionRegistry>(\n+      new FunctionRegistry(new FunctionRegistry::FunctionRegistryImpl(&*parent->impl_)));\n\nReview Comment:\n   This change leads to a failed test:\r\n   ```\r\n   /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/compute/registry_test.cc:124: Failure\r\n   Failed\r\n   'default_registry->CanAddFunction(func)' failed with Key error: Already have a function registered with name: f1\r\n   [  FAILED  ] TestRegistry.RegisterTempFunctions (0 ms)\r\n   ```\r\n   The existing code makes a new `FunctionRegistryImpl` with a parent of the same type, which is what we want for scoping. Though I did fix this code to use `.get()`.\n\n\n\n",
                    "created": "2022-06-09T10:02:42.824+0000",
                    "updated": "2022-06-09T10:02:42.824+0000",
                    "started": "2022-06-09T10:02:42.824+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "779843",
                    "issueId": "13447175"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175/worklog/779845",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #13252:\nURL: https://github.com/apache/arrow/pull/13252#issuecomment-1150927804\n\n   > Most of these changes are minor but we do need to clean up the constructors.\r\n   > \r\n   > I realized as I was doing the review that some of these method comments (e.g. `\\brief`) were following existing patterns in this file. However, I think the suggestions move us more in line with the rest of the code base (e.g. `\\brief` should be a one line description. The things that follow are a note) and we can clean up the others later.\r\n   > \r\n   > I find the nested ternary (i.e. `(a ? b : c) & d` a little too compact to follow. Now that `Status && Status` is unavailable I think we should probably avoid `&` when short-circuit is desired when using `Status`.\r\n   > \r\n   > It might be worth noting somewhere (assuming my understanding is correct here) that even if `allow_overwrite` is true it a registry will never modify its parent.\r\n   > \r\n   > Lastly, I'm not sure why we didn't check for existing function names in `AddAlias`. I think we should probably correct that here rather than persist the status quo. But it's possible I'm not understanding some nuance.\r\n   \r\n   I agree with almost everything. I think your comments about logic are not minor :) I ended up fixing and cleaning up the code quite a bit following them. Thanks for catching.\n\n\n",
                    "created": "2022-06-09T10:04:00.813+0000",
                    "updated": "2022-06-09T10:04:00.813+0000",
                    "started": "2022-06-09T10:04:00.813+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "779845",
                    "issueId": "13447175"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175/worklog/782532",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #13252:\nURL: https://github.com/apache/arrow/pull/13252#issuecomment-1159215617\n\n   This can get pushed and I'll handle the merge.\n\n\n",
                    "created": "2022-06-17T20:44:42.085+0000",
                    "updated": "2022-06-17T20:44:42.085+0000",
                    "started": "2022-06-17T20:44:42.084+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "782532",
                    "issueId": "13447175"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175/worklog/782569",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace merged PR #13252:\nURL: https://github.com/apache/arrow/pull/13252\n\n\n",
                    "created": "2022-06-18T03:16:52.253+0000",
                    "updated": "2022-06-18T03:16:52.253+0000",
                    "started": "2022-06-18T03:16:52.253+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "782569",
                    "issueId": "13447175"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 10800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@2430557b[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@657d58dd[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3448e5af[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@3bfce84b[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1e1e5d34[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@235e7ab9[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@504886e0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@c2a8212[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6031995e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@306aac53[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@24014338[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@7ce37fb8[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 10800,
        "customfield_12312520": null,
        "customfield_12312521": "Sat Jun 18 03:16:55 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": [
            "C++"
        ],
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-06-18T03:16:55.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16677/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2022-05-27T08:43:48.000+0000",
        "updated": "2022-06-18T03:16:55.000+0000",
        "timeoriginalestimate": null,
        "description": "h4. \r\nCurrently, only a default function-registry is supported. Modifying this registry has global effects, which is often undesirable. Support for nesting function-registries will provide scoping for such modifications.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "3h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 10800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Support nesting of function registries",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447175/comment/17555822",
                    "id": "17555822",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 13252\n[https://github.com/apache/arrow/pull/13252]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-06-18T03:16:55.216+0000",
                    "updated": "2022-06-18T03:16:55.216+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z12qqo:",
        "customfield_12314139": null
    }
}