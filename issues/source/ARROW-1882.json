{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13122531",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122531",
    "key": "ARROW-1882",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12341352",
                "id": "12341352",
                "name": "0.8.0",
                "archived": false,
                "released": true,
                "releaseDate": "2017-12-18"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/2",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/critical.svg",
            "name": "Critical",
            "id": "2"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": null,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
            "name": "uwe",
            "key": "xhochy",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
            },
            "displayName": "Uwe Korn",
            "active": true,
            "timeZone": "Europe/Berlin"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": null,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
            "name": "uwe",
            "key": "xhochy",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
            },
            "displayName": "Uwe Korn",
            "active": true,
            "timeZone": "Europe/Berlin"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
            "name": "uwe",
            "key": "xhochy",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
            },
            "displayName": "Uwe Korn",
            "active": true,
            "timeZone": "Europe/Berlin"
        },
        "aggregateprogress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1882/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 0,
            "worklogs": []
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
            "id": "1",
            "description": "A problem which impairs or prevents the functions of the product.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
            "name": "Bug",
            "subtask": false,
            "avatarId": 21133
        },
        "timespent": null,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@75ff0a5[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3b8d85c1[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5cc69fab[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@bb2aa7f[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@27a40dd6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@270a7e21[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4fd996ac[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@51a62c7a[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@566b4125[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@2264d6bf[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@218b48a9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@41ae651e[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": null,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Dec 06 03:02:58 UTC 2017",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2017-12-06T03:02:55.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1882/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2017-12-04T09:52:57.000+0000",
        "updated": "2017-12-06T03:02:58.000+0000",
        "timeoriginalestimate": null,
        "description": "We need the {{DictionaryBuilder}} to incrementally build Arrow Arrays of {{DictionaryType}}. The kernels only support en-bloc conversions of Arrays which yields a higher memory usage.",
        "customfield_10010": null,
        "timetracking": {},
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Reintroduce DictionaryBuilder",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122531/comment/16276878",
                    "id": "16276878",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Sorry about creating extra work for you here, I will be happy to help with refactoring and trying to increase possible code reuse between the incremental builder and the kernels. Let me know how I can help otherwise",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-12-04T14:46:09.951+0000",
                    "updated": "2017-12-04T14:46:09.951+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122531/comment/16277197",
                    "id": "16277197",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "xhochy opened a new pull request #1388: ARROW-1882: [C++] Reintroduce DictionaryBuilder\nURL: https://github.com/apache/arrow/pull/1388\n \n \n   Readded the previous code and moved some small parts to a new common place to share logic between kernels and builder.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-12-04T18:23:54.753+0000",
                    "updated": "2017-12-04T18:23:54.753+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122531/comment/16277279",
                    "id": "16277279",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1388: ARROW-1882: [C++] Reintroduce DictionaryBuilder\nURL: https://github.com/apache/arrow/pull/1388#issuecomment-349070682\n \n \n   Thanks @xhochy! I will review \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-12-04T19:07:00.387+0000",
                    "updated": "2017-12-04T19:07:00.387+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122531/comment/16278519",
                    "id": "16278519",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "xhochy commented on issue #1388: ARROW-1882: [C++] Reintroduce DictionaryBuilder\nURL: https://github.com/apache/arrow/pull/1388#issuecomment-349300694\n \n \n   Green AppVeyor: https://ci.appveyor.com/project/xhochy/arrow/build/1.0.526\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-12-05T13:15:15.606+0000",
                    "updated": "2017-12-05T13:15:15.606+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122531/comment/16278520",
                    "id": "16278520",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "xhochy commented on issue #1388: ARROW-1882: [C++] Reintroduce DictionaryBuilder\nURL: https://github.com/apache/arrow/pull/1388#issuecomment-349301287\n \n \n   @wesm it did not look at first glance that we could easily share more code. I would like to see this merged before 0.8 and then refactor a bit later on to reduce code duplication.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-12-05T13:17:50.761+0000",
                    "updated": "2017-12-05T13:17:50.761+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122531/comment/16279247",
                    "id": "16279247",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on a change in pull request #1388: ARROW-1882: [C++] Reintroduce DictionaryBuilder\nURL: https://github.com/apache/arrow/pull/1388#discussion_r155085087\n \n \n\n ##########\n File path: cpp/src/arrow/array-test.cc\n ##########\n @@ -1619,6 +1619,353 @@ TEST_F(TestAdaptiveUIntBuilder, TestAppendVector) {\n   ASSERT_TRUE(expected_->Equals(result_));\n }\n \n+// ----------------------------------------------------------------------\n+// Dictionary tests\n+\n+template <typename Type>\n+class TestDictionaryBuilder : public TestBuilder {};\n+\n+typedef ::testing::Types<Int8Type, UInt8Type, Int16Type, UInt16Type, Int32Type,\n+                         UInt32Type, Int64Type, UInt64Type, FloatType, DoubleType>\n+    PrimitiveDictionaries;\n+\n+TYPED_TEST_CASE(TestDictionaryBuilder, PrimitiveDictionaries);\n+\n+TYPED_TEST(TestDictionaryBuilder, Basic) {\n+  DictionaryBuilder<TypeParam> builder(default_memory_pool());\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(builder.Finish(&result));\n+\n+  // Build expected data\n+  NumericBuilder<TypeParam> dict_builder;\n+  ASSERT_OK(dict_builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(dict_builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  std::shared_ptr<Array> dict_array;\n+  ASSERT_OK(dict_builder.Finish(&dict_array));\n+  auto dtype = std::make_shared<DictionaryType>(int8(), dict_array);\n+\n+  Int8Builder int_builder;\n+  ASSERT_OK(int_builder.Append(0));\n+  ASSERT_OK(int_builder.Append(1));\n+  ASSERT_OK(int_builder.Append(0));\n+  std::shared_ptr<Array> int_array;\n+  ASSERT_OK(int_builder.Finish(&int_array));\n+\n+  DictionaryArray expected(dtype, int_array);\n+  ASSERT_TRUE(expected.Equals(result));\n+}\n+\n+TYPED_TEST(TestDictionaryBuilder, ArrayConversion) {\n+  NumericBuilder<TypeParam> builder;\n+  // DictionaryBuilder<TypeParam> builder;\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+\n+  std::shared_ptr<Array> intermediate_result;\n+  ASSERT_OK(builder.Finish(&intermediate_result));\n+  DictionaryBuilder<TypeParam> dictionary_builder(default_memory_pool());\n+  ASSERT_OK(dictionary_builder.AppendArray(*intermediate_result));\n \n Review comment:\n   We might consider removing these `AppendArray` methods in favor of the kernel-based approach\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-12-05T21:56:32.169+0000",
                    "updated": "2017-12-05T21:56:32.169+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122531/comment/16279575",
                    "id": "16279575",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 1388\n[https://github.com/apache/arrow/pull/1388]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-12-06T03:02:55.957+0000",
                    "updated": "2017-12-06T03:02:55.957+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13122531/comment/16279576",
                    "id": "16279576",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm closed pull request #1388: ARROW-1882: [C++] Reintroduce DictionaryBuilder\nURL: https://github.com/apache/arrow/pull/1388\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/cpp/src/arrow/CMakeLists.txt b/cpp/src/arrow/CMakeLists.txt\nindex 94705781f..d645cca22 100644\n--- a/cpp/src/arrow/CMakeLists.txt\n+++ b/cpp/src/arrow/CMakeLists.txt\n@@ -38,6 +38,7 @@ set(ARROW_SRCS\n   util/compression.cc\n   util/cpu-info.cc\n   util/decimal.cc\n+  util/hash.cc\n   util/key_value_metadata.cc\n )\n \ndiff --git a/cpp/src/arrow/array-test.cc b/cpp/src/arrow/array-test.cc\nindex d894df131..7ff3261ec 100644\n--- a/cpp/src/arrow/array-test.cc\n+++ b/cpp/src/arrow/array-test.cc\n@@ -1619,6 +1619,353 @@ TEST_F(TestAdaptiveUIntBuilder, TestAppendVector) {\n   ASSERT_TRUE(expected_->Equals(result_));\n }\n \n+// ----------------------------------------------------------------------\n+// Dictionary tests\n+\n+template <typename Type>\n+class TestDictionaryBuilder : public TestBuilder {};\n+\n+typedef ::testing::Types<Int8Type, UInt8Type, Int16Type, UInt16Type, Int32Type,\n+                         UInt32Type, Int64Type, UInt64Type, FloatType, DoubleType>\n+    PrimitiveDictionaries;\n+\n+TYPED_TEST_CASE(TestDictionaryBuilder, PrimitiveDictionaries);\n+\n+TYPED_TEST(TestDictionaryBuilder, Basic) {\n+  DictionaryBuilder<TypeParam> builder(default_memory_pool());\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(builder.Finish(&result));\n+\n+  // Build expected data\n+  NumericBuilder<TypeParam> dict_builder;\n+  ASSERT_OK(dict_builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(dict_builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  std::shared_ptr<Array> dict_array;\n+  ASSERT_OK(dict_builder.Finish(&dict_array));\n+  auto dtype = std::make_shared<DictionaryType>(int8(), dict_array);\n+\n+  Int8Builder int_builder;\n+  ASSERT_OK(int_builder.Append(0));\n+  ASSERT_OK(int_builder.Append(1));\n+  ASSERT_OK(int_builder.Append(0));\n+  std::shared_ptr<Array> int_array;\n+  ASSERT_OK(int_builder.Finish(&int_array));\n+\n+  DictionaryArray expected(dtype, int_array);\n+  ASSERT_TRUE(expected.Equals(result));\n+}\n+\n+TYPED_TEST(TestDictionaryBuilder, ArrayConversion) {\n+  NumericBuilder<TypeParam> builder;\n+  // DictionaryBuilder<TypeParam> builder;\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+\n+  std::shared_ptr<Array> intermediate_result;\n+  ASSERT_OK(builder.Finish(&intermediate_result));\n+  DictionaryBuilder<TypeParam> dictionary_builder(default_memory_pool());\n+  ASSERT_OK(dictionary_builder.AppendArray(*intermediate_result));\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(dictionary_builder.Finish(&result));\n+\n+  // Build expected data\n+  NumericBuilder<TypeParam> dict_builder;\n+  ASSERT_OK(dict_builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(dict_builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  std::shared_ptr<Array> dict_array;\n+  ASSERT_OK(dict_builder.Finish(&dict_array));\n+  auto dtype = std::make_shared<DictionaryType>(int8(), dict_array);\n+\n+  Int8Builder int_builder;\n+  ASSERT_OK(int_builder.Append(0));\n+  ASSERT_OK(int_builder.Append(1));\n+  ASSERT_OK(int_builder.Append(0));\n+  std::shared_ptr<Array> int_array;\n+  ASSERT_OK(int_builder.Finish(&int_array));\n+\n+  DictionaryArray expected(dtype, int_array);\n+  ASSERT_TRUE(expected.Equals(result));\n+}\n+\n+TYPED_TEST(TestDictionaryBuilder, DoubleTableSize) {\n+  using Scalar = typename TypeParam::c_type;\n+  // Skip this test for (u)int8\n+  if (sizeof(Scalar) > 1) {\n+    // Build the dictionary Array\n+    DictionaryBuilder<TypeParam> builder(default_memory_pool());\n+    // Build expected data\n+    NumericBuilder<TypeParam> dict_builder;\n+    Int16Builder int_builder;\n+\n+    // Fill with 1024 different values\n+    for (int64_t i = 0; i < 1024; i++) {\n+      ASSERT_OK(builder.Append(static_cast<Scalar>(i)));\n+      ASSERT_OK(dict_builder.Append(static_cast<Scalar>(i)));\n+      ASSERT_OK(int_builder.Append(static_cast<uint16_t>(i)));\n+    }\n+    // Fill with an already existing value\n+    for (int64_t i = 0; i < 1024; i++) {\n+      ASSERT_OK(builder.Append(static_cast<Scalar>(1)));\n+      ASSERT_OK(int_builder.Append(1));\n+    }\n+\n+    // Finalize result\n+    std::shared_ptr<Array> result;\n+    ASSERT_OK(builder.Finish(&result));\n+\n+    // Finalize expected data\n+    std::shared_ptr<Array> dict_array;\n+    ASSERT_OK(dict_builder.Finish(&dict_array));\n+    auto dtype = std::make_shared<DictionaryType>(int16(), dict_array);\n+    std::shared_ptr<Array> int_array;\n+    ASSERT_OK(int_builder.Finish(&int_array));\n+\n+    DictionaryArray expected(dtype, int_array);\n+    ASSERT_TRUE(expected.Equals(result));\n+  }\n+}\n+\n+TEST(TestStringDictionaryBuilder, Basic) {\n+  // Build the dictionary Array\n+  StringDictionaryBuilder builder(default_memory_pool());\n+  ASSERT_OK(builder.Append(\"test\"));\n+  ASSERT_OK(builder.Append(\"test2\"));\n+  ASSERT_OK(builder.Append(\"test\"));\n+\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(builder.Finish(&result));\n+\n+  // Build expected data\n+  StringBuilder str_builder;\n+  ASSERT_OK(str_builder.Append(\"test\"));\n+  ASSERT_OK(str_builder.Append(\"test2\"));\n+  std::shared_ptr<Array> str_array;\n+  ASSERT_OK(str_builder.Finish(&str_array));\n+  auto dtype = std::make_shared<DictionaryType>(int8(), str_array);\n+\n+  Int8Builder int_builder;\n+  ASSERT_OK(int_builder.Append(0));\n+  ASSERT_OK(int_builder.Append(1));\n+  ASSERT_OK(int_builder.Append(0));\n+  std::shared_ptr<Array> int_array;\n+  ASSERT_OK(int_builder.Finish(&int_array));\n+\n+  DictionaryArray expected(dtype, int_array);\n+  ASSERT_TRUE(expected.Equals(result));\n+}\n+\n+TEST(TestStringDictionaryBuilder, DoubleTableSize) {\n+  // Build the dictionary Array\n+  StringDictionaryBuilder builder(default_memory_pool());\n+  // Build expected data\n+  StringBuilder str_builder;\n+  Int16Builder int_builder;\n+\n+  // Fill with 1024 different values\n+  for (int64_t i = 0; i < 1024; i++) {\n+    std::stringstream ss;\n+    ss << \"test\" << i;\n+    ASSERT_OK(builder.Append(ss.str()));\n+    ASSERT_OK(str_builder.Append(ss.str()));\n+    ASSERT_OK(int_builder.Append(static_cast<uint16_t>(i)));\n+  }\n+  // Fill with an already existing value\n+  for (int64_t i = 0; i < 1024; i++) {\n+    ASSERT_OK(builder.Append(\"test1\"));\n+    ASSERT_OK(int_builder.Append(1));\n+  }\n+\n+  // Finalize result\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(builder.Finish(&result));\n+\n+  // Finalize expected data\n+  std::shared_ptr<Array> str_array;\n+  ASSERT_OK(str_builder.Finish(&str_array));\n+  auto dtype = std::make_shared<DictionaryType>(int16(), str_array);\n+  std::shared_ptr<Array> int_array;\n+  ASSERT_OK(int_builder.Finish(&int_array));\n+\n+  DictionaryArray expected(dtype, int_array);\n+  ASSERT_TRUE(expected.Equals(result));\n+}\n+\n+TEST(TestFixedSizeBinaryDictionaryBuilder, Basic) {\n+  // Build the dictionary Array\n+  DictionaryBuilder<FixedSizeBinaryType> builder(arrow::fixed_size_binary(4),\n+                                                 default_memory_pool());\n+  std::vector<uint8_t> test{12, 12, 11, 12};\n+  std::vector<uint8_t> test2{12, 12, 11, 11};\n+  ASSERT_OK(builder.Append(test.data()));\n+  ASSERT_OK(builder.Append(test2.data()));\n+  ASSERT_OK(builder.Append(test.data()));\n+\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(builder.Finish(&result));\n+\n+  // Build expected data\n+  FixedSizeBinaryBuilder fsb_builder(arrow::fixed_size_binary(4));\n+  ASSERT_OK(fsb_builder.Append(test.data()));\n+  ASSERT_OK(fsb_builder.Append(test2.data()));\n+  std::shared_ptr<Array> fsb_array;\n+  ASSERT_OK(fsb_builder.Finish(&fsb_array));\n+  auto dtype = std::make_shared<DictionaryType>(int8(), fsb_array);\n+\n+  Int8Builder int_builder;\n+  ASSERT_OK(int_builder.Append(0));\n+  ASSERT_OK(int_builder.Append(1));\n+  ASSERT_OK(int_builder.Append(0));\n+  std::shared_ptr<Array> int_array;\n+  ASSERT_OK(int_builder.Finish(&int_array));\n+\n+  DictionaryArray expected(dtype, int_array);\n+  ASSERT_TRUE(expected.Equals(result));\n+}\n+\n+TEST(TestFixedSizeBinaryDictionaryBuilder, DoubleTableSize) {\n+  // Build the dictionary Array\n+  DictionaryBuilder<FixedSizeBinaryType> builder(arrow::fixed_size_binary(4),\n+                                                 default_memory_pool());\n+  // Build expected data\n+  FixedSizeBinaryBuilder fsb_builder(arrow::fixed_size_binary(4));\n+  Int16Builder int_builder;\n+\n+  // Fill with 1024 different values\n+  for (int64_t i = 0; i < 1024; i++) {\n+    std::vector<uint8_t> value{12, 12, static_cast<uint8_t>(i / 128),\n+                               static_cast<uint8_t>(i % 128)};\n+    ASSERT_OK(builder.Append(value.data()));\n+    ASSERT_OK(fsb_builder.Append(value.data()));\n+    ASSERT_OK(int_builder.Append(static_cast<uint16_t>(i)));\n+  }\n+  // Fill with an already existing value\n+  std::vector<uint8_t> known_value{12, 12, 0, 1};\n+  for (int64_t i = 0; i < 1024; i++) {\n+    ASSERT_OK(builder.Append(known_value.data()));\n+    ASSERT_OK(int_builder.Append(1));\n+  }\n+\n+  // Finalize result\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(builder.Finish(&result));\n+\n+  // Finalize expected data\n+  std::shared_ptr<Array> fsb_array;\n+  ASSERT_OK(fsb_builder.Finish(&fsb_array));\n+  auto dtype = std::make_shared<DictionaryType>(int16(), fsb_array);\n+  std::shared_ptr<Array> int_array;\n+  ASSERT_OK(int_builder.Finish(&int_array));\n+\n+  DictionaryArray expected(dtype, int_array);\n+  ASSERT_TRUE(expected.Equals(result));\n+}\n+\n+TEST(TestFixedSizeBinaryDictionaryBuilder, InvalidTypeAppend) {\n+  // Build the dictionary Array\n+  DictionaryBuilder<FixedSizeBinaryType> builder(arrow::fixed_size_binary(4),\n+                                                 default_memory_pool());\n+  // Build an array with different byte width\n+  FixedSizeBinaryBuilder fsb_builder(arrow::fixed_size_binary(5));\n+  std::vector<uint8_t> value{100, 1, 1, 1, 1};\n+  ASSERT_OK(fsb_builder.Append(value.data()));\n+  std::shared_ptr<Array> fsb_array;\n+  ASSERT_OK(fsb_builder.Finish(&fsb_array));\n+\n+  ASSERT_RAISES(Invalid, builder.AppendArray(*fsb_array));\n+}\n+\n+TEST(TestDecimalDictionaryBuilder, Basic) {\n+  // Build the dictionary Array\n+  const auto& decimal_type = arrow::decimal(2, 0);\n+  DictionaryBuilder<FixedSizeBinaryType> builder(decimal_type, default_memory_pool());\n+\n+  // Test data\n+  std::vector<Decimal128> test{12, 12, 11, 12};\n+  for (const auto& value : test) {\n+    ASSERT_OK(builder.Append(value.ToBytes().data()));\n+  }\n+\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(builder.Finish(&result));\n+\n+  // Build expected data\n+  FixedSizeBinaryBuilder decimal_builder(decimal_type);\n+  ASSERT_OK(decimal_builder.Append(Decimal128(12).ToBytes()));\n+  ASSERT_OK(decimal_builder.Append(Decimal128(11).ToBytes()));\n+\n+  std::shared_ptr<Array> decimal_array;\n+  ASSERT_OK(decimal_builder.Finish(&decimal_array));\n+  auto dtype = arrow::dictionary(int8(), decimal_array);\n+\n+  Int8Builder int_builder;\n+  ASSERT_OK(int_builder.Append({0, 0, 1, 0}));\n+  std::shared_ptr<Array> int_array;\n+  ASSERT_OK(int_builder.Finish(&int_array));\n+\n+  DictionaryArray expected(dtype, int_array);\n+  ASSERT_TRUE(expected.Equals(result));\n+}\n+\n+TEST(TestDecimalDictionaryBuilder, DoubleTableSize) {\n+  const auto& decimal_type = arrow::decimal(21, 0);\n+\n+  // Build the dictionary Array\n+  DictionaryBuilder<FixedSizeBinaryType> builder(decimal_type, default_memory_pool());\n+\n+  // Build expected data\n+  FixedSizeBinaryBuilder fsb_builder(decimal_type);\n+  Int16Builder int_builder;\n+\n+  // Fill with 1024 different values\n+  for (int64_t i = 0; i < 1024; i++) {\n+    const uint8_t bytes[] = {0,\n+                             0,\n+                             0,\n+                             0,\n+                             0,\n+                             0,\n+                             0,\n+                             0,\n+                             0,\n+                             0,\n+                             0,\n+                             0,\n+                             12,\n+                             12,\n+                             static_cast<uint8_t>(i / 128),\n+                             static_cast<uint8_t>(i % 128)};\n+    ASSERT_OK(builder.Append(bytes));\n+    ASSERT_OK(fsb_builder.Append(bytes));\n+    ASSERT_OK(int_builder.Append(static_cast<uint16_t>(i)));\n+  }\n+  // Fill with an already existing value\n+  const uint8_t known_value[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 1};\n+  for (int64_t i = 0; i < 1024; i++) {\n+    ASSERT_OK(builder.Append(known_value));\n+    ASSERT_OK(int_builder.Append(1));\n+  }\n+\n+  // Finalize result\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(builder.Finish(&result));\n+\n+  // Finalize expected data\n+  std::shared_ptr<Array> fsb_array;\n+  ASSERT_OK(fsb_builder.Finish(&fsb_array));\n+\n+  auto dtype = std::make_shared<DictionaryType>(int16(), fsb_array);\n+  std::shared_ptr<Array> int_array;\n+  ASSERT_OK(int_builder.Finish(&int_array));\n+\n+  DictionaryArray expected(dtype, int_array);\n+  ASSERT_TRUE(expected.Equals(result));\n+}\n+\n // ----------------------------------------------------------------------\n // List tests\n \ndiff --git a/cpp/src/arrow/builder.cc b/cpp/src/arrow/builder.cc\nindex 4d7fd5ff8..de132b5f6 100644\n--- a/cpp/src/arrow/builder.cc\n+++ b/cpp/src/arrow/builder.cc\n@@ -34,6 +34,7 @@\n #include \"arrow/util/cpu-info.h\"\n #include \"arrow/util/decimal.h\"\n #include \"arrow/util/hash-util.h\"\n+#include \"arrow/util/hash.h\"\n #include \"arrow/util/logging.h\"\n \n namespace arrow {\n@@ -805,6 +806,305 @@ Status BooleanBuilder::Append(const std::vector<bool>& values) {\n   return Status::OK();\n }\n \n+// ----------------------------------------------------------------------\n+// DictionaryBuilder\n+\n+using internal::WrappedBinary;\n+\n+template <typename T>\n+DictionaryBuilder<T>::DictionaryBuilder(const std::shared_ptr<DataType>& type,\n+                                        MemoryPool* pool)\n+    : ArrayBuilder(type, pool),\n+      hash_slots_(nullptr),\n+      dict_builder_(type, pool),\n+      values_builder_(pool),\n+      byte_width_(-1) {\n+  if (!::arrow::CpuInfo::initialized()) {\n+    ::arrow::CpuInfo::Init();\n+  }\n+}\n+\n+DictionaryBuilder<NullType>::DictionaryBuilder(const std::shared_ptr<DataType>& type,\n+                                               MemoryPool* pool)\n+    : ArrayBuilder(type, pool), values_builder_(pool) {\n+  if (!::arrow::CpuInfo::initialized()) {\n+    ::arrow::CpuInfo::Init();\n+  }\n+}\n+\n+DictionaryBuilder<NullType>::~DictionaryBuilder() {}\n+\n+template <>\n+DictionaryBuilder<FixedSizeBinaryType>::DictionaryBuilder(\n+    const std::shared_ptr<DataType>& type, MemoryPool* pool)\n+    : ArrayBuilder(type, pool),\n+      hash_slots_(nullptr),\n+      dict_builder_(type, pool),\n+      values_builder_(pool),\n+      byte_width_(static_cast<const FixedSizeBinaryType&>(*type).byte_width()) {\n+  if (!::arrow::CpuInfo::initialized()) {\n+    ::arrow::CpuInfo::Init();\n+  }\n+}\n+\n+template <typename T>\n+Status DictionaryBuilder<T>::Init(int64_t elements) {\n+  RETURN_NOT_OK(ArrayBuilder::Init(elements));\n+\n+  // Fill the initial hash table\n+  RETURN_NOT_OK(internal::NewHashTable(kInitialHashTableSize, pool_, &hash_table_));\n+  hash_slots_ = reinterpret_cast<int32_t*>(hash_table_->mutable_data());\n+  hash_table_size_ = kInitialHashTableSize;\n+  mod_bitmask_ = kInitialHashTableSize - 1;\n+  hash_table_load_threshold_ =\n+      static_cast<int64_t>(static_cast<double>(elements) * kMaxHashTableLoad);\n+\n+  return values_builder_.Init(elements);\n+}\n+\n+Status DictionaryBuilder<NullType>::Init(int64_t elements) {\n+  RETURN_NOT_OK(ArrayBuilder::Init(elements));\n+  return values_builder_.Init(elements);\n+}\n+\n+template <typename T>\n+Status DictionaryBuilder<T>::Resize(int64_t capacity) {\n+  if (capacity < kMinBuilderCapacity) {\n+    capacity = kMinBuilderCapacity;\n+  }\n+\n+  if (capacity_ == 0) {\n+    return Init(capacity);\n+  } else {\n+    return ArrayBuilder::Resize(capacity);\n+  }\n+}\n+\n+Status DictionaryBuilder<NullType>::Resize(int64_t capacity) {\n+  if (capacity < kMinBuilderCapacity) {\n+    capacity = kMinBuilderCapacity;\n+  }\n+\n+  if (capacity_ == 0) {\n+    return Init(capacity);\n+  } else {\n+    return ArrayBuilder::Resize(capacity);\n+  }\n+}\n+\n+template <typename T>\n+Status DictionaryBuilder<T>::FinishInternal(std::shared_ptr<ArrayData>* out) {\n+  std::shared_ptr<Array> dictionary;\n+  RETURN_NOT_OK(dict_builder_.Finish(&dictionary));\n+\n+  RETURN_NOT_OK(values_builder_.FinishInternal(out));\n+  (*out)->type = std::make_shared<DictionaryType>((*out)->type, dictionary);\n+  return Status::OK();\n+}\n+\n+Status DictionaryBuilder<NullType>::FinishInternal(std::shared_ptr<ArrayData>* out) {\n+  std::shared_ptr<Array> dictionary = std::make_shared<NullArray>(0);\n+\n+  RETURN_NOT_OK(values_builder_.FinishInternal(out));\n+  (*out)->type = std::make_shared<DictionaryType>((*out)->type, dictionary);\n+  return Status::OK();\n+}\n+\n+template <typename T>\n+Status DictionaryBuilder<T>::Append(const Scalar& value) {\n+  RETURN_NOT_OK(Reserve(1));\n+  // Based on DictEncoder<DType>::Put\n+  int64_t j = HashValue(value) & mod_bitmask_;\n+  hash_slot_t index = hash_slots_[j];\n+\n+  // Find an empty slot\n+  while (kHashSlotEmpty != index && SlotDifferent(index, value)) {\n+    // Linear probing\n+    ++j;\n+    if (j == hash_table_size_) {\n+      j = 0;\n+    }\n+    index = hash_slots_[j];\n+  }\n+\n+  if (index == kHashSlotEmpty) {\n+    // Not in the hash table, so we insert it now\n+    index = static_cast<hash_slot_t>(dict_builder_.length());\n+    hash_slots_[j] = index;\n+    RETURN_NOT_OK(AppendDictionary(value));\n+\n+    if (ARROW_PREDICT_FALSE(static_cast<int32_t>(dict_builder_.length()) >\n+                            hash_table_load_threshold_)) {\n+      RETURN_NOT_OK(DoubleTableSize());\n+    }\n+  }\n+\n+  RETURN_NOT_OK(values_builder_.Append(index));\n+\n+  return Status::OK();\n+}\n+\n+template <typename T>\n+Status DictionaryBuilder<T>::AppendArray(const Array& array) {\n+  const auto& numeric_array = static_cast<const NumericArray<T>&>(array);\n+  for (int64_t i = 0; i < array.length(); i++) {\n+    if (array.IsNull(i)) {\n+      RETURN_NOT_OK(AppendNull());\n+    } else {\n+      RETURN_NOT_OK(Append(numeric_array.Value(i)));\n+    }\n+  }\n+  return Status::OK();\n+}\n+\n+Status DictionaryBuilder<NullType>::AppendArray(const Array& array) {\n+  for (int64_t i = 0; i < array.length(); i++) {\n+    RETURN_NOT_OK(AppendNull());\n+  }\n+  return Status::OK();\n+}\n+\n+template <>\n+Status DictionaryBuilder<FixedSizeBinaryType>::AppendArray(const Array& array) {\n+  if (!type_->Equals(*array.type())) {\n+    return Status::Invalid(\"Cannot append FixedSizeBinary array with non-matching type\");\n+  }\n+\n+  const auto& numeric_array = static_cast<const FixedSizeBinaryArray&>(array);\n+  for (int64_t i = 0; i < array.length(); i++) {\n+    if (array.IsNull(i)) {\n+      RETURN_NOT_OK(AppendNull());\n+    } else {\n+      RETURN_NOT_OK(Append(numeric_array.Value(i)));\n+    }\n+  }\n+  return Status::OK();\n+}\n+\n+template <typename T>\n+Status DictionaryBuilder<T>::AppendNull() {\n+  return values_builder_.AppendNull();\n+}\n+\n+Status DictionaryBuilder<NullType>::AppendNull() { return values_builder_.AppendNull(); }\n+\n+template <typename T>\n+Status DictionaryBuilder<T>::DoubleTableSize() {\n+#define INNER_LOOP                                                \\\n+  Scalar value = GetDictionaryValue(static_cast<int64_t>(index)); \\\n+  int64_t j = HashValue(value) & new_mod_bitmask;\n+\n+  DOUBLE_TABLE_SIZE(, INNER_LOOP);\n+\n+  return Status::OK();\n+}\n+\n+template <typename T>\n+typename DictionaryBuilder<T>::Scalar DictionaryBuilder<T>::GetDictionaryValue(\n+    int64_t index) {\n+  const Scalar* data = reinterpret_cast<const Scalar*>(dict_builder_.data()->data());\n+  return data[index];\n+}\n+\n+template <>\n+const uint8_t* DictionaryBuilder<FixedSizeBinaryType>::GetDictionaryValue(int64_t index) {\n+  return dict_builder_.GetValue(index);\n+}\n+\n+template <typename T>\n+int64_t DictionaryBuilder<T>::HashValue(const Scalar& value) {\n+  return HashUtil::Hash(&value, sizeof(Scalar), 0);\n+}\n+\n+template <>\n+int64_t DictionaryBuilder<FixedSizeBinaryType>::HashValue(const Scalar& value) {\n+  return HashUtil::Hash(value, byte_width_, 0);\n+}\n+\n+template <typename T>\n+bool DictionaryBuilder<T>::SlotDifferent(hash_slot_t index, const Scalar& value) {\n+  const Scalar other = GetDictionaryValue(static_cast<int64_t>(index));\n+  return other != value;\n+}\n+\n+template <>\n+bool DictionaryBuilder<FixedSizeBinaryType>::SlotDifferent(hash_slot_t index,\n+                                                           const Scalar& value) {\n+  int32_t width = static_cast<const FixedSizeBinaryType&>(*type_).byte_width();\n+  const Scalar other = GetDictionaryValue(static_cast<int64_t>(index));\n+  return memcmp(other, value, width) != 0;\n+}\n+\n+template <typename T>\n+Status DictionaryBuilder<T>::AppendDictionary(const Scalar& value) {\n+  return dict_builder_.Append(value);\n+}\n+\n+#define BINARY_DICTIONARY_SPECIALIZATIONS(Type)                                     \\\n+  template <>                                                                       \\\n+  WrappedBinary DictionaryBuilder<Type>::GetDictionaryValue(int64_t index) {        \\\n+    int32_t v_len;                                                                  \\\n+    const uint8_t* v = dict_builder_.GetValue(static_cast<int64_t>(index), &v_len); \\\n+    return WrappedBinary(v, v_len);                                                 \\\n+  }                                                                                 \\\n+                                                                                    \\\n+  template <>                                                                       \\\n+  Status DictionaryBuilder<Type>::AppendDictionary(const WrappedBinary& value) {    \\\n+    return dict_builder_.Append(value.ptr_, value.length_);                         \\\n+  }                                                                                 \\\n+                                                                                    \\\n+  template <>                                                                       \\\n+  Status DictionaryBuilder<Type>::AppendArray(const Array& array) {                 \\\n+    const BinaryArray& binary_array = static_cast<const BinaryArray&>(array);       \\\n+    WrappedBinary value(nullptr, 0);                                                \\\n+    for (int64_t i = 0; i < array.length(); i++) {                                  \\\n+      if (array.IsNull(i)) {                                                        \\\n+        RETURN_NOT_OK(AppendNull());                                                \\\n+      } else {                                                                      \\\n+        value.ptr_ = binary_array.GetValue(i, &value.length_);                      \\\n+        RETURN_NOT_OK(Append(value));                                               \\\n+      }                                                                             \\\n+    }                                                                               \\\n+    return Status::OK();                                                            \\\n+  }                                                                                 \\\n+                                                                                    \\\n+  template <>                                                                       \\\n+  int64_t DictionaryBuilder<Type>::HashValue(const WrappedBinary& value) {          \\\n+    return HashUtil::Hash(value.ptr_, value.length_, 0);                            \\\n+  }                                                                                 \\\n+                                                                                    \\\n+  template <>                                                                       \\\n+  bool DictionaryBuilder<Type>::SlotDifferent(hash_slot_t index,                    \\\n+                                              const WrappedBinary& value) {         \\\n+    int32_t other_length;                                                           \\\n+    const uint8_t* other_value =                                                    \\\n+        dict_builder_.GetValue(static_cast<int64_t>(index), &other_length);         \\\n+    return !(other_length == value.length_ &&                                       \\\n+             0 == memcmp(other_value, value.ptr_, value.length_));                  \\\n+  }\n+\n+BINARY_DICTIONARY_SPECIALIZATIONS(StringType);\n+BINARY_DICTIONARY_SPECIALIZATIONS(BinaryType);\n+\n+template class DictionaryBuilder<UInt8Type>;\n+template class DictionaryBuilder<UInt16Type>;\n+template class DictionaryBuilder<UInt32Type>;\n+template class DictionaryBuilder<UInt64Type>;\n+template class DictionaryBuilder<Int8Type>;\n+template class DictionaryBuilder<Int16Type>;\n+template class DictionaryBuilder<Int32Type>;\n+template class DictionaryBuilder<Int64Type>;\n+template class DictionaryBuilder<Date32Type>;\n+template class DictionaryBuilder<Date64Type>;\n+template class DictionaryBuilder<Time32Type>;\n+template class DictionaryBuilder<Time64Type>;\n+template class DictionaryBuilder<TimestampType>;\n+template class DictionaryBuilder<FloatType>;\n+template class DictionaryBuilder<DoubleType>;\n+template class DictionaryBuilder<FixedSizeBinaryType>;\n+template class DictionaryBuilder<BinaryType>;\n+template class DictionaryBuilder<StringType>;\n+\n // ----------------------------------------------------------------------\n // Decimal128Builder\n \ndiff --git a/cpp/src/arrow/builder.h b/cpp/src/arrow/builder.h\nindex e59e16658..ce7b8cd19 100644\n--- a/cpp/src/arrow/builder.h\n+++ b/cpp/src/arrow/builder.h\n@@ -32,6 +32,7 @@\n #include \"arrow/type.h\"\n #include \"arrow/type_traits.h\"\n #include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/hash.h\"\n #include \"arrow/util/macros.h\"\n #include \"arrow/util/visibility.h\"\n \n@@ -809,6 +810,158 @@ class ARROW_EXPORT StructBuilder : public ArrayBuilder {\n   std::vector<std::unique_ptr<ArrayBuilder>> field_builders_;\n };\n \n+// ----------------------------------------------------------------------\n+// Dictionary builder\n+\n+namespace internal {\n+\n+// TODO(ARROW-1176): Use Tensorflow's StringPiece instead of this here.\n+struct WrappedBinary {\n+  WrappedBinary(const uint8_t* ptr, int32_t length) : ptr_(ptr), length_(length) {}\n+\n+  const uint8_t* ptr_;\n+  int32_t length_;\n+};\n+\n+template <typename T>\n+struct DictionaryScalar {\n+  using type = typename T::c_type;\n+};\n+\n+template <>\n+struct DictionaryScalar<BinaryType> {\n+  using type = WrappedBinary;\n+};\n+\n+template <>\n+struct DictionaryScalar<StringType> {\n+  using type = WrappedBinary;\n+};\n+\n+template <>\n+struct DictionaryScalar<FixedSizeBinaryType> {\n+  using type = uint8_t const*;\n+};\n+\n+}  // namespace internal\n+\n+/// \\brief Array builder for created encoded DictionaryArray from dense array\n+/// data\n+template <typename T>\n+class ARROW_EXPORT DictionaryBuilder : public ArrayBuilder {\n+ public:\n+  using Scalar = typename internal::DictionaryScalar<T>::type;\n+\n+  ~DictionaryBuilder() {}\n+\n+  DictionaryBuilder(const std::shared_ptr<DataType>& type, MemoryPool* pool);\n+\n+  template <typename T1 = T>\n+  explicit DictionaryBuilder(\n+      typename std::enable_if<TypeTraits<T1>::is_parameter_free, MemoryPool*>::type pool)\n+      : DictionaryBuilder<T1>(TypeTraits<T1>::type_singleton(), pool) {}\n+\n+  /// \\brief Append a scalar value\n+  Status Append(const Scalar& value);\n+\n+  /// \\brief Append a scalar null value\n+  Status AppendNull();\n+\n+  /// \\brief Append a whole dense array to the builder\n+  Status AppendArray(const Array& array);\n+\n+  Status Init(int64_t elements) override;\n+  Status Resize(int64_t capacity) override;\n+  Status FinishInternal(std::shared_ptr<ArrayData>* out) override;\n+\n+ protected:\n+  Status DoubleTableSize();\n+  Scalar GetDictionaryValue(int64_t index);\n+  int64_t HashValue(const Scalar& value);\n+  bool SlotDifferent(hash_slot_t slot, const Scalar& value);\n+  Status AppendDictionary(const Scalar& value);\n+\n+  std::shared_ptr<Buffer> hash_table_;\n+  int32_t* hash_slots_;\n+\n+  /// Size of the table. Must be a power of 2.\n+  int64_t hash_table_size_;\n+\n+  // Store hash_table_size_ - 1, so that j & mod_bitmask_ is equivalent to j %\n+  // hash_table_size_, but uses far fewer CPU cycles\n+  int64_t mod_bitmask_;\n+\n+  typename TypeTraits<T>::BuilderType dict_builder_;\n+  AdaptiveIntBuilder values_builder_;\n+  int32_t byte_width_;\n+\n+  /// Size at which we decide to resize\n+  int64_t hash_table_load_threshold_;\n+};\n+\n+template <>\n+class ARROW_EXPORT DictionaryBuilder<NullType> : public ArrayBuilder {\n+ public:\n+  ~DictionaryBuilder();\n+\n+  DictionaryBuilder(const std::shared_ptr<DataType>& type, MemoryPool* pool);\n+  explicit DictionaryBuilder(MemoryPool* pool);\n+\n+  /// \\brief Append a scalar null value\n+  Status AppendNull();\n+\n+  /// \\brief Append a whole dense array to the builder\n+  Status AppendArray(const Array& array);\n+\n+  Status Init(int64_t elements) override;\n+  Status Resize(int64_t capacity) override;\n+  Status FinishInternal(std::shared_ptr<ArrayData>* out) override;\n+\n+ protected:\n+  AdaptiveIntBuilder values_builder_;\n+};\n+\n+class ARROW_EXPORT BinaryDictionaryBuilder : public DictionaryBuilder<BinaryType> {\n+ public:\n+  using DictionaryBuilder::Append;\n+  using DictionaryBuilder::DictionaryBuilder;\n+\n+  Status Append(const uint8_t* value, int32_t length) {\n+    return Append(internal::WrappedBinary(value, length));\n+  }\n+\n+  Status Append(const char* value, int32_t length) {\n+    return Append(\n+        internal::WrappedBinary(reinterpret_cast<const uint8_t*>(value), length));\n+  }\n+\n+  Status Append(const std::string& value) {\n+    return Append(internal::WrappedBinary(reinterpret_cast<const uint8_t*>(value.c_str()),\n+                                          static_cast<int32_t>(value.size())));\n+  }\n+};\n+\n+/// \\brief Dictionary array builder with convenience methods for strings\n+class ARROW_EXPORT StringDictionaryBuilder : public DictionaryBuilder<StringType> {\n+ public:\n+  using DictionaryBuilder::Append;\n+  using DictionaryBuilder::DictionaryBuilder;\n+\n+  Status Append(const uint8_t* value, int32_t length) {\n+    return Append(internal::WrappedBinary(value, length));\n+  }\n+\n+  Status Append(const char* value, int32_t length) {\n+    return Append(\n+        internal::WrappedBinary(reinterpret_cast<const uint8_t*>(value), length));\n+  }\n+\n+  Status Append(const std::string& value) {\n+    return Append(internal::WrappedBinary(reinterpret_cast<const uint8_t*>(value.c_str()),\n+                                          static_cast<int32_t>(value.size())));\n+  }\n+};\n+\n // ----------------------------------------------------------------------\n // Helper functions\n \ndiff --git a/cpp/src/arrow/compute/kernels/hash.cc b/cpp/src/arrow/compute/kernels/hash.cc\nindex 750f1d36a..1face78bd 100644\n--- a/cpp/src/arrow/compute/kernels/hash.cc\n+++ b/cpp/src/arrow/compute/kernels/hash.cc\n@@ -30,21 +30,13 @@\n #include \"arrow/compute/kernel.h\"\n #include \"arrow/compute/kernels/util-internal.h\"\n #include \"arrow/util/hash-util.h\"\n+#include \"arrow/util/hash.h\"\n \n namespace arrow {\n namespace compute {\n \n namespace {\n \n-// Initially 1024 elements\n-static constexpr int64_t kInitialHashTableSize = 1 << 10;\n-\n-typedef int32_t hash_slot_t;\n-static constexpr hash_slot_t kHashSlotEmpty = std::numeric_limits<int32_t>::max();\n-\n-// The maximum load factor for the hash table before resizing.\n-static constexpr double kMaxHashTableLoad = 0.5;\n-\n enum class SIMDMode : char { NOSIMD, SSE4, AVX2 };\n \n #define CHECK_IMPLEMENTED(KERNEL, FUNCNAME, TYPE)                  \\\n@@ -54,17 +46,6 @@ enum class SIMDMode : char { NOSIMD, SSE4, AVX2 };\n     return Status::NotImplemented(ss.str());                       \\\n   }\n \n-Status NewHashTable(int64_t size, MemoryPool* pool, std::shared_ptr<Buffer>* out) {\n-  auto hash_table = std::make_shared<PoolBuffer>(pool);\n-\n-  RETURN_NOT_OK(hash_table->Resize(sizeof(hash_slot_t) * size));\n-  int32_t* slots = reinterpret_cast<hash_slot_t*>(hash_table->mutable_data());\n-  std::fill(slots, slots + size, kHashSlotEmpty);\n-\n-  *out = hash_table;\n-  return Status::OK();\n-}\n-\n // This is a slight design concession -- some hash actions have the possibility\n // of failure. Rather than introduce extra error checking into all actions, we\n // will raise an internal exception so that only the actions where errors can\n@@ -129,7 +110,7 @@ class HashTable {\n \n Status HashTable::Init(int64_t elements) {\n   DCHECK_EQ(elements, BitUtil::NextPower2(elements));\n-  RETURN_NOT_OK(NewHashTable(elements, pool_, &hash_table_));\n+  RETURN_NOT_OK(internal::NewHashTable(elements, pool_, &hash_table_));\n   hash_slots_ = reinterpret_cast<hash_slot_t*>(hash_table_->mutable_data());\n   hash_table_size_ = elements;\n   hash_table_load_threshold_ =\n@@ -238,44 +219,6 @@ struct HashDictionary<Type, enable_if_has_c_type<Type>> {\n     }                                                                                    \\\n   }\n \n-#define DOUBLE_TABLE_SIZE(SETUP_CODE, COMPUTE_HASH)                              \\\n-  do {                                                                           \\\n-    int64_t new_size = hash_table_size_ * 2;                                     \\\n-                                                                                 \\\n-    std::shared_ptr<Buffer> new_hash_table;                                      \\\n-    RETURN_NOT_OK(NewHashTable(new_size, pool_, &new_hash_table));               \\\n-    int32_t* new_hash_slots =                                                    \\\n-        reinterpret_cast<hash_slot_t*>(new_hash_table->mutable_data());          \\\n-    int64_t new_mod_bitmask = new_size - 1;                                      \\\n-                                                                                 \\\n-    SETUP_CODE;                                                                  \\\n-                                                                                 \\\n-    for (int i = 0; i < hash_table_size_; ++i) {                                 \\\n-      hash_slot_t index = hash_slots_[i];                                        \\\n-                                                                                 \\\n-      if (index == kHashSlotEmpty) {                                             \\\n-        continue;                                                                \\\n-      }                                                                          \\\n-                                                                                 \\\n-      COMPUTE_HASH;                                                              \\\n-      while (kHashSlotEmpty != new_hash_slots[j]) {                              \\\n-        ++j;                                                                     \\\n-        if (ARROW_PREDICT_FALSE(j == new_size)) {                                \\\n-          j = 0;                                                                 \\\n-        }                                                                        \\\n-      }                                                                          \\\n-                                                                                 \\\n-      new_hash_slots[j] = index;                                                 \\\n-    }                                                                            \\\n-                                                                                 \\\n-    hash_table_ = new_hash_table;                                                \\\n-    hash_slots_ = reinterpret_cast<hash_slot_t*>(hash_table_->mutable_data());   \\\n-    hash_table_size_ = new_size;                                                 \\\n-    hash_table_load_threshold_ =                                                 \\\n-        static_cast<int64_t>(static_cast<double>(new_size) * kMaxHashTableLoad); \\\n-    mod_bitmask_ = new_size - 1;                                                 \\\n-  } while (false)\n-\n template <typename Type, typename Action>\n class HashTableKernel<Type, Action, enable_if_has_c_type<Type>> : public HashTable {\n  public:\ndiff --git a/cpp/src/arrow/util/CMakeLists.txt b/cpp/src/arrow/util/CMakeLists.txt\nindex 29b18a935..42613d6a5 100644\n--- a/cpp/src/arrow/util/CMakeLists.txt\n+++ b/cpp/src/arrow/util/CMakeLists.txt\n@@ -34,6 +34,7 @@ install(FILES\n   cpu-info.h\n   decimal.h\n   hash-util.h\n+  hash.h\n   key_value_metadata.h\n   logging.h\n   macros.h\ndiff --git a/cpp/src/arrow/util/hash.cc b/cpp/src/arrow/util/hash.cc\nnew file mode 100644\nindex 000000000..94ba52456\n--- /dev/null\n+++ b/cpp/src/arrow/util/hash.cc\n@@ -0,0 +1,38 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/util/hash.h\"\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/status.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+Status NewHashTable(int64_t size, MemoryPool* pool, std::shared_ptr<Buffer>* out) {\n+  auto hash_table = std::make_shared<PoolBuffer>(pool);\n+\n+  RETURN_NOT_OK(hash_table->Resize(sizeof(hash_slot_t) * size));\n+  int32_t* slots = reinterpret_cast<hash_slot_t*>(hash_table->mutable_data());\n+  std::fill(slots, slots + size, kHashSlotEmpty);\n+\n+  *out = hash_table;\n+  return Status::OK();\n+}\n+\n+}  // namespace internal\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/util/hash.h b/cpp/src/arrow/util/hash.h\nnew file mode 100644\nindex 000000000..359734271\n--- /dev/null\n+++ b/cpp/src/arrow/util/hash.h\n@@ -0,0 +1,85 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_UTIL_HASH_H\n+#define ARROW_UTIL_HASH_H\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+\n+namespace arrow {\n+\n+class Buffer;\n+class MemoryPool;\n+class Status;\n+\n+typedef int32_t hash_slot_t;\n+static constexpr hash_slot_t kHashSlotEmpty = std::numeric_limits<int32_t>::max();\n+\n+// Initially 1024 elements\n+static constexpr int kInitialHashTableSize = 1 << 10;\n+\n+// The maximum load factor for the hash table before resizing.\n+static constexpr double kMaxHashTableLoad = 0.5;\n+\n+namespace internal {\n+\n+#define DOUBLE_TABLE_SIZE(SETUP_CODE, COMPUTE_HASH)                              \\\n+  do {                                                                           \\\n+    int64_t new_size = hash_table_size_ * 2;                                     \\\n+                                                                                 \\\n+    std::shared_ptr<Buffer> new_hash_table;                                      \\\n+    RETURN_NOT_OK(internal::NewHashTable(new_size, pool_, &new_hash_table));     \\\n+    int32_t* new_hash_slots =                                                    \\\n+        reinterpret_cast<hash_slot_t*>(new_hash_table->mutable_data());          \\\n+    int64_t new_mod_bitmask = new_size - 1;                                      \\\n+                                                                                 \\\n+    SETUP_CODE;                                                                  \\\n+                                                                                 \\\n+    for (int i = 0; i < hash_table_size_; ++i) {                                 \\\n+      hash_slot_t index = hash_slots_[i];                                        \\\n+                                                                                 \\\n+      if (index == kHashSlotEmpty) {                                             \\\n+        continue;                                                                \\\n+      }                                                                          \\\n+                                                                                 \\\n+      COMPUTE_HASH;                                                              \\\n+      while (kHashSlotEmpty != new_hash_slots[j]) {                              \\\n+        ++j;                                                                     \\\n+        if (ARROW_PREDICT_FALSE(j == new_size)) {                                \\\n+          j = 0;                                                                 \\\n+        }                                                                        \\\n+      }                                                                          \\\n+                                                                                 \\\n+      new_hash_slots[j] = index;                                                 \\\n+    }                                                                            \\\n+                                                                                 \\\n+    hash_table_ = new_hash_table;                                                \\\n+    hash_slots_ = reinterpret_cast<hash_slot_t*>(hash_table_->mutable_data());   \\\n+    hash_table_size_ = new_size;                                                 \\\n+    hash_table_load_threshold_ =                                                 \\\n+        static_cast<int64_t>(static_cast<double>(new_size) * kMaxHashTableLoad); \\\n+    mod_bitmask_ = new_size - 1;                                                 \\\n+  } while (false)\n+\n+Status NewHashTable(int64_t size, MemoryPool* pool, std::shared_ptr<Buffer>* out);\n+\n+}  // namespace internal\n+}  // namespace arrow\n+\n+#endif  // ARROW_UTIL_HASH_H\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-12-06T03:02:58.618+0000",
                    "updated": "2017-12-06T03:02:58.618+0000"
                }
            ],
            "maxResults": 8,
            "total": 8,
            "startAt": 0
        },
        "customfield_12311820": "0|i3nhpr:",
        "customfield_12314139": null
    }
}