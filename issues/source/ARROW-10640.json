{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13341287",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287",
    "key": "ARROW-10640",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349983",
                "id": "12349983",
                "description": "",
                "name": "5.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-07-28"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12616699",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12616699",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "outwardIssue": {
                    "id": "13381940",
                    "key": "ARROW-12955",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381940",
                    "fields": {
                        "summary": "[C++] Add additional type support for if_else kernel",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12616796",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12616796",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "outwardIssue": {
                    "id": "13382193",
                    "key": "ARROW-12975",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382193",
                    "fields": {
                        "summary": "[C++][Python] if_else kernel doesn't support upcasting ",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12618504",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12618504",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13386828",
                    "key": "ARROW-13220",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13386828",
                    "fields": {
                        "summary": "[C++] Add a 'choose' kernel/scalar compute function",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12606017",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12606017",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13348043",
                    "key": "ARROW-11044",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13348043",
                    "fields": {
                        "summary": "[C++] Add \"replace\" kernel",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12617144",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12617144",
                "type": {
                    "id": "12310051",
                    "name": "Supercedes",
                    "inward": "is superceded by",
                    "outward": "supercedes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310051"
                },
                "outwardIssue": {
                    "id": "13348043",
                    "key": "ARROW-11044",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13348043",
                    "fields": {
                        "summary": "[C++] Add \"replace\" kernel",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12616722",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12616722",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "inwardIssue": {
                    "id": "13382008",
                    "key": "ARROW-12964",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382008",
                    "fields": {
                        "summary": "[R] Add bindings for ifelse() and if_else()",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=niranda",
            "name": "niranda",
            "key": "niranda",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=39936",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=39936",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=39936",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=39936"
            },
            "displayName": "Niranda Perera",
            "active": true,
            "timeZone": "America/Indiana/Indianapolis"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
            "name": "jorisvandenbossche",
            "key": "jorisvandenbossche",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Joris Van den Bossche",
            "active": true,
            "timeZone": "Europe/Brussels"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
            "name": "jorisvandenbossche",
            "key": "jorisvandenbossche",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Joris Van den Bossche",
            "active": true,
            "timeZone": "Europe/Brussels"
        },
        "aggregateprogress": {
            "progress": 38400,
            "total": 38400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 38400,
            "total": 38400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10640/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 64,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/600660",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera opened a new pull request #10377:\nURL: https://github.com/apache/arrow/pull/10377\n\n\n   Adding a preliminary impl for an `if_else(cond: Datum, left: Datum, right: Datum)` function. It works as follows,\r\n   ```python\r\n   def if_else(cond, left, right):\r\n       for c, true_val, false_val in zip(cond, left, right):\r\n           if c:\r\n               yield true_val\r\n           else:\r\n               yield false_val\r\n   ```\r\n   `null` values will be promoted to the output. \r\n   \r\n   Current commit only provides only Array-Array-Array kernels for the function. \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-21T21:46:08.136+0000",
                    "updated": "2021-05-21T21:46:08.136+0000",
                    "started": "2021-05-21T21:46:08.136+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "600660",
                    "issueId": "13341287"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/600661",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10377:\nURL: https://github.com/apache/arrow/pull/10377#issuecomment-846278900\n\n\n   https://issues.apache.org/jira/browse/ARROW-10640\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-21T21:46:36.631+0000",
                    "updated": "2021-05-21T21:46:36.631+0000",
                    "started": "2021-05-21T21:46:36.631+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "600661",
                    "issueId": "13341287"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/600679",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10377:\nURL: https://github.com/apache/arrow/pull/10377#discussion_r637268115\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,285 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// nulls will be promoted as follows\n+// cond.val && (cond.data && left.val || ~cond.data && right.val)\n+Status promote_nulls(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* output) {\n+  if (!cond.MayHaveNulls() && !left.MayHaveNulls() && !right.MayHaveNulls()) {\n+    return Status::OK();  // no nulls to handle\n+  }\n+  const int64_t len = cond.length;\n+\n+  ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_validity, ctx->AllocateBitmap(len));\n+  arrow::internal::InvertBitmap(out_validity->data(), 0, len,\n+                                out_validity->mutable_data(), 0);\n+  if (right.MayHaveNulls()) {\n+    // out_validity = right.val && ~cond.data\n+    arrow::internal::BitmapAndNot(right.buffers[0]->data(), right.offset,\n+                                  cond.buffers[1]->data(), cond.offset, len, 0,\n+                                  out_validity->mutable_data());\n+  }\n+\n+  if (left.MayHaveNulls()) {\n+    // tmp_buf = left.val && cond.data\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> temp_buf,\n+                          arrow::internal::BitmapAnd(\n+                              ctx->memory_pool(), left.buffers[0]->data(), left.offset,\n+                              cond.buffers[1]->data(), cond.offset, len, 0));\n+    // out_validity = cond.data && left.val || ~cond.data && right.val\n+    arrow::internal::BitmapOr(out_validity->data(), 0, temp_buf->data(), 0, len, 0,\n+                              out_validity->mutable_data());\n+  }\n+\n+  if (cond.MayHaveNulls()) {\n+    // out_validity &= cond.val\n+    ::arrow::internal::BitmapAnd(out_validity->data(), 0, cond.buffers[0]->data(),\n+                                 cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  output->buffers[0] = std::move(out_validity);\n+  output->GetNullCount();  // update null count\n+  return Status::OK();\n+}\n+\n+template <typename Type, bool swap = false, typename Enable = void>\n\nReview comment:\n       What is `swap` doing? \n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,285 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// nulls will be promoted as follows\n+// cond.val && (cond.data && left.val || ~cond.data && right.val)\n+Status promote_nulls(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n\nReview comment:\n       nit: use CamelCase (`PromoteNulls`)\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,285 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// nulls will be promoted as follows\n+// cond.val && (cond.data && left.val || ~cond.data && right.val)\n+Status promote_nulls(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* output) {\n+  if (!cond.MayHaveNulls() && !left.MayHaveNulls() && !right.MayHaveNulls()) {\n+    return Status::OK();  // no nulls to handle\n+  }\n+  const int64_t len = cond.length;\n+\n+  ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_validity, ctx->AllocateBitmap(len));\n+  arrow::internal::InvertBitmap(out_validity->data(), 0, len,\n+                                out_validity->mutable_data(), 0);\n+  if (right.MayHaveNulls()) {\n+    // out_validity = right.val && ~cond.data\n+    arrow::internal::BitmapAndNot(right.buffers[0]->data(), right.offset,\n+                                  cond.buffers[1]->data(), cond.offset, len, 0,\n+                                  out_validity->mutable_data());\n+  }\n+\n+  if (left.MayHaveNulls()) {\n+    // tmp_buf = left.val && cond.data\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> temp_buf,\n+                          arrow::internal::BitmapAnd(\n+                              ctx->memory_pool(), left.buffers[0]->data(), left.offset,\n+                              cond.buffers[1]->data(), cond.offset, len, 0));\n+    // out_validity = cond.data && left.val || ~cond.data && right.val\n+    arrow::internal::BitmapOr(out_validity->data(), 0, temp_buf->data(), 0, len, 0,\n+                              out_validity->mutable_data());\n+  }\n+\n+  if (cond.MayHaveNulls()) {\n+    // out_validity &= cond.val\n+    ::arrow::internal::BitmapAnd(out_validity->data(), 0, cond.buffers[0]->data(),\n+                                 cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  output->buffers[0] = std::move(out_validity);\n+  output->GetNullCount();  // update null count\n+  return Status::OK();\n+}\n+\n+template <typename Type, bool swap = false, typename Enable = void>\n+struct IfElseFunctor {};\n+\n+template <typename Type, bool swap>\n+struct IfElseFunctor<Type, swap, enable_if_t<is_number_type<Type>::value>> {\n+  using T = typename TypeTraits<Type>::CType;\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(promote_nulls(ctx, cond, left, right, out));\n+\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          ctx->Allocate(cond.length * sizeof(T)));\n+    T* out_values = reinterpret_cast<T*>(out_buf->mutable_data());\n+\n+    // copy right data to out_buff\n+    const T* right_data = right.GetValues<T>(1);\n+    std::memcpy(out_values, right_data, right.length * sizeof(T));\n+\n+    const auto* cond_data = cond.buffers[1]->data();  // this is a BoolArray\n+    BitBlockCounter bit_counter(cond_data, cond.offset, cond.length);\n+\n+    // selectively copy values from left data\n+    const T* left_data = left.GetValues<T>(1);\n+    int64_t offset = cond.offset;\n+\n+    // todo this can be improved by intrinsics. ex: _mm*_mask_store_e* (vmovdqa*)\n+    while (offset < cond.offset + cond.length) {\n+      const BitBlockCount& block = bit_counter.NextWord();\n+      if (block.AllSet()) {  // all from left\n+        std::memcpy(out_values, left_data, block.length * sizeof(T));\n+      } else if (block.popcount) {  // selectively copy from left\n+        for (int64_t i = 0; i < block.length; ++i) {\n+          if (BitUtil::GetBit(cond_data, offset + i)) {\n+            out_values[i] = left_data[i];\n+          }\n+        }\n+      }\n+\n+      offset += block.length;\n+      out_values += block.length;\n+      left_data += block.length;\n+    }\n+\n+    out->buffers[1] = std::move(out_buf);\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const Scalar& right, ArrayData* out) {\n+    // todo impl\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const Scalar& cond, const Scalar& left,\n+                     const Scalar& right, Scalar* out) {\n+    // todo impl\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type, bool swap>\n+struct IfElseFunctor<Type, swap, enable_if_t<is_boolean_type<Type>::value>> {\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(promote_nulls(ctx, cond, left, right, out));\n+\n+    // out_buff = right & ~cond\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          arrow::internal::BitmapAndNot(\n+                              ctx->memory_pool(), right.buffers[1]->data(), right.offset,\n+                              cond.buffers[1]->data(), cond.offset, cond.length, 0));\n+\n+    // out_buff = left & cond\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> temp_buf,\n+                          arrow::internal::BitmapAnd(\n+                              ctx->memory_pool(), left.buffers[1]->data(), left.offset,\n+                              cond.buffers[1]->data(), cond.offset, cond.length, 0));\n+\n+    arrow::internal::BitmapOr(out_buf->data(), 0, temp_buf->data(), 0, cond.length, 0,\n+                              out_buf->mutable_data());\n+    out->buffers[1] = std::move(out_buf);\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const Scalar& right, ArrayData* out) {\n+    // todo impl\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const Scalar& cond, const Scalar& left,\n+                     const Scalar& right, Scalar* out) {\n+    // todo impl\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type, bool swap>\n+struct IfElseFunctor<Type, swap, enable_if_t<is_null_type<Type>::value>> {\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    // Nothing preallocated, so we assign left into the output\n+    *out = left;\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const Scalar& right, ArrayData* out) {\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const Scalar& cond, const Scalar& left,\n+                     const Scalar& right, Scalar* out) {\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct ResolveExec {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    if (batch.length == 0) return Status::OK();\n\nReview comment:\n       Do you really need to check for this? You can assume you have three arguments.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,285 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// nulls will be promoted as follows\n+// cond.val && (cond.data && left.val || ~cond.data && right.val)\n+Status promote_nulls(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* output) {\n+  if (!cond.MayHaveNulls() && !left.MayHaveNulls() && !right.MayHaveNulls()) {\n+    return Status::OK();  // no nulls to handle\n+  }\n+  const int64_t len = cond.length;\n+\n+  ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_validity, ctx->AllocateBitmap(len));\n+  arrow::internal::InvertBitmap(out_validity->data(), 0, len,\n+                                out_validity->mutable_data(), 0);\n+  if (right.MayHaveNulls()) {\n+    // out_validity = right.val && ~cond.data\n+    arrow::internal::BitmapAndNot(right.buffers[0]->data(), right.offset,\n+                                  cond.buffers[1]->data(), cond.offset, len, 0,\n+                                  out_validity->mutable_data());\n+  }\n+\n+  if (left.MayHaveNulls()) {\n+    // tmp_buf = left.val && cond.data\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> temp_buf,\n+                          arrow::internal::BitmapAnd(\n+                              ctx->memory_pool(), left.buffers[0]->data(), left.offset,\n+                              cond.buffers[1]->data(), cond.offset, len, 0));\n+    // out_validity = cond.data && left.val || ~cond.data && right.val\n+    arrow::internal::BitmapOr(out_validity->data(), 0, temp_buf->data(), 0, len, 0,\n+                              out_validity->mutable_data());\n+  }\n+\n+  if (cond.MayHaveNulls()) {\n+    // out_validity &= cond.val\n+    ::arrow::internal::BitmapAnd(out_validity->data(), 0, cond.buffers[0]->data(),\n+                                 cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  output->buffers[0] = std::move(out_validity);\n+  output->GetNullCount();  // update null count\n+  return Status::OK();\n+}\n+\n+template <typename Type, bool swap = false, typename Enable = void>\n+struct IfElseFunctor {};\n+\n+template <typename Type, bool swap>\n+struct IfElseFunctor<Type, swap, enable_if_t<is_number_type<Type>::value>> {\n+  using T = typename TypeTraits<Type>::CType;\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(promote_nulls(ctx, cond, left, right, out));\n+\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          ctx->Allocate(cond.length * sizeof(T)));\n+    T* out_values = reinterpret_cast<T*>(out_buf->mutable_data());\n+\n+    // copy right data to out_buff\n+    const T* right_data = right.GetValues<T>(1);\n+    std::memcpy(out_values, right_data, right.length * sizeof(T));\n+\n+    const auto* cond_data = cond.buffers[1]->data();  // this is a BoolArray\n+    BitBlockCounter bit_counter(cond_data, cond.offset, cond.length);\n+\n+    // selectively copy values from left data\n+    const T* left_data = left.GetValues<T>(1);\n+    int64_t offset = cond.offset;\n+\n+    // todo this can be improved by intrinsics. ex: _mm*_mask_store_e* (vmovdqa*)\n\nReview comment:\n       I would assume memcpy already does this for you.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,285 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// nulls will be promoted as follows\n+// cond.val && (cond.data && left.val || ~cond.data && right.val)\n+Status promote_nulls(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* output) {\n+  if (!cond.MayHaveNulls() && !left.MayHaveNulls() && !right.MayHaveNulls()) {\n+    return Status::OK();  // no nulls to handle\n+  }\n+  const int64_t len = cond.length;\n+\n+  ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_validity, ctx->AllocateBitmap(len));\n+  arrow::internal::InvertBitmap(out_validity->data(), 0, len,\n+                                out_validity->mutable_data(), 0);\n+  if (right.MayHaveNulls()) {\n+    // out_validity = right.val && ~cond.data\n+    arrow::internal::BitmapAndNot(right.buffers[0]->data(), right.offset,\n+                                  cond.buffers[1]->data(), cond.offset, len, 0,\n+                                  out_validity->mutable_data());\n+  }\n+\n+  if (left.MayHaveNulls()) {\n+    // tmp_buf = left.val && cond.data\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> temp_buf,\n+                          arrow::internal::BitmapAnd(\n+                              ctx->memory_pool(), left.buffers[0]->data(), left.offset,\n+                              cond.buffers[1]->data(), cond.offset, len, 0));\n+    // out_validity = cond.data && left.val || ~cond.data && right.val\n+    arrow::internal::BitmapOr(out_validity->data(), 0, temp_buf->data(), 0, len, 0,\n+                              out_validity->mutable_data());\n+  }\n+\n+  if (cond.MayHaveNulls()) {\n+    // out_validity &= cond.val\n+    ::arrow::internal::BitmapAnd(out_validity->data(), 0, cond.buffers[0]->data(),\n+                                 cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  output->buffers[0] = std::move(out_validity);\n+  output->GetNullCount();  // update null count\n+  return Status::OK();\n+}\n+\n+template <typename Type, bool swap = false, typename Enable = void>\n+struct IfElseFunctor {};\n+\n+template <typename Type, bool swap>\n+struct IfElseFunctor<Type, swap, enable_if_t<is_number_type<Type>::value>> {\n+  using T = typename TypeTraits<Type>::CType;\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(promote_nulls(ctx, cond, left, right, out));\n+\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          ctx->Allocate(cond.length * sizeof(T)));\n+    T* out_values = reinterpret_cast<T*>(out_buf->mutable_data());\n+\n+    // copy right data to out_buff\n+    const T* right_data = right.GetValues<T>(1);\n+    std::memcpy(out_values, right_data, right.length * sizeof(T));\n+\n+    const auto* cond_data = cond.buffers[1]->data();  // this is a BoolArray\n+    BitBlockCounter bit_counter(cond_data, cond.offset, cond.length);\n+\n+    // selectively copy values from left data\n+    const T* left_data = left.GetValues<T>(1);\n+    int64_t offset = cond.offset;\n+\n+    // todo this can be improved by intrinsics. ex: _mm*_mask_store_e* (vmovdqa*)\n+    while (offset < cond.offset + cond.length) {\n+      const BitBlockCount& block = bit_counter.NextWord();\n+      if (block.AllSet()) {  // all from left\n+        std::memcpy(out_values, left_data, block.length * sizeof(T));\n+      } else if (block.popcount) {  // selectively copy from left\n+        for (int64_t i = 0; i < block.length; ++i) {\n+          if (BitUtil::GetBit(cond_data, offset + i)) {\n+            out_values[i] = left_data[i];\n+          }\n+        }\n+      }\n+\n+      offset += block.length;\n+      out_values += block.length;\n+      left_data += block.length;\n+    }\n+\n+    out->buffers[1] = std::move(out_buf);\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const Scalar& right, ArrayData* out) {\n+    // todo impl\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const Scalar& cond, const Scalar& left,\n+                     const Scalar& right, Scalar* out) {\n+    // todo impl\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type, bool swap>\n+struct IfElseFunctor<Type, swap, enable_if_t<is_boolean_type<Type>::value>> {\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(promote_nulls(ctx, cond, left, right, out));\n+\n+    // out_buff = right & ~cond\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          arrow::internal::BitmapAndNot(\n+                              ctx->memory_pool(), right.buffers[1]->data(), right.offset,\n+                              cond.buffers[1]->data(), cond.offset, cond.length, 0));\n+\n+    // out_buff = left & cond\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> temp_buf,\n+                          arrow::internal::BitmapAnd(\n+                              ctx->memory_pool(), left.buffers[1]->data(), left.offset,\n+                              cond.buffers[1]->data(), cond.offset, cond.length, 0));\n+\n+    arrow::internal::BitmapOr(out_buf->data(), 0, temp_buf->data(), 0, cond.length, 0,\n+                              out_buf->mutable_data());\n+    out->buffers[1] = std::move(out_buf);\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const Scalar& right, ArrayData* out) {\n+    // todo impl\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const Scalar& cond, const Scalar& left,\n+                     const Scalar& right, Scalar* out) {\n+    // todo impl\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type, bool swap>\n+struct IfElseFunctor<Type, swap, enable_if_t<is_null_type<Type>::value>> {\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    // Nothing preallocated, so we assign left into the output\n+    *out = left;\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const Scalar& right, ArrayData* out) {\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const Scalar& cond, const Scalar& left,\n+                     const Scalar& right, Scalar* out) {\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct ResolveExec {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    if (batch.length == 0) return Status::OK();\n+\n+    if (batch[0].kind() == Datum::ARRAY) {\n+      if (batch[1].kind() == Datum::ARRAY) {\n+        if (batch[2].kind() == Datum::ARRAY) {  // AAA\n+          return IfElseFunctor<Type>::Call(ctx, *batch[0].array(), *batch[1].array(),\n+                                           *batch[2].array(), out->mutable_array());\n+        } else {  // AAS\n+          return IfElseFunctor<Type>::Call(ctx, *batch[0].array(), *batch[1].array(),\n+                                           *batch[2].scalar(), out->mutable_array());\n+        }\n+      } else {\n+        return Status::Invalid(\"\");\n+        //        if (batch[2].kind() == Datum::ARRAY) {  // ASA\n+        //          return IfElseFunctor<Type, true>::Call(ctx, *batch[0].array(),\n+        //                                                 *batch[2].array(),\n+        //                                                 *batch[1].scalar(),\n+        //                                                 out->mutable_array());\n+        //        } else {  // ASS\n+        //          return IfElseFunctor<Type>::Call(ctx, *batch[0].array(),\n+        //          *batch[1].scalar(),\n+        //                                           *batch[2].scalar(),\n+        //                                           out->mutable_array());\n+        //        }\n+      }\n+    } else {\n+      if (batch[1].kind() == Datum::ARRAY) {\n+        return Status::Invalid(\"\");\n+        //        if (batch[2].kind() == Datum::ARRAY) {  // SAA\n+        //          return IfElseFunctor<Type>::Call(ctx, *batch[0].scalar(),\n+        //          *batch[1].array(),\n+        //                                           *batch[2].array(),\n+        //                                           out->mutable_array());\n+        //        } else {  // SAS\n+        //          return IfElseFunctor<Type>::Call(ctx, *batch[0].scalar(),\n+        //          *batch[1].array(),\n+        //                                           *batch[2].scalar(),\n+        //                                           out->mutable_array());\n+        //        }\n+      } else {\n+        if (batch[2].kind() == Datum::ARRAY) {  // SSA\n+          return Status::Invalid(\"\");\n+          //          return IfElseFunctor<Type>::Call(ctx, *batch[0].scalar(),\n+          //          *batch[1].scalar(),\n+          //                                           *batch[2].array(),\n+          //                                           out->mutable_array());\n+        } else {  // SSS\n+          return IfElseFunctor<Type>::Call(ctx, *batch[0].scalar(), *batch[1].scalar(),\n+                                           *batch[2].scalar(), out->scalar().get());\n+        }\n+      }\n+    }\n+  }\n+};\n+\n+void AddPrimitiveKernels(const std::shared_ptr<ScalarFunction>& scalar_function,\n\nReview comment:\n       A lot of these function names are a little generic, can we rename them to reflect that they're for IfElse? We might end up putting other similar kernels here.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,285 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// nulls will be promoted as follows\n+// cond.val && (cond.data && left.val || ~cond.data && right.val)\n+Status promote_nulls(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* output) {\n+  if (!cond.MayHaveNulls() && !left.MayHaveNulls() && !right.MayHaveNulls()) {\n+    return Status::OK();  // no nulls to handle\n+  }\n+  const int64_t len = cond.length;\n+\n+  ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_validity, ctx->AllocateBitmap(len));\n+  arrow::internal::InvertBitmap(out_validity->data(), 0, len,\n+                                out_validity->mutable_data(), 0);\n+  if (right.MayHaveNulls()) {\n+    // out_validity = right.val && ~cond.data\n+    arrow::internal::BitmapAndNot(right.buffers[0]->data(), right.offset,\n+                                  cond.buffers[1]->data(), cond.offset, len, 0,\n+                                  out_validity->mutable_data());\n+  }\n+\n+  if (left.MayHaveNulls()) {\n+    // tmp_buf = left.val && cond.data\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> temp_buf,\n+                          arrow::internal::BitmapAnd(\n+                              ctx->memory_pool(), left.buffers[0]->data(), left.offset,\n+                              cond.buffers[1]->data(), cond.offset, len, 0));\n+    // out_validity = cond.data && left.val || ~cond.data && right.val\n+    arrow::internal::BitmapOr(out_validity->data(), 0, temp_buf->data(), 0, len, 0,\n+                              out_validity->mutable_data());\n+  }\n+\n+  if (cond.MayHaveNulls()) {\n+    // out_validity &= cond.val\n+    ::arrow::internal::BitmapAnd(out_validity->data(), 0, cond.buffers[0]->data(),\n+                                 cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  output->buffers[0] = std::move(out_validity);\n+  output->GetNullCount();  // update null count\n+  return Status::OK();\n+}\n+\n+template <typename Type, bool swap = false, typename Enable = void>\n+struct IfElseFunctor {};\n+\n+template <typename Type, bool swap>\n+struct IfElseFunctor<Type, swap, enable_if_t<is_number_type<Type>::value>> {\n+  using T = typename TypeTraits<Type>::CType;\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(promote_nulls(ctx, cond, left, right, out));\n+\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          ctx->Allocate(cond.length * sizeof(T)));\n+    T* out_values = reinterpret_cast<T*>(out_buf->mutable_data());\n+\n+    // copy right data to out_buff\n+    const T* right_data = right.GetValues<T>(1);\n+    std::memcpy(out_values, right_data, right.length * sizeof(T));\n+\n+    const auto* cond_data = cond.buffers[1]->data();  // this is a BoolArray\n+    BitBlockCounter bit_counter(cond_data, cond.offset, cond.length);\n+\n+    // selectively copy values from left data\n+    const T* left_data = left.GetValues<T>(1);\n+    int64_t offset = cond.offset;\n+\n+    // todo this can be improved by intrinsics. ex: _mm*_mask_store_e* (vmovdqa*)\n+    while (offset < cond.offset + cond.length) {\n+      const BitBlockCount& block = bit_counter.NextWord();\n+      if (block.AllSet()) {  // all from left\n+        std::memcpy(out_values, left_data, block.length * sizeof(T));\n+      } else if (block.popcount) {  // selectively copy from left\n+        for (int64_t i = 0; i < block.length; ++i) {\n+          if (BitUtil::GetBit(cond_data, offset + i)) {\n+            out_values[i] = left_data[i];\n+          }\n+        }\n+      }\n+\n+      offset += block.length;\n+      out_values += block.length;\n+      left_data += block.length;\n+    }\n+\n+    out->buffers[1] = std::move(out_buf);\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const Scalar& right, ArrayData* out) {\n+    // todo impl\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const Scalar& cond, const Scalar& left,\n+                     const Scalar& right, Scalar* out) {\n+    // todo impl\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type, bool swap>\n+struct IfElseFunctor<Type, swap, enable_if_t<is_boolean_type<Type>::value>> {\n\nReview comment:\n       (same with `enable_if_number` etc)\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,285 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// nulls will be promoted as follows\n+// cond.val && (cond.data && left.val || ~cond.data && right.val)\n+Status promote_nulls(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* output) {\n+  if (!cond.MayHaveNulls() && !left.MayHaveNulls() && !right.MayHaveNulls()) {\n+    return Status::OK();  // no nulls to handle\n+  }\n+  const int64_t len = cond.length;\n+\n+  ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_validity, ctx->AllocateBitmap(len));\n+  arrow::internal::InvertBitmap(out_validity->data(), 0, len,\n+                                out_validity->mutable_data(), 0);\n+  if (right.MayHaveNulls()) {\n+    // out_validity = right.val && ~cond.data\n+    arrow::internal::BitmapAndNot(right.buffers[0]->data(), right.offset,\n+                                  cond.buffers[1]->data(), cond.offset, len, 0,\n+                                  out_validity->mutable_data());\n+  }\n+\n+  if (left.MayHaveNulls()) {\n+    // tmp_buf = left.val && cond.data\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> temp_buf,\n+                          arrow::internal::BitmapAnd(\n+                              ctx->memory_pool(), left.buffers[0]->data(), left.offset,\n+                              cond.buffers[1]->data(), cond.offset, len, 0));\n+    // out_validity = cond.data && left.val || ~cond.data && right.val\n+    arrow::internal::BitmapOr(out_validity->data(), 0, temp_buf->data(), 0, len, 0,\n+                              out_validity->mutable_data());\n+  }\n+\n+  if (cond.MayHaveNulls()) {\n+    // out_validity &= cond.val\n+    ::arrow::internal::BitmapAnd(out_validity->data(), 0, cond.buffers[0]->data(),\n+                                 cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  output->buffers[0] = std::move(out_validity);\n+  output->GetNullCount();  // update null count\n+  return Status::OK();\n+}\n+\n+template <typename Type, bool swap = false, typename Enable = void>\n+struct IfElseFunctor {};\n+\n+template <typename Type, bool swap>\n+struct IfElseFunctor<Type, swap, enable_if_t<is_number_type<Type>::value>> {\n+  using T = typename TypeTraits<Type>::CType;\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(promote_nulls(ctx, cond, left, right, out));\n+\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          ctx->Allocate(cond.length * sizeof(T)));\n+    T* out_values = reinterpret_cast<T*>(out_buf->mutable_data());\n+\n+    // copy right data to out_buff\n+    const T* right_data = right.GetValues<T>(1);\n+    std::memcpy(out_values, right_data, right.length * sizeof(T));\n+\n+    const auto* cond_data = cond.buffers[1]->data();  // this is a BoolArray\n+    BitBlockCounter bit_counter(cond_data, cond.offset, cond.length);\n+\n+    // selectively copy values from left data\n+    const T* left_data = left.GetValues<T>(1);\n+    int64_t offset = cond.offset;\n+\n+    // todo this can be improved by intrinsics. ex: _mm*_mask_store_e* (vmovdqa*)\n+    while (offset < cond.offset + cond.length) {\n+      const BitBlockCount& block = bit_counter.NextWord();\n+      if (block.AllSet()) {  // all from left\n+        std::memcpy(out_values, left_data, block.length * sizeof(T));\n+      } else if (block.popcount) {  // selectively copy from left\n+        for (int64_t i = 0; i < block.length; ++i) {\n+          if (BitUtil::GetBit(cond_data, offset + i)) {\n+            out_values[i] = left_data[i];\n+          }\n+        }\n+      }\n+\n+      offset += block.length;\n+      out_values += block.length;\n+      left_data += block.length;\n+    }\n+\n+    out->buffers[1] = std::move(out_buf);\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const Scalar& right, ArrayData* out) {\n+    // todo impl\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const Scalar& cond, const Scalar& left,\n+                     const Scalar& right, Scalar* out) {\n+    // todo impl\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type, bool swap>\n+struct IfElseFunctor<Type, swap, enable_if_t<is_boolean_type<Type>::value>> {\n\nReview comment:\n       nit: `type_traits.h` already has an `enable_if_boolean`\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-21T22:44:55.006+0000",
                    "updated": "2021-05-21T22:44:55.006+0000",
                    "started": "2021-05-21T22:44:55.006+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "600679",
                    "issueId": "13341287"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/601190",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on pull request #10377:\nURL: https://github.com/apache/arrow/pull/10377#issuecomment-847045029\n\n\n   > Just some quick initial feedback. I think the overall approach looks fine. Testing this thoroughly will be important.\r\n   > \r\n   > For a different PR I added a `DatumFromJSON` to make it easier to test functions that accept a lot of permutations of scalar/array arguments. I could pull that out separately if that would make testing easier here. (That way you don't need a lot of overloads and boilerplate to test all the possible input combinations.)\r\n   \r\n   That would be great @lidavidm . If you could send me the PR# that would be great! :-) \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-24T13:32:20.441+0000",
                    "updated": "2021-05-24T13:32:20.441+0000",
                    "started": "2021-05-24T13:32:20.440+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "601190",
                    "issueId": "13341287"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/601191",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on a change in pull request #10377:\nURL: https://github.com/apache/arrow/pull/10377#discussion_r637949150\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,285 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// nulls will be promoted as follows\n+// cond.val && (cond.data && left.val || ~cond.data && right.val)\n+Status promote_nulls(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* output) {\n+  if (!cond.MayHaveNulls() && !left.MayHaveNulls() && !right.MayHaveNulls()) {\n+    return Status::OK();  // no nulls to handle\n+  }\n+  const int64_t len = cond.length;\n+\n+  ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_validity, ctx->AllocateBitmap(len));\n+  arrow::internal::InvertBitmap(out_validity->data(), 0, len,\n+                                out_validity->mutable_data(), 0);\n+  if (right.MayHaveNulls()) {\n+    // out_validity = right.val && ~cond.data\n+    arrow::internal::BitmapAndNot(right.buffers[0]->data(), right.offset,\n+                                  cond.buffers[1]->data(), cond.offset, len, 0,\n+                                  out_validity->mutable_data());\n+  }\n+\n+  if (left.MayHaveNulls()) {\n+    // tmp_buf = left.val && cond.data\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> temp_buf,\n+                          arrow::internal::BitmapAnd(\n+                              ctx->memory_pool(), left.buffers[0]->data(), left.offset,\n+                              cond.buffers[1]->data(), cond.offset, len, 0));\n+    // out_validity = cond.data && left.val || ~cond.data && right.val\n+    arrow::internal::BitmapOr(out_validity->data(), 0, temp_buf->data(), 0, len, 0,\n+                              out_validity->mutable_data());\n+  }\n+\n+  if (cond.MayHaveNulls()) {\n+    // out_validity &= cond.val\n+    ::arrow::internal::BitmapAnd(out_validity->data(), 0, cond.buffers[0]->data(),\n+                                 cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  output->buffers[0] = std::move(out_validity);\n+  output->GetNullCount();  // update null count\n+  return Status::OK();\n+}\n+\n+template <typename Type, bool swap = false, typename Enable = void>\n\nReview comment:\n       My idea is to reuse the impl for the cases like, `cond, left: Array, right: Scalar` and `cond, left: Sca;ar, right: Array`. In the second scenario, I can swap left and right and invert the cond without changing the loop mechanism. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-24T13:35:36.132+0000",
                    "updated": "2021-05-24T13:35:36.132+0000",
                    "started": "2021-05-24T13:35:36.132+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "601191",
                    "issueId": "13341287"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/601195",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on a change in pull request #10377:\nURL: https://github.com/apache/arrow/pull/10377#discussion_r637955569\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,285 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// nulls will be promoted as follows\n+// cond.val && (cond.data && left.val || ~cond.data && right.val)\n+Status promote_nulls(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* output) {\n+  if (!cond.MayHaveNulls() && !left.MayHaveNulls() && !right.MayHaveNulls()) {\n+    return Status::OK();  // no nulls to handle\n+  }\n+  const int64_t len = cond.length;\n+\n+  ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_validity, ctx->AllocateBitmap(len));\n+  arrow::internal::InvertBitmap(out_validity->data(), 0, len,\n+                                out_validity->mutable_data(), 0);\n+  if (right.MayHaveNulls()) {\n+    // out_validity = right.val && ~cond.data\n+    arrow::internal::BitmapAndNot(right.buffers[0]->data(), right.offset,\n+                                  cond.buffers[1]->data(), cond.offset, len, 0,\n+                                  out_validity->mutable_data());\n+  }\n+\n+  if (left.MayHaveNulls()) {\n+    // tmp_buf = left.val && cond.data\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> temp_buf,\n+                          arrow::internal::BitmapAnd(\n+                              ctx->memory_pool(), left.buffers[0]->data(), left.offset,\n+                              cond.buffers[1]->data(), cond.offset, len, 0));\n+    // out_validity = cond.data && left.val || ~cond.data && right.val\n+    arrow::internal::BitmapOr(out_validity->data(), 0, temp_buf->data(), 0, len, 0,\n+                              out_validity->mutable_data());\n+  }\n+\n+  if (cond.MayHaveNulls()) {\n+    // out_validity &= cond.val\n+    ::arrow::internal::BitmapAnd(out_validity->data(), 0, cond.buffers[0]->data(),\n+                                 cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  output->buffers[0] = std::move(out_validity);\n+  output->GetNullCount();  // update null count\n+  return Status::OK();\n+}\n+\n+template <typename Type, bool swap = false, typename Enable = void>\n+struct IfElseFunctor {};\n+\n+template <typename Type, bool swap>\n+struct IfElseFunctor<Type, swap, enable_if_t<is_number_type<Type>::value>> {\n+  using T = typename TypeTraits<Type>::CType;\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(promote_nulls(ctx, cond, left, right, out));\n+\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          ctx->Allocate(cond.length * sizeof(T)));\n+    T* out_values = reinterpret_cast<T*>(out_buf->mutable_data());\n+\n+    // copy right data to out_buff\n+    const T* right_data = right.GetValues<T>(1);\n+    std::memcpy(out_values, right_data, right.length * sizeof(T));\n+\n+    const auto* cond_data = cond.buffers[1]->data();  // this is a BoolArray\n+    BitBlockCounter bit_counter(cond_data, cond.offset, cond.length);\n+\n+    // selectively copy values from left data\n+    const T* left_data = left.GetValues<T>(1);\n+    int64_t offset = cond.offset;\n+\n+    // todo this can be improved by intrinsics. ex: _mm*_mask_store_e* (vmovdqa*)\n\nReview comment:\n       Do you mean, load with mask?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-24T13:44:40.325+0000",
                    "updated": "2021-05-24T13:44:40.325+0000",
                    "started": "2021-05-24T13:44:40.324+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "601195",
                    "issueId": "13341287"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/601198",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10377:\nURL: https://github.com/apache/arrow/pull/10377#discussion_r637957534\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,285 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// nulls will be promoted as follows\n+// cond.val && (cond.data && left.val || ~cond.data && right.val)\n+Status promote_nulls(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* output) {\n+  if (!cond.MayHaveNulls() && !left.MayHaveNulls() && !right.MayHaveNulls()) {\n+    return Status::OK();  // no nulls to handle\n+  }\n+  const int64_t len = cond.length;\n+\n+  ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_validity, ctx->AllocateBitmap(len));\n+  arrow::internal::InvertBitmap(out_validity->data(), 0, len,\n+                                out_validity->mutable_data(), 0);\n+  if (right.MayHaveNulls()) {\n+    // out_validity = right.val && ~cond.data\n+    arrow::internal::BitmapAndNot(right.buffers[0]->data(), right.offset,\n+                                  cond.buffers[1]->data(), cond.offset, len, 0,\n+                                  out_validity->mutable_data());\n+  }\n+\n+  if (left.MayHaveNulls()) {\n+    // tmp_buf = left.val && cond.data\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> temp_buf,\n+                          arrow::internal::BitmapAnd(\n+                              ctx->memory_pool(), left.buffers[0]->data(), left.offset,\n+                              cond.buffers[1]->data(), cond.offset, len, 0));\n+    // out_validity = cond.data && left.val || ~cond.data && right.val\n+    arrow::internal::BitmapOr(out_validity->data(), 0, temp_buf->data(), 0, len, 0,\n+                              out_validity->mutable_data());\n+  }\n+\n+  if (cond.MayHaveNulls()) {\n+    // out_validity &= cond.val\n+    ::arrow::internal::BitmapAnd(out_validity->data(), 0, cond.buffers[0]->data(),\n+                                 cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  output->buffers[0] = std::move(out_validity);\n+  output->GetNullCount();  // update null count\n+  return Status::OK();\n+}\n+\n+template <typename Type, bool swap = false, typename Enable = void>\n+struct IfElseFunctor {};\n+\n+template <typename Type, bool swap>\n+struct IfElseFunctor<Type, swap, enable_if_t<is_number_type<Type>::value>> {\n+  using T = typename TypeTraits<Type>::CType;\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(promote_nulls(ctx, cond, left, right, out));\n+\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          ctx->Allocate(cond.length * sizeof(T)));\n+    T* out_values = reinterpret_cast<T*>(out_buf->mutable_data());\n+\n+    // copy right data to out_buff\n+    const T* right_data = right.GetValues<T>(1);\n+    std::memcpy(out_values, right_data, right.length * sizeof(T));\n+\n+    const auto* cond_data = cond.buffers[1]->data();  // this is a BoolArray\n+    BitBlockCounter bit_counter(cond_data, cond.offset, cond.length);\n+\n+    // selectively copy values from left data\n+    const T* left_data = left.GetValues<T>(1);\n+    int64_t offset = cond.offset;\n+\n+    // todo this can be improved by intrinsics. ex: _mm*_mask_store_e* (vmovdqa*)\n\nReview comment:\n       Sorry, I think I misunderstood the optimization you're thinking about. How would SIMD help here?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-24T13:47:43.815+0000",
                    "updated": "2021-05-24T13:47:43.815+0000",
                    "started": "2021-05-24T13:47:43.814+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "601198",
                    "issueId": "13341287"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/601200",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10377:\nURL: https://github.com/apache/arrow/pull/10377#issuecomment-847056827\n\n\n   > > Just some quick initial feedback. I think the overall approach looks fine. Testing this thoroughly will be important.\r\n   > > For a different PR I added a `DatumFromJSON` to make it easier to test functions that accept a lot of permutations of scalar/array arguments. I could pull that out separately if that would make testing easier here. (That way you don't need a lot of overloads and boilerplate to test all the possible input combinations.)\r\n   > \r\n   > That would be great @lidavidm . If you could send me the PR# that would be great! :-)\r\n   \r\n   See #10386\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-24T13:52:05.232+0000",
                    "updated": "2021-05-24T13:52:05.232+0000",
                    "started": "2021-05-24T13:52:05.232+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "601200",
                    "issueId": "13341287"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/601202",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on a change in pull request #10377:\nURL: https://github.com/apache/arrow/pull/10377#discussion_r637962492\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,285 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+\n+namespace compute {\n+\n+namespace {\n+\n+// nulls will be promoted as follows\n+// cond.val && (cond.data && left.val || ~cond.data && right.val)\n+Status promote_nulls(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* output) {\n+  if (!cond.MayHaveNulls() && !left.MayHaveNulls() && !right.MayHaveNulls()) {\n+    return Status::OK();  // no nulls to handle\n+  }\n+  const int64_t len = cond.length;\n+\n+  ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_validity, ctx->AllocateBitmap(len));\n+  arrow::internal::InvertBitmap(out_validity->data(), 0, len,\n+                                out_validity->mutable_data(), 0);\n+  if (right.MayHaveNulls()) {\n+    // out_validity = right.val && ~cond.data\n+    arrow::internal::BitmapAndNot(right.buffers[0]->data(), right.offset,\n+                                  cond.buffers[1]->data(), cond.offset, len, 0,\n+                                  out_validity->mutable_data());\n+  }\n+\n+  if (left.MayHaveNulls()) {\n+    // tmp_buf = left.val && cond.data\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> temp_buf,\n+                          arrow::internal::BitmapAnd(\n+                              ctx->memory_pool(), left.buffers[0]->data(), left.offset,\n+                              cond.buffers[1]->data(), cond.offset, len, 0));\n+    // out_validity = cond.data && left.val || ~cond.data && right.val\n+    arrow::internal::BitmapOr(out_validity->data(), 0, temp_buf->data(), 0, len, 0,\n+                              out_validity->mutable_data());\n+  }\n+\n+  if (cond.MayHaveNulls()) {\n+    // out_validity &= cond.val\n+    ::arrow::internal::BitmapAnd(out_validity->data(), 0, cond.buffers[0]->data(),\n+                                 cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  output->buffers[0] = std::move(out_validity);\n+  output->GetNullCount();  // update null count\n+  return Status::OK();\n+}\n+\n+template <typename Type, bool swap = false, typename Enable = void>\n+struct IfElseFunctor {};\n+\n+template <typename Type, bool swap>\n+struct IfElseFunctor<Type, swap, enable_if_t<is_number_type<Type>::value>> {\n+  using T = typename TypeTraits<Type>::CType;\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(promote_nulls(ctx, cond, left, right, out));\n+\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          ctx->Allocate(cond.length * sizeof(T)));\n+    T* out_values = reinterpret_cast<T*>(out_buf->mutable_data());\n+\n+    // copy right data to out_buff\n+    const T* right_data = right.GetValues<T>(1);\n+    std::memcpy(out_values, right_data, right.length * sizeof(T));\n+\n+    const auto* cond_data = cond.buffers[1]->data();  // this is a BoolArray\n+    BitBlockCounter bit_counter(cond_data, cond.offset, cond.length);\n+\n+    // selectively copy values from left data\n+    const T* left_data = left.GetValues<T>(1);\n+    int64_t offset = cond.offset;\n+\n+    // todo this can be improved by intrinsics. ex: _mm*_mask_store_e* (vmovdqa*)\n\nReview comment:\n       Say, you first copy `right` to `ouput`. Then, `cond` becomes a mask to store `left` onto `output`. For that there are specialized SIMD instructions. \r\n   https://software.intel.com/sites/landingpage/IntrinsicsGuide/#cats=Store&text=mask_store&expand=5564,5566\r\n   \r\n   So, we can drop the `BitBlock` objects, and remove all the loops and memcpy inside the `while` loop. We'd have to handle the alignment though. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-24T13:54:41.958+0000",
                    "updated": "2021-05-24T13:54:41.958+0000",
                    "started": "2021-05-24T13:54:41.957+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "601202",
                    "issueId": "13341287"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/601891",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on pull request #10377:\nURL: https://github.com/apache/arrow/pull/10377#issuecomment-848097418\n\n\n   I am closing this PR because there are some major refactors and it would be better to review them fresh. \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-25T18:07:22.238+0000",
                    "updated": "2021-05-25T18:07:22.238+0000",
                    "started": "2021-05-25T18:07:22.238+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "601891",
                    "issueId": "13341287"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/601892",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera closed pull request #10377:\nURL: https://github.com/apache/arrow/pull/10377\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-25T18:07:25.715+0000",
                    "updated": "2021-05-25T18:07:25.715+0000",
                    "started": "2021-05-25T18:07:25.714+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "601892",
                    "issueId": "13341287"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/602471",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera opened a new pull request #10410:\nURL: https://github.com/apache/arrow/pull/10410\n\n\n   Adding a preliminary impl for an `if_else(cond: Datum, left: Datum, right: Datum)` function. It works as follows,\r\n   ```python\r\n   def if_else(cond, left, right):\r\n       for c, true_val, false_val in zip(cond, left, right):\r\n           if c:\r\n               yield true_val\r\n           else:\r\n               yield false_val\r\n   ```\r\n   `null` values will be promoted to the output. \r\n   \r\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-26T18:19:37.860+0000",
                    "updated": "2021-05-26T18:19:37.860+0000",
                    "started": "2021-05-26T18:19:37.860+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "602471",
                    "issueId": "13341287"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/602472",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10410:\nURL: https://github.com/apache/arrow/pull/10410#issuecomment-849013467\n\n\n   https://issues.apache.org/jira/browse/ARROW-10640\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-26T18:20:03.410+0000",
                    "updated": "2021-05-26T18:20:03.410+0000",
                    "started": "2021-05-26T18:20:03.409+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "602472",
                    "issueId": "13341287"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/602500",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on pull request #10410:\nURL: https://github.com/apache/arrow/pull/10410#issuecomment-849044674\n\n\n   @bkietz I think the bitmap ops approach is simpler than the bitmap visitor approach. WDYT?\r\n   bitmap ops - \r\n   https://github.com/apache/arrow/blob/8c0e8d9749f171da3826d9b194eacbd897909873/cpp/src/arrow/compute/kernels/scalar_if_else.cc#L307 onward\r\n   \r\n   bitmap visitor - \r\n   https://github.com/apache/arrow/blob/8c0e8d9749f171da3826d9b194eacbd897909873/cpp/src/arrow/compute/kernels/scalar_if_else.cc#L156 onward\r\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-26T19:06:53.933+0000",
                    "updated": "2021-05-26T19:06:53.933+0000",
                    "started": "2021-05-26T19:06:53.933+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "602500",
                    "issueId": "13341287"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/602912",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10410:\nURL: https://github.com/apache/arrow/pull/10410#discussion_r640537055\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else_test.cc\n##########\n@@ -0,0 +1,291 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/array.h>\n+#include <arrow/compute/api_scalar.h>\n+#include <arrow/compute/kernels/test_util.h>\n+#include <arrow/testing/gtest_util.h>\n+#include <gtest/gtest.h>\n+\n+namespace arrow {\n+namespace compute {\n+\n+void CheckIfElseOutputArray(const Datum& cond, const Datum& left, const Datum& right,\n\nReview comment:\n       I don't think we need `all_valid` given it's pretty much always `false`. It made sense for the original `fill_null` test because you expect no nulls afterwards, but not here. \n\n##########\nFile path: cpp/src/arrow/compute/api_scalar.h\n##########\n@@ -462,5 +462,21 @@ ARROW_EXPORT\n Result<Datum> FillNull(const Datum& values, const Datum& fill_value,\n                        ExecContext* ctx = NULLPTR);\n \n+/// \\brief IfElse returns elements chosen from `left` or `right`\n+/// depending on `cond`. `Null` values would be promoted to the result\n+///\n+/// \\param[in] cond `BooleanArray` condition array\n+/// \\param[in] left scalar/ Array\n+/// \\param[in] right scalar/ Array\n+/// \\param[in] ctx the function execution context, optional\n+///\n+/// \\return the resulting datum\n+///\n+/// \\since x.x.x\n+/// \\note API not yet finalized\n\nReview comment:\n       ```suggestion\r\n   /// \\brief IfElse returns elements chosen from `left` or `right`\r\n   /// depending on `cond`. `null` values would be promoted to the result\r\n   ///\r\n   /// \\param[in] cond `BooleanArray` condition array\r\n   /// \\param[in] left scalar/ Array\r\n   /// \\param[in] right scalar/ Array\r\n   /// \\param[in] ctx the function execution context, optional\r\n   ///\r\n   /// \\return the resulting datum\r\n   ///\r\n   /// \\since 5.0.0\r\n   /// \\note API not yet finalized\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,838 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+using internal::Bitmap;\n+\n+namespace compute {\n+\n+namespace {\n+\n+enum { COND_ALL_VALID = 1, LEFT_ALL_VALID = 2, RIGHT_ALL_VALID = 4 };\n+\n+// if the condition is null then output is null otherwise we take validity from the\n+// selected argument\n+// ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+Status PromoteNullsVisitor(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                           const Scalar& right, ArrayData* output) {\n+  uint8_t flag = right.is_valid * 4 + left.is_valid * 2 + !cond.MayHaveNulls();\n+\n+  if (flag < 6 && flag != 3) {\n+    // there will be a validity buffer in the output\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(cond.length));\n+  }\n+\n+  // if the condition is null then output is null otherwise we take validity from the\n+  // selected argument\n+  // ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+  switch (flag) {\n+    case COND_ALL_VALID | LEFT_ALL_VALID | RIGHT_ALL_VALID:  // = 7\n\nReview comment:\n       Also because RLC/LRC/etc. is a confusing abbreviation especially when the order of arguments is CLR.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else_test.cc\n##########\n@@ -0,0 +1,291 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/array.h>\n+#include <arrow/compute/api_scalar.h>\n+#include <arrow/compute/kernels/test_util.h>\n+#include <arrow/testing/gtest_util.h>\n+#include <gtest/gtest.h>\n+\n+namespace arrow {\n+namespace compute {\n+\n+void CheckIfElseOutputArray(const Datum& cond, const Datum& left, const Datum& right,\n+                            const Datum& expected, bool all_valid = true) {\n+  ASSERT_OK_AND_ASSIGN(Datum datum_out, IfElse(cond, left, right));\n+  std::shared_ptr<Array> result = datum_out.make_array();\n+  ASSERT_OK(result->ValidateFull());\n+  AssertArraysEqual(*expected.make_array(), *result, /*verbose=*/true);\n+  if (all_valid) {\n+    // Check null count of ArrayData is set, not the computed Array.null_count\n+    ASSERT_EQ(result->data()->null_count, 0);\n+  }\n+}\n+\n+void CheckIfElseOutputAAA(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::string& left, const std::string& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& left_ = ArrayFromJSON(type, left);\n+  const std::shared_ptr<Array>& right_ = ArrayFromJSON(type, right);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left_, right_, expected_, all_valid);\n+}\n+\n+void CheckIfElseOutputAAS(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::string& left, const std::shared_ptr<Scalar>& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& left_ = ArrayFromJSON(type, left);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left_, right, expected_, all_valid);\n+}\n+\n+void CheckIfElseOutputASA(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::shared_ptr<Scalar>& left, const std::string& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& right_ = ArrayFromJSON(type, right);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left, right_, expected_, all_valid);\n+}\n+\n+void CheckIfElseOutputASS(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::shared_ptr<Scalar>& left,\n+                          const std::shared_ptr<Scalar>& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left, right, expected_, all_valid);\n+}\n+\n+class TestIfElseKernel : public ::testing::Test {};\n+\n+template <typename Type>\n+class TestIfElsePrimitive : public ::testing::Test {};\n+\n+using PrimitiveTypes = ::testing::Types<Int8Type, UInt8Type, Int16Type, UInt16Type,\n+                                        Int32Type, UInt32Type, Int64Type, UInt64Type,\n+                                        FloatType, DoubleType, Date32Type, Date64Type>;\n+\n+TYPED_TEST_SUITE(TestIfElsePrimitive, PrimitiveTypes);\n+\n+TYPED_TEST(TestIfElsePrimitive, IfElseFixedSize) {\n+  auto type = TypeTraits<TypeParam>::type_singleton();\n+\n+  // No Nulls\n+  CheckIfElseOutputAAA(type, \"[]\", \"[]\", \"[]\", \"[]\");\n+\n+  // -------- All arrays ---------\n+  // RLC = 111\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, 2, 3, 4]\", \"[5, 6, 7, 8]\",\n+                       \"[1, 2, 3, 8]\");\n+  // RLC = 110\n+  CheckIfElseOutputAAA(type, \"[true, true, null, false]\", \"[1, 2, 3, 4]\", \"[5, 6, 7, 8]\",\n+                       \"[1, 2, null, 8]\", false);\n+  // RLC = 101\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, null, 3, 4]\",\n+                       \"[5, 6, 7, 8]\", \"[1, null, 3, 8]\", false);\n+  // RLC = 100\n+  CheckIfElseOutputAAA(type, \"[true, true, null, false]\", \"[1, null, 3, 4]\",\n+                       \"[5, 6, 7, 8]\", \"[1, null, null, 8]\", false);\n+  // RLC = 011\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, 2, 3, 4]\",\n+                       \"[5, 6, 7, null]\", \"[1, 2, 3, null]\", false);\n+  // RLC = 010\n+  CheckIfElseOutputAAA(type, \"[null, true, true, false]\", \"[1, 2, 3, 4]\",\n+                       \"[5, 6, 7, null]\", \"[null, 2, 3, null]\", false);\n+  // RLC = 001\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, 2, null, null]\",\n+                       \"[null, 6, 7, null]\", \"[1, 2, null, null]\", false);\n+  // RLC = 000\n+  CheckIfElseOutputAAA(type, \"[null, true, true, false]\", \"[1, 2, null, null]\",\n+                       \"[null, 6, 7, null]\", \"[null, 2, null, null]\", false);\n+\n+  using ArrayType = typename TypeTraits<TypeParam>::ArrayType;\n+  random::RandomArrayGenerator rand(/*seed=*/0);\n+  int64_t len = 1000;\n+  auto cond = std::static_pointer_cast<BooleanArray>(\n+      rand.ArrayOf(boolean(), len, /*null_probability=*/0.01));\n+  auto left = std::static_pointer_cast<ArrayType>(\n+      rand.ArrayOf(type, len, /*null_probability=*/0.01));\n+  auto right = std::static_pointer_cast<ArrayType>(\n+      rand.ArrayOf(type, len, /*null_probability=*/0.01));\n+\n+  typename TypeTraits<TypeParam>::BuilderType builder;\n+\n+  for (int64_t i = 0; i < len; ++i) {\n+    if (!cond->IsValid(i) || (cond->Value(i) && !left->IsValid(i)) ||\n+        (!cond->Value(i) && !right->IsValid(i))) {\n+      ASSERT_OK(builder.AppendNull());\n+      continue;\n+    }\n+\n+    if (cond->Value(i)) {\n+      ASSERT_OK(builder.Append(left->Value(i)));\n+    } else {\n+      ASSERT_OK(builder.Append(right->Value(i)));\n+    }\n+  }\n+  ASSERT_OK_AND_ASSIGN(auto expected_data, builder.Finish());\n+\n+  CheckIfElseOutputArray(cond, left, right, expected_data, false);\n+\n+  // -------- Cond - Array, Left- Array, Right - Scalar ---------\n+\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Scalar> valid_scalar, MakeScalar(type, 100));\n+  std::shared_ptr<Scalar> null_scalar = MakeNullScalar(type);\n+\n+  // empty\n+  CheckIfElseOutputAAS(type, \"[]\", \"[]\", valid_scalar, \"[]\");\n+\n+  // RLC = 111\n+  CheckIfElseOutputAAS(type, \"[true, true, true, false]\", \"[1, 2, 3, 4]\", valid_scalar,\n+                       \"[1, 2, 3, 100]\");\n+  // RLC = 110\n+  CheckIfElseOutputAAS(type, \"[true, true, null, false]\", \"[1, 2, 3, 4]\", valid_scalar,\n+                       \"[1, 2, null, 100]\", false);\n+  // RLC = 101\n+  CheckIfElseOutputAAS(type, \"[true, true, true, false]\", \"[1, null, 3, 4]\", valid_scalar,\n+                       \"[1, null, 3, 100]\", false);\n+  // RLC = 100\n+  CheckIfElseOutputAAS(type, \"[true, true, null, false]\", \"[1, null, 3, 4]\", valid_scalar,\n+                       \"[1, null, null, 100]\", false);\n\nReview comment:\n       It's also unclear to me what RLC/LRC stand for.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,838 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+using internal::Bitmap;\n+\n+namespace compute {\n+\n+namespace {\n+\n+enum { COND_ALL_VALID = 1, LEFT_ALL_VALID = 2, RIGHT_ALL_VALID = 4 };\n+\n+// if the condition is null then output is null otherwise we take validity from the\n+// selected argument\n+// ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+Status PromoteNullsVisitor(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                           const Scalar& right, ArrayData* output) {\n+  uint8_t flag = right.is_valid * 4 + left.is_valid * 2 + !cond.MayHaveNulls();\n+\n+  if (flag < 6 && flag != 3) {\n\nReview comment:\n       This is a little confusing: can we move this into the switch below as another case?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,838 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+using internal::Bitmap;\n+\n+namespace compute {\n+\n+namespace {\n+\n+enum { COND_ALL_VALID = 1, LEFT_ALL_VALID = 2, RIGHT_ALL_VALID = 4 };\n+\n+// if the condition is null then output is null otherwise we take validity from the\n+// selected argument\n+// ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+Status PromoteNullsVisitor(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                           const Scalar& right, ArrayData* output) {\n+  uint8_t flag = right.is_valid * 4 + left.is_valid * 2 + !cond.MayHaveNulls();\n+\n+  if (flag < 6 && flag != 3) {\n+    // there will be a validity buffer in the output\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(cond.length));\n+  }\n+\n+  // if the condition is null then output is null otherwise we take validity from the\n+  // selected argument\n+  // ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+  switch (flag) {\n+    case COND_ALL_VALID | LEFT_ALL_VALID | RIGHT_ALL_VALID:  // = 7\n\nReview comment:\n       nit: below you abbreviate these as RLC/LRC/etc. I don't think we need any of those comments since the case itself should be self explanatory.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,838 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+using internal::Bitmap;\n+\n+namespace compute {\n+\n+namespace {\n+\n+enum { COND_ALL_VALID = 1, LEFT_ALL_VALID = 2, RIGHT_ALL_VALID = 4 };\n+\n+// if the condition is null then output is null otherwise we take validity from the\n+// selected argument\n+// ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+Status PromoteNullsVisitor(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                           const Scalar& right, ArrayData* output) {\n+  uint8_t flag = right.is_valid * 4 + left.is_valid * 2 + !cond.MayHaveNulls();\n+\n+  if (flag < 6 && flag != 3) {\n+    // there will be a validity buffer in the output\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(cond.length));\n+  }\n+\n+  // if the condition is null then output is null otherwise we take validity from the\n+  // selected argument\n+  // ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+  switch (flag) {\n+    case COND_ALL_VALID | LEFT_ALL_VALID | RIGHT_ALL_VALID:  // = 7\n+      break;\n+    case LEFT_ALL_VALID | RIGHT_ALL_VALID:  // = 6\n+      // out_valid = c_valid\n+      output->buffers[0] = SliceBuffer(cond.buffers[0], cond.offset, cond.length);\n+      break;\n+    case COND_ALL_VALID | RIGHT_ALL_VALID:  // = 5\n+      // out_valid = ~cond.data\n+      arrow::internal::InvertBitmap(cond.buffers[1]->data(), cond.offset, cond.length,\n+                                    output->buffers[0]->mutable_data(), 0);\n+      break;\n+    case RIGHT_ALL_VALID:  // = 4\n+      // out_valid = c_valid & ~cond.data\n+      arrow::internal::BitmapAndNot(cond.buffers[0]->data(), cond.offset,\n+                                    cond.buffers[1]->data(), cond.offset, cond.length, 0,\n+                                    output->buffers[0]->mutable_data());\n+      break;\n+    case COND_ALL_VALID | LEFT_ALL_VALID:  // = 3\n+      // out_valid = cond.data\n+      output->buffers[0] = SliceBuffer(cond.buffers[1], cond.offset, cond.length);\n+      break;\n+    case LEFT_ALL_VALID:  // = 2\n+      // out_valid = cond.valid & cond.data\n+      arrow::internal::BitmapAnd(cond.buffers[0]->data(), cond.offset,\n+                                 cond.buffers[1]->data(), cond.offset, cond.length, 0,\n+                                 output->buffers[0]->mutable_data());\n+      break;\n+    case COND_ALL_VALID:  // = 1\n+      // out_valid = 0 --> nothing to do; but requires out_valid to be a all-zero buffer\n\nReview comment:\n       AllocateBitmap doesn't zero the allocation\r\n   https://github.com/apache/arrow/blob/176988893e182ac418072ef8cd9a4bc598784d97/cpp/src/arrow/compute/kernel.h#L61-L64\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else_test.cc\n##########\n@@ -0,0 +1,291 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/array.h>\n+#include <arrow/compute/api_scalar.h>\n+#include <arrow/compute/kernels/test_util.h>\n+#include <arrow/testing/gtest_util.h>\n+#include <gtest/gtest.h>\n+\n+namespace arrow {\n+namespace compute {\n+\n+void CheckIfElseOutputArray(const Datum& cond, const Datum& left, const Datum& right,\n+                            const Datum& expected, bool all_valid = true) {\n+  ASSERT_OK_AND_ASSIGN(Datum datum_out, IfElse(cond, left, right));\n+  std::shared_ptr<Array> result = datum_out.make_array();\n+  ASSERT_OK(result->ValidateFull());\n+  AssertArraysEqual(*expected.make_array(), *result, /*verbose=*/true);\n+  if (all_valid) {\n+    // Check null count of ArrayData is set, not the computed Array.null_count\n+    ASSERT_EQ(result->data()->null_count, 0);\n+  }\n+}\n+\n+void CheckIfElseOutputAAA(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::string& left, const std::string& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& left_ = ArrayFromJSON(type, left);\n+  const std::shared_ptr<Array>& right_ = ArrayFromJSON(type, right);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left_, right_, expected_, all_valid);\n+}\n+\n+void CheckIfElseOutputAAS(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::string& left, const std::shared_ptr<Scalar>& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& left_ = ArrayFromJSON(type, left);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left_, right, expected_, all_valid);\n+}\n+\n+void CheckIfElseOutputASA(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::shared_ptr<Scalar>& left, const std::string& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& right_ = ArrayFromJSON(type, right);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left, right_, expected_, all_valid);\n+}\n+\n+void CheckIfElseOutputASS(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::shared_ptr<Scalar>& left,\n+                          const std::shared_ptr<Scalar>& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left, right, expected_, all_valid);\n+}\n+\n+class TestIfElseKernel : public ::testing::Test {};\n+\n+template <typename Type>\n+class TestIfElsePrimitive : public ::testing::Test {};\n+\n+using PrimitiveTypes = ::testing::Types<Int8Type, UInt8Type, Int16Type, UInt16Type,\n+                                        Int32Type, UInt32Type, Int64Type, UInt64Type,\n+                                        FloatType, DoubleType, Date32Type, Date64Type>;\n+\n+TYPED_TEST_SUITE(TestIfElsePrimitive, PrimitiveTypes);\n+\n+TYPED_TEST(TestIfElsePrimitive, IfElseFixedSize) {\n+  auto type = TypeTraits<TypeParam>::type_singleton();\n+\n+  // No Nulls\n+  CheckIfElseOutputAAA(type, \"[]\", \"[]\", \"[]\", \"[]\");\n+\n+  // -------- All arrays ---------\n+  // RLC = 111\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, 2, 3, 4]\", \"[5, 6, 7, 8]\",\n+                       \"[1, 2, 3, 8]\");\n+  // RLC = 110\n+  CheckIfElseOutputAAA(type, \"[true, true, null, false]\", \"[1, 2, 3, 4]\", \"[5, 6, 7, 8]\",\n+                       \"[1, 2, null, 8]\", false);\n+  // RLC = 101\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, null, 3, 4]\",\n+                       \"[5, 6, 7, 8]\", \"[1, null, 3, 8]\", false);\n+  // RLC = 100\n+  CheckIfElseOutputAAA(type, \"[true, true, null, false]\", \"[1, null, 3, 4]\",\n+                       \"[5, 6, 7, 8]\", \"[1, null, null, 8]\", false);\n+  // RLC = 011\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, 2, 3, 4]\",\n+                       \"[5, 6, 7, null]\", \"[1, 2, 3, null]\", false);\n+  // RLC = 010\n+  CheckIfElseOutputAAA(type, \"[null, true, true, false]\", \"[1, 2, 3, 4]\",\n+                       \"[5, 6, 7, null]\", \"[null, 2, 3, null]\", false);\n+  // RLC = 001\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, 2, null, null]\",\n+                       \"[null, 6, 7, null]\", \"[1, 2, null, null]\", false);\n+  // RLC = 000\n+  CheckIfElseOutputAAA(type, \"[null, true, true, false]\", \"[1, 2, null, null]\",\n+                       \"[null, 6, 7, null]\", \"[null, 2, null, null]\", false);\n+\n+  using ArrayType = typename TypeTraits<TypeParam>::ArrayType;\n+  random::RandomArrayGenerator rand(/*seed=*/0);\n+  int64_t len = 1000;\n+  auto cond = std::static_pointer_cast<BooleanArray>(\n+      rand.ArrayOf(boolean(), len, /*null_probability=*/0.01));\n+  auto left = std::static_pointer_cast<ArrayType>(\n+      rand.ArrayOf(type, len, /*null_probability=*/0.01));\n+  auto right = std::static_pointer_cast<ArrayType>(\n+      rand.ArrayOf(type, len, /*null_probability=*/0.01));\n+\n+  typename TypeTraits<TypeParam>::BuilderType builder;\n+\n+  for (int64_t i = 0; i < len; ++i) {\n+    if (!cond->IsValid(i) || (cond->Value(i) && !left->IsValid(i)) ||\n+        (!cond->Value(i) && !right->IsValid(i))) {\n+      ASSERT_OK(builder.AppendNull());\n+      continue;\n+    }\n+\n+    if (cond->Value(i)) {\n+      ASSERT_OK(builder.Append(left->Value(i)));\n+    } else {\n+      ASSERT_OK(builder.Append(right->Value(i)));\n+    }\n+  }\n+  ASSERT_OK_AND_ASSIGN(auto expected_data, builder.Finish());\n+\n+  CheckIfElseOutputArray(cond, left, right, expected_data, false);\n+\n+  // -------- Cond - Array, Left- Array, Right - Scalar ---------\n+\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Scalar> valid_scalar, MakeScalar(type, 100));\n+  std::shared_ptr<Scalar> null_scalar = MakeNullScalar(type);\n+\n+  // empty\n+  CheckIfElseOutputAAS(type, \"[]\", \"[]\", valid_scalar, \"[]\");\n+\n+  // RLC = 111\n+  CheckIfElseOutputAAS(type, \"[true, true, true, false]\", \"[1, 2, 3, 4]\", valid_scalar,\n+                       \"[1, 2, 3, 100]\");\n+  // RLC = 110\n+  CheckIfElseOutputAAS(type, \"[true, true, null, false]\", \"[1, 2, 3, 4]\", valid_scalar,\n+                       \"[1, 2, null, 100]\", false);\n+  // RLC = 101\n+  CheckIfElseOutputAAS(type, \"[true, true, true, false]\", \"[1, null, 3, 4]\", valid_scalar,\n+                       \"[1, null, 3, 100]\", false);\n+  // RLC = 100\n+  CheckIfElseOutputAAS(type, \"[true, true, null, false]\", \"[1, null, 3, 4]\", valid_scalar,\n+                       \"[1, null, null, 100]\", false);\n\nReview comment:\n       Couldn't these cases be combined? e.g. `[true, true, null, null, false, false]`, `[1, null, 2, null, 3, null]`, and `valid_scalar` -> `[1, null, null, null, 100, null]`?\r\n   \r\n   And ditto overall.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else_test.cc\n##########\n@@ -0,0 +1,291 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/array.h>\n+#include <arrow/compute/api_scalar.h>\n+#include <arrow/compute/kernels/test_util.h>\n+#include <arrow/testing/gtest_util.h>\n+#include <gtest/gtest.h>\n+\n+namespace arrow {\n+namespace compute {\n+\n+void CheckIfElseOutputArray(const Datum& cond, const Datum& left, const Datum& right,\n+                            const Datum& expected, bool all_valid = true) {\n+  ASSERT_OK_AND_ASSIGN(Datum datum_out, IfElse(cond, left, right));\n+  std::shared_ptr<Array> result = datum_out.make_array();\n+  ASSERT_OK(result->ValidateFull());\n+  AssertArraysEqual(*expected.make_array(), *result, /*verbose=*/true);\n+  if (all_valid) {\n+    // Check null count of ArrayData is set, not the computed Array.null_count\n+    ASSERT_EQ(result->data()->null_count, 0);\n+  }\n+}\n+\n+void CheckIfElseOutputAAA(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::string& left, const std::string& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& left_ = ArrayFromJSON(type, left);\n+  const std::shared_ptr<Array>& right_ = ArrayFromJSON(type, right);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left_, right_, expected_, all_valid);\n+}\n+\n+void CheckIfElseOutputAAS(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::string& left, const std::shared_ptr<Scalar>& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& left_ = ArrayFromJSON(type, left);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left_, right, expected_, all_valid);\n+}\n+\n+void CheckIfElseOutputASA(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::shared_ptr<Scalar>& left, const std::string& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& right_ = ArrayFromJSON(type, right);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left, right_, expected_, all_valid);\n+}\n+\n+void CheckIfElseOutputASS(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::shared_ptr<Scalar>& left,\n+                          const std::shared_ptr<Scalar>& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left, right, expected_, all_valid);\n+}\n+\n+class TestIfElseKernel : public ::testing::Test {};\n+\n+template <typename Type>\n+class TestIfElsePrimitive : public ::testing::Test {};\n+\n+using PrimitiveTypes = ::testing::Types<Int8Type, UInt8Type, Int16Type, UInt16Type,\n+                                        Int32Type, UInt32Type, Int64Type, UInt64Type,\n+                                        FloatType, DoubleType, Date32Type, Date64Type>;\n+\n+TYPED_TEST_SUITE(TestIfElsePrimitive, PrimitiveTypes);\n+\n+TYPED_TEST(TestIfElsePrimitive, IfElseFixedSize) {\n+  auto type = TypeTraits<TypeParam>::type_singleton();\n+\n+  // No Nulls\n+  CheckIfElseOutputAAA(type, \"[]\", \"[]\", \"[]\", \"[]\");\n+\n+  // -------- All arrays ---------\n+  // RLC = 111\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, 2, 3, 4]\", \"[5, 6, 7, 8]\",\n+                       \"[1, 2, 3, 8]\");\n+  // RLC = 110\n+  CheckIfElseOutputAAA(type, \"[true, true, null, false]\", \"[1, 2, 3, 4]\", \"[5, 6, 7, 8]\",\n+                       \"[1, 2, null, 8]\", false);\n+  // RLC = 101\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, null, 3, 4]\",\n+                       \"[5, 6, 7, 8]\", \"[1, null, 3, 8]\", false);\n+  // RLC = 100\n+  CheckIfElseOutputAAA(type, \"[true, true, null, false]\", \"[1, null, 3, 4]\",\n+                       \"[5, 6, 7, 8]\", \"[1, null, null, 8]\", false);\n+  // RLC = 011\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, 2, 3, 4]\",\n+                       \"[5, 6, 7, null]\", \"[1, 2, 3, null]\", false);\n+  // RLC = 010\n+  CheckIfElseOutputAAA(type, \"[null, true, true, false]\", \"[1, 2, 3, 4]\",\n+                       \"[5, 6, 7, null]\", \"[null, 2, 3, null]\", false);\n+  // RLC = 001\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, 2, null, null]\",\n+                       \"[null, 6, 7, null]\", \"[1, 2, null, null]\", false);\n+  // RLC = 000\n+  CheckIfElseOutputAAA(type, \"[null, true, true, false]\", \"[1, 2, null, null]\",\n+                       \"[null, 6, 7, null]\", \"[null, 2, null, null]\", false);\n+\n+  using ArrayType = typename TypeTraits<TypeParam>::ArrayType;\n\nReview comment:\n       nit: do you mind extracting out the random array test into a separate test case?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,838 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+using internal::Bitmap;\n+\n+namespace compute {\n+\n+namespace {\n+\n+enum { COND_ALL_VALID = 1, LEFT_ALL_VALID = 2, RIGHT_ALL_VALID = 4 };\n+\n+// if the condition is null then output is null otherwise we take validity from the\n+// selected argument\n+// ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+Status PromoteNullsVisitor(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                           const Scalar& right, ArrayData* output) {\n+  uint8_t flag = right.is_valid * 4 + left.is_valid * 2 + !cond.MayHaveNulls();\n+\n+  if (flag < 6 && flag != 3) {\n\nReview comment:\n       You could move the allocation into the cases as well.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else_test.cc\n##########\n@@ -0,0 +1,291 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/array.h>\n+#include <arrow/compute/api_scalar.h>\n+#include <arrow/compute/kernels/test_util.h>\n+#include <arrow/testing/gtest_util.h>\n+#include <gtest/gtest.h>\n+\n+namespace arrow {\n+namespace compute {\n+\n+void CheckIfElseOutputArray(const Datum& cond, const Datum& left, const Datum& right,\n+                            const Datum& expected, bool all_valid = true) {\n+  ASSERT_OK_AND_ASSIGN(Datum datum_out, IfElse(cond, left, right));\n+  std::shared_ptr<Array> result = datum_out.make_array();\n+  ASSERT_OK(result->ValidateFull());\n+  AssertArraysEqual(*expected.make_array(), *result, /*verbose=*/true);\n+  if (all_valid) {\n+    // Check null count of ArrayData is set, not the computed Array.null_count\n+    ASSERT_EQ(result->data()->null_count, 0);\n+  }\n+}\n+\n+void CheckIfElseOutputAAA(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::string& left, const std::string& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& left_ = ArrayFromJSON(type, left);\n+  const std::shared_ptr<Array>& right_ = ArrayFromJSON(type, right);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left_, right_, expected_, all_valid);\n+}\n+\n+void CheckIfElseOutputAAS(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::string& left, const std::shared_ptr<Scalar>& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& left_ = ArrayFromJSON(type, left);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left_, right, expected_, all_valid);\n+}\n+\n+void CheckIfElseOutputASA(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::shared_ptr<Scalar>& left, const std::string& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& right_ = ArrayFromJSON(type, right);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left, right_, expected_, all_valid);\n+}\n+\n+void CheckIfElseOutputASS(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::shared_ptr<Scalar>& left,\n+                          const std::shared_ptr<Scalar>& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left, right, expected_, all_valid);\n+}\n+\n+class TestIfElseKernel : public ::testing::Test {};\n+\n+template <typename Type>\n+class TestIfElsePrimitive : public ::testing::Test {};\n+\n+using PrimitiveTypes = ::testing::Types<Int8Type, UInt8Type, Int16Type, UInt16Type,\n+                                        Int32Type, UInt32Type, Int64Type, UInt64Type,\n+                                        FloatType, DoubleType, Date32Type, Date64Type>;\n+\n+TYPED_TEST_SUITE(TestIfElsePrimitive, PrimitiveTypes);\n+\n+TYPED_TEST(TestIfElsePrimitive, IfElseFixedSize) {\n+  auto type = TypeTraits<TypeParam>::type_singleton();\n+\n+  // No Nulls\n+  CheckIfElseOutputAAA(type, \"[]\", \"[]\", \"[]\", \"[]\");\n+\n+  // -------- All arrays ---------\n+  // RLC = 111\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, 2, 3, 4]\", \"[5, 6, 7, 8]\",\n+                       \"[1, 2, 3, 8]\");\n+  // RLC = 110\n+  CheckIfElseOutputAAA(type, \"[true, true, null, false]\", \"[1, 2, 3, 4]\", \"[5, 6, 7, 8]\",\n+                       \"[1, 2, null, 8]\", false);\n+  // RLC = 101\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, null, 3, 4]\",\n+                       \"[5, 6, 7, 8]\", \"[1, null, 3, 8]\", false);\n+  // RLC = 100\n+  CheckIfElseOutputAAA(type, \"[true, true, null, false]\", \"[1, null, 3, 4]\",\n+                       \"[5, 6, 7, 8]\", \"[1, null, null, 8]\", false);\n+  // RLC = 011\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, 2, 3, 4]\",\n+                       \"[5, 6, 7, null]\", \"[1, 2, 3, null]\", false);\n+  // RLC = 010\n+  CheckIfElseOutputAAA(type, \"[null, true, true, false]\", \"[1, 2, 3, 4]\",\n+                       \"[5, 6, 7, null]\", \"[null, 2, 3, null]\", false);\n+  // RLC = 001\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, 2, null, null]\",\n+                       \"[null, 6, 7, null]\", \"[1, 2, null, null]\", false);\n+  // RLC = 000\n+  CheckIfElseOutputAAA(type, \"[null, true, true, false]\", \"[1, 2, null, null]\",\n+                       \"[null, 6, 7, null]\", \"[null, 2, null, null]\", false);\n+\n+  using ArrayType = typename TypeTraits<TypeParam>::ArrayType;\n+  random::RandomArrayGenerator rand(/*seed=*/0);\n+  int64_t len = 1000;\n+  auto cond = std::static_pointer_cast<BooleanArray>(\n+      rand.ArrayOf(boolean(), len, /*null_probability=*/0.01));\n+  auto left = std::static_pointer_cast<ArrayType>(\n+      rand.ArrayOf(type, len, /*null_probability=*/0.01));\n+  auto right = std::static_pointer_cast<ArrayType>(\n+      rand.ArrayOf(type, len, /*null_probability=*/0.01));\n+\n+  typename TypeTraits<TypeParam>::BuilderType builder;\n+\n+  for (int64_t i = 0; i < len; ++i) {\n+    if (!cond->IsValid(i) || (cond->Value(i) && !left->IsValid(i)) ||\n+        (!cond->Value(i) && !right->IsValid(i))) {\n+      ASSERT_OK(builder.AppendNull());\n+      continue;\n+    }\n+\n+    if (cond->Value(i)) {\n+      ASSERT_OK(builder.Append(left->Value(i)));\n+    } else {\n+      ASSERT_OK(builder.Append(right->Value(i)));\n+    }\n+  }\n+  ASSERT_OK_AND_ASSIGN(auto expected_data, builder.Finish());\n+\n+  CheckIfElseOutputArray(cond, left, right, expected_data, false);\n+\n+  // -------- Cond - Array, Left- Array, Right - Scalar ---------\n+\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Scalar> valid_scalar, MakeScalar(type, 100));\n+  std::shared_ptr<Scalar> null_scalar = MakeNullScalar(type);\n+\n+  // empty\n+  CheckIfElseOutputAAS(type, \"[]\", \"[]\", valid_scalar, \"[]\");\n+\n+  // RLC = 111\n+  CheckIfElseOutputAAS(type, \"[true, true, true, false]\", \"[1, 2, 3, 4]\", valid_scalar,\n+                       \"[1, 2, 3, 100]\");\n+  // RLC = 110\n+  CheckIfElseOutputAAS(type, \"[true, true, null, false]\", \"[1, 2, 3, 4]\", valid_scalar,\n+                       \"[1, 2, null, 100]\", false);\n+  // RLC = 101\n+  CheckIfElseOutputAAS(type, \"[true, true, true, false]\", \"[1, null, 3, 4]\", valid_scalar,\n+                       \"[1, null, 3, 100]\", false);\n+  // RLC = 100\n+  CheckIfElseOutputAAS(type, \"[true, true, null, false]\", \"[1, null, 3, 4]\", valid_scalar,\n+                       \"[1, null, null, 100]\", false);\n\nReview comment:\n       Ok, I see from above that it's about the validity of cond/left/right. IMO if you're going to abbreviate it, at least always write it as C/L/R since that's the order of the arguments.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,838 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+using internal::Bitmap;\n+\n+namespace compute {\n+\n+namespace {\n+\n+enum { COND_ALL_VALID = 1, LEFT_ALL_VALID = 2, RIGHT_ALL_VALID = 4 };\n+\n+// if the condition is null then output is null otherwise we take validity from the\n+// selected argument\n+// ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+Status PromoteNullsVisitor(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                           const Scalar& right, ArrayData* output) {\n+  uint8_t flag = right.is_valid * 4 + left.is_valid * 2 + !cond.MayHaveNulls();\n+\n+  if (flag < 6 && flag != 3) {\n+    // there will be a validity buffer in the output\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(cond.length));\n+  }\n+\n+  // if the condition is null then output is null otherwise we take validity from the\n+  // selected argument\n+  // ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+  switch (flag) {\n+    case COND_ALL_VALID | LEFT_ALL_VALID | RIGHT_ALL_VALID:  // = 7\n+      break;\n+    case LEFT_ALL_VALID | RIGHT_ALL_VALID:  // = 6\n+      // out_valid = c_valid\n+      output->buffers[0] = SliceBuffer(cond.buffers[0], cond.offset, cond.length);\n+      break;\n+    case COND_ALL_VALID | RIGHT_ALL_VALID:  // = 5\n+      // out_valid = ~cond.data\n+      arrow::internal::InvertBitmap(cond.buffers[1]->data(), cond.offset, cond.length,\n+                                    output->buffers[0]->mutable_data(), 0);\n+      break;\n+    case RIGHT_ALL_VALID:  // = 4\n+      // out_valid = c_valid & ~cond.data\n+      arrow::internal::BitmapAndNot(cond.buffers[0]->data(), cond.offset,\n+                                    cond.buffers[1]->data(), cond.offset, cond.length, 0,\n+                                    output->buffers[0]->mutable_data());\n+      break;\n+    case COND_ALL_VALID | LEFT_ALL_VALID:  // = 3\n+      // out_valid = cond.data\n+      output->buffers[0] = SliceBuffer(cond.buffers[1], cond.offset, cond.length);\n+      break;\n+    case LEFT_ALL_VALID:  // = 2\n+      // out_valid = cond.valid & cond.data\n+      arrow::internal::BitmapAnd(cond.buffers[0]->data(), cond.offset,\n+                                 cond.buffers[1]->data(), cond.offset, cond.length, 0,\n+                                 output->buffers[0]->mutable_data());\n+      break;\n+    case COND_ALL_VALID:  // = 1\n+      // out_valid = 0 --> nothing to do; but requires out_valid to be a all-zero buffer\n+      break;\n+    case 0:  // RLC = 000\n+      // out_valid = 0 --> nothing to do; but requires out_valid to be a all-zero buffer\n+      break;\n+  }\n+  return Status::OK();\n+}\n+\n+Status PromoteNullsVisitor(KernelContext* ctx, const ArrayData& cond,\n+                           const ArrayData& left, const Scalar& right,\n+                           ArrayData* output) {\n+  uint8_t flag = right.is_valid * 4 + !left.MayHaveNulls() * 2 + !cond.MayHaveNulls();\n+\n+  enum { C_VALID, C_DATA, L_VALID };\n+\n+  Bitmap bitmaps[3];\n+  bitmaps[C_VALID] = {cond.buffers[0], cond.offset, cond.length};\n+  bitmaps[C_DATA] = {cond.buffers[1], cond.offset, cond.length};\n+  bitmaps[L_VALID] = {left.buffers[0], left.offset, left.length};\n+\n+  uint64_t* out_validity = nullptr;\n+  if (flag < 6 && flag != 3) {\n+    // there will be a validity buffer in the output\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(cond.length));\n+    out_validity = output->GetMutableValues<uint64_t>(0);\n+  }\n+\n+  // lambda function that will be used inside the visitor\n+  int64_t i = 0;\n+  auto apply = [&](uint64_t c_valid, uint64_t c_data, uint64_t l_valid,\n+                   uint64_t r_valid) {\n+    out_validity[i] = c_valid & ((c_data & l_valid) | (~c_data & r_valid));\n+    i++;\n+  };\n+\n+  // if the condition is null then output is null otherwise we take validity from the\n+  // selected argument\n+  // ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+  switch (flag) {\n+    case COND_ALL_VALID | LEFT_ALL_VALID | RIGHT_ALL_VALID:  // RLC = 111\n+      break;\n+    case LEFT_ALL_VALID | RIGHT_ALL_VALID:  // RLC = 110\n+      output->buffers[0] = SliceBuffer(cond.buffers[0], cond.offset, cond.length);\n+      break;\n+    case COND_ALL_VALID | RIGHT_ALL_VALID:  // RLC = 101\n+      // bitmaps[C_VALID] might be null; override to make it safe for Visit()\n+      bitmaps[C_VALID] = bitmaps[C_DATA];\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 3> words) {\n+        apply(UINT64_MAX, words[C_DATA], words[L_VALID], UINT64_MAX);\n+      });\n+      break;\n+    case RIGHT_ALL_VALID:  // RLC = 100\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 3> words) {\n+        apply(words[C_VALID], words[C_DATA], words[L_VALID], UINT64_MAX);\n+      });\n+      break;\n+    case COND_ALL_VALID | LEFT_ALL_VALID:  // RLC = 011\n+      // only cond.data is passed\n+      output->buffers[0] = SliceBuffer(cond.buffers[1], cond.offset, cond.length);\n+      break;\n+    case LEFT_ALL_VALID:  // RLC = 010\n+      // out_valid = cond.valid & cond.data\n+      arrow::internal::BitmapAnd(cond.buffers[0]->data(), cond.offset,\n+                                 cond.buffers[1]->data(), cond.offset, cond.length, 0,\n+                                 output->buffers[0]->mutable_data());\n+      break;\n+    case COND_ALL_VALID:  // RLC = 001\n+      // out_valid = cond.data & left.valid\n+      arrow::internal::BitmapAnd(cond.buffers[1]->data(), cond.offset,\n+                                 left.buffers[0]->data(), left.offset, cond.length, 0,\n+                                 output->buffers[0]->mutable_data());\n+      break;\n+    case 0:  // RLC = 000\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 3> words) {\n+        apply(words[C_VALID], words[C_DATA], words[L_VALID], 0);\n+      });\n+      break;\n+  }\n+  return Status::OK();\n+}\n+\n+// if the condition is null then output is null otherwise we take validity from the\n+// selected argument\n+// ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+Status PromoteNullsVisitor(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                           const ArrayData& right, ArrayData* output) {\n+  uint8_t flag = !right.MayHaveNulls() * 4 + left.is_valid * 2 + !cond.MayHaveNulls();\n+\n+  enum { C_VALID, C_DATA, R_VALID };\n+\n+  Bitmap bitmaps[3];\n+  bitmaps[C_VALID] = {cond.buffers[0], cond.offset, cond.length};\n+  bitmaps[C_DATA] = {cond.buffers[1], cond.offset, cond.length};\n+  bitmaps[R_VALID] = {right.buffers[0], right.offset, right.length};\n+\n+  uint64_t* out_validity = nullptr;\n+  if (flag < 6) {\n+    // there will be a validity buffer in the output\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(cond.length));\n+    out_validity = output->GetMutableValues<uint64_t>(0);\n+  }\n+\n+  // lambda function that will be used inside the visitor\n+  int64_t i = 0;\n+  auto apply = [&](uint64_t c_valid, uint64_t c_data, uint64_t l_valid,\n+                   uint64_t r_valid) {\n+    out_validity[i] = c_valid & ((c_data & l_valid) | (~c_data & r_valid));\n+    i++;\n+  };\n+\n+  // if the condition is null then output is null otherwise we take validity from the\n+  // selected argument\n+  // ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+  switch (flag) {\n+    case COND_ALL_VALID | LEFT_ALL_VALID | RIGHT_ALL_VALID:  // RLC = 111\n+      break;\n+    case LEFT_ALL_VALID | RIGHT_ALL_VALID:  // RLC = 110\n+      output->buffers[0] = SliceBuffer(cond.buffers[0], cond.offset, cond.length);\n+      break;\n+    case COND_ALL_VALID | RIGHT_ALL_VALID:  // RLC = 101\n+      // out_valid = ~cond.data\n+      arrow::internal::InvertBitmap(cond.buffers[1]->data(), cond.offset, cond.length,\n+                                    output->buffers[0]->mutable_data(), 0);\n+      break;\n+    case RIGHT_ALL_VALID:  // RLC = 100\n+      // out_valid = c_valid & ~cond.data\n+      arrow::internal::BitmapAndNot(cond.buffers[0]->data(), cond.offset,\n+                                    cond.buffers[1]->data(), cond.offset, cond.length, 0,\n+                                    output->buffers[0]->mutable_data());\n+      break;\n+    case COND_ALL_VALID | LEFT_ALL_VALID:  // RLC = 011\n+      // bitmaps[C_VALID] might be null; override to make it safe for Visit()\n+      bitmaps[C_VALID] = bitmaps[C_DATA];\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 3> words) {\n+        apply(UINT64_MAX, words[C_DATA], UINT64_MAX, words[R_VALID]);\n+      });\n+      break;\n+    case LEFT_ALL_VALID:  // RLC = 010\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 3> words) {\n+        apply(words[C_VALID], words[C_DATA], UINT64_MAX, words[R_VALID]);\n+      });\n+      break;\n+    case COND_ALL_VALID:  // RLC = 001\n+      // out_valid =  ~cond.data & right.valid\n+      arrow::internal::BitmapAndNot(right.buffers[0]->data(), right.offset,\n+                                    cond.buffers[1]->data(), cond.offset, cond.length, 0,\n+                                    output->buffers[0]->mutable_data());\n+      break;\n+    case 0:  // RLC = 000\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 3> words) {\n+        apply(words[C_VALID], words[C_DATA], 0, words[R_VALID]);\n+      });\n+      break;\n+  }\n+  return Status::OK();\n+}\n+\n+// if the condition is null then output is null otherwise we take validity from the\n+// selected argument\n+// ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+Status PromoteNullsVisitor(KernelContext* ctx, const ArrayData& cond,\n+                           const ArrayData& left, const ArrayData& right,\n+                           ArrayData* output) {\n+  uint8_t flag =\n+      !right.MayHaveNulls() * 4 + !left.MayHaveNulls() * 2 + !cond.MayHaveNulls();\n+\n+  enum { C_VALID, C_DATA, L_VALID, R_VALID };\n+\n+  Bitmap bitmaps[4];\n+  bitmaps[C_VALID] = {cond.buffers[0], cond.offset, cond.length};\n+  bitmaps[C_DATA] = {cond.buffers[1], cond.offset, cond.length};\n+  bitmaps[L_VALID] = {left.buffers[0], left.offset, left.length};\n+  bitmaps[R_VALID] = {right.buffers[0], right.offset, right.length};\n+\n+  uint64_t* out_validity = nullptr;\n+  if (flag < 6) {\n+    // there will be a validity buffer in the output\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(cond.length));\n+    out_validity = output->GetMutableValues<uint64_t>(0);\n+  }\n+\n+  // lambda function that will be used inside the visitor\n+  int64_t i = 0;\n+  auto apply = [&](uint64_t c_valid, uint64_t c_data, uint64_t l_valid,\n+                   uint64_t r_valid) {\n+    out_validity[i] = c_valid & ((c_data & l_valid) | (~c_data & r_valid));\n+    i++;\n+  };\n+\n+  // if the condition is null then output is null otherwise we take validity from the\n+  // selected argument\n+  // ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+  switch (flag) {\n+    case COND_ALL_VALID | LEFT_ALL_VALID | RIGHT_ALL_VALID:  // RLC = 111\n+      break;\n+    case LEFT_ALL_VALID | RIGHT_ALL_VALID:  // RLC = 110\n+      output->buffers[0] = SliceBuffer(cond.buffers[0], cond.offset, cond.length);\n+      break;\n+    case COND_ALL_VALID | RIGHT_ALL_VALID:  // RLC = 101\n+      // bitmaps[C_VALID], bitmaps[R_VALID] might be null; override to make it safe for\n+      // Visit()\n+      bitmaps[C_VALID] = bitmaps[C_DATA];\n+      bitmaps[R_VALID] = bitmaps[C_DATA];\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n+        apply(UINT64_MAX, words[C_DATA], words[L_VALID], UINT64_MAX);\n+      });\n+      break;\n+    case RIGHT_ALL_VALID:  // RLC = 100\n+      // bitmaps[R_VALID] might be null; override to make it safe for Visit()\n+      bitmaps[R_VALID] = bitmaps[C_DATA];\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n+        apply(words[C_VALID], words[C_DATA], words[L_VALID], UINT64_MAX);\n+      });\n+      break;\n+    case COND_ALL_VALID | LEFT_ALL_VALID:  // RLC = 011\n+      // bitmaps[C_VALID], bitmaps[L_VALID] might be null; override to make it safe for\n+      // Visit()\n+      bitmaps[C_VALID] = bitmaps[C_DATA];\n+      bitmaps[L_VALID] = bitmaps[C_DATA];\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n+        apply(UINT64_MAX, words[C_DATA], UINT64_MAX, words[R_VALID]);\n+      });\n+      break;\n+    case LEFT_ALL_VALID:  // RLC = 010\n+      // bitmaps[L_VALID] might be null; override to make it safe for Visit()\n+      bitmaps[L_VALID] = bitmaps[C_DATA];\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n+        apply(words[C_VALID], words[C_DATA], UINT64_MAX, words[R_VALID]);\n+      });\n+      break;\n+    case COND_ALL_VALID:  // RLC = 001\n+      // bitmaps[C_VALID] might be null; override to make it safe for Visit()\n+      bitmaps[C_VALID] = bitmaps[C_DATA];\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n+        apply(UINT64_MAX, words[C_DATA], words[L_VALID], words[R_VALID]);\n+      });\n+      break;\n+    case 0:  // RLC = 000\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n+        apply(words[C_VALID], words[C_DATA], words[L_VALID], words[R_VALID]);\n+      });\n+      break;\n+  }\n+  return Status::OK();\n+}\n+\n+// nulls will be promoted as follows:\n+// cond.valid && (cond.data && left.valid || ~cond.data && right.valid)\n+// Note: we have to work on ArrayData. Otherwise we won't be able to handle array\n+// offsets AAA\n+/*Status PromoteNulls(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                    const ArrayData& right, ArrayData* output) {\n+  if (!cond.MayHaveNulls() && !left.MayHaveNulls() && !right.MayHaveNulls()) {\n+    return Status::OK();  // no nulls to handle\n+  }\n+  const int64_t len = cond.length;\n+\n+  // out_validity = ~cond.data --> mask right values\n+  ARROW_ASSIGN_OR_RAISE(\n+      std::shared_ptr<Buffer> out_validity,\n+      arrow::internal::InvertBitmap(ctx->memory_pool(), cond.buffers[1]->data(),\n+                                    cond.offset, len));\n+\n+  if (right.MayHaveNulls()) {  // out_validity = right.valid && ~cond.data\n+    arrow::internal::BitmapAnd(right.buffers[0]->data(), right.offset,\n+                               out_validity->data(), 0, len, 0,\n+                               out_validity->mutable_data());\n+  }\n+\n+  std::shared_ptr<Buffer> tmp_buf;\n+  if (left.MayHaveNulls()) {\n+    // tmp_buf = left.valid && cond.data\n+    ARROW_ASSIGN_OR_RAISE(\n+        tmp_buf, arrow::internal::BitmapAnd(ctx->memory_pool(), left.buffers[0]->data(),\n+                                            left.offset, cond.buffers[1]->data(),\n+                                            cond.offset, len, 0));\n+  } else {  // if left all valid --> tmp_buf = cond.data (zero copy slice)\n+    tmp_buf = SliceBuffer(cond.buffers[1], cond.offset, cond.length);\n+  }\n+\n+  // out_validity = cond.data && left.valid || ~cond.data && right.valid\n+  arrow::internal::BitmapOr(out_validity->data(), 0, tmp_buf->data(), 0, len, 0,\n+                            out_validity->mutable_data());\n+\n+  if (cond.MayHaveNulls()) {\n+    // out_validity = cond.valid && (cond.data && left.valid || ~cond.data && right.valid)\n+    ::arrow::internal::BitmapAnd(out_validity->data(), 0, cond.buffers[0]->data(),\n+                                 cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  output->buffers[0] = std::move(out_validity);\n+  output->GetNullCount();  // update null count\n+  return Status::OK();\n+}\n+\n+// cond.valid && (cond.data && left.valid || ~cond.data && right.valid)\n+// ASA and AAS\n+Status PromoteNulls(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                    const ArrayData& right, ArrayData* output) {\n+  if (!cond.MayHaveNulls() && left.is_valid && !right.MayHaveNulls()) {\n+    return Status::OK();  // no nulls to handle\n+  }\n+  const int64_t len = cond.length;\n+\n+  // out_validity = ~cond.data\n+  ARROW_ASSIGN_OR_RAISE(\n+      std::shared_ptr<Buffer> out_validity,\n+      arrow::internal::InvertBitmap(ctx->memory_pool(), cond.buffers[1]->data(),\n+                                    cond.offset, len));\n+  // out_validity = ~cond.data && right.valid\n+  if (right.MayHaveNulls()) {  // out_validity = right.valid && ~cond.data\n+    arrow::internal::BitmapAnd(right.buffers[0]->data(), right.offset,\n+                               out_validity->data(), 0, len, 0,\n+                               out_validity->mutable_data());\n+  }\n+\n+  // out_validity = cond.data && left.valid || ~cond.data && right.valid\n+  if (left.is_valid) {\n+    arrow::internal::BitmapOr(out_validity->data(), 0, cond.buffers[1]->data(),\n+                              cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  // out_validity = cond.valid && (cond.data && left.valid || ~cond.data && right.valid)\n+  if (cond.MayHaveNulls()) {\n+    ::arrow::internal::BitmapAnd(out_validity->data(), 0, cond.buffers[0]->data(),\n+                                 cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  output->buffers[0] = std::move(out_validity);\n+  output->GetNullCount();  // update null count\n+  return Status::OK();\n+}\n+\n+// cond.valid && (cond.data && left.valid || ~cond.data && right.valid)\n+// ASS\n+Status PromoteNulls(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                    const Scalar& right, ArrayData* output) {\n+  if (!cond.MayHaveNulls() && left.is_valid && right.is_valid) {\n+    return Status::OK();  // no nulls to handle\n+  }\n+  const int64_t len = cond.length;\n+\n+  std::shared_ptr<Buffer> out_validity;\n+  if (right.is_valid) {\n+    // out_validity = ~cond.data\n+    ARROW_ASSIGN_OR_RAISE(\n+        out_validity, arrow::internal::InvertBitmap(\n+                          ctx->memory_pool(), cond.buffers[1]->data(), cond.offset, len));\n+  } else {\n+    // out_validity = [0...]\n+    ARROW_ASSIGN_OR_RAISE(out_validity, ctx->AllocateBitmap(len));\n+  }\n+\n+  // out_validity = cond.data && left.valid || ~cond.data && right.valid\n+  if (left.is_valid) {\n+    arrow::internal::BitmapOr(out_validity->data(), 0, cond.buffers[1]->data(),\n+                              cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  // out_validity = cond.valid && (cond.data && left.valid || ~cond.data && right.valid)\n+  if (cond.MayHaveNulls()) {\n+    ::arrow::internal::BitmapAnd(out_validity->data(), 0, cond.buffers[0]->data(),\n+                                 cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  output->buffers[0] = std::move(out_validity);\n+  output->GetNullCount();  // update null count\n+  return Status::OK();\n+}\n+\n+// todo: this could be dangerous because the inverted arraydata buffer[1] may not be\n+//  available outside Exec's scope\n+Status InvertBoolArrayData(KernelContext* ctx, const ArrayData& input,\n+                           ArrayData* output) {\n+  // null buffer\n+  if (input.MayHaveNulls()) {\n+    output->buffers.emplace_back(\n+        SliceBuffer(input.buffers[0], input.offset, input.length));\n+  } else {\n+    output->buffers.push_back(NULLPTR);\n+  }\n+\n+  // data buffer\n+  ARROW_ASSIGN_OR_RAISE(\n+      std::shared_ptr<Buffer> inv_data,\n+      arrow::internal::InvertBitmap(ctx->memory_pool(), input.buffers[1]->data(),\n+                                    input.offset, input.length));\n+  output->buffers.emplace_back(std::move(inv_data));\n+  return Status::OK();\n+}\n+ */\n+\n+template <typename Type, typename Enable = void>\n+struct IfElseFunctor {};\n+\n+// only number types needs to be handled for Fixed sized primitive data types because,\n+// internal::GenerateTypeAgnosticPrimitive forwards types to the corresponding unsigned\n+// int type\n+template <typename Type>\n+struct IfElseFunctor<Type, enable_if_number<Type>> {\n+  using T = typename TypeTraits<Type>::CType;\n+  // A - Array\n+  // S - Scalar\n+\n+  //  AAA\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(PromoteNullsVisitor(ctx, cond, left, right, out));\n+\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          ctx->Allocate(cond.length * sizeof(T)));\n+    T* out_values = reinterpret_cast<T*>(out_buf->mutable_data());\n+\n+    // copy right data to out_buff\n+    const T* right_data = right.GetValues<T>(1);\n+    std::memcpy(out_values, right_data, right.length * sizeof(T));\n+\n+    const auto* cond_data = cond.buffers[1]->data();  // this is a BoolArray\n+    BitBlockCounter bit_counter(cond_data, cond.offset, cond.length);\n+\n+    // selectively copy values from left data\n+    const T* left_data = left.GetValues<T>(1);\n+    int64_t offset = cond.offset;\n+\n+    // todo this can be improved by intrinsics. ex: _mm*_mask_store_e* (vmovdqa*)\n+    while (offset < cond.offset + cond.length) {\n+      const BitBlockCount& block = bit_counter.NextWord();\n+      if (block.AllSet()) {  // all from left\n+        std::memcpy(out_values, left_data, block.length * sizeof(T));\n+      } else if (block.popcount) {  // selectively copy from left\n+        for (int64_t i = 0; i < block.length; ++i) {\n+          if (BitUtil::GetBit(cond_data, offset + i)) {\n+            out_values[i] = left_data[i];\n+          }\n+        }\n+      }\n+\n+      offset += block.length;\n+      out_values += block.length;\n+      left_data += block.length;\n+    }\n+\n+    out->buffers[1] = std::move(out_buf);\n+    return Status::OK();\n+  }\n+\n+  // ASA\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(PromoteNullsVisitor(ctx, cond, left, right, out));\n+\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          ctx->Allocate(cond.length * sizeof(T)));\n+    T* out_values = reinterpret_cast<T*>(out_buf->mutable_data());\n+\n+    // copy right data to out_buff\n+    const T* right_data = right.GetValues<T>(1);\n+    std::memcpy(out_values, right_data, right.length * sizeof(T));\n+\n+    const auto* cond_data = cond.buffers[1]->data();  // this is a BoolArray\n+    BitBlockCounter bit_counter(cond_data, cond.offset, cond.length);\n+\n+    // selectively copy values from left data\n+    T left_data = internal::UnboxScalar<Type>::Unbox(left);\n+    int64_t offset = cond.offset;\n+\n+    // todo this can be improved by intrinsics. ex: _mm*_mask_store_e* (vmovdqa*)\n+    while (offset < cond.offset + cond.length) {\n+      const BitBlockCount& block = bit_counter.NextWord();\n+      if (block.AllSet()) {  // all from left\n+        std::fill(out_values, out_values + block.length, left_data);\n+      } else if (block.popcount) {  // selectively copy from left\n+        for (int64_t i = 0; i < block.length; ++i) {\n+          if (BitUtil::GetBit(cond_data, offset + i)) {\n+            out_values[i] = left_data;\n+          }\n+        }\n+      }\n+\n+      offset += block.length;\n+      out_values += block.length;\n+    }\n+\n+    out->buffers[1] = std::move(out_buf);\n+    return Status::OK();\n+  }\n+\n+  // AAS\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const Scalar& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(PromoteNullsVisitor(ctx, cond, left, right, out));\n+\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          ctx->Allocate(cond.length * sizeof(T)));\n+    T* out_values = reinterpret_cast<T*>(out_buf->mutable_data());\n+\n+    // copy left data to out_buff\n+    const T* left_data = left.GetValues<T>(1);\n+    std::memcpy(out_values, left_data, left.length * sizeof(T));\n+\n+    const auto* cond_data = cond.buffers[1]->data();  // this is a BoolArray\n+    BitBlockCounter bit_counter(cond_data, cond.offset, cond.length);\n+\n+    // selectively copy values from left data\n+    T right_data = internal::UnboxScalar<Type>::Unbox(right);\n+    int64_t offset = cond.offset;\n+\n+    // todo this can be improved by intrinsics. ex: _mm*_mask_store_e* (vmovdqa*)\n+    // left data is already in the output buffer. Therefore, mask needs to be inverted\n+    while (offset < cond.offset + cond.length) {\n+      const BitBlockCount& block = bit_counter.NextWord();\n+      if (block.NoneSet()) {  // all from right\n+        std::fill(out_values, out_values + block.length, right_data);\n+      } else if (block.popcount) {  // selectively copy from right\n+        for (int64_t i = 0; i < block.length; ++i) {\n+          if (!BitUtil::GetBit(cond_data, offset + i)) {\n+            out_values[i] = right_data;\n+          }\n+        }\n+      }\n+\n+      offset += block.length;\n+      out_values += block.length;\n+    }\n+\n+    out->buffers[1] = std::move(out_buf);\n+    return Status::OK();\n+  }\n+\n+  // ASS\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                     const Scalar& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(PromoteNullsVisitor(ctx, cond, left, right, out));\n+\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          ctx->Allocate(cond.length * sizeof(T)));\n+    T* out_values = reinterpret_cast<T*>(out_buf->mutable_data());\n+\n+    // copy right data to out_buff\n+    T right_data = internal::UnboxScalar<Type>::Unbox(right);\n+    std::fill(out_values, out_values + cond.length, right_data);\n+\n+    const auto* cond_data = cond.buffers[1]->data();  // this is a BoolArray\n+    BitBlockCounter bit_counter(cond_data, cond.offset, cond.length);\n+\n+    // selectively copy values from left data\n+    T left_data = internal::UnboxScalar<Type>::Unbox(left);\n+    int64_t offset = cond.offset;\n+\n+    // todo this can be improved by intrinsics. ex: _mm*_mask_store_e* (vmovdqa*)\n+    while (offset < cond.offset + cond.length) {\n+      const BitBlockCount& block = bit_counter.NextWord();\n+      if (block.AllSet()) {  // all from left\n+        std::fill(out_values, out_values + block.length, left_data);\n+      } else if (block.popcount) {  // selectively copy from left\n+        for (int64_t i = 0; i < block.length; ++i) {\n+          if (BitUtil::GetBit(cond_data, offset + i)) {\n+            out_values[i] = left_data;\n+          }\n+        }\n+      }\n+\n+      offset += block.length;\n+      out_values += block.length;\n+    }\n+\n+    out->buffers[1] = std::move(out_buf);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct IfElseFunctor<Type, enable_if_boolean<Type>> {\n+  // AAA\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(PromoteNullsVisitor(ctx, cond, left, right, out));\n+\n+    // out_buff = right & ~cond\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          arrow::internal::BitmapAndNot(\n+                              ctx->memory_pool(), right.buffers[1]->data(), right.offset,\n+                              cond.buffers[1]->data(), cond.offset, cond.length, 0));\n+\n+    // out_buff = left & cond\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> temp_buf,\n+                          arrow::internal::BitmapAnd(\n+                              ctx->memory_pool(), left.buffers[1]->data(), left.offset,\n+                              cond.buffers[1]->data(), cond.offset, cond.length, 0));\n+\n+    arrow::internal::BitmapOr(out_buf->data(), 0, temp_buf->data(), 0, cond.length, 0,\n+                              out_buf->mutable_data());\n+    out->buffers[1] = std::move(out_buf);\n+    return Status::OK();\n+  }\n+\n+  // ASA\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(PromoteNullsVisitor(ctx, cond, left, right, out));\n+\n+    // out_buff = right & ~cond\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          arrow::internal::BitmapAndNot(\n+                              ctx->memory_pool(), right.buffers[1]->data(), right.offset,\n+                              cond.buffers[1]->data(), cond.offset, cond.length, 0));\n+\n+    // out_buff = left & cond\n+    bool left_data = internal::UnboxScalar<BooleanType>::Unbox(left);\n+    if (left_data) {\n+      arrow::internal::BitmapOr(out_buf->data(), 0, cond.buffers[1]->data(), cond.offset,\n+                                cond.length, 0, out_buf->mutable_data());\n+    }\n+\n+    out->buffers[1] = std::move(out_buf);\n+    return Status::OK();\n+  }\n+\n+  // AAS\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const Scalar& right, ArrayData* out) {\n+    // todo impl\n+    return Status::OK();\n+  }\n+\n+  // ASS\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                     const Scalar& right, ArrayData* out) {\n+    // todo impl\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct IfElseFunctor<Type, enable_if_null<Type>> {\n+  template <typename T>\n+  static inline Status ReturnCopy(const T& in, T* out) {\n+    // Nothing preallocated, so we assign in into the output\n+    *out = in;\n+    return Status::OK();\n+  }\n+\n+  // AAA\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    return ReturnCopy(left, out);\n+  }\n+\n+  // ASA\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    return ReturnCopy(right, out);\n+  }\n+\n+  // AAS\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const Scalar& right, ArrayData* out) {\n+    return ReturnCopy(left, out);\n+  }\n+\n+  // ASS\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                     const Scalar& right, ArrayData* out) {\n+    return ReturnCopy(cond, out);\n+  }\n+};\n+\n+template <typename Type>\n+struct ResolveIfElseExec {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // cond is scalar\n\nReview comment:\n       Scalar conditions don't seem tested below?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-27T11:49:07.444+0000",
                    "updated": "2021-05-27T11:49:07.444+0000",
                    "started": "2021-05-27T11:49:07.444+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "602912",
                    "issueId": "13341287"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/602946",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10410:\nURL: https://github.com/apache/arrow/pull/10410#discussion_r640584062\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else_test.cc\n##########\n@@ -0,0 +1,291 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/array.h>\n+#include <arrow/compute/api_scalar.h>\n+#include <arrow/compute/kernels/test_util.h>\n+#include <arrow/testing/gtest_util.h>\n+#include <gtest/gtest.h>\n+\n+namespace arrow {\n+namespace compute {\n+\n+void CheckIfElseOutputArray(const Datum& cond, const Datum& left, const Datum& right,\n+                            const Datum& expected, bool all_valid = true) {\n+  ASSERT_OK_AND_ASSIGN(Datum datum_out, IfElse(cond, left, right));\n+  std::shared_ptr<Array> result = datum_out.make_array();\n+  ASSERT_OK(result->ValidateFull());\n+  AssertArraysEqual(*expected.make_array(), *result, /*verbose=*/true);\n+  if (all_valid) {\n+    // Check null count of ArrayData is set, not the computed Array.null_count\n+    ASSERT_EQ(result->data()->null_count, 0);\n+  }\n+}\n+\n+void CheckIfElseOutputAAA(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::string& left, const std::string& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& left_ = ArrayFromJSON(type, left);\n+  const std::shared_ptr<Array>& right_ = ArrayFromJSON(type, right);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left_, right_, expected_, all_valid);\n+}\n+\n+void CheckIfElseOutputAAS(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::string& left, const std::shared_ptr<Scalar>& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& left_ = ArrayFromJSON(type, left);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left_, right, expected_, all_valid);\n+}\n+\n+void CheckIfElseOutputASA(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::shared_ptr<Scalar>& left, const std::string& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& right_ = ArrayFromJSON(type, right);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left, right_, expected_, all_valid);\n+}\n+\n+void CheckIfElseOutputASS(const std::shared_ptr<DataType>& type, const std::string& cond,\n+                          const std::shared_ptr<Scalar>& left,\n+                          const std::shared_ptr<Scalar>& right,\n+                          const std::string& expected, bool all_valid = true) {\n+  const std::shared_ptr<Array>& cond_ = ArrayFromJSON(boolean(), cond);\n+  const std::shared_ptr<Array>& expected_ = ArrayFromJSON(type, expected);\n+  CheckIfElseOutputArray(cond_, left, right, expected_, all_valid);\n+}\n+\n+class TestIfElseKernel : public ::testing::Test {};\n+\n+template <typename Type>\n+class TestIfElsePrimitive : public ::testing::Test {};\n+\n+using PrimitiveTypes = ::testing::Types<Int8Type, UInt8Type, Int16Type, UInt16Type,\n+                                        Int32Type, UInt32Type, Int64Type, UInt64Type,\n+                                        FloatType, DoubleType, Date32Type, Date64Type>;\n+\n+TYPED_TEST_SUITE(TestIfElsePrimitive, PrimitiveTypes);\n+\n+TYPED_TEST(TestIfElsePrimitive, IfElseFixedSize) {\n+  auto type = TypeTraits<TypeParam>::type_singleton();\n+\n+  // No Nulls\n+  CheckIfElseOutputAAA(type, \"[]\", \"[]\", \"[]\", \"[]\");\n+\n+  // -------- All arrays ---------\n+  // RLC = 111\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, 2, 3, 4]\", \"[5, 6, 7, 8]\",\n+                       \"[1, 2, 3, 8]\");\n+  // RLC = 110\n+  CheckIfElseOutputAAA(type, \"[true, true, null, false]\", \"[1, 2, 3, 4]\", \"[5, 6, 7, 8]\",\n+                       \"[1, 2, null, 8]\", false);\n+  // RLC = 101\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, null, 3, 4]\",\n+                       \"[5, 6, 7, 8]\", \"[1, null, 3, 8]\", false);\n+  // RLC = 100\n+  CheckIfElseOutputAAA(type, \"[true, true, null, false]\", \"[1, null, 3, 4]\",\n+                       \"[5, 6, 7, 8]\", \"[1, null, null, 8]\", false);\n+  // RLC = 011\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, 2, 3, 4]\",\n+                       \"[5, 6, 7, null]\", \"[1, 2, 3, null]\", false);\n+  // RLC = 010\n+  CheckIfElseOutputAAA(type, \"[null, true, true, false]\", \"[1, 2, 3, 4]\",\n+                       \"[5, 6, 7, null]\", \"[null, 2, 3, null]\", false);\n+  // RLC = 001\n+  CheckIfElseOutputAAA(type, \"[true, true, true, false]\", \"[1, 2, null, null]\",\n+                       \"[null, 6, 7, null]\", \"[1, 2, null, null]\", false);\n+  // RLC = 000\n+  CheckIfElseOutputAAA(type, \"[null, true, true, false]\", \"[1, 2, null, null]\",\n+                       \"[null, 6, 7, null]\", \"[null, 2, null, null]\", false);\n+\n+  using ArrayType = typename TypeTraits<TypeParam>::ArrayType;\n+  random::RandomArrayGenerator rand(/*seed=*/0);\n+  int64_t len = 1000;\n+  auto cond = std::static_pointer_cast<BooleanArray>(\n+      rand.ArrayOf(boolean(), len, /*null_probability=*/0.01));\n+  auto left = std::static_pointer_cast<ArrayType>(\n+      rand.ArrayOf(type, len, /*null_probability=*/0.01));\n+  auto right = std::static_pointer_cast<ArrayType>(\n+      rand.ArrayOf(type, len, /*null_probability=*/0.01));\n+\n+  typename TypeTraits<TypeParam>::BuilderType builder;\n+\n+  for (int64_t i = 0; i < len; ++i) {\n+    if (!cond->IsValid(i) || (cond->Value(i) && !left->IsValid(i)) ||\n+        (!cond->Value(i) && !right->IsValid(i))) {\n+      ASSERT_OK(builder.AppendNull());\n+      continue;\n+    }\n+\n+    if (cond->Value(i)) {\n+      ASSERT_OK(builder.Append(left->Value(i)));\n+    } else {\n+      ASSERT_OK(builder.Append(right->Value(i)));\n+    }\n+  }\n+  ASSERT_OK_AND_ASSIGN(auto expected_data, builder.Finish());\n+\n+  CheckIfElseOutputArray(cond, left, right, expected_data, false);\n+\n+  // -------- Cond - Array, Left- Array, Right - Scalar ---------\n+\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Scalar> valid_scalar, MakeScalar(type, 100));\n+  std::shared_ptr<Scalar> null_scalar = MakeNullScalar(type);\n+\n+  // empty\n+  CheckIfElseOutputAAS(type, \"[]\", \"[]\", valid_scalar, \"[]\");\n+\n+  // RLC = 111\n+  CheckIfElseOutputAAS(type, \"[true, true, true, false]\", \"[1, 2, 3, 4]\", valid_scalar,\n+                       \"[1, 2, 3, 100]\");\n+  // RLC = 110\n+  CheckIfElseOutputAAS(type, \"[true, true, null, false]\", \"[1, 2, 3, 4]\", valid_scalar,\n+                       \"[1, 2, null, 100]\", false);\n+  // RLC = 101\n+  CheckIfElseOutputAAS(type, \"[true, true, true, false]\", \"[1, null, 3, 4]\", valid_scalar,\n+                       \"[1, null, 3, 100]\", false);\n+  // RLC = 100\n+  CheckIfElseOutputAAS(type, \"[true, true, null, false]\", \"[1, null, 3, 4]\", valid_scalar,\n+                       \"[1, null, null, 100]\", false);\n\nReview comment:\n       Ah, and these probably can't be combined as you want to test null handling for different cases as well. Ok, got it.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-27T12:41:11.114+0000",
                    "updated": "2021-05-27T12:41:11.114+0000",
                    "started": "2021-05-27T12:41:11.114+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "602946",
                    "issueId": "13341287"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/603021",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on a change in pull request #10410:\nURL: https://github.com/apache/arrow/pull/10410#discussion_r640660867\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,838 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+using internal::Bitmap;\n+\n+namespace compute {\n+\n+namespace {\n+\n+enum { COND_ALL_VALID = 1, LEFT_ALL_VALID = 2, RIGHT_ALL_VALID = 4 };\n+\n+// if the condition is null then output is null otherwise we take validity from the\n+// selected argument\n+// ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+Status PromoteNullsVisitor(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                           const Scalar& right, ArrayData* output) {\n+  uint8_t flag = right.is_valid * 4 + left.is_valid * 2 + !cond.MayHaveNulls();\n+\n+  if (flag < 6 && flag != 3) {\n+    // there will be a validity buffer in the output\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(cond.length));\n+  }\n+\n+  // if the condition is null then output is null otherwise we take validity from the\n+  // selected argument\n+  // ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+  switch (flag) {\n+    case COND_ALL_VALID | LEFT_ALL_VALID | RIGHT_ALL_VALID:  // = 7\n+      break;\n+    case LEFT_ALL_VALID | RIGHT_ALL_VALID:  // = 6\n+      // out_valid = c_valid\n+      output->buffers[0] = SliceBuffer(cond.buffers[0], cond.offset, cond.length);\n+      break;\n+    case COND_ALL_VALID | RIGHT_ALL_VALID:  // = 5\n+      // out_valid = ~cond.data\n+      arrow::internal::InvertBitmap(cond.buffers[1]->data(), cond.offset, cond.length,\n+                                    output->buffers[0]->mutable_data(), 0);\n+      break;\n+    case RIGHT_ALL_VALID:  // = 4\n+      // out_valid = c_valid & ~cond.data\n+      arrow::internal::BitmapAndNot(cond.buffers[0]->data(), cond.offset,\n+                                    cond.buffers[1]->data(), cond.offset, cond.length, 0,\n+                                    output->buffers[0]->mutable_data());\n+      break;\n+    case COND_ALL_VALID | LEFT_ALL_VALID:  // = 3\n+      // out_valid = cond.data\n+      output->buffers[0] = SliceBuffer(cond.buffers[1], cond.offset, cond.length);\n+      break;\n+    case LEFT_ALL_VALID:  // = 2\n+      // out_valid = cond.valid & cond.data\n+      arrow::internal::BitmapAnd(cond.buffers[0]->data(), cond.offset,\n+                                 cond.buffers[1]->data(), cond.offset, cond.length, 0,\n+                                 output->buffers[0]->mutable_data());\n+      break;\n+    case COND_ALL_VALID:  // = 1\n+      // out_valid = 0 --> nothing to do; but requires out_valid to be a all-zero buffer\n\nReview comment:\n       I think there is a mismatch in the kernel comment and the impl. \r\n   https://github.com/apache/arrow/blob/29130ca54cd773f6f52e17bc78d37fb72d53eb49/cpp/src/arrow/compute/kernel.cc#L56\r\n   It looks like it is zeroed out for bitmaps\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-27T14:09:37.601+0000",
                    "updated": "2021-05-27T14:09:37.601+0000",
                    "started": "2021-05-27T14:09:37.601+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "603021",
                    "issueId": "13341287"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/603022",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on a change in pull request #10410:\nURL: https://github.com/apache/arrow/pull/10410#discussion_r640662054\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,838 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+using internal::Bitmap;\n+\n+namespace compute {\n+\n+namespace {\n+\n+enum { COND_ALL_VALID = 1, LEFT_ALL_VALID = 2, RIGHT_ALL_VALID = 4 };\n+\n+// if the condition is null then output is null otherwise we take validity from the\n+// selected argument\n+// ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+Status PromoteNullsVisitor(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                           const Scalar& right, ArrayData* output) {\n+  uint8_t flag = right.is_valid * 4 + left.is_valid * 2 + !cond.MayHaveNulls();\n+\n+  if (flag < 6 && flag != 3) {\n\nReview comment:\n       Idea is to allocate buffer only for 5 cases. but yes, I will do that \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-27T14:10:51.439+0000",
                    "updated": "2021-05-27T14:10:51.439+0000",
                    "started": "2021-05-27T14:10:51.438+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "603022",
                    "issueId": "13341287"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/603025",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on a change in pull request #10410:\nURL: https://github.com/apache/arrow/pull/10410#discussion_r640664833\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,838 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+using internal::Bitmap;\n+\n+namespace compute {\n+\n+namespace {\n+\n+enum { COND_ALL_VALID = 1, LEFT_ALL_VALID = 2, RIGHT_ALL_VALID = 4 };\n+\n+// if the condition is null then output is null otherwise we take validity from the\n+// selected argument\n+// ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+Status PromoteNullsVisitor(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                           const Scalar& right, ArrayData* output) {\n+  uint8_t flag = right.is_valid * 4 + left.is_valid * 2 + !cond.MayHaveNulls();\n+\n+  if (flag < 6 && flag != 3) {\n+    // there will be a validity buffer in the output\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(cond.length));\n+  }\n+\n+  // if the condition is null then output is null otherwise we take validity from the\n+  // selected argument\n+  // ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+  switch (flag) {\n+    case COND_ALL_VALID | LEFT_ALL_VALID | RIGHT_ALL_VALID:  // = 7\n+      break;\n+    case LEFT_ALL_VALID | RIGHT_ALL_VALID:  // = 6\n+      // out_valid = c_valid\n+      output->buffers[0] = SliceBuffer(cond.buffers[0], cond.offset, cond.length);\n+      break;\n+    case COND_ALL_VALID | RIGHT_ALL_VALID:  // = 5\n+      // out_valid = ~cond.data\n+      arrow::internal::InvertBitmap(cond.buffers[1]->data(), cond.offset, cond.length,\n+                                    output->buffers[0]->mutable_data(), 0);\n+      break;\n+    case RIGHT_ALL_VALID:  // = 4\n+      // out_valid = c_valid & ~cond.data\n+      arrow::internal::BitmapAndNot(cond.buffers[0]->data(), cond.offset,\n+                                    cond.buffers[1]->data(), cond.offset, cond.length, 0,\n+                                    output->buffers[0]->mutable_data());\n+      break;\n+    case COND_ALL_VALID | LEFT_ALL_VALID:  // = 3\n+      // out_valid = cond.data\n+      output->buffers[0] = SliceBuffer(cond.buffers[1], cond.offset, cond.length);\n+      break;\n+    case LEFT_ALL_VALID:  // = 2\n+      // out_valid = cond.valid & cond.data\n+      arrow::internal::BitmapAnd(cond.buffers[0]->data(), cond.offset,\n+                                 cond.buffers[1]->data(), cond.offset, cond.length, 0,\n+                                 output->buffers[0]->mutable_data());\n+      break;\n+    case COND_ALL_VALID:  // = 1\n+      // out_valid = 0 --> nothing to do; but requires out_valid to be a all-zero buffer\n+      break;\n+    case 0:  // RLC = 000\n+      // out_valid = 0 --> nothing to do; but requires out_valid to be a all-zero buffer\n+      break;\n+  }\n+  return Status::OK();\n+}\n+\n+Status PromoteNullsVisitor(KernelContext* ctx, const ArrayData& cond,\n+                           const ArrayData& left, const Scalar& right,\n+                           ArrayData* output) {\n+  uint8_t flag = right.is_valid * 4 + !left.MayHaveNulls() * 2 + !cond.MayHaveNulls();\n+\n+  enum { C_VALID, C_DATA, L_VALID };\n+\n+  Bitmap bitmaps[3];\n+  bitmaps[C_VALID] = {cond.buffers[0], cond.offset, cond.length};\n+  bitmaps[C_DATA] = {cond.buffers[1], cond.offset, cond.length};\n+  bitmaps[L_VALID] = {left.buffers[0], left.offset, left.length};\n+\n+  uint64_t* out_validity = nullptr;\n+  if (flag < 6 && flag != 3) {\n+    // there will be a validity buffer in the output\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(cond.length));\n+    out_validity = output->GetMutableValues<uint64_t>(0);\n+  }\n+\n+  // lambda function that will be used inside the visitor\n+  int64_t i = 0;\n+  auto apply = [&](uint64_t c_valid, uint64_t c_data, uint64_t l_valid,\n+                   uint64_t r_valid) {\n+    out_validity[i] = c_valid & ((c_data & l_valid) | (~c_data & r_valid));\n+    i++;\n+  };\n+\n+  // if the condition is null then output is null otherwise we take validity from the\n+  // selected argument\n+  // ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+  switch (flag) {\n+    case COND_ALL_VALID | LEFT_ALL_VALID | RIGHT_ALL_VALID:  // RLC = 111\n+      break;\n+    case LEFT_ALL_VALID | RIGHT_ALL_VALID:  // RLC = 110\n+      output->buffers[0] = SliceBuffer(cond.buffers[0], cond.offset, cond.length);\n+      break;\n+    case COND_ALL_VALID | RIGHT_ALL_VALID:  // RLC = 101\n+      // bitmaps[C_VALID] might be null; override to make it safe for Visit()\n+      bitmaps[C_VALID] = bitmaps[C_DATA];\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 3> words) {\n+        apply(UINT64_MAX, words[C_DATA], words[L_VALID], UINT64_MAX);\n+      });\n+      break;\n+    case RIGHT_ALL_VALID:  // RLC = 100\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 3> words) {\n+        apply(words[C_VALID], words[C_DATA], words[L_VALID], UINT64_MAX);\n+      });\n+      break;\n+    case COND_ALL_VALID | LEFT_ALL_VALID:  // RLC = 011\n+      // only cond.data is passed\n+      output->buffers[0] = SliceBuffer(cond.buffers[1], cond.offset, cond.length);\n+      break;\n+    case LEFT_ALL_VALID:  // RLC = 010\n+      // out_valid = cond.valid & cond.data\n+      arrow::internal::BitmapAnd(cond.buffers[0]->data(), cond.offset,\n+                                 cond.buffers[1]->data(), cond.offset, cond.length, 0,\n+                                 output->buffers[0]->mutable_data());\n+      break;\n+    case COND_ALL_VALID:  // RLC = 001\n+      // out_valid = cond.data & left.valid\n+      arrow::internal::BitmapAnd(cond.buffers[1]->data(), cond.offset,\n+                                 left.buffers[0]->data(), left.offset, cond.length, 0,\n+                                 output->buffers[0]->mutable_data());\n+      break;\n+    case 0:  // RLC = 000\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 3> words) {\n+        apply(words[C_VALID], words[C_DATA], words[L_VALID], 0);\n+      });\n+      break;\n+  }\n+  return Status::OK();\n+}\n+\n+// if the condition is null then output is null otherwise we take validity from the\n+// selected argument\n+// ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+Status PromoteNullsVisitor(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                           const ArrayData& right, ArrayData* output) {\n+  uint8_t flag = !right.MayHaveNulls() * 4 + left.is_valid * 2 + !cond.MayHaveNulls();\n+\n+  enum { C_VALID, C_DATA, R_VALID };\n+\n+  Bitmap bitmaps[3];\n+  bitmaps[C_VALID] = {cond.buffers[0], cond.offset, cond.length};\n+  bitmaps[C_DATA] = {cond.buffers[1], cond.offset, cond.length};\n+  bitmaps[R_VALID] = {right.buffers[0], right.offset, right.length};\n+\n+  uint64_t* out_validity = nullptr;\n+  if (flag < 6) {\n+    // there will be a validity buffer in the output\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(cond.length));\n+    out_validity = output->GetMutableValues<uint64_t>(0);\n+  }\n+\n+  // lambda function that will be used inside the visitor\n+  int64_t i = 0;\n+  auto apply = [&](uint64_t c_valid, uint64_t c_data, uint64_t l_valid,\n+                   uint64_t r_valid) {\n+    out_validity[i] = c_valid & ((c_data & l_valid) | (~c_data & r_valid));\n+    i++;\n+  };\n+\n+  // if the condition is null then output is null otherwise we take validity from the\n+  // selected argument\n+  // ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+  switch (flag) {\n+    case COND_ALL_VALID | LEFT_ALL_VALID | RIGHT_ALL_VALID:  // RLC = 111\n+      break;\n+    case LEFT_ALL_VALID | RIGHT_ALL_VALID:  // RLC = 110\n+      output->buffers[0] = SliceBuffer(cond.buffers[0], cond.offset, cond.length);\n+      break;\n+    case COND_ALL_VALID | RIGHT_ALL_VALID:  // RLC = 101\n+      // out_valid = ~cond.data\n+      arrow::internal::InvertBitmap(cond.buffers[1]->data(), cond.offset, cond.length,\n+                                    output->buffers[0]->mutable_data(), 0);\n+      break;\n+    case RIGHT_ALL_VALID:  // RLC = 100\n+      // out_valid = c_valid & ~cond.data\n+      arrow::internal::BitmapAndNot(cond.buffers[0]->data(), cond.offset,\n+                                    cond.buffers[1]->data(), cond.offset, cond.length, 0,\n+                                    output->buffers[0]->mutable_data());\n+      break;\n+    case COND_ALL_VALID | LEFT_ALL_VALID:  // RLC = 011\n+      // bitmaps[C_VALID] might be null; override to make it safe for Visit()\n+      bitmaps[C_VALID] = bitmaps[C_DATA];\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 3> words) {\n+        apply(UINT64_MAX, words[C_DATA], UINT64_MAX, words[R_VALID]);\n+      });\n+      break;\n+    case LEFT_ALL_VALID:  // RLC = 010\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 3> words) {\n+        apply(words[C_VALID], words[C_DATA], UINT64_MAX, words[R_VALID]);\n+      });\n+      break;\n+    case COND_ALL_VALID:  // RLC = 001\n+      // out_valid =  ~cond.data & right.valid\n+      arrow::internal::BitmapAndNot(right.buffers[0]->data(), right.offset,\n+                                    cond.buffers[1]->data(), cond.offset, cond.length, 0,\n+                                    output->buffers[0]->mutable_data());\n+      break;\n+    case 0:  // RLC = 000\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 3> words) {\n+        apply(words[C_VALID], words[C_DATA], 0, words[R_VALID]);\n+      });\n+      break;\n+  }\n+  return Status::OK();\n+}\n+\n+// if the condition is null then output is null otherwise we take validity from the\n+// selected argument\n+// ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+Status PromoteNullsVisitor(KernelContext* ctx, const ArrayData& cond,\n+                           const ArrayData& left, const ArrayData& right,\n+                           ArrayData* output) {\n+  uint8_t flag =\n+      !right.MayHaveNulls() * 4 + !left.MayHaveNulls() * 2 + !cond.MayHaveNulls();\n+\n+  enum { C_VALID, C_DATA, L_VALID, R_VALID };\n+\n+  Bitmap bitmaps[4];\n+  bitmaps[C_VALID] = {cond.buffers[0], cond.offset, cond.length};\n+  bitmaps[C_DATA] = {cond.buffers[1], cond.offset, cond.length};\n+  bitmaps[L_VALID] = {left.buffers[0], left.offset, left.length};\n+  bitmaps[R_VALID] = {right.buffers[0], right.offset, right.length};\n+\n+  uint64_t* out_validity = nullptr;\n+  if (flag < 6) {\n+    // there will be a validity buffer in the output\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(cond.length));\n+    out_validity = output->GetMutableValues<uint64_t>(0);\n+  }\n+\n+  // lambda function that will be used inside the visitor\n+  int64_t i = 0;\n+  auto apply = [&](uint64_t c_valid, uint64_t c_data, uint64_t l_valid,\n+                   uint64_t r_valid) {\n+    out_validity[i] = c_valid & ((c_data & l_valid) | (~c_data & r_valid));\n+    i++;\n+  };\n+\n+  // if the condition is null then output is null otherwise we take validity from the\n+  // selected argument\n+  // ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+  switch (flag) {\n+    case COND_ALL_VALID | LEFT_ALL_VALID | RIGHT_ALL_VALID:  // RLC = 111\n+      break;\n+    case LEFT_ALL_VALID | RIGHT_ALL_VALID:  // RLC = 110\n+      output->buffers[0] = SliceBuffer(cond.buffers[0], cond.offset, cond.length);\n+      break;\n+    case COND_ALL_VALID | RIGHT_ALL_VALID:  // RLC = 101\n+      // bitmaps[C_VALID], bitmaps[R_VALID] might be null; override to make it safe for\n+      // Visit()\n+      bitmaps[C_VALID] = bitmaps[C_DATA];\n+      bitmaps[R_VALID] = bitmaps[C_DATA];\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n+        apply(UINT64_MAX, words[C_DATA], words[L_VALID], UINT64_MAX);\n+      });\n+      break;\n+    case RIGHT_ALL_VALID:  // RLC = 100\n+      // bitmaps[R_VALID] might be null; override to make it safe for Visit()\n+      bitmaps[R_VALID] = bitmaps[C_DATA];\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n+        apply(words[C_VALID], words[C_DATA], words[L_VALID], UINT64_MAX);\n+      });\n+      break;\n+    case COND_ALL_VALID | LEFT_ALL_VALID:  // RLC = 011\n+      // bitmaps[C_VALID], bitmaps[L_VALID] might be null; override to make it safe for\n+      // Visit()\n+      bitmaps[C_VALID] = bitmaps[C_DATA];\n+      bitmaps[L_VALID] = bitmaps[C_DATA];\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n+        apply(UINT64_MAX, words[C_DATA], UINT64_MAX, words[R_VALID]);\n+      });\n+      break;\n+    case LEFT_ALL_VALID:  // RLC = 010\n+      // bitmaps[L_VALID] might be null; override to make it safe for Visit()\n+      bitmaps[L_VALID] = bitmaps[C_DATA];\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n+        apply(words[C_VALID], words[C_DATA], UINT64_MAX, words[R_VALID]);\n+      });\n+      break;\n+    case COND_ALL_VALID:  // RLC = 001\n+      // bitmaps[C_VALID] might be null; override to make it safe for Visit()\n+      bitmaps[C_VALID] = bitmaps[C_DATA];\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n+        apply(UINT64_MAX, words[C_DATA], words[L_VALID], words[R_VALID]);\n+      });\n+      break;\n+    case 0:  // RLC = 000\n+      Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n+        apply(words[C_VALID], words[C_DATA], words[L_VALID], words[R_VALID]);\n+      });\n+      break;\n+  }\n+  return Status::OK();\n+}\n+\n+// nulls will be promoted as follows:\n+// cond.valid && (cond.data && left.valid || ~cond.data && right.valid)\n+// Note: we have to work on ArrayData. Otherwise we won't be able to handle array\n+// offsets AAA\n+/*Status PromoteNulls(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                    const ArrayData& right, ArrayData* output) {\n+  if (!cond.MayHaveNulls() && !left.MayHaveNulls() && !right.MayHaveNulls()) {\n+    return Status::OK();  // no nulls to handle\n+  }\n+  const int64_t len = cond.length;\n+\n+  // out_validity = ~cond.data --> mask right values\n+  ARROW_ASSIGN_OR_RAISE(\n+      std::shared_ptr<Buffer> out_validity,\n+      arrow::internal::InvertBitmap(ctx->memory_pool(), cond.buffers[1]->data(),\n+                                    cond.offset, len));\n+\n+  if (right.MayHaveNulls()) {  // out_validity = right.valid && ~cond.data\n+    arrow::internal::BitmapAnd(right.buffers[0]->data(), right.offset,\n+                               out_validity->data(), 0, len, 0,\n+                               out_validity->mutable_data());\n+  }\n+\n+  std::shared_ptr<Buffer> tmp_buf;\n+  if (left.MayHaveNulls()) {\n+    // tmp_buf = left.valid && cond.data\n+    ARROW_ASSIGN_OR_RAISE(\n+        tmp_buf, arrow::internal::BitmapAnd(ctx->memory_pool(), left.buffers[0]->data(),\n+                                            left.offset, cond.buffers[1]->data(),\n+                                            cond.offset, len, 0));\n+  } else {  // if left all valid --> tmp_buf = cond.data (zero copy slice)\n+    tmp_buf = SliceBuffer(cond.buffers[1], cond.offset, cond.length);\n+  }\n+\n+  // out_validity = cond.data && left.valid || ~cond.data && right.valid\n+  arrow::internal::BitmapOr(out_validity->data(), 0, tmp_buf->data(), 0, len, 0,\n+                            out_validity->mutable_data());\n+\n+  if (cond.MayHaveNulls()) {\n+    // out_validity = cond.valid && (cond.data && left.valid || ~cond.data && right.valid)\n+    ::arrow::internal::BitmapAnd(out_validity->data(), 0, cond.buffers[0]->data(),\n+                                 cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  output->buffers[0] = std::move(out_validity);\n+  output->GetNullCount();  // update null count\n+  return Status::OK();\n+}\n+\n+// cond.valid && (cond.data && left.valid || ~cond.data && right.valid)\n+// ASA and AAS\n+Status PromoteNulls(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                    const ArrayData& right, ArrayData* output) {\n+  if (!cond.MayHaveNulls() && left.is_valid && !right.MayHaveNulls()) {\n+    return Status::OK();  // no nulls to handle\n+  }\n+  const int64_t len = cond.length;\n+\n+  // out_validity = ~cond.data\n+  ARROW_ASSIGN_OR_RAISE(\n+      std::shared_ptr<Buffer> out_validity,\n+      arrow::internal::InvertBitmap(ctx->memory_pool(), cond.buffers[1]->data(),\n+                                    cond.offset, len));\n+  // out_validity = ~cond.data && right.valid\n+  if (right.MayHaveNulls()) {  // out_validity = right.valid && ~cond.data\n+    arrow::internal::BitmapAnd(right.buffers[0]->data(), right.offset,\n+                               out_validity->data(), 0, len, 0,\n+                               out_validity->mutable_data());\n+  }\n+\n+  // out_validity = cond.data && left.valid || ~cond.data && right.valid\n+  if (left.is_valid) {\n+    arrow::internal::BitmapOr(out_validity->data(), 0, cond.buffers[1]->data(),\n+                              cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  // out_validity = cond.valid && (cond.data && left.valid || ~cond.data && right.valid)\n+  if (cond.MayHaveNulls()) {\n+    ::arrow::internal::BitmapAnd(out_validity->data(), 0, cond.buffers[0]->data(),\n+                                 cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  output->buffers[0] = std::move(out_validity);\n+  output->GetNullCount();  // update null count\n+  return Status::OK();\n+}\n+\n+// cond.valid && (cond.data && left.valid || ~cond.data && right.valid)\n+// ASS\n+Status PromoteNulls(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                    const Scalar& right, ArrayData* output) {\n+  if (!cond.MayHaveNulls() && left.is_valid && right.is_valid) {\n+    return Status::OK();  // no nulls to handle\n+  }\n+  const int64_t len = cond.length;\n+\n+  std::shared_ptr<Buffer> out_validity;\n+  if (right.is_valid) {\n+    // out_validity = ~cond.data\n+    ARROW_ASSIGN_OR_RAISE(\n+        out_validity, arrow::internal::InvertBitmap(\n+                          ctx->memory_pool(), cond.buffers[1]->data(), cond.offset, len));\n+  } else {\n+    // out_validity = [0...]\n+    ARROW_ASSIGN_OR_RAISE(out_validity, ctx->AllocateBitmap(len));\n+  }\n+\n+  // out_validity = cond.data && left.valid || ~cond.data && right.valid\n+  if (left.is_valid) {\n+    arrow::internal::BitmapOr(out_validity->data(), 0, cond.buffers[1]->data(),\n+                              cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  // out_validity = cond.valid && (cond.data && left.valid || ~cond.data && right.valid)\n+  if (cond.MayHaveNulls()) {\n+    ::arrow::internal::BitmapAnd(out_validity->data(), 0, cond.buffers[0]->data(),\n+                                 cond.offset, len, 0, out_validity->mutable_data());\n+  }\n+\n+  output->buffers[0] = std::move(out_validity);\n+  output->GetNullCount();  // update null count\n+  return Status::OK();\n+}\n+\n+// todo: this could be dangerous because the inverted arraydata buffer[1] may not be\n+//  available outside Exec's scope\n+Status InvertBoolArrayData(KernelContext* ctx, const ArrayData& input,\n+                           ArrayData* output) {\n+  // null buffer\n+  if (input.MayHaveNulls()) {\n+    output->buffers.emplace_back(\n+        SliceBuffer(input.buffers[0], input.offset, input.length));\n+  } else {\n+    output->buffers.push_back(NULLPTR);\n+  }\n+\n+  // data buffer\n+  ARROW_ASSIGN_OR_RAISE(\n+      std::shared_ptr<Buffer> inv_data,\n+      arrow::internal::InvertBitmap(ctx->memory_pool(), input.buffers[1]->data(),\n+                                    input.offset, input.length));\n+  output->buffers.emplace_back(std::move(inv_data));\n+  return Status::OK();\n+}\n+ */\n+\n+template <typename Type, typename Enable = void>\n+struct IfElseFunctor {};\n+\n+// only number types needs to be handled for Fixed sized primitive data types because,\n+// internal::GenerateTypeAgnosticPrimitive forwards types to the corresponding unsigned\n+// int type\n+template <typename Type>\n+struct IfElseFunctor<Type, enable_if_number<Type>> {\n+  using T = typename TypeTraits<Type>::CType;\n+  // A - Array\n+  // S - Scalar\n+\n+  //  AAA\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(PromoteNullsVisitor(ctx, cond, left, right, out));\n+\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          ctx->Allocate(cond.length * sizeof(T)));\n+    T* out_values = reinterpret_cast<T*>(out_buf->mutable_data());\n+\n+    // copy right data to out_buff\n+    const T* right_data = right.GetValues<T>(1);\n+    std::memcpy(out_values, right_data, right.length * sizeof(T));\n+\n+    const auto* cond_data = cond.buffers[1]->data();  // this is a BoolArray\n+    BitBlockCounter bit_counter(cond_data, cond.offset, cond.length);\n+\n+    // selectively copy values from left data\n+    const T* left_data = left.GetValues<T>(1);\n+    int64_t offset = cond.offset;\n+\n+    // todo this can be improved by intrinsics. ex: _mm*_mask_store_e* (vmovdqa*)\n+    while (offset < cond.offset + cond.length) {\n+      const BitBlockCount& block = bit_counter.NextWord();\n+      if (block.AllSet()) {  // all from left\n+        std::memcpy(out_values, left_data, block.length * sizeof(T));\n+      } else if (block.popcount) {  // selectively copy from left\n+        for (int64_t i = 0; i < block.length; ++i) {\n+          if (BitUtil::GetBit(cond_data, offset + i)) {\n+            out_values[i] = left_data[i];\n+          }\n+        }\n+      }\n+\n+      offset += block.length;\n+      out_values += block.length;\n+      left_data += block.length;\n+    }\n+\n+    out->buffers[1] = std::move(out_buf);\n+    return Status::OK();\n+  }\n+\n+  // ASA\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(PromoteNullsVisitor(ctx, cond, left, right, out));\n+\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          ctx->Allocate(cond.length * sizeof(T)));\n+    T* out_values = reinterpret_cast<T*>(out_buf->mutable_data());\n+\n+    // copy right data to out_buff\n+    const T* right_data = right.GetValues<T>(1);\n+    std::memcpy(out_values, right_data, right.length * sizeof(T));\n+\n+    const auto* cond_data = cond.buffers[1]->data();  // this is a BoolArray\n+    BitBlockCounter bit_counter(cond_data, cond.offset, cond.length);\n+\n+    // selectively copy values from left data\n+    T left_data = internal::UnboxScalar<Type>::Unbox(left);\n+    int64_t offset = cond.offset;\n+\n+    // todo this can be improved by intrinsics. ex: _mm*_mask_store_e* (vmovdqa*)\n+    while (offset < cond.offset + cond.length) {\n+      const BitBlockCount& block = bit_counter.NextWord();\n+      if (block.AllSet()) {  // all from left\n+        std::fill(out_values, out_values + block.length, left_data);\n+      } else if (block.popcount) {  // selectively copy from left\n+        for (int64_t i = 0; i < block.length; ++i) {\n+          if (BitUtil::GetBit(cond_data, offset + i)) {\n+            out_values[i] = left_data;\n+          }\n+        }\n+      }\n+\n+      offset += block.length;\n+      out_values += block.length;\n+    }\n+\n+    out->buffers[1] = std::move(out_buf);\n+    return Status::OK();\n+  }\n+\n+  // AAS\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const Scalar& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(PromoteNullsVisitor(ctx, cond, left, right, out));\n+\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          ctx->Allocate(cond.length * sizeof(T)));\n+    T* out_values = reinterpret_cast<T*>(out_buf->mutable_data());\n+\n+    // copy left data to out_buff\n+    const T* left_data = left.GetValues<T>(1);\n+    std::memcpy(out_values, left_data, left.length * sizeof(T));\n+\n+    const auto* cond_data = cond.buffers[1]->data();  // this is a BoolArray\n+    BitBlockCounter bit_counter(cond_data, cond.offset, cond.length);\n+\n+    // selectively copy values from left data\n+    T right_data = internal::UnboxScalar<Type>::Unbox(right);\n+    int64_t offset = cond.offset;\n+\n+    // todo this can be improved by intrinsics. ex: _mm*_mask_store_e* (vmovdqa*)\n+    // left data is already in the output buffer. Therefore, mask needs to be inverted\n+    while (offset < cond.offset + cond.length) {\n+      const BitBlockCount& block = bit_counter.NextWord();\n+      if (block.NoneSet()) {  // all from right\n+        std::fill(out_values, out_values + block.length, right_data);\n+      } else if (block.popcount) {  // selectively copy from right\n+        for (int64_t i = 0; i < block.length; ++i) {\n+          if (!BitUtil::GetBit(cond_data, offset + i)) {\n+            out_values[i] = right_data;\n+          }\n+        }\n+      }\n+\n+      offset += block.length;\n+      out_values += block.length;\n+    }\n+\n+    out->buffers[1] = std::move(out_buf);\n+    return Status::OK();\n+  }\n+\n+  // ASS\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                     const Scalar& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(PromoteNullsVisitor(ctx, cond, left, right, out));\n+\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          ctx->Allocate(cond.length * sizeof(T)));\n+    T* out_values = reinterpret_cast<T*>(out_buf->mutable_data());\n+\n+    // copy right data to out_buff\n+    T right_data = internal::UnboxScalar<Type>::Unbox(right);\n+    std::fill(out_values, out_values + cond.length, right_data);\n+\n+    const auto* cond_data = cond.buffers[1]->data();  // this is a BoolArray\n+    BitBlockCounter bit_counter(cond_data, cond.offset, cond.length);\n+\n+    // selectively copy values from left data\n+    T left_data = internal::UnboxScalar<Type>::Unbox(left);\n+    int64_t offset = cond.offset;\n+\n+    // todo this can be improved by intrinsics. ex: _mm*_mask_store_e* (vmovdqa*)\n+    while (offset < cond.offset + cond.length) {\n+      const BitBlockCount& block = bit_counter.NextWord();\n+      if (block.AllSet()) {  // all from left\n+        std::fill(out_values, out_values + block.length, left_data);\n+      } else if (block.popcount) {  // selectively copy from left\n+        for (int64_t i = 0; i < block.length; ++i) {\n+          if (BitUtil::GetBit(cond_data, offset + i)) {\n+            out_values[i] = left_data;\n+          }\n+        }\n+      }\n+\n+      offset += block.length;\n+      out_values += block.length;\n+    }\n+\n+    out->buffers[1] = std::move(out_buf);\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct IfElseFunctor<Type, enable_if_boolean<Type>> {\n+  // AAA\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(PromoteNullsVisitor(ctx, cond, left, right, out));\n+\n+    // out_buff = right & ~cond\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          arrow::internal::BitmapAndNot(\n+                              ctx->memory_pool(), right.buffers[1]->data(), right.offset,\n+                              cond.buffers[1]->data(), cond.offset, cond.length, 0));\n+\n+    // out_buff = left & cond\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> temp_buf,\n+                          arrow::internal::BitmapAnd(\n+                              ctx->memory_pool(), left.buffers[1]->data(), left.offset,\n+                              cond.buffers[1]->data(), cond.offset, cond.length, 0));\n+\n+    arrow::internal::BitmapOr(out_buf->data(), 0, temp_buf->data(), 0, cond.length, 0,\n+                              out_buf->mutable_data());\n+    out->buffers[1] = std::move(out_buf);\n+    return Status::OK();\n+  }\n+\n+  // ASA\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    ARROW_RETURN_NOT_OK(PromoteNullsVisitor(ctx, cond, left, right, out));\n+\n+    // out_buff = right & ~cond\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Buffer> out_buf,\n+                          arrow::internal::BitmapAndNot(\n+                              ctx->memory_pool(), right.buffers[1]->data(), right.offset,\n+                              cond.buffers[1]->data(), cond.offset, cond.length, 0));\n+\n+    // out_buff = left & cond\n+    bool left_data = internal::UnboxScalar<BooleanType>::Unbox(left);\n+    if (left_data) {\n+      arrow::internal::BitmapOr(out_buf->data(), 0, cond.buffers[1]->data(), cond.offset,\n+                                cond.length, 0, out_buf->mutable_data());\n+    }\n+\n+    out->buffers[1] = std::move(out_buf);\n+    return Status::OK();\n+  }\n+\n+  // AAS\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const Scalar& right, ArrayData* out) {\n+    // todo impl\n+    return Status::OK();\n+  }\n+\n+  // ASS\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                     const Scalar& right, ArrayData* out) {\n+    // todo impl\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct IfElseFunctor<Type, enable_if_null<Type>> {\n+  template <typename T>\n+  static inline Status ReturnCopy(const T& in, T* out) {\n+    // Nothing preallocated, so we assign in into the output\n+    *out = in;\n+    return Status::OK();\n+  }\n+\n+  // AAA\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    return ReturnCopy(left, out);\n+  }\n+\n+  // ASA\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                     const ArrayData& right, ArrayData* out) {\n+    return ReturnCopy(right, out);\n+  }\n+\n+  // AAS\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const ArrayData& left,\n+                     const Scalar& right, ArrayData* out) {\n+    return ReturnCopy(left, out);\n+  }\n+\n+  // ASS\n+  static Status Call(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                     const Scalar& right, ArrayData* out) {\n+    return ReturnCopy(cond, out);\n+  }\n+};\n+\n+template <typename Type>\n+struct ResolveIfElseExec {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // cond is scalar\n\nReview comment:\n       yep.. still didnt add that. So, there are 4^3 = 64 (each param can be `all_valid_array, array_with_nulls, valid_scalar, null_scalar`) test cases for a single type-category :grin: \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-27T14:14:03.554+0000",
                    "updated": "2021-05-27T14:14:03.554+0000",
                    "started": "2021-05-27T14:14:03.554+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "603025",
                    "issueId": "13341287"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/worklog/603065",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10410:\nURL: https://github.com/apache/arrow/pull/10410#discussion_r640711551\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -0,0 +1,838 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/compute/api.h>\n+#include <arrow/util/bit_block_counter.h>\n+#include <arrow/util/bitmap.h>\n+#include <arrow/util/bitmap_ops.h>\n+\n+#include \"codegen_internal.h\"\n+\n+namespace arrow {\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+using internal::Bitmap;\n+\n+namespace compute {\n+\n+namespace {\n+\n+enum { COND_ALL_VALID = 1, LEFT_ALL_VALID = 2, RIGHT_ALL_VALID = 4 };\n+\n+// if the condition is null then output is null otherwise we take validity from the\n+// selected argument\n+// ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+Status PromoteNullsVisitor(KernelContext* ctx, const ArrayData& cond, const Scalar& left,\n+                           const Scalar& right, ArrayData* output) {\n+  uint8_t flag = right.is_valid * 4 + left.is_valid * 2 + !cond.MayHaveNulls();\n+\n+  if (flag < 6 && flag != 3) {\n+    // there will be a validity buffer in the output\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(cond.length));\n+  }\n+\n+  // if the condition is null then output is null otherwise we take validity from the\n+  // selected argument\n+  // ie. cond.valid & (cond.data & left.valid | ~cond.data & right.valid)\n+  switch (flag) {\n+    case COND_ALL_VALID | LEFT_ALL_VALID | RIGHT_ALL_VALID:  // = 7\n+      break;\n+    case LEFT_ALL_VALID | RIGHT_ALL_VALID:  // = 6\n+      // out_valid = c_valid\n+      output->buffers[0] = SliceBuffer(cond.buffers[0], cond.offset, cond.length);\n+      break;\n+    case COND_ALL_VALID | RIGHT_ALL_VALID:  // = 5\n+      // out_valid = ~cond.data\n+      arrow::internal::InvertBitmap(cond.buffers[1]->data(), cond.offset, cond.length,\n+                                    output->buffers[0]->mutable_data(), 0);\n+      break;\n+    case RIGHT_ALL_VALID:  // = 4\n+      // out_valid = c_valid & ~cond.data\n+      arrow::internal::BitmapAndNot(cond.buffers[0]->data(), cond.offset,\n+                                    cond.buffers[1]->data(), cond.offset, cond.length, 0,\n+                                    output->buffers[0]->mutable_data());\n+      break;\n+    case COND_ALL_VALID | LEFT_ALL_VALID:  // = 3\n+      // out_valid = cond.data\n+      output->buffers[0] = SliceBuffer(cond.buffers[1], cond.offset, cond.length);\n+      break;\n+    case LEFT_ALL_VALID:  // = 2\n+      // out_valid = cond.valid & cond.data\n+      arrow::internal::BitmapAnd(cond.buffers[0]->data(), cond.offset,\n+                                 cond.buffers[1]->data(), cond.offset, cond.length, 0,\n+                                 output->buffers[0]->mutable_data());\n+      break;\n+    case COND_ALL_VALID:  // = 1\n+      // out_valid = 0 --> nothing to do; but requires out_valid to be a all-zero buffer\n\nReview comment:\n       Hmm, we should probably update comment then. CC @bkietz given KernelContext::AllocateBitmap has to zero the allocation to satisfy Valgrind et al, should we just go ahead and guarantee that it returns a pre-cleared bitmap?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-27T15:03:08.845+0000",
                    "updated": "2021-05-27T15:03:08.845+0000",
                    "started": "2021-05-27T15:03:08.844+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "603065",
                    "issueId": "13341287"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 38400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@7a6bf602[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2e6efff3[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@126b8dcb[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@4b237912[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7639ddde[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@6c80be9a[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@22cb6314[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@72f065b6[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4a1f811b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@230282ac[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5aa8861b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@2b04952d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 38400,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Jun 03 18:19:24 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-06-03T18:19:24.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10640/watchers",
            "watchCount": 6,
            "isWatching": false
        },
        "created": "2020-11-18T10:04:51.000+0000",
        "updated": "2021-07-02T08:22:47.000+0000",
        "timeoriginalestimate": null,
        "description": "(from discussion in ARROW-9489 with [~maartenbreddels])\r\n\r\nA general \"where\" kernel like {{np.where}} (https://numpy.org/doc/stable/reference/generated/numpy.where.html) seems a generally useful kernel to have, and could also help mimicking some other python (setitem-like) operations. \r\n\r\nThe concrete use case in ARROW-9489 is to basically do a {{fill_null(array[string], array[string])}} which could be expressed as {{where(is_null(arr), arr2, arr)}}. ",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "10h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 38400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] An \"if_else\" kernel to combine two arrays based on a mask",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/comment/17234451",
                    "id": "17234451",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "A boolean entry can be true, false or null. Shouldn't the kernel combine three arrays? (of course, you're free to pass the same input twice).",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2020-11-18T10:11:50.080+0000",
                    "updated": "2020-11-18T10:11:50.080+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/comment/17234481",
                    "id": "17234481",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=maartenbreddels",
                        "name": "maartenbreddels",
                        "key": "maartenbreddels",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Maarten Breddels",
                        "active": true,
                        "timeZone": "Europe/Amsterdam"
                    },
                    "body": "Another idea would be to have a 'choose' like kernel [https://numpy.org/doc/stable/reference/generated/numpy.choose.html]\u00a0\r\n\r\n`choose(array[int], a0, a1, ... an)` where the first argument should be indices referring to array aX. `where` could then be implemented by casting the boolean to an int.\r\n\r\nSomething that might also be interesting would be to 'zip' the arguments. Something like this:\r\n\r\n\u00a0\r\n{code:java}\r\ncondition # boolean array\r\nar        # some array of length N\r\nassert len(condition) == len(ar)\r\n\r\nar1 = ar.filter(condition)\r\nar2 = ar.filter(pc.invert(condition))\r\nx1 = expensive_calculation1(ar1)\r\nx2 = expensive_calculation2(ar2)\r\nassert len(x1) + len(x2) == len(ar)\r\nx = pc.zip(condition, x1, x2) # length N again{code}\r\n\u00a0This would allow for a vectorized ternary like operation equivalent to\r\n{code:java}\r\n[expensive_calculation1(ar[i]) if condition[i] else expensive_calculation2(ar[i]) for i in range(len(ar))]{code}\r\n\u00a0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=maartenbreddels",
                        "name": "maartenbreddels",
                        "key": "maartenbreddels",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Maarten Breddels",
                        "active": true,
                        "timeZone": "Europe/Amsterdam"
                    },
                    "created": "2020-11-18T10:59:41.457+0000",
                    "updated": "2020-11-18T10:59:41.457+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/comment/17235523",
                    "id": "17235523",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "body": "bq. A boolean entry can be true, false or null. Shouldn't the kernel combine three arrays? (of course, you're free to pass the same input twice).\r\n\r\nYes, that's indeed a possibility. Now, I think we could also decide that a null in the mask (or the indices) becomes a null in the output (I suppose the 3-arrays approach is more generally flexible, but might also be less performant compared to simply propagating the validity bitmask?)\r\n\r\n---\r\n\r\n{{np.choose}} indeed sounds as a generalization of where. No idea how much it is used though, and if it would be worth the added complexity compared to {{np.where}} (although it might not be that more complex)\r\n\r\nThe \"zip\" seems useful as well. Basically you could say it is the same as \"where\", but where the arrays only have those number of elements as needed to fill in the output array. In that sense, could also have such a generalized zip (or interleave), similarly as \"choose\" generalizes \"where\": {{zip(array[int], x1, x2, ..., xn)}} using an array of indices instead of a boolean mask.\r\n\r\n\r\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "created": "2020-11-19T14:42:55.460+0000",
                    "updated": "2020-11-19T14:43:06.881+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/comment/17235563",
                    "id": "17235563",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=maartenbreddels",
                        "name": "maartenbreddels",
                        "key": "maartenbreddels",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Maarten Breddels",
                        "active": true,
                        "timeZone": "Europe/Amsterdam"
                    },
                    "body": "Yes, that would maybe be the 'ultimate' variant, but I think the integer variation would be quite difficult to implement compared to the booleans, which only has to deal with 2 arrays.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=maartenbreddels",
                        "name": "maartenbreddels",
                        "key": "maartenbreddels",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Maarten Breddels",
                        "active": true,
                        "timeZone": "Europe/Amsterdam"
                    },
                    "created": "2020-11-19T16:12:40.289+0000",
                    "updated": "2020-11-19T16:12:40.289+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/comment/17235569",
                    "id": "17235569",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
                        "name": "npr",
                        "key": "npr",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Neal Richardson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "In R this is called {{ifelse}} https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/ifelse",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
                        "name": "npr",
                        "key": "npr",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Neal Richardson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2020-11-19T16:14:39.578+0000",
                    "updated": "2020-11-19T16:14:39.578+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/comment/17237243",
                    "id": "17237243",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "body": "And in SQL, this is related to a \"CASE WHEN\" clause: https://www.postgresqltutorial.com/postgresql-case/ (although here you can provide multiple boolean conditions, and it's also using expressions instead of actual boolean masks, but that's something to optimize only when there is a query engine)",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "created": "2020-11-23T09:25:18.707+0000",
                    "updated": "2020-11-23T09:25:18.707+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/comment/17259143",
                    "id": "17259143",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "body": "Note there is some discussion about this on https://github.com/apache/arrow/pull/9024",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "created": "2021-01-05T19:04:29.480+0000",
                    "updated": "2021-01-05T19:04:29.480+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/comment/17346972",
                    "id": "17346972",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "I think to summarize the discussion (including from the PR), we can call this {{if_else}} which uses a Boolean mask to select from one of two input arrays/scalars.\r\n\r\nA null mask value outputs a null.\r\n\r\nA True mask value outputs the LHS scalar/corresponding value from the LHS array.\r\n\r\nA False mask value outputs the RHS scalar/corresponding value from the RHS value.\r\n\r\nHence:\r\n{noformat}\r\nif_else([True, False, null], 1, 0) -> [1, 0, null]\r\nif_else([True, False, null], null, 0) -> [null, 0, null]\r\nif_else([True, False, null], 1, null) -> [1, null, null{noformat}\r\nWe can file separate issues for CASE WHEN/choose.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-05-18T14:46:11.384+0000",
                    "updated": "2021-05-18T14:46:50.914+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341287/comment/17356636",
                    "id": "17356636",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 10410\n[https://github.com/apache/arrow/pull/10410]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-06-03T18:19:24.984+0000",
                    "updated": "2021-06-03T18:19:24.984+0000"
                }
            ],
            "maxResults": 9,
            "total": 9,
            "startAt": 0
        },
        "customfield_12311820": "0|z0kpcw:",
        "customfield_12314139": null
    }
}