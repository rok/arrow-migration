{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13196854",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13196854",
    "key": "ARROW-3716",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343858",
                "id": "12343858",
                "description": "",
                "name": "0.12.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-01-20"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=romainfrancois",
            "name": "romainfrancois",
            "key": "romainfrancois",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=romainfrancois&avatarId=35092",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=romainfrancois&avatarId=35092",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=romainfrancois&avatarId=35092",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=romainfrancois&avatarId=35092"
            },
            "displayName": "Romain Francois",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333008",
                "id": "12333008",
                "name": "R"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=romainfrancois",
            "name": "romainfrancois",
            "key": "romainfrancois",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=romainfrancois&avatarId=35092",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=romainfrancois&avatarId=35092",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=romainfrancois&avatarId=35092",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=romainfrancois&avatarId=35092"
            },
            "displayName": "Romain Francois",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=romainfrancois",
            "name": "romainfrancois",
            "key": "romainfrancois",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=romainfrancois&avatarId=35092",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=romainfrancois&avatarId=35092",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=romainfrancois&avatarId=35092",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=romainfrancois&avatarId=35092"
            },
            "displayName": "Romain Francois",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 3000,
            "total": 3000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 3000,
            "total": 3000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3716/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 6,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13196854/worklog/164429",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois opened a new pull request #2928: ARROW-3716: [R] Missing cases for ChunkedArray conversion\nURL: https://github.com/apache/arrow/pull/2928\n \n \n   *WIP* and will need some more testing of support of various chunked_array. There's also some room for less code duplication. \r\n   \r\n   But I'll need that before I can follow up on the feather support. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-09T17:23:40.364+0000",
                    "updated": "2018-11-09T17:23:40.364+0000",
                    "started": "2018-11-09T17:23:40.363+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "164429",
                    "issueId": "13196854"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13196854/worklog/164455",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "codecov-io commented on issue #2928: ARROW-3716: [R] Missing cases for ChunkedArray conversion\nURL: https://github.com/apache/arrow/pull/2928#issuecomment-437446212\n \n \n   # [Codecov](https://codecov.io/gh/apache/arrow/pull/2928?src=pr&el=h1) Report\n   > Merging [#2928](https://codecov.io/gh/apache/arrow/pull/2928?src=pr&el=desc) into [master](https://codecov.io/gh/apache/arrow/commit/3ae41615fb086bd021ddcc44bd2b9e00eb265493?src=pr&el=desc) will **increase** coverage by `0.96%`.\n   > The diff coverage is `n/a`.\n   \n   [![Impacted file tree graph](https://codecov.io/gh/apache/arrow/pull/2928/graphs/tree.svg?width=650&token=LpTCFbqVT1&height=150&src=pr)](https://codecov.io/gh/apache/arrow/pull/2928?src=pr&el=tree)\n   \n   ```diff\n   @@            Coverage Diff             @@\n   ##           master    #2928      +/-   ##\n   ==========================================\n   + Coverage    86.2%   87.16%   +0.96%     \n   ==========================================\n     Files         490      422      -68     \n     Lines       68611    63451    -5160     \n   ==========================================\n   - Hits        59143    55307    -3836     \n   + Misses       9374     8144    -1230     \n   + Partials       94        0      -94\n   ```\n   \n   \n   | [Impacted Files](https://codecov.io/gh/apache/arrow/pull/2928?src=pr&el=tree) | Coverage \u0394 | |\n   |---|---|---|\n   | [rust/src/record\\_batch.rs](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-cnVzdC9zcmMvcmVjb3JkX2JhdGNoLnJz) | | |\n   | [go/arrow/array/table.go](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-Z28vYXJyb3cvYXJyYXkvdGFibGUuZ28=) | | |\n   | [rust/src/array.rs](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-cnVzdC9zcmMvYXJyYXkucnM=) | | |\n   | [go/arrow/math/uint64\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWF0aC91aW50NjRfYW1kNjQuZ28=) | | |\n   | [go/arrow/internal/testing/tools/bool.go](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-Z28vYXJyb3cvaW50ZXJuYWwvdGVzdGluZy90b29scy9ib29sLmdv) | | |\n   | [go/arrow/array/bufferbuilder.go](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-Z28vYXJyb3cvYXJyYXkvYnVmZmVyYnVpbGRlci5nbw==) | | |\n   | [go/arrow/internal/bitutil/bitutil.go](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-Z28vYXJyb3cvaW50ZXJuYWwvYml0dXRpbC9iaXR1dGlsLmdv) | | |\n   | [go/arrow/memory/memory\\_avx2\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWVtb3J5L21lbW9yeV9hdngyX2FtZDY0Lmdv) | | |\n   | [go/arrow/array/null.go](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-Z28vYXJyb3cvYXJyYXkvbnVsbC5nbw==) | | |\n   | [go/arrow/datatype\\_nested.go](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-Z28vYXJyb3cvZGF0YXR5cGVfbmVzdGVkLmdv) | | |\n   | ... and [59 more](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree-more) | |\n   \n   ------\n   \n   [Continue to review full report at Codecov](https://codecov.io/gh/apache/arrow/pull/2928?src=pr&el=continue).\n   > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n   > `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n   > Powered by [Codecov](https://codecov.io/gh/apache/arrow/pull/2928?src=pr&el=footer). Last update [3ae4161...8ea426c](https://codecov.io/gh/apache/arrow/pull/2928?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-09T18:12:05.174+0000",
                    "updated": "2018-11-09T18:12:05.174+0000",
                    "started": "2018-11-09T18:12:05.173+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "164455",
                    "issueId": "13196854"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13196854/worklog/164521",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "codecov-io edited a comment on issue #2928: ARROW-3716: [R] Missing cases for ChunkedArray conversion\nURL: https://github.com/apache/arrow/pull/2928#issuecomment-437446212\n \n \n   # [Codecov](https://codecov.io/gh/apache/arrow/pull/2928?src=pr&el=h1) Report\n   > Merging [#2928](https://codecov.io/gh/apache/arrow/pull/2928?src=pr&el=desc) into [master](https://codecov.io/gh/apache/arrow/commit/0a2ce9d67b8dccc25dc41aeb190deadfbd5d3167?src=pr&el=desc) will **increase** coverage by `0.8%`.\n   > The diff coverage is `n/a`.\n   \n   [![Impacted file tree graph](https://codecov.io/gh/apache/arrow/pull/2928/graphs/tree.svg?width=650&token=LpTCFbqVT1&height=150&src=pr)](https://codecov.io/gh/apache/arrow/pull/2928?src=pr&el=tree)\n   \n   ```diff\n   @@            Coverage Diff            @@\n   ##           master    #2928     +/-   ##\n   =========================================\n   + Coverage   84.25%   85.05%   +0.8%     \n   =========================================\n     Files         490      422     -68     \n     Lines       68694    63534   -5160     \n   =========================================\n   - Hits        57880    54042   -3838     \n   + Misses      10720     9492   -1228     \n   + Partials       94        0     -94\n   ```\n   \n   \n   | [Impacted Files](https://codecov.io/gh/apache/arrow/pull/2928?src=pr&el=tree) | Coverage \u0394 | |\n   |---|---|---|\n   | [rust/src/record\\_batch.rs](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-cnVzdC9zcmMvcmVjb3JkX2JhdGNoLnJz) | | |\n   | [go/arrow/array/table.go](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-Z28vYXJyb3cvYXJyYXkvdGFibGUuZ28=) | | |\n   | [rust/src/array.rs](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-cnVzdC9zcmMvYXJyYXkucnM=) | | |\n   | [go/arrow/math/uint64\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWF0aC91aW50NjRfYW1kNjQuZ28=) | | |\n   | [go/arrow/internal/testing/tools/bool.go](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-Z28vYXJyb3cvaW50ZXJuYWwvdGVzdGluZy90b29scy9ib29sLmdv) | | |\n   | [go/arrow/array/bufferbuilder.go](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-Z28vYXJyb3cvYXJyYXkvYnVmZmVyYnVpbGRlci5nbw==) | | |\n   | [go/arrow/internal/bitutil/bitutil.go](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-Z28vYXJyb3cvaW50ZXJuYWwvYml0dXRpbC9iaXR1dGlsLmdv) | | |\n   | [go/arrow/memory/memory\\_avx2\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWVtb3J5L21lbW9yeV9hdngyX2FtZDY0Lmdv) | | |\n   | [go/arrow/array/null.go](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-Z28vYXJyb3cvYXJyYXkvbnVsbC5nbw==) | | |\n   | [go/arrow/datatype\\_nested.go](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree#diff-Z28vYXJyb3cvZGF0YXR5cGVfbmVzdGVkLmdv) | | |\n   | ... and [58 more](https://codecov.io/gh/apache/arrow/pull/2928/diff?src=pr&el=tree-more) | |\n   \n   ------\n   \n   [Continue to review full report at Codecov](https://codecov.io/gh/apache/arrow/pull/2928?src=pr&el=continue).\n   > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n   > `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n   > Powered by [Codecov](https://codecov.io/gh/apache/arrow/pull/2928?src=pr&el=footer). Last update [0a2ce9d...f56891b](https://codecov.io/gh/apache/arrow/pull/2928?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-09T21:31:56.266+0000",
                    "updated": "2018-11-09T21:31:56.266+0000",
                    "started": "2018-11-09T21:31:56.266+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "164521",
                    "issueId": "13196854"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13196854/worklog/164619",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #2928: ARROW-3716: [R] Missing cases for ChunkedArray conversion\nURL: https://github.com/apache/arrow/pull/2928#discussion_r232438558\n \n \n\n ##########\n File path: r/tests/testthat/test-chunkedarray.R\n ##########\n @@ -110,8 +113,48 @@ test_that(\"ChunkedArray supports character vectors (ARROW-3339)\", {\n   arr_chr <- chunked_array(!!!data)\n   expect_equal(arr_chr$length(), length(unlist(data)))\n   expect_equal(arr_chr$null_count(), 1L)\n+  expect_equal(arr_chr$as_vector(), purrr::flatten_chr(data))\n \n   chunks <- arr_chr$chunks()\n   expect_equal(data, purrr::map(chunks, ~.$as_vector()))\n })\n \n+test_that(\"ChunkedArray supports factors (ARROW-3716)\", {\n+  f <- factor(c(\"itsy\", \"bitsy\", \"spider\", \"spider\"))\n+  arr_fac <- chunked_array(f, f, f)\n+  expect_equal(arr_fac$length(), 12L)\n+  expect_equal(arr_fac$type()$index_type(), int8())\n+  expect_identical(arr_fac$as_vector(), vctrs::vec_c(f, f, f))\n+})\n+\n+test_that(\"ChunkedArray supports dates (ARROW-3716)\", {\n+  d <- Sys.Date() + 1:10\n+  a <- chunked_array(d, d)\n+  expect_equal(a$type(), date32())\n+  expect_equal(a$length(), 20L)\n+  expect_equal(a$as_vector(), c(d, d))\n+})\n+\n+test_that(\"ChunkedArray supports POSIXct (ARROW-3716)\", {\n \n Review comment:\n   I guess this is on deck to change to timestamp\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-10T02:45:04.967+0000",
                    "updated": "2018-11-10T02:45:04.967+0000",
                    "started": "2018-11-10T02:45:04.966+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "164619",
                    "issueId": "13196854"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13196854/worklog/164620",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #2928: ARROW-3716: [R] Missing cases for ChunkedArray conversion\nURL: https://github.com/apache/arrow/pull/2928#discussion_r232438623\n \n \n\n ##########\n File path: r/src/array.cpp\n ##########\n @@ -506,167 +506,310 @@ std::shared_ptr<arrow::Array> Array__from_vector(SEXP x) {\n namespace arrow {\n namespace r {\n \n+template <typename Converter, typename... Args>\n+SEXP ArrayVector_To_Vector(int64_t n, const ArrayVector& arrays, Args... args) {\n+  Converter converter(n, std::forward<Args>(args)...);\n+\n+  R_xlen_t k = 0;\n+  for (const auto& array : arrays) {\n+    auto n_chunk = array->length();\n+    converter.Ingest(array, k, n_chunk);\n+    k += n_chunk;\n+  }\n+  return converter.data;\n+}\n+\n template <int RTYPE>\n-inline SEXP simple_Array_to_Vector(const std::shared_ptr<arrow::Array>& array) {\n-  using value_type = typename Rcpp::Vector<RTYPE>::stored_type;\n-  auto n = array->length();\n-  auto null_count = array->null_count();\n+struct Converter_SimpleArray {\n+  using Vector = Rcpp::Vector<RTYPE>;\n \n-  // special cases\n-  if (n == 0) return Rcpp::Vector<RTYPE>(0);\n-  if (n == null_count) {\n-    return Rcpp::Vector<RTYPE>(n, default_value<RTYPE>());\n-  }\n+  Converter_SimpleArray(R_xlen_t n) : data(no_init(n)) {}\n+\n+  void Ingest(const std::shared_ptr<arrow::Array>& array, R_xlen_t start, R_xlen_t n) {\n+    using value_type = typename Vector::stored_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = GetValuesSafely<value_type>(array->data(), 1, array->offset());\n+      STOP_IF_NULL(p_values);\n+\n+      // first copy all the data\n+      std::copy_n(p_values, n, data.begin() + start);\n+\n+      if (null_count) {\n+        // then set the sentinel NA\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n \n-  // first copy all the data\n-  auto p_values = GetValuesSafely<value_type>(array->data(), 1, array->offset());\n-  STOP_IF_NULL(p_values);\n-  Rcpp::Vector<RTYPE> vec(p_values, p_values + n);\n-\n-  // then set the sentinel NA\n-  if (array->null_count() && RTYPE != RAWSXP) {\n-    // TODO: not sure what to do with RAWSXP since\n-    //       R raw vector do not have a concept of missing data\n-\n-    arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n-                                                array->offset(), n);\n-    for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n-      if (bitmap_reader.IsNotSet()) {\n-        vec[i] = Rcpp::Vector<RTYPE>::get_na();\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          if (bitmap_reader.IsNotSet()) {\n+            data[i + start] = default_value<RTYPE>();\n+          }\n+        }\n       }\n     }\n   }\n \n-  return vec;\n-}\n+  Vector data;\n+};\n \n-inline SEXP StringArray_to_Vector(const std::shared_ptr<arrow::Array>& array) {\n-  auto n = array->length();\n-  auto null_count = array->null_count();\n+struct Converter_String {\n+  Converter_String(R_xlen_t n) : data(n) {}\n \n-  // special cases\n-  if (n == 0) return Rcpp::CharacterVector_(0);\n+  void Ingest(const std::shared_ptr<arrow::Array>& array, R_xlen_t start, R_xlen_t n) {\n+    auto null_count = array->null_count();\n \n-  // only NA\n-  if (null_count == n) {\n-    return StringVector_(n, NA_STRING);\n-  }\n+    if (null_count == n) {\n+      std::fill_n(data.begin(), n, NA_STRING);\n+    } else {\n+      auto p_offset = GetValuesSafely<int32_t>(array->data(), 1, array->offset());\n+      STOP_IF_NULL(p_offset);\n+      auto p_data = GetValuesSafely<char>(array->data(), 2, *p_offset);\n+      if (!p_data) {\n+        // There is an offset buffer, but the data buffer is null\n+        // There is at least one value in the array and not all the values are null\n+        // That means all values are empty strings so there is nothing to do\n+        return;\n+      }\n \n-  Rcpp::CharacterVector res(no_init(n));\n-  auto p_offset = GetValuesSafely<int32_t>(array->data(), 1, array->offset());\n-  STOP_IF_NULL(p_offset);\n+      if (null_count) {\n+        // need to watch for nulls\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap_data(),\n+                                                  array->offset(), n);\n+        for (int i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsSet()) {\n+            auto diff = p_offset[i + 1] - p_offset[i];\n+            SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+            p_data += diff;\n+          } else {\n+            SET_STRING_ELT(data, start + i, NA_STRING);\n+          }\n+        }\n \n-  auto p_data = GetValuesSafely<char>(array->data(), 2, *p_offset);\n-  if (!p_data) {\n-    // There is an offset buffer, but the data buffer is null\n-    // There is at least one value in the array and not all the values are null\n-    // That means all values are empty strings so we can just return `res`\n-    return res;\n-  }\n-  if (null_count) {\n-    // need to watch for nulls\n-    arrow::internal::BitmapReader null_reader(array->null_bitmap_data(), array->offset(),\n-                                              n);\n-    for (int i = 0; i < n; i++, null_reader.Next()) {\n-      if (null_reader.IsSet()) {\n-        auto diff = p_offset[i + 1] - p_offset[i];\n-        SET_STRING_ELT(res, i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n-        p_data += diff;\n       } else {\n-        SET_STRING_ELT(res, i, NA_STRING);\n+        // no need to check for nulls\n+        // TODO: altrep mark this as no na\n+        for (int i = 0; i < n; i++) {\n+          auto diff = p_offset[i + 1] - p_offset[i];\n+          SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+          p_data += diff;\n+        }\n       }\n     }\n+  }\n \n-  } else {\n-    // no need to check for nulls\n-    // TODO: altrep mark this as no na\n-    for (int i = 0; i < n; i++) {\n-      auto diff = p_offset[i + 1] - p_offset[i];\n-      SET_STRING_ELT(res, i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n-      p_data += diff;\n+  CharacterVector data;\n+};\n+\n+struct Converter_Boolean {\n+  Converter_Boolean(R_xlen_t n) : data(n) {}\n+\n+  void Ingest(const std::shared_ptr<arrow::Array>& array, R_xlen_t start, R_xlen_t n) {\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_LOGICAL);\n+    } else {\n+      // process the data\n+      auto p_data = GetValuesSafely<uint8_t>(array->data(), 1, 0);\n+      STOP_IF_NULL(p_data);\n+\n+      arrow::internal::BitmapReader data_reader(p_data, array->offset(), n);\n+      for (size_t i = 0; i < n; i++, data_reader.Next()) {\n+        data[start + i] = data_reader.IsSet();\n+      }\n+\n+      // then the null bitmap if needed\n+      if (null_count) {\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap()->data(),\n+                                                  array->offset(), n);\n+        for (size_t i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsNotSet()) {\n+            data[start + i] = NA_LOGICAL;\n+          }\n+        }\n+      }\n     }\n   }\n \n-  return res;\n-}\n-\n-inline SEXP BooleanArray_to_Vector(const std::shared_ptr<arrow::Array>& array) {\n-  auto n = array->length();\n-  auto null_count = array->null_count();\n+  LogicalVector data;\n+};\n \n-  if (n == 0) {\n-    return LogicalVector(0);\n+template <typename Type>\n+struct Converter_Dictionary_Int32Indices {\n \n Review comment:\n   Can probably make the index type another template argument\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-10T02:45:04.974+0000",
                    "updated": "2018-11-10T02:45:04.974+0000",
                    "started": "2018-11-10T02:45:04.973+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "164620",
                    "issueId": "13196854"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13196854/worklog/164621",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm closed pull request #2928: ARROW-3716: [R] Missing cases for ChunkedArray conversion\nURL: https://github.com/apache/arrow/pull/2928\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/r/R/ArrayData.R b/r/R/ArrayData.R\nindex 8075b9ee85..47b858d589 100644\n--- a/r/R/ArrayData.R\n+++ b/r/R/ArrayData.R\n@@ -24,6 +24,6 @@\n     length = function() ArrayData__get_length(self),\n     null_count = function() ArrayData__get_null_count(self),\n     offset = function() ArrayData__get_offset(self),\n-    buffers = function() map(ArrayData__buffers(self), construct, class = `arrow::Buffer`)\n+    buffers = function() map(ArrayData__buffers(self), shared_ptr, class = `arrow::Buffer`)\n   )\n )\ndiff --git a/r/R/RcppExports.R b/r/R/RcppExports.R\nindex 6304898256..3811c5d316 100644\n--- a/r/R/RcppExports.R\n+++ b/r/R/RcppExports.R\n@@ -9,6 +9,10 @@ Array__as_vector <- function(array) {\n     .Call(`_arrow_Array__as_vector`, array)\n }\n \n+ChunkedArray__as_vector <- function(chunked_array) {\n+    .Call(`_arrow_ChunkedArray__as_vector`, chunked_array)\n+}\n+\n Array__Slice1 <- function(array, offset) {\n     .Call(`_arrow_Array__Slice1`, array, offset)\n }\n@@ -141,10 +145,6 @@ ChunkedArray__type <- function(chunked_array) {\n     .Call(`_arrow_ChunkedArray__type`, chunked_array)\n }\n \n-ChunkedArray__as_vector <- function(chunked_array) {\n-    .Call(`_arrow_ChunkedArray__as_vector`, chunked_array)\n-}\n-\n ChunkArray__Slice1 <- function(chunked_array, offset) {\n     .Call(`_arrow_ChunkArray__Slice1`, chunked_array, offset)\n }\ndiff --git a/r/src/RcppExports.cpp b/r/src/RcppExports.cpp\nindex 2b4338df69..79ee497660 100644\n--- a/r/src/RcppExports.cpp\n+++ b/r/src/RcppExports.cpp\n@@ -28,6 +28,17 @@ BEGIN_RCPP\n     return rcpp_result_gen;\n END_RCPP\n }\n+// ChunkedArray__as_vector\n+SEXP ChunkedArray__as_vector(const std::shared_ptr<arrow::ChunkedArray>& chunked_array);\n+RcppExport SEXP _arrow_ChunkedArray__as_vector(SEXP chunked_arraySEXP) {\n+BEGIN_RCPP\n+    Rcpp::RObject rcpp_result_gen;\n+    Rcpp::RNGScope rcpp_rngScope_gen;\n+    Rcpp::traits::input_parameter< const std::shared_ptr<arrow::ChunkedArray>& >::type chunked_array(chunked_arraySEXP);\n+    rcpp_result_gen = Rcpp::wrap(ChunkedArray__as_vector(chunked_array));\n+    return rcpp_result_gen;\n+END_RCPP\n+}\n // Array__Slice1\n std::shared_ptr<arrow::Array> Array__Slice1(const std::shared_ptr<arrow::Array>& array, int offset);\n RcppExport SEXP _arrow_Array__Slice1(SEXP arraySEXP, SEXP offsetSEXP) {\n@@ -402,17 +413,6 @@ BEGIN_RCPP\n     return rcpp_result_gen;\n END_RCPP\n }\n-// ChunkedArray__as_vector\n-SEXP ChunkedArray__as_vector(const std::shared_ptr<arrow::ChunkedArray>& chunked_array);\n-RcppExport SEXP _arrow_ChunkedArray__as_vector(SEXP chunked_arraySEXP) {\n-BEGIN_RCPP\n-    Rcpp::RObject rcpp_result_gen;\n-    Rcpp::RNGScope rcpp_rngScope_gen;\n-    Rcpp::traits::input_parameter< const std::shared_ptr<arrow::ChunkedArray>& >::type chunked_array(chunked_arraySEXP);\n-    rcpp_result_gen = Rcpp::wrap(ChunkedArray__as_vector(chunked_array));\n-    return rcpp_result_gen;\n-END_RCPP\n-}\n // ChunkArray__Slice1\n std::shared_ptr<arrow::ChunkedArray> ChunkArray__Slice1(const std::shared_ptr<arrow::ChunkedArray>& chunked_array, int offset);\n RcppExport SEXP _arrow_ChunkArray__Slice1(SEXP chunked_arraySEXP, SEXP offsetSEXP) {\n@@ -1821,6 +1821,7 @@ END_RCPP\n static const R_CallMethodDef CallEntries[] = {\n     {\"_arrow_Array__from_vector\", (DL_FUNC) &_arrow_Array__from_vector, 1},\n     {\"_arrow_Array__as_vector\", (DL_FUNC) &_arrow_Array__as_vector, 1},\n+    {\"_arrow_ChunkedArray__as_vector\", (DL_FUNC) &_arrow_ChunkedArray__as_vector, 1},\n     {\"_arrow_Array__Slice1\", (DL_FUNC) &_arrow_Array__Slice1, 2},\n     {\"_arrow_Array__Slice2\", (DL_FUNC) &_arrow_Array__Slice2, 3},\n     {\"_arrow_Array__IsNull\", (DL_FUNC) &_arrow_Array__IsNull, 2},\n@@ -1854,7 +1855,6 @@ static const R_CallMethodDef CallEntries[] = {\n     {\"_arrow_ChunkedArray__chunk\", (DL_FUNC) &_arrow_ChunkedArray__chunk, 2},\n     {\"_arrow_ChunkedArray__chunks\", (DL_FUNC) &_arrow_ChunkedArray__chunks, 1},\n     {\"_arrow_ChunkedArray__type\", (DL_FUNC) &_arrow_ChunkedArray__type, 1},\n-    {\"_arrow_ChunkedArray__as_vector\", (DL_FUNC) &_arrow_ChunkedArray__as_vector, 1},\n     {\"_arrow_ChunkArray__Slice1\", (DL_FUNC) &_arrow_ChunkArray__Slice1, 2},\n     {\"_arrow_ChunkArray__Slice2\", (DL_FUNC) &_arrow_ChunkArray__Slice2, 3},\n     {\"_arrow_ChunkedArray__from_list\", (DL_FUNC) &_arrow_ChunkedArray__from_list, 1},\ndiff --git a/r/src/array.cpp b/r/src/array.cpp\nindex 820adf62f4..a83929c206 100644\n--- a/r/src/array.cpp\n+++ b/r/src/array.cpp\n@@ -506,167 +506,310 @@ std::shared_ptr<arrow::Array> Array__from_vector(SEXP x) {\n namespace arrow {\n namespace r {\n \n+template <typename Converter, typename... Args>\n+SEXP ArrayVector_To_Vector(int64_t n, const ArrayVector& arrays, Args... args) {\n+  Converter converter(n, std::forward<Args>(args)...);\n+\n+  R_xlen_t k = 0;\n+  for (const auto& array : arrays) {\n+    auto n_chunk = array->length();\n+    converter.Ingest(array, k, n_chunk);\n+    k += n_chunk;\n+  }\n+  return converter.data;\n+}\n+\n template <int RTYPE>\n-inline SEXP simple_Array_to_Vector(const std::shared_ptr<arrow::Array>& array) {\n-  using value_type = typename Rcpp::Vector<RTYPE>::stored_type;\n-  auto n = array->length();\n-  auto null_count = array->null_count();\n+struct Converter_SimpleArray {\n+  using Vector = Rcpp::Vector<RTYPE>;\n \n-  // special cases\n-  if (n == 0) return Rcpp::Vector<RTYPE>(0);\n-  if (n == null_count) {\n-    return Rcpp::Vector<RTYPE>(n, default_value<RTYPE>());\n-  }\n+  Converter_SimpleArray(R_xlen_t n) : data(no_init(n)) {}\n+\n+  void Ingest(const std::shared_ptr<arrow::Array>& array, R_xlen_t start, R_xlen_t n) {\n+    using value_type = typename Vector::stored_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = GetValuesSafely<value_type>(array->data(), 1, array->offset());\n+      STOP_IF_NULL(p_values);\n+\n+      // first copy all the data\n+      std::copy_n(p_values, n, data.begin() + start);\n+\n+      if (null_count) {\n+        // then set the sentinel NA\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n \n-  // first copy all the data\n-  auto p_values = GetValuesSafely<value_type>(array->data(), 1, array->offset());\n-  STOP_IF_NULL(p_values);\n-  Rcpp::Vector<RTYPE> vec(p_values, p_values + n);\n-\n-  // then set the sentinel NA\n-  if (array->null_count() && RTYPE != RAWSXP) {\n-    // TODO: not sure what to do with RAWSXP since\n-    //       R raw vector do not have a concept of missing data\n-\n-    arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n-                                                array->offset(), n);\n-    for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n-      if (bitmap_reader.IsNotSet()) {\n-        vec[i] = Rcpp::Vector<RTYPE>::get_na();\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          if (bitmap_reader.IsNotSet()) {\n+            data[i + start] = default_value<RTYPE>();\n+          }\n+        }\n       }\n     }\n   }\n \n-  return vec;\n-}\n+  Vector data;\n+};\n \n-inline SEXP StringArray_to_Vector(const std::shared_ptr<arrow::Array>& array) {\n-  auto n = array->length();\n-  auto null_count = array->null_count();\n+struct Converter_String {\n+  Converter_String(R_xlen_t n) : data(n) {}\n \n-  // special cases\n-  if (n == 0) return Rcpp::CharacterVector_(0);\n+  void Ingest(const std::shared_ptr<arrow::Array>& array, R_xlen_t start, R_xlen_t n) {\n+    auto null_count = array->null_count();\n \n-  // only NA\n-  if (null_count == n) {\n-    return StringVector_(n, NA_STRING);\n-  }\n+    if (null_count == n) {\n+      std::fill_n(data.begin(), n, NA_STRING);\n+    } else {\n+      auto p_offset = GetValuesSafely<int32_t>(array->data(), 1, array->offset());\n+      STOP_IF_NULL(p_offset);\n+      auto p_data = GetValuesSafely<char>(array->data(), 2, *p_offset);\n+      if (!p_data) {\n+        // There is an offset buffer, but the data buffer is null\n+        // There is at least one value in the array and not all the values are null\n+        // That means all values are empty strings so there is nothing to do\n+        return;\n+      }\n \n-  Rcpp::CharacterVector res(no_init(n));\n-  auto p_offset = GetValuesSafely<int32_t>(array->data(), 1, array->offset());\n-  STOP_IF_NULL(p_offset);\n+      if (null_count) {\n+        // need to watch for nulls\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap_data(),\n+                                                  array->offset(), n);\n+        for (int i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsSet()) {\n+            auto diff = p_offset[i + 1] - p_offset[i];\n+            SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+            p_data += diff;\n+          } else {\n+            SET_STRING_ELT(data, start + i, NA_STRING);\n+          }\n+        }\n \n-  auto p_data = GetValuesSafely<char>(array->data(), 2, *p_offset);\n-  if (!p_data) {\n-    // There is an offset buffer, but the data buffer is null\n-    // There is at least one value in the array and not all the values are null\n-    // That means all values are empty strings so we can just return `res`\n-    return res;\n-  }\n-  if (null_count) {\n-    // need to watch for nulls\n-    arrow::internal::BitmapReader null_reader(array->null_bitmap_data(), array->offset(),\n-                                              n);\n-    for (int i = 0; i < n; i++, null_reader.Next()) {\n-      if (null_reader.IsSet()) {\n-        auto diff = p_offset[i + 1] - p_offset[i];\n-        SET_STRING_ELT(res, i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n-        p_data += diff;\n       } else {\n-        SET_STRING_ELT(res, i, NA_STRING);\n+        // no need to check for nulls\n+        // TODO: altrep mark this as no na\n+        for (int i = 0; i < n; i++) {\n+          auto diff = p_offset[i + 1] - p_offset[i];\n+          SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+          p_data += diff;\n+        }\n       }\n     }\n+  }\n \n-  } else {\n-    // no need to check for nulls\n-    // TODO: altrep mark this as no na\n-    for (int i = 0; i < n; i++) {\n-      auto diff = p_offset[i + 1] - p_offset[i];\n-      SET_STRING_ELT(res, i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n-      p_data += diff;\n+  CharacterVector data;\n+};\n+\n+struct Converter_Boolean {\n+  Converter_Boolean(R_xlen_t n) : data(n) {}\n+\n+  void Ingest(const std::shared_ptr<arrow::Array>& array, R_xlen_t start, R_xlen_t n) {\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_LOGICAL);\n+    } else {\n+      // process the data\n+      auto p_data = GetValuesSafely<uint8_t>(array->data(), 1, 0);\n+      STOP_IF_NULL(p_data);\n+\n+      arrow::internal::BitmapReader data_reader(p_data, array->offset(), n);\n+      for (size_t i = 0; i < n; i++, data_reader.Next()) {\n+        data[start + i] = data_reader.IsSet();\n+      }\n+\n+      // then the null bitmap if needed\n+      if (null_count) {\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap()->data(),\n+                                                  array->offset(), n);\n+        for (size_t i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsNotSet()) {\n+            data[start + i] = NA_LOGICAL;\n+          }\n+        }\n+      }\n     }\n   }\n \n-  return res;\n-}\n-\n-inline SEXP BooleanArray_to_Vector(const std::shared_ptr<arrow::Array>& array) {\n-  auto n = array->length();\n-  auto null_count = array->null_count();\n+  LogicalVector data;\n+};\n \n-  if (n == 0) {\n-    return LogicalVector(0);\n+template <typename Type>\n+struct Converter_Dictionary_Int32Indices {\n+  Converter_Dictionary_Int32Indices(R_xlen_t n, const std::shared_ptr<arrow::Array>& dict,\n+                                    bool ordered)\n+      : data(no_init(n)) {\n+    data.attr(\"levels\") = ArrayVector_To_Vector<Converter_String>(dict->length(), {dict});\n+    if (ordered) {\n+      data.attr(\"class\") = CharacterVector::create(\"ordered\", \"factor\");\n+    } else {\n+      data.attr(\"class\") = \"factor\";\n+    }\n   }\n-  if (n == null_count) {\n-    return LogicalVector(n, NA_LOGICAL);\n+\n+  void Ingest(const std::shared_ptr<arrow::Array>& array, R_xlen_t start, R_xlen_t n) {\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    using value_type = typename arrow::TypeTraits<Type>::ArrayType::value_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_INTEGER);\n+    } else {\n+      std::shared_ptr<Array> indices = dict_array->indices();\n+      auto p_array = GetValuesSafely<value_type>(indices->data(), 1, indices->offset());\n+      STOP_IF_NULL(p_array);\n+\n+      if (array->null_count()) {\n+        arrow::internal::BitmapReader bitmap_reader(indices->null_bitmap()->data(),\n+                                                    indices->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_array) {\n+          data[start + i] =\n+              bitmap_reader.IsNotSet() ? NA_INTEGER : (static_cast<int>(*p_array) + 1);\n+        }\n+      } else {\n+        std::transform(\n+            p_array, p_array + n, data.begin() + start,\n+            [](const value_type value) { return static_cast<int>(value) + 1; });\n+      }\n+    }\n   }\n \n-  LogicalVector vec = no_init(n);\n+  IntegerVector data;\n+};\n \n-  // process the data\n-  auto p_data = GetValuesSafely<uint8_t>(array->data(), 1, 0);\n-  STOP_IF_NULL(p_data);\n-  arrow::internal::BitmapReader data_reader(p_data, array->offset(), n);\n-  for (size_t i = 0; i < n; i++, data_reader.Next()) {\n-    vec[i] = data_reader.IsSet();\n+struct Converter_Date64 {\n+  Converter_Date64(R_xlen_t n) : data(n) {\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n   }\n \n-  // then the null bitmap if needed\n-  if (array->null_count()) {\n-    arrow::internal::BitmapReader null_reader(array->null_bitmap()->data(),\n-                                              array->offset(), n);\n-    for (size_t i = 0; i < n; i++, null_reader.Next()) {\n-      if (null_reader.IsNotSet()) {\n-        vec[i] = LogicalVector::get_na();\n+  void Ingest(const std::shared_ptr<arrow::Array>& array, R_xlen_t start, R_xlen_t n) {\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = GetValuesSafely<int64_t>(array->data(), 1, array->offset());\n+      STOP_IF_NULL(p_values);\n+      auto p_vec = data.begin() + start;\n+\n+      // convert DATE64 milliseconds to R seconds (stored as double)\n+      auto seconds = [](int64_t ms) { return static_cast<double>(ms / 1000); };\n+\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? seconds(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, seconds);\n       }\n     }\n   }\n \n-  return vec;\n-}\n+  NumericVector data;\n+};\n \n-template <typename Type>\n-inline SEXP DictionaryArrayInt32Indices_to_Vector(\n-    const std::shared_ptr<arrow::Array>& array, const std::shared_ptr<arrow::Array>& dict,\n-    bool ordered) {\n-  using value_type = typename arrow::TypeTraits<Type>::ArrayType::value_type;\n+template <int RTYPE, typename Type>\n+struct Converter_Promotion {\n+  using r_stored_type = typename Rcpp::Vector<RTYPE>::stored_type;\n+  using value_type = typename TypeTraits<Type>::ArrayType::value_type;\n \n-  size_t n = array->length();\n-  IntegerVector vec(no_init(n));\n-  vec.attr(\"levels\") = StringArray_to_Vector(dict);\n-  if (ordered) {\n-    vec.attr(\"class\") = CharacterVector::create(\"ordered\", \"factor\");\n-  } else {\n-    vec.attr(\"class\") = \"factor\";\n+  Converter_Promotion(R_xlen_t n) : data(no_init(n)) {}\n+\n+  void Ingest(const std::shared_ptr<arrow::Array>& array, R_xlen_t start, R_xlen_t n) {\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = GetValuesSafely<value_type>(array->data(), 1, array->offset());\n+      STOP_IF_NULL(start);\n+\n+      auto value_convert = [](value_type value) {\n+        return static_cast<r_stored_type>(value);\n+      };\n+      if (null_count) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          data[start + i] = bitmap_reader.IsNotSet() ? Rcpp::Vector<RTYPE>::get_na()\n+                                                     : value_convert(p_values[i]);\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, data.begin(), value_convert);\n+      }\n+    }\n   }\n \n-  if (n == 0) {\n-    return vec;\n+  Rcpp::Vector<RTYPE> data;\n+};\n+\n+template <typename value_type>\n+struct Converter_Time {\n+  Converter_Time(int64_t n, int32_t multiplier)\n+      : data(no_init(n)), multiplier_(multiplier) {\n+    data.attr(\"class\") = CharacterVector::create(\"hms\", \"difftime\");\n+    data.attr(\"units\") = \"secs\";\n   }\n \n-  auto null_count = array->null_count();\n-  if (n == null_count) {\n-    std::fill(vec.begin(), vec.end(), NA_INTEGER);\n-    return vec;\n+  void Ingest(const std::shared_ptr<arrow::Array>& array, R_xlen_t start, R_xlen_t n) {\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = GetValuesSafely<value_type>(array->data(), 1, array->offset());\n+      STOP_IF_NULL(p_values);\n+      auto p_vec = data.begin() + start;\n+      auto convert = [this](value_type value) {\n+        return static_cast<double>(value) / multiplier_;\n+      };\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? convert(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, convert);\n+      }\n+    }\n   }\n \n-  auto p_array = GetValuesSafely<value_type>(array->data(), 1, array->offset());\n-  STOP_IF_NULL(p_array);\n+  NumericVector data;\n+  int32_t multiplier_;\n+};\n+\n+struct Converter_Int64 {\n+  Converter_Int64(R_xlen_t n) : data(no_init(n)) { data.attr(\"class\") = \"integer64\"; }\n \n-  if (array->null_count()) {\n-    arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n-                                                array->offset(), n);\n-    for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_array) {\n-      vec[i] = bitmap_reader.IsNotSet() ? NA_INTEGER : (static_cast<int>(*p_array) + 1);\n+  void Ingest(const std::shared_ptr<arrow::Array>& array, R_xlen_t start, R_xlen_t n) {\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, NA_INT64);\n+    } else {\n+      auto p_values = GetValuesSafely<int64_t>(array->data(), 1, array->offset());\n+      STOP_IF_NULL(p_values);\n+      auto p_vec = reinterpret_cast<int64_t*>(data.begin()) + start;\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet() ? NA_INT64 : p_values[i];\n+        }\n+      } else {\n+        std::copy_n(p_values, n, p_vec);\n+      }\n     }\n-  } else {\n-    std::transform(p_array, p_array + n, vec.begin(),\n-                   [](const value_type value) { return static_cast<int>(value) + 1; });\n   }\n-  return vec;\n-}\n \n-SEXP DictionaryArray_to_Vector(arrow::DictionaryArray* dict_array) {\n+  NumericVector data;\n+};\n+\n+SEXP DictionaryArrays_to_Vector(int64_t n, const ArrayVector& arrays) {\n+  DictionaryArray* dict_array = static_cast<DictionaryArray*>(arrays[0].get());\n   auto dict = dict_array->dictionary();\n   auto indices = dict_array->indices();\n \n@@ -677,20 +820,25 @@ SEXP DictionaryArray_to_Vector(arrow::DictionaryArray* dict_array) {\n   bool ordered = dict_array->dict_type()->ordered();\n   switch (indices->type_id()) {\n     case Type::UINT8:\n-      return DictionaryArrayInt32Indices_to_Vector<arrow::UInt8Type>(indices, dict,\n-                                                                     ordered);\n+      return ArrayVector_To_Vector<Converter_Dictionary_Int32Indices<arrow::UInt8Type>>(\n+          n, arrays, dict, ordered);\n+\n     case Type::INT8:\n-      return DictionaryArrayInt32Indices_to_Vector<arrow::Int8Type>(indices, dict,\n-                                                                    ordered);\n+      return ArrayVector_To_Vector<Converter_Dictionary_Int32Indices<arrow::Int8Type>>(\n+          n, arrays, dict, ordered);\n+\n     case Type::UINT16:\n-      return DictionaryArrayInt32Indices_to_Vector<arrow::UInt16Type>(indices, dict,\n-                                                                      ordered);\n+      return ArrayVector_To_Vector<Converter_Dictionary_Int32Indices<arrow::UInt16Type>>(\n+          n, arrays, dict, ordered);\n+\n     case Type::INT16:\n-      return DictionaryArrayInt32Indices_to_Vector<arrow::Int16Type>(indices, dict,\n-                                                                     ordered);\n+      return ArrayVector_To_Vector<Converter_Dictionary_Int32Indices<arrow::Int16Type>>(\n+          n, arrays, dict, ordered);\n+\n     case Type::INT32:\n-      return DictionaryArrayInt32Indices_to_Vector<arrow::Int32Type>(indices, dict,\n-                                                                     ordered);\n+      return ArrayVector_To_Vector<Converter_Dictionary_Int32Indices<arrow::Int32Type>>(\n+          n, arrays, dict, ordered);\n+\n     default:\n       stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n            dict_array->type()->ToString());\n@@ -698,240 +846,135 @@ SEXP DictionaryArray_to_Vector(arrow::DictionaryArray* dict_array) {\n   return R_NilValue;\n }\n \n-SEXP Date32Array_to_Vector(const std::shared_ptr<arrow::Array>& array) {\n-  IntegerVector out(simple_Array_to_Vector<INTSXP>(array));\n+SEXP Date32ArrayVector_to_Vector(int64_t n, const ArrayVector& arrays) {\n+  IntegerVector out(\n+      arrow::r::ArrayVector_To_Vector<Converter_SimpleArray<INTSXP>>(n, arrays));\n   out.attr(\"class\") = \"Date\";\n   return out;\n }\n \n-SEXP Date64Array_to_Vector(const std::shared_ptr<arrow::Array> array) {\n-  auto n = array->length();\n-  NumericVector vec(no_init(n));\n-  vec.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n-  if (n == 0) {\n-    return vec;\n-  }\n-  auto null_count = array->null_count();\n-  if (null_count == n) {\n-    std::fill(vec.begin(), vec.end(), NA_REAL);\n-    return vec;\n-  }\n-  auto p_values = GetValuesSafely<int64_t>(array->data(), 1, array->offset());\n-  STOP_IF_NULL(p_values);\n-  auto p_vec = vec.begin();\n-\n-  if (null_count) {\n-    arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n-                                                array->offset(), n);\n-    for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n-      *p_vec = bitmap_reader.IsSet() ? static_cast<double>(*p_values / 1000) : NA_REAL;\n-    }\n-  } else {\n-    std::transform(p_values, p_values + n, vec.begin(),\n-                   [](int64_t value) { return static_cast<double>(value / 1000); });\n-  }\n-\n-  return vec;\n-}\n-\n-template <int RTYPE, typename Type>\n-SEXP promotion_Array_to_Vector(const std::shared_ptr<Array>& array) {\n-  using r_stored_type = typename Rcpp::Vector<RTYPE>::stored_type;\n-  using value_type = typename TypeTraits<Type>::ArrayType::value_type;\n-\n-  auto n = array->length();\n-  Rcpp::Vector<RTYPE> vec(no_init(n));\n-  if (n == 0) {\n-    return vec;\n-  }\n-  auto null_count = array->null_count();\n-  if (null_count == n) {\n-    std::fill(vec.begin(), vec.end(), NA_REAL);\n-    return vec;\n-  }\n-\n-  auto start = GetValuesSafely<value_type>(array->data(), 1, array->offset());\n-  STOP_IF_NULL(start);\n-\n-  if (null_count) {\n-    internal::BitmapReader bitmap_reader(array->null_bitmap()->data(), array->offset(),\n-                                         n);\n-    for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n-      vec[i] = bitmap_reader.IsNotSet() ? Rcpp::Vector<RTYPE>::get_na()\n-                                        : static_cast<r_stored_type>(start[i]);\n-    }\n-  } else {\n-    std::transform(start, start + n, vec.begin(),\n-                   [](value_type x) { return static_cast<r_stored_type>(x); });\n-  }\n-\n-  return vec;\n-}\n-\n-SEXP Int64Array(const std::shared_ptr<Array>& array) {\n-  auto n = array->length();\n-  NumericVector vec(no_init(n));\n-  vec.attr(\"class\") = \"integer64\";\n-  if (n == 0) {\n-    return vec;\n-  }\n-  auto null_count = array->null_count();\n-  if (null_count == n) {\n-    std::fill(vec.begin(), vec.end(), NA_REAL);\n-    return vec;\n-  }\n-  auto p_values = GetValuesSafely<int64_t>(array->data(), 1, array->offset());\n-  STOP_IF_NULL(p_values);\n-  auto p_vec = reinterpret_cast<int64_t*>(vec.begin());\n-\n-  if (array->null_count()) {\n-    internal::BitmapReader bitmap_reader(array->null_bitmap()->data(), array->offset(),\n-                                         n);\n-    for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n-      p_vec[i] = bitmap_reader.IsNotSet() ? NA_INT64 : p_values[i];\n-    }\n-  } else {\n-    std::copy_n(p_values, n, p_vec);\n-  }\n+struct Converter_Decimal {\n+  Converter_Decimal(R_xlen_t n) : data(no_init(n)) {}\n \n-  return vec;\n-}\n-\n-template <typename value_type>\n-SEXP TimeArray_to_Vector(const std::shared_ptr<Array>& array, int32_t multiplier) {\n-  auto n = array->length();\n-  NumericVector vec(no_init(n));\n-  auto null_count = array->null_count();\n-  vec.attr(\"class\") = CharacterVector::create(\"hms\", \"difftime\");\n-  vec.attr(\"units\") = \"secs\";\n-  if (n == 0) {\n-    return vec;\n-  }\n-  auto p_values = GetValuesSafely<value_type>(array->data(), 1, array->offset());\n-  STOP_IF_NULL(p_values);\n-  auto p_vec = vec.begin();\n-\n-  if (null_count) {\n-    arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n-                                                array->offset(), n);\n-    for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n-      *p_vec =\n-          bitmap_reader.IsSet() ? (static_cast<double>(*p_values) / multiplier) : NA_REAL;\n-    }\n-  } else {\n-    std::transform(p_values, p_values + n, vec.begin(), [multiplier](value_type value) {\n-      return static_cast<double>(value) / multiplier;\n-    });\n-  }\n-  return vec;\n-}\n-\n-SEXP DecimalArray(const std::shared_ptr<Array>& array) {\n-  auto n = array->length();\n-  NumericVector vec(no_init(n));\n-\n-  if (n == 0) return vec;\n-\n-  auto null_count = array->null_count();\n-  if (null_count == n) {\n-    std::fill(vec.begin(), vec.end(), NA_REAL);\n-    return vec;\n-  }\n-\n-  auto p_vec = reinterpret_cast<double*>(vec.begin());\n-  const auto& decimals_arr =\n-      internal::checked_cast<const arrow::Decimal128Array&>(*array);\n-\n-  if (array->null_count()) {\n-    internal::BitmapReader bitmap_reader(array->null_bitmap()->data(), array->offset(),\n-                                         n);\n-\n-    for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n-      p_vec[i] = bitmap_reader.IsNotSet()\n-                     ? NA_REAL\n-                     : std::stod(decimals_arr.FormatValue(i).c_str());\n-    }\n-  } else {\n-    for (size_t i = 0; i < n; i++) {\n-      p_vec[i] = std::stod(decimals_arr.FormatValue(i).c_str());\n+  void Ingest(const std::shared_ptr<arrow::Array>& array, R_xlen_t start, R_xlen_t n) {\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_vec = reinterpret_cast<double*>(data.begin()) + start;\n+      const auto& decimals_arr =\n+          internal::checked_cast<const arrow::Decimal128Array&>(*array);\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet()\n+                         ? NA_REAL\n+                         : std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      } else {\n+        for (size_t i = 0; i < n; i++) {\n+          p_vec[i] = std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      }\n     }\n   }\n \n-  return vec;\n-}\n+  NumericVector data;\n+};\n \n }  // namespace r\n }  // namespace arrow\n \n-// [[Rcpp::export]]\n-SEXP Array__as_vector(const std::shared_ptr<arrow::Array>& array) {\n+SEXP ArrayVector__as_vector(int64_t n, const ArrayVector& arrays) {\n   using namespace arrow::r;\n \n-  switch (array->type_id()) {\n+  switch (arrays[0]->type_id()) {\n     // direct support\n     case Type::INT8:\n-      return simple_Array_to_Vector<RAWSXP>(array);\n+      return ArrayVector_To_Vector<Converter_SimpleArray<RAWSXP>>(n, arrays);\n     case Type::INT32:\n-      return simple_Array_to_Vector<INTSXP>(array);\n+      return ArrayVector_To_Vector<Converter_SimpleArray<INTSXP>>(n, arrays);\n     case Type::DOUBLE:\n-      return simple_Array_to_Vector<REALSXP>(array);\n+      return ArrayVector_To_Vector<Converter_SimpleArray<REALSXP>>(n, arrays);\n \n     // need to handle 1-bit case\n     case Type::BOOL:\n-      return BooleanArray_to_Vector(array);\n+      return ArrayVector_To_Vector<Converter_Boolean>(n, arrays);\n \n-    // handle memory dense strings\n+      // handle memory dense strings\n     case Type::STRING:\n-      return StringArray_to_Vector(array);\n+      return ArrayVector_To_Vector<Converter_String>(n, arrays);\n     case Type::DICTIONARY:\n-      return DictionaryArray_to_Vector(static_cast<arrow::DictionaryArray*>(array.get()));\n+      return DictionaryArrays_to_Vector(n, arrays);\n \n     case Type::DATE32:\n-      return Date32Array_to_Vector(array);\n+      return Date32ArrayVector_to_Vector(n, arrays);\n     case Type::DATE64:\n-      return Date64Array_to_Vector(array);\n+      return ArrayVector_To_Vector<Converter_Date64>(n, arrays);\n \n-    // promotions to integer vector\n+      // promotions to integer vector\n     case Type::UINT8:\n-      return arrow::r::promotion_Array_to_Vector<INTSXP, arrow::UInt8Type>(array);\n+      return ArrayVector_To_Vector<Converter_Promotion<INTSXP, arrow::UInt8Type>>(n,\n+                                                                                  arrays);\n     case Type::INT16:\n-      return arrow::r::promotion_Array_to_Vector<INTSXP, arrow::Int16Type>(array);\n+      return ArrayVector_To_Vector<Converter_Promotion<INTSXP, arrow::Int16Type>>(n,\n+                                                                                  arrays);\n     case Type::UINT16:\n-      return arrow::r::promotion_Array_to_Vector<INTSXP, arrow::UInt16Type>(array);\n+      return ArrayVector_To_Vector<Converter_Promotion<INTSXP, arrow::UInt16Type>>(\n+          n, arrays);\n \n-    // promotions to numeric vector\n+      // promotions to numeric vector\n     case Type::UINT32:\n-      return arrow::r::promotion_Array_to_Vector<REALSXP, arrow::UInt32Type>(array);\n+      return ArrayVector_To_Vector<Converter_Promotion<REALSXP, arrow::UInt32Type>>(\n+          n, arrays);\n     case Type::HALF_FLOAT:\n-      return arrow::r::promotion_Array_to_Vector<REALSXP, arrow::UInt32Type>(array);\n+      return ArrayVector_To_Vector<Converter_Promotion<REALSXP, arrow::UInt32Type>>(\n+          n, arrays);\n     case Type::FLOAT:\n-      return arrow::r::promotion_Array_to_Vector<REALSXP, arrow::UInt32Type>(array);\n+      return ArrayVector_To_Vector<Converter_Promotion<REALSXP, arrow::UInt32Type>>(\n+          n, arrays);\n \n-    // time32 ane time64\n+      // time32 ane time64\n     case Type::TIME32:\n-      return arrow::r::TimeArray_to_Vector<int32_t>(\n-          array, static_cast<TimeType*>(array->type().get())->unit() == TimeUnit::SECOND\n-                     ? 1\n-                     : 1000);\n+      return ArrayVector_To_Vector<Converter_Time<int32_t>>(\n+          n, arrays,\n+          static_cast<TimeType*>(arrays[0]->type().get())->unit() == TimeUnit::SECOND\n+              ? 1\n+              : 1000);\n+\n     case Type::TIME64:\n-      return arrow::r::TimeArray_to_Vector<int64_t>(\n-          array, static_cast<TimeType*>(array->type().get())->unit() == TimeUnit::MICRO\n-                     ? 1000000\n-                     : 1000000000);\n+      return ArrayVector_To_Vector<Converter_Time<int64_t>>(\n+          n, arrays,\n+          static_cast<TimeType*>(arrays[0]->type().get())->unit() == TimeUnit::MICRO\n+              ? 1000000\n+              : 1000000000);\n \n     case Type::INT64:\n-      return arrow::r::Int64Array(array);\n+      return ArrayVector_To_Vector<Converter_Int64>(n, arrays);\n     case Type::DECIMAL:\n-      return arrow::r::DecimalArray(array);\n+      ArrayVector_To_Vector<Converter_Decimal>(n, arrays);\n \n     default:\n       break;\n   }\n \n-  stop(tfm::format(\"cannot handle Array of type %s\", array->type()->name()));\n+  stop(tfm::format(\"cannot handle Array of type %s\", arrays[0]->type()->name()));\n   return R_NilValue;\n }\n \n+// [[Rcpp::export]]\n+SEXP Array__as_vector(const std::shared_ptr<arrow::Array>& array) {\n+  return ArrayVector__as_vector(array->length(), {array});\n+}\n+\n+// [[Rcpp::export]]\n+SEXP ChunkedArray__as_vector(const std::shared_ptr<arrow::ChunkedArray>& chunked_array) {\n+  return ArrayVector__as_vector(chunked_array->length(), chunked_array->chunks());\n+}\n+\n // [[Rcpp::export]]\n std::shared_ptr<arrow::Array> Array__Slice1(const std::shared_ptr<arrow::Array>& array,\n                                             int offset) {\ndiff --git a/r/src/chunkedarray.cpp b/r/src/chunkedarray.cpp\nindex ffb763fecd..06b32d3454 100644\n--- a/r/src/chunkedarray.cpp\n+++ b/r/src/chunkedarray.cpp\n@@ -20,43 +20,6 @@\n using namespace Rcpp;\n using namespace arrow;\n \n-template <int RTYPE>\n-inline SEXP simple_ChunkedArray_to_Vector(\n-    const std::shared_ptr<arrow::ChunkedArray>& chunked_array) {\n-  using value_type = typename Rcpp::Vector<RTYPE>::stored_type;\n-  Rcpp::Vector<RTYPE> out = no_init(chunked_array->length());\n-  auto p = out.begin();\n-\n-  int k = 0;\n-  for (int i = 0; i < chunked_array->num_chunks(); i++) {\n-    auto chunk = chunked_array->chunk(i);\n-    auto n = chunk->length();\n-\n-    // copy the data\n-    auto q = p;\n-    auto p_chunk =\n-        arrow::r::GetValuesSafely<value_type>(chunk->data(), 1, chunk->offset());\n-    STOP_IF_NULL(p_chunk);\n-    p = std::copy_n(p_chunk, n, p);\n-\n-    // set NA using the bitmap\n-    auto bitmap_data = chunk->null_bitmap();\n-    if (bitmap_data && RTYPE != RAWSXP) {\n-      arrow::internal::BitmapReader bitmap_reader(bitmap_data->data(), chunk->offset(),\n-                                                  n);\n-\n-      for (int j = 0; j < n; j++, bitmap_reader.Next()) {\n-        if (bitmap_reader.IsNotSet()) {\n-          q[k + j] = Rcpp::Vector<RTYPE>::get_na();\n-        }\n-      }\n-    }\n-\n-    k += chunk->length();\n-  }\n-  return out;\n-}\n-\n // [[Rcpp::export]]\n int ChunkedArray__length(const std::shared_ptr<arrow::ChunkedArray>& chunked_array) {\n   return chunked_array->length();\n@@ -89,23 +52,6 @@ std::shared_ptr<arrow::DataType> ChunkedArray__type(\n   return chunked_array->type();\n }\n \n-// [[Rcpp::export]]\n-SEXP ChunkedArray__as_vector(const std::shared_ptr<arrow::ChunkedArray>& chunked_array) {\n-  switch (chunked_array->type()->id()) {\n-    case Type::INT8:\n-      return simple_ChunkedArray_to_Vector<RAWSXP>(chunked_array);\n-    case Type::INT32:\n-      return simple_ChunkedArray_to_Vector<INTSXP>(chunked_array);\n-    case Type::DOUBLE:\n-      return simple_ChunkedArray_to_Vector<REALSXP>(chunked_array);\n-    default:\n-      break;\n-  }\n-\n-  stop(tfm::format(\"cannot handle Array of type %d\", chunked_array->type()->id()));\n-  return R_NilValue;\n-}\n-\n // [[Rcpp::export]]\n std::shared_ptr<arrow::ChunkedArray> ChunkArray__Slice1(\n     const std::shared_ptr<arrow::ChunkedArray>& chunked_array, int offset) {\ndiff --git a/r/src/message.cpp b/r/src/message.cpp\nindex 03504b186e..9cfa24bb42 100644\n--- a/r/src/message.cpp\n+++ b/r/src/message.cpp\n@@ -58,7 +58,7 @@ std::shared_ptr<arrow::RecordBatch> ipc___ReadRecordBatch__Message__Schema(\n     const std::unique_ptr<arrow::ipc::Message>& message,\n     const std::shared_ptr<arrow::Schema>& schema) {\n   std::shared_ptr<arrow::RecordBatch> batch;\n-  R_ERROR_NOT_OK(arrow::ipc::ReadRecordBatch(*message, schema, &batch));\n+  STOP_IF_NOT_OK(arrow::ipc::ReadRecordBatch(*message, schema, &batch));\n   return batch;\n }\n \n@@ -66,7 +66,7 @@ std::shared_ptr<arrow::RecordBatch> ipc___ReadRecordBatch__Message__Schema(\n std::shared_ptr<arrow::Schema> ipc___ReadSchema_InputStream(\n     const std::shared_ptr<arrow::io::InputStream>& stream) {\n   std::shared_ptr<arrow::Schema> schema;\n-  R_ERROR_NOT_OK(arrow::ipc::ReadSchema(stream.get(), &schema));\n+  STOP_IF_NOT_OK(arrow::ipc::ReadSchema(stream.get(), &schema));\n   return schema;\n }\n \n@@ -82,7 +82,7 @@ std::unique_ptr<arrow::ipc::MessageReader> ipc___MessageReader__Open(\n std::unique_ptr<arrow::ipc::Message> ipc___MessageReader__ReadNextMessage(\n     const std::unique_ptr<arrow::ipc::MessageReader>& reader) {\n   std::unique_ptr<arrow::ipc::Message> message;\n-  R_ERROR_NOT_OK(reader->ReadNextMessage(&message));\n+  STOP_IF_NOT_OK(reader->ReadNextMessage(&message));\n   return message;\n }\n \n@@ -90,6 +90,6 @@ std::unique_ptr<arrow::ipc::Message> ipc___MessageReader__ReadNextMessage(\n std::unique_ptr<arrow::ipc::Message> ipc___ReadMessage(\n     const std::shared_ptr<arrow::io::InputStream>& stream) {\n   std::unique_ptr<arrow::ipc::Message> message;\n-  R_ERROR_NOT_OK(arrow::ipc::ReadMessage(stream.get(), &message));\n+  STOP_IF_NOT_OK(arrow::ipc::ReadMessage(stream.get(), &message));\n   return message;\n }\ndiff --git a/r/tests/testthat/test-arraydata.R b/r/tests/testthat/test-arraydata.R\nindex 8b154194b2..5d8f8f1dca 100644\n--- a/r/tests/testthat/test-arraydata.R\n+++ b/r/tests/testthat/test-arraydata.R\n@@ -15,7 +15,7 @@\n # specific language governing permissions and limitations\n # under the License.\n \n-context(\"ArrayData\")\n+context(\"arrow::ArrayData\")\n \n test_that(\"string vectors with only empty strings and nulls don't allocate a data buffer (ARROW-3693)\", {\n   a <- array(\"\")\ndiff --git a/r/tests/testthat/test-buffer.R b/r/tests/testthat/test-buffer.R\nindex 1c0336e410..f00386263f 100644\n--- a/r/tests/testthat/test-buffer.R\n+++ b/r/tests/testthat/test-buffer.R\n@@ -15,7 +15,7 @@\n # specific language governing permissions and limitations\n # under the License.\n \n-context(\"test-buffer\")\n+context(\"arrow::Buffer\")\n \n test_that(\"arrow::Buffer can be created from raw vector\", {\n   vec <- raw(123)\ndiff --git a/r/tests/testthat/test-bufferreader.R b/r/tests/testthat/test-bufferreader.R\nindex a78153cbfc..e7680a493f 100644\n--- a/r/tests/testthat/test-bufferreader.R\n+++ b/r/tests/testthat/test-bufferreader.R\n@@ -15,7 +15,7 @@\n # specific language governing permissions and limitations\n # under the License.\n \n-context(\"test-bufferreader\")\n+context(\"arrow::BufferReader\")\n \n test_that(\"BufferReader can be created from R objects\", {\n   num <- buffer_reader(numeric(13))\ndiff --git a/r/tests/testthat/test-chunkedarray.R b/r/tests/testthat/test-chunkedarray.R\nindex b9a5c18d39..4c41f8ae0f 100644\n--- a/r/tests/testthat/test-chunkedarray.R\n+++ b/r/tests/testthat/test-chunkedarray.R\n@@ -82,17 +82,20 @@ test_that(\"ChunkedArray supports logical vectors (ARROW-3341)\", {\n   arr_lgl <- chunked_array(!!!data)\n   expect_equal(arr_lgl$length(), 300L)\n   expect_equal(arr_lgl$null_count(), sum(unlist(map(data, is.na))))\n+  expect_identical(arr_lgl$as_vector(), purrr::flatten_lgl(data))\n \n   chunks <- arr_lgl$chunks()\n   expect_identical(data[[1]], chunks[[1]]$as_vector())\n   expect_identical(data[[2]], chunks[[2]]$as_vector())\n   expect_identical(data[[3]], chunks[[3]]$as_vector())\n \n+\n   # without NA\n   data <- purrr::rerun(3, sample(c(TRUE, FALSE), 100, replace = TRUE))\n   arr_lgl <- chunked_array(!!!data)\n   expect_equal(arr_lgl$length(), 300L)\n   expect_equal(arr_lgl$null_count(), sum(unlist(map(data, is.na))))\n+  expect_identical(arr_lgl$as_vector(), purrr::flatten_lgl(data))\n \n   chunks <- arr_lgl$chunks()\n   expect_identical(data[[1]], chunks[[1]]$as_vector())\n@@ -110,8 +113,48 @@ test_that(\"ChunkedArray supports character vectors (ARROW-3339)\", {\n   arr_chr <- chunked_array(!!!data)\n   expect_equal(arr_chr$length(), length(unlist(data)))\n   expect_equal(arr_chr$null_count(), 1L)\n+  expect_equal(arr_chr$as_vector(), purrr::flatten_chr(data))\n \n   chunks <- arr_chr$chunks()\n   expect_equal(data, purrr::map(chunks, ~.$as_vector()))\n })\n \n+test_that(\"ChunkedArray supports factors (ARROW-3716)\", {\n+  f <- factor(c(\"itsy\", \"bitsy\", \"spider\", \"spider\"))\n+  arr_fac <- chunked_array(f, f, f)\n+  expect_equal(arr_fac$length(), 12L)\n+  expect_equal(arr_fac$type()$index_type(), int8())\n+  expect_identical(arr_fac$as_vector(), vctrs::vec_c(f, f, f))\n+})\n+\n+test_that(\"ChunkedArray supports dates (ARROW-3716)\", {\n+  d <- Sys.Date() + 1:10\n+  a <- chunked_array(d, d)\n+  expect_equal(a$type(), date32())\n+  expect_equal(a$length(), 20L)\n+  expect_equal(a$as_vector(), c(d, d))\n+})\n+\n+test_that(\"ChunkedArray supports POSIXct (ARROW-3716)\", {\n+  times <- lubridate::ymd_hms(\"2018-10-07 19:04:05\") + 1:10\n+  a <- chunked_array(times, times)\n+  expect_equal(a$type(), date64())\n+  expect_equal(a$length(), 20L)\n+  expect_equal(as.numeric(a$as_vector()), as.numeric(c(times, times)))\n+})\n+\n+test_that(\"ChunkedArray supports integer64 (ARROW-3716)\", {\n+  x <- bit64::as.integer64(1:10)\n+  a <- chunked_array(x, x)\n+  expect_equal(a$type(), int64())\n+  expect_equal(a$length(), 20L)\n+  expect_equal(a$as_vector(), c(x,x))\n+})\n+\n+test_that(\"ChunkedArray supports difftime\", {\n+  time <- hms::hms(56, 34, 12)\n+  a <- chunked_array(time, time)\n+  expect_equal(a$type(), time32(unit = TimeUnit$SECOND))\n+  expect_equal(a$length(), 2L)\n+  expect_equal(a$as_vector(), c(time, time))\n+})\ndiff --git a/r/tests/testthat/test-read-write.R b/r/tests/testthat/test-read-write.R\nindex bcf3922028..2af718ebe5 100644\n--- a/r/tests/testthat/test-read-write.R\n+++ b/r/tests/testthat/test-read-write.R\n@@ -15,7 +15,7 @@\n # specific language governing permissions and limitations\n # under the License.\n \n-context(\"test-read-write\")\n+context(\"read-write\")\n \n test_that(\"arrow::table round trip\", {\n   tbl <- tibble::tibble(\ndiff --git a/r/tests/testthat/test-schema.R b/r/tests/testthat/test-schema.R\nindex b5a514eaba..d40fbfa36b 100644\n--- a/r/tests/testthat/test-schema.R\n+++ b/r/tests/testthat/test-schema.R\n@@ -15,7 +15,7 @@\n # specific language governing permissions and limitations\n # under the License.\n \n-context(\"test-schema\")\n+context(\"arrow::Schema\")\n \n test_that(\"reading schema from raw vector\", {\n   batch <- record_batch(tibble::tibble(x = 1:10))\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-10T02:45:41.643+0000",
                    "updated": "2018-11-10T02:45:41.643+0000",
                    "started": "2018-11-10T02:45:41.642+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "164621",
                    "issueId": "13196854"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
            "id": "1",
            "description": "A problem which impairs or prevents the functions of the product.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
            "name": "Bug",
            "subtask": false,
            "avatarId": 21133
        },
        "timespent": 3000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@1bd4b8b0[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@12d0d6dc[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6a3a1e8d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7ec84320[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@47318f06[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@3ab5ebe2[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@c1544f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@3cacd634[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@772e2718[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@625128e4[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@68b86bcd[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@32ff1d98[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 3000,
        "customfield_12312520": null,
        "customfield_12312521": "Sat Nov 10 02:48:20 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-11-10T02:48:20.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3716/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2018-11-07T15:56:17.000+0000",
        "updated": "2018-11-10T02:48:28.000+0000",
        "timeoriginalestimate": null,
        "description": "{code}\r\n library(arrow)\r\n tab <- table(iris)\r\n tab$schema()\r\n #> arrow::Schema \r\n #> Sepal.Length: double\r\n #> Sepal.Width: double\r\n #> Petal.Length: double\r\n #> Petal.Width: double\r\n #> Species: dictionary<values=string, indices=int8, ordered=0>\r\n\r\nas_tibble(tab)\r\n #> Error in Table__to_dataframe(x): cannot handle Array of type 26\r\n # simpler reprex:\r\n a <- chunked_array(factor(c(\"a\", \"b\")))\r\n a$as_vector()\r\n #> Error in ChunkedArray__as_vector(self): cannot handle Array of type 26\r\n{code}",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 3000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[R] Missing cases for ChunkedArray conversion",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13196854/comment/16678765",
                    "id": "16678765",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Should probably also print the {{ToString()}} version of the type",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-11-07T21:00:53.718+0000",
                    "updated": "2018-11-07T21:00:53.718+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13196854/comment/16682161",
                    "id": "16682161",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 2928\n[https://github.com/apache/arrow/pull/2928]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-11-10T02:48:20.494+0000",
                    "updated": "2018-11-10T02:48:20.494+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|s008a0:",
        "customfield_12314139": null
    }
}