{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13328368",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368",
    "key": "ARROW-10043",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12345977",
                "id": "12345977",
                "description": "",
                "name": "2.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-10-19"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
            "name": "Minor",
            "id": "4"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12602610",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12602610",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13339221",
                    "key": "ARROW-10510",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339221",
                    "fields": {
                        "summary": "[Rust] [DataFusion] Add benchmarks for COUNT(DISTINCT)",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
                            "name": "Minor",
                            "id": "4"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=drusso",
            "name": "drusso",
            "key": "drusso",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=drusso&avatarId=43921",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=drusso&avatarId=43921",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=drusso&avatarId=43921",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=drusso&avatarId=43921"
            },
            "displayName": "Daniel Russo",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12335005",
                "id": "12335005",
                "name": "Rust - DataFusion"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=drusso",
            "name": "drusso",
            "key": "drusso",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=drusso&avatarId=43921",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=drusso&avatarId=43921",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=drusso&avatarId=43921",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=drusso&avatarId=43921"
            },
            "displayName": "Daniel Russo",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=drusso",
            "name": "drusso",
            "key": "drusso",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=drusso&avatarId=43921",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=drusso&avatarId=43921",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=drusso&avatarId=43921",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=drusso&avatarId=43921"
            },
            "displayName": "Daniel Russo",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 33600,
            "total": 33600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 33600,
            "total": 33600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10043/votes",
            "votes": 1,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 56,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/486528",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "drusso opened a new pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222\n\n\n   This is a proposal for an initial and partial implementation of the `DISTINCT` keyword. Only `COUNT(DISTINCT)` is supported, with the following conditions:\r\n   \r\n   (a) only one argument, i.e. `COUNT(DISTINCT col)`, but not `COUNT(DISTINCT col, other)`,\r\n   (b) the argument is an integer type, and\r\n   (c) the query must have a `GROUP BY` clause.\r\n   \r\n   **Implementation Overview:**\r\n   \r\n   The `Expr::AggregateFunction` variant has a new field, `distinct`, which mirrors the `distinct` flag from `SQLExpr::Function` (up until now this flag was unused). Any `Expr::AggregateFunction` may have its `distinct` flag switched to `true` if the keyword is present in the SQL query. However, the physical planner respects it only for `COUNT` expressions.\r\n   \r\n   The count distinct aggregation slots into the existing physical plans as a new set of `AggregateExpr`. To demonstrate, below are examples of the physical plans for the following query, where `c1` may be any data type, and `c2` is a `UInt8` column:\r\n   \r\n   ```\r\n   SELECT c1, COUNT(DISTINCT c2) FROM t1 GROUP BY c1\r\n   ```\r\n   \r\n   (a) Multiple Partitions:\r\n   \r\n       HashAggregateExec:\r\n         mode: Final\r\n         group_expr:\r\n           Column(c1)\r\n         aggr_expr:\r\n           DistinctCountReduce(Column(c2))\r\n         schema:\r\n           c1: any\r\n           c2: UInt64\r\n         input:\r\n           MergeExec:\r\n             input:\r\n               HashAggregateExec:\r\n                 mode: Partial\r\n                 group_expr:\r\n                   Column(c1)\r\n                 aggr_expr:\r\n                   DistinctCount(Column(c2))\r\n                 schema:\r\n                   c1: any\r\n                   c2: LargeList(UInt8)\r\n                 input:\r\n                   CsvExec:\r\n                     schema:\r\n                       c1: any\r\n                       c2: UInt8\r\n   \r\n   The `DistinctCount` accumulates each `UInt8` into a list of distinct `UInt8`. No counts are collected yet, this is a partial result: lists of distinct values. In the `RecordBatch`, this is a `LargeListArray<UInt8>` column. After the `MergeExec`, each list in `LargeListArray<UInt8>` is accumulated by `DistinctCountReduce` (via `accumulate_batch()`), producing the _final_ sets of distinct values. Finally, given the finalized sets of distinct values, the counts are computed (always as `UInt64`).\r\n   \r\n   (b) Single Partition:\r\n   \r\n       HashAggregateExec:\r\n         mode: NoPartial\r\n         group_expr:\r\n           Column(c1)\r\n         aggr_expr:\r\n           DistinctCountReduce(Column(c2))\r\n         schema:\r\n           c1: any\r\n           c2: UInt64\r\n         input:\r\n           CsvExec:\r\n             schema:\r\n               c1: any\r\n               c2: UInt8\r\n   \r\n   This scenario is unlike the multiple partition scenario: `DistinctCount` is _not_ used, and there are no partial sets of distinct values. Rather, in a single `HashAggregateExec` stage, each `UInt8` is accumulated into a distinct value set, then the counts are computed at the end of the stage. `DistinctCountReduce` is used, but note that unlike the multiple partition case, it accumulates scalars via `accumulate_scalar()`.\r\n   \r\n   There is a new aggregation mode: `NoPartial`. In summary, the modes are:\r\n   \r\n   - `NoPartial`: used in single-stage aggregations\r\n   - `Partial`: used as the first stage of two-stage aggregations\r\n   - `Final`: used as the second stage of two-stage aggregaions\r\n   \r\n   Prior to the new `NoPartial` mode, `Partial` was handling both of what are now the responsibilities of `Partial` and `NoPartial`. No distinction was required, because _non-distinct_ aggregations (such as count, sum, min, max, and avg) do not need the distinction: the first aggregation stage is always the same, regardless of whether the aggregation is one-stage or two-stage. This is not the case for a _distinct_ count aggregation, and we can see that in the physical plans above.\r\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-19T18:58:59.662+0000",
                    "updated": "2020-09-19T18:58:59.662+0000",
                    "started": "2020-09-19T18:58:59.662+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486528",
                    "issueId": "13328368"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/486530",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222#issuecomment-695345313\n\n\n   https://issues.apache.org/jira/browse/ARROW-10043\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-19T19:05:19.802+0000",
                    "updated": "2020-09-19T19:05:19.802+0000",
                    "started": "2020-09-19T19:05:19.801+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486530",
                    "issueId": "13328368"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/486662",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222#issuecomment-695804292\n\n\n   @jorgecarleitao @alamb fyi\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-20T16:07:27.408+0000",
                    "updated": "2020-09-20T16:07:27.408+0000",
                    "started": "2020-09-20T16:07:27.407+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486662",
                    "issueId": "13328368"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/486666",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222#discussion_r491530453\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/distinct_expressions.rs\n##########\n@@ -0,0 +1,303 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Implementations for DISTINCT expressions, e.g. `COUNT(DISTINCT c)`\n+\n+use std::cell::RefCell;\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use arrow::array::ArrayRef;\n+use arrow::array::{\n+    Int16Array, Int32Array, Int64Array, Int8Array, PrimitiveArrayOps, UInt16Array,\n+    UInt32Array, UInt64Array, UInt8Array,\n+};\n+use arrow::datatypes::{DataType, Schema};\n+use arrow::record_batch::RecordBatch;\n+\n+use fnv::FnvHashSet;\n+\n+use crate::error::{ExecutionError, Result};\n+use crate::logical_plan::ScalarValue;\n+use crate::physical_plan::expressions::Column;\n+use crate::physical_plan::hash_aggregate::AggregateMode;\n+use crate::physical_plan::{Accumulator, AggregateExpr, PhysicalExpr};\n+\n+/// Enumeration of types that can be accumulated into a distinct set of values.\n+#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n+enum DistinctScalarValue {\n\nReview comment:\n       Wouldn't it be possible to use `ScalarValue`, instead of declaring a new enum?\n\n##########\nFile path: rust/datafusion/src/physical_plan/hash_aggregate.rs\n##########\n@@ -48,9 +48,12 @@ use fnv::FnvHashMap;\n /// Hash aggregate modes\n #[derive(Debug, Copy, Clone)]\n pub enum AggregateMode {\n+    /// Aggregate mode without any partial/intermediate aggregation\n+    NoPartial,\n\nReview comment:\n       A naming idea: `SinglePartition`\n\n##########\nFile path: rust/datafusion/src/physical_plan/distinct_expressions.rs\n##########\n@@ -0,0 +1,303 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Implementations for DISTINCT expressions, e.g. `COUNT(DISTINCT c)`\n+\n+use std::cell::RefCell;\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use arrow::array::ArrayRef;\n+use arrow::array::{\n+    Int16Array, Int32Array, Int64Array, Int8Array, PrimitiveArrayOps, UInt16Array,\n+    UInt32Array, UInt64Array, UInt8Array,\n+};\n+use arrow::datatypes::{DataType, Schema};\n+use arrow::record_batch::RecordBatch;\n+\n+use fnv::FnvHashSet;\n+\n+use crate::error::{ExecutionError, Result};\n+use crate::logical_plan::ScalarValue;\n+use crate::physical_plan::expressions::Column;\n+use crate::physical_plan::hash_aggregate::AggregateMode;\n+use crate::physical_plan::{Accumulator, AggregateExpr, PhysicalExpr};\n+\n+/// Enumeration of types that can be accumulated into a distinct set of values.\n+#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n+enum DistinctScalarValue {\n+    Int8(i8),\n+    Int16(i16),\n+    Int32(i32),\n+    Int64(i64),\n+    UInt8(u8),\n+    UInt16(u16),\n+    UInt32(u32),\n+    UInt64(u64),\n+}\n+\n+/// For a given expression, maps its Arrow DataType into a LargeList of the\n+/// same DataType.\n+fn list_of(expr: Arc<dyn PhysicalExpr>, input_schema: &Schema) -> Result<DataType> {\n+    let value_data_type = expr.data_type(input_schema)?;\n+\n+    match value_data_type {\n+        DataType::Int8\n+        | DataType::Int16\n+        | DataType::Int32\n+        | DataType::Int64\n+        | DataType::UInt8\n+        | DataType::UInt16\n+        | DataType::UInt32\n+        | DataType::UInt64 => Ok(DataType::LargeList(Box::new(value_data_type))),\n+        _ => Err(ExecutionError::NotImplemented(\n+            \"Unsupported column data type for DISTINCT\".to_string(),\n+        )),\n+    }\n+}\n+\n+fn accumulate_scalar(\n+    accum: &mut FnvHashSet<DistinctScalarValue>,\n+    value: Option<ScalarValue>,\n+) -> Result<()> {\n+    let accum_value = match value {\n+        Some(ScalarValue::Int8(v)) => Some(DistinctScalarValue::Int8(v)),\n+        Some(ScalarValue::Int16(v)) => Some(DistinctScalarValue::Int16(v)),\n+        Some(ScalarValue::Int32(v)) => Some(DistinctScalarValue::Int32(v)),\n+        Some(ScalarValue::Int64(v)) => Some(DistinctScalarValue::Int64(v)),\n+        Some(ScalarValue::UInt8(v)) => Some(DistinctScalarValue::UInt8(v)),\n+        Some(ScalarValue::UInt16(v)) => Some(DistinctScalarValue::UInt16(v)),\n+        Some(ScalarValue::UInt32(v)) => Some(DistinctScalarValue::UInt32(v)),\n+        Some(ScalarValue::UInt64(v)) => Some(DistinctScalarValue::UInt64(v)),\n+        Some(ScalarValue::Null) => None,\n+        _ => {\n+            return Err(ExecutionError::NotImplemented(\n+                \"Unsupported scalar value for DISTINCT accumulator\".to_string(),\n+            ))\n+        }\n+    };\n+\n+    match accum_value {\n+        Some(v) => {\n+            accum.insert(v);\n+        }\n+        None => {}\n+    }\n+\n+    Ok(())\n+}\n+\n+macro_rules! accum_batch {\n+    ($ARRAY_TY:ident, $DISTINCT_SCALAR_TY: path, $ARRAY: expr, $ACCUM: expr) => {{\n+        let array = $ARRAY.as_any().downcast_ref::<$ARRAY_TY>().ok_or_else(|| {\n+            ExecutionError::ExecutionError(\"Error downcasting array\".to_string())\n+        })?;\n+\n+        for i in 0..array.len() {\n+            $ACCUM.insert($DISTINCT_SCALAR_TY(array.value(i)));\n+        }\n+\n+        Ok(())\n+    }};\n+}\n+\n+#[derive(Debug)]\n+struct DistinctValuesAccumulator {\n+    values: FnvHashSet<DistinctScalarValue>,\n+}\n+\n+impl Accumulator for DistinctValuesAccumulator {\n+    fn accumulate_scalar(&mut self, value: Option<ScalarValue>) -> Result<()> {\n+        accumulate_scalar(&mut self.values, value)\n+    }\n+\n+    fn accumulate_batch(&mut self, _array: &ArrayRef) -> Result<()> {\n+        Err(ExecutionError::NotImplemented(\n+            \"Aggregates with DISTINCT not supported without a GROUP BY\".to_string(),\n+        ))\n+    }\n+\n+    fn get_value(&self) -> Result<Option<ScalarValue>> {\n+        let value_out = self\n+            .values\n+            .iter()\n+            .map(|accumulated_value| match accumulated_value {\n+                DistinctScalarValue::Int8(v) => Ok(ScalarValue::Int8(*v)),\n+                DistinctScalarValue::Int16(v) => Ok(ScalarValue::Int16(*v)),\n+                DistinctScalarValue::Int32(v) => Ok(ScalarValue::Int32(*v)),\n+                DistinctScalarValue::Int64(v) => Ok(ScalarValue::Int64(*v)),\n+                DistinctScalarValue::UInt8(v) => Ok(ScalarValue::UInt8(*v)),\n+                DistinctScalarValue::UInt16(v) => Ok(ScalarValue::UInt16(*v)),\n+                DistinctScalarValue::UInt32(v) => Ok(ScalarValue::UInt32(*v)),\n+                DistinctScalarValue::UInt64(v) => Ok(ScalarValue::UInt64(*v)),\n+            })\n+            .collect::<Result<Vec<ScalarValue>>>()?;\n+\n+        Ok(Some(ScalarValue::Struct(value_out)))\n+    }\n+}\n+\n+/// Create a distint count expression.\n+pub fn count(mode: AggregateMode, expr: Arc<dyn PhysicalExpr>) -> Arc<dyn AggregateExpr> {\n\nReview comment:\n       Note that this will not apply any coercion to the arguments. We are trying to make `aggregates::create_aggregate_expr` be the entry point to create the physical expressions, to guarantee that the signature is correct and coercion rules apply.\r\n   \r\n   However, I see that this depends on the `AggregateMode`, which the current `create_aggregate_expr` does not support. #8172 addresses exactly this. :)\n\n##########\nFile path: rust/datafusion/src/physical_plan/distinct_expressions.rs\n##########\n@@ -0,0 +1,303 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Implementations for DISTINCT expressions, e.g. `COUNT(DISTINCT c)`\n+\n+use std::cell::RefCell;\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use arrow::array::ArrayRef;\n+use arrow::array::{\n+    Int16Array, Int32Array, Int64Array, Int8Array, PrimitiveArrayOps, UInt16Array,\n+    UInt32Array, UInt64Array, UInt8Array,\n+};\n+use arrow::datatypes::{DataType, Schema};\n+use arrow::record_batch::RecordBatch;\n+\n+use fnv::FnvHashSet;\n+\n+use crate::error::{ExecutionError, Result};\n+use crate::logical_plan::ScalarValue;\n+use crate::physical_plan::expressions::Column;\n+use crate::physical_plan::hash_aggregate::AggregateMode;\n+use crate::physical_plan::{Accumulator, AggregateExpr, PhysicalExpr};\n+\n+/// Enumeration of types that can be accumulated into a distinct set of values.\n+#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n+enum DistinctScalarValue {\n+    Int8(i8),\n+    Int16(i16),\n+    Int32(i32),\n+    Int64(i64),\n+    UInt8(u8),\n+    UInt16(u16),\n+    UInt32(u32),\n+    UInt64(u64),\n+}\n+\n+/// For a given expression, maps its Arrow DataType into a LargeList of the\n+/// same DataType.\n+fn list_of(expr: Arc<dyn PhysicalExpr>, input_schema: &Schema) -> Result<DataType> {\n+    let value_data_type = expr.data_type(input_schema)?;\n+\n+    match value_data_type {\n+        DataType::Int8\n+        | DataType::Int16\n+        | DataType::Int32\n+        | DataType::Int64\n+        | DataType::UInt8\n+        | DataType::UInt16\n+        | DataType::UInt32\n+        | DataType::UInt64 => Ok(DataType::LargeList(Box::new(value_data_type))),\n+        _ => Err(ExecutionError::NotImplemented(\n+            \"Unsupported column data type for DISTINCT\".to_string(),\n+        )),\n+    }\n+}\n+\n+fn accumulate_scalar(\n+    accum: &mut FnvHashSet<DistinctScalarValue>,\n+    value: Option<ScalarValue>,\n+) -> Result<()> {\n+    let accum_value = match value {\n+        Some(ScalarValue::Int8(v)) => Some(DistinctScalarValue::Int8(v)),\n+        Some(ScalarValue::Int16(v)) => Some(DistinctScalarValue::Int16(v)),\n+        Some(ScalarValue::Int32(v)) => Some(DistinctScalarValue::Int32(v)),\n+        Some(ScalarValue::Int64(v)) => Some(DistinctScalarValue::Int64(v)),\n+        Some(ScalarValue::UInt8(v)) => Some(DistinctScalarValue::UInt8(v)),\n+        Some(ScalarValue::UInt16(v)) => Some(DistinctScalarValue::UInt16(v)),\n+        Some(ScalarValue::UInt32(v)) => Some(DistinctScalarValue::UInt32(v)),\n+        Some(ScalarValue::UInt64(v)) => Some(DistinctScalarValue::UInt64(v)),\n+        Some(ScalarValue::Null) => None,\n+        _ => {\n+            return Err(ExecutionError::NotImplemented(\n+                \"Unsupported scalar value for DISTINCT accumulator\".to_string(),\n+            ))\n+        }\n+    };\n+\n+    match accum_value {\n+        Some(v) => {\n+            accum.insert(v);\n+        }\n+        None => {}\n+    }\n+\n+    Ok(())\n+}\n+\n+macro_rules! accum_batch {\n+    ($ARRAY_TY:ident, $DISTINCT_SCALAR_TY: path, $ARRAY: expr, $ACCUM: expr) => {{\n+        let array = $ARRAY.as_any().downcast_ref::<$ARRAY_TY>().ok_or_else(|| {\n+            ExecutionError::ExecutionError(\"Error downcasting array\".to_string())\n+        })?;\n+\n+        for i in 0..array.len() {\n+            $ACCUM.insert($DISTINCT_SCALAR_TY(array.value(i)));\n+        }\n+\n+        Ok(())\n+    }};\n+}\n+\n+#[derive(Debug)]\n+struct DistinctValuesAccumulator {\n+    values: FnvHashSet<DistinctScalarValue>,\n+}\n+\n+impl Accumulator for DistinctValuesAccumulator {\n+    fn accumulate_scalar(&mut self, value: Option<ScalarValue>) -> Result<()> {\n+        accumulate_scalar(&mut self.values, value)\n+    }\n+\n+    fn accumulate_batch(&mut self, _array: &ArrayRef) -> Result<()> {\n+        Err(ExecutionError::NotImplemented(\n+            \"Aggregates with DISTINCT not supported without a GROUP BY\".to_string(),\n+        ))\n+    }\n+\n+    fn get_value(&self) -> Result<Option<ScalarValue>> {\n+        let value_out = self\n+            .values\n+            .iter()\n+            .map(|accumulated_value| match accumulated_value {\n+                DistinctScalarValue::Int8(v) => Ok(ScalarValue::Int8(*v)),\n\nReview comment:\n       ... and back: `DistinctScalarValue -> ScalarValue`\n\n##########\nFile path: rust/datafusion/src/physical_plan/distinct_expressions.rs\n##########\n@@ -0,0 +1,303 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Implementations for DISTINCT expressions, e.g. `COUNT(DISTINCT c)`\n+\n+use std::cell::RefCell;\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use arrow::array::ArrayRef;\n+use arrow::array::{\n+    Int16Array, Int32Array, Int64Array, Int8Array, PrimitiveArrayOps, UInt16Array,\n+    UInt32Array, UInt64Array, UInt8Array,\n+};\n+use arrow::datatypes::{DataType, Schema};\n+use arrow::record_batch::RecordBatch;\n+\n+use fnv::FnvHashSet;\n+\n+use crate::error::{ExecutionError, Result};\n+use crate::logical_plan::ScalarValue;\n+use crate::physical_plan::expressions::Column;\n+use crate::physical_plan::hash_aggregate::AggregateMode;\n+use crate::physical_plan::{Accumulator, AggregateExpr, PhysicalExpr};\n+\n+/// Enumeration of types that can be accumulated into a distinct set of values.\n+#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n+enum DistinctScalarValue {\n+    Int8(i8),\n+    Int16(i16),\n+    Int32(i32),\n+    Int64(i64),\n+    UInt8(u8),\n+    UInt16(u16),\n+    UInt32(u32),\n+    UInt64(u64),\n+}\n+\n+/// For a given expression, maps its Arrow DataType into a LargeList of the\n+/// same DataType.\n+fn list_of(expr: Arc<dyn PhysicalExpr>, input_schema: &Schema) -> Result<DataType> {\n+    let value_data_type = expr.data_type(input_schema)?;\n+\n+    match value_data_type {\n+        DataType::Int8\n+        | DataType::Int16\n+        | DataType::Int32\n+        | DataType::Int64\n+        | DataType::UInt8\n+        | DataType::UInt16\n+        | DataType::UInt32\n+        | DataType::UInt64 => Ok(DataType::LargeList(Box::new(value_data_type))),\n+        _ => Err(ExecutionError::NotImplemented(\n+            \"Unsupported column data type for DISTINCT\".to_string(),\n+        )),\n+    }\n+}\n+\n+fn accumulate_scalar(\n+    accum: &mut FnvHashSet<DistinctScalarValue>,\n+    value: Option<ScalarValue>,\n+) -> Result<()> {\n+    let accum_value = match value {\n+        Some(ScalarValue::Int8(v)) => Some(DistinctScalarValue::Int8(v)),\n\nReview comment:\n       ... this way, we do not need to go `ScalarValue -> DistinctScalarValue`...\n\n##########\nFile path: rust/datafusion/src/physical_plan/distinct_expressions.rs\n##########\n@@ -0,0 +1,303 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Implementations for DISTINCT expressions, e.g. `COUNT(DISTINCT c)`\n+\n+use std::cell::RefCell;\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use arrow::array::ArrayRef;\n+use arrow::array::{\n+    Int16Array, Int32Array, Int64Array, Int8Array, PrimitiveArrayOps, UInt16Array,\n+    UInt32Array, UInt64Array, UInt8Array,\n+};\n+use arrow::datatypes::{DataType, Schema};\n+use arrow::record_batch::RecordBatch;\n+\n+use fnv::FnvHashSet;\n+\n+use crate::error::{ExecutionError, Result};\n+use crate::logical_plan::ScalarValue;\n+use crate::physical_plan::expressions::Column;\n+use crate::physical_plan::hash_aggregate::AggregateMode;\n+use crate::physical_plan::{Accumulator, AggregateExpr, PhysicalExpr};\n+\n+/// Enumeration of types that can be accumulated into a distinct set of values.\n+#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n+enum DistinctScalarValue {\n+    Int8(i8),\n+    Int16(i16),\n+    Int32(i32),\n+    Int64(i64),\n+    UInt8(u8),\n+    UInt16(u16),\n+    UInt32(u32),\n+    UInt64(u64),\n+}\n+\n+/// For a given expression, maps its Arrow DataType into a LargeList of the\n+/// same DataType.\n+fn list_of(expr: Arc<dyn PhysicalExpr>, input_schema: &Schema) -> Result<DataType> {\n+    let value_data_type = expr.data_type(input_schema)?;\n+\n+    match value_data_type {\n+        DataType::Int8\n+        | DataType::Int16\n+        | DataType::Int32\n+        | DataType::Int64\n+        | DataType::UInt8\n+        | DataType::UInt16\n+        | DataType::UInt32\n+        | DataType::UInt64 => Ok(DataType::LargeList(Box::new(value_data_type))),\n+        _ => Err(ExecutionError::NotImplemented(\n+            \"Unsupported column data type for DISTINCT\".to_string(),\n+        )),\n+    }\n+}\n+\n+fn accumulate_scalar(\n+    accum: &mut FnvHashSet<DistinctScalarValue>,\n+    value: Option<ScalarValue>,\n+) -> Result<()> {\n+    let accum_value = match value {\n+        Some(ScalarValue::Int8(v)) => Some(DistinctScalarValue::Int8(v)),\n+        Some(ScalarValue::Int16(v)) => Some(DistinctScalarValue::Int16(v)),\n+        Some(ScalarValue::Int32(v)) => Some(DistinctScalarValue::Int32(v)),\n+        Some(ScalarValue::Int64(v)) => Some(DistinctScalarValue::Int64(v)),\n+        Some(ScalarValue::UInt8(v)) => Some(DistinctScalarValue::UInt8(v)),\n+        Some(ScalarValue::UInt16(v)) => Some(DistinctScalarValue::UInt16(v)),\n+        Some(ScalarValue::UInt32(v)) => Some(DistinctScalarValue::UInt32(v)),\n+        Some(ScalarValue::UInt64(v)) => Some(DistinctScalarValue::UInt64(v)),\n+        Some(ScalarValue::Null) => None,\n+        _ => {\n+            return Err(ExecutionError::NotImplemented(\n+                \"Unsupported scalar value for DISTINCT accumulator\".to_string(),\n+            ))\n+        }\n+    };\n+\n+    match accum_value {\n+        Some(v) => {\n+            accum.insert(v);\n+        }\n+        None => {}\n+    }\n+\n+    Ok(())\n+}\n+\n+macro_rules! accum_batch {\n+    ($ARRAY_TY:ident, $DISTINCT_SCALAR_TY: path, $ARRAY: expr, $ACCUM: expr) => {{\n+        let array = $ARRAY.as_any().downcast_ref::<$ARRAY_TY>().ok_or_else(|| {\n+            ExecutionError::ExecutionError(\"Error downcasting array\".to_string())\n+        })?;\n+\n+        for i in 0..array.len() {\n+            $ACCUM.insert($DISTINCT_SCALAR_TY(array.value(i)));\n+        }\n+\n+        Ok(())\n+    }};\n+}\n+\n+#[derive(Debug)]\n+struct DistinctValuesAccumulator {\n+    values: FnvHashSet<DistinctScalarValue>,\n+}\n+\n+impl Accumulator for DistinctValuesAccumulator {\n+    fn accumulate_scalar(&mut self, value: Option<ScalarValue>) -> Result<()> {\n+        accumulate_scalar(&mut self.values, value)\n+    }\n+\n+    fn accumulate_batch(&mut self, _array: &ArrayRef) -> Result<()> {\n+        Err(ExecutionError::NotImplemented(\n\nReview comment:\n       Wouldn't it be possible to implement this one here? Loop through the elements one by one.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-20T16:57:27.966+0000",
                    "updated": "2020-09-20T16:57:27.966+0000",
                    "started": "2020-09-20T16:57:27.966+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486666",
                    "issueId": "13328368"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/486816",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jhorstmann commented on a change in pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222#discussion_r491869035\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/distinct_expressions.rs\n##########\n@@ -0,0 +1,303 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Implementations for DISTINCT expressions, e.g. `COUNT(DISTINCT c)`\n+\n+use std::cell::RefCell;\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use arrow::array::ArrayRef;\n+use arrow::array::{\n+    Int16Array, Int32Array, Int64Array, Int8Array, PrimitiveArrayOps, UInt16Array,\n+    UInt32Array, UInt64Array, UInt8Array,\n+};\n+use arrow::datatypes::{DataType, Schema};\n+use arrow::record_batch::RecordBatch;\n+\n+use fnv::FnvHashSet;\n+\n+use crate::error::{ExecutionError, Result};\n+use crate::logical_plan::ScalarValue;\n+use crate::physical_plan::expressions::Column;\n+use crate::physical_plan::hash_aggregate::AggregateMode;\n+use crate::physical_plan::{Accumulator, AggregateExpr, PhysicalExpr};\n+\n+/// Enumeration of types that can be accumulated into a distinct set of values.\n+#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n+enum DistinctScalarValue {\n+    Int8(i8),\n+    Int16(i16),\n+    Int32(i32),\n+    Int64(i64),\n+    UInt8(u8),\n+    UInt16(u16),\n+    UInt32(u32),\n+    UInt64(u64),\n+}\n+\n+/// For a given expression, maps its Arrow DataType into a LargeList of the\n+/// same DataType.\n+fn list_of(expr: Arc<dyn PhysicalExpr>, input_schema: &Schema) -> Result<DataType> {\n+    let value_data_type = expr.data_type(input_schema)?;\n+\n+    match value_data_type {\n+        DataType::Int8\n+        | DataType::Int16\n+        | DataType::Int32\n+        | DataType::Int64\n+        | DataType::UInt8\n+        | DataType::UInt16\n+        | DataType::UInt32\n+        | DataType::UInt64 => Ok(DataType::LargeList(Box::new(value_data_type))),\n+        _ => Err(ExecutionError::NotImplemented(\n+            \"Unsupported column data type for DISTINCT\".to_string(),\n+        )),\n+    }\n+}\n+\n+fn accumulate_scalar(\n+    accum: &mut FnvHashSet<DistinctScalarValue>,\n+    value: Option<ScalarValue>,\n+) -> Result<()> {\n+    let accum_value = match value {\n+        Some(ScalarValue::Int8(v)) => Some(DistinctScalarValue::Int8(v)),\n+        Some(ScalarValue::Int16(v)) => Some(DistinctScalarValue::Int16(v)),\n+        Some(ScalarValue::Int32(v)) => Some(DistinctScalarValue::Int32(v)),\n+        Some(ScalarValue::Int64(v)) => Some(DistinctScalarValue::Int64(v)),\n+        Some(ScalarValue::UInt8(v)) => Some(DistinctScalarValue::UInt8(v)),\n+        Some(ScalarValue::UInt16(v)) => Some(DistinctScalarValue::UInt16(v)),\n+        Some(ScalarValue::UInt32(v)) => Some(DistinctScalarValue::UInt32(v)),\n+        Some(ScalarValue::UInt64(v)) => Some(DistinctScalarValue::UInt64(v)),\n+        Some(ScalarValue::Null) => None,\n+        _ => {\n+            return Err(ExecutionError::NotImplemented(\n+                \"Unsupported scalar value for DISTINCT accumulator\".to_string(),\n+            ))\n+        }\n+    };\n+\n+    match accum_value {\n+        Some(v) => {\n+            accum.insert(v);\n+        }\n+        None => {}\n+    }\n+\n+    Ok(())\n+}\n+\n+macro_rules! accum_batch {\n+    ($ARRAY_TY:ident, $DISTINCT_SCALAR_TY: path, $ARRAY: expr, $ACCUM: expr) => {{\n+        let array = $ARRAY.as_any().downcast_ref::<$ARRAY_TY>().ok_or_else(|| {\n+            ExecutionError::ExecutionError(\"Error downcasting array\".to_string())\n+        })?;\n+\n+        for i in 0..array.len() {\n+            $ACCUM.insert($DISTINCT_SCALAR_TY(array.value(i)));\n+        }\n+\n+        Ok(())\n+    }};\n+}\n+\n+#[derive(Debug)]\n+struct DistinctValuesAccumulator {\n+    values: FnvHashSet<DistinctScalarValue>,\n\nReview comment:\n       A more efficient implementation for distinct integers could be a bitset\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-21T08:28:34.542+0000",
                    "updated": "2020-09-21T08:28:34.542+0000",
                    "started": "2020-09-21T08:28:34.542+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486816",
                    "issueId": "13328368"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/486947",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on a change in pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222#discussion_r492074780\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/hash_aggregate.rs\n##########\n@@ -48,9 +48,12 @@ use fnv::FnvHashMap;\n /// Hash aggregate modes\n #[derive(Debug, Copy, Clone)]\n pub enum AggregateMode {\n+    /// Aggregate mode without any partial/intermediate aggregation\n+    NoPartial,\n\nReview comment:\n       Spark uses the term `Complete`. Our existing names `Partial` and `Final` were based on Spark's naming.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-21T14:09:54.188+0000",
                    "updated": "2020-09-21T14:09:54.188+0000",
                    "started": "2020-09-21T14:09:54.188+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486947",
                    "issueId": "13328368"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/486948",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on a change in pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222#discussion_r492075137\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/hash_aggregate.rs\n##########\n@@ -48,9 +48,12 @@ use fnv::FnvHashMap;\n /// Hash aggregate modes\n #[derive(Debug, Copy, Clone)]\n pub enum AggregateMode {\n+    /// Aggregate mode without any partial/intermediate aggregation\n+    NoPartial,\n\nReview comment:\n       ```\r\n   /**\r\n    * An [[AggregateFunction]] with [[Complete]] mode is used to evaluate this function directly\r\n    * from original input rows without any partial aggregation.\r\n    * This function updates the given aggregation buffer with the original input of this\r\n    * function. When it has processed all input rows, the final result of this function is returned.\r\n    */\r\n   case object Complete extends AggregateMode\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-21T14:10:17.452+0000",
                    "updated": "2020-09-21T14:10:17.452+0000",
                    "started": "2020-09-21T14:10:17.451+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486948",
                    "issueId": "13328368"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/486950",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on a change in pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222#discussion_r492076215\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/hash_aggregate.rs\n##########\n@@ -374,6 +380,18 @@ impl RecordBatchReader for GroupedHashAggregateIterator {\n                         col,\n                         accums\n                     ),\n+                    DataType::LargeList(_) => {\n+                        let len = array.len();\n+                        let list_array =\n+                            array.as_any().downcast_ref::<LargeListArray>().unwrap();\n\nReview comment:\n       nit: I'd prefer that we use `expect` rather than `unwrap` so we can add a meaningful message.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-21T14:11:16.347+0000",
                    "updated": "2020-09-21T14:11:16.347+0000",
                    "started": "2020-09-21T14:11:16.347+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486950",
                    "issueId": "13328368"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/486952",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222#issuecomment-696140653\n\n\n   Thanks @drusso this looks great. I agree with Jorge's comments about ScalarValue and I also added some minor comments.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-21T14:12:12.958+0000",
                    "updated": "2020-09-21T14:12:12.958+0000",
                    "started": "2020-09-21T14:12:12.958+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486952",
                    "issueId": "13328368"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/487440",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jhorstmann commented on a change in pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222#discussion_r491869035\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/distinct_expressions.rs\n##########\n@@ -0,0 +1,303 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Implementations for DISTINCT expressions, e.g. `COUNT(DISTINCT c)`\n+\n+use std::cell::RefCell;\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use arrow::array::ArrayRef;\n+use arrow::array::{\n+    Int16Array, Int32Array, Int64Array, Int8Array, PrimitiveArrayOps, UInt16Array,\n+    UInt32Array, UInt64Array, UInt8Array,\n+};\n+use arrow::datatypes::{DataType, Schema};\n+use arrow::record_batch::RecordBatch;\n+\n+use fnv::FnvHashSet;\n+\n+use crate::error::{ExecutionError, Result};\n+use crate::logical_plan::ScalarValue;\n+use crate::physical_plan::expressions::Column;\n+use crate::physical_plan::hash_aggregate::AggregateMode;\n+use crate::physical_plan::{Accumulator, AggregateExpr, PhysicalExpr};\n+\n+/// Enumeration of types that can be accumulated into a distinct set of values.\n+#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n+enum DistinctScalarValue {\n+    Int8(i8),\n+    Int16(i16),\n+    Int32(i32),\n+    Int64(i64),\n+    UInt8(u8),\n+    UInt16(u16),\n+    UInt32(u32),\n+    UInt64(u64),\n+}\n+\n+/// For a given expression, maps its Arrow DataType into a LargeList of the\n+/// same DataType.\n+fn list_of(expr: Arc<dyn PhysicalExpr>, input_schema: &Schema) -> Result<DataType> {\n+    let value_data_type = expr.data_type(input_schema)?;\n+\n+    match value_data_type {\n+        DataType::Int8\n+        | DataType::Int16\n+        | DataType::Int32\n+        | DataType::Int64\n+        | DataType::UInt8\n+        | DataType::UInt16\n+        | DataType::UInt32\n+        | DataType::UInt64 => Ok(DataType::LargeList(Box::new(value_data_type))),\n+        _ => Err(ExecutionError::NotImplemented(\n+            \"Unsupported column data type for DISTINCT\".to_string(),\n+        )),\n+    }\n+}\n+\n+fn accumulate_scalar(\n+    accum: &mut FnvHashSet<DistinctScalarValue>,\n+    value: Option<ScalarValue>,\n+) -> Result<()> {\n+    let accum_value = match value {\n+        Some(ScalarValue::Int8(v)) => Some(DistinctScalarValue::Int8(v)),\n+        Some(ScalarValue::Int16(v)) => Some(DistinctScalarValue::Int16(v)),\n+        Some(ScalarValue::Int32(v)) => Some(DistinctScalarValue::Int32(v)),\n+        Some(ScalarValue::Int64(v)) => Some(DistinctScalarValue::Int64(v)),\n+        Some(ScalarValue::UInt8(v)) => Some(DistinctScalarValue::UInt8(v)),\n+        Some(ScalarValue::UInt16(v)) => Some(DistinctScalarValue::UInt16(v)),\n+        Some(ScalarValue::UInt32(v)) => Some(DistinctScalarValue::UInt32(v)),\n+        Some(ScalarValue::UInt64(v)) => Some(DistinctScalarValue::UInt64(v)),\n+        Some(ScalarValue::Null) => None,\n+        _ => {\n+            return Err(ExecutionError::NotImplemented(\n+                \"Unsupported scalar value for DISTINCT accumulator\".to_string(),\n+            ))\n+        }\n+    };\n+\n+    match accum_value {\n+        Some(v) => {\n+            accum.insert(v);\n+        }\n+        None => {}\n+    }\n+\n+    Ok(())\n+}\n+\n+macro_rules! accum_batch {\n+    ($ARRAY_TY:ident, $DISTINCT_SCALAR_TY: path, $ARRAY: expr, $ACCUM: expr) => {{\n+        let array = $ARRAY.as_any().downcast_ref::<$ARRAY_TY>().ok_or_else(|| {\n+            ExecutionError::ExecutionError(\"Error downcasting array\".to_string())\n+        })?;\n+\n+        for i in 0..array.len() {\n+            $ACCUM.insert($DISTINCT_SCALAR_TY(array.value(i)));\n+        }\n+\n+        Ok(())\n+    }};\n+}\n+\n+#[derive(Debug)]\n+struct DistinctValuesAccumulator {\n+    values: FnvHashSet<DistinctScalarValue>,\n\nReview comment:\n       A more efficient implementation for distinct integers could be a bitset\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-22T03:01:30.912+0000",
                    "updated": "2020-09-22T03:01:30.912+0000",
                    "started": "2020-09-22T03:01:30.912+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "487440",
                    "issueId": "13328368"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/487508",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222#discussion_r491530453\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/distinct_expressions.rs\n##########\n@@ -0,0 +1,303 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Implementations for DISTINCT expressions, e.g. `COUNT(DISTINCT c)`\n+\n+use std::cell::RefCell;\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use arrow::array::ArrayRef;\n+use arrow::array::{\n+    Int16Array, Int32Array, Int64Array, Int8Array, PrimitiveArrayOps, UInt16Array,\n+    UInt32Array, UInt64Array, UInt8Array,\n+};\n+use arrow::datatypes::{DataType, Schema};\n+use arrow::record_batch::RecordBatch;\n+\n+use fnv::FnvHashSet;\n+\n+use crate::error::{ExecutionError, Result};\n+use crate::logical_plan::ScalarValue;\n+use crate::physical_plan::expressions::Column;\n+use crate::physical_plan::hash_aggregate::AggregateMode;\n+use crate::physical_plan::{Accumulator, AggregateExpr, PhysicalExpr};\n+\n+/// Enumeration of types that can be accumulated into a distinct set of values.\n+#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n+enum DistinctScalarValue {\n\nReview comment:\n       Wouldn't it be possible to use `ScalarValue`, instead of declaring a new enum?\n\n##########\nFile path: rust/datafusion/src/physical_plan/hash_aggregate.rs\n##########\n@@ -48,9 +48,12 @@ use fnv::FnvHashMap;\n /// Hash aggregate modes\n #[derive(Debug, Copy, Clone)]\n pub enum AggregateMode {\n+    /// Aggregate mode without any partial/intermediate aggregation\n+    NoPartial,\n\nReview comment:\n       A naming idea: `SinglePartition`\n\n##########\nFile path: rust/datafusion/src/physical_plan/distinct_expressions.rs\n##########\n@@ -0,0 +1,303 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Implementations for DISTINCT expressions, e.g. `COUNT(DISTINCT c)`\n+\n+use std::cell::RefCell;\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use arrow::array::ArrayRef;\n+use arrow::array::{\n+    Int16Array, Int32Array, Int64Array, Int8Array, PrimitiveArrayOps, UInt16Array,\n+    UInt32Array, UInt64Array, UInt8Array,\n+};\n+use arrow::datatypes::{DataType, Schema};\n+use arrow::record_batch::RecordBatch;\n+\n+use fnv::FnvHashSet;\n+\n+use crate::error::{ExecutionError, Result};\n+use crate::logical_plan::ScalarValue;\n+use crate::physical_plan::expressions::Column;\n+use crate::physical_plan::hash_aggregate::AggregateMode;\n+use crate::physical_plan::{Accumulator, AggregateExpr, PhysicalExpr};\n+\n+/// Enumeration of types that can be accumulated into a distinct set of values.\n+#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n+enum DistinctScalarValue {\n+    Int8(i8),\n+    Int16(i16),\n+    Int32(i32),\n+    Int64(i64),\n+    UInt8(u8),\n+    UInt16(u16),\n+    UInt32(u32),\n+    UInt64(u64),\n+}\n+\n+/// For a given expression, maps its Arrow DataType into a LargeList of the\n+/// same DataType.\n+fn list_of(expr: Arc<dyn PhysicalExpr>, input_schema: &Schema) -> Result<DataType> {\n+    let value_data_type = expr.data_type(input_schema)?;\n+\n+    match value_data_type {\n+        DataType::Int8\n+        | DataType::Int16\n+        | DataType::Int32\n+        | DataType::Int64\n+        | DataType::UInt8\n+        | DataType::UInt16\n+        | DataType::UInt32\n+        | DataType::UInt64 => Ok(DataType::LargeList(Box::new(value_data_type))),\n+        _ => Err(ExecutionError::NotImplemented(\n+            \"Unsupported column data type for DISTINCT\".to_string(),\n+        )),\n+    }\n+}\n+\n+fn accumulate_scalar(\n+    accum: &mut FnvHashSet<DistinctScalarValue>,\n+    value: Option<ScalarValue>,\n+) -> Result<()> {\n+    let accum_value = match value {\n+        Some(ScalarValue::Int8(v)) => Some(DistinctScalarValue::Int8(v)),\n+        Some(ScalarValue::Int16(v)) => Some(DistinctScalarValue::Int16(v)),\n+        Some(ScalarValue::Int32(v)) => Some(DistinctScalarValue::Int32(v)),\n+        Some(ScalarValue::Int64(v)) => Some(DistinctScalarValue::Int64(v)),\n+        Some(ScalarValue::UInt8(v)) => Some(DistinctScalarValue::UInt8(v)),\n+        Some(ScalarValue::UInt16(v)) => Some(DistinctScalarValue::UInt16(v)),\n+        Some(ScalarValue::UInt32(v)) => Some(DistinctScalarValue::UInt32(v)),\n+        Some(ScalarValue::UInt64(v)) => Some(DistinctScalarValue::UInt64(v)),\n+        Some(ScalarValue::Null) => None,\n+        _ => {\n+            return Err(ExecutionError::NotImplemented(\n+                \"Unsupported scalar value for DISTINCT accumulator\".to_string(),\n+            ))\n+        }\n+    };\n+\n+    match accum_value {\n+        Some(v) => {\n+            accum.insert(v);\n+        }\n+        None => {}\n+    }\n+\n+    Ok(())\n+}\n+\n+macro_rules! accum_batch {\n+    ($ARRAY_TY:ident, $DISTINCT_SCALAR_TY: path, $ARRAY: expr, $ACCUM: expr) => {{\n+        let array = $ARRAY.as_any().downcast_ref::<$ARRAY_TY>().ok_or_else(|| {\n+            ExecutionError::ExecutionError(\"Error downcasting array\".to_string())\n+        })?;\n+\n+        for i in 0..array.len() {\n+            $ACCUM.insert($DISTINCT_SCALAR_TY(array.value(i)));\n+        }\n+\n+        Ok(())\n+    }};\n+}\n+\n+#[derive(Debug)]\n+struct DistinctValuesAccumulator {\n+    values: FnvHashSet<DistinctScalarValue>,\n+}\n+\n+impl Accumulator for DistinctValuesAccumulator {\n+    fn accumulate_scalar(&mut self, value: Option<ScalarValue>) -> Result<()> {\n+        accumulate_scalar(&mut self.values, value)\n+    }\n+\n+    fn accumulate_batch(&mut self, _array: &ArrayRef) -> Result<()> {\n+        Err(ExecutionError::NotImplemented(\n+            \"Aggregates with DISTINCT not supported without a GROUP BY\".to_string(),\n+        ))\n+    }\n+\n+    fn get_value(&self) -> Result<Option<ScalarValue>> {\n+        let value_out = self\n+            .values\n+            .iter()\n+            .map(|accumulated_value| match accumulated_value {\n+                DistinctScalarValue::Int8(v) => Ok(ScalarValue::Int8(*v)),\n+                DistinctScalarValue::Int16(v) => Ok(ScalarValue::Int16(*v)),\n+                DistinctScalarValue::Int32(v) => Ok(ScalarValue::Int32(*v)),\n+                DistinctScalarValue::Int64(v) => Ok(ScalarValue::Int64(*v)),\n+                DistinctScalarValue::UInt8(v) => Ok(ScalarValue::UInt8(*v)),\n+                DistinctScalarValue::UInt16(v) => Ok(ScalarValue::UInt16(*v)),\n+                DistinctScalarValue::UInt32(v) => Ok(ScalarValue::UInt32(*v)),\n+                DistinctScalarValue::UInt64(v) => Ok(ScalarValue::UInt64(*v)),\n+            })\n+            .collect::<Result<Vec<ScalarValue>>>()?;\n+\n+        Ok(Some(ScalarValue::Struct(value_out)))\n+    }\n+}\n+\n+/// Create a distint count expression.\n+pub fn count(mode: AggregateMode, expr: Arc<dyn PhysicalExpr>) -> Arc<dyn AggregateExpr> {\n\nReview comment:\n       Note that this will not apply any coercion to the arguments. We are trying to make `aggregates::create_aggregate_expr` be the entry point to create the physical expressions, to guarantee that the signature is correct and coercion rules apply.\r\n   \r\n   However, I see that this depends on the `AggregateMode`, which the current `create_aggregate_expr` does not support. #8172 addresses exactly this. :)\n\n##########\nFile path: rust/datafusion/src/physical_plan/distinct_expressions.rs\n##########\n@@ -0,0 +1,303 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Implementations for DISTINCT expressions, e.g. `COUNT(DISTINCT c)`\n+\n+use std::cell::RefCell;\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use arrow::array::ArrayRef;\n+use arrow::array::{\n+    Int16Array, Int32Array, Int64Array, Int8Array, PrimitiveArrayOps, UInt16Array,\n+    UInt32Array, UInt64Array, UInt8Array,\n+};\n+use arrow::datatypes::{DataType, Schema};\n+use arrow::record_batch::RecordBatch;\n+\n+use fnv::FnvHashSet;\n+\n+use crate::error::{ExecutionError, Result};\n+use crate::logical_plan::ScalarValue;\n+use crate::physical_plan::expressions::Column;\n+use crate::physical_plan::hash_aggregate::AggregateMode;\n+use crate::physical_plan::{Accumulator, AggregateExpr, PhysicalExpr};\n+\n+/// Enumeration of types that can be accumulated into a distinct set of values.\n+#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n+enum DistinctScalarValue {\n+    Int8(i8),\n+    Int16(i16),\n+    Int32(i32),\n+    Int64(i64),\n+    UInt8(u8),\n+    UInt16(u16),\n+    UInt32(u32),\n+    UInt64(u64),\n+}\n+\n+/// For a given expression, maps its Arrow DataType into a LargeList of the\n+/// same DataType.\n+fn list_of(expr: Arc<dyn PhysicalExpr>, input_schema: &Schema) -> Result<DataType> {\n+    let value_data_type = expr.data_type(input_schema)?;\n+\n+    match value_data_type {\n+        DataType::Int8\n+        | DataType::Int16\n+        | DataType::Int32\n+        | DataType::Int64\n+        | DataType::UInt8\n+        | DataType::UInt16\n+        | DataType::UInt32\n+        | DataType::UInt64 => Ok(DataType::LargeList(Box::new(value_data_type))),\n+        _ => Err(ExecutionError::NotImplemented(\n+            \"Unsupported column data type for DISTINCT\".to_string(),\n+        )),\n+    }\n+}\n+\n+fn accumulate_scalar(\n+    accum: &mut FnvHashSet<DistinctScalarValue>,\n+    value: Option<ScalarValue>,\n+) -> Result<()> {\n+    let accum_value = match value {\n+        Some(ScalarValue::Int8(v)) => Some(DistinctScalarValue::Int8(v)),\n+        Some(ScalarValue::Int16(v)) => Some(DistinctScalarValue::Int16(v)),\n+        Some(ScalarValue::Int32(v)) => Some(DistinctScalarValue::Int32(v)),\n+        Some(ScalarValue::Int64(v)) => Some(DistinctScalarValue::Int64(v)),\n+        Some(ScalarValue::UInt8(v)) => Some(DistinctScalarValue::UInt8(v)),\n+        Some(ScalarValue::UInt16(v)) => Some(DistinctScalarValue::UInt16(v)),\n+        Some(ScalarValue::UInt32(v)) => Some(DistinctScalarValue::UInt32(v)),\n+        Some(ScalarValue::UInt64(v)) => Some(DistinctScalarValue::UInt64(v)),\n+        Some(ScalarValue::Null) => None,\n+        _ => {\n+            return Err(ExecutionError::NotImplemented(\n+                \"Unsupported scalar value for DISTINCT accumulator\".to_string(),\n+            ))\n+        }\n+    };\n+\n+    match accum_value {\n+        Some(v) => {\n+            accum.insert(v);\n+        }\n+        None => {}\n+    }\n+\n+    Ok(())\n+}\n+\n+macro_rules! accum_batch {\n+    ($ARRAY_TY:ident, $DISTINCT_SCALAR_TY: path, $ARRAY: expr, $ACCUM: expr) => {{\n+        let array = $ARRAY.as_any().downcast_ref::<$ARRAY_TY>().ok_or_else(|| {\n+            ExecutionError::ExecutionError(\"Error downcasting array\".to_string())\n+        })?;\n+\n+        for i in 0..array.len() {\n+            $ACCUM.insert($DISTINCT_SCALAR_TY(array.value(i)));\n+        }\n+\n+        Ok(())\n+    }};\n+}\n+\n+#[derive(Debug)]\n+struct DistinctValuesAccumulator {\n+    values: FnvHashSet<DistinctScalarValue>,\n+}\n+\n+impl Accumulator for DistinctValuesAccumulator {\n+    fn accumulate_scalar(&mut self, value: Option<ScalarValue>) -> Result<()> {\n+        accumulate_scalar(&mut self.values, value)\n+    }\n+\n+    fn accumulate_batch(&mut self, _array: &ArrayRef) -> Result<()> {\n+        Err(ExecutionError::NotImplemented(\n+            \"Aggregates with DISTINCT not supported without a GROUP BY\".to_string(),\n+        ))\n+    }\n+\n+    fn get_value(&self) -> Result<Option<ScalarValue>> {\n+        let value_out = self\n+            .values\n+            .iter()\n+            .map(|accumulated_value| match accumulated_value {\n+                DistinctScalarValue::Int8(v) => Ok(ScalarValue::Int8(*v)),\n\nReview comment:\n       ... and back: `DistinctScalarValue -> ScalarValue`\n\n##########\nFile path: rust/datafusion/src/physical_plan/distinct_expressions.rs\n##########\n@@ -0,0 +1,303 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Implementations for DISTINCT expressions, e.g. `COUNT(DISTINCT c)`\n+\n+use std::cell::RefCell;\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use arrow::array::ArrayRef;\n+use arrow::array::{\n+    Int16Array, Int32Array, Int64Array, Int8Array, PrimitiveArrayOps, UInt16Array,\n+    UInt32Array, UInt64Array, UInt8Array,\n+};\n+use arrow::datatypes::{DataType, Schema};\n+use arrow::record_batch::RecordBatch;\n+\n+use fnv::FnvHashSet;\n+\n+use crate::error::{ExecutionError, Result};\n+use crate::logical_plan::ScalarValue;\n+use crate::physical_plan::expressions::Column;\n+use crate::physical_plan::hash_aggregate::AggregateMode;\n+use crate::physical_plan::{Accumulator, AggregateExpr, PhysicalExpr};\n+\n+/// Enumeration of types that can be accumulated into a distinct set of values.\n+#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n+enum DistinctScalarValue {\n+    Int8(i8),\n+    Int16(i16),\n+    Int32(i32),\n+    Int64(i64),\n+    UInt8(u8),\n+    UInt16(u16),\n+    UInt32(u32),\n+    UInt64(u64),\n+}\n+\n+/// For a given expression, maps its Arrow DataType into a LargeList of the\n+/// same DataType.\n+fn list_of(expr: Arc<dyn PhysicalExpr>, input_schema: &Schema) -> Result<DataType> {\n+    let value_data_type = expr.data_type(input_schema)?;\n+\n+    match value_data_type {\n+        DataType::Int8\n+        | DataType::Int16\n+        | DataType::Int32\n+        | DataType::Int64\n+        | DataType::UInt8\n+        | DataType::UInt16\n+        | DataType::UInt32\n+        | DataType::UInt64 => Ok(DataType::LargeList(Box::new(value_data_type))),\n+        _ => Err(ExecutionError::NotImplemented(\n+            \"Unsupported column data type for DISTINCT\".to_string(),\n+        )),\n+    }\n+}\n+\n+fn accumulate_scalar(\n+    accum: &mut FnvHashSet<DistinctScalarValue>,\n+    value: Option<ScalarValue>,\n+) -> Result<()> {\n+    let accum_value = match value {\n+        Some(ScalarValue::Int8(v)) => Some(DistinctScalarValue::Int8(v)),\n\nReview comment:\n       ... this way, we do not need to go `ScalarValue -> DistinctScalarValue`...\n\n##########\nFile path: rust/datafusion/src/physical_plan/distinct_expressions.rs\n##########\n@@ -0,0 +1,303 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Implementations for DISTINCT expressions, e.g. `COUNT(DISTINCT c)`\n+\n+use std::cell::RefCell;\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use arrow::array::ArrayRef;\n+use arrow::array::{\n+    Int16Array, Int32Array, Int64Array, Int8Array, PrimitiveArrayOps, UInt16Array,\n+    UInt32Array, UInt64Array, UInt8Array,\n+};\n+use arrow::datatypes::{DataType, Schema};\n+use arrow::record_batch::RecordBatch;\n+\n+use fnv::FnvHashSet;\n+\n+use crate::error::{ExecutionError, Result};\n+use crate::logical_plan::ScalarValue;\n+use crate::physical_plan::expressions::Column;\n+use crate::physical_plan::hash_aggregate::AggregateMode;\n+use crate::physical_plan::{Accumulator, AggregateExpr, PhysicalExpr};\n+\n+/// Enumeration of types that can be accumulated into a distinct set of values.\n+#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n+enum DistinctScalarValue {\n+    Int8(i8),\n+    Int16(i16),\n+    Int32(i32),\n+    Int64(i64),\n+    UInt8(u8),\n+    UInt16(u16),\n+    UInt32(u32),\n+    UInt64(u64),\n+}\n+\n+/// For a given expression, maps its Arrow DataType into a LargeList of the\n+/// same DataType.\n+fn list_of(expr: Arc<dyn PhysicalExpr>, input_schema: &Schema) -> Result<DataType> {\n+    let value_data_type = expr.data_type(input_schema)?;\n+\n+    match value_data_type {\n+        DataType::Int8\n+        | DataType::Int16\n+        | DataType::Int32\n+        | DataType::Int64\n+        | DataType::UInt8\n+        | DataType::UInt16\n+        | DataType::UInt32\n+        | DataType::UInt64 => Ok(DataType::LargeList(Box::new(value_data_type))),\n+        _ => Err(ExecutionError::NotImplemented(\n+            \"Unsupported column data type for DISTINCT\".to_string(),\n+        )),\n+    }\n+}\n+\n+fn accumulate_scalar(\n+    accum: &mut FnvHashSet<DistinctScalarValue>,\n+    value: Option<ScalarValue>,\n+) -> Result<()> {\n+    let accum_value = match value {\n+        Some(ScalarValue::Int8(v)) => Some(DistinctScalarValue::Int8(v)),\n+        Some(ScalarValue::Int16(v)) => Some(DistinctScalarValue::Int16(v)),\n+        Some(ScalarValue::Int32(v)) => Some(DistinctScalarValue::Int32(v)),\n+        Some(ScalarValue::Int64(v)) => Some(DistinctScalarValue::Int64(v)),\n+        Some(ScalarValue::UInt8(v)) => Some(DistinctScalarValue::UInt8(v)),\n+        Some(ScalarValue::UInt16(v)) => Some(DistinctScalarValue::UInt16(v)),\n+        Some(ScalarValue::UInt32(v)) => Some(DistinctScalarValue::UInt32(v)),\n+        Some(ScalarValue::UInt64(v)) => Some(DistinctScalarValue::UInt64(v)),\n+        Some(ScalarValue::Null) => None,\n+        _ => {\n+            return Err(ExecutionError::NotImplemented(\n+                \"Unsupported scalar value for DISTINCT accumulator\".to_string(),\n+            ))\n+        }\n+    };\n+\n+    match accum_value {\n+        Some(v) => {\n+            accum.insert(v);\n+        }\n+        None => {}\n+    }\n+\n+    Ok(())\n+}\n+\n+macro_rules! accum_batch {\n+    ($ARRAY_TY:ident, $DISTINCT_SCALAR_TY: path, $ARRAY: expr, $ACCUM: expr) => {{\n+        let array = $ARRAY.as_any().downcast_ref::<$ARRAY_TY>().ok_or_else(|| {\n+            ExecutionError::ExecutionError(\"Error downcasting array\".to_string())\n+        })?;\n+\n+        for i in 0..array.len() {\n+            $ACCUM.insert($DISTINCT_SCALAR_TY(array.value(i)));\n+        }\n+\n+        Ok(())\n+    }};\n+}\n+\n+#[derive(Debug)]\n+struct DistinctValuesAccumulator {\n+    values: FnvHashSet<DistinctScalarValue>,\n+}\n+\n+impl Accumulator for DistinctValuesAccumulator {\n+    fn accumulate_scalar(&mut self, value: Option<ScalarValue>) -> Result<()> {\n+        accumulate_scalar(&mut self.values, value)\n+    }\n+\n+    fn accumulate_batch(&mut self, _array: &ArrayRef) -> Result<()> {\n+        Err(ExecutionError::NotImplemented(\n\nReview comment:\n       Wouldn't it be possible to implement this one here? Loop through the elements one by one.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-22T03:11:37.820+0000",
                    "updated": "2020-09-22T03:11:37.820+0000",
                    "started": "2020-09-22T03:11:37.820+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "487508",
                    "issueId": "13328368"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/487552",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on a change in pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222#discussion_r492074780\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/hash_aggregate.rs\n##########\n@@ -48,9 +48,12 @@ use fnv::FnvHashMap;\n /// Hash aggregate modes\n #[derive(Debug, Copy, Clone)]\n pub enum AggregateMode {\n+    /// Aggregate mode without any partial/intermediate aggregation\n+    NoPartial,\n\nReview comment:\n       Spark uses the term `Complete`. Our existing names `Partial` and `Final` were based on Spark's naming.\n\n##########\nFile path: rust/datafusion/src/physical_plan/hash_aggregate.rs\n##########\n@@ -48,9 +48,12 @@ use fnv::FnvHashMap;\n /// Hash aggregate modes\n #[derive(Debug, Copy, Clone)]\n pub enum AggregateMode {\n+    /// Aggregate mode without any partial/intermediate aggregation\n+    NoPartial,\n\nReview comment:\n       ```\r\n   /**\r\n    * An [[AggregateFunction]] with [[Complete]] mode is used to evaluate this function directly\r\n    * from original input rows without any partial aggregation.\r\n    * This function updates the given aggregation buffer with the original input of this\r\n    * function. When it has processed all input rows, the final result of this function is returned.\r\n    */\r\n   case object Complete extends AggregateMode\r\n   ```\n\n##########\nFile path: rust/datafusion/src/physical_plan/hash_aggregate.rs\n##########\n@@ -374,6 +380,18 @@ impl RecordBatchReader for GroupedHashAggregateIterator {\n                         col,\n                         accums\n                     ),\n+                    DataType::LargeList(_) => {\n+                        let len = array.len();\n+                        let list_array =\n+                            array.as_any().downcast_ref::<LargeListArray>().unwrap();\n\nReview comment:\n       nit: I'd prefer that we use `expect` rather than `unwrap` so we can add a meaningful message.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-22T03:15:38.980+0000",
                    "updated": "2020-09-22T03:15:38.980+0000",
                    "started": "2020-09-22T03:15:38.980+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "487552",
                    "issueId": "13328368"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/487637",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222#issuecomment-695804292\n\n\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-22T03:23:16.538+0000",
                    "updated": "2020-09-22T03:23:16.538+0000",
                    "started": "2020-09-22T03:23:16.538+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "487637",
                    "issueId": "13328368"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/488221",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "drusso commented on a change in pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222#discussion_r492692158\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/distinct_expressions.rs\n##########\n@@ -0,0 +1,303 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Implementations for DISTINCT expressions, e.g. `COUNT(DISTINCT c)`\n+\n+use std::cell::RefCell;\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use arrow::array::ArrayRef;\n+use arrow::array::{\n+    Int16Array, Int32Array, Int64Array, Int8Array, PrimitiveArrayOps, UInt16Array,\n+    UInt32Array, UInt64Array, UInt8Array,\n+};\n+use arrow::datatypes::{DataType, Schema};\n+use arrow::record_batch::RecordBatch;\n+\n+use fnv::FnvHashSet;\n+\n+use crate::error::{ExecutionError, Result};\n+use crate::logical_plan::ScalarValue;\n+use crate::physical_plan::expressions::Column;\n+use crate::physical_plan::hash_aggregate::AggregateMode;\n+use crate::physical_plan::{Accumulator, AggregateExpr, PhysicalExpr};\n+\n+/// Enumeration of types that can be accumulated into a distinct set of values.\n+#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n+enum DistinctScalarValue {\n\nReview comment:\n       These are used as the values in the iterator's `HashSet`, and unfortunately it's not possible to derive `Hash` for `ScalarValue` since it nests `f32` and `f64`. \r\n   \r\n   As you suggested, `GroupByScalar` is a good candidate here. (I assumed you meant `GroupByScalar` rather than `GroupByKey`?)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-22T12:27:37.818+0000",
                    "updated": "2020-09-22T12:27:37.818+0000",
                    "started": "2020-09-22T12:27:37.818+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "488221",
                    "issueId": "13328368"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/488223",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "drusso commented on a change in pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222#discussion_r492692251\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/distinct_expressions.rs\n##########\n@@ -0,0 +1,303 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Implementations for DISTINCT expressions, e.g. `COUNT(DISTINCT c)`\n+\n+use std::cell::RefCell;\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use arrow::array::ArrayRef;\n+use arrow::array::{\n+    Int16Array, Int32Array, Int64Array, Int8Array, PrimitiveArrayOps, UInt16Array,\n+    UInt32Array, UInt64Array, UInt8Array,\n+};\n+use arrow::datatypes::{DataType, Schema};\n+use arrow::record_batch::RecordBatch;\n+\n+use fnv::FnvHashSet;\n+\n+use crate::error::{ExecutionError, Result};\n+use crate::logical_plan::ScalarValue;\n+use crate::physical_plan::expressions::Column;\n+use crate::physical_plan::hash_aggregate::AggregateMode;\n+use crate::physical_plan::{Accumulator, AggregateExpr, PhysicalExpr};\n+\n+/// Enumeration of types that can be accumulated into a distinct set of values.\n+#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n+enum DistinctScalarValue {\n+    Int8(i8),\n+    Int16(i16),\n+    Int32(i32),\n+    Int64(i64),\n+    UInt8(u8),\n+    UInt16(u16),\n+    UInt32(u32),\n+    UInt64(u64),\n+}\n+\n+/// For a given expression, maps its Arrow DataType into a LargeList of the\n+/// same DataType.\n+fn list_of(expr: Arc<dyn PhysicalExpr>, input_schema: &Schema) -> Result<DataType> {\n+    let value_data_type = expr.data_type(input_schema)?;\n+\n+    match value_data_type {\n+        DataType::Int8\n+        | DataType::Int16\n+        | DataType::Int32\n+        | DataType::Int64\n+        | DataType::UInt8\n+        | DataType::UInt16\n+        | DataType::UInt32\n+        | DataType::UInt64 => Ok(DataType::LargeList(Box::new(value_data_type))),\n+        _ => Err(ExecutionError::NotImplemented(\n+            \"Unsupported column data type for DISTINCT\".to_string(),\n+        )),\n+    }\n+}\n+\n+fn accumulate_scalar(\n+    accum: &mut FnvHashSet<DistinctScalarValue>,\n+    value: Option<ScalarValue>,\n+) -> Result<()> {\n+    let accum_value = match value {\n+        Some(ScalarValue::Int8(v)) => Some(DistinctScalarValue::Int8(v)),\n+        Some(ScalarValue::Int16(v)) => Some(DistinctScalarValue::Int16(v)),\n+        Some(ScalarValue::Int32(v)) => Some(DistinctScalarValue::Int32(v)),\n+        Some(ScalarValue::Int64(v)) => Some(DistinctScalarValue::Int64(v)),\n+        Some(ScalarValue::UInt8(v)) => Some(DistinctScalarValue::UInt8(v)),\n+        Some(ScalarValue::UInt16(v)) => Some(DistinctScalarValue::UInt16(v)),\n+        Some(ScalarValue::UInt32(v)) => Some(DistinctScalarValue::UInt32(v)),\n+        Some(ScalarValue::UInt64(v)) => Some(DistinctScalarValue::UInt64(v)),\n+        Some(ScalarValue::Null) => None,\n+        _ => {\n+            return Err(ExecutionError::NotImplemented(\n+                \"Unsupported scalar value for DISTINCT accumulator\".to_string(),\n+            ))\n+        }\n+    };\n+\n+    match accum_value {\n+        Some(v) => {\n+            accum.insert(v);\n+        }\n+        None => {}\n+    }\n+\n+    Ok(())\n+}\n+\n+macro_rules! accum_batch {\n+    ($ARRAY_TY:ident, $DISTINCT_SCALAR_TY: path, $ARRAY: expr, $ACCUM: expr) => {{\n+        let array = $ARRAY.as_any().downcast_ref::<$ARRAY_TY>().ok_or_else(|| {\n+            ExecutionError::ExecutionError(\"Error downcasting array\".to_string())\n+        })?;\n+\n+        for i in 0..array.len() {\n+            $ACCUM.insert($DISTINCT_SCALAR_TY(array.value(i)));\n+        }\n+\n+        Ok(())\n+    }};\n+}\n+\n+#[derive(Debug)]\n+struct DistinctValuesAccumulator {\n+    values: FnvHashSet<DistinctScalarValue>,\n+}\n+\n+impl Accumulator for DistinctValuesAccumulator {\n+    fn accumulate_scalar(&mut self, value: Option<ScalarValue>) -> Result<()> {\n+        accumulate_scalar(&mut self.values, value)\n+    }\n+\n+    fn accumulate_batch(&mut self, _array: &ArrayRef) -> Result<()> {\n+        Err(ExecutionError::NotImplemented(\n\nReview comment:\n       Certainly. This path isn't reachable in the scenarios this PR addresses, but I think this will be relevant to `SELECT COUNT(DISTINCT col)` queries that does not include a `GROUP BY`. \r\n   \r\n   \r\n   \n\n##########\nFile path: rust/datafusion/src/physical_plan/distinct_expressions.rs\n##########\n@@ -0,0 +1,303 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Implementations for DISTINCT expressions, e.g. `COUNT(DISTINCT c)`\n+\n+use std::cell::RefCell;\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use arrow::array::ArrayRef;\n+use arrow::array::{\n+    Int16Array, Int32Array, Int64Array, Int8Array, PrimitiveArrayOps, UInt16Array,\n+    UInt32Array, UInt64Array, UInt8Array,\n+};\n+use arrow::datatypes::{DataType, Schema};\n+use arrow::record_batch::RecordBatch;\n+\n+use fnv::FnvHashSet;\n+\n+use crate::error::{ExecutionError, Result};\n+use crate::logical_plan::ScalarValue;\n+use crate::physical_plan::expressions::Column;\n+use crate::physical_plan::hash_aggregate::AggregateMode;\n+use crate::physical_plan::{Accumulator, AggregateExpr, PhysicalExpr};\n+\n+/// Enumeration of types that can be accumulated into a distinct set of values.\n+#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n+enum DistinctScalarValue {\n+    Int8(i8),\n+    Int16(i16),\n+    Int32(i32),\n+    Int64(i64),\n+    UInt8(u8),\n+    UInt16(u16),\n+    UInt32(u32),\n+    UInt64(u64),\n+}\n+\n+/// For a given expression, maps its Arrow DataType into a LargeList of the\n+/// same DataType.\n+fn list_of(expr: Arc<dyn PhysicalExpr>, input_schema: &Schema) -> Result<DataType> {\n+    let value_data_type = expr.data_type(input_schema)?;\n+\n+    match value_data_type {\n+        DataType::Int8\n+        | DataType::Int16\n+        | DataType::Int32\n+        | DataType::Int64\n+        | DataType::UInt8\n+        | DataType::UInt16\n+        | DataType::UInt32\n+        | DataType::UInt64 => Ok(DataType::LargeList(Box::new(value_data_type))),\n+        _ => Err(ExecutionError::NotImplemented(\n+            \"Unsupported column data type for DISTINCT\".to_string(),\n+        )),\n+    }\n+}\n+\n+fn accumulate_scalar(\n+    accum: &mut FnvHashSet<DistinctScalarValue>,\n+    value: Option<ScalarValue>,\n+) -> Result<()> {\n+    let accum_value = match value {\n+        Some(ScalarValue::Int8(v)) => Some(DistinctScalarValue::Int8(v)),\n+        Some(ScalarValue::Int16(v)) => Some(DistinctScalarValue::Int16(v)),\n+        Some(ScalarValue::Int32(v)) => Some(DistinctScalarValue::Int32(v)),\n+        Some(ScalarValue::Int64(v)) => Some(DistinctScalarValue::Int64(v)),\n+        Some(ScalarValue::UInt8(v)) => Some(DistinctScalarValue::UInt8(v)),\n+        Some(ScalarValue::UInt16(v)) => Some(DistinctScalarValue::UInt16(v)),\n+        Some(ScalarValue::UInt32(v)) => Some(DistinctScalarValue::UInt32(v)),\n+        Some(ScalarValue::UInt64(v)) => Some(DistinctScalarValue::UInt64(v)),\n+        Some(ScalarValue::Null) => None,\n+        _ => {\n+            return Err(ExecutionError::NotImplemented(\n+                \"Unsupported scalar value for DISTINCT accumulator\".to_string(),\n+            ))\n+        }\n+    };\n+\n+    match accum_value {\n+        Some(v) => {\n+            accum.insert(v);\n+        }\n+        None => {}\n+    }\n+\n+    Ok(())\n+}\n+\n+macro_rules! accum_batch {\n+    ($ARRAY_TY:ident, $DISTINCT_SCALAR_TY: path, $ARRAY: expr, $ACCUM: expr) => {{\n+        let array = $ARRAY.as_any().downcast_ref::<$ARRAY_TY>().ok_or_else(|| {\n+            ExecutionError::ExecutionError(\"Error downcasting array\".to_string())\n+        })?;\n+\n+        for i in 0..array.len() {\n+            $ACCUM.insert($DISTINCT_SCALAR_TY(array.value(i)));\n+        }\n+\n+        Ok(())\n+    }};\n+}\n+\n+#[derive(Debug)]\n+struct DistinctValuesAccumulator {\n+    values: FnvHashSet<DistinctScalarValue>,\n+}\n+\n+impl Accumulator for DistinctValuesAccumulator {\n+    fn accumulate_scalar(&mut self, value: Option<ScalarValue>) -> Result<()> {\n+        accumulate_scalar(&mut self.values, value)\n+    }\n+\n+    fn accumulate_batch(&mut self, _array: &ArrayRef) -> Result<()> {\n+        Err(ExecutionError::NotImplemented(\n+            \"Aggregates with DISTINCT not supported without a GROUP BY\".to_string(),\n+        ))\n+    }\n+\n+    fn get_value(&self) -> Result<Option<ScalarValue>> {\n+        let value_out = self\n+            .values\n+            .iter()\n+            .map(|accumulated_value| match accumulated_value {\n+                DistinctScalarValue::Int8(v) => Ok(ScalarValue::Int8(*v)),\n+                DistinctScalarValue::Int16(v) => Ok(ScalarValue::Int16(*v)),\n+                DistinctScalarValue::Int32(v) => Ok(ScalarValue::Int32(*v)),\n+                DistinctScalarValue::Int64(v) => Ok(ScalarValue::Int64(*v)),\n+                DistinctScalarValue::UInt8(v) => Ok(ScalarValue::UInt8(*v)),\n+                DistinctScalarValue::UInt16(v) => Ok(ScalarValue::UInt16(*v)),\n+                DistinctScalarValue::UInt32(v) => Ok(ScalarValue::UInt32(*v)),\n+                DistinctScalarValue::UInt64(v) => Ok(ScalarValue::UInt64(*v)),\n+            })\n+            .collect::<Result<Vec<ScalarValue>>>()?;\n+\n+        Ok(Some(ScalarValue::Struct(value_out)))\n+    }\n+}\n+\n+/// Create a distint count expression.\n+pub fn count(mode: AggregateMode, expr: Arc<dyn PhysicalExpr>) -> Arc<dyn AggregateExpr> {\n\nReview comment:\n       Good catch, thanks for pointing that out. I'll have a look at this as soon as I integrate with #8172. \n\n##########\nFile path: rust/datafusion/src/physical_plan/hash_aggregate.rs\n##########\n@@ -48,9 +48,12 @@ use fnv::FnvHashMap;\n /// Hash aggregate modes\n #[derive(Debug, Copy, Clone)]\n pub enum AggregateMode {\n+    /// Aggregate mode without any partial/intermediate aggregation\n+    NoPartial,\n\nReview comment:\n       Both suggestions sound good. Let me know if there's a preference one way or the other. For now I will go ahead with `Complete` for consistency with Spark. \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-22T12:28:04.362+0000",
                    "updated": "2020-09-22T12:28:04.362+0000",
                    "started": "2020-09-22T12:28:04.362+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "488223",
                    "issueId": "13328368"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/488225",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "drusso commented on a change in pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222#discussion_r492692512\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/distinct_expressions.rs\n##########\n@@ -0,0 +1,303 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Implementations for DISTINCT expressions, e.g. `COUNT(DISTINCT c)`\n+\n+use std::cell::RefCell;\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use arrow::array::ArrayRef;\n+use arrow::array::{\n+    Int16Array, Int32Array, Int64Array, Int8Array, PrimitiveArrayOps, UInt16Array,\n+    UInt32Array, UInt64Array, UInt8Array,\n+};\n+use arrow::datatypes::{DataType, Schema};\n+use arrow::record_batch::RecordBatch;\n+\n+use fnv::FnvHashSet;\n+\n+use crate::error::{ExecutionError, Result};\n+use crate::logical_plan::ScalarValue;\n+use crate::physical_plan::expressions::Column;\n+use crate::physical_plan::hash_aggregate::AggregateMode;\n+use crate::physical_plan::{Accumulator, AggregateExpr, PhysicalExpr};\n+\n+/// Enumeration of types that can be accumulated into a distinct set of values.\n+#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n+enum DistinctScalarValue {\n+    Int8(i8),\n+    Int16(i16),\n+    Int32(i32),\n+    Int64(i64),\n+    UInt8(u8),\n+    UInt16(u16),\n+    UInt32(u32),\n+    UInt64(u64),\n+}\n+\n+/// For a given expression, maps its Arrow DataType into a LargeList of the\n+/// same DataType.\n+fn list_of(expr: Arc<dyn PhysicalExpr>, input_schema: &Schema) -> Result<DataType> {\n+    let value_data_type = expr.data_type(input_schema)?;\n+\n+    match value_data_type {\n+        DataType::Int8\n+        | DataType::Int16\n+        | DataType::Int32\n+        | DataType::Int64\n+        | DataType::UInt8\n+        | DataType::UInt16\n+        | DataType::UInt32\n+        | DataType::UInt64 => Ok(DataType::LargeList(Box::new(value_data_type))),\n+        _ => Err(ExecutionError::NotImplemented(\n+            \"Unsupported column data type for DISTINCT\".to_string(),\n+        )),\n+    }\n+}\n+\n+fn accumulate_scalar(\n+    accum: &mut FnvHashSet<DistinctScalarValue>,\n+    value: Option<ScalarValue>,\n+) -> Result<()> {\n+    let accum_value = match value {\n+        Some(ScalarValue::Int8(v)) => Some(DistinctScalarValue::Int8(v)),\n+        Some(ScalarValue::Int16(v)) => Some(DistinctScalarValue::Int16(v)),\n+        Some(ScalarValue::Int32(v)) => Some(DistinctScalarValue::Int32(v)),\n+        Some(ScalarValue::Int64(v)) => Some(DistinctScalarValue::Int64(v)),\n+        Some(ScalarValue::UInt8(v)) => Some(DistinctScalarValue::UInt8(v)),\n+        Some(ScalarValue::UInt16(v)) => Some(DistinctScalarValue::UInt16(v)),\n+        Some(ScalarValue::UInt32(v)) => Some(DistinctScalarValue::UInt32(v)),\n+        Some(ScalarValue::UInt64(v)) => Some(DistinctScalarValue::UInt64(v)),\n+        Some(ScalarValue::Null) => None,\n+        _ => {\n+            return Err(ExecutionError::NotImplemented(\n+                \"Unsupported scalar value for DISTINCT accumulator\".to_string(),\n+            ))\n+        }\n+    };\n+\n+    match accum_value {\n+        Some(v) => {\n+            accum.insert(v);\n+        }\n+        None => {}\n+    }\n+\n+    Ok(())\n+}\n+\n+macro_rules! accum_batch {\n+    ($ARRAY_TY:ident, $DISTINCT_SCALAR_TY: path, $ARRAY: expr, $ACCUM: expr) => {{\n+        let array = $ARRAY.as_any().downcast_ref::<$ARRAY_TY>().ok_or_else(|| {\n+            ExecutionError::ExecutionError(\"Error downcasting array\".to_string())\n+        })?;\n+\n+        for i in 0..array.len() {\n+            $ACCUM.insert($DISTINCT_SCALAR_TY(array.value(i)));\n+        }\n+\n+        Ok(())\n+    }};\n+}\n+\n+#[derive(Debug)]\n+struct DistinctValuesAccumulator {\n+    values: FnvHashSet<DistinctScalarValue>,\n\nReview comment:\n       Good suggestion. A couple of questions:\r\n   \r\n   - Would this generalize to (or be easily adapted for) non-integers, like floats or strings?\r\n   - Is there DataFusion tooling for benchmarking different implementations?\r\n   \r\n   Given that, perhaps this is an optimization we can explore at a later time? \n\n##########\nFile path: rust/datafusion/src/physical_plan/hash_aggregate.rs\n##########\n@@ -374,6 +380,18 @@ impl RecordBatchReader for GroupedHashAggregateIterator {\n                         col,\n                         accums\n                     ),\n+                    DataType::LargeList(_) => {\n+                        let len = array.len();\n+                        let list_array =\n+                            array.as_any().downcast_ref::<LargeListArray>().unwrap();\n\nReview comment:\n       Sounds good, will update. \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-22T12:28:21.206+0000",
                    "updated": "2020-09-22T12:28:21.206+0000",
                    "started": "2020-09-22T12:28:21.206+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "488225",
                    "issueId": "13328368"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/488232",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "drusso commented on pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222#issuecomment-696689994\n\n\n   Thanks for the review/feedback all!\r\n   \r\n   @jorgecarleitao: \r\n   \r\n   > it may be worth take a look at #8172 , where we are trying to improve how to declare and run aggregate expressions. Many parts of this PR are in conflict with that one (at API level, all the implementation here is valid).\r\n   \r\n   I will get the changes here updated and integrated with #8172. It looks like they've already landed \ud83d\udc4d \r\n   \r\n   > Out of curiosity: is the DISTINCT something that is applicable to an aggregate expression in general, or is something that is only applicable to a subset of aggregations (such as count, sum)?\r\n   \r\n   To my knowledge `DISTINCT` is applicable to all aggregations. Though there are some cases where `DISTINCT` won't have any effect on the result, for example the results of `MIN(col)` and `MIN(DISTINCT col)` are always the same. This is something the logical (or physical) planner can optimize for \u2013 there's no need to do the work to compute the distinct set in those cases. \r\n   \r\n   (Also note that `DISTINCT` is applicable outside the context of aggregations, for example `SELECT DISTINCT c1, c2 FROM t1`.)\r\n   \r\n   @alamb:\r\n   \r\n   > One potential downside of the approach in this PR is that it will likely struggle when there are a large number of distinct values per group (as the FnvHashSet will be huge) as well as needing special support for each datatype.\r\n   \r\n   Agreed. I'm happy to continue iterating and improving on the work here. \r\n   \r\n   > Another approach we could consider is to use a HashAggregateExpr operation as a pre-filter to remove duplicates.\r\n   \r\n   I had this thought as well, however \u2013 and correct me if I'm wrong \u2013 it doesn't generalize to a scenario like:\r\n   \r\n   ```\r\n   SELECT c1, COUNT(DISTINCT c2), COUNT(DISTINCT c3) FROM t1 GROUP BY c1\r\n   ```\r\n   \r\n   For the `COUNT(DISTINCT c2)` expression we would want distinct pairs of `(c1, c2)`; for the `COUNT(DISTINCT c3)` expression we would want distinct pairs of `(c1, c3)`. But we can't do both simultaneously. The existing implementation handles that scenario. Perhaps there's some ideas here we can use for further optimizations, though. \r\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-22T12:30:58.825+0000",
                    "updated": "2020-09-22T12:30:58.825+0000",
                    "started": "2020-09-22T12:30:58.825+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "488232",
                    "issueId": "13328368"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/488244",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "drusso commented on a change in pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222#discussion_r492692251\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/distinct_expressions.rs\n##########\n@@ -0,0 +1,303 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Implementations for DISTINCT expressions, e.g. `COUNT(DISTINCT c)`\n+\n+use std::cell::RefCell;\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use arrow::array::ArrayRef;\n+use arrow::array::{\n+    Int16Array, Int32Array, Int64Array, Int8Array, PrimitiveArrayOps, UInt16Array,\n+    UInt32Array, UInt64Array, UInt8Array,\n+};\n+use arrow::datatypes::{DataType, Schema};\n+use arrow::record_batch::RecordBatch;\n+\n+use fnv::FnvHashSet;\n+\n+use crate::error::{ExecutionError, Result};\n+use crate::logical_plan::ScalarValue;\n+use crate::physical_plan::expressions::Column;\n+use crate::physical_plan::hash_aggregate::AggregateMode;\n+use crate::physical_plan::{Accumulator, AggregateExpr, PhysicalExpr};\n+\n+/// Enumeration of types that can be accumulated into a distinct set of values.\n+#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n+enum DistinctScalarValue {\n+    Int8(i8),\n+    Int16(i16),\n+    Int32(i32),\n+    Int64(i64),\n+    UInt8(u8),\n+    UInt16(u16),\n+    UInt32(u32),\n+    UInt64(u64),\n+}\n+\n+/// For a given expression, maps its Arrow DataType into a LargeList of the\n+/// same DataType.\n+fn list_of(expr: Arc<dyn PhysicalExpr>, input_schema: &Schema) -> Result<DataType> {\n+    let value_data_type = expr.data_type(input_schema)?;\n+\n+    match value_data_type {\n+        DataType::Int8\n+        | DataType::Int16\n+        | DataType::Int32\n+        | DataType::Int64\n+        | DataType::UInt8\n+        | DataType::UInt16\n+        | DataType::UInt32\n+        | DataType::UInt64 => Ok(DataType::LargeList(Box::new(value_data_type))),\n+        _ => Err(ExecutionError::NotImplemented(\n+            \"Unsupported column data type for DISTINCT\".to_string(),\n+        )),\n+    }\n+}\n+\n+fn accumulate_scalar(\n+    accum: &mut FnvHashSet<DistinctScalarValue>,\n+    value: Option<ScalarValue>,\n+) -> Result<()> {\n+    let accum_value = match value {\n+        Some(ScalarValue::Int8(v)) => Some(DistinctScalarValue::Int8(v)),\n+        Some(ScalarValue::Int16(v)) => Some(DistinctScalarValue::Int16(v)),\n+        Some(ScalarValue::Int32(v)) => Some(DistinctScalarValue::Int32(v)),\n+        Some(ScalarValue::Int64(v)) => Some(DistinctScalarValue::Int64(v)),\n+        Some(ScalarValue::UInt8(v)) => Some(DistinctScalarValue::UInt8(v)),\n+        Some(ScalarValue::UInt16(v)) => Some(DistinctScalarValue::UInt16(v)),\n+        Some(ScalarValue::UInt32(v)) => Some(DistinctScalarValue::UInt32(v)),\n+        Some(ScalarValue::UInt64(v)) => Some(DistinctScalarValue::UInt64(v)),\n+        Some(ScalarValue::Null) => None,\n+        _ => {\n+            return Err(ExecutionError::NotImplemented(\n+                \"Unsupported scalar value for DISTINCT accumulator\".to_string(),\n+            ))\n+        }\n+    };\n+\n+    match accum_value {\n+        Some(v) => {\n+            accum.insert(v);\n+        }\n+        None => {}\n+    }\n+\n+    Ok(())\n+}\n+\n+macro_rules! accum_batch {\n+    ($ARRAY_TY:ident, $DISTINCT_SCALAR_TY: path, $ARRAY: expr, $ACCUM: expr) => {{\n+        let array = $ARRAY.as_any().downcast_ref::<$ARRAY_TY>().ok_or_else(|| {\n+            ExecutionError::ExecutionError(\"Error downcasting array\".to_string())\n+        })?;\n+\n+        for i in 0..array.len() {\n+            $ACCUM.insert($DISTINCT_SCALAR_TY(array.value(i)));\n+        }\n+\n+        Ok(())\n+    }};\n+}\n+\n+#[derive(Debug)]\n+struct DistinctValuesAccumulator {\n+    values: FnvHashSet<DistinctScalarValue>,\n+}\n+\n+impl Accumulator for DistinctValuesAccumulator {\n+    fn accumulate_scalar(&mut self, value: Option<ScalarValue>) -> Result<()> {\n+        accumulate_scalar(&mut self.values, value)\n+    }\n+\n+    fn accumulate_batch(&mut self, _array: &ArrayRef) -> Result<()> {\n+        Err(ExecutionError::NotImplemented(\n\nReview comment:\n       Certainly. This path isn't reachable in the scenarios this PR addresses, but I think this will be relevant to `SELECT COUNT(DISTINCT col)` queries that do not include a `GROUP BY`. \r\n   \r\n   \r\n   \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-22T12:57:42.789+0000",
                    "updated": "2020-09-22T12:57:42.789+0000",
                    "started": "2020-09-22T12:57:42.789+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "488244",
                    "issueId": "13328368"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/488400",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222#issuecomment-696842287\n\n\n   @drusso  I think you are correct that we would need a separate group by operator for each count distinct and then combine them together:\r\n   \r\n   so `SELECT c1, COUNT(DISTINCT c2), COUNT(DISTINCT c3) FROM t1 GROUP BY c1` might look like\r\n   \r\n   ```\r\n   HashAggregateExec: // this second phase then counts\r\n     group_expr:\r\n       Column(c1)\r\n     aggr_expr:\r\n       CountReduce(Column(c2))\r\n     input:\r\n       HashAggregateExec: // this first agg expr finds all distinct values of (c1,c2)\r\n         group_expr:\r\n           Column(c1), Column(c2)\r\n           input:\r\n             CsvExec:\r\n   \r\n   JOIN ON (c1):\r\n   \r\n   HashAggregateExec: // this second phase then counts\r\n     group_expr:\r\n       Column(c1)\r\n     aggr_expr:\r\n       CountReduce(Column(c3))\r\n     input:\r\n       HashAggregateExec: // this first agg expr finds all distinct values of (c1,c2)\r\n         group_expr:\r\n           Column(c1), Column(c3)\r\n           input:\r\n             CsvExec:\r\n   ```\r\n   \r\n   Or something. I like you suggestion to get an implementation in (this one) and then iterate as needed\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-22T16:44:02.712+0000",
                    "updated": "2020-09-22T16:44:02.712+0000",
                    "started": "2020-09-22T16:44:02.712+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "488400",
                    "issueId": "13328368"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/worklog/488401",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb edited a comment on pull request #8222:\nURL: https://github.com/apache/arrow/pull/8222#issuecomment-696842287\n\n\n   @drusso  I think you are correct that we would need a separate group by operator for each count distinct and then combine them together:\r\n   \r\n   so `SELECT c1, COUNT(DISTINCT c2), COUNT(DISTINCT c3) FROM t1 GROUP BY c1` might look like\r\n   \r\n   ```\r\n   HashAggregateExec: // this second phase then counts\r\n     group_expr:\r\n       Column(c1)\r\n     aggr_expr:\r\n       CountReduce(Column(c2))\r\n     input:\r\n       HashAggregateExec: // this first agg expr finds all distinct values of (c1,c2)\r\n         group_expr:\r\n           Column(c1), Column(c2)\r\n           input:\r\n             CsvExec:\r\n   \r\n   JOIN ON (c1):\r\n   \r\n   HashAggregateExec: // this second phase then counts\r\n     group_expr:\r\n       Column(c1)\r\n     aggr_expr:\r\n       CountReduce(Column(c3))\r\n     input:\r\n       HashAggregateExec: // this first agg expr finds all distinct values of (c1,c2)\r\n         group_expr:\r\n           Column(c1), Column(c3)\r\n           input:\r\n             CsvExec:\r\n   ```\r\n   \r\n   Or something. I like your suggestion to get an implementation in (this one) and then iterate as needed\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-22T16:44:25.868+0000",
                    "updated": "2020-09-22T16:44:25.868+0000",
                    "started": "2020-09-22T16:44:25.868+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "488401",
                    "issueId": "13328368"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/5",
            "id": "5",
            "description": "General wishlist item.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Wish",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 33600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@64eab40a[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@51e8b92e[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4aabcf06[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@5e1e2eb4[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7f6863c4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@7343645[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@13f30a5a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@3cb7fd1e[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@fddf0f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@265d574b[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2df73800[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@2eab7fad[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 33600,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Oct 08 23:43:38 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-10-08T23:43:38.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10043/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2020-09-19T18:41:53.000+0000",
        "updated": "2020-11-06T20:35:35.000+0000",
        "timeoriginalestimate": null,
        "description": "I am unsure where support for {{DISTINCT}} may be on the DataFusion roadmap, so I've filed this with the \"Wish\" type and \"Minor\" priority to reflect that this is a proposal:\r\n\r\nIntroduce {{DISTINCT}} into DataFusion by partially implementing {{COUNT(DISTINCT)}}. The ultimate goal is to fully support the {{DISTINCT}} keyword, but to get implementation started, limit the scope of this work to:\r\n * the {{COUNT()}} aggregate function\r\n * a single expression in {{COUNT()}}, i.e., {{COUNT(DISTINCT c1)}}, but not {{COUNT(DISTINCT c1, c2)}}\r\n * only queries with a {{GROUP BY}} clause\r\n * integer types",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "9h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 33600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] [DataFusion] Introduce support for DISTINCT by partially implementing COUNT(DISTINCT)",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/comment/17198837",
                    "id": "17198837",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
                        "name": "jorgecarleitao",
                        "key": "jorgecarleitao",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
                        },
                        "displayName": "Jorge Leit\u00e3o",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "I assigned [~drusso] , as he is spearheading this on the PR above :)",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
                        "name": "jorgecarleitao",
                        "key": "jorgecarleitao",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
                        },
                        "displayName": "Jorge Leit\u00e3o",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2020-09-19T21:15:15.430+0000",
                    "updated": "2020-09-19T21:15:15.430+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13328368/comment/17210524",
                    "id": "17210524",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
                        "name": "andygrove",
                        "key": "andygrove",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
                        },
                        "displayName": "Andy Grove",
                        "active": true,
                        "timeZone": "America/Denver"
                    },
                    "body": "Issue resolved by pull request 8222\n[https://github.com/apache/arrow/pull/8222]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
                        "name": "andygrove",
                        "key": "andygrove",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
                        },
                        "displayName": "Andy Grove",
                        "active": true,
                        "timeZone": "America/Denver"
                    },
                    "created": "2020-10-08T23:43:38.571+0000",
                    "updated": "2020-10-08T23:43:38.571+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|z0iqn4:",
        "customfield_12314139": null
    }
}