{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13220373",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373",
    "key": "ARROW-4800",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12344925",
                "id": "12344925",
                "description": "",
                "name": "0.14.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-07-04"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
            "name": "Minor",
            "id": "4"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12344925",
                "id": "12344925",
                "description": "",
                "name": "0.14.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-07-04"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 47400,
            "total": 47400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 47400,
            "total": 47400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-4800/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 79,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/256480",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501\n \n \n   - Mostly an adaptation of StatusOr from google/asylo (both header and unittests).  \r\n   - Demonstrate usage in ipc/writer*\r\n   - If this PR is accepted I can do a follow-up PR to port over useful testing utilities.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-09T06:02:40.798+0000",
                    "updated": "2019-06-09T06:02:40.798+0000",
                    "started": "2019-06-09T06:02:40.797+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "256480",
                    "issueId": "13220373"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/256882",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on pull request #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501#discussion_r292020549\n \n \n\n ##########\n File path: cpp/src/arrow/error_or.h\n ##########\n @@ -0,0 +1,427 @@\n+//\n+// Copyright 2017 Asylo authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+// Adapted from Asylo\n+\n+#pragma once\n+\n+#include <utility>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+\n+struct ErrorOrConstants {\n+  static const char kValueMoveConstructorMsg[];\n+  static const char kValueMoveAssignmentMsg[];\n+  static const char kValueOrDieMovedMsg[];\n+  static const char kStatusMoveConstructorMsg[];\n+  static const char kStatusMoveAssignmentMsg[];\n+};\n+\n+// A class for representing either a usable value, or an error.\n+///\n+/// A ErrorOr object either contains a value of type `T` or a Status object\n+/// explaining why such a value is not present. The type `T` must be\n+/// copy-constructible and/or move-constructible.\n+///\n+/// The state of a ErrorOr object may be determined by calling ok() or\n+/// status(). The ok() method returns true if the object contains a valid value.\n+/// The status() method returns the internal Status object. A ErrorOr object\n+/// that contains a valid value will return an OK Status for a call to status().\n+///\n+/// A value of type `T` may be extracted from a ErrorOr object through a call\n+/// to ValueOrDie(). This function should only be called if a call to ok()\n+/// returns true. Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<Foo> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     Foo foo = result.ValueOrDie();\n+///     foo->DoSomethingCool();\n \n Review comment:\n   Minor `foo.`\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-10T14:57:05.567+0000",
                    "updated": "2019-06-10T14:57:05.567+0000",
                    "started": "2019-06-10T14:57:05.567+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "256882",
                    "issueId": "13220373"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/256883",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on pull request #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501#discussion_r292026847\n \n \n\n ##########\n File path: cpp/src/arrow/error_or.h\n ##########\n @@ -0,0 +1,427 @@\n+//\n+// Copyright 2017 Asylo authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+// Adapted from Asylo\n+\n+#pragma once\n+\n+#include <utility>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+\n+struct ErrorOrConstants {\n+  static const char kValueMoveConstructorMsg[];\n+  static const char kValueMoveAssignmentMsg[];\n+  static const char kValueOrDieMovedMsg[];\n+  static const char kStatusMoveConstructorMsg[];\n+  static const char kStatusMoveAssignmentMsg[];\n+};\n+\n+// A class for representing either a usable value, or an error.\n+///\n+/// A ErrorOr object either contains a value of type `T` or a Status object\n+/// explaining why such a value is not present. The type `T` must be\n+/// copy-constructible and/or move-constructible.\n+///\n+/// The state of a ErrorOr object may be determined by calling ok() or\n+/// status(). The ok() method returns true if the object contains a valid value.\n+/// The status() method returns the internal Status object. A ErrorOr object\n+/// that contains a valid value will return an OK Status for a call to status().\n+///\n+/// A value of type `T` may be extracted from a ErrorOr object through a call\n+/// to ValueOrDie(). This function should only be called if a call to ok()\n+/// returns true. Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<Foo> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     Foo foo = result.ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///  }\n+/// ```\n+///\n+/// If `T` is a move-only type, like `std::unique_ptr<>`, then the value should\n+/// only be extracted after invoking `std::move()` on the ErrorOr object.\n+/// Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<std::unique_ptr<Foo>> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     std::unique_ptr<Foo> foo = std::move(result).ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///   }\n+/// ```\n+///\n+/// ErrorOr is provided for the convenience of implementing functions that\n+/// return some value but may fail during execution. For instance, consider a\n+/// function with the following signature:\n+///\n+/// ```\n+///   arrow::Status CalculateFoo(int *output);\n+/// ```\n+///\n+/// This function may instead be written as:\n+///\n+/// ```\n+///   arrow::ErrorOr<int> CalculateFoo();\n+/// ```\n+template <class T>\n+class ErrorOr {\n+  template <typename U>\n+  friend class ErrorOr;\n+\n+ public:\n+  /// Constructs a ErrorOr object that contains a non-OK status.\n+  /// The non-OK status has an error code of -1. This is a non-standard POSIX\n+  /// error code and is used in this context to indicate an unknown error.\n+  ///\n+  /// This constructor is marked `explicit` to prevent attempts to `return {}`\n+  /// from a function with a return type of, for example,\n+  /// `ErrorOr<std::vector<int>>`. While `return {}` seems like it would return\n+  /// an empty vector, it will actually invoke the default constructor of\n+  /// ErrorOr.\n+  explicit ErrorOr()  // NOLINT(runtime/explicit)\n+      : variant_(Status::UnknownError(\"Unknown error\")), has_value_(false) {}\n+\n+  ~ErrorOr() {\n+    if (has_value_) {\n+      variant_.value_.~T();\n+    } else {\n+      variant_.status_.~Status();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object with the given non-OK Status object. All\n+  /// calls to ValueOrDie() on this object will abort. The given `status` must\n+  /// not be an OK status, otherwise this constructor will abort.\n+  ///\n+  /// This constructor is not declared explicit so that a function with a return\n+  /// type of `ErrorOr<T>` can return a Status object, and the status will be\n+  /// implicitly converted to the appropriate return type as a matter of\n+  /// convenience.\n+  ///\n+  /// \\param status The non-OK Status object to initalize to.\n+  ErrorOr(const Status& status)  // NOLINT(runtime/explicit)\n+      : variant_(status), has_value_(false) {\n+    if (status.ok()) {\n+      std::abort();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object that contains `value`. The resulting object\n+  /// is considered to have an OK status. The wrapped element can be accessed\n+  /// with ValueOrDie().\n+  ///\n+  /// This constructor is made implicit so that a function with a return type of\n+  /// `ErrorOr<T>` can return an object of type `U &&`, implicitly converting\n+  /// it to a `ErrorOr<T>` object.\n+  ///\n+  /// Note that `T` must be implicitly constructible from `U`, and `U` must not\n+  /// be a (cv-qualified) Status or Status-reference type. Due to C++\n+  /// reference-collapsing rules and perfect-forwarding semantics, this\n+  /// constructor matches invocations that pass `value` either as a const\n+  /// reference or as an rvalue reference. Since ErrorOr needs to work for both\n+  /// reference and rvalue-reference types, the constructor uses perfect\n+  /// forwarding to avoid invalidating arguments that were passed by reference.\n+  /// See http://thbecker.net/articles/rvalue_references/section_08.html for\n+  /// additional details.\n+  ///\n+  /// \\param value The value to initialize to.\n+  template <typename U,\n+            typename E = typename std::enable_if<\n+                std::is_constructible<T, U>::value && std::is_convertible<U, T>::value &&\n+                !std::is_same<typename std::remove_reference<\n+                                  typename std::remove_cv<U>::type>::type,\n+                              Status>::value>::type>\n+  ErrorOr(U&& value)  // NOLINT(runtime/explicit)\n+      : variant_(std::forward<U>(value)), has_value_(true) {}\n+\n+  /// Copy constructor.\n+  ///\n+  /// This constructor needs to be explicitly defined because the presence of\n+  /// the move-assignment operator deletes the default copy constructor. In such\n+  /// a scenario, since the deleted copy constructor has stricter binding rules\n+  /// than the templated copy constructor, the templated constructor cannot act\n+  /// as a copy constructor, and any attempt to copy-construct a `ErrorOr`\n+  /// object results in a compilation error.\n+  ///\n+  /// \\param other The value to copy from.\n+  ErrorOr(const ErrorOr& other)\n+      : has_value_(other.has_value_) {  // NOLINT(runtime/explicit)\n+    if (has_value_) {\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Templatized constructor that constructs a `ErrorOr<T>` from a const\n+  /// reference to a `ErrorOr<U>`.\n+  ///\n+  /// `T` must be implicitly constructible from `const U &`.\n+  ///\n+  /// \\param other The value to copy from.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(const ErrorOr<U>& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Copy-assignment operator.\n+  ///\n+  /// \\param other The ErrorOr object to copy.\n+  ErrorOr& operator=(const ErrorOr& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the source.\n+    if (other.has_value_) {\n+      AssignValue(other.variant_.value_);\n+    } else {\n+      AssignStatus(other.variant_.status_);\n+    }\n+    return *this;\n+  }\n+\n+  /// Templatized constructor which constructs a `ErrorOr<T>` by moving the\n+  /// contents of a `ErrorOr<U>`. `T` must be implicitly constructible from `U\n+  /// &&`.\n+  ///\n+  /// Sets `other` to contain a non-OK status with a`StatusError::Invalid`\n+  /// error code.\n+  ///\n+  /// \\param other The ErrorOr object to move from and set to a non-OK status.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(ErrorOr<U>&& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      new (&variant_) variant(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveConstructorMsg));\n+    } else {\n+      new (&variant_) variant(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveConstructorMsg);\n+#endif\n+    }\n+  }\n+\n+  /// Move-assignment operator.\n+  ///\n+  /// Sets `other` to contain a non-OK status.\n+  ///\n+  /// \\param other The ErrorOr object to assign from and set to a non-OK\n+  /// status.\n+  ErrorOr& operator=(ErrorOr&& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the donor.\n+    if (other.has_value_) {\n+      AssignValue(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveAssignmentMsg));\n+    } else {\n+      AssignStatus(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveAssignmentMsg);\n+#endif\n+    }\n+\n+    return *this;\n+  }\n+\n+  /// Indicates whether the object contains a `T` value.\n+  ///\n+  /// \\return True if this ErrorOr object's status is OK (i.e. a call to ok()\n+  /// returns true). If this function returns true, then it is safe to access\n+  /// the wrapped element through a call to ValueOrDie().\n+  bool ok() const { return has_value_; }\n+\n+  /// Gets the stored status object, or an OK status if a `T` value is stored.\n+  ///\n+  /// \\return The stored non-OK status object, or an OK status if this object\n+  ///         has a value.\n+  Status status() const { return ok() ? Status::OK() : variant_.status_; }\n+\n+  /// Gets the stored `T` value.\n+  ///\n+  /// This method should only be called if this ErrorOr object's status is OK\n+  /// (i.e. a call to ok() returns true), otherwise this call will abort.\n+  ///\n+  /// \\return The stored `T` value.\n+  const T& ValueOrDie() const& {\n+    if (!ok()) {\n \n Review comment:\n   I think it makes sense to use `ARROW_PREDICT_FALSE`, and everywhere you see `!ok()`.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-10T14:57:05.661+0000",
                    "updated": "2019-06-10T14:57:05.661+0000",
                    "started": "2019-06-10T14:57:05.661+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "256883",
                    "issueId": "13220373"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/256884",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on pull request #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501#discussion_r292021068\n \n \n\n ##########\n File path: cpp/src/arrow/error_or.h\n ##########\n @@ -0,0 +1,427 @@\n+//\n+// Copyright 2017 Asylo authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+// Adapted from Asylo\n+\n+#pragma once\n+\n+#include <utility>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+\n+struct ErrorOrConstants {\n+  static const char kValueMoveConstructorMsg[];\n+  static const char kValueMoveAssignmentMsg[];\n+  static const char kValueOrDieMovedMsg[];\n+  static const char kStatusMoveConstructorMsg[];\n+  static const char kStatusMoveAssignmentMsg[];\n+};\n+\n+// A class for representing either a usable value, or an error.\n+///\n+/// A ErrorOr object either contains a value of type `T` or a Status object\n+/// explaining why such a value is not present. The type `T` must be\n+/// copy-constructible and/or move-constructible.\n+///\n+/// The state of a ErrorOr object may be determined by calling ok() or\n+/// status(). The ok() method returns true if the object contains a valid value.\n+/// The status() method returns the internal Status object. A ErrorOr object\n+/// that contains a valid value will return an OK Status for a call to status().\n+///\n+/// A value of type `T` may be extracted from a ErrorOr object through a call\n+/// to ValueOrDie(). This function should only be called if a call to ok()\n+/// returns true. Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<Foo> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     Foo foo = result.ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///  }\n+/// ```\n+///\n+/// If `T` is a move-only type, like `std::unique_ptr<>`, then the value should\n+/// only be extracted after invoking `std::move()` on the ErrorOr object.\n+/// Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<std::unique_ptr<Foo>> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     std::unique_ptr<Foo> foo = std::move(result).ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///   }\n+/// ```\n+///\n+/// ErrorOr is provided for the convenience of implementing functions that\n+/// return some value but may fail during execution. For instance, consider a\n+/// function with the following signature:\n+///\n+/// ```\n+///   arrow::Status CalculateFoo(int *output);\n+/// ```\n+///\n+/// This function may instead be written as:\n+///\n+/// ```\n+///   arrow::ErrorOr<int> CalculateFoo();\n+/// ```\n+template <class T>\n+class ErrorOr {\n+  template <typename U>\n+  friend class ErrorOr;\n+\n+ public:\n+  /// Constructs a ErrorOr object that contains a non-OK status.\n+  /// The non-OK status has an error code of -1. This is a non-standard POSIX\n+  /// error code and is used in this context to indicate an unknown error.\n+  ///\n+  /// This constructor is marked `explicit` to prevent attempts to `return {}`\n+  /// from a function with a return type of, for example,\n+  /// `ErrorOr<std::vector<int>>`. While `return {}` seems like it would return\n+  /// an empty vector, it will actually invoke the default constructor of\n+  /// ErrorOr.\n+  explicit ErrorOr()  // NOLINT(runtime/explicit)\n+      : variant_(Status::UnknownError(\"Unknown error\")), has_value_(false) {}\n+\n+  ~ErrorOr() {\n+    if (has_value_) {\n+      variant_.value_.~T();\n+    } else {\n+      variant_.status_.~Status();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object with the given non-OK Status object. All\n+  /// calls to ValueOrDie() on this object will abort. The given `status` must\n+  /// not be an OK status, otherwise this constructor will abort.\n+  ///\n+  /// This constructor is not declared explicit so that a function with a return\n+  /// type of `ErrorOr<T>` can return a Status object, and the status will be\n+  /// implicitly converted to the appropriate return type as a matter of\n+  /// convenience.\n+  ///\n+  /// \\param status The non-OK Status object to initalize to.\n+  ErrorOr(const Status& status)  // NOLINT(runtime/explicit)\n+      : variant_(status), has_value_(false) {\n+    if (status.ok()) {\n+      std::abort();\n \n Review comment:\n   I'm of the opinion that a library should never abort. On the other side, I'm torn on the other option of undefined behavior.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-10T14:57:05.689+0000",
                    "updated": "2019-06-10T14:57:05.689+0000",
                    "started": "2019-06-10T14:57:05.688+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "256884",
                    "issueId": "13220373"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/256885",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on pull request #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501#discussion_r292020067\n \n \n\n ##########\n File path: cpp/src/arrow/error_or.h\n ##########\n @@ -0,0 +1,427 @@\n+//\n+// Copyright 2017 Asylo authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+// Adapted from Asylo\n+\n+#pragma once\n+\n+#include <utility>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+\n+struct ErrorOrConstants {\n+  static const char kValueMoveConstructorMsg[];\n+  static const char kValueMoveAssignmentMsg[];\n+  static const char kValueOrDieMovedMsg[];\n+  static const char kStatusMoveConstructorMsg[];\n+  static const char kStatusMoveAssignmentMsg[];\n+};\n+\n+// A class for representing either a usable value, or an error.\n+///\n+/// A ErrorOr object either contains a value of type `T` or a Status object\n+/// explaining why such a value is not present. The type `T` must be\n+/// copy-constructible and/or move-constructible.\n+///\n+/// The state of a ErrorOr object may be determined by calling ok() or\n+/// status(). The ok() method returns true if the object contains a valid value.\n+/// The status() method returns the internal Status object. A ErrorOr object\n+/// that contains a valid value will return an OK Status for a call to status().\n+///\n+/// A value of type `T` may be extracted from a ErrorOr object through a call\n+/// to ValueOrDie(). This function should only be called if a call to ok()\n+/// returns true. Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<Foo> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     Foo foo = result.ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///  }\n+/// ```\n+///\n+/// If `T` is a move-only type, like `std::unique_ptr<>`, then the value should\n+/// only be extracted after invoking `std::move()` on the ErrorOr object.\n+/// Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<std::unique_ptr<Foo>> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     std::unique_ptr<Foo> foo = std::move(result).ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///   }\n+/// ```\n+///\n+/// ErrorOr is provided for the convenience of implementing functions that\n+/// return some value but may fail during execution. For instance, consider a\n+/// function with the following signature:\n+///\n+/// ```\n+///   arrow::Status CalculateFoo(int *output);\n+/// ```\n+///\n+/// This function may instead be written as:\n+///\n+/// ```\n+///   arrow::ErrorOr<int> CalculateFoo();\n+/// ```\n+template <class T>\n+class ErrorOr {\n+  template <typename U>\n+  friend class ErrorOr;\n+\n+ public:\n+  /// Constructs a ErrorOr object that contains a non-OK status.\n+  /// The non-OK status has an error code of -1. This is a non-standard POSIX\n+  /// error code and is used in this context to indicate an unknown error.\n+  ///\n+  /// This constructor is marked `explicit` to prevent attempts to `return {}`\n+  /// from a function with a return type of, for example,\n+  /// `ErrorOr<std::vector<int>>`. While `return {}` seems like it would return\n+  /// an empty vector, it will actually invoke the default constructor of\n+  /// ErrorOr.\n+  explicit ErrorOr()  // NOLINT(runtime/explicit)\n+      : variant_(Status::UnknownError(\"Unknown error\")), has_value_(false) {}\n+\n+  ~ErrorOr() {\n+    if (has_value_) {\n+      variant_.value_.~T();\n+    } else {\n+      variant_.status_.~Status();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object with the given non-OK Status object. All\n+  /// calls to ValueOrDie() on this object will abort. The given `status` must\n+  /// not be an OK status, otherwise this constructor will abort.\n+  ///\n+  /// This constructor is not declared explicit so that a function with a return\n+  /// type of `ErrorOr<T>` can return a Status object, and the status will be\n+  /// implicitly converted to the appropriate return type as a matter of\n+  /// convenience.\n+  ///\n+  /// \\param status The non-OK Status object to initalize to.\n+  ErrorOr(const Status& status)  // NOLINT(runtime/explicit)\n+      : variant_(status), has_value_(false) {\n+    if (status.ok()) {\n+      std::abort();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object that contains `value`. The resulting object\n+  /// is considered to have an OK status. The wrapped element can be accessed\n+  /// with ValueOrDie().\n+  ///\n+  /// This constructor is made implicit so that a function with a return type of\n+  /// `ErrorOr<T>` can return an object of type `U &&`, implicitly converting\n+  /// it to a `ErrorOr<T>` object.\n+  ///\n+  /// Note that `T` must be implicitly constructible from `U`, and `U` must not\n+  /// be a (cv-qualified) Status or Status-reference type. Due to C++\n+  /// reference-collapsing rules and perfect-forwarding semantics, this\n+  /// constructor matches invocations that pass `value` either as a const\n+  /// reference or as an rvalue reference. Since ErrorOr needs to work for both\n+  /// reference and rvalue-reference types, the constructor uses perfect\n+  /// forwarding to avoid invalidating arguments that were passed by reference.\n+  /// See http://thbecker.net/articles/rvalue_references/section_08.html for\n+  /// additional details.\n+  ///\n+  /// \\param value The value to initialize to.\n+  template <typename U,\n+            typename E = typename std::enable_if<\n+                std::is_constructible<T, U>::value && std::is_convertible<U, T>::value &&\n+                !std::is_same<typename std::remove_reference<\n+                                  typename std::remove_cv<U>::type>::type,\n+                              Status>::value>::type>\n+  ErrorOr(U&& value)  // NOLINT(runtime/explicit)\n+      : variant_(std::forward<U>(value)), has_value_(true) {}\n+\n+  /// Copy constructor.\n+  ///\n+  /// This constructor needs to be explicitly defined because the presence of\n+  /// the move-assignment operator deletes the default copy constructor. In such\n+  /// a scenario, since the deleted copy constructor has stricter binding rules\n+  /// than the templated copy constructor, the templated constructor cannot act\n+  /// as a copy constructor, and any attempt to copy-construct a `ErrorOr`\n+  /// object results in a compilation error.\n+  ///\n+  /// \\param other The value to copy from.\n+  ErrorOr(const ErrorOr& other)\n+      : has_value_(other.has_value_) {  // NOLINT(runtime/explicit)\n+    if (has_value_) {\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Templatized constructor that constructs a `ErrorOr<T>` from a const\n+  /// reference to a `ErrorOr<U>`.\n+  ///\n+  /// `T` must be implicitly constructible from `const U &`.\n+  ///\n+  /// \\param other The value to copy from.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(const ErrorOr<U>& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Copy-assignment operator.\n+  ///\n+  /// \\param other The ErrorOr object to copy.\n+  ErrorOr& operator=(const ErrorOr& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the source.\n+    if (other.has_value_) {\n+      AssignValue(other.variant_.value_);\n+    } else {\n+      AssignStatus(other.variant_.status_);\n+    }\n+    return *this;\n+  }\n+\n+  /// Templatized constructor which constructs a `ErrorOr<T>` by moving the\n+  /// contents of a `ErrorOr<U>`. `T` must be implicitly constructible from `U\n+  /// &&`.\n+  ///\n+  /// Sets `other` to contain a non-OK status with a`StatusError::Invalid`\n+  /// error code.\n+  ///\n+  /// \\param other The ErrorOr object to move from and set to a non-OK status.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(ErrorOr<U>&& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      new (&variant_) variant(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveConstructorMsg));\n+    } else {\n+      new (&variant_) variant(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveConstructorMsg);\n+#endif\n+    }\n+  }\n+\n+  /// Move-assignment operator.\n+  ///\n+  /// Sets `other` to contain a non-OK status.\n+  ///\n+  /// \\param other The ErrorOr object to assign from and set to a non-OK\n+  /// status.\n+  ErrorOr& operator=(ErrorOr&& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the donor.\n+    if (other.has_value_) {\n+      AssignValue(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveAssignmentMsg));\n+    } else {\n+      AssignStatus(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveAssignmentMsg);\n+#endif\n+    }\n+\n+    return *this;\n+  }\n+\n+  /// Indicates whether the object contains a `T` value.\n+  ///\n+  /// \\return True if this ErrorOr object's status is OK (i.e. a call to ok()\n+  /// returns true). If this function returns true, then it is safe to access\n+  /// the wrapped element through a call to ValueOrDie().\n+  bool ok() const { return has_value_; }\n \n Review comment:\n   Should recommend the `operator bool` instead?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-10T14:57:05.726+0000",
                    "updated": "2019-06-10T14:57:05.726+0000",
                    "started": "2019-06-10T14:57:05.725+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "256885",
                    "issueId": "13220373"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/256886",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on pull request #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501#discussion_r292022719\n \n \n\n ##########\n File path: cpp/src/arrow/error_or.h\n ##########\n @@ -0,0 +1,427 @@\n+//\n+// Copyright 2017 Asylo authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+// Adapted from Asylo\n+\n+#pragma once\n+\n+#include <utility>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+\n+struct ErrorOrConstants {\n+  static const char kValueMoveConstructorMsg[];\n+  static const char kValueMoveAssignmentMsg[];\n+  static const char kValueOrDieMovedMsg[];\n+  static const char kStatusMoveConstructorMsg[];\n+  static const char kStatusMoveAssignmentMsg[];\n+};\n+\n+// A class for representing either a usable value, or an error.\n+///\n+/// A ErrorOr object either contains a value of type `T` or a Status object\n+/// explaining why such a value is not present. The type `T` must be\n+/// copy-constructible and/or move-constructible.\n+///\n+/// The state of a ErrorOr object may be determined by calling ok() or\n+/// status(). The ok() method returns true if the object contains a valid value.\n+/// The status() method returns the internal Status object. A ErrorOr object\n+/// that contains a valid value will return an OK Status for a call to status().\n+///\n+/// A value of type `T` may be extracted from a ErrorOr object through a call\n+/// to ValueOrDie(). This function should only be called if a call to ok()\n+/// returns true. Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<Foo> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     Foo foo = result.ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///  }\n+/// ```\n+///\n+/// If `T` is a move-only type, like `std::unique_ptr<>`, then the value should\n+/// only be extracted after invoking `std::move()` on the ErrorOr object.\n+/// Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<std::unique_ptr<Foo>> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     std::unique_ptr<Foo> foo = std::move(result).ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///   }\n+/// ```\n+///\n+/// ErrorOr is provided for the convenience of implementing functions that\n+/// return some value but may fail during execution. For instance, consider a\n+/// function with the following signature:\n+///\n+/// ```\n+///   arrow::Status CalculateFoo(int *output);\n+/// ```\n+///\n+/// This function may instead be written as:\n+///\n+/// ```\n+///   arrow::ErrorOr<int> CalculateFoo();\n+/// ```\n+template <class T>\n+class ErrorOr {\n+  template <typename U>\n+  friend class ErrorOr;\n+\n+ public:\n+  /// Constructs a ErrorOr object that contains a non-OK status.\n+  /// The non-OK status has an error code of -1. This is a non-standard POSIX\n+  /// error code and is used in this context to indicate an unknown error.\n+  ///\n+  /// This constructor is marked `explicit` to prevent attempts to `return {}`\n+  /// from a function with a return type of, for example,\n+  /// `ErrorOr<std::vector<int>>`. While `return {}` seems like it would return\n+  /// an empty vector, it will actually invoke the default constructor of\n+  /// ErrorOr.\n+  explicit ErrorOr()  // NOLINT(runtime/explicit)\n+      : variant_(Status::UnknownError(\"Unknown error\")), has_value_(false) {}\n+\n+  ~ErrorOr() {\n+    if (has_value_) {\n+      variant_.value_.~T();\n+    } else {\n+      variant_.status_.~Status();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object with the given non-OK Status object. All\n+  /// calls to ValueOrDie() on this object will abort. The given `status` must\n+  /// not be an OK status, otherwise this constructor will abort.\n+  ///\n+  /// This constructor is not declared explicit so that a function with a return\n+  /// type of `ErrorOr<T>` can return a Status object, and the status will be\n+  /// implicitly converted to the appropriate return type as a matter of\n+  /// convenience.\n+  ///\n+  /// \\param status The non-OK Status object to initalize to.\n+  ErrorOr(const Status& status)  // NOLINT(runtime/explicit)\n+      : variant_(status), has_value_(false) {\n+    if (status.ok()) {\n+      std::abort();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object that contains `value`. The resulting object\n+  /// is considered to have an OK status. The wrapped element can be accessed\n+  /// with ValueOrDie().\n+  ///\n+  /// This constructor is made implicit so that a function with a return type of\n+  /// `ErrorOr<T>` can return an object of type `U &&`, implicitly converting\n+  /// it to a `ErrorOr<T>` object.\n+  ///\n+  /// Note that `T` must be implicitly constructible from `U`, and `U` must not\n+  /// be a (cv-qualified) Status or Status-reference type. Due to C++\n+  /// reference-collapsing rules and perfect-forwarding semantics, this\n+  /// constructor matches invocations that pass `value` either as a const\n+  /// reference or as an rvalue reference. Since ErrorOr needs to work for both\n+  /// reference and rvalue-reference types, the constructor uses perfect\n+  /// forwarding to avoid invalidating arguments that were passed by reference.\n+  /// See http://thbecker.net/articles/rvalue_references/section_08.html for\n+  /// additional details.\n+  ///\n+  /// \\param value The value to initialize to.\n+  template <typename U,\n+            typename E = typename std::enable_if<\n+                std::is_constructible<T, U>::value && std::is_convertible<U, T>::value &&\n+                !std::is_same<typename std::remove_reference<\n+                                  typename std::remove_cv<U>::type>::type,\n+                              Status>::value>::type>\n+  ErrorOr(U&& value)  // NOLINT(runtime/explicit)\n+      : variant_(std::forward<U>(value)), has_value_(true) {}\n+\n+  /// Copy constructor.\n+  ///\n+  /// This constructor needs to be explicitly defined because the presence of\n+  /// the move-assignment operator deletes the default copy constructor. In such\n+  /// a scenario, since the deleted copy constructor has stricter binding rules\n+  /// than the templated copy constructor, the templated constructor cannot act\n+  /// as a copy constructor, and any attempt to copy-construct a `ErrorOr`\n+  /// object results in a compilation error.\n+  ///\n+  /// \\param other The value to copy from.\n+  ErrorOr(const ErrorOr& other)\n+      : has_value_(other.has_value_) {  // NOLINT(runtime/explicit)\n+    if (has_value_) {\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Templatized constructor that constructs a `ErrorOr<T>` from a const\n+  /// reference to a `ErrorOr<U>`.\n+  ///\n+  /// `T` must be implicitly constructible from `const U &`.\n+  ///\n+  /// \\param other The value to copy from.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(const ErrorOr<U>& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Copy-assignment operator.\n+  ///\n+  /// \\param other The ErrorOr object to copy.\n+  ErrorOr& operator=(const ErrorOr& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the source.\n+    if (other.has_value_) {\n+      AssignValue(other.variant_.value_);\n+    } else {\n+      AssignStatus(other.variant_.status_);\n+    }\n+    return *this;\n+  }\n+\n+  /// Templatized constructor which constructs a `ErrorOr<T>` by moving the\n+  /// contents of a `ErrorOr<U>`. `T` must be implicitly constructible from `U\n+  /// &&`.\n+  ///\n+  /// Sets `other` to contain a non-OK status with a`StatusError::Invalid`\n+  /// error code.\n+  ///\n+  /// \\param other The ErrorOr object to move from and set to a non-OK status.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(ErrorOr<U>&& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      new (&variant_) variant(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveConstructorMsg));\n+    } else {\n+      new (&variant_) variant(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveConstructorMsg);\n+#endif\n+    }\n+  }\n+\n+  /// Move-assignment operator.\n+  ///\n+  /// Sets `other` to contain a non-OK status.\n+  ///\n+  /// \\param other The ErrorOr object to assign from and set to a non-OK\n+  /// status.\n+  ErrorOr& operator=(ErrorOr&& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the donor.\n+    if (other.has_value_) {\n+      AssignValue(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveAssignmentMsg));\n+    } else {\n+      AssignStatus(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveAssignmentMsg);\n+#endif\n+    }\n+\n+    return *this;\n+  }\n+\n+  /// Indicates whether the object contains a `T` value.\n+  ///\n+  /// \\return True if this ErrorOr object's status is OK (i.e. a call to ok()\n+  /// returns true). If this function returns true, then it is safe to access\n+  /// the wrapped element through a call to ValueOrDie().\n+  bool ok() const { return has_value_; }\n+\n+  /// Gets the stored status object, or an OK status if a `T` value is stored.\n+  ///\n+  /// \\return The stored non-OK status object, or an OK status if this object\n+  ///         has a value.\n+  Status status() const { return ok() ? Status::OK() : variant_.status_; }\n+\n+  /// Gets the stored `T` value.\n+  ///\n+  /// This method should only be called if this ErrorOr object's status is OK\n+  /// (i.e. a call to ok() returns true), otherwise this call will abort.\n+  ///\n+  /// \\return The stored `T` value.\n+  const T& ValueOrDie() const& {\n+    if (!ok()) {\n+      std::abort();\n+    }\n+    return variant_.value_;\n+  }\n+\n+  /// Gets a mutable reference to the stored `T` value.\n+  ///\n+  /// This method should only be called if this ErrorOr object's status is OK\n+  /// (i.e. a call to ok() returns true), otherwise this call will abort.\n+  ///\n+  /// \\return The stored `T` value.\n+  T& ValueOrDie() & {\n+    if (!ok()) {\n+      std::abort();\n+    }\n+    return variant_.value_;\n+  }\n+\n+  /// Moves and returns the internally-stored `T` value.\n+  ///\n+  /// This method should only be called if this ErrorOr object's status is OK\n+  /// (i.e. a call to ok() returns true), otherwise this call will abort. The\n+  /// ErrorOr object is invalidated after this call and will be updated to\n+  /// contain a non-OK status.\n+  ///\n+  /// \\return The stored `T` value.\n+  T ValueOrDie() && {\n+    if (!ok()) {\n+      std::abort();\n+    }\n+    T tmp(std::move(variant_.value_));\n+\n+    // Invalidate this ErrorOr object.\n+    OverwriteValueWithStatus(Status::Invalid(ErrorOrConstants::kValueOrDieMovedMsg));\n+    return std::move(tmp);\n+  }\n+\n+ private:\n+  // Resets the |variant_| member to contain |status|.\n+  template <class U>\n+  void AssignStatus(U&& status) {\n+    if (ok()) {\n+      OverwriteValueWithStatus(std::forward<U>(status));\n+    } else {\n+      // Reuse the existing Status object. has_value_ is already false.\n+      variant_.status_ = std::forward<U>(status);\n+    }\n+  }\n+\n+  // Under the assumption that |this| is currently holding a value, resets the\n+  // |variant_| member to contain |status| and sets |has_value_| to indicate\n+  // that |this| does not have a value. Destroys the existing |variant_| member.\n+  template <class U>\n+  void OverwriteValueWithStatus(U&& status) {\n+#ifndef NDEBUG\n+    if (!ok()) {\n+      std::abort();\n+    }\n+#endif\n+    variant_.value_.~T();\n+    new (&variant_) variant(std::forward<U>(status));\n \n Review comment:\n   I'd put a comment.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-10T14:57:05.744+0000",
                    "updated": "2019-06-10T14:57:05.744+0000",
                    "started": "2019-06-10T14:57:05.743+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "256886",
                    "issueId": "13220373"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/256887",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on pull request #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501#discussion_r292047832\n \n \n\n ##########\n File path: cpp/src/arrow/error_or.h\n ##########\n @@ -0,0 +1,427 @@\n+//\n+// Copyright 2017 Asylo authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+// Adapted from Asylo\n+\n+#pragma once\n+\n+#include <utility>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+\n+struct ErrorOrConstants {\n+  static const char kValueMoveConstructorMsg[];\n+  static const char kValueMoveAssignmentMsg[];\n+  static const char kValueOrDieMovedMsg[];\n+  static const char kStatusMoveConstructorMsg[];\n+  static const char kStatusMoveAssignmentMsg[];\n+};\n+\n+// A class for representing either a usable value, or an error.\n+///\n+/// A ErrorOr object either contains a value of type `T` or a Status object\n+/// explaining why such a value is not present. The type `T` must be\n+/// copy-constructible and/or move-constructible.\n+///\n+/// The state of a ErrorOr object may be determined by calling ok() or\n+/// status(). The ok() method returns true if the object contains a valid value.\n+/// The status() method returns the internal Status object. A ErrorOr object\n+/// that contains a valid value will return an OK Status for a call to status().\n+///\n+/// A value of type `T` may be extracted from a ErrorOr object through a call\n+/// to ValueOrDie(). This function should only be called if a call to ok()\n+/// returns true. Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<Foo> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     Foo foo = result.ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///  }\n+/// ```\n+///\n+/// If `T` is a move-only type, like `std::unique_ptr<>`, then the value should\n+/// only be extracted after invoking `std::move()` on the ErrorOr object.\n+/// Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<std::unique_ptr<Foo>> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     std::unique_ptr<Foo> foo = std::move(result).ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///   }\n+/// ```\n+///\n+/// ErrorOr is provided for the convenience of implementing functions that\n+/// return some value but may fail during execution. For instance, consider a\n+/// function with the following signature:\n+///\n+/// ```\n+///   arrow::Status CalculateFoo(int *output);\n+/// ```\n+///\n+/// This function may instead be written as:\n+///\n+/// ```\n+///   arrow::ErrorOr<int> CalculateFoo();\n+/// ```\n+template <class T>\n+class ErrorOr {\n+  template <typename U>\n+  friend class ErrorOr;\n+\n+ public:\n+  /// Constructs a ErrorOr object that contains a non-OK status.\n+  /// The non-OK status has an error code of -1. This is a non-standard POSIX\n+  /// error code and is used in this context to indicate an unknown error.\n+  ///\n+  /// This constructor is marked `explicit` to prevent attempts to `return {}`\n+  /// from a function with a return type of, for example,\n+  /// `ErrorOr<std::vector<int>>`. While `return {}` seems like it would return\n+  /// an empty vector, it will actually invoke the default constructor of\n+  /// ErrorOr.\n+  explicit ErrorOr()  // NOLINT(runtime/explicit)\n+      : variant_(Status::UnknownError(\"Unknown error\")), has_value_(false) {}\n+\n+  ~ErrorOr() {\n+    if (has_value_) {\n+      variant_.value_.~T();\n+    } else {\n+      variant_.status_.~Status();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object with the given non-OK Status object. All\n+  /// calls to ValueOrDie() on this object will abort. The given `status` must\n+  /// not be an OK status, otherwise this constructor will abort.\n+  ///\n+  /// This constructor is not declared explicit so that a function with a return\n+  /// type of `ErrorOr<T>` can return a Status object, and the status will be\n+  /// implicitly converted to the appropriate return type as a matter of\n+  /// convenience.\n+  ///\n+  /// \\param status The non-OK Status object to initalize to.\n+  ErrorOr(const Status& status)  // NOLINT(runtime/explicit)\n+      : variant_(status), has_value_(false) {\n+    if (status.ok()) {\n+      std::abort();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object that contains `value`. The resulting object\n+  /// is considered to have an OK status. The wrapped element can be accessed\n+  /// with ValueOrDie().\n+  ///\n+  /// This constructor is made implicit so that a function with a return type of\n+  /// `ErrorOr<T>` can return an object of type `U &&`, implicitly converting\n+  /// it to a `ErrorOr<T>` object.\n+  ///\n+  /// Note that `T` must be implicitly constructible from `U`, and `U` must not\n+  /// be a (cv-qualified) Status or Status-reference type. Due to C++\n+  /// reference-collapsing rules and perfect-forwarding semantics, this\n+  /// constructor matches invocations that pass `value` either as a const\n+  /// reference or as an rvalue reference. Since ErrorOr needs to work for both\n+  /// reference and rvalue-reference types, the constructor uses perfect\n+  /// forwarding to avoid invalidating arguments that were passed by reference.\n+  /// See http://thbecker.net/articles/rvalue_references/section_08.html for\n+  /// additional details.\n+  ///\n+  /// \\param value The value to initialize to.\n+  template <typename U,\n+            typename E = typename std::enable_if<\n+                std::is_constructible<T, U>::value && std::is_convertible<U, T>::value &&\n+                !std::is_same<typename std::remove_reference<\n+                                  typename std::remove_cv<U>::type>::type,\n+                              Status>::value>::type>\n+  ErrorOr(U&& value)  // NOLINT(runtime/explicit)\n+      : variant_(std::forward<U>(value)), has_value_(true) {}\n+\n+  /// Copy constructor.\n+  ///\n+  /// This constructor needs to be explicitly defined because the presence of\n+  /// the move-assignment operator deletes the default copy constructor. In such\n+  /// a scenario, since the deleted copy constructor has stricter binding rules\n+  /// than the templated copy constructor, the templated constructor cannot act\n+  /// as a copy constructor, and any attempt to copy-construct a `ErrorOr`\n+  /// object results in a compilation error.\n+  ///\n+  /// \\param other The value to copy from.\n+  ErrorOr(const ErrorOr& other)\n+      : has_value_(other.has_value_) {  // NOLINT(runtime/explicit)\n+    if (has_value_) {\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Templatized constructor that constructs a `ErrorOr<T>` from a const\n+  /// reference to a `ErrorOr<U>`.\n+  ///\n+  /// `T` must be implicitly constructible from `const U &`.\n+  ///\n+  /// \\param other The value to copy from.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(const ErrorOr<U>& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Copy-assignment operator.\n+  ///\n+  /// \\param other The ErrorOr object to copy.\n+  ErrorOr& operator=(const ErrorOr& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the source.\n+    if (other.has_value_) {\n+      AssignValue(other.variant_.value_);\n+    } else {\n+      AssignStatus(other.variant_.status_);\n+    }\n+    return *this;\n+  }\n+\n+  /// Templatized constructor which constructs a `ErrorOr<T>` by moving the\n+  /// contents of a `ErrorOr<U>`. `T` must be implicitly constructible from `U\n+  /// &&`.\n+  ///\n+  /// Sets `other` to contain a non-OK status with a`StatusError::Invalid`\n+  /// error code.\n+  ///\n+  /// \\param other The ErrorOr object to move from and set to a non-OK status.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(ErrorOr<U>&& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      new (&variant_) variant(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveConstructorMsg));\n+    } else {\n+      new (&variant_) variant(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveConstructorMsg);\n+#endif\n+    }\n+  }\n+\n+  /// Move-assignment operator.\n+  ///\n+  /// Sets `other` to contain a non-OK status.\n+  ///\n+  /// \\param other The ErrorOr object to assign from and set to a non-OK\n+  /// status.\n+  ErrorOr& operator=(ErrorOr&& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the donor.\n+    if (other.has_value_) {\n+      AssignValue(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveAssignmentMsg));\n+    } else {\n+      AssignStatus(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveAssignmentMsg);\n+#endif\n+    }\n+\n+    return *this;\n+  }\n+\n+  /// Indicates whether the object contains a `T` value.\n+  ///\n+  /// \\return True if this ErrorOr object's status is OK (i.e. a call to ok()\n+  /// returns true). If this function returns true, then it is safe to access\n+  /// the wrapped element through a call to ValueOrDie().\n+  bool ok() const { return has_value_; }\n+\n+  /// Gets the stored status object, or an OK status if a `T` value is stored.\n+  ///\n+  /// \\return The stored non-OK status object, or an OK status if this object\n+  ///         has a value.\n+  Status status() const { return ok() ? Status::OK() : variant_.status_; }\n+\n+  /// Gets the stored `T` value.\n+  ///\n+  /// This method should only be called if this ErrorOr object's status is OK\n+  /// (i.e. a call to ok() returns true), otherwise this call will abort.\n+  ///\n+  /// \\return The stored `T` value.\n+  const T& ValueOrDie() const& {\n+    if (!ok()) {\n+      std::abort();\n+    }\n+    return variant_.value_;\n+  }\n+\n+  /// Gets a mutable reference to the stored `T` value.\n+  ///\n+  /// This method should only be called if this ErrorOr object's status is OK\n+  /// (i.e. a call to ok() returns true), otherwise this call will abort.\n+  ///\n+  /// \\return The stored `T` value.\n+  T& ValueOrDie() & {\n+    if (!ok()) {\n+      std::abort();\n+    }\n+    return variant_.value_;\n+  }\n+\n+  /// Moves and returns the internally-stored `T` value.\n+  ///\n+  /// This method should only be called if this ErrorOr object's status is OK\n+  /// (i.e. a call to ok() returns true), otherwise this call will abort. The\n+  /// ErrorOr object is invalidated after this call and will be updated to\n+  /// contain a non-OK status.\n+  ///\n+  /// \\return The stored `T` value.\n+  T ValueOrDie() && {\n+    if (!ok()) {\n+      std::abort();\n+    }\n+    T tmp(std::move(variant_.value_));\n+\n+    // Invalidate this ErrorOr object.\n+    OverwriteValueWithStatus(Status::Invalid(ErrorOrConstants::kValueOrDieMovedMsg));\n+    return std::move(tmp);\n+  }\n+\n+ private:\n+  // Resets the |variant_| member to contain |status|.\n+  template <class U>\n+  void AssignStatus(U&& status) {\n+    if (ok()) {\n+      OverwriteValueWithStatus(std::forward<U>(status));\n+    } else {\n+      // Reuse the existing Status object. has_value_ is already false.\n+      variant_.status_ = std::forward<U>(status);\n+    }\n+  }\n+\n+  // Under the assumption that |this| is currently holding a value, resets the\n+  // |variant_| member to contain |status| and sets |has_value_| to indicate\n+  // that |this| does not have a value. Destroys the existing |variant_| member.\n+  template <class U>\n+  void OverwriteValueWithStatus(U&& status) {\n+#ifndef NDEBUG\n+    if (!ok()) {\n+      std::abort();\n+    }\n+#endif\n+    variant_.value_.~T();\n+    new (&variant_) variant(std::forward<U>(status));\n+    has_value_ = false;\n+  }\n+\n+  // Resets the |variant_| member to contain the |value| and sets |has_value_|\n+  // to indicate that the ErrorOr object has a value. Destroys the existing\n+  // |variant_| member.\n+  template <class U>\n+  void AssignValue(U&& value) {\n+    if (ok()) {\n+      // We cannot assume that T is move-assignable.\n+      variant_.value_.~T();\n+    } else {\n+      variant_.status_.~Status();\n+    }\n+    new (&variant_) variant(std::forward<U>(value));\n+    has_value_ = true;\n+  }\n+\n+  // Use custom variant instead of c++ standard, to avoid header polution.\n+  union variant {\n+    // A non-OK status.\n+    Status status_;\n+\n+    // An element of type T.\n+    T value_;\n+\n+    variant() {}\n+\n+    variant(const Status& status) : status_(status) {}\n+\n+    variant(Status&& status) : status_(std::move(status)) {}\n+\n+    template <typename U, typename E = typename std::enable_if<\n+                              std::is_constructible<T, U>::value &&\n+                              std::is_convertible<U, T>::value>::type>\n+    variant(U&& value) : value_(std::forward<U>(value)) {}\n+\n+    // This destructor must be explicitly defined because it is deleted due to\n+    // the variant type having non-static data members with non-trivial\n+    // destructors.\n+    ~variant() {}\n+  };\n+\n+  // One of: a non-OK status or an element of type T.\n+  variant variant_;\n+\n+  // Indicates the active member of the variant_ member.\n+  //\n+  // A value of true indicates that value_ is the active member of variant_.\n+  //\n+  // A value of false indicates that status_ is the active member of variant_.\n+  bool has_value_;\n+};\n+\n+#define ASSIGN_OR_RAISE_IMPL(status_name, lhs, rexpr) \\\n+  auto status_name = (rexpr);                         \\\n+  RETURN_NOT_OK(status_name.status());                \\\n+  lhs = std::move(status_name).ValueOrDie();\n+\n+#define ASSIGN_OR_RAISE_NAME(x, y) ARROW_CONCAT(x, y)\n+\n+// Executes an expression that returns a ErrorOr, extracting its value\n+// into the variable defined by lhs (or returning on error).\n+//\n+// Example: Assigning to an existing value\n+//   ValueType value;\n+//   ASSIGN_OR_RAISE(value, MaybeGetValue(arg));\n+//\n+// WARNING: ASSIGN_OR_RAISE expands into multiple statements; it cannot be used\n \n Review comment:\n   How can we make this more explicit? I suspect that a lot of code is written by using existing code as template (I'm guilty of this). This also requires the scope to return Status.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-10T14:57:05.800+0000",
                    "updated": "2019-06-10T14:57:05.800+0000",
                    "started": "2019-06-10T14:57:05.799+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "256887",
                    "issueId": "13220373"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/256893",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501#issuecomment-500456696\n \n \n   While I think think this is useful to have, I don't personally have that much of an issue with the current way we've been using out arguments with Status. So I don't think there's necessary a need to be prescriptive about \"there should be one, and only one way, to do things\". Using ErrorOr could carry minor additional cognitive burden. Do you know what kind of guidance for developers is in place in the Google projects that use both this and plain Status in APIs?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-10T15:21:00.662+0000",
                    "updated": "2019-06-10T15:21:00.662+0000",
                    "started": "2019-06-10T15:21:00.661+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "256893",
                    "issueId": "13220373"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/257439",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501#discussion_r292290777\n \n \n\n ##########\n File path: cpp/src/arrow/error_or.h\n ##########\n @@ -0,0 +1,427 @@\n+//\n+// Copyright 2017 Asylo authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+// Adapted from Asylo\n+\n+#pragma once\n+\n+#include <utility>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+\n+struct ErrorOrConstants {\n+  static const char kValueMoveConstructorMsg[];\n+  static const char kValueMoveAssignmentMsg[];\n+  static const char kValueOrDieMovedMsg[];\n+  static const char kStatusMoveConstructorMsg[];\n+  static const char kStatusMoveAssignmentMsg[];\n+};\n+\n+// A class for representing either a usable value, or an error.\n+///\n+/// A ErrorOr object either contains a value of type `T` or a Status object\n+/// explaining why such a value is not present. The type `T` must be\n+/// copy-constructible and/or move-constructible.\n+///\n+/// The state of a ErrorOr object may be determined by calling ok() or\n+/// status(). The ok() method returns true if the object contains a valid value.\n+/// The status() method returns the internal Status object. A ErrorOr object\n+/// that contains a valid value will return an OK Status for a call to status().\n+///\n+/// A value of type `T` may be extracted from a ErrorOr object through a call\n+/// to ValueOrDie(). This function should only be called if a call to ok()\n+/// returns true. Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<Foo> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     Foo foo = result.ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///  }\n+/// ```\n+///\n+/// If `T` is a move-only type, like `std::unique_ptr<>`, then the value should\n+/// only be extracted after invoking `std::move()` on the ErrorOr object.\n+/// Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<std::unique_ptr<Foo>> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     std::unique_ptr<Foo> foo = std::move(result).ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///   }\n+/// ```\n+///\n+/// ErrorOr is provided for the convenience of implementing functions that\n+/// return some value but may fail during execution. For instance, consider a\n+/// function with the following signature:\n+///\n+/// ```\n+///   arrow::Status CalculateFoo(int *output);\n+/// ```\n+///\n+/// This function may instead be written as:\n+///\n+/// ```\n+///   arrow::ErrorOr<int> CalculateFoo();\n+/// ```\n+template <class T>\n+class ErrorOr {\n+  template <typename U>\n+  friend class ErrorOr;\n+\n+ public:\n+  /// Constructs a ErrorOr object that contains a non-OK status.\n+  /// The non-OK status has an error code of -1. This is a non-standard POSIX\n+  /// error code and is used in this context to indicate an unknown error.\n+  ///\n+  /// This constructor is marked `explicit` to prevent attempts to `return {}`\n+  /// from a function with a return type of, for example,\n+  /// `ErrorOr<std::vector<int>>`. While `return {}` seems like it would return\n+  /// an empty vector, it will actually invoke the default constructor of\n+  /// ErrorOr.\n+  explicit ErrorOr()  // NOLINT(runtime/explicit)\n+      : variant_(Status::UnknownError(\"Unknown error\")), has_value_(false) {}\n+\n+  ~ErrorOr() {\n+    if (has_value_) {\n+      variant_.value_.~T();\n+    } else {\n+      variant_.status_.~Status();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object with the given non-OK Status object. All\n+  /// calls to ValueOrDie() on this object will abort. The given `status` must\n+  /// not be an OK status, otherwise this constructor will abort.\n+  ///\n+  /// This constructor is not declared explicit so that a function with a return\n+  /// type of `ErrorOr<T>` can return a Status object, and the status will be\n+  /// implicitly converted to the appropriate return type as a matter of\n+  /// convenience.\n+  ///\n+  /// \\param status The non-OK Status object to initalize to.\n+  ErrorOr(const Status& status)  // NOLINT(runtime/explicit)\n+      : variant_(status), has_value_(false) {\n+    if (status.ok()) {\n+      std::abort();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object that contains `value`. The resulting object\n+  /// is considered to have an OK status. The wrapped element can be accessed\n+  /// with ValueOrDie().\n+  ///\n+  /// This constructor is made implicit so that a function with a return type of\n+  /// `ErrorOr<T>` can return an object of type `U &&`, implicitly converting\n+  /// it to a `ErrorOr<T>` object.\n+  ///\n+  /// Note that `T` must be implicitly constructible from `U`, and `U` must not\n+  /// be a (cv-qualified) Status or Status-reference type. Due to C++\n+  /// reference-collapsing rules and perfect-forwarding semantics, this\n+  /// constructor matches invocations that pass `value` either as a const\n+  /// reference or as an rvalue reference. Since ErrorOr needs to work for both\n+  /// reference and rvalue-reference types, the constructor uses perfect\n+  /// forwarding to avoid invalidating arguments that were passed by reference.\n+  /// See http://thbecker.net/articles/rvalue_references/section_08.html for\n+  /// additional details.\n+  ///\n+  /// \\param value The value to initialize to.\n+  template <typename U,\n+            typename E = typename std::enable_if<\n+                std::is_constructible<T, U>::value && std::is_convertible<U, T>::value &&\n+                !std::is_same<typename std::remove_reference<\n+                                  typename std::remove_cv<U>::type>::type,\n+                              Status>::value>::type>\n+  ErrorOr(U&& value)  // NOLINT(runtime/explicit)\n+      : variant_(std::forward<U>(value)), has_value_(true) {}\n+\n+  /// Copy constructor.\n+  ///\n+  /// This constructor needs to be explicitly defined because the presence of\n+  /// the move-assignment operator deletes the default copy constructor. In such\n+  /// a scenario, since the deleted copy constructor has stricter binding rules\n+  /// than the templated copy constructor, the templated constructor cannot act\n+  /// as a copy constructor, and any attempt to copy-construct a `ErrorOr`\n+  /// object results in a compilation error.\n+  ///\n+  /// \\param other The value to copy from.\n+  ErrorOr(const ErrorOr& other)\n+      : has_value_(other.has_value_) {  // NOLINT(runtime/explicit)\n+    if (has_value_) {\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Templatized constructor that constructs a `ErrorOr<T>` from a const\n+  /// reference to a `ErrorOr<U>`.\n+  ///\n+  /// `T` must be implicitly constructible from `const U &`.\n+  ///\n+  /// \\param other The value to copy from.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(const ErrorOr<U>& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Copy-assignment operator.\n+  ///\n+  /// \\param other The ErrorOr object to copy.\n+  ErrorOr& operator=(const ErrorOr& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the source.\n+    if (other.has_value_) {\n+      AssignValue(other.variant_.value_);\n+    } else {\n+      AssignStatus(other.variant_.status_);\n+    }\n+    return *this;\n+  }\n+\n+  /// Templatized constructor which constructs a `ErrorOr<T>` by moving the\n+  /// contents of a `ErrorOr<U>`. `T` must be implicitly constructible from `U\n+  /// &&`.\n+  ///\n+  /// Sets `other` to contain a non-OK status with a`StatusError::Invalid`\n+  /// error code.\n+  ///\n+  /// \\param other The ErrorOr object to move from and set to a non-OK status.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(ErrorOr<U>&& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      new (&variant_) variant(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveConstructorMsg));\n+    } else {\n+      new (&variant_) variant(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveConstructorMsg);\n+#endif\n+    }\n+  }\n+\n+  /// Move-assignment operator.\n+  ///\n+  /// Sets `other` to contain a non-OK status.\n+  ///\n+  /// \\param other The ErrorOr object to assign from and set to a non-OK\n+  /// status.\n+  ErrorOr& operator=(ErrorOr&& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the donor.\n+    if (other.has_value_) {\n+      AssignValue(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveAssignmentMsg));\n+    } else {\n+      AssignStatus(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveAssignmentMsg);\n+#endif\n+    }\n+\n+    return *this;\n+  }\n+\n+  /// Indicates whether the object contains a `T` value.\n+  ///\n+  /// \\return True if this ErrorOr object's status is OK (i.e. a call to ok()\n+  /// returns true). If this function returns true, then it is safe to access\n+  /// the wrapped element through a call to ValueOrDie().\n+  bool ok() const { return has_value_; }\n \n Review comment:\n   Are you suggesting adding one?  I added a comment recommending using ASSIGN_OR_RAISE.  But can add an operator as well if you think it is worthwhile.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-11T06:12:18.070+0000",
                    "updated": "2019-06-11T06:12:18.070+0000",
                    "started": "2019-06-11T06:12:18.069+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "257439",
                    "issueId": "13220373"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/257440",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501#discussion_r292290856\n \n \n\n ##########\n File path: cpp/src/arrow/error_or.h\n ##########\n @@ -0,0 +1,427 @@\n+//\n+// Copyright 2017 Asylo authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+// Adapted from Asylo\n+\n+#pragma once\n+\n+#include <utility>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+\n+struct ErrorOrConstants {\n+  static const char kValueMoveConstructorMsg[];\n+  static const char kValueMoveAssignmentMsg[];\n+  static const char kValueOrDieMovedMsg[];\n+  static const char kStatusMoveConstructorMsg[];\n+  static const char kStatusMoveAssignmentMsg[];\n+};\n+\n+// A class for representing either a usable value, or an error.\n+///\n+/// A ErrorOr object either contains a value of type `T` or a Status object\n+/// explaining why such a value is not present. The type `T` must be\n+/// copy-constructible and/or move-constructible.\n+///\n+/// The state of a ErrorOr object may be determined by calling ok() or\n+/// status(). The ok() method returns true if the object contains a valid value.\n+/// The status() method returns the internal Status object. A ErrorOr object\n+/// that contains a valid value will return an OK Status for a call to status().\n+///\n+/// A value of type `T` may be extracted from a ErrorOr object through a call\n+/// to ValueOrDie(). This function should only be called if a call to ok()\n+/// returns true. Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<Foo> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     Foo foo = result.ValueOrDie();\n+///     foo->DoSomethingCool();\n \n Review comment:\n   I suppose it depends on the type of foo :).  Done.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-11T06:12:37.332+0000",
                    "updated": "2019-06-11T06:12:37.332+0000",
                    "started": "2019-06-11T06:12:37.331+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "257440",
                    "issueId": "13220373"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/257442",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501#discussion_r292292244\n \n \n\n ##########\n File path: cpp/src/arrow/error_or.h\n ##########\n @@ -0,0 +1,427 @@\n+//\n+// Copyright 2017 Asylo authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+// Adapted from Asylo\n+\n+#pragma once\n+\n+#include <utility>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+\n+struct ErrorOrConstants {\n+  static const char kValueMoveConstructorMsg[];\n+  static const char kValueMoveAssignmentMsg[];\n+  static const char kValueOrDieMovedMsg[];\n+  static const char kStatusMoveConstructorMsg[];\n+  static const char kStatusMoveAssignmentMsg[];\n+};\n+\n+// A class for representing either a usable value, or an error.\n+///\n+/// A ErrorOr object either contains a value of type `T` or a Status object\n+/// explaining why such a value is not present. The type `T` must be\n+/// copy-constructible and/or move-constructible.\n+///\n+/// The state of a ErrorOr object may be determined by calling ok() or\n+/// status(). The ok() method returns true if the object contains a valid value.\n+/// The status() method returns the internal Status object. A ErrorOr object\n+/// that contains a valid value will return an OK Status for a call to status().\n+///\n+/// A value of type `T` may be extracted from a ErrorOr object through a call\n+/// to ValueOrDie(). This function should only be called if a call to ok()\n+/// returns true. Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<Foo> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     Foo foo = result.ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///  }\n+/// ```\n+///\n+/// If `T` is a move-only type, like `std::unique_ptr<>`, then the value should\n+/// only be extracted after invoking `std::move()` on the ErrorOr object.\n+/// Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<std::unique_ptr<Foo>> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     std::unique_ptr<Foo> foo = std::move(result).ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///   }\n+/// ```\n+///\n+/// ErrorOr is provided for the convenience of implementing functions that\n+/// return some value but may fail during execution. For instance, consider a\n+/// function with the following signature:\n+///\n+/// ```\n+///   arrow::Status CalculateFoo(int *output);\n+/// ```\n+///\n+/// This function may instead be written as:\n+///\n+/// ```\n+///   arrow::ErrorOr<int> CalculateFoo();\n+/// ```\n+template <class T>\n+class ErrorOr {\n+  template <typename U>\n+  friend class ErrorOr;\n+\n+ public:\n+  /// Constructs a ErrorOr object that contains a non-OK status.\n+  /// The non-OK status has an error code of -1. This is a non-standard POSIX\n+  /// error code and is used in this context to indicate an unknown error.\n+  ///\n+  /// This constructor is marked `explicit` to prevent attempts to `return {}`\n+  /// from a function with a return type of, for example,\n+  /// `ErrorOr<std::vector<int>>`. While `return {}` seems like it would return\n+  /// an empty vector, it will actually invoke the default constructor of\n+  /// ErrorOr.\n+  explicit ErrorOr()  // NOLINT(runtime/explicit)\n+      : variant_(Status::UnknownError(\"Unknown error\")), has_value_(false) {}\n+\n+  ~ErrorOr() {\n+    if (has_value_) {\n+      variant_.value_.~T();\n+    } else {\n+      variant_.status_.~Status();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object with the given non-OK Status object. All\n+  /// calls to ValueOrDie() on this object will abort. The given `status` must\n+  /// not be an OK status, otherwise this constructor will abort.\n+  ///\n+  /// This constructor is not declared explicit so that a function with a return\n+  /// type of `ErrorOr<T>` can return a Status object, and the status will be\n+  /// implicitly converted to the appropriate return type as a matter of\n+  /// convenience.\n+  ///\n+  /// \\param status The non-OK Status object to initalize to.\n+  ErrorOr(const Status& status)  // NOLINT(runtime/explicit)\n+      : variant_(status), has_value_(false) {\n+    if (status.ok()) {\n+      std::abort();\n \n Review comment:\n   I made a method that will at least give more details, which was how this was defined in the ported source.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-11T06:19:09.943+0000",
                    "updated": "2019-06-11T06:19:09.943+0000",
                    "started": "2019-06-11T06:19:09.942+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "257442",
                    "issueId": "13220373"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/257443",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501#discussion_r292292736\n \n \n\n ##########\n File path: cpp/src/arrow/error_or.h\n ##########\n @@ -0,0 +1,427 @@\n+//\n+// Copyright 2017 Asylo authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+// Adapted from Asylo\n+\n+#pragma once\n+\n+#include <utility>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+\n+struct ErrorOrConstants {\n+  static const char kValueMoveConstructorMsg[];\n+  static const char kValueMoveAssignmentMsg[];\n+  static const char kValueOrDieMovedMsg[];\n+  static const char kStatusMoveConstructorMsg[];\n+  static const char kStatusMoveAssignmentMsg[];\n+};\n+\n+// A class for representing either a usable value, or an error.\n+///\n+/// A ErrorOr object either contains a value of type `T` or a Status object\n+/// explaining why such a value is not present. The type `T` must be\n+/// copy-constructible and/or move-constructible.\n+///\n+/// The state of a ErrorOr object may be determined by calling ok() or\n+/// status(). The ok() method returns true if the object contains a valid value.\n+/// The status() method returns the internal Status object. A ErrorOr object\n+/// that contains a valid value will return an OK Status for a call to status().\n+///\n+/// A value of type `T` may be extracted from a ErrorOr object through a call\n+/// to ValueOrDie(). This function should only be called if a call to ok()\n+/// returns true. Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<Foo> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     Foo foo = result.ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///  }\n+/// ```\n+///\n+/// If `T` is a move-only type, like `std::unique_ptr<>`, then the value should\n+/// only be extracted after invoking `std::move()` on the ErrorOr object.\n+/// Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<std::unique_ptr<Foo>> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     std::unique_ptr<Foo> foo = std::move(result).ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///   }\n+/// ```\n+///\n+/// ErrorOr is provided for the convenience of implementing functions that\n+/// return some value but may fail during execution. For instance, consider a\n+/// function with the following signature:\n+///\n+/// ```\n+///   arrow::Status CalculateFoo(int *output);\n+/// ```\n+///\n+/// This function may instead be written as:\n+///\n+/// ```\n+///   arrow::ErrorOr<int> CalculateFoo();\n+/// ```\n+template <class T>\n+class ErrorOr {\n+  template <typename U>\n+  friend class ErrorOr;\n+\n+ public:\n+  /// Constructs a ErrorOr object that contains a non-OK status.\n+  /// The non-OK status has an error code of -1. This is a non-standard POSIX\n+  /// error code and is used in this context to indicate an unknown error.\n+  ///\n+  /// This constructor is marked `explicit` to prevent attempts to `return {}`\n+  /// from a function with a return type of, for example,\n+  /// `ErrorOr<std::vector<int>>`. While `return {}` seems like it would return\n+  /// an empty vector, it will actually invoke the default constructor of\n+  /// ErrorOr.\n+  explicit ErrorOr()  // NOLINT(runtime/explicit)\n+      : variant_(Status::UnknownError(\"Unknown error\")), has_value_(false) {}\n+\n+  ~ErrorOr() {\n+    if (has_value_) {\n+      variant_.value_.~T();\n+    } else {\n+      variant_.status_.~Status();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object with the given non-OK Status object. All\n+  /// calls to ValueOrDie() on this object will abort. The given `status` must\n+  /// not be an OK status, otherwise this constructor will abort.\n+  ///\n+  /// This constructor is not declared explicit so that a function with a return\n+  /// type of `ErrorOr<T>` can return a Status object, and the status will be\n+  /// implicitly converted to the appropriate return type as a matter of\n+  /// convenience.\n+  ///\n+  /// \\param status The non-OK Status object to initalize to.\n+  ErrorOr(const Status& status)  // NOLINT(runtime/explicit)\n+      : variant_(status), has_value_(false) {\n+    if (status.ok()) {\n+      std::abort();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object that contains `value`. The resulting object\n+  /// is considered to have an OK status. The wrapped element can be accessed\n+  /// with ValueOrDie().\n+  ///\n+  /// This constructor is made implicit so that a function with a return type of\n+  /// `ErrorOr<T>` can return an object of type `U &&`, implicitly converting\n+  /// it to a `ErrorOr<T>` object.\n+  ///\n+  /// Note that `T` must be implicitly constructible from `U`, and `U` must not\n+  /// be a (cv-qualified) Status or Status-reference type. Due to C++\n+  /// reference-collapsing rules and perfect-forwarding semantics, this\n+  /// constructor matches invocations that pass `value` either as a const\n+  /// reference or as an rvalue reference. Since ErrorOr needs to work for both\n+  /// reference and rvalue-reference types, the constructor uses perfect\n+  /// forwarding to avoid invalidating arguments that were passed by reference.\n+  /// See http://thbecker.net/articles/rvalue_references/section_08.html for\n+  /// additional details.\n+  ///\n+  /// \\param value The value to initialize to.\n+  template <typename U,\n+            typename E = typename std::enable_if<\n+                std::is_constructible<T, U>::value && std::is_convertible<U, T>::value &&\n+                !std::is_same<typename std::remove_reference<\n+                                  typename std::remove_cv<U>::type>::type,\n+                              Status>::value>::type>\n+  ErrorOr(U&& value)  // NOLINT(runtime/explicit)\n+      : variant_(std::forward<U>(value)), has_value_(true) {}\n+\n+  /// Copy constructor.\n+  ///\n+  /// This constructor needs to be explicitly defined because the presence of\n+  /// the move-assignment operator deletes the default copy constructor. In such\n+  /// a scenario, since the deleted copy constructor has stricter binding rules\n+  /// than the templated copy constructor, the templated constructor cannot act\n+  /// as a copy constructor, and any attempt to copy-construct a `ErrorOr`\n+  /// object results in a compilation error.\n+  ///\n+  /// \\param other The value to copy from.\n+  ErrorOr(const ErrorOr& other)\n+      : has_value_(other.has_value_) {  // NOLINT(runtime/explicit)\n+    if (has_value_) {\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Templatized constructor that constructs a `ErrorOr<T>` from a const\n+  /// reference to a `ErrorOr<U>`.\n+  ///\n+  /// `T` must be implicitly constructible from `const U &`.\n+  ///\n+  /// \\param other The value to copy from.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(const ErrorOr<U>& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Copy-assignment operator.\n+  ///\n+  /// \\param other The ErrorOr object to copy.\n+  ErrorOr& operator=(const ErrorOr& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the source.\n+    if (other.has_value_) {\n+      AssignValue(other.variant_.value_);\n+    } else {\n+      AssignStatus(other.variant_.status_);\n+    }\n+    return *this;\n+  }\n+\n+  /// Templatized constructor which constructs a `ErrorOr<T>` by moving the\n+  /// contents of a `ErrorOr<U>`. `T` must be implicitly constructible from `U\n+  /// &&`.\n+  ///\n+  /// Sets `other` to contain a non-OK status with a`StatusError::Invalid`\n+  /// error code.\n+  ///\n+  /// \\param other The ErrorOr object to move from and set to a non-OK status.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(ErrorOr<U>&& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      new (&variant_) variant(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveConstructorMsg));\n+    } else {\n+      new (&variant_) variant(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveConstructorMsg);\n+#endif\n+    }\n+  }\n+\n+  /// Move-assignment operator.\n+  ///\n+  /// Sets `other` to contain a non-OK status.\n+  ///\n+  /// \\param other The ErrorOr object to assign from and set to a non-OK\n+  /// status.\n+  ErrorOr& operator=(ErrorOr&& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the donor.\n+    if (other.has_value_) {\n+      AssignValue(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveAssignmentMsg));\n+    } else {\n+      AssignStatus(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveAssignmentMsg);\n+#endif\n+    }\n+\n+    return *this;\n+  }\n+\n+  /// Indicates whether the object contains a `T` value.\n+  ///\n+  /// \\return True if this ErrorOr object's status is OK (i.e. a call to ok()\n+  /// returns true). If this function returns true, then it is safe to access\n+  /// the wrapped element through a call to ValueOrDie().\n+  bool ok() const { return has_value_; }\n+\n+  /// Gets the stored status object, or an OK status if a `T` value is stored.\n+  ///\n+  /// \\return The stored non-OK status object, or an OK status if this object\n+  ///         has a value.\n+  Status status() const { return ok() ? Status::OK() : variant_.status_; }\n+\n+  /// Gets the stored `T` value.\n+  ///\n+  /// This method should only be called if this ErrorOr object's status is OK\n+  /// (i.e. a call to ok() returns true), otherwise this call will abort.\n+  ///\n+  /// \\return The stored `T` value.\n+  const T& ValueOrDie() const& {\n+    if (!ok()) {\n \n Review comment:\n   done.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-11T06:21:32.985+0000",
                    "updated": "2019-06-11T06:21:32.985+0000",
                    "started": "2019-06-11T06:21:32.984+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "257443",
                    "issueId": "13220373"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/257446",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501#discussion_r292294541\n \n \n\n ##########\n File path: cpp/src/arrow/error_or.h\n ##########\n @@ -0,0 +1,427 @@\n+//\n+// Copyright 2017 Asylo authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+// Adapted from Asylo\n+\n+#pragma once\n+\n+#include <utility>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+\n+struct ErrorOrConstants {\n+  static const char kValueMoveConstructorMsg[];\n+  static const char kValueMoveAssignmentMsg[];\n+  static const char kValueOrDieMovedMsg[];\n+  static const char kStatusMoveConstructorMsg[];\n+  static const char kStatusMoveAssignmentMsg[];\n+};\n+\n+// A class for representing either a usable value, or an error.\n+///\n+/// A ErrorOr object either contains a value of type `T` or a Status object\n+/// explaining why such a value is not present. The type `T` must be\n+/// copy-constructible and/or move-constructible.\n+///\n+/// The state of a ErrorOr object may be determined by calling ok() or\n+/// status(). The ok() method returns true if the object contains a valid value.\n+/// The status() method returns the internal Status object. A ErrorOr object\n+/// that contains a valid value will return an OK Status for a call to status().\n+///\n+/// A value of type `T` may be extracted from a ErrorOr object through a call\n+/// to ValueOrDie(). This function should only be called if a call to ok()\n+/// returns true. Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<Foo> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     Foo foo = result.ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///  }\n+/// ```\n+///\n+/// If `T` is a move-only type, like `std::unique_ptr<>`, then the value should\n+/// only be extracted after invoking `std::move()` on the ErrorOr object.\n+/// Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<std::unique_ptr<Foo>> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     std::unique_ptr<Foo> foo = std::move(result).ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///   }\n+/// ```\n+///\n+/// ErrorOr is provided for the convenience of implementing functions that\n+/// return some value but may fail during execution. For instance, consider a\n+/// function with the following signature:\n+///\n+/// ```\n+///   arrow::Status CalculateFoo(int *output);\n+/// ```\n+///\n+/// This function may instead be written as:\n+///\n+/// ```\n+///   arrow::ErrorOr<int> CalculateFoo();\n+/// ```\n+template <class T>\n+class ErrorOr {\n+  template <typename U>\n+  friend class ErrorOr;\n+\n+ public:\n+  /// Constructs a ErrorOr object that contains a non-OK status.\n+  /// The non-OK status has an error code of -1. This is a non-standard POSIX\n+  /// error code and is used in this context to indicate an unknown error.\n+  ///\n+  /// This constructor is marked `explicit` to prevent attempts to `return {}`\n+  /// from a function with a return type of, for example,\n+  /// `ErrorOr<std::vector<int>>`. While `return {}` seems like it would return\n+  /// an empty vector, it will actually invoke the default constructor of\n+  /// ErrorOr.\n+  explicit ErrorOr()  // NOLINT(runtime/explicit)\n+      : variant_(Status::UnknownError(\"Unknown error\")), has_value_(false) {}\n+\n+  ~ErrorOr() {\n+    if (has_value_) {\n+      variant_.value_.~T();\n+    } else {\n+      variant_.status_.~Status();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object with the given non-OK Status object. All\n+  /// calls to ValueOrDie() on this object will abort. The given `status` must\n+  /// not be an OK status, otherwise this constructor will abort.\n+  ///\n+  /// This constructor is not declared explicit so that a function with a return\n+  /// type of `ErrorOr<T>` can return a Status object, and the status will be\n+  /// implicitly converted to the appropriate return type as a matter of\n+  /// convenience.\n+  ///\n+  /// \\param status The non-OK Status object to initalize to.\n+  ErrorOr(const Status& status)  // NOLINT(runtime/explicit)\n+      : variant_(status), has_value_(false) {\n+    if (status.ok()) {\n+      std::abort();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object that contains `value`. The resulting object\n+  /// is considered to have an OK status. The wrapped element can be accessed\n+  /// with ValueOrDie().\n+  ///\n+  /// This constructor is made implicit so that a function with a return type of\n+  /// `ErrorOr<T>` can return an object of type `U &&`, implicitly converting\n+  /// it to a `ErrorOr<T>` object.\n+  ///\n+  /// Note that `T` must be implicitly constructible from `U`, and `U` must not\n+  /// be a (cv-qualified) Status or Status-reference type. Due to C++\n+  /// reference-collapsing rules and perfect-forwarding semantics, this\n+  /// constructor matches invocations that pass `value` either as a const\n+  /// reference or as an rvalue reference. Since ErrorOr needs to work for both\n+  /// reference and rvalue-reference types, the constructor uses perfect\n+  /// forwarding to avoid invalidating arguments that were passed by reference.\n+  /// See http://thbecker.net/articles/rvalue_references/section_08.html for\n+  /// additional details.\n+  ///\n+  /// \\param value The value to initialize to.\n+  template <typename U,\n+            typename E = typename std::enable_if<\n+                std::is_constructible<T, U>::value && std::is_convertible<U, T>::value &&\n+                !std::is_same<typename std::remove_reference<\n+                                  typename std::remove_cv<U>::type>::type,\n+                              Status>::value>::type>\n+  ErrorOr(U&& value)  // NOLINT(runtime/explicit)\n+      : variant_(std::forward<U>(value)), has_value_(true) {}\n+\n+  /// Copy constructor.\n+  ///\n+  /// This constructor needs to be explicitly defined because the presence of\n+  /// the move-assignment operator deletes the default copy constructor. In such\n+  /// a scenario, since the deleted copy constructor has stricter binding rules\n+  /// than the templated copy constructor, the templated constructor cannot act\n+  /// as a copy constructor, and any attempt to copy-construct a `ErrorOr`\n+  /// object results in a compilation error.\n+  ///\n+  /// \\param other The value to copy from.\n+  ErrorOr(const ErrorOr& other)\n+      : has_value_(other.has_value_) {  // NOLINT(runtime/explicit)\n+    if (has_value_) {\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Templatized constructor that constructs a `ErrorOr<T>` from a const\n+  /// reference to a `ErrorOr<U>`.\n+  ///\n+  /// `T` must be implicitly constructible from `const U &`.\n+  ///\n+  /// \\param other The value to copy from.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(const ErrorOr<U>& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Copy-assignment operator.\n+  ///\n+  /// \\param other The ErrorOr object to copy.\n+  ErrorOr& operator=(const ErrorOr& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the source.\n+    if (other.has_value_) {\n+      AssignValue(other.variant_.value_);\n+    } else {\n+      AssignStatus(other.variant_.status_);\n+    }\n+    return *this;\n+  }\n+\n+  /// Templatized constructor which constructs a `ErrorOr<T>` by moving the\n+  /// contents of a `ErrorOr<U>`. `T` must be implicitly constructible from `U\n+  /// &&`.\n+  ///\n+  /// Sets `other` to contain a non-OK status with a`StatusError::Invalid`\n+  /// error code.\n+  ///\n+  /// \\param other The ErrorOr object to move from and set to a non-OK status.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(ErrorOr<U>&& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      new (&variant_) variant(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveConstructorMsg));\n+    } else {\n+      new (&variant_) variant(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveConstructorMsg);\n+#endif\n+    }\n+  }\n+\n+  /// Move-assignment operator.\n+  ///\n+  /// Sets `other` to contain a non-OK status.\n+  ///\n+  /// \\param other The ErrorOr object to assign from and set to a non-OK\n+  /// status.\n+  ErrorOr& operator=(ErrorOr&& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the donor.\n+    if (other.has_value_) {\n+      AssignValue(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveAssignmentMsg));\n+    } else {\n+      AssignStatus(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveAssignmentMsg);\n+#endif\n+    }\n+\n+    return *this;\n+  }\n+\n+  /// Indicates whether the object contains a `T` value.\n+  ///\n+  /// \\return True if this ErrorOr object's status is OK (i.e. a call to ok()\n+  /// returns true). If this function returns true, then it is safe to access\n+  /// the wrapped element through a call to ValueOrDie().\n+  bool ok() const { return has_value_; }\n+\n+  /// Gets the stored status object, or an OK status if a `T` value is stored.\n+  ///\n+  /// \\return The stored non-OK status object, or an OK status if this object\n+  ///         has a value.\n+  Status status() const { return ok() ? Status::OK() : variant_.status_; }\n+\n+  /// Gets the stored `T` value.\n+  ///\n+  /// This method should only be called if this ErrorOr object's status is OK\n+  /// (i.e. a call to ok() returns true), otherwise this call will abort.\n+  ///\n+  /// \\return The stored `T` value.\n+  const T& ValueOrDie() const& {\n+    if (!ok()) {\n+      std::abort();\n+    }\n+    return variant_.value_;\n+  }\n+\n+  /// Gets a mutable reference to the stored `T` value.\n+  ///\n+  /// This method should only be called if this ErrorOr object's status is OK\n+  /// (i.e. a call to ok() returns true), otherwise this call will abort.\n+  ///\n+  /// \\return The stored `T` value.\n+  T& ValueOrDie() & {\n+    if (!ok()) {\n+      std::abort();\n+    }\n+    return variant_.value_;\n+  }\n+\n+  /// Moves and returns the internally-stored `T` value.\n+  ///\n+  /// This method should only be called if this ErrorOr object's status is OK\n+  /// (i.e. a call to ok() returns true), otherwise this call will abort. The\n+  /// ErrorOr object is invalidated after this call and will be updated to\n+  /// contain a non-OK status.\n+  ///\n+  /// \\return The stored `T` value.\n+  T ValueOrDie() && {\n+    if (!ok()) {\n+      std::abort();\n+    }\n+    T tmp(std::move(variant_.value_));\n+\n+    // Invalidate this ErrorOr object.\n+    OverwriteValueWithStatus(Status::Invalid(ErrorOrConstants::kValueOrDieMovedMsg));\n+    return std::move(tmp);\n+  }\n+\n+ private:\n+  // Resets the |variant_| member to contain |status|.\n+  template <class U>\n+  void AssignStatus(U&& status) {\n+    if (ok()) {\n+      OverwriteValueWithStatus(std::forward<U>(status));\n+    } else {\n+      // Reuse the existing Status object. has_value_ is already false.\n+      variant_.status_ = std::forward<U>(status);\n+    }\n+  }\n+\n+  // Under the assumption that |this| is currently holding a value, resets the\n+  // |variant_| member to contain |status| and sets |has_value_| to indicate\n+  // that |this| does not have a value. Destroys the existing |variant_| member.\n+  template <class U>\n+  void OverwriteValueWithStatus(U&& status) {\n+#ifndef NDEBUG\n+    if (!ok()) {\n+      std::abort();\n+    }\n+#endif\n+    variant_.value_.~T();\n+    new (&variant_) variant(std::forward<U>(status));\n+    has_value_ = false;\n+  }\n+\n+  // Resets the |variant_| member to contain the |value| and sets |has_value_|\n+  // to indicate that the ErrorOr object has a value. Destroys the existing\n+  // |variant_| member.\n+  template <class U>\n+  void AssignValue(U&& value) {\n+    if (ok()) {\n+      // We cannot assume that T is move-assignable.\n+      variant_.value_.~T();\n+    } else {\n+      variant_.status_.~Status();\n+    }\n+    new (&variant_) variant(std::forward<U>(value));\n+    has_value_ = true;\n+  }\n+\n+  // Use custom variant instead of c++ standard, to avoid header polution.\n+  union variant {\n+    // A non-OK status.\n+    Status status_;\n+\n+    // An element of type T.\n+    T value_;\n+\n+    variant() {}\n+\n+    variant(const Status& status) : status_(status) {}\n+\n+    variant(Status&& status) : status_(std::move(status)) {}\n+\n+    template <typename U, typename E = typename std::enable_if<\n+                              std::is_constructible<T, U>::value &&\n+                              std::is_convertible<U, T>::value>::type>\n+    variant(U&& value) : value_(std::forward<U>(value)) {}\n+\n+    // This destructor must be explicitly defined because it is deleted due to\n+    // the variant type having non-static data members with non-trivial\n+    // destructors.\n+    ~variant() {}\n+  };\n+\n+  // One of: a non-OK status or an element of type T.\n+  variant variant_;\n+\n+  // Indicates the active member of the variant_ member.\n+  //\n+  // A value of true indicates that value_ is the active member of variant_.\n+  //\n+  // A value of false indicates that status_ is the active member of variant_.\n+  bool has_value_;\n+};\n+\n+#define ASSIGN_OR_RAISE_IMPL(status_name, lhs, rexpr) \\\n+  auto status_name = (rexpr);                         \\\n+  RETURN_NOT_OK(status_name.status());                \\\n+  lhs = std::move(status_name).ValueOrDie();\n+\n+#define ASSIGN_OR_RAISE_NAME(x, y) ARROW_CONCAT(x, y)\n+\n+// Executes an expression that returns a ErrorOr, extracting its value\n+// into the variable defined by lhs (or returning on error).\n+//\n+// Example: Assigning to an existing value\n+//   ValueType value;\n+//   ASSIGN_OR_RAISE(value, MaybeGetValue(arg));\n+//\n+// WARNING: ASSIGN_OR_RAISE expands into multiple statements; it cannot be used\n \n Review comment:\n   FWIW, I don't think too many people will try to do this.  But I'm not sure I understand your comment fully.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-11T06:29:50.408+0000",
                    "updated": "2019-06-11T06:29:50.408+0000",
                    "started": "2019-06-11T06:29:50.393+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "257446",
                    "issueId": "13220373"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/257456",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on issue #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501#issuecomment-500708155\n \n \n   > Do you know what kind of guidance for developers is in place in the Google projects that use both this and plain Status in APIs?\r\n   \r\n   @wesm I think StatusOr  has been around long enough at google that there aren't many mixed projects.  Generally the guidance is to use StatusOr/ErrorOr instead of output parameters when possible (there still might be some scenarios where the performance is better with the Status pattern, but I think those are few and far between, and would probably warrant returning status as an output parameter as well).\r\n   \r\n   If this PR is approved I would propose the following strategy:\r\n   1.   New code use it when possible.\r\n   2.  Slowly add methods that give the same functionality as existing ones and deprecate the old ones over a period of time).\r\n   \r\n   @fsaintjacques tried to address comments. will look at fixing appveyor builds tomorrow.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-11T06:40:05.046+0000",
                    "updated": "2019-06-11T06:40:05.046+0000",
                    "started": "2019-06-11T06:40:05.046+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "257456",
                    "issueId": "13220373"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/257646",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on pull request #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501#discussion_r292420703\n \n \n\n ##########\n File path: cpp/src/arrow/error_or.h\n ##########\n @@ -0,0 +1,427 @@\n+//\n+// Copyright 2017 Asylo authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+// Adapted from Asylo\n+\n+#pragma once\n+\n+#include <utility>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+\n+struct ErrorOrConstants {\n+  static const char kValueMoveConstructorMsg[];\n+  static const char kValueMoveAssignmentMsg[];\n+  static const char kValueOrDieMovedMsg[];\n+  static const char kStatusMoveConstructorMsg[];\n+  static const char kStatusMoveAssignmentMsg[];\n+};\n+\n+// A class for representing either a usable value, or an error.\n+///\n+/// A ErrorOr object either contains a value of type `T` or a Status object\n+/// explaining why such a value is not present. The type `T` must be\n+/// copy-constructible and/or move-constructible.\n+///\n+/// The state of a ErrorOr object may be determined by calling ok() or\n+/// status(). The ok() method returns true if the object contains a valid value.\n+/// The status() method returns the internal Status object. A ErrorOr object\n+/// that contains a valid value will return an OK Status for a call to status().\n+///\n+/// A value of type `T` may be extracted from a ErrorOr object through a call\n+/// to ValueOrDie(). This function should only be called if a call to ok()\n+/// returns true. Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<Foo> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     Foo foo = result.ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///  }\n+/// ```\n+///\n+/// If `T` is a move-only type, like `std::unique_ptr<>`, then the value should\n+/// only be extracted after invoking `std::move()` on the ErrorOr object.\n+/// Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<std::unique_ptr<Foo>> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     std::unique_ptr<Foo> foo = std::move(result).ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///   }\n+/// ```\n+///\n+/// ErrorOr is provided for the convenience of implementing functions that\n+/// return some value but may fail during execution. For instance, consider a\n+/// function with the following signature:\n+///\n+/// ```\n+///   arrow::Status CalculateFoo(int *output);\n+/// ```\n+///\n+/// This function may instead be written as:\n+///\n+/// ```\n+///   arrow::ErrorOr<int> CalculateFoo();\n+/// ```\n+template <class T>\n+class ErrorOr {\n+  template <typename U>\n+  friend class ErrorOr;\n+\n+ public:\n+  /// Constructs a ErrorOr object that contains a non-OK status.\n+  /// The non-OK status has an error code of -1. This is a non-standard POSIX\n+  /// error code and is used in this context to indicate an unknown error.\n+  ///\n+  /// This constructor is marked `explicit` to prevent attempts to `return {}`\n+  /// from a function with a return type of, for example,\n+  /// `ErrorOr<std::vector<int>>`. While `return {}` seems like it would return\n+  /// an empty vector, it will actually invoke the default constructor of\n+  /// ErrorOr.\n+  explicit ErrorOr()  // NOLINT(runtime/explicit)\n+      : variant_(Status::UnknownError(\"Unknown error\")), has_value_(false) {}\n+\n+  ~ErrorOr() {\n+    if (has_value_) {\n+      variant_.value_.~T();\n+    } else {\n+      variant_.status_.~Status();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object with the given non-OK Status object. All\n+  /// calls to ValueOrDie() on this object will abort. The given `status` must\n+  /// not be an OK status, otherwise this constructor will abort.\n+  ///\n+  /// This constructor is not declared explicit so that a function with a return\n+  /// type of `ErrorOr<T>` can return a Status object, and the status will be\n+  /// implicitly converted to the appropriate return type as a matter of\n+  /// convenience.\n+  ///\n+  /// \\param status The non-OK Status object to initalize to.\n+  ErrorOr(const Status& status)  // NOLINT(runtime/explicit)\n+      : variant_(status), has_value_(false) {\n+    if (status.ok()) {\n+      std::abort();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object that contains `value`. The resulting object\n+  /// is considered to have an OK status. The wrapped element can be accessed\n+  /// with ValueOrDie().\n+  ///\n+  /// This constructor is made implicit so that a function with a return type of\n+  /// `ErrorOr<T>` can return an object of type `U &&`, implicitly converting\n+  /// it to a `ErrorOr<T>` object.\n+  ///\n+  /// Note that `T` must be implicitly constructible from `U`, and `U` must not\n+  /// be a (cv-qualified) Status or Status-reference type. Due to C++\n+  /// reference-collapsing rules and perfect-forwarding semantics, this\n+  /// constructor matches invocations that pass `value` either as a const\n+  /// reference or as an rvalue reference. Since ErrorOr needs to work for both\n+  /// reference and rvalue-reference types, the constructor uses perfect\n+  /// forwarding to avoid invalidating arguments that were passed by reference.\n+  /// See http://thbecker.net/articles/rvalue_references/section_08.html for\n+  /// additional details.\n+  ///\n+  /// \\param value The value to initialize to.\n+  template <typename U,\n+            typename E = typename std::enable_if<\n+                std::is_constructible<T, U>::value && std::is_convertible<U, T>::value &&\n+                !std::is_same<typename std::remove_reference<\n+                                  typename std::remove_cv<U>::type>::type,\n+                              Status>::value>::type>\n+  ErrorOr(U&& value)  // NOLINT(runtime/explicit)\n+      : variant_(std::forward<U>(value)), has_value_(true) {}\n+\n+  /// Copy constructor.\n+  ///\n+  /// This constructor needs to be explicitly defined because the presence of\n+  /// the move-assignment operator deletes the default copy constructor. In such\n+  /// a scenario, since the deleted copy constructor has stricter binding rules\n+  /// than the templated copy constructor, the templated constructor cannot act\n+  /// as a copy constructor, and any attempt to copy-construct a `ErrorOr`\n+  /// object results in a compilation error.\n+  ///\n+  /// \\param other The value to copy from.\n+  ErrorOr(const ErrorOr& other)\n+      : has_value_(other.has_value_) {  // NOLINT(runtime/explicit)\n+    if (has_value_) {\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Templatized constructor that constructs a `ErrorOr<T>` from a const\n+  /// reference to a `ErrorOr<U>`.\n+  ///\n+  /// `T` must be implicitly constructible from `const U &`.\n+  ///\n+  /// \\param other The value to copy from.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(const ErrorOr<U>& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Copy-assignment operator.\n+  ///\n+  /// \\param other The ErrorOr object to copy.\n+  ErrorOr& operator=(const ErrorOr& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the source.\n+    if (other.has_value_) {\n+      AssignValue(other.variant_.value_);\n+    } else {\n+      AssignStatus(other.variant_.status_);\n+    }\n+    return *this;\n+  }\n+\n+  /// Templatized constructor which constructs a `ErrorOr<T>` by moving the\n+  /// contents of a `ErrorOr<U>`. `T` must be implicitly constructible from `U\n+  /// &&`.\n+  ///\n+  /// Sets `other` to contain a non-OK status with a`StatusError::Invalid`\n+  /// error code.\n+  ///\n+  /// \\param other The ErrorOr object to move from and set to a non-OK status.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(ErrorOr<U>&& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      new (&variant_) variant(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveConstructorMsg));\n+    } else {\n+      new (&variant_) variant(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveConstructorMsg);\n+#endif\n+    }\n+  }\n+\n+  /// Move-assignment operator.\n+  ///\n+  /// Sets `other` to contain a non-OK status.\n+  ///\n+  /// \\param other The ErrorOr object to assign from and set to a non-OK\n+  /// status.\n+  ErrorOr& operator=(ErrorOr&& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the donor.\n+    if (other.has_value_) {\n+      AssignValue(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveAssignmentMsg));\n+    } else {\n+      AssignStatus(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveAssignmentMsg);\n+#endif\n+    }\n+\n+    return *this;\n+  }\n+\n+  /// Indicates whether the object contains a `T` value.\n+  ///\n+  /// \\return True if this ErrorOr object's status is OK (i.e. a call to ok()\n+  /// returns true). If this function returns true, then it is safe to access\n+  /// the wrapped element through a call to ValueOrDie().\n+  bool ok() const { return has_value_; }\n \n Review comment:\n   I think it's worth adding the bool operator.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-11T12:09:50.332+0000",
                    "updated": "2019-06-11T12:09:50.332+0000",
                    "started": "2019-06-11T12:09:50.331+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "257646",
                    "issueId": "13220373"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/257658",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on issue #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501#issuecomment-500817353\n \n \n   One thing to consider is integration with other languages, notably C/glib. The advantage of the output pointer parameter is that the caller decide the memory location, while the later requires an explicit move to emulate the same.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-11T12:23:29.114+0000",
                    "updated": "2019-06-11T12:23:29.114+0000",
                    "started": "2019-06-11T12:23:29.112+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "257658",
                    "issueId": "13220373"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/257691",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501#discussion_r292431472\n \n \n\n ##########\n File path: cpp/src/arrow/error_or.h\n ##########\n @@ -0,0 +1,440 @@\n+//\n+// Copyright 2017 Asylo authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+// Adapted from Asylo\n+\n+#pragma once\n+\n+#include <string>\n+#include <utility>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+\n+namespace internal {\n+void DieWithMessage(const std::string& msg);\n+}  // namespace internal\n+\n+struct ARROW_EXPORT ErrorOrConstants {\n+  static const char kValueMoveConstructorMsg[];\n+  static const char kValueMoveAssignmentMsg[];\n+  static const char kValueOrDieMovedMsg[];\n+  static const char kStatusMoveConstructorMsg[];\n+  static const char kStatusMoveAssignmentMsg[];\n+};\n+\n+// A class for representing either a usable value, or an error.\n+///\n+/// A ErrorOr object either contains a value of type `T` or a Status object\n+/// explaining why such a value is not present. The type `T` must be\n+/// copy-constructible and/or move-constructible.\n+///\n+/// The state of a ErrorOr object may be determined by calling ok() or\n+/// status(). The ok() method returns true if the object contains a valid value.\n+/// The status() method returns the internal Status object. A ErrorOr object\n+/// that contains a valid value will return an OK Status for a call to status().\n+///\n+/// A value of type `T` may be extracted from a ErrorOr object through a call\n+/// to ValueOrDie(). This function should only be called if a call to ok()\n+/// returns true. Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<Foo> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     Foo foo = result.ValueOrDie();\n+///     foo.DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///  }\n+/// ```\n+///\n+/// If `T` is a move-only type, like `std::unique_ptr<>`, then the value should\n+/// only be extracted after invoking `std::move()` on the ErrorOr object.\n+/// Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<std::unique_ptr<Foo>> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     std::unique_ptr<Foo> foo = std::move(result).ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///   }\n+/// ```\n+///\n+/// ErrorOr is provided for the convenience of implementing functions that\n+/// return some value but may fail during execution. For instance, consider a\n+/// function with the following signature:\n+///\n+/// ```\n+///   arrow::Status CalculateFoo(int *output);\n+/// ```\n+///\n+/// This function may instead be written as:\n+///\n+/// ```\n+///   arrow::ErrorOr<int> CalculateFoo();\n+/// ```\n+template <class T>\n+class ARROW_EXPORT ErrorOr {\n+  template <typename U>\n+  friend class ErrorOr;\n+\n+ public:\n+  /// Constructs a ErrorOr object that contains a non-OK status.\n+  /// The non-OK status has an error code of -1. This is a non-standard POSIX\n+  /// error code and is used in this context to indicate an unknown error.\n+  ///\n+  /// This constructor is marked `explicit` to prevent attempts to `return {}`\n+  /// from a function with a return type of, for example,\n+  /// `ErrorOr<std::vector<int>>`. While `return {}` seems like it would return\n+  /// an empty vector, it will actually invoke the default constructor of\n+  /// ErrorOr.\n+  explicit ErrorOr()  // NOLINT(runtime/explicit)\n+      : variant_(Status::UnknownError(\"Unknown error\")), has_value_(false) {}\n+\n+  ~ErrorOr() {\n+    if (has_value_) {\n+      variant_.value_.~T();\n+    } else {\n+      variant_.status_.~Status();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object with the given non-OK Status object. All\n+  /// calls to ValueOrDie() on this object will abort. The given `status` must\n+  /// not be an OK status, otherwise this constructor will abort.\n+  ///\n+  /// This constructor is not declared explicit so that a function with a return\n+  /// type of `ErrorOr<T>` can return a Status object, and the status will be\n+  /// implicitly converted to the appropriate return type as a matter of\n+  /// convenience.\n+  ///\n+  /// \\param status The non-OK Status object to initalize to.\n+  ErrorOr(const Status& status)  // NOLINT(runtime/explicit)\n+      : variant_(status), has_value_(false) {\n+    if (ARROW_PREDICT_FALSE(status.ok())) {\n+      internal::DieWithMessage(\"Constructed with a non-error status.\");\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object that contains `value`. The resulting object\n+  /// is considered to have an OK status. The wrapped element can be accessed\n+  /// with ValueOrDie().\n+  ///\n+  /// This constructor is made implicit so that a function with a return type of\n+  /// `ErrorOr<T>` can return an object of type `U &&`, implicitly converting\n+  /// it to a `ErrorOr<T>` object.\n+  ///\n+  /// Note that `T` must be implicitly constructible from `U`, and `U` must not\n+  /// be a (cv-qualified) Status or Status-reference type. Due to C++\n+  /// reference-collapsing rules and perfect-forwarding semantics, this\n+  /// constructor matches invocations that pass `value` either as a const\n+  /// reference or as an rvalue reference. Since ErrorOr needs to work for both\n+  /// reference and rvalue-reference types, the constructor uses perfect\n+  /// forwarding to avoid invalidating arguments that were passed by reference.\n+  /// See http://thbecker.net/articles/rvalue_references/section_08.html for\n+  /// additional details.\n+  ///\n+  /// \\param value The value to initialize to.\n+  template <typename U,\n+            typename E = typename std::enable_if<\n+                std::is_constructible<T, U>::value && std::is_convertible<U, T>::value &&\n+                !std::is_same<typename std::remove_reference<\n+                                  typename std::remove_cv<U>::type>::type,\n+                              Status>::value>::type>\n+  ErrorOr(U&& value)  // NOLINT(runtime/explicit)\n+      : variant_(std::forward<U>(value)), has_value_(true) {}\n+\n+  /// Copy constructor.\n+  ///\n+  /// This constructor needs to be explicitly defined because the presence of\n+  /// the move-assignment operator deletes the default copy constructor. In such\n+  /// a scenario, since the deleted copy constructor has stricter binding rules\n+  /// than the templated copy constructor, the templated constructor cannot act\n+  /// as a copy constructor, and any attempt to copy-construct a `ErrorOr`\n+  /// object results in a compilation error.\n+  ///\n+  /// \\param other The value to copy from.\n+  ErrorOr(const ErrorOr& other)\n+      : has_value_(other.has_value_) {  // NOLINT(runtime/explicit)\n+    if (has_value_) {\n+      // Re-use the memory from variant when constructing\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Templatized constructor that constructs a `ErrorOr<T>` from a const\n+  /// reference to a `ErrorOr<U>`.\n+  ///\n+  /// `T` must be implicitly constructible from `const U &`.\n+  ///\n+  /// \\param other The value to copy from.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(const ErrorOr<U>& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      // Re-use the memory from variant when constructing\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Copy-assignment operator.\n+  ///\n+  /// \\param other The ErrorOr object to copy.\n+  ErrorOr& operator=(const ErrorOr& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the source.\n+    if (other.has_value_) {\n+      AssignValue(other.variant_.value_);\n+    } else {\n+      AssignStatus(other.variant_.status_);\n+    }\n+    return *this;\n+  }\n+\n+  /// Templatized constructor which constructs a `ErrorOr<T>` by moving the\n+  /// contents of a `ErrorOr<U>`. `T` must be implicitly constructible from `U\n+  /// &&`.\n+  ///\n+  /// Sets `other` to contain a non-OK status with a`StatusError::Invalid`\n+  /// error code.\n+  ///\n+  /// \\param other The ErrorOr object to move from and set to a non-OK status.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(ErrorOr<U>&& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      // Re-use the memory from variant when constructing\n+      new (&variant_) variant(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveConstructorMsg));\n+    } else {\n+      // Re-use the memory from variant when constructing\n+      new (&variant_) variant(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveConstructorMsg);\n+#endif\n+    }\n+  }\n+\n+  /// Move-assignment operator.\n+  ///\n+  /// Sets `other` to contain a non-OK status.\n+  ///\n+  /// \\param other The ErrorOr object to assign from and set to a non-OK\n+  /// status.\n+  ErrorOr& operator=(ErrorOr&& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the donor.\n+    if (other.has_value_) {\n+      AssignValue(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveAssignmentMsg));\n+    } else {\n+      AssignStatus(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveAssignmentMsg);\n+#endif\n+    }\n+\n+    return *this;\n+  }\n+\n+  /// Indicates whether the object contains a `T` value.  Generally instead\n+  /// of accessing this directly you will want to use ASSIGN_OR_RAISE defined\n+  /// below.\n+  ///\n+  /// \\return True if this ErrorOr object's status is OK (i.e. a call to ok()\n+  /// returns true). If this function returns true, then it is safe to access\n+  /// the wrapped element through a call to ValueOrDie().\n+  bool ok() const { return has_value_; }\n+\n+  /// Gets the stored status object, or an OK status if a `T` value is stored.\n+  ///\n+  /// \\return The stored non-OK status object, or an OK status if this object\n+  ///         has a value.\n+  Status status() const { return ok() ? Status::OK() : variant_.status_; }\n+\n+  /// Gets the stored `T` value.\n+  ///\n+  /// This method should only be called if this ErrorOr object's status is OK\n+  /// (i.e. a call to ok() returns true), otherwise this call will abort.\n+  ///\n+  /// \\return The stored `T` value.\n+  const T& ValueOrDie() const& {\n+    if (ARROW_PREDICT_FALSE(!ok())) {\n+      internal::DieWithMessage(\"ValueOrDie called on an error.\");\n+    }\n+    return variant_.value_;\n+  }\n+\n+  /// Gets a mutable reference to the stored `T` value.\n+  ///\n+  /// This method should only be called if this ErrorOr object's status is OK\n+  /// (i.e. a call to ok() returns true), otherwise this call will abort.\n+  ///\n+  /// \\return The stored `T` value.\n+  T& ValueOrDie() & {\n \n Review comment:\n   This is a mouthful. Can't we have `operator*` or something?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-11T12:51:37.423+0000",
                    "updated": "2019-06-11T12:51:37.423+0000",
                    "started": "2019-06-11T12:51:37.422+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "257691",
                    "issueId": "13220373"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/257692",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501#discussion_r292433572\n \n \n\n ##########\n File path: cpp/src/arrow/error_or.h\n ##########\n @@ -0,0 +1,427 @@\n+//\n+// Copyright 2017 Asylo authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+// Adapted from Asylo\n+\n+#pragma once\n+\n+#include <utility>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+\n+struct ErrorOrConstants {\n+  static const char kValueMoveConstructorMsg[];\n+  static const char kValueMoveAssignmentMsg[];\n+  static const char kValueOrDieMovedMsg[];\n+  static const char kStatusMoveConstructorMsg[];\n+  static const char kStatusMoveAssignmentMsg[];\n+};\n+\n+// A class for representing either a usable value, or an error.\n+///\n+/// A ErrorOr object either contains a value of type `T` or a Status object\n+/// explaining why such a value is not present. The type `T` must be\n+/// copy-constructible and/or move-constructible.\n+///\n+/// The state of a ErrorOr object may be determined by calling ok() or\n+/// status(). The ok() method returns true if the object contains a valid value.\n+/// The status() method returns the internal Status object. A ErrorOr object\n+/// that contains a valid value will return an OK Status for a call to status().\n+///\n+/// A value of type `T` may be extracted from a ErrorOr object through a call\n+/// to ValueOrDie(). This function should only be called if a call to ok()\n+/// returns true. Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<Foo> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     Foo foo = result.ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///  }\n+/// ```\n+///\n+/// If `T` is a move-only type, like `std::unique_ptr<>`, then the value should\n+/// only be extracted after invoking `std::move()` on the ErrorOr object.\n+/// Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<std::unique_ptr<Foo>> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     std::unique_ptr<Foo> foo = std::move(result).ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///   }\n+/// ```\n+///\n+/// ErrorOr is provided for the convenience of implementing functions that\n+/// return some value but may fail during execution. For instance, consider a\n+/// function with the following signature:\n+///\n+/// ```\n+///   arrow::Status CalculateFoo(int *output);\n+/// ```\n+///\n+/// This function may instead be written as:\n+///\n+/// ```\n+///   arrow::ErrorOr<int> CalculateFoo();\n+/// ```\n+template <class T>\n+class ErrorOr {\n+  template <typename U>\n+  friend class ErrorOr;\n+\n+ public:\n+  /// Constructs a ErrorOr object that contains a non-OK status.\n+  /// The non-OK status has an error code of -1. This is a non-standard POSIX\n+  /// error code and is used in this context to indicate an unknown error.\n+  ///\n+  /// This constructor is marked `explicit` to prevent attempts to `return {}`\n+  /// from a function with a return type of, for example,\n+  /// `ErrorOr<std::vector<int>>`. While `return {}` seems like it would return\n+  /// an empty vector, it will actually invoke the default constructor of\n+  /// ErrorOr.\n+  explicit ErrorOr()  // NOLINT(runtime/explicit)\n+      : variant_(Status::UnknownError(\"Unknown error\")), has_value_(false) {}\n+\n+  ~ErrorOr() {\n+    if (has_value_) {\n+      variant_.value_.~T();\n+    } else {\n+      variant_.status_.~Status();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object with the given non-OK Status object. All\n+  /// calls to ValueOrDie() on this object will abort. The given `status` must\n+  /// not be an OK status, otherwise this constructor will abort.\n+  ///\n+  /// This constructor is not declared explicit so that a function with a return\n+  /// type of `ErrorOr<T>` can return a Status object, and the status will be\n+  /// implicitly converted to the appropriate return type as a matter of\n+  /// convenience.\n+  ///\n+  /// \\param status The non-OK Status object to initalize to.\n+  ErrorOr(const Status& status)  // NOLINT(runtime/explicit)\n+      : variant_(status), has_value_(false) {\n+    if (status.ok()) {\n+      std::abort();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object that contains `value`. The resulting object\n+  /// is considered to have an OK status. The wrapped element can be accessed\n+  /// with ValueOrDie().\n+  ///\n+  /// This constructor is made implicit so that a function with a return type of\n+  /// `ErrorOr<T>` can return an object of type `U &&`, implicitly converting\n+  /// it to a `ErrorOr<T>` object.\n+  ///\n+  /// Note that `T` must be implicitly constructible from `U`, and `U` must not\n+  /// be a (cv-qualified) Status or Status-reference type. Due to C++\n+  /// reference-collapsing rules and perfect-forwarding semantics, this\n+  /// constructor matches invocations that pass `value` either as a const\n+  /// reference or as an rvalue reference. Since ErrorOr needs to work for both\n+  /// reference and rvalue-reference types, the constructor uses perfect\n+  /// forwarding to avoid invalidating arguments that were passed by reference.\n+  /// See http://thbecker.net/articles/rvalue_references/section_08.html for\n+  /// additional details.\n+  ///\n+  /// \\param value The value to initialize to.\n+  template <typename U,\n+            typename E = typename std::enable_if<\n+                std::is_constructible<T, U>::value && std::is_convertible<U, T>::value &&\n+                !std::is_same<typename std::remove_reference<\n+                                  typename std::remove_cv<U>::type>::type,\n+                              Status>::value>::type>\n+  ErrorOr(U&& value)  // NOLINT(runtime/explicit)\n+      : variant_(std::forward<U>(value)), has_value_(true) {}\n+\n+  /// Copy constructor.\n+  ///\n+  /// This constructor needs to be explicitly defined because the presence of\n+  /// the move-assignment operator deletes the default copy constructor. In such\n+  /// a scenario, since the deleted copy constructor has stricter binding rules\n+  /// than the templated copy constructor, the templated constructor cannot act\n+  /// as a copy constructor, and any attempt to copy-construct a `ErrorOr`\n+  /// object results in a compilation error.\n+  ///\n+  /// \\param other The value to copy from.\n+  ErrorOr(const ErrorOr& other)\n+      : has_value_(other.has_value_) {  // NOLINT(runtime/explicit)\n+    if (has_value_) {\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Templatized constructor that constructs a `ErrorOr<T>` from a const\n+  /// reference to a `ErrorOr<U>`.\n+  ///\n+  /// `T` must be implicitly constructible from `const U &`.\n+  ///\n+  /// \\param other The value to copy from.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(const ErrorOr<U>& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Copy-assignment operator.\n+  ///\n+  /// \\param other The ErrorOr object to copy.\n+  ErrorOr& operator=(const ErrorOr& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the source.\n+    if (other.has_value_) {\n+      AssignValue(other.variant_.value_);\n+    } else {\n+      AssignStatus(other.variant_.status_);\n+    }\n+    return *this;\n+  }\n+\n+  /// Templatized constructor which constructs a `ErrorOr<T>` by moving the\n+  /// contents of a `ErrorOr<U>`. `T` must be implicitly constructible from `U\n+  /// &&`.\n+  ///\n+  /// Sets `other` to contain a non-OK status with a`StatusError::Invalid`\n+  /// error code.\n+  ///\n+  /// \\param other The ErrorOr object to move from and set to a non-OK status.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(ErrorOr<U>&& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      new (&variant_) variant(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveConstructorMsg));\n+    } else {\n+      new (&variant_) variant(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveConstructorMsg);\n+#endif\n+    }\n+  }\n+\n+  /// Move-assignment operator.\n+  ///\n+  /// Sets `other` to contain a non-OK status.\n+  ///\n+  /// \\param other The ErrorOr object to assign from and set to a non-OK\n+  /// status.\n+  ErrorOr& operator=(ErrorOr&& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the donor.\n+    if (other.has_value_) {\n+      AssignValue(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveAssignmentMsg));\n+    } else {\n+      AssignStatus(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveAssignmentMsg);\n+#endif\n+    }\n+\n+    return *this;\n+  }\n+\n+  /// Indicates whether the object contains a `T` value.\n+  ///\n+  /// \\return True if this ErrorOr object's status is OK (i.e. a call to ok()\n+  /// returns true). If this function returns true, then it is safe to access\n+  /// the wrapped element through a call to ValueOrDie().\n+  bool ok() const { return has_value_; }\n+\n+  /// Gets the stored status object, or an OK status if a `T` value is stored.\n+  ///\n+  /// \\return The stored non-OK status object, or an OK status if this object\n+  ///         has a value.\n+  Status status() const { return ok() ? Status::OK() : variant_.status_; }\n+\n+  /// Gets the stored `T` value.\n+  ///\n+  /// This method should only be called if this ErrorOr object's status is OK\n+  /// (i.e. a call to ok() returns true), otherwise this call will abort.\n+  ///\n+  /// \\return The stored `T` value.\n+  const T& ValueOrDie() const& {\n+    if (!ok()) {\n+      std::abort();\n+    }\n+    return variant_.value_;\n+  }\n+\n+  /// Gets a mutable reference to the stored `T` value.\n+  ///\n+  /// This method should only be called if this ErrorOr object's status is OK\n+  /// (i.e. a call to ok() returns true), otherwise this call will abort.\n+  ///\n+  /// \\return The stored `T` value.\n+  T& ValueOrDie() & {\n+    if (!ok()) {\n+      std::abort();\n+    }\n+    return variant_.value_;\n+  }\n+\n+  /// Moves and returns the internally-stored `T` value.\n+  ///\n+  /// This method should only be called if this ErrorOr object's status is OK\n+  /// (i.e. a call to ok() returns true), otherwise this call will abort. The\n+  /// ErrorOr object is invalidated after this call and will be updated to\n+  /// contain a non-OK status.\n+  ///\n+  /// \\return The stored `T` value.\n+  T ValueOrDie() && {\n+    if (!ok()) {\n+      std::abort();\n+    }\n+    T tmp(std::move(variant_.value_));\n+\n+    // Invalidate this ErrorOr object.\n+    OverwriteValueWithStatus(Status::Invalid(ErrorOrConstants::kValueOrDieMovedMsg));\n+    return std::move(tmp);\n+  }\n+\n+ private:\n+  // Resets the |variant_| member to contain |status|.\n+  template <class U>\n+  void AssignStatus(U&& status) {\n+    if (ok()) {\n+      OverwriteValueWithStatus(std::forward<U>(status));\n+    } else {\n+      // Reuse the existing Status object. has_value_ is already false.\n+      variant_.status_ = std::forward<U>(status);\n+    }\n+  }\n+\n+  // Under the assumption that |this| is currently holding a value, resets the\n+  // |variant_| member to contain |status| and sets |has_value_| to indicate\n+  // that |this| does not have a value. Destroys the existing |variant_| member.\n+  template <class U>\n+  void OverwriteValueWithStatus(U&& status) {\n+#ifndef NDEBUG\n+    if (!ok()) {\n+      std::abort();\n+    }\n+#endif\n+    variant_.value_.~T();\n+    new (&variant_) variant(std::forward<U>(status));\n+    has_value_ = false;\n+  }\n+\n+  // Resets the |variant_| member to contain the |value| and sets |has_value_|\n+  // to indicate that the ErrorOr object has a value. Destroys the existing\n+  // |variant_| member.\n+  template <class U>\n+  void AssignValue(U&& value) {\n+    if (ok()) {\n+      // We cannot assume that T is move-assignable.\n+      variant_.value_.~T();\n+    } else {\n+      variant_.status_.~Status();\n+    }\n+    new (&variant_) variant(std::forward<U>(value));\n+    has_value_ = true;\n+  }\n+\n+  // Use custom variant instead of c++ standard, to avoid header polution.\n+  union variant {\n+    // A non-OK status.\n+    Status status_;\n+\n+    // An element of type T.\n+    T value_;\n+\n+    variant() {}\n+\n+    variant(const Status& status) : status_(status) {}\n+\n+    variant(Status&& status) : status_(std::move(status)) {}\n+\n+    template <typename U, typename E = typename std::enable_if<\n+                              std::is_constructible<T, U>::value &&\n+                              std::is_convertible<U, T>::value>::type>\n+    variant(U&& value) : value_(std::forward<U>(value)) {}\n+\n+    // This destructor must be explicitly defined because it is deleted due to\n+    // the variant type having non-static data members with non-trivial\n+    // destructors.\n+    ~variant() {}\n+  };\n+\n+  // One of: a non-OK status or an element of type T.\n+  variant variant_;\n+\n+  // Indicates the active member of the variant_ member.\n+  //\n+  // A value of true indicates that value_ is the active member of variant_.\n+  //\n+  // A value of false indicates that status_ is the active member of variant_.\n+  bool has_value_;\n+};\n+\n+#define ASSIGN_OR_RAISE_IMPL(status_name, lhs, rexpr) \\\n+  auto status_name = (rexpr);                         \\\n+  RETURN_NOT_OK(status_name.status());                \\\n+  lhs = std::move(status_name).ValueOrDie();\n+\n+#define ASSIGN_OR_RAISE_NAME(x, y) ARROW_CONCAT(x, y)\n+\n+// Executes an expression that returns a ErrorOr, extracting its value\n+// into the variable defined by lhs (or returning on error).\n+//\n+// Example: Assigning to an existing value\n+//   ValueType value;\n+//   ASSIGN_OR_RAISE(value, MaybeGetValue(arg));\n+//\n+// WARNING: ASSIGN_OR_RAISE expands into multiple statements; it cannot be used\n \n Review comment:\n   You should enclose the macro if a `do...while`, like this:\r\n   ```cpp\r\n   ASSIGN_OR_RAISE_IMPL(status_name, lhs, rexpr) \\\r\n     do { \\\r\n       auto status_name = (rexpr);                         \\\r\n       ARROW_RETURN_NOT_OK(status_name.status());          \\\r\n       lhs = std::move(status_name).ValueOrDie(); \\\r\n     } while(0)\r\n   ```\r\n   \r\n   \r\n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-11T12:51:37.557+0000",
                    "updated": "2019-06-11T12:51:37.557+0000",
                    "started": "2019-06-11T12:51:37.556+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "257692",
                    "issueId": "13220373"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/257693",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501#discussion_r292436476\n \n \n\n ##########\n File path: cpp/src/arrow/error_or.h\n ##########\n @@ -0,0 +1,440 @@\n+//\n+// Copyright 2017 Asylo authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+// Adapted from Asylo\n+\n+#pragma once\n+\n+#include <string>\n+#include <utility>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+\n+namespace internal {\n+void DieWithMessage(const std::string& msg);\n+}  // namespace internal\n+\n+struct ARROW_EXPORT ErrorOrConstants {\n+  static const char kValueMoveConstructorMsg[];\n+  static const char kValueMoveAssignmentMsg[];\n+  static const char kValueOrDieMovedMsg[];\n+  static const char kStatusMoveConstructorMsg[];\n+  static const char kStatusMoveAssignmentMsg[];\n+};\n+\n+// A class for representing either a usable value, or an error.\n+///\n+/// A ErrorOr object either contains a value of type `T` or a Status object\n+/// explaining why such a value is not present. The type `T` must be\n+/// copy-constructible and/or move-constructible.\n+///\n+/// The state of a ErrorOr object may be determined by calling ok() or\n+/// status(). The ok() method returns true if the object contains a valid value.\n+/// The status() method returns the internal Status object. A ErrorOr object\n+/// that contains a valid value will return an OK Status for a call to status().\n+///\n+/// A value of type `T` may be extracted from a ErrorOr object through a call\n+/// to ValueOrDie(). This function should only be called if a call to ok()\n+/// returns true. Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<Foo> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     Foo foo = result.ValueOrDie();\n+///     foo.DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///  }\n+/// ```\n+///\n+/// If `T` is a move-only type, like `std::unique_ptr<>`, then the value should\n+/// only be extracted after invoking `std::move()` on the ErrorOr object.\n+/// Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<std::unique_ptr<Foo>> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     std::unique_ptr<Foo> foo = std::move(result).ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///   }\n+/// ```\n+///\n+/// ErrorOr is provided for the convenience of implementing functions that\n+/// return some value but may fail during execution. For instance, consider a\n+/// function with the following signature:\n+///\n+/// ```\n+///   arrow::Status CalculateFoo(int *output);\n+/// ```\n+///\n+/// This function may instead be written as:\n+///\n+/// ```\n+///   arrow::ErrorOr<int> CalculateFoo();\n+/// ```\n+template <class T>\n+class ARROW_EXPORT ErrorOr {\n+  template <typename U>\n+  friend class ErrorOr;\n+\n+ public:\n+  /// Constructs a ErrorOr object that contains a non-OK status.\n+  /// The non-OK status has an error code of -1. This is a non-standard POSIX\n+  /// error code and is used in this context to indicate an unknown error.\n+  ///\n+  /// This constructor is marked `explicit` to prevent attempts to `return {}`\n+  /// from a function with a return type of, for example,\n+  /// `ErrorOr<std::vector<int>>`. While `return {}` seems like it would return\n+  /// an empty vector, it will actually invoke the default constructor of\n+  /// ErrorOr.\n+  explicit ErrorOr()  // NOLINT(runtime/explicit)\n+      : variant_(Status::UnknownError(\"Unknown error\")), has_value_(false) {}\n+\n+  ~ErrorOr() {\n+    if (has_value_) {\n+      variant_.value_.~T();\n+    } else {\n+      variant_.status_.~Status();\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object with the given non-OK Status object. All\n+  /// calls to ValueOrDie() on this object will abort. The given `status` must\n+  /// not be an OK status, otherwise this constructor will abort.\n+  ///\n+  /// This constructor is not declared explicit so that a function with a return\n+  /// type of `ErrorOr<T>` can return a Status object, and the status will be\n+  /// implicitly converted to the appropriate return type as a matter of\n+  /// convenience.\n+  ///\n+  /// \\param status The non-OK Status object to initalize to.\n+  ErrorOr(const Status& status)  // NOLINT(runtime/explicit)\n+      : variant_(status), has_value_(false) {\n+    if (ARROW_PREDICT_FALSE(status.ok())) {\n+      internal::DieWithMessage(\"Constructed with a non-error status.\");\n+    }\n+  }\n+\n+  /// Constructs a ErrorOr object that contains `value`. The resulting object\n+  /// is considered to have an OK status. The wrapped element can be accessed\n+  /// with ValueOrDie().\n+  ///\n+  /// This constructor is made implicit so that a function with a return type of\n+  /// `ErrorOr<T>` can return an object of type `U &&`, implicitly converting\n+  /// it to a `ErrorOr<T>` object.\n+  ///\n+  /// Note that `T` must be implicitly constructible from `U`, and `U` must not\n+  /// be a (cv-qualified) Status or Status-reference type. Due to C++\n+  /// reference-collapsing rules and perfect-forwarding semantics, this\n+  /// constructor matches invocations that pass `value` either as a const\n+  /// reference or as an rvalue reference. Since ErrorOr needs to work for both\n+  /// reference and rvalue-reference types, the constructor uses perfect\n+  /// forwarding to avoid invalidating arguments that were passed by reference.\n+  /// See http://thbecker.net/articles/rvalue_references/section_08.html for\n+  /// additional details.\n+  ///\n+  /// \\param value The value to initialize to.\n+  template <typename U,\n+            typename E = typename std::enable_if<\n+                std::is_constructible<T, U>::value && std::is_convertible<U, T>::value &&\n+                !std::is_same<typename std::remove_reference<\n+                                  typename std::remove_cv<U>::type>::type,\n+                              Status>::value>::type>\n+  ErrorOr(U&& value)  // NOLINT(runtime/explicit)\n+      : variant_(std::forward<U>(value)), has_value_(true) {}\n+\n+  /// Copy constructor.\n+  ///\n+  /// This constructor needs to be explicitly defined because the presence of\n+  /// the move-assignment operator deletes the default copy constructor. In such\n+  /// a scenario, since the deleted copy constructor has stricter binding rules\n+  /// than the templated copy constructor, the templated constructor cannot act\n+  /// as a copy constructor, and any attempt to copy-construct a `ErrorOr`\n+  /// object results in a compilation error.\n+  ///\n+  /// \\param other The value to copy from.\n+  ErrorOr(const ErrorOr& other)\n+      : has_value_(other.has_value_) {  // NOLINT(runtime/explicit)\n+    if (has_value_) {\n+      // Re-use the memory from variant when constructing\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Templatized constructor that constructs a `ErrorOr<T>` from a const\n+  /// reference to a `ErrorOr<U>`.\n+  ///\n+  /// `T` must be implicitly constructible from `const U &`.\n+  ///\n+  /// \\param other The value to copy from.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(const ErrorOr<U>& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      // Re-use the memory from variant when constructing\n+      new (&variant_) variant(other.variant_.value_);\n+    } else {\n+      new (&variant_) variant(other.variant_.status_);\n+    }\n+  }\n+\n+  /// Copy-assignment operator.\n+  ///\n+  /// \\param other The ErrorOr object to copy.\n+  ErrorOr& operator=(const ErrorOr& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the source.\n+    if (other.has_value_) {\n+      AssignValue(other.variant_.value_);\n+    } else {\n+      AssignStatus(other.variant_.status_);\n+    }\n+    return *this;\n+  }\n+\n+  /// Templatized constructor which constructs a `ErrorOr<T>` by moving the\n+  /// contents of a `ErrorOr<U>`. `T` must be implicitly constructible from `U\n+  /// &&`.\n+  ///\n+  /// Sets `other` to contain a non-OK status with a`StatusError::Invalid`\n+  /// error code.\n+  ///\n+  /// \\param other The ErrorOr object to move from and set to a non-OK status.\n+  template <typename U,\n+            typename E = typename std::enable_if<std::is_constructible<T, U>::value &&\n+                                                 std::is_convertible<U, T>::value>::type>\n+  ErrorOr(ErrorOr<U>&& other) : has_value_(other.has_value_) {\n+    if (has_value_) {\n+      // Re-use the memory from variant when constructing\n+      new (&variant_) variant(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveConstructorMsg));\n+    } else {\n+      // Re-use the memory from variant when constructing\n+      new (&variant_) variant(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveConstructorMsg);\n+#endif\n+    }\n+  }\n+\n+  /// Move-assignment operator.\n+  ///\n+  /// Sets `other` to contain a non-OK status.\n+  ///\n+  /// \\param other The ErrorOr object to assign from and set to a non-OK\n+  /// status.\n+  ErrorOr& operator=(ErrorOr&& other) {\n+    // Check for self-assignment.\n+    if (this == &other) {\n+      return *this;\n+    }\n+\n+    // Construct the variant object using the variant object of the donor.\n+    if (other.has_value_) {\n+      AssignValue(std::move(other.variant_.value_));\n+      other.OverwriteValueWithStatus(\n+          Status::Invalid(ErrorOrConstants::kValueMoveAssignmentMsg));\n+    } else {\n+      AssignStatus(std::move(other.variant_.status_));\n+#ifndef NDEBUG\n+      // The other.variant_.status_ gets moved and invalidated with a Status-\n+      // specific error message above. To aid debugging, set the status to a\n+      // ErrorOr-specific error message.\n+      other.variant_.status_ =\n+          Status::Invalid(ErrorOrConstants::kStatusMoveAssignmentMsg);\n+#endif\n+    }\n+\n+    return *this;\n+  }\n+\n+  /// Indicates whether the object contains a `T` value.  Generally instead\n+  /// of accessing this directly you will want to use ASSIGN_OR_RAISE defined\n+  /// below.\n+  ///\n+  /// \\return True if this ErrorOr object's status is OK (i.e. a call to ok()\n+  /// returns true). If this function returns true, then it is safe to access\n+  /// the wrapped element through a call to ValueOrDie().\n+  bool ok() const { return has_value_; }\n+\n+  /// Gets the stored status object, or an OK status if a `T` value is stored.\n+  ///\n+  /// \\return The stored non-OK status object, or an OK status if this object\n+  ///         has a value.\n+  Status status() const { return ok() ? Status::OK() : variant_.status_; }\n+\n+  /// Gets the stored `T` value.\n+  ///\n+  /// This method should only be called if this ErrorOr object's status is OK\n+  /// (i.e. a call to ok() returns true), otherwise this call will abort.\n+  ///\n+  /// \\return The stored `T` value.\n+  const T& ValueOrDie() const& {\n+    if (ARROW_PREDICT_FALSE(!ok())) {\n+      internal::DieWithMessage(\"ValueOrDie called on an error.\");\n+    }\n+    return variant_.value_;\n+  }\n+\n+  /// Gets a mutable reference to the stored `T` value.\n+  ///\n+  /// This method should only be called if this ErrorOr object's status is OK\n+  /// (i.e. a call to ok() returns true), otherwise this call will abort.\n+  ///\n+  /// \\return The stored `T` value.\n+  T& ValueOrDie() & {\n+    if (ARROW_PREDICT_FALSE(!ok())) {\n+      internal::DieWithMessage(\"ValueOrDie called on an error.\");\n+    }\n+    return variant_.value_;\n+  }\n+\n+  /// Moves and returns the internally-stored `T` value.\n+  ///\n+  /// This method should only be called if this ErrorOr object's status is OK\n+  /// (i.e. a call to ok() returns true), otherwise this call will abort. The\n+  /// ErrorOr object is invalidated after this call and will be updated to\n+  /// contain a non-OK status.\n+  ///\n+  /// \\return The stored `T` value.\n+  T ValueOrDie() && {\n+    if (ARROW_PREDICT_FALSE(!ok())) {\n+      internal::DieWithMessage(\"ValueOrDie called on an error.\");\n+    }\n+    T tmp(std::move(variant_.value_));\n+\n+    // Invalidate this ErrorOr object.\n+    OverwriteValueWithStatus(Status::Invalid(ErrorOrConstants::kValueOrDieMovedMsg));\n+    return std::move(tmp);\n+  }\n+\n+ private:\n+  // Resets the |variant_| member to contain |status|.\n+  template <class U>\n+  void AssignStatus(U&& status) {\n+    if (ok()) {\n+      OverwriteValueWithStatus(std::forward<U>(status));\n+    } else {\n+      // Reuse the existing Status object. has_value_ is already false.\n+      variant_.status_ = std::forward<U>(status);\n+    }\n+  }\n+\n+  // Under the assumption that |this| is currently holding a value, resets the\n+  // |variant_| member to contain |status| and sets |has_value_| to indicate\n+  // that |this| does not have a value. Destroys the existing |variant_| member.\n+  template <class U>\n+  void OverwriteValueWithStatus(U&& status) {\n+#ifndef NDEBUG\n+    if (ARROW_PREDICT_FALSE(!ok())) {\n+      internal::DieWithMessage(\"OverwriteValueWithStatus called on with existing error.\");\n+    }\n+#endif\n+    variant_.value_.~T();\n+    // Re-use the memory from variant when constructing\n+    new (&variant_) variant(std::forward<U>(status));\n+    has_value_ = false;\n+  }\n+\n+  // Resets the |variant_| member to contain the |value| and sets |has_value_|\n+  // to indicate that the ErrorOr object has a value. Destroys the existing\n+  // |variant_| member.\n+  template <class U>\n+  void AssignValue(U&& value) {\n+    if (ok()) {\n+      // We cannot assume that T is move-assignable.\n+      variant_.value_.~T();\n+    } else {\n+      variant_.status_.~Status();\n+    }\n+    // Re-use the memory from variant when constructing\n+    new (&variant_) variant(std::forward<U>(value));\n+    has_value_ = true;\n+  }\n+\n+  // Use custom variant instead of c++ standard, to avoid header polution.\n+  union variant {\n+    // A non-OK status.\n+    Status status_;\n+\n+    // An element of type T.\n+    T value_;\n+\n+    variant() {}\n+\n+    variant(const Status& status) : status_(status) {}\n+\n+    variant(Status&& status) : status_(std::move(status)) {}\n+\n+    template <typename U, typename E = typename std::enable_if<\n+                              std::is_constructible<T, U>::value &&\n+                              std::is_convertible<U, T>::value>::type>\n+    variant(U&& value) : value_(std::forward<U>(value)) {}\n+\n+    // This destructor must be explicitly defined because it is deleted due to\n+    // the variant type having non-static data members with non-trivial\n+    // destructors.\n+    ~variant() {}\n+  };\n+\n+  // One of: a non-OK status or an element of type T.\n+  variant variant_;\n+\n+  // Indicates the active member of the variant_ member.\n+  //\n+  // A value of true indicates that value_ is the active member of variant_.\n+  //\n+  // A value of false indicates that status_ is the active member of variant_.\n+  bool has_value_;\n+};\n+\n+#define ASSIGN_OR_RAISE_IMPL(status_name, lhs, rexpr) \\\n+  auto status_name = (rexpr);                         \\\n+  ARROW_RETURN_NOT_OK(status_name.status());          \\\n+  lhs = std::move(status_name).ValueOrDie();\n+\n+#define ASSIGN_OR_RAISE_NAME(x, y) ARROW_CONCAT(x, y)\n+\n+// Executes an expression that returns a ErrorOr, extracting its value\n+// into the variable defined by lhs (or returning on error).\n+//\n+// Example: Assigning to an existing value\n+//   ValueType value;\n+//   ASSIGN_OR_RAISE(value, MaybeGetValue(arg));\n+//\n+// WARNING: ASSIGN_OR_RAISE expands into multiple statements; it cannot be used\n+//  in a single statement (e.g. as the body of an if statement without {})!\n+#define ASSIGN_OR_RAISE(lhs, rexpr) \\\n \n Review comment:\n   By the way, macros exposed in headers should probably begin with ARROW_.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-11T12:51:37.641+0000",
                    "updated": "2019-06-11T12:51:37.641+0000",
                    "started": "2019-06-11T12:51:37.641+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "257693",
                    "issueId": "13220373"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/worklog/257694",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4501: ARROW-4800: [C++] Introduce an ErrorOr class\nURL: https://github.com/apache/arrow/pull/4501#discussion_r292433892\n \n \n\n ##########\n File path: cpp/src/arrow/error_or.h\n ##########\n @@ -0,0 +1,440 @@\n+//\n+// Copyright 2017 Asylo authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+// Adapted from Asylo\n+\n+#pragma once\n+\n+#include <string>\n+#include <utility>\n+\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+\n+namespace arrow {\n+\n+namespace internal {\n+void DieWithMessage(const std::string& msg);\n+}  // namespace internal\n+\n+struct ARROW_EXPORT ErrorOrConstants {\n+  static const char kValueMoveConstructorMsg[];\n+  static const char kValueMoveAssignmentMsg[];\n+  static const char kValueOrDieMovedMsg[];\n+  static const char kStatusMoveConstructorMsg[];\n+  static const char kStatusMoveAssignmentMsg[];\n+};\n+\n+// A class for representing either a usable value, or an error.\n+///\n+/// A ErrorOr object either contains a value of type `T` or a Status object\n+/// explaining why such a value is not present. The type `T` must be\n+/// copy-constructible and/or move-constructible.\n+///\n+/// The state of a ErrorOr object may be determined by calling ok() or\n+/// status(). The ok() method returns true if the object contains a valid value.\n+/// The status() method returns the internal Status object. A ErrorOr object\n+/// that contains a valid value will return an OK Status for a call to status().\n+///\n+/// A value of type `T` may be extracted from a ErrorOr object through a call\n+/// to ValueOrDie(). This function should only be called if a call to ok()\n+/// returns true. Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<Foo> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     Foo foo = result.ValueOrDie();\n+///     foo.DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///  }\n+/// ```\n+///\n+/// If `T` is a move-only type, like `std::unique_ptr<>`, then the value should\n+/// only be extracted after invoking `std::move()` on the ErrorOr object.\n+/// Sample usage:\n+///\n+/// ```\n+///   arrow::ErrorOr<std::unique_ptr<Foo>> result = CalculateFoo();\n+///   if (result.ok()) {\n+///     std::unique_ptr<Foo> foo = std::move(result).ValueOrDie();\n+///     foo->DoSomethingCool();\n+///   } else {\n+///     ARROW_LOG(ERROR) << result.status();\n+///   }\n+/// ```\n+///\n+/// ErrorOr is provided for the convenience of implementing functions that\n+/// return some value but may fail during execution. For instance, consider a\n+/// function with the following signature:\n+///\n+/// ```\n+///   arrow::Status CalculateFoo(int *output);\n+/// ```\n+///\n+/// This function may instead be written as:\n+///\n+/// ```\n+///   arrow::ErrorOr<int> CalculateFoo();\n+/// ```\n+template <class T>\n+class ARROW_EXPORT ErrorOr {\n \n Review comment:\n   My 2 cents, but I find this name ugly. `Result<T>` reads much better.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-11T12:51:40.480+0000",
                    "updated": "2019-06-11T12:51:40.480+0000",
                    "started": "2019-06-11T12:51:40.479+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "257694",
                    "issueId": "13220373"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 47400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@1b776825[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@77935d98[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2d58154f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@40cae2e1[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@50e2ce98[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@2e46f4ed[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@43d97e07[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@54135177[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1243d363[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@b3bac5a[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@31ad27c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4dccb381[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 47400,
        "customfield_12312520": null,
        "customfield_12312521": "Sat Jun 22 20:22:52 UTC 2019",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2019-06-22T20:22:52.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-4800/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2019-03-08T03:57:19.000+0000",
        "updated": "2019-06-22T20:23:03.000+0000",
        "timeoriginalestimate": null,
        "description": "Example from grpc: https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/stubs/statusor.h",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "13h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 47400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Create/port a StatusOr implementation to be able to return a status or a type",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/comment/16795000",
                    "id": "16795000",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "What is the cost of unboxing the value with such a scheme? Say I have a {{StatusOr<std::vector<something>>}}, can we avoid copying the vector when getting its value?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2019-03-18T13:14:49.424+0000",
                    "updated": "2019-03-18T13:14:49.424+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/comment/16796197",
                    "id": "16796197",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
                        "name": "emkornfield@gmail.com",
                        "key": "emkornfield@gmail.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "The linked reference seems relatively simple, and returns a reference when unboxing.  I believe this could probably be made more complex to support move-semantics as well.   I've mostly seen usage of this type with either primitives or unique/shared pointers so the cost hasn't been an issue.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
                        "name": "emkornfield@gmail.com",
                        "key": "emkornfield@gmail.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2019-03-19T15:28:06.428+0000",
                    "updated": "2019-03-19T15:28:06.428+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/comment/16796204",
                    "id": "16796204",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
                        "name": "emkornfield@gmail.com",
                        "key": "emkornfield@gmail.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "https://github.com/google/asylo/blob/master/asylo/util/statusor.h is a slightly more complicated implementation that does some with with R-value references.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
                        "name": "emkornfield@gmail.com",
                        "key": "emkornfield@gmail.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2019-03-19T15:31:06.874+0000",
                    "updated": "2019-03-19T15:31:06.874+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/comment/16796209",
                    "id": "16796209",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
                        "name": "emkornfield@gmail.com",
                        "key": "emkornfield@gmail.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "We should also port ASSIGN_OR_RETURN (https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/xla/status_macros.h#L203) when implementing this.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
                        "name": "emkornfield@gmail.com",
                        "key": "emkornfield@gmail.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2019-03-19T15:37:29.425+0000",
                    "updated": "2019-03-19T15:37:29.425+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/comment/16809779",
                    "id": "16809779",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=fsaintjacques",
                        "name": "fsaintjacques",
                        "key": "fsaintjacques",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=fsaintjacques&avatarId=37276",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fsaintjacques&avatarId=37276",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fsaintjacques&avatarId=37276",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fsaintjacques&avatarId=37276"
                        },
                        "displayName": "Francois Saint-Jacques",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "LLVM types:\r\n\r\n* [Expected|https://github.com/llvm/llvm-project/blob/master/llvm/include/llvm/Support/Error.h#L433]\r\n* [ErrorOr|https://github.com/llvm/llvm-project/blob/master/llvm/include/llvm/Support/ErrorOr.h#L26]\r\n* [Optional|https://github.com/llvm/llvm-project/blob/master/llvm/include/llvm/ADT/Optional.h]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=fsaintjacques",
                        "name": "fsaintjacques",
                        "key": "fsaintjacques",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=fsaintjacques&avatarId=37276",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fsaintjacques&avatarId=37276",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fsaintjacques&avatarId=37276",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fsaintjacques&avatarId=37276"
                        },
                        "displayName": "Francois Saint-Jacques",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2019-04-04T12:08:18.156+0000",
                    "updated": "2019-04-04T12:08:18.156+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/comment/16845686",
                    "id": "16845686",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "I would rather call this {{Result<>}}.\r\n\r\nIdeally we would rewrite all Status-returning APIs to return a {{Result<>}} instead. Of course it's probably out of question (both because it breaks compatibility, and because of the huge hassle in refactoring all Arrow code).",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2019-05-22T08:58:02.485+0000",
                    "updated": "2019-05-22T08:58:02.485+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/comment/16846467",
                    "id": "16846467",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
                        "name": "emkornfield@gmail.com",
                        "key": "emkornfield@gmail.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "As long as we are bikeshedding, I think I ErrorOr or StatusOr are more understandable without looking at the class.\r\n\r\nAgreed on trying to replace APIs, but I think this can be somewhat incremental as we developer higher level functionality we can go down the stack.  The nice thing is these APIs can live side by side since the method signature should always be different.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
                        "name": "emkornfield@gmail.com",
                        "key": "emkornfield@gmail.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2019-05-23T06:34:52.167+0000",
                    "updated": "2019-05-23T06:34:52.167+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220373/comment/16870355",
                    "id": "16870355",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 4501\n[https://github.com/apache/arrow/pull/4501]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2019-06-22T20:22:52.123+0000",
                    "updated": "2019-06-22T20:22:52.123+0000"
                }
            ],
            "maxResults": 8,
            "total": 8,
            "startAt": 0
        },
        "customfield_12311820": "0|z00hgg:",
        "customfield_12314139": null
    }
}