{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13312505",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505",
    "key": "ARROW-9186",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350591",
                "id": "12350591",
                "description": "",
                "name": "7.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-02-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=paleolimbot",
            "name": "paleolimbot",
            "key": "paleolimbot",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=paleolimbot&avatarId=47795",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=paleolimbot&avatarId=47795",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=paleolimbot&avatarId=47795",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=paleolimbot&avatarId=47795"
            },
            "displayName": "Dewey Dunnington",
            "active": true,
            "timeZone": "America/Halifax"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333008",
                "id": "12333008",
                "name": "R"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
            "name": "npr",
            "key": "npr",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Neal Richardson",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
            "name": "npr",
            "key": "npr",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Neal Richardson",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 16800,
            "total": 16800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 16800,
            "total": 16800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9186/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 28,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/700239",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot opened a new pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030\n\n\n   This PR makes it possible to read non-utf-8-encoded CSV files as was done in Python (ARROW-9106). I'm very open to (and would love suggestions on!) changes in the structure, naming, and implementation, since C++ isn't my strong suit. I opted for using R's C-level iconv because it made more sense to me than calling back to R (where I don't know how I'd handle partial multibyte characters at the end of a buffer).\r\n   \r\n   Reprex for testing:\r\n   \r\n   ``` r\r\n   library(arrow, warn.conflicts = FALSE)\r\n   \r\n   tf <- tempfile()\r\n   on.exit(unlink(tf))\r\n   \r\n   strings <- c(\"a\", \"\\u00e9\", \"\\U0001f4a9\", NA)\r\n   file_string <- paste0(\r\n     \"col1,col2\\n\",\r\n     paste(strings, 1:400, sep = \",\", collapse = \"\\n\")\r\n   )\r\n   \r\n   file_bytes_utf16 <- iconv(file_string, to = \"UTF-16LE\", toRaw = TRUE)[[1]]\r\n   \r\n   con <- file(tf, open = \"wb\")\r\n   writeBin(file_bytes_utf16, con)\r\n   close(con)\r\n   \r\n   fs <- LocalFileSystem$create()\r\n   reader <- CsvTableReader$create(\r\n     fs$OpenInputStream(tf),\r\n     read_options = CsvReadOptions$create(encoding = \"UTF-16LE\")\r\n   )\r\n   \r\n   tibble::as_tibble(reader$Read())\r\n   #> # A tibble: 400 \u00d7 2\r\n   #>    col1   col2\r\n   #>    <chr> <int>\r\n   #>  1 a         1\r\n   #>  2 \u00e9         2\r\n   #>  3 \ud83d\udca9        3\r\n   #>  4 NA        4\r\n   #>  5 a         5\r\n   #>  6 \u00e9         6\r\n   #>  7 \ud83d\udca9        7\r\n   #>  8 NA        8\r\n   #>  9 a         9\r\n   #> 10 \u00e9        10\r\n   #> # \u2026 with 390 more rows\r\n   ```\r\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-22T20:33:06.785+0000",
                    "updated": "2021-12-22T20:33:06.785+0000",
                    "started": "2021-12-22T20:33:06.785+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "700239",
                    "issueId": "13312505"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/700240",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030#issuecomment-999858022\n\n\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-22T20:33:29.669+0000",
                    "updated": "2021-12-22T20:33:29.669+0000",
                    "started": "2021-12-22T20:33:29.669+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "700240",
                    "issueId": "13312505"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/702948",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030#discussion_r777481461\n\n\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n\nReview comment:\n       Or perhaps you can wrap the `RIconvWrapper` in a `shared_ptr`...\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n+\n+    size_t out_bytes_left = dest->size();\n+    char* out_buf = (char*)dest->data();\n+    size_t out_bytes_used = 0;\n\nReview comment:\n       Please use `int64_t` everywhere for sizes, because it conforms to the style guide and also to avoid conversions between signed and unsigned.\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n+\n+    size_t out_bytes_left = dest->size();\n+    char* out_buf = (char*)dest->data();\n\nReview comment:\n       Please use C++-style casts, e.g. `reinterpret_cast<char*>(dest->mutable_data())`\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n+\n+    size_t out_bytes_left = dest->size();\n+    char* out_buf = (char*)dest->data();\n+    size_t out_bytes_used = 0;\n+\n+    size_t in_bytes_left;\n+    const char* in_buf;\n+    int64_t n_src_bytes_in_pending = 0;\n+\n+    // There may be a few leftover bytes from the last call to iconv. Process these first\n+    // using the internal buffer as the source. This may also result in a partial\n+    // character left over but will always get us into the src buffer.\n+    if (n_pending_ > 0) {\n+      // fill the pending_ buffer with characters and call iconv() once\n+      n_src_bytes_in_pending =\n+          std::min<int64_t>(sizeof(pending_) - n_pending_, src->size());\n+      memcpy(pending_ + n_pending_, src->data(), n_src_bytes_in_pending);\n+      in_buf = pending_;\n+      in_bytes_left = n_pending_ + n_src_bytes_in_pending;\n+\n+      iconv_.iconv(&in_buf, &in_bytes_left, &out_buf, &out_bytes_left);\n+\n+      int64_t chars_read_out = out_buf - ((char*)dest->data());\n+      out_bytes_used += chars_read_out;\n+\n+      int64_t chars_read_in = n_pending_ + n_src_bytes_in_pending - in_bytes_left;\n+      in_buf = (const char*)src->data() + chars_read_in - n_pending_;\n+      in_bytes_left = src->size() + n_pending_ - chars_read_in;\n+    } else {\n+      in_buf = (const char*)src->data();\n+      in_bytes_left = src->size();\n+    }\n+\n+    // UTF-8 has a maximum of 4 bytes per character, so it's OK if we have a few bytes\n+    // left after processing all of src. If we have more than this, it means the\n+    // output buffer wasn't big enough.\n+    while (in_bytes_left >= 4) {\n+      int64_t new_size = std::max<int64_t>(src->size(), dest->size() * 2);\n+      auto reserve_result = dest->Resize(new_size);\n+      if (!reserve_result.ok()) {\n+        return reserve_result;\n+      }\n+\n+      out_buf = (char*)dest->data() + out_bytes_used;\n+      out_bytes_left = dest->size() - out_bytes_used;\n+\n+      const char* in_buf_before = in_buf;\n+      char* out_buf_before = out_buf;\n+      iconv_.iconv(&in_buf, &in_bytes_left, &out_buf, &out_bytes_left);\n\nReview comment:\n       Do we never check the return value of calling `iconv`? It cannot fail?\n\n##########\nFile path: r/R/csv.R\n##########\n@@ -300,6 +300,11 @@ CsvTableReader$create <- function(file,\n                                   convert_options = CsvConvertOptions$create(),\n                                   ...) {\n   assert_is(file, \"InputStream\")\n+\n+  if (!identical(read_options$encoding, \"UTF-8\")) {\n\nReview comment:\n       Do we want to handle the various spellings of \"utf-8\" here? (lowercase, uppercase, with or without a hyphen)\n\n##########\nFile path: r/tests/testthat/test-csv.R\n##########\n@@ -290,6 +292,50 @@ test_that(\"more informative error when reading a CSV with headers and schema\", {\n   )\n })\n \n+test_that(\"CSV reader works on files with non-UTF-8 encoding\", {\n+  strings <- c(\"a\", \"\\u00e9\", \"\\U0001f4a9\")\n+  file_string <- paste0(\n+    \"col1,col2\\n\",\n+    paste(strings, 1:30, sep = \",\", collapse = \"\\n\")\n+  )\n+  file_bytes_utf16 <- iconv(\n+    file_string,\n+    from = Encoding(file_string),\n+    to = \"UTF-16LE\",\n+    toRaw = TRUE\n+  )[[1]]\n+\n+  tf <- tempfile()\n+  on.exit(unlink(tf))\n+  con <- file(tf, open = \"wb\")\n+  writeBin(file_bytes_utf16, con)\n+  close(con)\n+\n+  fs <- LocalFileSystem$create()\n+  reader <- CsvTableReader$create(\n+    fs$OpenInputStream(tf),\n+    read_options = CsvReadOptions$create(encoding = \"UTF-16LE\")\n+  )\n+\n+  table <- reader$Read()\n+\n+  # check that the CSV reader didn't create a binary column because of\n+  # invalid bytes\n+  expect_true(table$col1$type == string())\n+\n+  # check that the bytes are correct\n+  expect_identical(\n+    lapply(as.vector(table$col1$cast(binary())), as.raw),\n+    rep(\n+      list(as.raw(0x61), as.raw(c(0xc3, 0xa9)), as.raw(c(0xf0, 0x9f, 0x92, 0xa9))),\n+      10\n+    )\n+  )\n+\n+  # check that the strings are correct\n+  expect_identical(as.vector(table$col1), rep(strings, 10))\n+})\n+\n\nReview comment:\n       Can you add a check with a file that has invalid encoded contents?\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n+\n+    size_t out_bytes_left = dest->size();\n+    char* out_buf = (char*)dest->data();\n+    size_t out_bytes_used = 0;\n+\n+    size_t in_bytes_left;\n+    const char* in_buf;\n+    int64_t n_src_bytes_in_pending = 0;\n+\n+    // There may be a few leftover bytes from the last call to iconv. Process these first\n+    // using the internal buffer as the source. This may also result in a partial\n+    // character left over but will always get us into the src buffer.\n+    if (n_pending_ > 0) {\n+      // fill the pending_ buffer with characters and call iconv() once\n+      n_src_bytes_in_pending =\n+          std::min<int64_t>(sizeof(pending_) - n_pending_, src->size());\n+      memcpy(pending_ + n_pending_, src->data(), n_src_bytes_in_pending);\n+      in_buf = pending_;\n+      in_bytes_left = n_pending_ + n_src_bytes_in_pending;\n+\n+      iconv_.iconv(&in_buf, &in_bytes_left, &out_buf, &out_bytes_left);\n+\n+      int64_t chars_read_out = out_buf - ((char*)dest->data());\n+      out_bytes_used += chars_read_out;\n+\n+      int64_t chars_read_in = n_pending_ + n_src_bytes_in_pending - in_bytes_left;\n+      in_buf = (const char*)src->data() + chars_read_in - n_pending_;\n+      in_bytes_left = src->size() + n_pending_ - chars_read_in;\n+    } else {\n+      in_buf = (const char*)src->data();\n+      in_bytes_left = src->size();\n+    }\n+\n+    // UTF-8 has a maximum of 4 bytes per character, so it's OK if we have a few bytes\n+    // left after processing all of src. If we have more than this, it means the\n+    // output buffer wasn't big enough.\n+    while (in_bytes_left >= 4) {\n+      int64_t new_size = std::max<int64_t>(src->size(), dest->size() * 2);\n+      auto reserve_result = dest->Resize(new_size);\n+      if (!reserve_result.ok()) {\n+        return reserve_result;\n+      }\n+\n+      out_buf = (char*)dest->data() + out_bytes_used;\n+      out_bytes_left = dest->size() - out_bytes_used;\n+\n+      const char* in_buf_before = in_buf;\n+      char* out_buf_before = out_buf;\n+      iconv_.iconv(&in_buf, &in_bytes_left, &out_buf, &out_bytes_left);\n+      int64_t bytes_read_out = out_buf - out_buf_before;\n+      int64_t bytes_read_in = in_buf - in_buf_before;\n+\n+      if (bytes_read_out <= 0 || bytes_read_in <= 0) {\n\nReview comment:\n       Is it possible for these quantities to be negative?\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n+\n+    size_t out_bytes_left = dest->size();\n+    char* out_buf = (char*)dest->data();\n+    size_t out_bytes_used = 0;\n+\n+    size_t in_bytes_left;\n+    const char* in_buf;\n+    int64_t n_src_bytes_in_pending = 0;\n+\n+    // There may be a few leftover bytes from the last call to iconv. Process these first\n+    // using the internal buffer as the source. This may also result in a partial\n+    // character left over but will always get us into the src buffer.\n+    if (n_pending_ > 0) {\n+      // fill the pending_ buffer with characters and call iconv() once\n+      n_src_bytes_in_pending =\n+          std::min<int64_t>(sizeof(pending_) - n_pending_, src->size());\n+      memcpy(pending_ + n_pending_, src->data(), n_src_bytes_in_pending);\n+      in_buf = pending_;\n+      in_bytes_left = n_pending_ + n_src_bytes_in_pending;\n+\n+      iconv_.iconv(&in_buf, &in_bytes_left, &out_buf, &out_bytes_left);\n+\n+      int64_t chars_read_out = out_buf - ((char*)dest->data());\n+      out_bytes_used += chars_read_out;\n+\n+      int64_t chars_read_in = n_pending_ + n_src_bytes_in_pending - in_bytes_left;\n+      in_buf = (const char*)src->data() + chars_read_in - n_pending_;\n+      in_bytes_left = src->size() + n_pending_ - chars_read_in;\n+    } else {\n+      in_buf = (const char*)src->data();\n+      in_bytes_left = src->size();\n+    }\n+\n+    // UTF-8 has a maximum of 4 bytes per character, so it's OK if we have a few bytes\n+    // left after processing all of src. If we have more than this, it means the\n\nReview comment:\n       There could also be a few bytes left if `new_size` below was too small. Don't we want to consume as much as possible?\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n\nReview comment:\n       Pre-allocating `src->size()` bytes sounds like a better heuristic (or perhaps even a bit more).\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n\nReview comment:\n       Actually, it would perhaps be even better to use a `BufferBuilder` and call `Reserve` accordingly. It will handle overallocation for you.\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n+\n+    size_t out_bytes_left = dest->size();\n+    char* out_buf = (char*)dest->data();\n+    size_t out_bytes_used = 0;\n+\n+    size_t in_bytes_left;\n+    const char* in_buf;\n+    int64_t n_src_bytes_in_pending = 0;\n+\n+    // There may be a few leftover bytes from the last call to iconv. Process these first\n+    // using the internal buffer as the source. This may also result in a partial\n+    // character left over but will always get us into the src buffer.\n+    if (n_pending_ > 0) {\n+      // fill the pending_ buffer with characters and call iconv() once\n+      n_src_bytes_in_pending =\n+          std::min<int64_t>(sizeof(pending_) - n_pending_, src->size());\n+      memcpy(pending_ + n_pending_, src->data(), n_src_bytes_in_pending);\n+      in_buf = pending_;\n+      in_bytes_left = n_pending_ + n_src_bytes_in_pending;\n+\n+      iconv_.iconv(&in_buf, &in_bytes_left, &out_buf, &out_bytes_left);\n+\n+      int64_t chars_read_out = out_buf - ((char*)dest->data());\n+      out_bytes_used += chars_read_out;\n+\n+      int64_t chars_read_in = n_pending_ + n_src_bytes_in_pending - in_bytes_left;\n+      in_buf = (const char*)src->data() + chars_read_in - n_pending_;\n+      in_bytes_left = src->size() + n_pending_ - chars_read_in;\n+    } else {\n+      in_buf = (const char*)src->data();\n+      in_bytes_left = src->size();\n+    }\n+\n+    // UTF-8 has a maximum of 4 bytes per character, so it's OK if we have a few bytes\n+    // left after processing all of src. If we have more than this, it means the\n+    // output buffer wasn't big enough.\n+    while (in_bytes_left >= 4) {\n+      int64_t new_size = std::max<int64_t>(src->size(), dest->size() * 2);\n+      auto reserve_result = dest->Resize(new_size);\n+      if (!reserve_result.ok()) {\n+        return reserve_result;\n+      }\n+\n+      out_buf = (char*)dest->data() + out_bytes_used;\n+      out_bytes_left = dest->size() - out_bytes_used;\n+\n+      const char* in_buf_before = in_buf;\n+      char* out_buf_before = out_buf;\n+      iconv_.iconv(&in_buf, &in_bytes_left, &out_buf, &out_bytes_left);\n+      int64_t bytes_read_out = out_buf - out_buf_before;\n+      int64_t bytes_read_in = in_buf - in_buf_before;\n+\n+      if (bytes_read_out <= 0 || bytes_read_in <= 0) {\n+        // This should not happen, but if it does, we want to abort to make sure\n+        // the loop doesn't continue forever.\n+        return arrow::Status::IOError(\n+            \"Call to iconv() read or appended zero output bytes\");\n+      }\n+\n+      out_bytes_used += bytes_read_out;\n+    }\n+\n+    // Keep the leftover characters until the next call to the function\n+    n_pending_ = in_bytes_left;\n+    if (in_bytes_left > 0) {\n+      memcpy(pending_, in_buf, in_bytes_left);\n+    }\n+\n+    // Shrink the output buffer to only the size used\n+    auto resize_result = dest->Resize(out_bytes_used);\n\nReview comment:\n       Can use the `RETURN_NOT_OK` macro:\r\n   ```c++\r\n   RETURN_NOT_OK(dest->Resize(out_bytes_used));\r\n   ```\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n+\n+    size_t out_bytes_left = dest->size();\n+    char* out_buf = (char*)dest->data();\n+    size_t out_bytes_used = 0;\n+\n+    size_t in_bytes_left;\n+    const char* in_buf;\n+    int64_t n_src_bytes_in_pending = 0;\n+\n+    // There may be a few leftover bytes from the last call to iconv. Process these first\n+    // using the internal buffer as the source. This may also result in a partial\n+    // character left over but will always get us into the src buffer.\n+    if (n_pending_ > 0) {\n+      // fill the pending_ buffer with characters and call iconv() once\n+      n_src_bytes_in_pending =\n+          std::min<int64_t>(sizeof(pending_) - n_pending_, src->size());\n+      memcpy(pending_ + n_pending_, src->data(), n_src_bytes_in_pending);\n+      in_buf = pending_;\n+      in_bytes_left = n_pending_ + n_src_bytes_in_pending;\n+\n+      iconv_.iconv(&in_buf, &in_bytes_left, &out_buf, &out_bytes_left);\n+\n+      int64_t chars_read_out = out_buf - ((char*)dest->data());\n\nReview comment:\n       Please use C++-style casts, e.g. `reinterpret_cast<char*>(dest->mutable_data())`\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-03T13:51:20.537+0000",
                    "updated": "2022-01-03T13:51:20.537+0000",
                    "started": "2022-01-03T13:51:20.537+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "702948",
                    "issueId": "13312505"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/703073",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on a change in pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030#discussion_r777654597\n\n\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n+\n+    size_t out_bytes_left = dest->size();\n+    char* out_buf = (char*)dest->data();\n+    size_t out_bytes_used = 0;\n+\n+    size_t in_bytes_left;\n+    const char* in_buf;\n+    int64_t n_src_bytes_in_pending = 0;\n+\n+    // There may be a few leftover bytes from the last call to iconv. Process these first\n+    // using the internal buffer as the source. This may also result in a partial\n+    // character left over but will always get us into the src buffer.\n+    if (n_pending_ > 0) {\n+      // fill the pending_ buffer with characters and call iconv() once\n+      n_src_bytes_in_pending =\n+          std::min<int64_t>(sizeof(pending_) - n_pending_, src->size());\n+      memcpy(pending_ + n_pending_, src->data(), n_src_bytes_in_pending);\n+      in_buf = pending_;\n+      in_bytes_left = n_pending_ + n_src_bytes_in_pending;\n+\n+      iconv_.iconv(&in_buf, &in_bytes_left, &out_buf, &out_bytes_left);\n+\n+      int64_t chars_read_out = out_buf - ((char*)dest->data());\n+      out_bytes_used += chars_read_out;\n+\n+      int64_t chars_read_in = n_pending_ + n_src_bytes_in_pending - in_bytes_left;\n+      in_buf = (const char*)src->data() + chars_read_in - n_pending_;\n+      in_bytes_left = src->size() + n_pending_ - chars_read_in;\n+    } else {\n+      in_buf = (const char*)src->data();\n+      in_bytes_left = src->size();\n+    }\n+\n+    // UTF-8 has a maximum of 4 bytes per character, so it's OK if we have a few bytes\n+    // left after processing all of src. If we have more than this, it means the\n\nReview comment:\n       I'm trying to avoid too many calls to `iconv()` because every time it happens I have to check the number of bytes output and/or return value. The `TransformInputStream` always ends with an empty buffer as input to the transform function to flush internal buffers (according to the comments in the source), which is how `pending_` is used here. I think this is better than adding a third call to `iconv()` at the end (or perhaps there's a better option than all the ones I'm listing here). I've updated the comment to clarify my thinking here.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-03T19:07:58.180+0000",
                    "updated": "2022-01-03T19:07:58.180+0000",
                    "started": "2022-01-03T19:07:58.180+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "703073",
                    "issueId": "13312505"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/703080",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on a change in pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030#discussion_r777665555\n\n\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n+\n+    size_t out_bytes_left = dest->size();\n+    char* out_buf = (char*)dest->data();\n+    size_t out_bytes_used = 0;\n+\n+    size_t in_bytes_left;\n+    const char* in_buf;\n+    int64_t n_src_bytes_in_pending = 0;\n+\n+    // There may be a few leftover bytes from the last call to iconv. Process these first\n+    // using the internal buffer as the source. This may also result in a partial\n+    // character left over but will always get us into the src buffer.\n+    if (n_pending_ > 0) {\n+      // fill the pending_ buffer with characters and call iconv() once\n+      n_src_bytes_in_pending =\n+          std::min<int64_t>(sizeof(pending_) - n_pending_, src->size());\n+      memcpy(pending_ + n_pending_, src->data(), n_src_bytes_in_pending);\n+      in_buf = pending_;\n+      in_bytes_left = n_pending_ + n_src_bytes_in_pending;\n+\n+      iconv_.iconv(&in_buf, &in_bytes_left, &out_buf, &out_bytes_left);\n+\n+      int64_t chars_read_out = out_buf - ((char*)dest->data());\n+      out_bytes_used += chars_read_out;\n+\n+      int64_t chars_read_in = n_pending_ + n_src_bytes_in_pending - in_bytes_left;\n+      in_buf = (const char*)src->data() + chars_read_in - n_pending_;\n+      in_bytes_left = src->size() + n_pending_ - chars_read_in;\n+    } else {\n+      in_buf = (const char*)src->data();\n+      in_bytes_left = src->size();\n+    }\n+\n+    // UTF-8 has a maximum of 4 bytes per character, so it's OK if we have a few bytes\n+    // left after processing all of src. If we have more than this, it means the\n+    // output buffer wasn't big enough.\n+    while (in_bytes_left >= 4) {\n+      int64_t new_size = std::max<int64_t>(src->size(), dest->size() * 2);\n+      auto reserve_result = dest->Resize(new_size);\n+      if (!reserve_result.ok()) {\n+        return reserve_result;\n+      }\n+\n+      out_buf = (char*)dest->data() + out_bytes_used;\n+      out_bytes_left = dest->size() - out_bytes_used;\n+\n+      const char* in_buf_before = in_buf;\n+      char* out_buf_before = out_buf;\n+      iconv_.iconv(&in_buf, &in_bytes_left, &out_buf, &out_bytes_left);\n\nReview comment:\n       It often fails (invalid input, too few bytes in output, partial character at the end of the input buffer), so the return value isn't useful (because we need to do different things depending on which of these happened). I've added errors (when invalid input occurs) and comments to clarify these cases (and added a missing check for invalid input in the `pending_` buffer).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-03T19:32:59.996+0000",
                    "updated": "2022-01-03T19:32:59.996+0000",
                    "started": "2022-01-03T19:32:59.996+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "703080",
                    "issueId": "13312505"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/703082",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on a change in pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030#discussion_r777666240\n\n\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n+\n+    size_t out_bytes_left = dest->size();\n+    char* out_buf = (char*)dest->data();\n+    size_t out_bytes_used = 0;\n+\n+    size_t in_bytes_left;\n+    const char* in_buf;\n+    int64_t n_src_bytes_in_pending = 0;\n+\n+    // There may be a few leftover bytes from the last call to iconv. Process these first\n+    // using the internal buffer as the source. This may also result in a partial\n+    // character left over but will always get us into the src buffer.\n+    if (n_pending_ > 0) {\n+      // fill the pending_ buffer with characters and call iconv() once\n+      n_src_bytes_in_pending =\n+          std::min<int64_t>(sizeof(pending_) - n_pending_, src->size());\n+      memcpy(pending_ + n_pending_, src->data(), n_src_bytes_in_pending);\n+      in_buf = pending_;\n+      in_bytes_left = n_pending_ + n_src_bytes_in_pending;\n+\n+      iconv_.iconv(&in_buf, &in_bytes_left, &out_buf, &out_bytes_left);\n+\n+      int64_t chars_read_out = out_buf - ((char*)dest->data());\n+      out_bytes_used += chars_read_out;\n+\n+      int64_t chars_read_in = n_pending_ + n_src_bytes_in_pending - in_bytes_left;\n+      in_buf = (const char*)src->data() + chars_read_in - n_pending_;\n+      in_bytes_left = src->size() + n_pending_ - chars_read_in;\n+    } else {\n+      in_buf = (const char*)src->data();\n+      in_bytes_left = src->size();\n+    }\n+\n+    // UTF-8 has a maximum of 4 bytes per character, so it's OK if we have a few bytes\n+    // left after processing all of src. If we have more than this, it means the\n+    // output buffer wasn't big enough.\n+    while (in_bytes_left >= 4) {\n+      int64_t new_size = std::max<int64_t>(src->size(), dest->size() * 2);\n+      auto reserve_result = dest->Resize(new_size);\n+      if (!reserve_result.ok()) {\n+        return reserve_result;\n+      }\n+\n+      out_buf = (char*)dest->data() + out_bytes_used;\n+      out_bytes_left = dest->size() - out_bytes_used;\n+\n+      const char* in_buf_before = in_buf;\n+      char* out_buf_before = out_buf;\n+      iconv_.iconv(&in_buf, &in_bytes_left, &out_buf, &out_bytes_left);\n+      int64_t bytes_read_out = out_buf - out_buf_before;\n+      int64_t bytes_read_in = in_buf - in_buf_before;\n+\n+      if (bytes_read_out <= 0 || bytes_read_in <= 0) {\n\nReview comment:\n       They can't be! I updated this check as part of the below comment to detect if and how `iconv()` failed.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-03T19:34:35.111+0000",
                    "updated": "2022-01-03T19:34:35.111+0000",
                    "started": "2022-01-03T19:34:35.110+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "703082",
                    "issueId": "13312505"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/703084",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on a change in pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030#discussion_r777668121\n\n\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n+\n+    size_t out_bytes_left = dest->size();\n+    char* out_buf = (char*)dest->data();\n+    size_t out_bytes_used = 0;\n\nReview comment:\n       I moved the use of the types specific to `iconv()` into the `RIconvWrapper`, which doesn't minimize the conversions between signed and unsigned but does keep the iconv-specific stuff contained.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-03T19:39:01.351+0000",
                    "updated": "2022-01-03T19:39:01.351+0000",
                    "started": "2022-01-03T19:39:01.351+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "703084",
                    "issueId": "13312505"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/703085",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on a change in pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030#discussion_r777670303\n\n\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n\nReview comment:\n       I tried a `BufferBuilder` solution but I found it hard to make it readable without allocating a bunch of intermediary buffers and `Append()`ing them. I did completely rewrite the `Buffer`-based solution but if there's a pattern I'm missing I'm happy to rewrite again! I think the current version works for most input with a single allocation (but I will check more thoroughly).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-03T19:44:09.862+0000",
                    "updated": "2022-01-03T19:44:09.862+0000",
                    "started": "2022-01-03T19:44:09.862+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "703085",
                    "issueId": "13312505"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/703086",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030#discussion_r777671440\n\n\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n\nReview comment:\n       I'm a bit surprised, because you could just use the `Reserve`, `mutable_data` and `UnsafeAdvance` methods on `BufferBuilder`: basically, rely on the (re)allocation facilities but do the buffer filling yourself.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-03T19:46:55.153+0000",
                    "updated": "2022-01-03T19:46:55.153+0000",
                    "started": "2022-01-03T19:46:55.153+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "703086",
                    "issueId": "13312505"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/703088",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030#discussion_r777672319\n\n\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +181,166 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const uint8_t** inbuf, int64_t* inbytesleft, uint8_t** outbuf,\n+               int64_t* outbytesleft) {\n+    // This iconv signature uses the types that Arrow C++ uses to minimize\n+    // deviations from the style guide; however, iconv() uses pointers\n+    // to char* and size_t instead of uint8_t and int64_t.\n+    size_t inbytesleft_size_t = *inbytesleft;\n+    size_t outbytesleft_size_t = *outbytesleft;\n+    const char** inbuf_const_char = reinterpret_cast<const char**>(inbuf);\n+    char** outbuf_char = reinterpret_cast<char**>(outbuf);\n+\n+    size_t return_value = Riconv(handle_, inbuf_const_char, &inbytesleft_size_t,\n+                                 outbuf_char, &outbytesleft_size_t);\n+\n+    *inbytesleft = inbytesleft_size_t;\n+    *outbytesleft = outbytesleft_size_t;\n+    return return_value;\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    int64_t initial_size = std::min<int64_t>((src->size() + 8 * 1.2), 32);\n\nReview comment:\n       You probably want `max` not `min`? Also, `8 * 1.2` is a constant :-)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-03T19:49:01.228+0000",
                    "updated": "2022-01-03T19:49:01.228+0000",
                    "started": "2022-01-03T19:49:01.228+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "703088",
                    "issueId": "13312505"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/703089",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030#discussion_r777673010\n\n\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +181,164 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const uint8_t** inbuf, int64_t* inbytesleft, uint8_t** outbuf,\n+               int64_t* outbytesleft) {\n+    // This iconv signature uses the types that Arrow C++ uses to minimize\n+    // deviations from the style guide; however, iconv() uses pointers\n+    // to char* and size_t instead of uint8_t and int64_t.\n+    size_t inbytesleft_size_t = *inbytesleft;\n+    size_t outbytesleft_size_t = *outbytesleft;\n+    const char** inbuf_const_char = reinterpret_cast<const char**>(inbuf);\n+    char** outbuf_char = reinterpret_cast<char**>(outbuf);\n+\n+    size_t return_value = Riconv(handle_, inbuf_const_char, &inbytesleft_size_t,\n+                                 outbuf_char, &outbytesleft_size_t);\n+\n+    *inbytesleft = inbytesleft_size_t;\n+    *outbytesleft = outbytesleft_size_t;\n+    return return_value;\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from),\n+        iconv_(std::make_shared<RIconvWrapper>(\"UTF-8\", from)),\n+        n_pending_(0) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    int64_t initial_size = std::min<int64_t>((src->size() + 8 * 1.2), 32);\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(initial_size));\n+\n+    int64_t out_bytes_left = dest->size();\n+    uint8_t* out_buf = dest->mutable_data();\n+    int64_t out_bytes_used = 0;\n+\n+    int64_t in_bytes_left;\n+    const uint8_t* in_buf;\n+    int64_t n_src_bytes_in_pending = 0;\n+\n+    // There may be a few left over bytes from the last call to iconv.\n+    // Process these first using the internal buffer (with as many bytes\n+    // as possible added from src) as the source. This may also result in\n+    // a partial character left over but will always get us into the src buffer.\n+    if (n_pending_ > 0) {\n+      n_src_bytes_in_pending =\n+          std::min<int64_t>(sizeof(pending_) - n_pending_, src->size());\n+      memcpy(pending_ + n_pending_, src->data(), n_src_bytes_in_pending);\n+      in_buf = pending_;\n+      in_bytes_left = n_pending_ + n_src_bytes_in_pending;\n+\n+      iconv_->iconv(&in_buf, &in_bytes_left, &out_buf, &out_bytes_left);\n+\n+      // Rather than check the error return code (which is often returned\n+      // in the case of a partial character at the end of the pending_\n+      // buffer), check that we have read enough characters to get into\n+      // `src` (after which the loop below will error for invalid characters).\n+      int64_t bytes_read_in = in_buf - pending_;\n+      if (bytes_read_in < n_pending_) {\n+        return StatusInvalidInput();\n+      }\n+\n+      int64_t bytes_read_out = out_buf - dest->data();\n+      out_bytes_used += bytes_read_out;\n+\n+      int64_t chars_read_in = n_pending_ + n_src_bytes_in_pending - in_bytes_left;\n+      in_buf = src->data() + chars_read_in - n_pending_;\n+      in_bytes_left = src->size() + n_pending_ - chars_read_in;\n+    } else {\n+      in_buf = src->data();\n+      in_bytes_left = src->size();\n+    }\n+\n+    // in_bytes_left >= 4 assumes a maximum of 4 bytes per character in the\n+    // input (the maximum for UTF-8, UTF-16, and UTF-32). If we\n+    // have more than this, it means the output buffer wasn't big enough\n+    // and the next iteration of the loop will try iconv() again with a\n+    // bigger buffer. When we have less than 4 bytes left, the bytes\n+    // will be copied to pending_ and processed in the next call (the\n+    // TransformInputStream always finishes with a src that is 0 bytes\n+    // for this purpose.)\n+    while (in_bytes_left >= 4) {\n+      // When this is true, we will (almost) always need a new buffer\n+      if (out_bytes_left < in_bytes_left) {\n+        RETURN_NOT_OK(dest->Resize(dest->size() * 1.2));\n+        out_buf = dest->mutable_data() + out_bytes_used;\n+        out_bytes_left = dest->size() - out_bytes_used;\n+      }\n+\n+      // iconv() can return an error code ((size_t) -1) but it's not\n+      // useful as it can occur because of invalid input, because\n+      // of a full output buffer, or because there are partial characters\n+      // at the end of the input buffer that were not completely decoded.\n+      // We handle each of these cases separately based on the number of bytes\n+      // read or written.\n+      uint8_t* out_buf_before = out_buf;\n+\n+      iconv_->iconv(&in_buf, &in_bytes_left, &out_buf, &out_bytes_left);\n+\n+      int64_t bytes_read_out = out_buf - out_buf_before;\n+\n+      if (bytes_read_out == 0) {\n+        return StatusInvalidInput();\n+      }\n+\n+      out_bytes_used += bytes_read_out;\n+    }\n+\n+    // Keep the leftover characters until the next call to the function\n+    n_pending_ = in_bytes_left;\n+    if (in_bytes_left > 0) {\n+      memcpy(pending_, in_buf, in_bytes_left);\n+    }\n+\n+    // Shrink the output buffer to only the size used\n+    RETURN_NOT_OK(dest->Resize(out_bytes_used, false));\n+    return std::move(dest);\n+  }\n+\n+ protected:\n+  std::string from_;\n+  std::shared_ptr<RIconvWrapper> iconv_;\n+  uint8_t pending_[8];\n+  int64_t n_pending_;\n+\n+  arrow::Status StatusInvalidInput() {\n+    std::stringstream stream;\n+    stream << \"Encountered invalid input bytes \";\n+    stream << \"(input encoding was '\" << from_ << \"')\";\n+    return arrow::Status::IOError(stream.str());\n\nReview comment:\n       Nit: you don't need to use `StringStream` explicit, the Status factory methods will do it for you, e.g.:\r\n   ```c++\r\n   return Status::IOError(\r\n       \"Encountered invalid input bytes \",\r\n       \"(input encoding was '\", from_, \"')\";\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-03T19:50:34.356+0000",
                    "updated": "2022-01-03T19:50:34.356+0000",
                    "started": "2022-01-03T19:50:34.355+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "703089",
                    "issueId": "13312505"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/703090",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030#discussion_r777673125\n\n\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +181,164 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const uint8_t** inbuf, int64_t* inbytesleft, uint8_t** outbuf,\n+               int64_t* outbytesleft) {\n+    // This iconv signature uses the types that Arrow C++ uses to minimize\n+    // deviations from the style guide; however, iconv() uses pointers\n+    // to char* and size_t instead of uint8_t and int64_t.\n+    size_t inbytesleft_size_t = *inbytesleft;\n+    size_t outbytesleft_size_t = *outbytesleft;\n+    const char** inbuf_const_char = reinterpret_cast<const char**>(inbuf);\n+    char** outbuf_char = reinterpret_cast<char**>(outbuf);\n+\n+    size_t return_value = Riconv(handle_, inbuf_const_char, &inbytesleft_size_t,\n+                                 outbuf_char, &outbytesleft_size_t);\n+\n+    *inbytesleft = inbytesleft_size_t;\n+    *outbytesleft = outbytesleft_size_t;\n+    return return_value;\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from),\n+        iconv_(std::make_shared<RIconvWrapper>(\"UTF-8\", from)),\n+        n_pending_(0) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    int64_t initial_size = std::min<int64_t>((src->size() + 8 * 1.2), 32);\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(initial_size));\n+\n+    int64_t out_bytes_left = dest->size();\n+    uint8_t* out_buf = dest->mutable_data();\n+    int64_t out_bytes_used = 0;\n+\n+    int64_t in_bytes_left;\n+    const uint8_t* in_buf;\n+    int64_t n_src_bytes_in_pending = 0;\n+\n+    // There may be a few left over bytes from the last call to iconv.\n+    // Process these first using the internal buffer (with as many bytes\n+    // as possible added from src) as the source. This may also result in\n+    // a partial character left over but will always get us into the src buffer.\n+    if (n_pending_ > 0) {\n+      n_src_bytes_in_pending =\n+          std::min<int64_t>(sizeof(pending_) - n_pending_, src->size());\n+      memcpy(pending_ + n_pending_, src->data(), n_src_bytes_in_pending);\n+      in_buf = pending_;\n+      in_bytes_left = n_pending_ + n_src_bytes_in_pending;\n+\n+      iconv_->iconv(&in_buf, &in_bytes_left, &out_buf, &out_bytes_left);\n+\n+      // Rather than check the error return code (which is often returned\n+      // in the case of a partial character at the end of the pending_\n+      // buffer), check that we have read enough characters to get into\n+      // `src` (after which the loop below will error for invalid characters).\n+      int64_t bytes_read_in = in_buf - pending_;\n+      if (bytes_read_in < n_pending_) {\n+        return StatusInvalidInput();\n+      }\n+\n+      int64_t bytes_read_out = out_buf - dest->data();\n+      out_bytes_used += bytes_read_out;\n+\n+      int64_t chars_read_in = n_pending_ + n_src_bytes_in_pending - in_bytes_left;\n+      in_buf = src->data() + chars_read_in - n_pending_;\n+      in_bytes_left = src->size() + n_pending_ - chars_read_in;\n+    } else {\n+      in_buf = src->data();\n+      in_bytes_left = src->size();\n+    }\n+\n+    // in_bytes_left >= 4 assumes a maximum of 4 bytes per character in the\n+    // input (the maximum for UTF-8, UTF-16, and UTF-32). If we\n+    // have more than this, it means the output buffer wasn't big enough\n+    // and the next iteration of the loop will try iconv() again with a\n+    // bigger buffer. When we have less than 4 bytes left, the bytes\n+    // will be copied to pending_ and processed in the next call (the\n+    // TransformInputStream always finishes with a src that is 0 bytes\n+    // for this purpose.)\n+    while (in_bytes_left >= 4) {\n+      // When this is true, we will (almost) always need a new buffer\n+      if (out_bytes_left < in_bytes_left) {\n+        RETURN_NOT_OK(dest->Resize(dest->size() * 1.2));\n+        out_buf = dest->mutable_data() + out_bytes_used;\n+        out_bytes_left = dest->size() - out_bytes_used;\n+      }\n+\n+      // iconv() can return an error code ((size_t) -1) but it's not\n+      // useful as it can occur because of invalid input, because\n+      // of a full output buffer, or because there are partial characters\n+      // at the end of the input buffer that were not completely decoded.\n+      // We handle each of these cases separately based on the number of bytes\n+      // read or written.\n+      uint8_t* out_buf_before = out_buf;\n+\n+      iconv_->iconv(&in_buf, &in_bytes_left, &out_buf, &out_bytes_left);\n+\n+      int64_t bytes_read_out = out_buf - out_buf_before;\n+\n+      if (bytes_read_out == 0) {\n+        return StatusInvalidInput();\n+      }\n+\n+      out_bytes_used += bytes_read_out;\n+    }\n+\n+    // Keep the leftover characters until the next call to the function\n+    n_pending_ = in_bytes_left;\n+    if (in_bytes_left > 0) {\n+      memcpy(pending_, in_buf, in_bytes_left);\n+    }\n+\n+    // Shrink the output buffer to only the size used\n+    RETURN_NOT_OK(dest->Resize(out_bytes_used, false));\n+    return std::move(dest);\n+  }\n+\n+ protected:\n+  std::string from_;\n+  std::shared_ptr<RIconvWrapper> iconv_;\n+  uint8_t pending_[8];\n+  int64_t n_pending_;\n+\n+  arrow::Status StatusInvalidInput() {\n+    std::stringstream stream;\n+    stream << \"Encountered invalid input bytes \";\n+    stream << \"(input encoding was '\" << from_ << \"')\";\n+    return arrow::Status::IOError(stream.str());\n\nReview comment:\n       Also, this would be better as `Status::Invalid`, not `Status::IOError`\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-03T19:50:59.169+0000",
                    "updated": "2022-01-03T19:50:59.169+0000",
                    "started": "2022-01-03T19:50:59.168+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "703090",
                    "issueId": "13312505"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/703092",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030#discussion_r777674074\n\n\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n+\n+    size_t out_bytes_left = dest->size();\n+    char* out_buf = (char*)dest->data();\n+    size_t out_bytes_used = 0;\n+\n+    size_t in_bytes_left;\n+    const char* in_buf;\n+    int64_t n_src_bytes_in_pending = 0;\n+\n+    // There may be a few leftover bytes from the last call to iconv. Process these first\n+    // using the internal buffer as the source. This may also result in a partial\n+    // character left over but will always get us into the src buffer.\n+    if (n_pending_ > 0) {\n+      // fill the pending_ buffer with characters and call iconv() once\n+      n_src_bytes_in_pending =\n+          std::min<int64_t>(sizeof(pending_) - n_pending_, src->size());\n+      memcpy(pending_ + n_pending_, src->data(), n_src_bytes_in_pending);\n+      in_buf = pending_;\n+      in_bytes_left = n_pending_ + n_src_bytes_in_pending;\n+\n+      iconv_.iconv(&in_buf, &in_bytes_left, &out_buf, &out_bytes_left);\n+\n+      int64_t chars_read_out = out_buf - ((char*)dest->data());\n+      out_bytes_used += chars_read_out;\n+\n+      int64_t chars_read_in = n_pending_ + n_src_bytes_in_pending - in_bytes_left;\n+      in_buf = (const char*)src->data() + chars_read_in - n_pending_;\n+      in_bytes_left = src->size() + n_pending_ - chars_read_in;\n+    } else {\n+      in_buf = (const char*)src->data();\n+      in_bytes_left = src->size();\n+    }\n+\n+    // UTF-8 has a maximum of 4 bytes per character, so it's OK if we have a few bytes\n+    // left after processing all of src. If we have more than this, it means the\n\nReview comment:\n       Why would you need a third call to `iconv()`? This could just be part of the loop.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-03T19:53:15.355+0000",
                    "updated": "2022-01-03T19:53:15.355+0000",
                    "started": "2022-01-03T19:53:15.354+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "703092",
                    "issueId": "13312505"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/703096",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on a change in pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030#discussion_r777678382\n\n\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +181,166 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const uint8_t** inbuf, int64_t* inbytesleft, uint8_t** outbuf,\n+               int64_t* outbytesleft) {\n+    // This iconv signature uses the types that Arrow C++ uses to minimize\n+    // deviations from the style guide; however, iconv() uses pointers\n+    // to char* and size_t instead of uint8_t and int64_t.\n+    size_t inbytesleft_size_t = *inbytesleft;\n+    size_t outbytesleft_size_t = *outbytesleft;\n+    const char** inbuf_const_char = reinterpret_cast<const char**>(inbuf);\n+    char** outbuf_char = reinterpret_cast<char**>(outbuf);\n+\n+    size_t return_value = Riconv(handle_, inbuf_const_char, &inbytesleft_size_t,\n+                                 outbuf_char, &outbytesleft_size_t);\n+\n+    *inbytesleft = inbytesleft_size_t;\n+    *outbytesleft = outbytesleft_size_t;\n+    return return_value;\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    int64_t initial_size = std::min<int64_t>((src->size() + 8 * 1.2), 32);\n\nReview comment:\n       ...and was also not what I intended!!\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-03T20:03:05.525+0000",
                    "updated": "2022-01-03T20:03:05.525+0000",
                    "started": "2022-01-03T20:03:05.525+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "703096",
                    "issueId": "13312505"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/703522",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on a change in pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030#discussion_r778346765\n\n\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n+\n+    size_t out_bytes_left = dest->size();\n+    char* out_buf = (char*)dest->data();\n+    size_t out_bytes_used = 0;\n+\n+    size_t in_bytes_left;\n+    const char* in_buf;\n+    int64_t n_src_bytes_in_pending = 0;\n+\n+    // There may be a few leftover bytes from the last call to iconv. Process these first\n+    // using the internal buffer as the source. This may also result in a partial\n+    // character left over but will always get us into the src buffer.\n+    if (n_pending_ > 0) {\n+      // fill the pending_ buffer with characters and call iconv() once\n+      n_src_bytes_in_pending =\n+          std::min<int64_t>(sizeof(pending_) - n_pending_, src->size());\n+      memcpy(pending_ + n_pending_, src->data(), n_src_bytes_in_pending);\n+      in_buf = pending_;\n+      in_bytes_left = n_pending_ + n_src_bytes_in_pending;\n+\n+      iconv_.iconv(&in_buf, &in_bytes_left, &out_buf, &out_bytes_left);\n+\n+      int64_t chars_read_out = out_buf - ((char*)dest->data());\n+      out_bytes_used += chars_read_out;\n+\n+      int64_t chars_read_in = n_pending_ + n_src_bytes_in_pending - in_bytes_left;\n+      in_buf = (const char*)src->data() + chars_read_in - n_pending_;\n+      in_bytes_left = src->size() + n_pending_ - chars_read_in;\n+    } else {\n+      in_buf = (const char*)src->data();\n+      in_bytes_left = src->size();\n+    }\n+\n+    // UTF-8 has a maximum of 4 bytes per character, so it's OK if we have a few bytes\n+    // left after processing all of src. If we have more than this, it means the\n\nReview comment:\n       Right! I changed this to consume as much as possible, only breaking for partial characters.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-04T19:50:31.212+0000",
                    "updated": "2022-01-04T19:50:31.212+0000",
                    "started": "2022-01-04T19:50:31.211+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "703522",
                    "issueId": "13312505"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/703528",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on a change in pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030#discussion_r778353013\n\n\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n\nReview comment:\n       I'm totally game to use it, but in the current version I only interact with the buffer object 3 times:\r\n   \r\n   ```cpp\r\n   ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(initial_size));\r\n   ```\r\n   \r\n   ```cpp\r\n   if (out_bytes_left < in_bytes_left) {\r\n     RETURN_NOT_OK(dest->Resize(dest->size() * 1.2));\r\n     out_buf = dest->mutable_data() + out_bytes_used;\r\n     out_bytes_left = dest->size() - out_bytes_used;\r\n   }\r\n   ```\r\n   \r\n   ```cpp\r\n   RETURN_NOT_OK(dest->Resize(out_bytes_used, false));\r\n   ```\r\n   \r\n   I found that with the `BufferBuiler` I needed an extra line for `Finish()` and the rest was almost the same (`Reserve()` instead of `Resize()`). Is there anything that I'm missing that would be safer or more readable using the `BufferBuilder`?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-04T20:01:32.640+0000",
                    "updated": "2022-01-04T20:01:32.640+0000",
                    "started": "2022-01-04T20:01:32.640+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "703528",
                    "issueId": "13312505"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/703933",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030#discussion_r778813936\n\n\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n\nReview comment:\n       I think the main point is to avoid reinventing the overallocation logic. I pushed a commit that uses `BufferBuilder`, feel free to keep it or not depending on how you feel about it.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-05T13:23:43.045+0000",
                    "updated": "2022-01-05T13:23:43.045+0000",
                    "started": "2022-01-05T13:23:43.044+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "703933",
                    "issueId": "13312505"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/703993",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on a change in pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030#discussion_r778851474\n\n\n\n##########\nFile path: r/src/io.cpp\n##########\n@@ -178,4 +180,134 @@ void io___BufferOutputStream__Write(\n   StopIfNotOk(stream->Write(RAW(bytes), bytes.size()));\n }\n \n+// TransformInputStream::TransformFunc wrapper\n+\n+class RIconvWrapper {\n+ public:\n+  RIconvWrapper(std::string to, std::string from)\n+      : handle_(Riconv_open(to.c_str(), from.c_str())) {\n+    if (handle_ == ((void*)-1)) {\n+      cpp11::stop(\"Can't convert encoding from '%s' to '%s'\", from.c_str(), to.c_str());\n+    }\n+  }\n+\n+  size_t iconv(const char** inbuf, size_t* inbytesleft, char** outbuf,\n+               size_t* outbytesleft) {\n+    return Riconv(handle_, inbuf, inbytesleft, outbuf, outbytesleft);\n+  }\n+\n+  ~RIconvWrapper() {\n+    if (handle_ != ((void*)-1)) {\n+      Riconv_close(handle_);\n+    }\n+  }\n+\n+ protected:\n+  void* handle_;\n+};\n+\n+struct ReencodeUTF8TransformFunctionWrapper {\n+  explicit ReencodeUTF8TransformFunctionWrapper(std::string from)\n+      : from_(from), iconv_(\"UTF-8\", from), n_pending_(0) {}\n+\n+  // This may get copied and we need a fresh RIconvWrapper for each copy.\n+  ReencodeUTF8TransformFunctionWrapper(const ReencodeUTF8TransformFunctionWrapper& ref)\n+      : ReencodeUTF8TransformFunctionWrapper(ref.from_) {}\n+\n+  arrow::Result<std::shared_ptr<arrow::Buffer>> operator()(\n+      const std::shared_ptr<arrow::Buffer>& src) {\n+    ARROW_ASSIGN_OR_RAISE(auto dest, arrow::AllocateResizableBuffer(32));\n\nReview comment:\n       I see! It's definitely better. It also takes care of some of the bookkeeping that was previously duplicated.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-05T14:17:46.192+0000",
                    "updated": "2022-01-05T14:17:46.192+0000",
                    "started": "2022-01-05T14:17:46.191+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "703993",
                    "issueId": "13312505"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/704183",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jonkeane commented on a change in pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030#discussion_r779103165\n\n\n\n##########\nFile path: r/tests/testthat/test-csv.R\n##########\n@@ -290,6 +292,50 @@ test_that(\"more informative error when reading a CSV with headers and schema\", {\n   )\n })\n \n+test_that(\"CSV reader works on files with non-UTF-8 encoding\", {\n+  strings <- c(\"a\", \"\\u00e9\", \"\\U0001f4a9\")\n+  file_string <- paste0(\n+    \"col1,col2\\n\",\n+    paste(strings, 1:30, sep = \",\", collapse = \"\\n\")\n+  )\n+  file_bytes_utf16 <- iconv(\n+    file_string,\n+    from = Encoding(file_string),\n+    to = \"UTF-16LE\",\n+    toRaw = TRUE\n+  )[[1]]\n+\n+  tf <- tempfile()\n+  on.exit(unlink(tf))\n+  con <- file(tf, open = \"wb\")\n+  writeBin(file_bytes_utf16, con)\n+  close(con)\n+\n+  fs <- LocalFileSystem$create()\n+  reader <- CsvTableReader$create(\n+    fs$OpenInputStream(tf),\n+    read_options = CsvReadOptions$create(encoding = \"UTF-16LE\")\n+  )\n\nReview comment:\n       What happens if someone calls this without specifying the encoding?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-05T20:06:03.635+0000",
                    "updated": "2022-01-05T20:06:03.635+0000",
                    "started": "2022-01-05T20:06:03.635+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "704183",
                    "issueId": "13312505"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/worklog/704214",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paleolimbot commented on pull request #12030:\nURL: https://github.com/apache/arrow/pull/12030#issuecomment-1006058148\n\n\n   A reprex that might help with testing (since my example is a little dinky)...the probable use case is reading encodings like latin1, but I also did check with a bunch of random latin1 characters:\r\n   \r\n   <details>\r\n   \r\n   ``` r\r\n   # generate a data frame with funky characters\r\n   latin1_chars <- iconv(\r\n     # exclude the comma and control characters\r\n     list(as.raw(setdiff(c(38:126, 161:255), 44))),\r\n     \"latin1\", \"UTF-8\"\r\n   )\r\n   \r\n   make_text_col <- function(chars, \r\n                             chars_per_item_min = 1, chars_per_item_max = 20,\r\n                             n_items = 20) {\r\n     choices <- unlist(strsplit(chars, \"\"))\r\n     text_col <- character(n_items)\r\n     for (i in seq_along(text_col)) {\r\n       text_col[i] <- paste0(\r\n         sample(\r\n           choices, \r\n           round(runif(1, chars_per_item_min, chars_per_item_max)), \r\n           replace = TRUE\r\n         ),\r\n         collapse = \"\"\r\n       )\r\n     }\r\n     text_col\r\n   }\r\n   \r\n   set.seed(1843)\r\n   n_items <- 1e6\r\n   \r\n   df_latin1 <- data.frame(\r\n     n = 1:n_items,\r\n     latin1_chars = make_text_col(latin1_chars, n_items = n_items)\r\n   )\r\n   \r\n   # now check the CSV reader\r\n   library(arrow, warn.conflicts = FALSE)\r\n   \r\n   # make some files\r\n   tf_latin1_utf8 <- tempfile()\r\n   tf_latin1_latin1 <- tempfile()\r\n   \r\n   readr::write_csv(df_latin1, tf_latin1_utf8)\r\n   readr::write_file(\r\n     iconv(list(readr::read_file_raw(tf_latin1_utf8)), \"UTF-8\", \"latin1\", toRaw = TRUE)[[1]],\r\n     tf_latin1_latin1\r\n   )\r\n   \r\n   \r\n   fs <- LocalFileSystem$create()\r\n   reader <- CsvTableReader$create(\r\n     fs$OpenInputStream(tf_latin1_utf8),\r\n     read_options = CsvReadOptions$create(encoding = \"UTF-8\")\r\n   )\r\n   \r\n   df_latin1_from_utf8 <- tibble::as_tibble(reader$Read())\r\n   \r\n   reader <- CsvTableReader$create(\r\n     fs$OpenInputStream(tf_latin1_latin1),\r\n     read_options = CsvReadOptions$create(encoding = \"latin1\")\r\n   )\r\n   df_latin1_from_latin1 <- tibble::as_tibble(reader$Read())\r\n   \r\n   identical(df_latin1_from_utf8, df_latin1_from_latin1)\r\n   #> [1] TRUE\r\n   ```\r\n   \r\n   <sup>Created on 2022-01-05 by the [reprex package](https://reprex.tidyverse.org) (v2.0.1)</sup>\r\n   \r\n   </details>\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-05T20:35:22.186+0000",
                    "updated": "2022-01-05T20:35:22.186+0000",
                    "started": "2022-01-05T20:35:22.185+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "704214",
                    "issueId": "13312505"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 16800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@24fc8344[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@791b67e1[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@eba82b0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@2c3cc8e9[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@658e2c45[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@4d4e260e[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@173b9215[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@5d0a6b9b[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@49f2887b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@7530a91d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3e502694[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@3008c476[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 16800,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Jan 10 20:31:21 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-01-10T20:31:21.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9186/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2020-06-19T15:36:23.000+0000",
        "updated": "2022-01-12T06:19:03.000+0000",
        "timeoriginalestimate": null,
        "description": "ARROW-9106 did this for Python and we should have the same in R",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 16800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[R] Allow specifying CSV file encoding",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/comment/17368269",
                    "id": "17368269",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "cc @thisisnic [~jonkeane]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-06-23T15:17:54.988+0000",
                    "updated": "2021-06-23T15:17:54.988+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/comment/17461663",
                    "id": "17461663",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=paleolimbot",
                        "name": "paleolimbot",
                        "key": "paleolimbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=paleolimbot&avatarId=47795",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=paleolimbot&avatarId=47795",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=paleolimbot&avatarId=47795",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=paleolimbot&avatarId=47795"
                        },
                        "displayName": "Dewey Dunnington",
                        "active": true,
                        "timeZone": "America/Halifax"
                    },
                    "body": "Doesn't look like it's implemented as part of the [C++ ReadOptions|https://github.com/apache/arrow/blob/master/cpp/src/arrow/csv/options.h#L138-L171] but that Python uses the ReadOptions class to carry this information (with a Python-only {{.encoding}} attribute). We could/should do this, too.\r\n\r\nIt looks from the Python PR that we'd have to provide our own {{iconv}} and wrap a {{TransformInputStream}}. R provides an {{iconv}} at the C level, so we shouldn't need to call into R for this. I [wrote about this a while ago](https://fishandwhistle.net/post/2021/using-rs-cross-platform-iconv-wrapper-from-cpp11/) and I think there's another example in either readr or vroom where this bit of code is wrapped up in a helper class.\r\n\r\nWhere Python creates its wrapper around {{TransformInputStream}}: https://github.com/apache/arrow/blob/master/cpp/src/arrow/python/io.cc#L340-L371\r\n\r\nWhere R creates the {{CsvReadOptions}}: https://github.com/apache/arrow/blob/master/r/R/csv.R#L402-L416",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=paleolimbot",
                        "name": "paleolimbot",
                        "key": "paleolimbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=paleolimbot&avatarId=47795",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=paleolimbot&avatarId=47795",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=paleolimbot&avatarId=47795",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=paleolimbot&avatarId=47795"
                        },
                        "displayName": "Dewey Dunnington",
                        "active": true,
                        "timeZone": "America/Halifax"
                    },
                    "created": "2021-12-17T20:48:12.128+0000",
                    "updated": "2021-12-17T20:48:12.128+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/comment/17461670",
                    "id": "17461670",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=paleolimbot",
                        "name": "paleolimbot",
                        "key": "paleolimbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=paleolimbot&avatarId=47795",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=paleolimbot&avatarId=47795",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=paleolimbot&avatarId=47795",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=paleolimbot&avatarId=47795"
                        },
                        "displayName": "Dewey Dunnington",
                        "active": true,
                        "timeZone": "America/Halifax"
                    },
                    "body": "Reprex:\r\n\r\n{code:R}\r\nlibrary(arrow, warn.conflicts = FALSE)\r\n\r\nstring <- \"province_name\\nQu\u00e9bec\"\r\nbytes_utf8 <- iconv(string, to = \"UTF-8\", toRaw = TRUE)[[1]]\r\nbytes_windows1252 <- iconv(string, to = \"windows-1252\", toRaw = TRUE)[[1]]\r\n\r\ntemp_utf8 <- tempfile()\r\ntemp_windows1252 <- tempfile()\r\n\r\ncon <- file(temp_utf8, open = \"wb\")\r\nwriteBin(bytes_utf8, con)\r\nclose(con)\r\n\r\ncon <- file(temp_windows1252, open = \"wb\")\r\nwriteBin(bytes_windows1252, con)\r\nclose(con)\r\n\r\nreadr::read_csv(\r\n  temp_utf8,\r\n  locale = readr::locale(encoding = \"UTF-8\"),\r\n  show_col_types = FALSE\r\n)\r\n#> # A tibble: 1 \u00d7 1\r\n#>   province_name\r\n#>   <chr>        \r\n#> 1 Qu\u00e9bec\r\n\r\nreadr::read_csv(\r\n  temp_windows1252,\r\n  locale = readr::locale(encoding = \"windows-1252\"),\r\n  show_col_types = FALSE\r\n)\r\n#> # A tibble: 1 \u00d7 1\r\n#>   province_name\r\n#>   <chr>        \r\n#> 1 Qu\u00e9bec\r\n\r\nread_csv_arrow(temp_utf8)\r\n#> # A tibble: 1 \u00d7 1\r\n#>   province_name\r\n#>   <chr>        \r\n#> 1 Qu\u00e9bec\r\nread_csv_arrow(temp_windows1252)\r\n#> # A tibble: 1 \u00d7 1\r\n#>            province_name\r\n#>               <arrw_bnr>\r\n#> 1 51, 75, e9, 62, 65, 63\r\n{code}\r\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=paleolimbot",
                        "name": "paleolimbot",
                        "key": "paleolimbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=paleolimbot&avatarId=47795",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=paleolimbot&avatarId=47795",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=paleolimbot&avatarId=47795",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=paleolimbot&avatarId=47795"
                        },
                        "displayName": "Dewey Dunnington",
                        "active": true,
                        "timeZone": "America/Halifax"
                    },
                    "created": "2021-12-17T20:59:47.932+0000",
                    "updated": "2021-12-17T20:59:47.932+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13312505/comment/17472285",
                    "id": "17472285",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jonkeane",
                        "name": "jonkeane",
                        "key": "jonkeane",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Jonathan Keane",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Issue resolved by pull request 12030\n[https://github.com/apache/arrow/pull/12030]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jonkeane",
                        "name": "jonkeane",
                        "key": "jonkeane",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Jonathan Keane",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-01-10T20:31:21.989+0000",
                    "updated": "2022-01-10T20:31:21.989+0000"
                }
            ],
            "maxResults": 4,
            "total": 4,
            "startAt": 0
        },
        "customfield_12311820": "0|z0g16g:",
        "customfield_12314139": null
    }
}