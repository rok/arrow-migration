{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13071628",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13071628",
    "key": "ARROW-1018",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12342562",
                "id": "12342562",
                "description": "",
                "name": "0.10.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-08-06"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": null,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": null,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1018/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 0,
            "worklogs": []
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": null,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@2cf691d4[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@740998ad[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@41c80f81[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@793c3be5[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@175e963b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@c0703c4[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@db2a1c2[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@15c94082[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@76c5e34e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@4268c771[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5accc24f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@55e54c4[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": null,
        "customfield_12312520": null,
        "customfield_12312521": "Sat Apr 21 14:05:36 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-04-21T14:05:36.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1018/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2017-05-12T18:41:26.000+0000",
        "updated": "2018-04-21T14:05:36.000+0000",
        "timeoriginalestimate": null,
        "description": "Currently we require a file path. It should also be possible to initialize from a file descriptor",
        "customfield_10010": null,
        "timetracking": {},
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Add option to create FileOutputStream, ReadableFile from OS file descriptor",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13071628/comment/16443035",
                    "id": "16443035",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "pitrou opened a new pull request #1909: ARROW-1018: [C++] Create FileOutputStream, ReadableFile from file descriptor\nURL: https://github.com/apache/arrow/pull/1909\n \n \n   Also:\r\n   - move platform-specific code to `util/file-util.h`\r\n   - backport the `FileReadAt` helper from PR #1867 (to minimize conflicts)\r\n   - add a pipe-writing benchmark for more realistic numbers\r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-18T18:56:41.940+0000",
                    "updated": "2018-04-18T18:56:41.940+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13071628/comment/16443036",
                    "id": "16443036",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "pitrou commented on issue #1909: ARROW-1018: [C++] Create FileOutputStream, ReadableFile from file descriptor\nURL: https://github.com/apache/arrow/pull/1909#issuecomment-382493368\n \n \n   Benchmark numbers (Ubuntu 16.04, x86-64):\r\n   ```\r\n   Benchmark                                                                                   Time           CPU Iterations\r\n   -------------------------------------------------------------------------------------------------------------------------\r\n   BM_FileOutputStreamSmallWritesToNull/min_time:1.000/repeats:2/real_time                  1052 ns       1052 ns    1326145   313.608MB/s\r\n   BM_FileOutputStreamSmallWritesToNull/min_time:1.000/repeats:2/real_time                  1052 ns       1052 ns    1326145   313.514MB/s\r\n   BM_FileOutputStreamSmallWritesToNull/min_time:1.000/repeats:2/real_time_mean             1052 ns       1052 ns    1326145   313.561MB/s\r\n   BM_FileOutputStreamSmallWritesToNull/min_time:1.000/repeats:2/real_time_stddev              0 ns          0 ns          0   48.1773kB/s\r\n   BM_FileOutputStreamSmallWritesToPipe/min_time:1.000/repeats:2/real_time                  4009 ns       4008 ns     372208   82.3114MB/s\r\n   BM_FileOutputStreamSmallWritesToPipe/min_time:1.000/repeats:2/real_time                  3743 ns       3742 ns     372208   88.1568MB/s\r\n   BM_FileOutputStreamSmallWritesToPipe/min_time:1.000/repeats:2/real_time_mean             3876 ns       3875 ns     372208   85.2341MB/s\r\n   BM_FileOutputStreamSmallWritesToPipe/min_time:1.000/repeats:2/real_time_stddev            133 ns        133 ns          0   2.92271MB/s\r\n   BM_FileOutputStreamLargeWritesToPipe/min_time:1.000/repeats:2/real_time                 34605 ns      29539 ns      40466   2.91177GB/s\r\n   BM_FileOutputStreamLargeWritesToPipe/min_time:1.000/repeats:2/real_time                 34811 ns      29694 ns      40466   2.89456GB/s\r\n   BM_FileOutputStreamLargeWritesToPipe/min_time:1.000/repeats:2/real_time_mean            34708 ns      29617 ns      40466   2.90316GB/s\r\n   BM_FileOutputStreamLargeWritesToPipe/min_time:1.000/repeats:2/real_time_stddev            103 ns         78 ns          0   8.80971MB/s\r\n   BM_BufferedOutputStreamSmallWritesToNull/min_time:1.000/repeats:2/real_time               178 ns        178 ns    7815782   1.81128GB/s\r\n   BM_BufferedOutputStreamSmallWritesToNull/min_time:1.000/repeats:2/real_time               178 ns        178 ns    7815782   1.80823GB/s\r\n   BM_BufferedOutputStreamSmallWritesToNull/min_time:1.000/repeats:2/real_time_mean          178 ns        178 ns    7815782   1.80976GB/s\r\n   BM_BufferedOutputStreamSmallWritesToNull/min_time:1.000/repeats:2/real_time_stddev          0 ns          0 ns          0   1.56144MB/s\r\n   BM_BufferedOutputStreamSmallWritesToPipe/min_time:1.000/repeats:2/real_time               260 ns        260 ns    5326950   1.23725GB/s\r\n   BM_BufferedOutputStreamSmallWritesToPipe/min_time:1.000/repeats:2/real_time               259 ns        259 ns    5326950   1.24258GB/s\r\n   BM_BufferedOutputStreamSmallWritesToPipe/min_time:1.000/repeats:2/real_time_mean          260 ns        260 ns    5326950   1.23991GB/s\r\n   BM_BufferedOutputStreamSmallWritesToPipe/min_time:1.000/repeats:2/real_time_stddev          1 ns          1 ns          0   2.72658MB/s\r\n   BM_BufferedOutputStreamLargeWritesToPipe/min_time:1.000/repeats:2/real_time             34746 ns      29644 ns      40294   2.89998GB/s\r\n   BM_BufferedOutputStreamLargeWritesToPipe/min_time:1.000/repeats:2/real_time             34612 ns      29472 ns      40294   2.91121GB/s\r\n   BM_BufferedOutputStreamLargeWritesToPipe/min_time:1.000/repeats:2/real_time_mean        34679 ns      29558 ns      40294   2.90559GB/s\r\n   BM_BufferedOutputStreamLargeWritesToPipe/min_time:1.000/repeats:2/real_time_stddev         67 ns         86 ns          0   5.75201MB/s\r\n   ```\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-18T18:57:59.612+0000",
                    "updated": "2018-04-18T18:57:59.612+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13071628/comment/16446814",
                    "id": "16446814",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "xhochy closed pull request #1909: ARROW-1018: [C++] Create FileOutputStream, ReadableFile from file descriptor\nURL: https://github.com/apache/arrow/pull/1909\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/.travis.yml b/.travis.yml\nindex 2fd31bec72..59ad4bcf0d 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -87,7 +87,7 @@ matrix:\n     before_script:\n     - if [ $ARROW_CI_PYTHON_AFFECTED != \"1\" ]; then exit; fi\n     # If either C++ or Python changed, we must install the C++ libraries\n-    - travis_wait 50 $TRAVIS_BUILD_DIR/ci/travis_before_script_cpp.sh\n+    - $TRAVIS_BUILD_DIR/ci/travis_before_script_cpp.sh\n     script:\n     - if [ $ARROW_CI_CPP_AFFECTED == \"1\" ]; then $TRAVIS_BUILD_DIR/ci/travis_script_cpp.sh; fi\n     - $TRAVIS_BUILD_DIR/ci/travis_build_parquet_cpp.sh\ndiff --git a/cpp/src/arrow/CMakeLists.txt b/cpp/src/arrow/CMakeLists.txt\nindex da7e24d2d3..a3997c7373 100644\n--- a/cpp/src/arrow/CMakeLists.txt\n+++ b/cpp/src/arrow/CMakeLists.txt\n@@ -40,11 +40,12 @@ set(ARROW_SRCS\n   util/cpu-info.cc\n   util/decimal.cc\n   util/hash.cc\n+  util/io-util.cc\n   util/key_value_metadata.cc\n )\n \n if (\"${COMPILER_FAMILY}\" STREQUAL \"clang\")\n-  set_property(SOURCE io/file.cc\n+  set_property(SOURCE util/io-util.cc\n     APPEND_STRING\n     PROPERTY COMPILE_FLAGS\n     \" -Wno-unused-macros \")\ndiff --git a/cpp/src/arrow/io/file.cc b/cpp/src/arrow/io/file.cc\nindex 008f2b2e22..ba012beb72 100644\n--- a/cpp/src/arrow/io/file.cc\n+++ b/cpp/src/arrow/io/file.cc\n@@ -15,37 +15,7 @@\n // specific language governing permissions and limitations\n // under the License.\n \n-// Ensure 64-bit off_t for platforms where it matters\n-#ifdef _FILE_OFFSET_BITS\n-#undef _FILE_OFFSET_BITS\n-#endif\n-\n-#define _FILE_OFFSET_BITS 64\n-\n-// define max read/write count\n-#if defined(_MSC_VER)\n-#define ARROW_MAX_IO_CHUNKSIZE INT32_MAX\n-#else\n-\n-#ifdef __APPLE__\n-// due to macOS bug, we need to set read/write max\n-#define ARROW_MAX_IO_CHUNKSIZE INT32_MAX\n-#else\n-// see notes on Linux read/write manpage\n-#define ARROW_MAX_IO_CHUNKSIZE 0x7ffff000\n-#endif\n-\n-#endif\n-\n-#include \"arrow/io/file.h\"\n-\n-#if _WIN32 || _WIN64\n-#if _WIN64\n-#define ENVIRONMENT64\n-#else\n-#define ENVIRONMENT32\n-#endif\n-#endif\n+#include \"arrow/io/windows_compatibility.h\"\n \n // sys/mman.h not present in Visual Studio or Cygwin\n #ifdef _WIN32\n@@ -55,334 +25,88 @@\n #include \"arrow/io/mman.h\"\n #undef Realloc\n #undef Free\n-#include <windows.h>\n #else\n #include <sys/mman.h>\n #endif\n \n+#include <string.h>\n+\n #include <algorithm>\n #include <cerrno>\n #include <cstdint>\n #include <cstring>\n #include <mutex>\n-#include <sstream>  // IWYU pragma: keep\n-\n-#if defined(_MSC_VER)\n-#include <codecvt>\n-#include <locale>\n-#endif\n-\n-#include <fcntl.h>\n-#include <sys/stat.h>\n-#include <sys/types.h>  // IWYU pragma: keep\n-\n-#ifndef _MSC_VER  // POSIX-like platforms\n-\n-#include <unistd.h>\n-\n-// Not available on some platforms\n-#ifndef errno_t\n-#define errno_t int\n-#endif\n-\n-#endif  // _MSC_VER\n-\n-// defines that don't exist in MinGW\n-#if defined(__MINGW32__)\n-#define ARROW_WRITE_SHMODE S_IRUSR | S_IWUSR\n-#elif defined(_MSC_VER)  // Visual Studio\n-\n-#else  // gcc / clang on POSIX platforms\n-#define ARROW_WRITE_SHMODE S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH\n-#endif\n-\n-// ----------------------------------------------------------------------\n-// file compatibility stuff\n-\n-#if defined(__MINGW32__)  // MinGW\n-// nothing\n-#elif defined(_MSC_VER)  // Visual Studio\n-#include <io.h>\n-#else  // POSIX / Linux\n-// nothing\n-#endif\n-\n-// POSIX systems do not have this\n-#ifndef O_BINARY\n-#define O_BINARY 0\n-#endif\n+#include <sstream>\n \n // ----------------------------------------------------------------------\n // Other Arrow includes\n \n+#include \"arrow/io/file.h\"\n #include \"arrow/io/interfaces.h\"\n \n #include \"arrow/buffer.h\"\n #include \"arrow/memory_pool.h\"\n #include \"arrow/status.h\"\n+#include \"arrow/util/io-util.h\"\n #include \"arrow/util/logging.h\"\n \n-#if defined(_MSC_VER)\n-#include <boost/filesystem.hpp>           // NOLINT\n-#include <boost/system/system_error.hpp>  // NOLINT\n-namespace fs = boost::filesystem;\n-#define PlatformFilename fs::path\n-\n-namespace arrow {\n-namespace io {\n-\n-#else\n namespace arrow {\n namespace io {\n \n-struct PlatformFilename {\n-  PlatformFilename() {}\n-  explicit PlatformFilename(const std::string& path) { utf8_path = path; }\n-\n-  const char* c_str() const { return utf8_path.c_str(); }\n-\n-  const std::string& string() const { return utf8_path; }\n-\n-  size_t length() const { return utf8_path.size(); }\n-\n-  std::string utf8_path;\n-};\n-#endif\n-\n-static inline Status CheckFileOpResult(int ret, int errno_actual,\n-                                       const PlatformFilename& file_name,\n-                                       const std::string& opname) {\n-  if (ret == -1) {\n-    std::stringstream ss;\n-    ss << \"Failed to \" << opname << \" file: \" << file_name.string();\n-    ss << \" , error: \" << std::strerror(errno_actual);\n-    return Status::IOError(ss.str());\n-  }\n-  return Status::OK();\n-}\n-\n-#define CHECK_LSEEK(retval) \\\n-  if ((retval) == -1) return Status::IOError(\"lseek failed\");\n-\n-static inline int64_t lseek64_compat(int fd, int64_t pos, int whence) {\n-#if defined(_MSC_VER)\n-  return _lseeki64(fd, pos, whence);\n-#else\n-  return lseek(fd, pos, whence);\n-#endif\n-}\n-\n-static inline Status FileOpenReadable(const PlatformFilename& file_name, int* fd) {\n-  int ret;\n-  errno_t errno_actual = 0;\n-#if defined(_MSC_VER)\n-  errno_actual = _wsopen_s(fd, file_name.wstring().c_str(), _O_RDONLY | _O_BINARY,\n-                           _SH_DENYNO, _S_IREAD);\n-  ret = *fd;\n-#else\n-  ret = *fd = open(file_name.c_str(), O_RDONLY | O_BINARY);\n-  errno_actual = errno;\n-#endif\n-\n-  return CheckFileOpResult(ret, errno_actual, file_name, \"open local\");\n-}\n-\n-static inline Status FileOpenWriteable(const PlatformFilename& file_name, bool write_only,\n-                                       bool truncate, int* fd) {\n-  int ret;\n-  errno_t errno_actual = 0;\n-\n-#if defined(_MSC_VER)\n-  int oflag = _O_CREAT | _O_BINARY;\n-  int pmode = _S_IWRITE;\n-  if (!write_only) {\n-    pmode |= _S_IREAD;\n-  }\n-\n-  if (truncate) {\n-    oflag |= _O_TRUNC;\n-  }\n-\n-  if (write_only) {\n-    oflag |= _O_WRONLY;\n-  } else {\n-    oflag |= _O_RDWR;\n-  }\n-\n-  errno_actual = _wsopen_s(fd, file_name.wstring().c_str(), oflag, _SH_DENYNO, pmode);\n-  ret = *fd;\n-\n-#else\n-  int oflag = O_CREAT | O_BINARY;\n-\n-  if (truncate) {\n-    oflag |= O_TRUNC;\n-  }\n-\n-  if (write_only) {\n-    oflag |= O_WRONLY;\n-  } else {\n-    oflag |= O_RDWR;\n-  }\n-\n-  ret = *fd = open(file_name.c_str(), oflag, ARROW_WRITE_SHMODE);\n-#endif\n-  return CheckFileOpResult(ret, errno_actual, file_name, \"open local\");\n-}\n-\n-static inline Status FileTell(int fd, int64_t* pos) {\n-  int64_t current_pos;\n-\n-#if defined(_MSC_VER)\n-  current_pos = _telli64(fd);\n-  if (current_pos == -1) {\n-    return Status::IOError(\"_telli64 failed\");\n-  }\n-#else\n-  current_pos = lseek64_compat(fd, 0, SEEK_CUR);\n-  CHECK_LSEEK(current_pos);\n-#endif\n-\n-  *pos = current_pos;\n-  return Status::OK();\n-}\n-\n-static inline Status FileSeek(int fd, int64_t pos) {\n-  int64_t ret = lseek64_compat(fd, pos, SEEK_SET);\n-  CHECK_LSEEK(ret);\n-  return Status::OK();\n-}\n-\n-static inline Status FileRead(const int fd, uint8_t* buffer, const int64_t nbytes,\n-                              int64_t* bytes_read) {\n-  *bytes_read = 0;\n-\n-  while (*bytes_read != -1 && *bytes_read < nbytes) {\n-    int64_t chunksize =\n-        std::min(static_cast<int64_t>(ARROW_MAX_IO_CHUNKSIZE), nbytes - *bytes_read);\n-#if defined(_MSC_VER)\n-    int64_t ret = static_cast<int64_t>(\n-        _read(fd, buffer + *bytes_read, static_cast<uint32_t>(chunksize)));\n-#else\n-    int64_t ret = static_cast<int64_t>(\n-        read(fd, buffer + *bytes_read, static_cast<size_t>(chunksize)));\n-#endif\n-\n-    if (ret != -1) {\n-      *bytes_read += ret;\n-      if (ret < chunksize) {\n-        // EOF\n-        break;\n-      }\n-    } else {\n-      *bytes_read = ret;\n-    }\n-  }\n-\n-  if (*bytes_read == -1) {\n-    return Status::IOError(std::string(\"Error reading bytes from file: \") +\n-                           std::string(strerror(errno)));\n-  }\n-\n-  return Status::OK();\n-}\n-\n-static inline Status FileWrite(const int fd, const uint8_t* buffer,\n-                               const int64_t nbytes) {\n-  int ret = 0;\n-  int64_t bytes_written = 0;\n-\n-  while (ret != -1 && bytes_written < nbytes) {\n-    int64_t chunksize =\n-        std::min(static_cast<int64_t>(ARROW_MAX_IO_CHUNKSIZE), nbytes - bytes_written);\n-#if defined(_MSC_VER)\n-    ret = static_cast<int>(\n-        _write(fd, buffer + bytes_written, static_cast<uint32_t>(chunksize)));\n-#else\n-    ret = static_cast<int>(\n-        write(fd, buffer + bytes_written, static_cast<size_t>(chunksize)));\n-#endif\n-\n-    if (ret != -1) {\n-      bytes_written += ret;\n-    }\n-  }\n-\n-  if (ret == -1) {\n-    return Status::IOError(std::string(\"Error writing bytes from file: \") +\n-                           std::string(strerror(errno)));\n-  }\n-  return Status::OK();\n-}\n-\n-static inline Status FileGetSize(int fd, int64_t* size) {\n-  int64_t ret;\n-\n-  // Save current position\n-  int64_t current_position = lseek64_compat(fd, 0, SEEK_CUR);\n-  CHECK_LSEEK(current_position);\n-\n-  // move to end of the file\n-  ret = lseek64_compat(fd, 0, SEEK_END);\n-  CHECK_LSEEK(ret);\n-\n-  // Get file length\n-  ret = lseek64_compat(fd, 0, SEEK_CUR);\n-  CHECK_LSEEK(ret);\n-\n-  *size = ret;\n-\n-  // Restore file position\n-  ret = lseek64_compat(fd, current_position, SEEK_SET);\n-  CHECK_LSEEK(ret);\n-\n-  return Status::OK();\n-}\n-\n-static inline Status FileClose(int fd) {\n-  int ret;\n-\n-#if defined(_MSC_VER)\n-  ret = static_cast<int>(_close(fd));\n-#else\n-  ret = static_cast<int>(close(fd));\n-#endif\n-\n-  if (ret == -1) {\n-    return Status::IOError(\"error closing file\");\n-  }\n-  return Status::OK();\n-}\n-\n class OSFile {\n  public:\n   OSFile() : fd_(-1), is_open_(false), size_(-1) {}\n \n   ~OSFile() {}\n \n+  // Note: only one of the Open* methods below may be called on a given instance\n+\n   Status OpenWriteable(const std::string& path, bool append, bool write_only) {\n     RETURN_NOT_OK(SetFileName(path));\n \n-    RETURN_NOT_OK(FileOpenWriteable(file_name_, write_only, !append, &fd_));\n+    RETURN_NOT_OK(internal::FileOpenWriteable(file_name_, write_only, !append, &fd_));\n     is_open_ = true;\n     mode_ = write_only ? FileMode::WRITE : FileMode::READWRITE;\n \n     if (append) {\n-      RETURN_NOT_OK(FileGetSize(fd_, &size_));\n+      RETURN_NOT_OK(internal::FileGetSize(fd_, &size_));\n     } else {\n       size_ = 0;\n     }\n     return Status::OK();\n   }\n \n+  // This is different from OpenWriteable(string, ...) in that it doesn't\n+  // truncate nor mandate a seekable file\n+  Status OpenWriteable(int fd) {\n+    if (!internal::FileGetSize(fd, &size_).ok()) {\n+      // Non-seekable file\n+      size_ = -1;\n+    }\n+    RETURN_NOT_OK(SetFileName(fd));\n+    is_open_ = true;\n+    mode_ = FileMode::WRITE;\n+    fd_ = fd;\n+    return Status::OK();\n+  }\n+\n   Status OpenReadable(const std::string& path) {\n     RETURN_NOT_OK(SetFileName(path));\n \n-    RETURN_NOT_OK(FileOpenReadable(file_name_, &fd_));\n-    RETURN_NOT_OK(FileGetSize(fd_, &size_));\n+    RETURN_NOT_OK(internal::FileOpenReadable(file_name_, &fd_));\n+    RETURN_NOT_OK(internal::FileGetSize(fd_, &size_));\n+\n+    is_open_ = true;\n+    mode_ = FileMode::READ;\n+    return Status::OK();\n+  }\n \n+  Status OpenReadable(int fd) {\n+    RETURN_NOT_OK(internal::FileGetSize(fd, &size_));\n+    RETURN_NOT_OK(SetFileName(fd));\n     is_open_ = true;\n     mode_ = FileMode::READ;\n+    fd_ = fd;\n     return Status::OK();\n   }\n \n@@ -391,13 +115,13 @@ class OSFile {\n       // Even if closing fails, the fd will likely be closed (perhaps it's\n       // already closed).\n       is_open_ = false;\n-      RETURN_NOT_OK(FileClose(fd_));\n+      RETURN_NOT_OK(internal::FileClose(fd_));\n     }\n     return Status::OK();\n   }\n \n   Status Read(int64_t nbytes, int64_t* bytes_read, void* out) {\n-    return FileRead(fd_, reinterpret_cast<uint8_t*>(out), nbytes, bytes_read);\n+    return internal::FileRead(fd_, reinterpret_cast<uint8_t*>(out), nbytes, bytes_read);\n   }\n \n   Status ReadAt(int64_t position, int64_t nbytes, int64_t* bytes_read, void* out) {\n@@ -410,17 +134,17 @@ class OSFile {\n     if (pos < 0) {\n       return Status::Invalid(\"Invalid position\");\n     }\n-    return FileSeek(fd_, pos);\n+    return internal::FileSeek(fd_, pos);\n   }\n \n-  Status Tell(int64_t* pos) const { return FileTell(fd_, pos); }\n+  Status Tell(int64_t* pos) const { return internal::FileTell(fd_, pos); }\n \n   Status Write(const void* data, int64_t length) {\n     std::lock_guard<std::mutex> guard(lock_);\n     if (length < 0) {\n       return Status::IOError(\"Length must be non-negative\");\n     }\n-    return FileWrite(fd_, reinterpret_cast<const uint8_t*>(data), length);\n+    return internal::FileWrite(fd_, reinterpret_cast<const uint8_t*>(data), length);\n   }\n \n   int fd() const { return fd_; }\n@@ -435,20 +159,15 @@ class OSFile {\n \n  protected:\n   Status SetFileName(const std::string& file_name) {\n-#if defined(_MSC_VER)\n-    try {\n-      std::codecvt_utf8_utf16<wchar_t> utf16_converter;\n-      file_name_.assign(file_name, utf16_converter);\n-    } catch (boost::system::system_error& e) {\n-      return Status::Invalid(e.what());\n-    }\n-#else\n-    file_name_ = PlatformFilename(file_name);\n-#endif\n-    return Status::OK();\n+    return internal::FileNameFromString(file_name, &file_name_);\n+  }\n+  Status SetFileName(int fd) {\n+    std::stringstream ss;\n+    ss << \"<fd \" << fd << \">\";\n+    return SetFileName(ss.str());\n   }\n \n-  PlatformFilename file_name_;\n+  internal::PlatformFilename file_name_;\n \n   std::mutex lock_;\n \n@@ -469,6 +188,7 @@ class ReadableFile::ReadableFileImpl : public OSFile {\n   explicit ReadableFileImpl(MemoryPool* pool) : OSFile(), pool_(pool) {}\n \n   Status Open(const std::string& path) { return OpenReadable(path); }\n+  Status Open(int fd) { return OpenReadable(fd); }\n \n   Status ReadBuffer(int64_t nbytes, std::shared_ptr<Buffer>* out) {\n     std::shared_ptr<ResizableBuffer> buffer;\n@@ -492,8 +212,7 @@ ReadableFile::ReadableFile(MemoryPool* pool) { impl_.reset(new ReadableFileImpl(\n ReadableFile::~ReadableFile() { DCHECK(impl_->Close().ok()); }\n \n Status ReadableFile::Open(const std::string& path, std::shared_ptr<ReadableFile>* file) {\n-  *file = std::shared_ptr<ReadableFile>(new ReadableFile(default_memory_pool()));\n-  return (*file)->impl_->Open(path);\n+  return Open(path, default_memory_pool(), file);\n }\n \n Status ReadableFile::Open(const std::string& path, MemoryPool* memory_pool,\n@@ -502,6 +221,16 @@ Status ReadableFile::Open(const std::string& path, MemoryPool* memory_pool,\n   return (*file)->impl_->Open(path);\n }\n \n+Status ReadableFile::Open(int fd, MemoryPool* memory_pool,\n+                          std::shared_ptr<ReadableFile>* file) {\n+  *file = std::shared_ptr<ReadableFile>(new ReadableFile(memory_pool));\n+  return (*file)->impl_->Open(fd);\n+}\n+\n+Status ReadableFile::Open(int fd, std::shared_ptr<ReadableFile>* file) {\n+  return Open(fd, default_memory_pool(), file);\n+}\n+\n Status ReadableFile::Close() { return impl_->Close(); }\n \n Status ReadableFile::Tell(int64_t* pos) const { return impl_->Tell(pos); }\n@@ -545,8 +274,9 @@ int ReadableFile::file_descriptor() const { return impl_->fd(); }\n class FileOutputStream::FileOutputStreamImpl : public OSFile {\n  public:\n   Status Open(const std::string& path, bool append) {\n-    return OpenWriteable(path, append, true);\n+    return OpenWriteable(path, append, true /* write_only */);\n   }\n+  Status Open(int fd) { return OpenWriteable(fd); }\n };\n \n FileOutputStream::FileOutputStream() { impl_.reset(new FileOutputStreamImpl()); }\n@@ -567,6 +297,11 @@ Status FileOutputStream::Open(const std::string& path, bool append,\n   return std::static_pointer_cast<FileOutputStream>(*out)->impl_->Open(path, append);\n }\n \n+Status FileOutputStream::Open(int fd, std::shared_ptr<OutputStream>* out) {\n+  *out = std::shared_ptr<FileOutputStream>(new FileOutputStream());\n+  return std::static_pointer_cast<FileOutputStream>(*out)->impl_->Open(fd);\n+}\n+\n Status FileOutputStream::Open(const std::string& path,\n                               std::shared_ptr<FileOutputStream>* file) {\n   return Open(path, false, file);\n@@ -579,6 +314,11 @@ Status FileOutputStream::Open(const std::string& path, bool append,\n   return (*file)->impl_->Open(path, append);\n }\n \n+Status FileOutputStream::Open(int fd, std::shared_ptr<FileOutputStream>* file) {\n+  *file = std::shared_ptr<FileOutputStream>(new FileOutputStream());\n+  return (*file)->impl_->Open(fd);\n+}\n+\n Status FileOutputStream::Close() { return impl_->Close(); }\n \n Status FileOutputStream::Tell(int64_t* pos) const { return impl_->Tell(pos); }\n@@ -682,20 +422,10 @@ MemoryMappedFile::~MemoryMappedFile() {}\n \n Status MemoryMappedFile::Create(const std::string& path, int64_t size,\n                                 std::shared_ptr<MemoryMappedFile>* out) {\n-  int ret;\n-  errno_t errno_actual;\n   std::shared_ptr<FileOutputStream> file;\n   RETURN_NOT_OK(FileOutputStream::Open(path, &file));\n \n-#ifdef _MSC_VER\n-  errno_actual = _chsize_s(file->file_descriptor(), static_cast<size_t>(size));\n-  ret = errno_actual == 0 ? 0 : -1;\n-#else\n-  ret = ftruncate(file->file_descriptor(), static_cast<size_t>(size));\n-  errno_actual = errno;\n-#endif\n-\n-  RETURN_NOT_OK(CheckFileOpResult(ret, errno_actual, PlatformFilename(path), \"truncate\"));\n+  RETURN_NOT_OK(internal::FileTruncate(file->file_descriptor(), size));\n \n   RETURN_NOT_OK(file->Close());\n   return MemoryMappedFile::Open(path, FileMode::READWRITE, out);\ndiff --git a/cpp/src/arrow/io/file.h b/cpp/src/arrow/io/file.h\nindex a1f9edc1c6..c2572da590 100644\n--- a/cpp/src/arrow/io/file.h\n+++ b/cpp/src/arrow/io/file.h\n@@ -54,6 +54,15 @@ class ARROW_EXPORT FileOutputStream : public OutputStream {\n   static Status Open(const std::string& path, bool append,\n                      std::shared_ptr<OutputStream>* out);\n \n+  /// \\brief Open a file descriptor for writing.  The underlying file isn't\n+  /// truncated.\n+  /// \\param[in] fd file descriptor\n+  /// \\param[out] out a base interface OutputStream instance\n+  ///\n+  /// The file descriptor becomes owned by the OutputStream, and will be closed\n+  /// on Close() or destruction.\n+  static Status Open(int fd, std::shared_ptr<OutputStream>* out);\n+\n   /// \\brief Open a local file for writing, truncating any existing file\n   /// \\param[in] path with UTF8 encoding\n   /// \\param[out] file a FileOutputStream instance\n@@ -69,6 +78,15 @@ class ARROW_EXPORT FileOutputStream : public OutputStream {\n   static Status Open(const std::string& path, bool append,\n                      std::shared_ptr<FileOutputStream>* file);\n \n+  /// \\brief Open a file descriptor for writing.  The underlying file isn't\n+  /// truncated.\n+  /// \\param[in] fd file descriptor\n+  /// \\param[out] out a FileOutputStream instance\n+  ///\n+  /// The file descriptor becomes owned by the OutputStream, and will be closed\n+  /// on Close() or destruction.\n+  static Status Open(int fd, std::shared_ptr<FileOutputStream>* out);\n+\n   // OutputStream interface\n   Status Close() override;\n   Status Tell(int64_t* position) const override;\n@@ -104,6 +122,25 @@ class ARROW_EXPORT ReadableFile : public RandomAccessFile {\n   static Status Open(const std::string& path, MemoryPool* pool,\n                      std::shared_ptr<ReadableFile>* file);\n \n+  /// \\brief Open a local file for reading\n+  /// \\param[in] fd file descriptor\n+  /// \\param[out] file ReadableFile instance\n+  /// Open file with one's own memory pool for memory allocations\n+  ///\n+  /// The file descriptor becomes owned by the ReadableFile, and will be closed\n+  /// on Close() or destruction.\n+  static Status Open(int fd, std::shared_ptr<ReadableFile>* file);\n+\n+  /// \\brief Open a local file for reading\n+  /// \\param[in] fd file descriptor\n+  /// \\param[in] pool a MemoryPool for memory allocations\n+  /// \\param[out] file ReadableFile instance\n+  /// Open file with one's own memory pool for memory allocations\n+  ///\n+  /// The file descriptor becomes owned by the ReadableFile, and will be closed\n+  /// on Close() or destruction.\n+  static Status Open(int fd, MemoryPool* pool, std::shared_ptr<ReadableFile>* file);\n+\n   Status Close() override;\n   Status Tell(int64_t* position) const override;\n \ndiff --git a/cpp/src/arrow/io/io-file-benchmark.cc b/cpp/src/arrow/io/io-file-benchmark.cc\nindex bb35b080d1..e5a326e277 100644\n--- a/cpp/src/arrow/io/io-file-benchmark.cc\n+++ b/cpp/src/arrow/io/io-file-benchmark.cc\n@@ -19,25 +19,109 @@\n #include \"arrow/io/buffered.h\"\n #include \"arrow/io/file.h\"\n #include \"arrow/test-util.h\"\n+#include \"arrow/util/io-util.h\"\n \n #include \"benchmark/benchmark.h\"\n \n #include <algorithm>\n+#include <atomic>\n+#include <cstdlib>\n #include <iostream>\n+#include <thread>\n #include <valarray>\n \n+#include <fcntl.h>\n+#include <poll.h>\n+#include <unistd.h>\n+\n namespace arrow {\n \n-// XXX Writing to /dev/null is irrealistic as the kernel likely doesn't\n-// copy the data at all.  Use a socketpair instead?\n std::string GetNullFile() { return \"/dev/null\"; }\n \n const std::valarray<int64_t> small_sizes = {8, 24, 33, 1, 32, 192, 16, 40};\n const std::valarray<int64_t> large_sizes = {8192, 100000};\n \n+class BackgroundReader {\n+  // A class that reads data in the background from a file descriptor\n+\n+ public:\n+  static std::shared_ptr<BackgroundReader> StartReader(int fd) {\n+    std::shared_ptr<BackgroundReader> reader(new BackgroundReader(fd));\n+    reader->worker_.reset(new std::thread([=] { reader->LoopReading(); }));\n+    return reader;\n+  }\n+  void Stop() {\n+    const uint8_t data[] = \"x\";\n+    ABORT_NOT_OK(internal::FileWrite(wakeup_w_, data, 1));\n+  }\n+  void Join() { worker_->join(); }\n+\n+  ~BackgroundReader() {\n+    for (int fd : {fd_, wakeup_r_, wakeup_w_}) {\n+      ABORT_NOT_OK(internal::FileClose(fd));\n+    }\n+  }\n+\n+ protected:\n+  explicit BackgroundReader(int fd) : fd_(fd), total_bytes_(0) {\n+    // Prepare self-pipe trick\n+    int wakeupfd[2];\n+    ABORT_NOT_OK(internal::CreatePipe(wakeupfd));\n+    wakeup_r_ = wakeupfd[0];\n+    wakeup_w_ = wakeupfd[1];\n+    // Put fd in non-blocking mode\n+    fcntl(fd, F_SETFL, O_NONBLOCK);\n+  }\n+\n+  void LoopReading() {\n+    struct pollfd pollfds[2];\n+    pollfds[0].fd = fd_;\n+    pollfds[0].events = POLLIN;\n+    pollfds[1].fd = wakeup_r_;\n+    pollfds[1].events = POLLIN;\n+    while (true) {\n+      int ret = poll(pollfds, 2, -1 /* timeout */);\n+      if (ret < 1) {\n+        std::cerr << \"poll() failed with code \" << ret << \"\\n\";\n+        abort();\n+      }\n+      if (pollfds[1].revents & POLLIN) {\n+        // We're done\n+        break;\n+      }\n+      if (!(pollfds[0].revents & POLLIN)) {\n+        continue;\n+      }\n+      int64_t bytes_read;\n+      // There could be a spurious wakeup followed by EAGAIN\n+      ARROW_UNUSED(internal::FileRead(fd_, buffer_, buffer_size_, &bytes_read));\n+      total_bytes_ += bytes_read;\n+    }\n+  }\n+\n+  int fd_, wakeup_r_, wakeup_w_;\n+  int64_t total_bytes_;\n+\n+  static const int64_t buffer_size_ = 16384;\n+  uint8_t buffer_[buffer_size_];\n+\n+  std::unique_ptr<std::thread> worker_;\n+};\n+\n+// Set up a pipe with an OutputStream at one end and a BackgroundReader at\n+// the other end.\n+static void SetupPipeWriter(std::shared_ptr<io::OutputStream>* stream,\n+                            std::shared_ptr<BackgroundReader>* reader) {\n+  int fd[2];\n+  ABORT_NOT_OK(internal::CreatePipe(fd));\n+  ABORT_NOT_OK(io::FileOutputStream::Open(fd[1], stream));\n+  *reader = BackgroundReader::StartReader(fd[0]);\n+}\n+\n static void BenchmarkStreamingWrites(benchmark::State& state,\n                                      std::valarray<int64_t> sizes,\n-                                     io::OutputStream* stream) {\n+                                     io::OutputStream* stream,\n+                                     BackgroundReader* reader = nullptr) {\n   const std::string datastr(*std::max_element(std::begin(sizes), std::end(sizes)), 'x');\n   const void* data = datastr.data();\n   const int64_t sum_sizes = sizes.sum();\n@@ -47,10 +131,23 @@ static void BenchmarkStreamingWrites(benchmark::State& state,\n       ABORT_NOT_OK(stream->Write(data, size));\n     }\n   }\n-  state.SetBytesProcessed(int64_t(state.iterations()) * sum_sizes);\n+  const int64_t total_bytes = static_cast<int64_t>(state.iterations()) * sum_sizes;\n+  state.SetBytesProcessed(total_bytes);\n+\n+  if (reader != nullptr) {\n+    // Wake up and stop\n+    reader->Stop();\n+    reader->Join();\n+  }\n+  ABORT_NOT_OK(stream->Close());\n }\n \n-static void BM_FileOutputStreamSmallWrites(\n+// Benchmark writing to /dev/null\n+//\n+// This situation is irrealistic as the kernel likely doesn't\n+// copy the data at all, so we only measure small writes.\n+\n+static void BM_FileOutputStreamSmallWritesToNull(\n     benchmark::State& state) {  // NOLINT non-const reference\n   std::shared_ptr<io::OutputStream> stream;\n   ABORT_NOT_OK(io::FileOutputStream::Open(GetNullFile(), &stream));\n@@ -58,38 +155,84 @@ static void BM_FileOutputStreamSmallWrites(\n   BenchmarkStreamingWrites(state, small_sizes, stream.get());\n }\n \n-static void BM_FileOutputStreamLargeWrites(\n+static void BM_BufferedOutputStreamSmallWritesToNull(\n     benchmark::State& state) {  // NOLINT non-const reference\n   std::shared_ptr<io::OutputStream> stream;\n   ABORT_NOT_OK(io::FileOutputStream::Open(GetNullFile(), &stream));\n+  stream = std::make_shared<io::BufferedOutputStream>(std::move(stream));\n \n-  BenchmarkStreamingWrites(state, large_sizes, stream.get());\n+  BenchmarkStreamingWrites(state, small_sizes, stream.get());\n }\n \n-static void BM_BufferedOutputStreamSmallWrites(\n+// Benchmark writing a pipe\n+//\n+// This is slightly more realistic than the above\n+\n+static void BM_FileOutputStreamSmallWritesToPipe(\n     benchmark::State& state) {  // NOLINT non-const reference\n   std::shared_ptr<io::OutputStream> stream;\n-  ABORT_NOT_OK(io::FileOutputStream::Open(GetNullFile(), &stream));\n-  stream = std::make_shared<io::BufferedOutputStream>(std::move(stream));\n+  std::shared_ptr<BackgroundReader> reader;\n+  SetupPipeWriter(&stream, &reader);\n \n-  BenchmarkStreamingWrites(state, small_sizes, stream.get());\n+  BenchmarkStreamingWrites(state, small_sizes, stream.get(), reader.get());\n }\n \n-static void BM_BufferedOutputStreamLargeWrites(\n+static void BM_FileOutputStreamLargeWritesToPipe(\n     benchmark::State& state) {  // NOLINT non-const reference\n   std::shared_ptr<io::OutputStream> stream;\n-  ABORT_NOT_OK(io::FileOutputStream::Open(GetNullFile(), &stream));\n-  stream = std::make_shared<io::BufferedOutputStream>(std::move(stream));\n+  std::shared_ptr<BackgroundReader> reader;\n+  SetupPipeWriter(&stream, &reader);\n \n-  BenchmarkStreamingWrites(state, large_sizes, stream.get());\n+  BenchmarkStreamingWrites(state, large_sizes, stream.get(), reader.get());\n }\n \n-BENCHMARK(BM_FileOutputStreamSmallWrites)->Repetitions(2)->MinTime(1.0);\n+static void BM_BufferedOutputStreamSmallWritesToPipe(\n+    benchmark::State& state) {  // NOLINT non-const reference\n+  std::shared_ptr<io::OutputStream> stream;\n+  std::shared_ptr<BackgroundReader> reader;\n+  SetupPipeWriter(&stream, &reader);\n+  stream = std::make_shared<io::BufferedOutputStream>(std::move(stream));\n+\n+  BenchmarkStreamingWrites(state, small_sizes, stream.get(), reader.get());\n+}\n \n-BENCHMARK(BM_FileOutputStreamLargeWrites)->Repetitions(2)->MinTime(1.0);\n+static void BM_BufferedOutputStreamLargeWritesToPipe(\n+    benchmark::State& state) {  // NOLINT non-const reference\n+  std::shared_ptr<io::OutputStream> stream;\n+  std::shared_ptr<BackgroundReader> reader;\n+  SetupPipeWriter(&stream, &reader);\n+  stream = std::make_shared<io::BufferedOutputStream>(std::move(stream));\n \n-BENCHMARK(BM_BufferedOutputStreamSmallWrites)->Repetitions(2)->MinTime(1.0);\n+  BenchmarkStreamingWrites(state, large_sizes, stream.get(), reader.get());\n+}\n \n-BENCHMARK(BM_BufferedOutputStreamLargeWrites)->Repetitions(2)->MinTime(1.0);\n+// We use real time as we don't want to count CPU time spent in the\n+// BackgroundReader thread\n+\n+BENCHMARK(BM_FileOutputStreamSmallWritesToNull)\n+    ->Repetitions(2)\n+    ->MinTime(1.0)\n+    ->UseRealTime();\n+BENCHMARK(BM_FileOutputStreamSmallWritesToPipe)\n+    ->Repetitions(2)\n+    ->MinTime(1.0)\n+    ->UseRealTime();\n+BENCHMARK(BM_FileOutputStreamLargeWritesToPipe)\n+    ->Repetitions(2)\n+    ->MinTime(1.0)\n+    ->UseRealTime();\n+\n+BENCHMARK(BM_BufferedOutputStreamSmallWritesToNull)\n+    ->Repetitions(2)\n+    ->MinTime(1.0)\n+    ->UseRealTime();\n+BENCHMARK(BM_BufferedOutputStreamSmallWritesToPipe)\n+    ->Repetitions(2)\n+    ->MinTime(1.0)\n+    ->UseRealTime();\n+BENCHMARK(BM_BufferedOutputStreamLargeWritesToPipe)\n+    ->Repetitions(2)\n+    ->MinTime(1.0)\n+    ->UseRealTime();\n \n }  // namespace arrow\ndiff --git a/cpp/src/arrow/io/io-file-test.cc b/cpp/src/arrow/io/io-file-test.cc\nindex 098e82f437..d3ef90800f 100644\n--- a/cpp/src/arrow/io/io-file-test.cc\n+++ b/cpp/src/arrow/io/io-file-test.cc\n@@ -36,6 +36,7 @@\n #include \"arrow/memory_pool.h\"\n #include \"arrow/status.h\"\n #include \"arrow/test-util.h\"\n+#include \"arrow/util/io-util.h\"\n \n namespace arrow {\n namespace io {\n@@ -43,7 +44,7 @@ namespace io {\n class FileTestFixture : public ::testing::Test {\n  public:\n   void SetUp() {\n-    path_ = \"arrow-test-io-file-output-stream.txt\";\n+    path_ = \"arrow-test-io-file.txt\";\n     EnsureFileDeleted();\n   }\n \n@@ -68,6 +69,17 @@ class TestFileOutputStream : public FileTestFixture {\n     ASSERT_OK(FileOutputStream::Open(path_, append, &file_));\n     ASSERT_OK(FileOutputStream::Open(path_, append, &stream_));\n   }\n+  void OpenFileDescriptor() {\n+    internal::PlatformFilename file_name;\n+    ASSERT_OK(internal::FileNameFromString(path_, &file_name));\n+    int fd_file, fd_stream;\n+    ASSERT_OK(internal::FileOpenWriteable(file_name, true /* write_only */,\n+                                          false /* truncate */, &fd_file));\n+    ASSERT_OK(FileOutputStream::Open(fd_file, &file_));\n+    ASSERT_OK(internal::FileOpenWriteable(file_name, true /* write_only */,\n+                                          false /* truncate */, &fd_stream));\n+    ASSERT_OK(FileOutputStream::Open(fd_stream, &stream_));\n+  }\n \n  protected:\n   std::shared_ptr<FileOutputStream> file_;\n@@ -90,19 +102,27 @@ TEST_F(TestFileOutputStream, FileNameWideCharConversionRangeException) {\n #endif\n \n TEST_F(TestFileOutputStream, DestructorClosesFile) {\n-  int fd;\n-  {\n-    std::shared_ptr<FileOutputStream> file;\n-    ASSERT_OK(FileOutputStream::Open(path_, &file));\n-    fd = file->file_descriptor();\n-  }\n-  ASSERT_TRUE(FileIsClosed(fd));\n-  {\n-    std::shared_ptr<OutputStream> stream;\n-    ASSERT_OK(FileOutputStream::Open(path_, &stream));\n-    fd = std::static_pointer_cast<FileOutputStream>(stream)->file_descriptor();\n-  }\n-  ASSERT_TRUE(FileIsClosed(fd));\n+  int fd_file, fd_stream;\n+\n+  OpenFile();\n+  fd_file = file_->file_descriptor();\n+  fd_stream = std::static_pointer_cast<FileOutputStream>(stream_)->file_descriptor();\n+  ASSERT_FALSE(FileIsClosed(fd_file));\n+  file_.reset();\n+  ASSERT_TRUE(FileIsClosed(fd_file));\n+  ASSERT_FALSE(FileIsClosed(fd_stream));\n+  stream_.reset();\n+  ASSERT_TRUE(FileIsClosed(fd_stream));\n+\n+  OpenFileDescriptor();\n+  fd_file = file_->file_descriptor();\n+  fd_stream = std::static_pointer_cast<FileOutputStream>(stream_)->file_descriptor();\n+  ASSERT_FALSE(FileIsClosed(fd_file));\n+  file_.reset();\n+  ASSERT_TRUE(FileIsClosed(fd_file));\n+  ASSERT_FALSE(FileIsClosed(fd_stream));\n+  stream_.reset();\n+  ASSERT_TRUE(FileIsClosed(fd_stream));\n }\n \n TEST_F(TestFileOutputStream, Close) {\n@@ -132,6 +152,33 @@ TEST_F(TestFileOutputStream, Close) {\n   AssertFileContents(path_, data);\n }\n \n+TEST_F(TestFileOutputStream, FromFileDescriptor) {\n+  OpenFileDescriptor();\n+  stream_.reset();\n+\n+  std::string data1 = \"test\";\n+  ASSERT_OK(file_->Write(data1.data(), data1.size()));\n+  int fd = file_->file_descriptor();\n+  ASSERT_OK(file_->Close());\n+  ASSERT_TRUE(FileIsClosed(fd));\n+\n+  AssertFileContents(path_, data1);\n+\n+  // Re-open at end of file\n+  internal::PlatformFilename file_name;\n+  ASSERT_OK(internal::FileNameFromString(path_, &file_name));\n+  ASSERT_OK(internal::FileOpenWriteable(file_name, true /* write_only */,\n+                                        false /* truncate */, &fd));\n+  ASSERT_OK(internal::FileSeek(fd, 0, SEEK_END));\n+  ASSERT_OK(FileOutputStream::Open(fd, &stream_));\n+\n+  std::string data2 = \"data\";\n+  ASSERT_OK(stream_->Write(data2.data(), data2.size()));\n+  ASSERT_OK(stream_->Close());\n+\n+  AssertFileContents(path_, data1 + data2);\n+}\n+\n TEST_F(TestFileOutputStream, InvalidWrites) {\n   OpenFile();\n \n@@ -225,6 +272,32 @@ TEST_F(TestReadableFile, Close) {\n \n   // Idempotent\n   ASSERT_OK(file_->Close());\n+  ASSERT_TRUE(FileIsClosed(fd));\n+}\n+\n+TEST_F(TestReadableFile, FromFileDescriptor) {\n+  MakeTestFile();\n+\n+  internal::PlatformFilename file_name;\n+  int fd = -2;\n+  ASSERT_OK(internal::FileNameFromString(path_, &file_name));\n+  ASSERT_OK(internal::FileOpenReadable(file_name, &fd));\n+  ASSERT_GE(fd, 0);\n+  ASSERT_OK(internal::FileSeek(fd, 4));\n+\n+  ASSERT_OK(ReadableFile::Open(fd, &file_));\n+  ASSERT_EQ(file_->file_descriptor(), fd);\n+  std::shared_ptr<Buffer> buf;\n+  ASSERT_OK(file_->Read(5, &buf));\n+  ASSERT_EQ(buf->size(), 4);\n+  ASSERT_TRUE(buf->Equals(Buffer(\"data\")));\n+\n+  ASSERT_FALSE(FileIsClosed(fd));\n+  ASSERT_OK(file_->Close());\n+  ASSERT_TRUE(FileIsClosed(fd));\n+  // Idempotent\n+  ASSERT_OK(file_->Close());\n+  ASSERT_TRUE(FileIsClosed(fd));\n }\n \n TEST_F(TestReadableFile, SeekTellSize) {\n@@ -406,6 +479,65 @@ TEST_F(TestReadableFile, ThreadSafety) {\n   ASSERT_EQ(niter * 2, correct_count);\n }\n \n+// ----------------------------------------------------------------------\n+// Pipe I/O tests using FileOutputStream\n+// (cannot test using ReadableFile as it currently requires seeking)\n+\n+class TestPipeIO : public ::testing::Test {\n+ public:\n+  void MakePipe() {\n+    int fd[2];\n+    ASSERT_OK(internal::CreatePipe(fd));\n+    r_ = fd[0];\n+    w_ = fd[1];\n+    ASSERT_GE(r_, 0);\n+    ASSERT_GE(w_, 0);\n+  }\n+  void ClosePipe() {\n+    if (r_ != -1) {\n+      ASSERT_OK(internal::FileClose(r_));\n+      r_ = -1;\n+    }\n+    if (w_ != -1) {\n+      ASSERT_OK(internal::FileClose(w_));\n+      w_ = -1;\n+    }\n+  }\n+  void TearDown() { ClosePipe(); }\n+\n+ protected:\n+  int r_ = -1, w_ = -1;\n+};\n+\n+TEST_F(TestPipeIO, TestWrite) {\n+  std::string data1 = \"test\", data2 = \"data!\";\n+  std::shared_ptr<FileOutputStream> file;\n+  uint8_t buffer[10];\n+  int64_t bytes_read;\n+\n+  MakePipe();\n+  ASSERT_OK(FileOutputStream::Open(w_, &file));\n+  w_ = -1;  // now owned by FileOutputStream\n+\n+  ASSERT_OK(file->Write(data1.data(), data1.size()));\n+  ASSERT_OK(internal::FileRead(r_, buffer, 4, &bytes_read));\n+  ASSERT_EQ(bytes_read, 4);\n+  ASSERT_EQ(0, std::memcmp(buffer, \"test\", 4));\n+\n+  ASSERT_OK(file->Write(data2.data(), data2.size()));\n+  ASSERT_OK(internal::FileRead(r_, buffer, 4, &bytes_read));\n+  ASSERT_EQ(bytes_read, 4);\n+  ASSERT_EQ(0, std::memcmp(buffer, \"data\", 4));\n+\n+  ASSERT_OK(file->Close());\n+  ASSERT_OK(internal::FileRead(r_, buffer, 2, &bytes_read));\n+  ASSERT_EQ(bytes_read, 1);\n+  ASSERT_EQ(0, std::memcmp(buffer, \"!\", 1));\n+  // EOF reached\n+  ASSERT_OK(internal::FileRead(r_, buffer, 2, &bytes_read));\n+  ASSERT_EQ(bytes_read, 0);\n+}\n+\n // ----------------------------------------------------------------------\n // Memory map tests\n \ndiff --git a/cpp/src/arrow/test-util.h b/cpp/src/arrow/test-util.h\nindex 58f82b3484..a046228b5d 100644\n--- a/cpp/src/arrow/test-util.h\n+++ b/cpp/src/arrow/test-util.h\n@@ -20,6 +20,8 @@\n \n #include <algorithm>\n #include <cstdint>\n+#include <cstdlib>\n+#include <iostream>\n #include <limits>\n #include <memory>\n #include <random>\n@@ -70,7 +72,8 @@\n   do {                                   \\\n     ::arrow::Status _s = (s);            \\\n     if (ARROW_PREDICT_FALSE(!_s.ok())) { \\\n-      exit(EXIT_FAILURE);                \\\n+      std::cerr << s.ToString() << \"\\n\"; \\\n+      std::abort();                      \\\n     }                                    \\\n   } while (false);\n \ndiff --git a/cpp/src/arrow/util/io-util.cc b/cpp/src/arrow/util/io-util.cc\nnew file mode 100644\nindex 0000000000..10a30df5e5\n--- /dev/null\n+++ b/cpp/src/arrow/util/io-util.cc\n@@ -0,0 +1,418 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Ensure 64-bit off_t for platforms where it matters\n+#ifdef _FILE_OFFSET_BITS\n+#undef _FILE_OFFSET_BITS\n+#endif\n+\n+#define _FILE_OFFSET_BITS 64\n+\n+#include \"arrow/io/windows_compatibility.h\"\n+\n+#include <algorithm>\n+#include <cerrno>\n+#include <sstream>\n+\n+#include <fcntl.h>\n+#include <string.h>\n+#include <sys/stat.h>\n+#include <sys/types.h>  // IWYU pragma: keep\n+\n+// Defines that don't exist in MinGW\n+#if defined(__MINGW32__)\n+#define ARROW_WRITE_SHMODE S_IRUSR | S_IWUSR\n+#elif defined(_MSC_VER)  // Visual Studio\n+\n+#else  // gcc / clang on POSIX platforms\n+#define ARROW_WRITE_SHMODE S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH\n+#endif\n+\n+// For filename conversion\n+#if defined(_MSC_VER)\n+#include <boost/system/system_error.hpp>  // NOLINT\n+#include <codecvt>\n+#include <locale>\n+#endif\n+\n+// ----------------------------------------------------------------------\n+// file compatibility stuff\n+\n+#if defined(__MINGW32__)  // MinGW\n+// nothing\n+#elif defined(_MSC_VER)  // Visual Studio\n+#include <io.h>\n+#else  // POSIX / Linux\n+// nothing\n+#endif\n+\n+#ifndef _MSC_VER  // POSIX-like platforms\n+#include <unistd.h>\n+#endif  // _MSC_VER\n+\n+// POSIX systems do not have this\n+#ifndef O_BINARY\n+#define O_BINARY 0\n+#endif\n+\n+// define max read/write count\n+#if defined(_MSC_VER)\n+#define ARROW_MAX_IO_CHUNKSIZE INT32_MAX\n+#else\n+\n+#ifdef __APPLE__\n+// due to macOS bug, we need to set read/write max\n+#define ARROW_MAX_IO_CHUNKSIZE INT32_MAX\n+#else\n+// see notes on Linux read/write manpage\n+#define ARROW_MAX_IO_CHUNKSIZE 0x7ffff000\n+#endif\n+\n+#endif\n+\n+#include \"arrow/util/io-util.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+#define CHECK_LSEEK(retval) \\\n+  if ((retval) == -1) return Status::IOError(\"lseek failed\");\n+\n+static inline int64_t lseek64_compat(int fd, int64_t pos, int whence) {\n+#if defined(_MSC_VER)\n+  return _lseeki64(fd, pos, whence);\n+#else\n+  return lseek(fd, pos, whence);\n+#endif\n+}\n+\n+static inline Status CheckFileOpResult(int ret, int errno_actual,\n+                                       const PlatformFilename& file_name,\n+                                       const char* opname) {\n+  if (ret == -1) {\n+    std::stringstream ss;\n+    ss << \"Failed to \" << opname << \" file: \" << file_name.string();\n+    ss << \" , error: \" << std::strerror(errno_actual);\n+    return Status::IOError(ss.str());\n+  }\n+  return Status::OK();\n+}\n+\n+//\n+// File name handling\n+//\n+\n+Status FileNameFromString(const std::string& file_name, PlatformFilename* out) {\n+#if defined(_MSC_VER)\n+  try {\n+    std::codecvt_utf8_utf16<wchar_t> utf16_converter;\n+    out->assign(file_name, utf16_converter);\n+  } catch (boost::system::system_error& e) {\n+    return Status::Invalid(e.what());\n+  }\n+#else\n+  *out = internal::PlatformFilename(file_name);\n+#endif\n+  return Status::OK();\n+}\n+\n+//\n+// Functions for creating file descriptors\n+//\n+\n+Status FileOpenReadable(const PlatformFilename& file_name, int* fd) {\n+  int ret, errno_actual;\n+#if defined(_MSC_VER)\n+  errno_actual = _wsopen_s(fd, file_name.wstring().c_str(), _O_RDONLY | _O_BINARY,\n+                           _SH_DENYNO, _S_IREAD);\n+  ret = *fd;\n+#else\n+  ret = *fd = open(file_name.c_str(), O_RDONLY | O_BINARY);\n+  errno_actual = errno;\n+#endif\n+\n+  return CheckFileOpResult(ret, errno_actual, file_name, \"open local\");\n+}\n+\n+Status FileOpenWriteable(const PlatformFilename& file_name, bool write_only,\n+                         bool truncate, int* fd) {\n+  int ret, errno_actual;\n+\n+#if defined(_MSC_VER)\n+  int oflag = _O_CREAT | _O_BINARY;\n+  int pmode = _S_IWRITE;\n+  if (!write_only) {\n+    pmode |= _S_IREAD;\n+  }\n+\n+  if (truncate) {\n+    oflag |= _O_TRUNC;\n+  }\n+\n+  if (write_only) {\n+    oflag |= _O_WRONLY;\n+  } else {\n+    oflag |= _O_RDWR;\n+  }\n+\n+  errno_actual = _wsopen_s(fd, file_name.wstring().c_str(), oflag, _SH_DENYNO, pmode);\n+  ret = *fd;\n+\n+#else\n+  int oflag = O_CREAT | O_BINARY;\n+\n+  if (truncate) {\n+    oflag |= O_TRUNC;\n+  }\n+\n+  if (write_only) {\n+    oflag |= O_WRONLY;\n+  } else {\n+    oflag |= O_RDWR;\n+  }\n+\n+  ret = *fd = open(file_name.c_str(), oflag, ARROW_WRITE_SHMODE);\n+  errno_actual = errno;\n+#endif\n+  return CheckFileOpResult(ret, errno_actual, file_name, \"open local\");\n+}\n+\n+Status FileTell(int fd, int64_t* pos) {\n+  int64_t current_pos;\n+\n+#if defined(_MSC_VER)\n+  current_pos = _telli64(fd);\n+  if (current_pos == -1) {\n+    return Status::IOError(\"_telli64 failed\");\n+  }\n+#else\n+  current_pos = lseek64_compat(fd, 0, SEEK_CUR);\n+  CHECK_LSEEK(current_pos);\n+#endif\n+\n+  *pos = current_pos;\n+  return Status::OK();\n+}\n+\n+Status CreatePipe(int fd[2]) {\n+  int ret;\n+#if defined(_MSC_VER)\n+  ret = _pipe(fd, 4096, _O_BINARY);\n+#else\n+  ret = pipe(fd);\n+#endif\n+\n+  if (ret == -1) {\n+    return Status::IOError(std::string(\"Error creating pipe: \") +\n+                           std::string(strerror(errno)));\n+  }\n+  return Status::OK();\n+}\n+\n+//\n+// Closing files\n+//\n+\n+Status FileClose(int fd) {\n+  int ret;\n+\n+#if defined(_MSC_VER)\n+  ret = static_cast<int>(_close(fd));\n+#else\n+  ret = static_cast<int>(close(fd));\n+#endif\n+\n+  if (ret == -1) {\n+    return Status::IOError(\"error closing file\");\n+  }\n+  return Status::OK();\n+}\n+\n+//\n+// Seeking and telling\n+//\n+\n+Status FileSeek(int fd, int64_t pos, int whence) {\n+  int64_t ret = lseek64_compat(fd, pos, whence);\n+  CHECK_LSEEK(ret);\n+  return Status::OK();\n+}\n+\n+Status FileSeek(int fd, int64_t pos) { return FileSeek(fd, pos, SEEK_SET); }\n+\n+Status FileGetSize(int fd, int64_t* size) {\n+  int64_t ret;\n+\n+  // XXX Should use fstat() instead, but this function also ensures the\n+  // file is seekable\n+\n+  // Save current position\n+  int64_t current_position = lseek64_compat(fd, 0, SEEK_CUR);\n+  CHECK_LSEEK(current_position);\n+\n+  // Move to end of the file, which returns the file length\n+  ret = lseek64_compat(fd, 0, SEEK_END);\n+  CHECK_LSEEK(ret);\n+\n+  *size = ret;\n+\n+  // Restore file position\n+  ret = lseek64_compat(fd, current_position, SEEK_SET);\n+  CHECK_LSEEK(ret);\n+\n+  return Status::OK();\n+}\n+\n+//\n+// Reading data\n+//\n+\n+static inline int64_t pread_compat(int fd, void* buf, int64_t nbytes, int64_t pos) {\n+#if defined(_MSC_VER)\n+  HANDLE handle = reinterpret_cast<HANDLE>(_get_osfhandle(fd));\n+  DWORD dwBytesRead = 0;\n+  OVERLAPPED overlapped = {0};\n+  overlapped.Offset = static_cast<uint32_t>(pos);\n+  overlapped.OffsetHigh = static_cast<uint32_t>(pos >> 32);\n+\n+  // Note: ReadFile() will update the file position\n+  BOOL bRet =\n+      ReadFile(handle, buf, static_cast<uint32_t>(nbytes), &dwBytesRead, &overlapped);\n+  if (bRet || GetLastError() == ERROR_HANDLE_EOF) {\n+    return dwBytesRead;\n+  } else {\n+    return -1;\n+  }\n+#else\n+  return static_cast<int64_t>(\n+      pread(fd, buf, static_cast<size_t>(nbytes), static_cast<off_t>(pos)));\n+#endif\n+}\n+\n+Status FileRead(int fd, uint8_t* buffer, int64_t nbytes, int64_t* bytes_read) {\n+  *bytes_read = 0;\n+\n+  while (*bytes_read < nbytes) {\n+    int64_t chunksize =\n+        std::min(static_cast<int64_t>(ARROW_MAX_IO_CHUNKSIZE), nbytes - *bytes_read);\n+#if defined(_MSC_VER)\n+    int64_t ret =\n+        static_cast<int64_t>(_read(fd, buffer, static_cast<uint32_t>(chunksize)));\n+#else\n+    int64_t ret = static_cast<int64_t>(read(fd, buffer, static_cast<size_t>(chunksize)));\n+#endif\n+\n+    if (ret == -1) {\n+      *bytes_read = ret;\n+      break;\n+    }\n+    if (ret == 0) {\n+      // EOF\n+      break;\n+    }\n+    buffer += ret;\n+    *bytes_read += ret;\n+  }\n+\n+  if (*bytes_read == -1) {\n+    return Status::IOError(std::string(\"Error reading bytes from file: \") +\n+                           std::string(strerror(errno)));\n+  }\n+\n+  return Status::OK();\n+}\n+\n+Status FileReadAt(int fd, uint8_t* buffer, int64_t position, int64_t nbytes,\n+                  int64_t* bytes_read) {\n+  *bytes_read = 0;\n+\n+  while (*bytes_read < nbytes) {\n+    int64_t chunksize =\n+        std::min(static_cast<int64_t>(ARROW_MAX_IO_CHUNKSIZE), nbytes - *bytes_read);\n+    int64_t ret = pread_compat(fd, buffer, chunksize, position);\n+\n+    if (ret == -1) {\n+      *bytes_read = ret;\n+      break;\n+    }\n+    if (ret == 0) {\n+      // EOF\n+      break;\n+    }\n+    buffer += ret;\n+    position += ret;\n+    *bytes_read += ret;\n+  }\n+\n+  if (*bytes_read == -1) {\n+    return Status::IOError(std::string(\"Error reading bytes from file: \") +\n+                           std::string(strerror(errno)));\n+  }\n+  return Status::OK();\n+}\n+\n+//\n+// Writing data\n+//\n+\n+Status FileWrite(int fd, const uint8_t* buffer, const int64_t nbytes) {\n+  int ret = 0;\n+  int64_t bytes_written = 0;\n+\n+  while (ret != -1 && bytes_written < nbytes) {\n+    int64_t chunksize =\n+        std::min(static_cast<int64_t>(ARROW_MAX_IO_CHUNKSIZE), nbytes - bytes_written);\n+#if defined(_MSC_VER)\n+    ret = static_cast<int>(\n+        _write(fd, buffer + bytes_written, static_cast<uint32_t>(chunksize)));\n+#else\n+    ret = static_cast<int>(\n+        write(fd, buffer + bytes_written, static_cast<size_t>(chunksize)));\n+#endif\n+\n+    if (ret != -1) {\n+      bytes_written += ret;\n+    }\n+  }\n+\n+  if (ret == -1) {\n+    return Status::IOError(std::string(\"Error writing bytes from file: \") +\n+                           std::string(strerror(errno)));\n+  }\n+  return Status::OK();\n+}\n+\n+Status FileTruncate(int fd, const int64_t size) {\n+  int ret, errno_actual;\n+\n+#ifdef _MSC_VER\n+  errno_actual = _chsize_s(fd, static_cast<size_t>(size));\n+  ret = errno_actual == 0 ? 0 : -1;\n+#else\n+  ret = ftruncate(fd, static_cast<size_t>(size));\n+  errno_actual = errno;\n+#endif\n+\n+  if (ret == -1) {\n+    return Status::IOError(std::string(\"Error truncating file: \") +\n+                           std::string(strerror(errno_actual)));\n+  }\n+  return Status::OK();\n+}\n+\n+}  // namespace internal\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/util/io-util.h b/cpp/src/arrow/util/io-util.h\nindex 2a01be1044..e857490c95 100644\n--- a/cpp/src/arrow/util/io-util.h\n+++ b/cpp/src/arrow/util/io-util.h\n@@ -20,11 +20,16 @@\n \n #include <iostream>\n #include <memory>\n+#include <string>\n \n #include \"arrow/buffer.h\"\n #include \"arrow/io/interfaces.h\"\n #include \"arrow/status.h\"\n \n+#if defined(_MSC_VER)\n+#include <boost/filesystem.hpp>  // NOLINT\n+#endif\n+\n namespace arrow {\n namespace io {\n \n@@ -113,6 +118,52 @@ class StdinStream : public InputStream {\n };\n \n }  // namespace io\n+\n+namespace internal {\n+\n+#if defined(_MSC_VER)\n+// namespace fs = boost::filesystem;\n+// #define PlatformFilename fs::path\n+typedef ::boost::filesystem::path PlatformFilename;\n+\n+#else\n+\n+struct PlatformFilename {\n+  PlatformFilename() {}\n+  explicit PlatformFilename(const std::string& path) { utf8_path = path; }\n+\n+  const char* c_str() const { return utf8_path.c_str(); }\n+\n+  const std::string& string() const { return utf8_path; }\n+\n+  size_t length() const { return utf8_path.size(); }\n+\n+  std::string utf8_path;\n+};\n+#endif\n+\n+Status FileNameFromString(const std::string& file_name, PlatformFilename* out);\n+\n+Status FileOpenReadable(const PlatformFilename& file_name, int* fd);\n+Status FileOpenWriteable(const PlatformFilename& file_name, bool write_only,\n+                         bool truncate, int* fd);\n+\n+Status FileRead(int fd, uint8_t* buffer, const int64_t nbytes, int64_t* bytes_read);\n+Status FileReadAt(int fd, uint8_t* buffer, int64_t position, int64_t nbytes,\n+                  int64_t* bytes_read);\n+Status FileWrite(int fd, const uint8_t* buffer, const int64_t nbytes);\n+Status FileTruncate(int fd, const int64_t size);\n+\n+Status FileTell(int fd, int64_t* pos);\n+Status FileSeek(int fd, int64_t pos);\n+Status FileSeek(int fd, int64_t pos, int whence);\n+Status FileGetSize(int fd, int64_t* size);\n+\n+Status FileClose(int fd);\n+\n+Status CreatePipe(int fd[2]);\n+\n+}  // namespace internal\n }  // namespace arrow\n \n #endif  // ARROW_UTIL_IO_UTIL_H\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-21T14:05:19.824+0000",
                    "updated": "2018-04-21T14:05:19.824+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13071628/comment/16446815",
                    "id": "16446815",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "body": "Issue resolved by pull request 1909\n[https://github.com/apache/arrow/pull/1909]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "created": "2018-04-21T14:05:36.919+0000",
                    "updated": "2018-04-21T14:05:36.919+0000"
                }
            ],
            "maxResults": 4,
            "total": 4,
            "startAt": 0
        },
        "customfield_12311820": "0|i3ewxr:",
        "customfield_12314139": null
    }
}