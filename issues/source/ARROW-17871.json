{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13483547",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547",
    "key": "ARROW-17871",
    "fields": {
        "parent": {
            "id": "13483546",
            "key": "ARROW-17870",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13483546",
            "fields": {
                "summary": "[Go] Add Scalar Binary Arithmetic",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/3",
                    "description": "This issue is being actively worked on at the moment by the assignee.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/inprogress.png",
                    "name": "In Progress",
                    "id": "3",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/4",
                        "id": 4,
                        "key": "indeterminate",
                        "colorName": "yellow",
                        "name": "In Progress"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                    "id": "2",
                    "description": "A new feature of the product, which has yet to be developed.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                    "name": "New Feature",
                    "subtask": false,
                    "avatarId": 21141
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12352360",
                "id": "12352360",
                "description": "",
                "name": "11.0.0",
                "archived": false,
                "released": false
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=zeroshade",
            "name": "zeroshade",
            "key": "zeroshade",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=zeroshade&avatarId=31230",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=zeroshade&avatarId=31230",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=zeroshade&avatarId=31230",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=zeroshade&avatarId=31230"
            },
            "displayName": "Matthew Topol",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333772",
                "id": "12333772",
                "name": "Go"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=zeroshade",
            "name": "zeroshade",
            "key": "zeroshade",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=zeroshade&avatarId=31230",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=zeroshade&avatarId=31230",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=zeroshade&avatarId=31230",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=zeroshade&avatarId=31230"
            },
            "displayName": "Matthew Topol",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=zeroshade",
            "name": "zeroshade",
            "key": "zeroshade",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=zeroshade&avatarId=31230",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=zeroshade&avatarId=31230",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=zeroshade&avatarId=31230",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=zeroshade&avatarId=31230"
            },
            "displayName": "Matthew Topol",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 40200,
            "total": 40200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 40200,
            "total": 40200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17871/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 67,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812662",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade opened a new pull request, #14255:\nURL: https://github.com/apache/arrow/pull/14255\n\n   Only implements Addition and Subtraction for integral types and float32/float64. Temporal types and others will come afterwards.\n\n\n",
                    "created": "2022-09-27T21:38:30.406+0000",
                    "updated": "2022-09-27T21:38:30.406+0000",
                    "started": "2022-09-27T21:38:30.406+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812662",
                    "issueId": "13483547"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812758",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on code in PR #14255:\nURL: https://github.com/apache/arrow/pull/14255#discussion_r981984818\n\n\n##########\ngo/arrow/compute/internal/kernels/_lib/base_arithmetic_avx2_amd64.s:\n##########\n@@ -0,0 +1,12469 @@\n+\t.text\n+\t.intel_syntax noprefix\n+\t.file\t\"base_arithmetic.cc\"\n+\t.globl\tarithmetic_avx2                 # ",
                    "created": "2022-09-28T06:41:13.775+0000",
                    "updated": "2022-09-28T06:41:13.775+0000",
                    "started": "2022-09-28T06:41:13.774+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812758",
                    "issueId": "13483547"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812845",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #14255:\nURL: https://github.com/apache/arrow/pull/14255#discussion_r982232766\n\n\n##########\ngo/arrow/compute/arithmetic.go:\n##########\n@@ -0,0 +1,155 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package compute\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/kernels\"\n+)\n+\n+type arithmeticFunction struct {\n+\tScalarFunction\n+}\n+\n+func (fn *arithmeticFunction) checkDecimals(vals ...arrow.DataType) error {\n+\tif !hasDecimal(vals...) {\n+\t\treturn nil\n+\t}\n+\n+\tif len(vals) != 2 {\n+\t\treturn nil\n+\t}\n+\n+\top := fn.name[:strings.Index(fn.name, \"_\")]\n\nReview Comment:\n   Using string comparison for this is a bit weird, no? Can't you have `arithmeticFunction` be some kind of polymorphic type with different implementations of argument promotion for each subtype/implementation/whatever?\n\n\n\n",
                    "created": "2022-09-28T10:32:12.785+0000",
                    "updated": "2022-09-28T10:32:12.785+0000",
                    "started": "2022-09-28T10:32:12.784+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812845",
                    "issueId": "13483547"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812848",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #14255:\nURL: https://github.com/apache/arrow/pull/14255#discussion_r982232984\n\n\n##########\ngo/arrow/compute/arithmetic.go:\n##########\n@@ -0,0 +1,155 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package compute\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/kernels\"\n+)\n+\n+type arithmeticFunction struct {\n+\tScalarFunction\n+}\n+\n+func (fn *arithmeticFunction) checkDecimals(vals ...arrow.DataType) error {\n+\tif !hasDecimal(vals...) {\n+\t\treturn nil\n+\t}\n+\n+\tif len(vals) != 2 {\n+\t\treturn nil\n+\t}\n+\n+\top := fn.name[:strings.Index(fn.name, \"_\")]\n\nReview Comment:\n   Using string comparison for this is a bit weird, no? Can't you have `arithmeticFunction` be some kind of polymorphic type with different implementations of argument promotion for each subtype/implementation/whatever?\n\n\n\n##########\ngo/arrow/compute/arithmetic.go:\n##########\n@@ -0,0 +1,155 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package compute\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/kernels\"\n+)\n+\n+type arithmeticFunction struct {\n+\tScalarFunction\n+}\n+\n+func (fn *arithmeticFunction) checkDecimals(vals ...arrow.DataType) error {\n+\tif !hasDecimal(vals...) {\n+\t\treturn nil\n+\t}\n+\n+\tif len(vals) != 2 {\n+\t\treturn nil\n+\t}\n+\n+\top := fn.name[:strings.Index(fn.name, \"_\")]\n+\tswitch op {\n+\tcase \"add\", \"subtract\":\n+\t\treturn castBinaryDecimalArgs(decPromoteAdd, vals...)\n+\tcase \"multiply\":\n+\t\treturn castBinaryDecimalArgs(decPromoteMultiply, vals...)\n+\tcase \"divide\":\n+\t\treturn castBinaryDecimalArgs(decPromoteDivide, vals...)\n+\tdefault:\n+\t\treturn fmt.Errorf(\"%w: invalid decimal function: %s\", arrow.ErrInvalid, fn.name)\n+\t}\n+}\n+\n+func (fn *arithmeticFunction) DispatchBest(vals ...arrow.DataType) (exec.Kernel, error) {\n+\tif err := fn.checkArity(len(vals)); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif err := fn.checkDecimals(vals...); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif kn, err := fn.DispatchExact(vals...); err == nil {\n+\t\treturn kn, nil\n+\t}\n+\n+\tensureDictionaryDecoded(vals...)\n+\n+\t// only promote types for binary funcs\n+\tif len(vals) == 2 {\n+\t\treplaceNullWithOtherType(vals...)\n+\t\tif unit, istime := commonTemporalResolution(vals...); istime {\n+\t\t\treplaceTemporalTypes(unit, vals...)\n+\t\t} else {\n+\t\t\tif dt := commonNumeric(vals...); dt != nil {\n+\t\t\t\treplaceTypes(dt, vals...)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn fn.DispatchExact(vals...)\n+}\n+\n+var (\n+\taddDoc FunctionDoc\n+)\n+\n+func RegisterScalarArithmetic(reg FunctionRegistry) {\n+\taddFn := &arithmeticFunction{*NewScalarFunction(\"add\", Binary(), addDoc)}\n+\tfor _, k := range kernels.GetArithmeticKernels(kernels.OpAdd) {\n+\t\tif err := addFn.AddKernel(k); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}\n+\n+\treg.AddFunction(addFn, false)\n+\n+\taddCheckedFn := &arithmeticFunction{*NewScalarFunction(\"add_checked\", Binary(), addDoc)}\n\nReview Comment:\n   I don't know how much you want to follow the C++ design but one mistake we made is that the \"default\" arithmetic functions are unchecked.\r\n   If I were to do it again I'd have \"add\" (checked) and \"add_unchecked\".\n\n\n\n##########\ngo/arrow/compute/arithmetic_test.go:\n##########\n@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package compute_test\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/array\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/apache/arrow/go/v10/arrow/scalar\"\n+\t\"github.com/stretchr/testify/suite\"\n+)\n+\n+type binaryFunc = func(context.Context, compute.ArithmeticOptions, compute.Datum, compute.Datum) (compute.Datum, error)\n+\n+type BinaryArithmeticSuite[T exec.NumericTypes] struct {\n+\tsuite.Suite\n+\n+\tmem  *memory.CheckedAllocator\n+\topts compute.ArithmeticOptions\n+\tctx  context.Context\n+}\n+\n+func (BinaryArithmeticSuite[T]) DataType() arrow.DataType {\n+\treturn exec.GetDataType[T]()\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) SetupTest() {\n+\tb.mem = memory.NewCheckedAllocator(memory.DefaultAllocator)\n+\tb.opts.CheckOverflow = false\n+\tb.ctx = compute.WithAllocator(context.TODO(), b.mem)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) TearDownTest() {\n+\tb.mem.AssertSize(b.T(), 0)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeNullScalar() scalar.Scalar {\n+\treturn scalar.MakeNullScalar(b.DataType())\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeScalar(val T) scalar.Scalar {\n+\treturn scalar.MakeScalar(val)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalars(fn binaryFunc, lhs, rhs T, expected T) {\n+\tleft, right := b.makeScalar(lhs), b.makeScalar(rhs)\n+\texp := b.makeScalar(expected)\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: left}, &compute.ScalarDatum{Value: right})\n+\tb.NoError(err)\n+\tsc := actual.(*compute.ScalarDatum).Value\n+\n+\tb.Truef(scalar.Equals(exp, sc), \"expected: %s\\ngot: %s\", exp, sc)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScArr(fn binaryFunc, lhs T, rhs, expected string) {\n\nReview Comment:\n   \"Sc\" vs \"Scalar\" is not really meaningful to the reader.\n\n\n\n##########\ngo/arrow/compute/arithmetic_test.go:\n##########\n@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package compute_test\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/array\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/apache/arrow/go/v10/arrow/scalar\"\n+\t\"github.com/stretchr/testify/suite\"\n+)\n+\n+type binaryFunc = func(context.Context, compute.ArithmeticOptions, compute.Datum, compute.Datum) (compute.Datum, error)\n+\n+type BinaryArithmeticSuite[T exec.NumericTypes] struct {\n+\tsuite.Suite\n+\n+\tmem  *memory.CheckedAllocator\n+\topts compute.ArithmeticOptions\n+\tctx  context.Context\n+}\n+\n+func (BinaryArithmeticSuite[T]) DataType() arrow.DataType {\n+\treturn exec.GetDataType[T]()\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) SetupTest() {\n+\tb.mem = memory.NewCheckedAllocator(memory.DefaultAllocator)\n+\tb.opts.CheckOverflow = false\n+\tb.ctx = compute.WithAllocator(context.TODO(), b.mem)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) TearDownTest() {\n+\tb.mem.AssertSize(b.T(), 0)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeNullScalar() scalar.Scalar {\n+\treturn scalar.MakeNullScalar(b.DataType())\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeScalar(val T) scalar.Scalar {\n+\treturn scalar.MakeScalar(val)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalars(fn binaryFunc, lhs, rhs T, expected T) {\n+\tleft, right := b.makeScalar(lhs), b.makeScalar(rhs)\n+\texp := b.makeScalar(expected)\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: left}, &compute.ScalarDatum{Value: right})\n+\tb.NoError(err)\n+\tsc := actual.(*compute.ScalarDatum).Value\n+\n+\tb.Truef(scalar.Equals(exp, sc), \"expected: %s\\ngot: %s\", exp, sc)\n\nReview Comment:\n   I think you want to define helper testers/assertions for this ASAP, otherwise you'll write such assertions a lot in your test code.\n\n\n\n##########\ngo/arrow/compute/arithmetic_test.go:\n##########\n@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package compute_test\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/array\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/apache/arrow/go/v10/arrow/scalar\"\n+\t\"github.com/stretchr/testify/suite\"\n+)\n+\n+type binaryFunc = func(context.Context, compute.ArithmeticOptions, compute.Datum, compute.Datum) (compute.Datum, error)\n+\n+type BinaryArithmeticSuite[T exec.NumericTypes] struct {\n+\tsuite.Suite\n+\n+\tmem  *memory.CheckedAllocator\n+\topts compute.ArithmeticOptions\n+\tctx  context.Context\n+}\n+\n+func (BinaryArithmeticSuite[T]) DataType() arrow.DataType {\n+\treturn exec.GetDataType[T]()\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) SetupTest() {\n+\tb.mem = memory.NewCheckedAllocator(memory.DefaultAllocator)\n+\tb.opts.CheckOverflow = false\n+\tb.ctx = compute.WithAllocator(context.TODO(), b.mem)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) TearDownTest() {\n+\tb.mem.AssertSize(b.T(), 0)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeNullScalar() scalar.Scalar {\n+\treturn scalar.MakeNullScalar(b.DataType())\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeScalar(val T) scalar.Scalar {\n+\treturn scalar.MakeScalar(val)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalars(fn binaryFunc, lhs, rhs T, expected T) {\n+\tleft, right := b.makeScalar(lhs), b.makeScalar(rhs)\n+\texp := b.makeScalar(expected)\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: left}, &compute.ScalarDatum{Value: right})\n+\tb.NoError(err)\n+\tsc := actual.(*compute.ScalarDatum).Value\n+\n+\tb.Truef(scalar.Equals(exp, sc), \"expected: %s\\ngot: %s\", exp, sc)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScArr(fn binaryFunc, lhs T, rhs, expected string) {\n+\tleft := b.makeScalar(lhs)\n+\tb.assertBinopScalarArr(fn, left, rhs, expected)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalarArr(fn binaryFunc, lhs scalar.Scalar, rhs, expected string) {\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: lhs}, &compute.ArrayDatum{Value: right.Data()})\n+\tb.NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: exp.Data()}, actual)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrSc(fn binaryFunc, lhs string, rhs T, expected string) {\n\nReview Comment:\n   Same here.\n\n\n\n##########\ngo/arrow/compute/arithmetic_test.go:\n##########\n@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package compute_test\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/array\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/apache/arrow/go/v10/arrow/scalar\"\n+\t\"github.com/stretchr/testify/suite\"\n+)\n+\n+type binaryFunc = func(context.Context, compute.ArithmeticOptions, compute.Datum, compute.Datum) (compute.Datum, error)\n+\n+type BinaryArithmeticSuite[T exec.NumericTypes] struct {\n+\tsuite.Suite\n+\n+\tmem  *memory.CheckedAllocator\n+\topts compute.ArithmeticOptions\n+\tctx  context.Context\n+}\n+\n+func (BinaryArithmeticSuite[T]) DataType() arrow.DataType {\n+\treturn exec.GetDataType[T]()\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) SetupTest() {\n+\tb.mem = memory.NewCheckedAllocator(memory.DefaultAllocator)\n+\tb.opts.CheckOverflow = false\n+\tb.ctx = compute.WithAllocator(context.TODO(), b.mem)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) TearDownTest() {\n+\tb.mem.AssertSize(b.T(), 0)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeNullScalar() scalar.Scalar {\n+\treturn scalar.MakeNullScalar(b.DataType())\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeScalar(val T) scalar.Scalar {\n+\treturn scalar.MakeScalar(val)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalars(fn binaryFunc, lhs, rhs T, expected T) {\n+\tleft, right := b.makeScalar(lhs), b.makeScalar(rhs)\n+\texp := b.makeScalar(expected)\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: left}, &compute.ScalarDatum{Value: right})\n+\tb.NoError(err)\n+\tsc := actual.(*compute.ScalarDatum).Value\n+\n+\tb.Truef(scalar.Equals(exp, sc), \"expected: %s\\ngot: %s\", exp, sc)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScArr(fn binaryFunc, lhs T, rhs, expected string) {\n+\tleft := b.makeScalar(lhs)\n+\tb.assertBinopScalarArr(fn, left, rhs, expected)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalarArr(fn binaryFunc, lhs scalar.Scalar, rhs, expected string) {\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: lhs}, &compute.ArrayDatum{Value: right.Data()})\n+\tb.NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: exp.Data()}, actual)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrSc(fn binaryFunc, lhs string, rhs T, expected string) {\n+\tright := b.makeScalar(rhs)\n+\tb.assertBinopArrScalar(fn, lhs, right, expected)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrScalar(fn binaryFunc, lhs string, rhs scalar.Scalar, expected string) {\n+\tleft, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(lhs))\n+\tdefer left.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ArrayDatum{Value: left.Data()}, &compute.ScalarDatum{Value: rhs})\n+\tb.NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: exp.Data()}, actual)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrays(fn binaryFunc, lhs, rhs, expected string) {\n+\tleft, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(lhs))\n+\tdefer left.Release()\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tb.assertBinop(fn, left, right, exp)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinop(fn binaryFunc, left, right, expected arrow.Array) {\n+\tactual, err := fn(b.ctx, b.opts, &compute.ArrayDatum{Value: left.Data()}, &compute.ArrayDatum{Value: right.Data()})\n+\tb.Require().NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: expected.Data()}, actual)\n+\n+\t// also check (Scalar, Scalar) operations\n+\tfor i := 0; i < expected.Len(); i++ {\n+\t\ts, err := scalar.GetScalar(expected, i)\n+\t\tb.Require().NoError(err)\n+\t\tlhs, _ := scalar.GetScalar(left, i)\n+\t\trhs, _ := scalar.GetScalar(right, i)\n+\n+\t\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: lhs}, &compute.ScalarDatum{Value: rhs})\n+\t\tb.NoError(err)\n+\t\tb.Truef(scalar.Equals(s, actual.(*compute.ScalarDatum).Value), \"expected: %s\\ngot: %s\", s, actual)\n+\t}\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) setOverflowCheck(value bool) {\n+\tb.opts.CheckOverflow = value\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopErr(fn binaryFunc, lhs, rhs, expectedMsg string) {\n+\tleft, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(lhs))\n+\tdefer left.Release()\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\n+\t_, err := fn(b.ctx, b.opts, &compute.ArrayDatum{left.Data()}, &compute.ArrayDatum{Value: right.Data()})\n+\tb.ErrorIs(err, arrow.ErrInvalid)\n+\tb.ErrorContains(err, expectedMsg)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) TestAdd() {\n+\tb.Run(b.DataType().String(), func() {\n+\t\tfor _, overflow := range []bool{false, true} {\n+\t\t\tb.Run(fmt.Sprintf(\"overflow=%t\", overflow), func() {\n+\t\t\t\tb.setOverflowCheck(overflow)\n+\n+\t\t\t\tb.assertBinopArrays(compute.Add, `[]`, `[]`, `[]`)\n+\t\t\t\tb.assertBinopArrays(compute.Add, `[3, 2, 6]`, `[1, 0, 2]`, `[4, 2, 8]`)\n+\t\t\t\t// nulls on one side\n+\t\t\t\tb.assertBinopArrays(compute.Add, `[null, 1, null]`, `[3, 4, 5]`, `[null, 5, null]`)\n+\t\t\t\tb.assertBinopArrays(compute.Add, `[3, 4, 5]`, `[null, 1, null]`, `[null, 5, null]`)\n+\t\t\t\t// nulls on both sides\n+\t\t\t\tb.assertBinopArrays(compute.Add, `[null, 1, 2]`, `[3, 4, null]`, `[null, 5, null]`)\n+\t\t\t\t// all nulls\n+\t\t\t\tb.assertBinopArrays(compute.Add, `[null]`, `[null]`, `[null]`)\n+\n+\t\t\t\t// scalar on the left\n+\t\t\t\tb.assertBinopScArr(compute.Add, 3, `[1, 2]`, `[4, 5]`)\n+\t\t\t\tb.assertBinopScArr(compute.Add, 3, `[null, 2]`, `[null, 5]`)\n+\t\t\t\tb.assertBinopScalarArr(compute.Add, b.makeNullScalar(), `[1, 2]`, `[null, null]`)\n+\t\t\t\tb.assertBinopScalarArr(compute.Add, b.makeNullScalar(), `[null, 2]`, `[null, null]`)\n+\t\t\t\t// scalar on the right\n+\t\t\t\tb.assertBinopArrSc(compute.Add, `[1, 2]`, 3, `[4, 5]`)\n+\t\t\t\tb.assertBinopArrSc(compute.Add, `[null, 2]`, 3, `[null, 5]`)\n+\t\t\t\tb.assertBinopArrScalar(compute.Add, `[1, 2]`, b.makeNullScalar(), `[null, null]`)\n+\t\t\t\tb.assertBinopArrScalar(compute.Add, `[null, 2]`, b.makeNullScalar(), `[null, null]`)\n+\t\t\t})\n+\t\t}\n+\t})\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) TestSub() {\n+\tb.Run(b.DataType().String(), func() {\n+\t\tfor _, overflow := range []bool{false, true} {\n+\t\t\tb.Run(fmt.Sprintf(\"overflow=%t\", overflow), func() {\n+\t\t\t\tb.setOverflowCheck(overflow)\n+\n+\t\t\t\tb.assertBinopArrays(compute.Subtract, `[]`, `[]`, `[]`)\n+\t\t\t\tb.assertBinopArrays(compute.Subtract, `[3, 2, 6]`, `[1, 0, 2]`, `[2, 2, 4]`)\n+\t\t\t\t// nulls on one side\n+\t\t\t\tb.assertBinopArrays(compute.Subtract, `[null, 4, null]`, `[2, 1, 0]`, `[null, 3, null]`)\n+\t\t\t\tb.assertBinopArrays(compute.Subtract, `[3, 4, 5]`, `[null, 1, null]`, `[null, 3, null]`)\n+\t\t\t\t// nulls on both sides\n+\t\t\t\tb.assertBinopArrays(compute.Subtract, `[null, 4, 3]`, `[2, 1, null]`, `[null, 3, null]`)\n+\t\t\t\t// all nulls\n+\t\t\t\tb.assertBinopArrays(compute.Subtract, `[null]`, `[null]`, `[null]`)\n+\n+\t\t\t\t// scalar on the left\n+\t\t\t\tb.assertBinopScArr(compute.Subtract, 3, `[1, 2]`, `[2, 1]`)\n+\t\t\t\tb.assertBinopScArr(compute.Subtract, 3, `[null, 2]`, `[null, 1]`)\n+\t\t\t\tb.assertBinopScalarArr(compute.Subtract, b.makeNullScalar(), `[1, 2]`, `[null, null]`)\n+\t\t\t\tb.assertBinopScalarArr(compute.Subtract, b.makeNullScalar(), `[null, 2]`, `[null, null]`)\n+\t\t\t\t// scalar on the right\n+\t\t\t\tb.assertBinopArrSc(compute.Subtract, `[4, 5]`, 3, `[1, 2]`)\n+\t\t\t\tb.assertBinopArrSc(compute.Subtract, `[null, 5]`, 3, `[null, 2]`)\n+\t\t\t\tb.assertBinopArrScalar(compute.Subtract, `[1, 2]`, b.makeNullScalar(), `[null, null]`)\n+\t\t\t\tb.assertBinopArrScalar(compute.Subtract, `[null, 2]`, b.makeNullScalar(), `[null, null]`)\n+\t\t\t})\n+\t\t}\n+\t})\n+}\n+\n+func TestBinaryArithmetic(t *testing.T) {\n+\tsuite.Run(t, new(BinaryArithmeticSuite[int8]))\n\nReview Comment:\n   Is there a way of looping other those types?\r\n   \r\n   Also, you need not necessarily use generics if you can simply define the datatype at runtime (which you can certainly do!). This can cut down on compile times in addition to allow easier looping on datatypes of choice (including parametric types such as temporals).\n\n\n\n##########\ngo/arrow/compute/internal/exec/utils.go:\n##########\n@@ -172,6 +179,11 @@ func GetDataType[T NumericTypes | bool | string]() arrow.DataType {\n \treturn typMap[reflect.TypeOf(z)]\n }\n \n+func GetType[T NumericTypes | bool | string]() arrow.Type {\n+\tvar z T\n+\treturn typMap[reflect.TypeOf(z)].ID()\n\nReview Comment:\n   Does this happen purely at compile time or is there an actual map lookup at runtime?\n\n\n\n##########\ngo/arrow/compute/internal/kernels/_lib/types.h:\n##########\n@@ -0,0 +1,477 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// corresponds to datatype.go's arrow.Type\n+enum class arrtype : int {\n+    NULL,\n+    BOOL,\n+    UINT8,\n+    INT8,\n+    UINT16,\n+    INT16,\n+    UINT32,\n+    INT32,\n+    UINT64,\n+    INT64,\n+    FLOAT16,\n+    FLOAT32,\n+    FLOAT64\n+};\n+\n+// The following is copied from <type_traits> since we use -target \n\nReview Comment:\n   Copied from where exactly? What is the license?\n\n\n\n##########\ngo/arrow/compute/internal/kernels/base_arithmetic.go:\n##########\n@@ -0,0 +1,141 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package kernels\n+\n+import (\n+\t\"fmt\"\n+\t\"math/bits\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/internal/debug\"\n+\t\"golang.org/x/exp/constraints\"\n+)\n+\n+type ArithmeticOp int8\n+\n+const (\n+\tOpAdd ArithmeticOp = iota\n+\tOpAddChecked\n+\tOpSub\n+\tOpSubChecked\n+)\n+\n+func getGoArithmeticBinaryOpsFloating[T constraints.Float](op ArithmeticOp) binaryOps[T, T, T] {\n\nReview Comment:\n   Why is this needed in addition to the C++ versions?\n\n\n\n##########\ngo/arrow/compute/internal/kernels/_lib/base_arithmetic.cc:\n##########\n@@ -0,0 +1,255 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <arch.h>\n+#include <stdint.h>\n+#include \"types.h\"\n+#include \"vendored/safe-math.h\"\n+\n+// Define functions AddWithOverflow, SubtractWithOverflow, MultiplyWithOverflow\n+// with the signature `bool(T u, T v, T* out)` where T is an integer type.\n+// On overflow, these functions return true.  Otherwise, false is returned\n+// and `out` is updated with the result of the operation.\n+\n+#define OP_WITH_OVERFLOW(_func_name, _psnip_op, _type, _psnip_type) \\\n+  static inline bool _func_name(_type u, _type v, _type* out) {     \\\n+    return !psnip_safe_##_psnip_type##_##_psnip_op(out, u, v);      \\\n+  }\n+\n+#define OPS_WITH_OVERFLOW(_func_name, _psnip_op)            \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int8_t, int8)     \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int16_t, int16)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int32_t, int32)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int64_t, int64)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint8_t, uint8)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint16_t, uint16) \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint32_t, uint32) \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint64_t, uint64)\n+\n+OPS_WITH_OVERFLOW(AddWithOverflow, add)\n+OPS_WITH_OVERFLOW(SubtractWithOverflow, sub)\n+OPS_WITH_OVERFLOW(MultiplyWithOverflow, mul)\n+OPS_WITH_OVERFLOW(DivideWithOverflow, div)\n+\n+// Corresponds to equivalent ArithmeticOp enum in base_arithmetic.go\n+// for passing across which operation to perform. This allows simpler\n+// implementation at the cost of having to pass the extra int8 and\n+// perform a switch.\n+//\n+// In cases of small arrays, this is completely negligible. In cases\n+// of large arrays, the time saved by using SIMD here is significantly\n+// worth the cost.\n+enum class optype : int8_t {\n+    ADD,\n+    ADD_CHECKED,\n+    SUB, \n+    SUB_CHECKED,\n+};\n+\n+template <typename T>\n+using is_unsigned_integer_value = bool_constant<is_integral_v<T> && is_unsigned_v<T>>;\n+\n+template <typename T>\n+using is_signed_integer_value = bool_constant<is_integral_v<T> && is_signed_v<T>>;\n+\n+template <typename T, typename R = T>\n+using enable_if_signed_integer_t = enable_if_t<is_signed_integer_value<T>::value, R>;\n+\n+template <typename T, typename R = T>\n+using enable_if_unsigned_integer_t = enable_if_t<is_unsigned_integer_value<T>::value, R>;\n+\n+template <typename T, typename R = T>\n+using enable_if_integer_t = enable_if_t<\n+    is_signed_integer_value<T>::value || is_unsigned_integer_value<T>::value, R>;\n+\n+template <typename T, typename R = T>\n+using enable_if_floating_t = enable_if_t<is_floating_point_v<T>, R>;\n+\n+struct Add {\n\nReview Comment:\n   You copied this directly from the Arrow C++ source code?\r\n   Because now you can use C++17 features which will allow writing neater code, as @cyb70289 alluded to below.\r\n   \n\n\n\n##########\ngo/arrow/compute/internal/kernels/_lib/base_arithmetic_avx2_amd64.s:\n##########\n@@ -0,0 +1,12469 @@\n+\t.text\n\nReview Comment:\n   Can you mark generated files generated?\r\n   https://docs.github.com/en/repositories/working-with-files/managing-files/customizing-how-changed-files-appear-on-github\n\n\n\n##########\ngo/arrow/compute/internal/kernels/base_arithmetic.go:\n##########\n@@ -0,0 +1,141 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package kernels\n+\n+import (\n+\t\"fmt\"\n+\t\"math/bits\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/internal/debug\"\n+\t\"golang.org/x/exp/constraints\"\n+)\n+\n+type ArithmeticOp int8\n+\n+const (\n+\tOpAdd ArithmeticOp = iota\n+\tOpAddChecked\n+\tOpSub\n+\tOpSubChecked\n+)\n+\n+func getGoArithmeticBinaryOpsFloating[T constraints.Float](op ArithmeticOp) binaryOps[T, T, T] {\n+\tOp := map[ArithmeticOp]func(a, b T, e *error) T{\n+\t\tOpAdd:        func(a, b T, _ *error) T { return a + b },\n+\t\tOpAddChecked: func(a, b T, _ *error) T { return a + b },\n+\t\tOpSub:        func(a, b T, _ *error) T { return a - b },\n+\t\tOpSubChecked: func(a, b T, _ *error) T { return a - b },\n+\t}[op]\n+\n+\treturn binaryOps[T, T, T]{\n+\t\tarrArr: func(_ *exec.KernelCtx, left, right, out []T) error {\n+\t\t\tvar err error\n+\t\t\tfor i := range out {\n+\t\t\t\tout[i] = Op(left[i], right[i], &err)\n+\t\t\t}\n+\t\t\treturn err\n+\t\t},\n+\t\tarrScalar: func(ctx *exec.KernelCtx, left []T, right T, out []T) error {\n+\t\t\tvar err error\n+\t\t\tfor i := range out {\n+\t\t\t\tout[i] = Op(left[i], right, &err)\n+\t\t\t}\n+\t\t\treturn err\n+\t\t},\n+\t\tscalarArr: func(ctx *exec.KernelCtx, left T, right, out []T) error {\n+\t\t\tvar err error\n+\t\t\tfor i := range out {\n+\t\t\t\tout[i] = Op(left, right[i], &err)\n+\t\t\t}\n+\t\t\treturn err\n+\t\t},\n+\t}\n+}\n+\n+func getGoArithmeticBinaryOpsIntegral[T exec.UintTypes | exec.IntTypes](op ArithmeticOp) binaryOps[T, T, T] {\n+\tOp := map[ArithmeticOp]func(a, b T, e *error) T{\n+\t\tOpAdd: func(a, b T, _ *error) T { return a + b },\n+\t\tOpAddChecked: func(a, b T, e *error) T {\n+\t\t\tout, carry := bits.Add64(uint64(a), uint64(b), 0)\n+\t\t\tif carry > 0 {\n+\t\t\t\t*e = fmt.Errorf(\"%w: overflow\", arrow.ErrInvalid)\n+\t\t\t}\n+\t\t\treturn T(out)\n\nReview Comment:\n   Yeah... what if conversion truncates the result?\n\n\n\n##########\ngo/arrow/compute/internal/kernels/helpers.go:\n##########\n@@ -159,6 +161,72 @@ func ScalarUnaryBoolArg[OutT exec.FixedWidthTypes](op func(*exec.KernelCtx, []by\n \t}\n }\n \n+func UnboxScalar[T exec.FixedWidthTypes](val scalar.PrimitiveScalar) T {\n+\treturn exec.GetData[T](val.Data())[0]\n+}\n+\n+func UnboxBinaryScalar(val scalar.BinaryScalar) []byte {\n+\tif !val.IsValid() {\n+\t\treturn nil\n+\t}\n+\treturn val.Data()\n+}\n+\n+type binaryOps[OutT, Arg0T, Arg1T exec.FixedWidthTypes] struct {\n+\tarrArr    func(*exec.KernelCtx, []Arg0T, []Arg1T, []OutT) error\n+\tarrScalar func(*exec.KernelCtx, []Arg0T, Arg1T, []OutT) error\n+\tscalarArr func(*exec.KernelCtx, Arg0T, []Arg1T, []OutT) error\n+}\n+\n+func ScalarBinary[OutT, Arg0T, Arg1T exec.FixedWidthTypes](ops binaryOps[OutT, Arg0T, Arg1T]) exec.ArrayKernelExec {\n+\tarrayArray := func(ctx *exec.KernelCtx, arg0, arg1 *exec.ArraySpan, out *exec.ExecResult) error {\n+\t\tvar (\n+\t\t\ta0      = exec.GetSpanValues[Arg0T](arg0, 1)\n+\t\t\ta1      = exec.GetSpanValues[Arg1T](arg1, 1)\n+\t\t\toutData = exec.GetSpanValues[OutT](out, 1)\n+\t\t)\n+\t\treturn ops.arrArr(ctx, a0, a1, outData)\n+\t}\n+\n+\tarrayScalar := func(ctx *exec.KernelCtx, arg0 *exec.ArraySpan, arg1 scalar.Scalar, out *exec.ExecResult) error {\n+\t\tvar (\n+\t\t\ta0      = exec.GetSpanValues[Arg0T](arg0, 1)\n+\t\t\ta1      = UnboxScalar[Arg1T](arg1.(scalar.PrimitiveScalar))\n+\t\t\toutData = exec.GetSpanValues[OutT](out, 1)\n+\t\t)\n+\t\treturn ops.arrScalar(ctx, a0, a1, outData)\n+\t}\n+\n+\tscalarArray := func(ctx *exec.KernelCtx, arg0 scalar.Scalar, arg1 *exec.ArraySpan, out *exec.ExecResult) error {\n+\t\tvar (\n+\t\t\ta0      = UnboxScalar[Arg0T](arg0.(scalar.PrimitiveScalar))\n+\t\t\ta1      = exec.GetSpanValues[Arg1T](arg1, 1)\n+\t\t\toutData = exec.GetSpanValues[OutT](out, 1)\n+\t\t)\n+\t\treturn ops.scalarArr(ctx, a0, a1, outData)\n+\t}\n+\n+\treturn func(ctx *exec.KernelCtx, batch *exec.ExecSpan, out *exec.ExecResult) error {\n+\t\tif batch.Values[0].IsArray() {\n+\t\t\tif batch.Values[1].IsArray() {\n+\t\t\t\treturn arrayArray(ctx, &batch.Values[0].Array, &batch.Values[1].Array, out)\n+\t\t\t}\n+\t\t\treturn arrayScalar(ctx, &batch.Values[0].Array, batch.Values[1].Scalar, out)\n+\t\t}\n+\n+\t\tif batch.Values[1].IsArray() {\n+\t\t\treturn scalarArray(ctx, batch.Values[0].Scalar, &batch.Values[1].Array, out)\n+\t\t}\n+\n+\t\tdebug.Assert(false, \"should be unreachable\")\n+\t\treturn fmt.Errorf(\"%w: scalar binary with two scalars?\", arrow.ErrInvalid)\n+\t}\n+}\n+\n+func ScalarBinaryEqualTypes[OutT, ArgT exec.FixedWidthTypes](ops binaryOps[OutT, ArgT, ArgT]) exec.ArrayKernelExec {\n\nReview Comment:\n   Is this useful?\n\n\n\n##########\ngo/arrow/compute/internal/kernels/base_arithmetic.go:\n##########\n@@ -0,0 +1,141 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package kernels\n+\n+import (\n+\t\"fmt\"\n+\t\"math/bits\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/internal/debug\"\n+\t\"golang.org/x/exp/constraints\"\n+)\n+\n+type ArithmeticOp int8\n+\n+const (\n+\tOpAdd ArithmeticOp = iota\n+\tOpAddChecked\n+\tOpSub\n+\tOpSubChecked\n+)\n+\n+func getGoArithmeticBinaryOpsFloating[T constraints.Float](op ArithmeticOp) binaryOps[T, T, T] {\n+\tOp := map[ArithmeticOp]func(a, b T, e *error) T{\n+\t\tOpAdd:        func(a, b T, _ *error) T { return a + b },\n+\t\tOpAddChecked: func(a, b T, _ *error) T { return a + b },\n+\t\tOpSub:        func(a, b T, _ *error) T { return a - b },\n+\t\tOpSubChecked: func(a, b T, _ *error) T { return a - b },\n+\t}[op]\n+\n+\treturn binaryOps[T, T, T]{\n+\t\tarrArr: func(_ *exec.KernelCtx, left, right, out []T) error {\n+\t\t\tvar err error\n+\t\t\tfor i := range out {\n+\t\t\t\tout[i] = Op(left[i], right[i], &err)\n+\t\t\t}\n+\t\t\treturn err\n+\t\t},\n+\t\tarrScalar: func(ctx *exec.KernelCtx, left []T, right T, out []T) error {\n+\t\t\tvar err error\n+\t\t\tfor i := range out {\n+\t\t\t\tout[i] = Op(left[i], right, &err)\n+\t\t\t}\n+\t\t\treturn err\n+\t\t},\n+\t\tscalarArr: func(ctx *exec.KernelCtx, left T, right, out []T) error {\n+\t\t\tvar err error\n+\t\t\tfor i := range out {\n+\t\t\t\tout[i] = Op(left, right[i], &err)\n+\t\t\t}\n+\t\t\treturn err\n+\t\t},\n+\t}\n+}\n+\n+func getGoArithmeticBinaryOpsIntegral[T exec.UintTypes | exec.IntTypes](op ArithmeticOp) binaryOps[T, T, T] {\n+\tOp := map[ArithmeticOp]func(a, b T, e *error) T{\n+\t\tOpAdd: func(a, b T, _ *error) T { return a + b },\n+\t\tOpAddChecked: func(a, b T, e *error) T {\n+\t\t\tout, carry := bits.Add64(uint64(a), uint64(b), 0)\n+\t\t\tif carry > 0 {\n+\t\t\t\t*e = fmt.Errorf(\"%w: overflow\", arrow.ErrInvalid)\n+\t\t\t}\n+\t\t\treturn T(out)\n+\t\t},\n+\t\tOpSub: func(a, b T, _ *error) T { return a - b },\n+\t\tOpSubChecked: func(a, b T, e *error) T {\n+\t\t\tout, carry := bits.Sub64(uint64(a), uint64(b), 0)\n+\t\t\tif carry > 0 {\n+\t\t\t\t*e = fmt.Errorf(\"%w: overflow\", arrow.ErrInvalid)\n+\t\t\t}\n+\t\t\treturn T(out)\n+\t\t},\n+\t}[op]\n+\n+\treturn binaryOps[T, T, T]{\n+\t\tarrArr: func(_ *exec.KernelCtx, left, right, out []T) error {\n+\t\t\tvar err error\n+\t\t\tfor i := range out {\n+\t\t\t\tout[i] = Op(left[i], right[i], &err)\n\nReview Comment:\n   You can't do that as it will also run overflow checks on null entries, AFAIU.\n\n\n\n##########\ngo/arrow/compute/arithmetic_test.go:\n##########\n@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package compute_test\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/array\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/apache/arrow/go/v10/arrow/scalar\"\n+\t\"github.com/stretchr/testify/suite\"\n+)\n+\n+type binaryFunc = func(context.Context, compute.ArithmeticOptions, compute.Datum, compute.Datum) (compute.Datum, error)\n+\n+type BinaryArithmeticSuite[T exec.NumericTypes] struct {\n+\tsuite.Suite\n+\n+\tmem  *memory.CheckedAllocator\n+\topts compute.ArithmeticOptions\n+\tctx  context.Context\n+}\n+\n+func (BinaryArithmeticSuite[T]) DataType() arrow.DataType {\n+\treturn exec.GetDataType[T]()\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) SetupTest() {\n+\tb.mem = memory.NewCheckedAllocator(memory.DefaultAllocator)\n+\tb.opts.CheckOverflow = false\n+\tb.ctx = compute.WithAllocator(context.TODO(), b.mem)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) TearDownTest() {\n+\tb.mem.AssertSize(b.T(), 0)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeNullScalar() scalar.Scalar {\n+\treturn scalar.MakeNullScalar(b.DataType())\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeScalar(val T) scalar.Scalar {\n+\treturn scalar.MakeScalar(val)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalars(fn binaryFunc, lhs, rhs T, expected T) {\n+\tleft, right := b.makeScalar(lhs), b.makeScalar(rhs)\n+\texp := b.makeScalar(expected)\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: left}, &compute.ScalarDatum{Value: right})\n+\tb.NoError(err)\n+\tsc := actual.(*compute.ScalarDatum).Value\n+\n+\tb.Truef(scalar.Equals(exp, sc), \"expected: %s\\ngot: %s\", exp, sc)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScArr(fn binaryFunc, lhs T, rhs, expected string) {\n+\tleft := b.makeScalar(lhs)\n+\tb.assertBinopScalarArr(fn, left, rhs, expected)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalarArr(fn binaryFunc, lhs scalar.Scalar, rhs, expected string) {\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: lhs}, &compute.ArrayDatum{Value: right.Data()})\n+\tb.NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: exp.Data()}, actual)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrSc(fn binaryFunc, lhs string, rhs T, expected string) {\n+\tright := b.makeScalar(rhs)\n+\tb.assertBinopArrScalar(fn, lhs, right, expected)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrScalar(fn binaryFunc, lhs string, rhs scalar.Scalar, expected string) {\n+\tleft, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(lhs))\n+\tdefer left.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ArrayDatum{Value: left.Data()}, &compute.ScalarDatum{Value: rhs})\n+\tb.NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: exp.Data()}, actual)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrays(fn binaryFunc, lhs, rhs, expected string) {\n+\tleft, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(lhs))\n+\tdefer left.Release()\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tb.assertBinop(fn, left, right, exp)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinop(fn binaryFunc, left, right, expected arrow.Array) {\n\nReview Comment:\n   Here as well, you probably want to expose this as a more general test helper, since this won't be useful for other things than arithmetic functions.\n\n\n\n##########\ngo/arrow/compute/utils.go:\n##########\n@@ -81,3 +84,159 @@ func (b *bufferWriteSeeker) Seek(offset int64, whence int) (int64, error) {\n \tb.pos = newpos\n \treturn int64(newpos), nil\n }\n+\n+func ensureDictionaryDecoded(vals ...arrow.DataType) {\n+\tfor i, v := range vals {\n+\t\tif v.ID() == arrow.DICTIONARY {\n+\t\t\tvals[i] = v.(*arrow.DictionaryType).ValueType\n\nReview Comment:\n   For the record, where does the actual dictionary decoding happen? (add a comment?)\n\n\n\n##########\ngo/arrow/compute/arithmetic_test.go:\n##########\n@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package compute_test\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/array\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/apache/arrow/go/v10/arrow/scalar\"\n+\t\"github.com/stretchr/testify/suite\"\n+)\n+\n+type binaryFunc = func(context.Context, compute.ArithmeticOptions, compute.Datum, compute.Datum) (compute.Datum, error)\n+\n+type BinaryArithmeticSuite[T exec.NumericTypes] struct {\n+\tsuite.Suite\n+\n+\tmem  *memory.CheckedAllocator\n+\topts compute.ArithmeticOptions\n+\tctx  context.Context\n+}\n+\n+func (BinaryArithmeticSuite[T]) DataType() arrow.DataType {\n+\treturn exec.GetDataType[T]()\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) SetupTest() {\n+\tb.mem = memory.NewCheckedAllocator(memory.DefaultAllocator)\n+\tb.opts.CheckOverflow = false\n+\tb.ctx = compute.WithAllocator(context.TODO(), b.mem)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) TearDownTest() {\n+\tb.mem.AssertSize(b.T(), 0)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeNullScalar() scalar.Scalar {\n+\treturn scalar.MakeNullScalar(b.DataType())\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeScalar(val T) scalar.Scalar {\n+\treturn scalar.MakeScalar(val)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalars(fn binaryFunc, lhs, rhs T, expected T) {\n+\tleft, right := b.makeScalar(lhs), b.makeScalar(rhs)\n+\texp := b.makeScalar(expected)\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: left}, &compute.ScalarDatum{Value: right})\n+\tb.NoError(err)\n+\tsc := actual.(*compute.ScalarDatum).Value\n+\n+\tb.Truef(scalar.Equals(exp, sc), \"expected: %s\\ngot: %s\", exp, sc)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScArr(fn binaryFunc, lhs T, rhs, expected string) {\n+\tleft := b.makeScalar(lhs)\n+\tb.assertBinopScalarArr(fn, left, rhs, expected)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalarArr(fn binaryFunc, lhs scalar.Scalar, rhs, expected string) {\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: lhs}, &compute.ArrayDatum{Value: right.Data()})\n+\tb.NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: exp.Data()}, actual)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrSc(fn binaryFunc, lhs string, rhs T, expected string) {\n+\tright := b.makeScalar(rhs)\n+\tb.assertBinopArrScalar(fn, lhs, right, expected)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrScalar(fn binaryFunc, lhs string, rhs scalar.Scalar, expected string) {\n+\tleft, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(lhs))\n+\tdefer left.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ArrayDatum{Value: left.Data()}, &compute.ScalarDatum{Value: rhs})\n+\tb.NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: exp.Data()}, actual)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrays(fn binaryFunc, lhs, rhs, expected string) {\n+\tleft, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(lhs))\n+\tdefer left.Release()\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tb.assertBinop(fn, left, right, exp)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinop(fn binaryFunc, left, right, expected arrow.Array) {\n+\tactual, err := fn(b.ctx, b.opts, &compute.ArrayDatum{Value: left.Data()}, &compute.ArrayDatum{Value: right.Data()})\n+\tb.Require().NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: expected.Data()}, actual)\n+\n+\t// also check (Scalar, Scalar) operations\n+\tfor i := 0; i < expected.Len(); i++ {\n+\t\ts, err := scalar.GetScalar(expected, i)\n+\t\tb.Require().NoError(err)\n+\t\tlhs, _ := scalar.GetScalar(left, i)\n+\t\trhs, _ := scalar.GetScalar(right, i)\n+\n+\t\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: lhs}, &compute.ScalarDatum{Value: rhs})\n+\t\tb.NoError(err)\n+\t\tb.Truef(scalar.Equals(s, actual.(*compute.ScalarDatum).Value), \"expected: %s\\ngot: %s\", s, actual)\n+\t}\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) setOverflowCheck(value bool) {\n+\tb.opts.CheckOverflow = value\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopErr(fn binaryFunc, lhs, rhs, expectedMsg string) {\n+\tleft, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(lhs))\n+\tdefer left.Release()\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\n+\t_, err := fn(b.ctx, b.opts, &compute.ArrayDatum{left.Data()}, &compute.ArrayDatum{Value: right.Data()})\n+\tb.ErrorIs(err, arrow.ErrInvalid)\n+\tb.ErrorContains(err, expectedMsg)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) TestAdd() {\n+\tb.Run(b.DataType().String(), func() {\n+\t\tfor _, overflow := range []bool{false, true} {\n+\t\t\tb.Run(fmt.Sprintf(\"overflow=%t\", overflow), func() {\n+\t\t\t\tb.setOverflowCheck(overflow)\n+\n+\t\t\t\tb.assertBinopArrays(compute.Add, `[]`, `[]`, `[]`)\n+\t\t\t\tb.assertBinopArrays(compute.Add, `[3, 2, 6]`, `[1, 0, 2]`, `[4, 2, 8]`)\n+\t\t\t\t// nulls on one side\n+\t\t\t\tb.assertBinopArrays(compute.Add, `[null, 1, null]`, `[3, 4, 5]`, `[null, 5, null]`)\n+\t\t\t\tb.assertBinopArrays(compute.Add, `[3, 4, 5]`, `[null, 1, null]`, `[null, 5, null]`)\n+\t\t\t\t// nulls on both sides\n+\t\t\t\tb.assertBinopArrays(compute.Add, `[null, 1, 2]`, `[3, 4, null]`, `[null, 5, null]`)\n+\t\t\t\t// all nulls\n+\t\t\t\tb.assertBinopArrays(compute.Add, `[null]`, `[null]`, `[null]`)\n+\n+\t\t\t\t// scalar on the left\n+\t\t\t\tb.assertBinopScArr(compute.Add, 3, `[1, 2]`, `[4, 5]`)\n+\t\t\t\tb.assertBinopScArr(compute.Add, 3, `[null, 2]`, `[null, 5]`)\n+\t\t\t\tb.assertBinopScalarArr(compute.Add, b.makeNullScalar(), `[1, 2]`, `[null, null]`)\n+\t\t\t\tb.assertBinopScalarArr(compute.Add, b.makeNullScalar(), `[null, 2]`, `[null, null]`)\n+\t\t\t\t// scalar on the right\n+\t\t\t\tb.assertBinopArrSc(compute.Add, `[1, 2]`, 3, `[4, 5]`)\n+\t\t\t\tb.assertBinopArrSc(compute.Add, `[null, 2]`, 3, `[null, 5]`)\n+\t\t\t\tb.assertBinopArrScalar(compute.Add, `[1, 2]`, b.makeNullScalar(), `[null, null]`)\n+\t\t\t\tb.assertBinopArrScalar(compute.Add, `[null, 2]`, b.makeNullScalar(), `[null, null]`)\n+\t\t\t})\n+\t\t}\n+\t})\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) TestSub() {\n+\tb.Run(b.DataType().String(), func() {\n+\t\tfor _, overflow := range []bool{false, true} {\n+\t\t\tb.Run(fmt.Sprintf(\"overflow=%t\", overflow), func() {\n+\t\t\t\tb.setOverflowCheck(overflow)\n+\n+\t\t\t\tb.assertBinopArrays(compute.Subtract, `[]`, `[]`, `[]`)\n+\t\t\t\tb.assertBinopArrays(compute.Subtract, `[3, 2, 6]`, `[1, 0, 2]`, `[2, 2, 4]`)\n+\t\t\t\t// nulls on one side\n+\t\t\t\tb.assertBinopArrays(compute.Subtract, `[null, 4, null]`, `[2, 1, 0]`, `[null, 3, null]`)\n+\t\t\t\tb.assertBinopArrays(compute.Subtract, `[3, 4, 5]`, `[null, 1, null]`, `[null, 3, null]`)\n+\t\t\t\t// nulls on both sides\n+\t\t\t\tb.assertBinopArrays(compute.Subtract, `[null, 4, 3]`, `[2, 1, null]`, `[null, 3, null]`)\n+\t\t\t\t// all nulls\n+\t\t\t\tb.assertBinopArrays(compute.Subtract, `[null]`, `[null]`, `[null]`)\n+\n+\t\t\t\t// scalar on the left\n+\t\t\t\tb.assertBinopScArr(compute.Subtract, 3, `[1, 2]`, `[2, 1]`)\n+\t\t\t\tb.assertBinopScArr(compute.Subtract, 3, `[null, 2]`, `[null, 1]`)\n+\t\t\t\tb.assertBinopScalarArr(compute.Subtract, b.makeNullScalar(), `[1, 2]`, `[null, null]`)\n+\t\t\t\tb.assertBinopScalarArr(compute.Subtract, b.makeNullScalar(), `[null, 2]`, `[null, null]`)\n+\t\t\t\t// scalar on the right\n+\t\t\t\tb.assertBinopArrSc(compute.Subtract, `[4, 5]`, 3, `[1, 2]`)\n+\t\t\t\tb.assertBinopArrSc(compute.Subtract, `[null, 5]`, 3, `[null, 2]`)\n+\t\t\t\tb.assertBinopArrScalar(compute.Subtract, `[1, 2]`, b.makeNullScalar(), `[null, null]`)\n+\t\t\t\tb.assertBinopArrScalar(compute.Subtract, `[null, 2]`, b.makeNullScalar(), `[null, null]`)\n+\t\t\t})\n+\t\t}\n+\t})\n+}\n+\n+func TestBinaryArithmetic(t *testing.T) {\n+\tsuite.Run(t, new(BinaryArithmeticSuite[int8]))\n+\tsuite.Run(t, new(BinaryArithmeticSuite[uint8]))\n+\tsuite.Run(t, new(BinaryArithmeticSuite[int16]))\n+\tsuite.Run(t, new(BinaryArithmeticSuite[uint16]))\n+\tsuite.Run(t, new(BinaryArithmeticSuite[int32]))\n+\tsuite.Run(t, new(BinaryArithmeticSuite[uint32]))\n+\tsuite.Run(t, new(BinaryArithmeticSuite[int64]))\n+\tsuite.Run(t, new(BinaryArithmeticSuite[uint64]))\n+\tsuite.Run(t, new(BinaryArithmeticSuite[float32]))\n+\tsuite.Run(t, new(BinaryArithmeticSuite[float64]))\n\nReview Comment:\n   Is float16 supported? Regardless of the answer, add a test for it?\n\n\n\n##########\ngo/arrow/compute/utils.go:\n##########\n@@ -81,3 +84,159 @@ func (b *bufferWriteSeeker) Seek(offset int64, whence int) (int64, error) {\n \tb.pos = newpos\n \treturn int64(newpos), nil\n }\n+\n+func ensureDictionaryDecoded(vals ...arrow.DataType) {\n\nReview Comment:\n   Can you add docstrings to all these helpers?\n\n\n\n##########\ngo/arrow/compute/internal/kernels/base_arithmetic_amd64.go:\n##########\n@@ -0,0 +1,83 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+//go:build !noasm\n+\n+package kernels\n+\n+import (\n+\t\"unsafe\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/sys/cpu\"\n+)\n+\n+func getAvx2ArithmeticBinaryNumeric[T exec.NumericTypes](op ArithmeticOp) binaryOps[T, T, T] {\n+\ttyp := exec.GetType[T]()\n+\treturn binaryOps[T, T, T]{\n+\t\tarrArr: func(_ *exec.KernelCtx, Arg0, Arg1, Out []T) error {\n+\t\t\tarithmeticAvx2(typ, op, exec.GetBytes(Arg0), exec.GetBytes(Arg1), exec.GetBytes(Out), len(Out))\n+\t\t\treturn nil\n+\t\t},\n+\t\tarrScalar: func(_ *exec.KernelCtx, Arg0 []T, Arg1 T, Out []T) error {\n+\t\t\tarithmeticArrScalarAvx2(typ, op, exec.GetBytes(Arg0), unsafe.Pointer(&Arg1), exec.GetBytes(Out), len(Out))\n+\t\t\treturn nil\n+\t\t},\n+\t\tscalarArr: func(_ *exec.KernelCtx, Arg0 T, Arg1, Out []T) error {\n+\t\t\tarithmeticScalarArrAvx2(typ, op, unsafe.Pointer(&Arg0), exec.GetBytes(Arg1), exec.GetBytes(Out), len(Out))\n+\t\t\treturn nil\n+\t\t},\n+\t}\n+}\n+\n+func getSSE4ArithmeticBinaryNumeric[T exec.NumericTypes](op ArithmeticOp) binaryOps[T, T, T] {\n+\ttyp := exec.GetType[T]()\n+\treturn binaryOps[T, T, T]{\n+\t\tarrArr: func(_ *exec.KernelCtx, Arg0, Arg1, Out []T) error {\n+\t\t\tarithmeticSSE4(typ, op, exec.GetBytes(Arg0), exec.GetBytes(Arg1), exec.GetBytes(Out), len(Out))\n+\t\t\treturn nil\n+\t\t},\n+\t\tarrScalar: func(_ *exec.KernelCtx, Arg0 []T, Arg1 T, Out []T) error {\n+\t\t\tarithmeticArrScalarSSE4(typ, op, exec.GetBytes(Arg0), unsafe.Pointer(&Arg1), exec.GetBytes(Out), len(Out))\n+\t\t\treturn nil\n+\t\t},\n+\t\tscalarArr: func(_ *exec.KernelCtx, Arg0 T, Arg1, Out []T) error {\n+\t\t\tarithmeticScalarArrSSE4(typ, op, unsafe.Pointer(&Arg0), exec.GetBytes(Arg1), exec.GetBytes(Out), len(Out))\n+\t\t\treturn nil\n+\t\t},\n+\t}\n+}\n+\n+func getArithmeticBinaryOpsFloating[T constraints.Float](op ArithmeticOp) binaryOps[T, T, T] {\n+\tif cpu.X86.HasAVX2 {\n+\t\treturn getAvx2ArithmeticBinaryNumeric[T](op)\n+\t} else if cpu.X86.HasSSE42 {\n+\t\treturn getSSE4ArithmeticBinaryNumeric[T](op)\n+\t}\n+\n+\treturn getGoArithmeticBinaryOpsFloating[T](op)\n\nReview Comment:\n   I'm curious, why not also compile this one from C++? 1) the C++ optimizer is probably better than the Go one, 2) less code to write and maintain?\n\n\n\n##########\ngo/arrow/compute/internal/exec/utils.go:\n##########\n@@ -172,6 +179,11 @@ func GetDataType[T NumericTypes | bool | string]() arrow.DataType {\n \treturn typMap[reflect.TypeOf(z)]\n }\n \n+func GetType[T NumericTypes | bool | string]() arrow.Type {\n\nReview Comment:\n   Also why is it not defined for all types?\n\n\n\n##########\ngo/arrow/compute/internal/kernels/_lib/base_arithmetic.cc:\n##########\n@@ -0,0 +1,255 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <arch.h>\n+#include <stdint.h>\n+#include \"types.h\"\n+#include \"vendored/safe-math.h\"\n+\n+// Define functions AddWithOverflow, SubtractWithOverflow, MultiplyWithOverflow\n+// with the signature `bool(T u, T v, T* out)` where T is an integer type.\n+// On overflow, these functions return true.  Otherwise, false is returned\n+// and `out` is updated with the result of the operation.\n+\n+#define OP_WITH_OVERFLOW(_func_name, _psnip_op, _type, _psnip_type) \\\n+  static inline bool _func_name(_type u, _type v, _type* out) {     \\\n+    return !psnip_safe_##_psnip_type##_##_psnip_op(out, u, v);      \\\n+  }\n+\n+#define OPS_WITH_OVERFLOW(_func_name, _psnip_op)            \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int8_t, int8)     \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int16_t, int16)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int32_t, int32)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int64_t, int64)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint8_t, uint8)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint16_t, uint16) \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint32_t, uint32) \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint64_t, uint64)\n+\n+OPS_WITH_OVERFLOW(AddWithOverflow, add)\n+OPS_WITH_OVERFLOW(SubtractWithOverflow, sub)\n+OPS_WITH_OVERFLOW(MultiplyWithOverflow, mul)\n+OPS_WITH_OVERFLOW(DivideWithOverflow, div)\n+\n+// Corresponds to equivalent ArithmeticOp enum in base_arithmetic.go\n+// for passing across which operation to perform. This allows simpler\n+// implementation at the cost of having to pass the extra int8 and\n+// perform a switch.\n+//\n+// In cases of small arrays, this is completely negligible. In cases\n+// of large arrays, the time saved by using SIMD here is significantly\n+// worth the cost.\n+enum class optype : int8_t {\n+    ADD,\n+    ADD_CHECKED,\n+    SUB, \n+    SUB_CHECKED,\n+};\n+\n+template <typename T>\n+using is_unsigned_integer_value = bool_constant<is_integral_v<T> && is_unsigned_v<T>>;\n+\n+template <typename T>\n+using is_signed_integer_value = bool_constant<is_integral_v<T> && is_signed_v<T>>;\n+\n+template <typename T, typename R = T>\n+using enable_if_signed_integer_t = enable_if_t<is_signed_integer_value<T>::value, R>;\n+\n+template <typename T, typename R = T>\n+using enable_if_unsigned_integer_t = enable_if_t<is_unsigned_integer_value<T>::value, R>;\n+\n+template <typename T, typename R = T>\n+using enable_if_integer_t = enable_if_t<\n+    is_signed_integer_value<T>::value || is_unsigned_integer_value<T>::value, R>;\n+\n+template <typename T, typename R = T>\n+using enable_if_floating_t = enable_if_t<is_floating_point_v<T>, R>;\n+\n+struct Add {\n+    template <typename T, typename Arg0, typename Arg1>\n+    static constexpr enable_if_floating_t<T> Call(Arg0 left, Arg1 right, bool*) {\n+        return left + right;\n+    }\n+\n+    template <typename T, typename Arg0, typename Arg1>\n+    static constexpr enable_if_integer_t<T> Call(Arg0 left, Arg1 right, bool*) {\n+        return left + right;\n+    }\n+};\n+\n+struct Sub {\n+    template <typename T, typename Arg0, typename Arg1>\n+    static constexpr enable_if_floating_t<T> Call(Arg0 left, Arg1 right, bool*) {\n+        return left - right;\n+    }\n+\n+    template <typename T, typename Arg0, typename Arg1>\n+    static constexpr enable_if_integer_t<T> Call(Arg0 left, Arg1 right, bool*) {\n+        return left - right;\n+    }\n+};\n+\n+struct AddChecked {\n+    template <typename T, typename Arg0, typename Arg1>\n+    static constexpr enable_if_floating_t<T> Call(Arg0 left, Arg1 right, bool*) {\n+        return left + right;\n+    }\n+\n+    template <typename T, typename Arg0, typename Arg1>\n+    static constexpr enable_if_integer_t<T> Call(Arg0 left, Arg1 right, bool* failure) {\n\nReview Comment:\n   For the record, this would probably be:\r\n   ```c++\r\n   struct AddChecked {\r\n       template <typename T, typename Arg0, typename Arg1>\r\n       static constexpr void Call(Arg0 left, Arg1 right, bool* failure) {\r\n           static_assert(is_same<T, Arg0>::value && is_same<T, Arg1>::value, \"\");\r\n           if constexpr(is_signed_integer_value<T>::value ||\r\n                        is_unsigned_integer_value<T>::value) {\r\n               T result = 0;\r\n               if (AddWithOverflow(left, right, &result)) {\r\n                   *failure = true;\r\n               }\r\n               return result;\r\n           } else {\r\n               return left + right;\r\n           }\r\n       }\r\n   };\r\n   ```\n\n\n\n##########\ngo/arrow/compute/utils.go:\n##########\n@@ -81,3 +84,159 @@ func (b *bufferWriteSeeker) Seek(offset int64, whence int) (int64, error) {\n \tb.pos = newpos\n \treturn int64(newpos), nil\n }\n+\n+func ensureDictionaryDecoded(vals ...arrow.DataType) {\n\nReview Comment:\n   Also, are there any tests for them?\n\n\n\n##########\ngo/arrow/compute/internal/kernels/_lib/types.h:\n##########\n@@ -0,0 +1,477 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// corresponds to datatype.go's arrow.Type\n+enum class arrtype : int {\n+    NULL,\n+    BOOL,\n+    UINT8,\n+    INT8,\n+    UINT16,\n+    INT16,\n+    UINT32,\n+    INT32,\n+    UINT64,\n+    INT64,\n+    FLOAT16,\n+    FLOAT32,\n+    FLOAT64\n+};\n+\n+// The following is copied from <type_traits> since we use -target \n\nReview Comment:\n   If this is from libstdc++, then it's under the GPLv3 and cannot be copied here.\r\n   \n\n\n\n##########\ngo/arrow/compute/arithmetic.go:\n##########\n@@ -0,0 +1,155 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package compute\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/kernels\"\n+)\n+\n+type arithmeticFunction struct {\n+\tScalarFunction\n+}\n+\n+func (fn *arithmeticFunction) checkDecimals(vals ...arrow.DataType) error {\n+\tif !hasDecimal(vals...) {\n+\t\treturn nil\n+\t}\n+\n+\tif len(vals) != 2 {\n+\t\treturn nil\n+\t}\n+\n+\top := fn.name[:strings.Index(fn.name, \"_\")]\n+\tswitch op {\n+\tcase \"add\", \"subtract\":\n+\t\treturn castBinaryDecimalArgs(decPromoteAdd, vals...)\n+\tcase \"multiply\":\n+\t\treturn castBinaryDecimalArgs(decPromoteMultiply, vals...)\n+\tcase \"divide\":\n+\t\treturn castBinaryDecimalArgs(decPromoteDivide, vals...)\n+\tdefault:\n+\t\treturn fmt.Errorf(\"%w: invalid decimal function: %s\", arrow.ErrInvalid, fn.name)\n+\t}\n+}\n+\n+func (fn *arithmeticFunction) DispatchBest(vals ...arrow.DataType) (exec.Kernel, error) {\n+\tif err := fn.checkArity(len(vals)); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif err := fn.checkDecimals(vals...); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif kn, err := fn.DispatchExact(vals...); err == nil {\n+\t\treturn kn, nil\n+\t}\n+\n+\tensureDictionaryDecoded(vals...)\n+\n+\t// only promote types for binary funcs\n+\tif len(vals) == 2 {\n+\t\treplaceNullWithOtherType(vals...)\n+\t\tif unit, istime := commonTemporalResolution(vals...); istime {\n+\t\t\treplaceTemporalTypes(unit, vals...)\n+\t\t} else {\n+\t\t\tif dt := commonNumeric(vals...); dt != nil {\n+\t\t\t\treplaceTypes(dt, vals...)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn fn.DispatchExact(vals...)\n+}\n+\n+var (\n+\taddDoc FunctionDoc\n+)\n+\n+func RegisterScalarArithmetic(reg FunctionRegistry) {\n+\taddFn := &arithmeticFunction{*NewScalarFunction(\"add\", Binary(), addDoc)}\n+\tfor _, k := range kernels.GetArithmeticKernels(kernels.OpAdd) {\n+\t\tif err := addFn.AddKernel(k); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}\n+\n+\treg.AddFunction(addFn, false)\n+\n+\taddCheckedFn := &arithmeticFunction{*NewScalarFunction(\"add_checked\", Binary(), addDoc)}\n\nReview Comment:\n   (I'm not even sure unchecked arithmetic is worth adding TBH)\n\n\n\n##########\ngo/arrow/compute/internal/kernels/base_arithmetic.go:\n##########\n@@ -0,0 +1,141 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package kernels\n+\n+import (\n+\t\"fmt\"\n+\t\"math/bits\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/internal/debug\"\n+\t\"golang.org/x/exp/constraints\"\n+)\n+\n+type ArithmeticOp int8\n+\n+const (\n+\tOpAdd ArithmeticOp = iota\n+\tOpAddChecked\n+\tOpSub\n+\tOpSubChecked\n+)\n+\n+func getGoArithmeticBinaryOpsFloating[T constraints.Float](op ArithmeticOp) binaryOps[T, T, T] {\n+\tOp := map[ArithmeticOp]func(a, b T, e *error) T{\n\nReview Comment:\n   Why pass an error pointer that never gets used?\n\n\n\n##########\ngo/arrow/compute/internal/kernels/base_arithmetic.go:\n##########\n@@ -0,0 +1,141 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package kernels\n+\n+import (\n+\t\"fmt\"\n+\t\"math/bits\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/internal/debug\"\n+\t\"golang.org/x/exp/constraints\"\n+)\n+\n+type ArithmeticOp int8\n+\n+const (\n+\tOpAdd ArithmeticOp = iota\n+\tOpAddChecked\n+\tOpSub\n+\tOpSubChecked\n+)\n+\n+func getGoArithmeticBinaryOpsFloating[T constraints.Float](op ArithmeticOp) binaryOps[T, T, T] {\n+\tOp := map[ArithmeticOp]func(a, b T, e *error) T{\n+\t\tOpAdd:        func(a, b T, _ *error) T { return a + b },\n+\t\tOpAddChecked: func(a, b T, _ *error) T { return a + b },\n+\t\tOpSub:        func(a, b T, _ *error) T { return a - b },\n+\t\tOpSubChecked: func(a, b T, _ *error) T { return a - b },\n+\t}[op]\n+\n+\treturn binaryOps[T, T, T]{\n+\t\tarrArr: func(_ *exec.KernelCtx, left, right, out []T) error {\n+\t\t\tvar err error\n+\t\t\tfor i := range out {\n+\t\t\t\tout[i] = Op(left[i], right[i], &err)\n\nReview Comment:\n   Does this actually call a runtime-selected function pointer on every loop iteration?\n\n\n\n##########\ngo/arrow/compute/internal/exec/utils.go:\n##########\n@@ -135,6 +135,13 @@ func Min[T constraints.Ordered](a, b T) T {\n \treturn b\n }\n \n+func Max[T constraints.Ordered](a, b T) T {\n\nReview Comment:\n   Do you want this to be well-behaved for signed zeros? i.e. do `Max(0.0, -0.0)` and `Max(-0.0, 0.0)` both return 0.0?\n\n\n\n##########\ngo/arrow/compute/internal/exec/utils.go:\n##########\n@@ -172,6 +179,11 @@ func GetDataType[T NumericTypes | bool | string]() arrow.DataType {\n \treturn typMap[reflect.TypeOf(z)]\n }\n \n+func GetType[T NumericTypes | bool | string]() arrow.Type {\n\nReview Comment:\n   What does this do? Add a docstring?\n\n\n\n##########\ngo/arrow/compute/arithmetic_test.go:\n##########\n@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package compute_test\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/array\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/apache/arrow/go/v10/arrow/scalar\"\n+\t\"github.com/stretchr/testify/suite\"\n+)\n+\n+type binaryFunc = func(context.Context, compute.ArithmeticOptions, compute.Datum, compute.Datum) (compute.Datum, error)\n+\n+type BinaryArithmeticSuite[T exec.NumericTypes] struct {\n\nReview Comment:\n   Wow, Go has generics finally? :-)\n\n\n\n##########\ngo/arrow/compute/arithmetic_test.go:\n##########\n@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package compute_test\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/array\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/apache/arrow/go/v10/arrow/scalar\"\n+\t\"github.com/stretchr/testify/suite\"\n+)\n+\n+type binaryFunc = func(context.Context, compute.ArithmeticOptions, compute.Datum, compute.Datum) (compute.Datum, error)\n+\n+type BinaryArithmeticSuite[T exec.NumericTypes] struct {\n+\tsuite.Suite\n+\n+\tmem  *memory.CheckedAllocator\n+\topts compute.ArithmeticOptions\n+\tctx  context.Context\n+}\n+\n+func (BinaryArithmeticSuite[T]) DataType() arrow.DataType {\n+\treturn exec.GetDataType[T]()\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) SetupTest() {\n+\tb.mem = memory.NewCheckedAllocator(memory.DefaultAllocator)\n+\tb.opts.CheckOverflow = false\n+\tb.ctx = compute.WithAllocator(context.TODO(), b.mem)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) TearDownTest() {\n+\tb.mem.AssertSize(b.T(), 0)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeNullScalar() scalar.Scalar {\n+\treturn scalar.MakeNullScalar(b.DataType())\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeScalar(val T) scalar.Scalar {\n+\treturn scalar.MakeScalar(val)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalars(fn binaryFunc, lhs, rhs T, expected T) {\n+\tleft, right := b.makeScalar(lhs), b.makeScalar(rhs)\n+\texp := b.makeScalar(expected)\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: left}, &compute.ScalarDatum{Value: right})\n+\tb.NoError(err)\n+\tsc := actual.(*compute.ScalarDatum).Value\n+\n+\tb.Truef(scalar.Equals(exp, sc), \"expected: %s\\ngot: %s\", exp, sc)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScArr(fn binaryFunc, lhs T, rhs, expected string) {\n+\tleft := b.makeScalar(lhs)\n+\tb.assertBinopScalarArr(fn, left, rhs, expected)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalarArr(fn binaryFunc, lhs scalar.Scalar, rhs, expected string) {\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: lhs}, &compute.ArrayDatum{Value: right.Data()})\n+\tb.NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: exp.Data()}, actual)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrSc(fn binaryFunc, lhs string, rhs T, expected string) {\n+\tright := b.makeScalar(rhs)\n+\tb.assertBinopArrScalar(fn, lhs, right, expected)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrScalar(fn binaryFunc, lhs string, rhs scalar.Scalar, expected string) {\n+\tleft, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(lhs))\n+\tdefer left.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ArrayDatum{Value: left.Data()}, &compute.ScalarDatum{Value: rhs})\n+\tb.NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: exp.Data()}, actual)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrays(fn binaryFunc, lhs, rhs, expected string) {\n+\tleft, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(lhs))\n+\tdefer left.Release()\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tb.assertBinop(fn, left, right, exp)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinop(fn binaryFunc, left, right, expected arrow.Array) {\n+\tactual, err := fn(b.ctx, b.opts, &compute.ArrayDatum{Value: left.Data()}, &compute.ArrayDatum{Value: right.Data()})\n+\tb.Require().NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: expected.Data()}, actual)\n+\n+\t// also check (Scalar, Scalar) operations\n\nReview Comment:\n   Also may want to check (Array, Scalar) and (Scalar, Array) automatically?\n\n\n\n",
                    "created": "2022-09-28T11:02:57.486+0000",
                    "updated": "2022-09-28T11:02:57.486+0000",
                    "started": "2022-09-28T11:02:57.485+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812848",
                    "issueId": "13483547"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812849",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #14255:\nURL: https://github.com/apache/arrow/pull/14255#discussion_r982237005\n\n\n##########\ngo/arrow/compute/arithmetic_test.go:\n##########\n@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package compute_test\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/array\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/apache/arrow/go/v10/arrow/scalar\"\n+\t\"github.com/stretchr/testify/suite\"\n+)\n+\n+type binaryFunc = func(context.Context, compute.ArithmeticOptions, compute.Datum, compute.Datum) (compute.Datum, error)\n+\n+type BinaryArithmeticSuite[T exec.NumericTypes] struct {\n+\tsuite.Suite\n+\n+\tmem  *memory.CheckedAllocator\n+\topts compute.ArithmeticOptions\n+\tctx  context.Context\n+}\n+\n+func (BinaryArithmeticSuite[T]) DataType() arrow.DataType {\n+\treturn exec.GetDataType[T]()\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) SetupTest() {\n+\tb.mem = memory.NewCheckedAllocator(memory.DefaultAllocator)\n+\tb.opts.CheckOverflow = false\n+\tb.ctx = compute.WithAllocator(context.TODO(), b.mem)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) TearDownTest() {\n+\tb.mem.AssertSize(b.T(), 0)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeNullScalar() scalar.Scalar {\n+\treturn scalar.MakeNullScalar(b.DataType())\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeScalar(val T) scalar.Scalar {\n+\treturn scalar.MakeScalar(val)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalars(fn binaryFunc, lhs, rhs T, expected T) {\n+\tleft, right := b.makeScalar(lhs), b.makeScalar(rhs)\n+\texp := b.makeScalar(expected)\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: left}, &compute.ScalarDatum{Value: right})\n+\tb.NoError(err)\n+\tsc := actual.(*compute.ScalarDatum).Value\n+\n+\tb.Truef(scalar.Equals(exp, sc), \"expected: %s\\ngot: %s\", exp, sc)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScArr(fn binaryFunc, lhs T, rhs, expected string) {\n+\tleft := b.makeScalar(lhs)\n+\tb.assertBinopScalarArr(fn, left, rhs, expected)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalarArr(fn binaryFunc, lhs scalar.Scalar, rhs, expected string) {\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: lhs}, &compute.ArrayDatum{Value: right.Data()})\n+\tb.NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: exp.Data()}, actual)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrSc(fn binaryFunc, lhs string, rhs T, expected string) {\n+\tright := b.makeScalar(rhs)\n+\tb.assertBinopArrScalar(fn, lhs, right, expected)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrScalar(fn binaryFunc, lhs string, rhs scalar.Scalar, expected string) {\n+\tleft, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(lhs))\n+\tdefer left.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ArrayDatum{Value: left.Data()}, &compute.ScalarDatum{Value: rhs})\n+\tb.NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: exp.Data()}, actual)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrays(fn binaryFunc, lhs, rhs, expected string) {\n+\tleft, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(lhs))\n+\tdefer left.Release()\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tb.assertBinop(fn, left, right, exp)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinop(fn binaryFunc, left, right, expected arrow.Array) {\n\nReview Comment:\n   Here as well, you probably want to expose this as a more general test helper, since this will be useful for other things than arithmetic functions.\n\n\n\n",
                    "created": "2022-09-28T11:04:02.713+0000",
                    "updated": "2022-09-28T11:04:02.713+0000",
                    "started": "2022-09-28T11:04:02.713+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812849",
                    "issueId": "13483547"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812946",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #14255:\nURL: https://github.com/apache/arrow/pull/14255#discussion_r982491947\n\n\n##########\ngo/arrow/compute/arithmetic_test.go:\n##########\n@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package compute_test\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n\nReview Comment:\n   There's a bunch of utilities such as https://github.com/marwan-at-work/mod that exist which will do it automatically for you.\n\n\n\n",
                    "created": "2022-09-28T14:37:08.095+0000",
                    "updated": "2022-09-28T14:37:08.095+0000",
                    "started": "2022-09-28T14:37:08.095+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812946",
                    "issueId": "13483547"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812947",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #14255:\nURL: https://github.com/apache/arrow/pull/14255#discussion_r982495241\n\n\n##########\ngo/arrow/compute/internal/kernels/_lib/base_arithmetic_avx2_amd64.s:\n##########\n@@ -0,0 +1,12469 @@\n+\t.text\n+\t.intel_syntax noprefix\n+\t.file\t\"base_arithmetic.cc\"\n+\t.globl\tarithmetic_avx2                 # ",
                    "created": "2022-09-28T14:39:48.749+0000",
                    "updated": "2022-09-28T14:39:48.749+0000",
                    "started": "2022-09-28T14:39:48.748+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812947",
                    "issueId": "13483547"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812948",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #14255:\nURL: https://github.com/apache/arrow/pull/14255#discussion_r982495987\n\n\n##########\ngo/arrow/compute/internal/kernels/_lib/base_arithmetic.cc:\n##########\n@@ -0,0 +1,255 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <arch.h>\n+#include <stdint.h>\n+#include \"types.h\"\n+#include \"vendored/safe-math.h\"\n+\n+// Define functions AddWithOverflow, SubtractWithOverflow, MultiplyWithOverflow\n+// with the signature `bool(T u, T v, T* out)` where T is an integer type.\n+// On overflow, these functions return true.  Otherwise, false is returned\n+// and `out` is updated with the result of the operation.\n+\n+#define OP_WITH_OVERFLOW(_func_name, _psnip_op, _type, _psnip_type) \\\n+  static inline bool _func_name(_type u, _type v, _type* out) {     \\\n+    return !psnip_safe_##_psnip_type##_##_psnip_op(out, u, v);      \\\n+  }\n+\n+#define OPS_WITH_OVERFLOW(_func_name, _psnip_op)            \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int8_t, int8)     \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int16_t, int16)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int32_t, int32)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int64_t, int64)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint8_t, uint8)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint16_t, uint16) \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint32_t, uint32) \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint64_t, uint64)\n+\n+OPS_WITH_OVERFLOW(AddWithOverflow, add)\n+OPS_WITH_OVERFLOW(SubtractWithOverflow, sub)\n+OPS_WITH_OVERFLOW(MultiplyWithOverflow, mul)\n+OPS_WITH_OVERFLOW(DivideWithOverflow, div)\n+\n+// Corresponds to equivalent ArithmeticOp enum in base_arithmetic.go\n+// for passing across which operation to perform. This allows simpler\n+// implementation at the cost of having to pass the extra int8 and\n+// perform a switch.\n+//\n+// In cases of small arrays, this is completely negligible. In cases\n+// of large arrays, the time saved by using SIMD here is significantly\n+// worth the cost.\n+enum class optype : int8_t {\n+    ADD,\n+    ADD_CHECKED,\n+    SUB, \n+    SUB_CHECKED,\n+};\n+\n+template <typename T>\n+using is_unsigned_integer_value = bool_constant<is_integral_v<T> && is_unsigned_v<T>>;\n+\n+template <typename T>\n+using is_signed_integer_value = bool_constant<is_integral_v<T> && is_signed_v<T>>;\n+\n+template <typename T, typename R = T>\n+using enable_if_signed_integer_t = enable_if_t<is_signed_integer_value<T>::value, R>;\n+\n+template <typename T, typename R = T>\n+using enable_if_unsigned_integer_t = enable_if_t<is_unsigned_integer_value<T>::value, R>;\n+\n+template <typename T, typename R = T>\n+using enable_if_integer_t = enable_if_t<\n+    is_signed_integer_value<T>::value || is_unsigned_integer_value<T>::value, R>;\n+\n+template <typename T, typename R = T>\n+using enable_if_floating_t = enable_if_t<is_floating_point_v<T>, R>;\n+\n+struct Add {\n+    template <typename T, typename Arg0, typename Arg1>\n+    static constexpr enable_if_floating_t<T> Call(Arg0 left, Arg1 right, bool*) {\n+        return left + right;\n+    }\n+\n+    template <typename T, typename Arg0, typename Arg1>\n+    static constexpr enable_if_integer_t<T> Call(Arg0 left, Arg1 right, bool*) {\n+        return left + right;\n+    }\n\nReview Comment:\n   good point, no need to differentiate them in this case\n\n\n\n",
                    "created": "2022-09-28T14:40:18.331+0000",
                    "updated": "2022-09-28T14:40:18.331+0000",
                    "started": "2022-09-28T14:40:18.331+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812948",
                    "issueId": "13483547"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812952",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #14255:\nURL: https://github.com/apache/arrow/pull/14255#discussion_r982499486\n\n\n##########\ngo/arrow/compute/internal/kernels/_lib/base_arithmetic.cc:\n##########\n@@ -0,0 +1,255 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <arch.h>\n+#include <stdint.h>\n+#include \"types.h\"\n+#include \"vendored/safe-math.h\"\n+\n+// Define functions AddWithOverflow, SubtractWithOverflow, MultiplyWithOverflow\n+// with the signature `bool(T u, T v, T* out)` where T is an integer type.\n+// On overflow, these functions return true.  Otherwise, false is returned\n+// and `out` is updated with the result of the operation.\n+\n+#define OP_WITH_OVERFLOW(_func_name, _psnip_op, _type, _psnip_type) \\\n+  static inline bool _func_name(_type u, _type v, _type* out) {     \\\n+    return !psnip_safe_##_psnip_type##_##_psnip_op(out, u, v);      \\\n+  }\n+\n+#define OPS_WITH_OVERFLOW(_func_name, _psnip_op)            \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int8_t, int8)     \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int16_t, int16)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int32_t, int32)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int64_t, int64)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint8_t, uint8)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint16_t, uint16) \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint32_t, uint32) \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint64_t, uint64)\n+\n+OPS_WITH_OVERFLOW(AddWithOverflow, add)\n+OPS_WITH_OVERFLOW(SubtractWithOverflow, sub)\n+OPS_WITH_OVERFLOW(MultiplyWithOverflow, mul)\n+OPS_WITH_OVERFLOW(DivideWithOverflow, div)\n+\n+// Corresponds to equivalent ArithmeticOp enum in base_arithmetic.go\n+// for passing across which operation to perform. This allows simpler\n+// implementation at the cost of having to pass the extra int8 and\n+// perform a switch.\n+//\n+// In cases of small arrays, this is completely negligible. In cases\n+// of large arrays, the time saved by using SIMD here is significantly\n+// worth the cost.\n+enum class optype : int8_t {\n+    ADD,\n+    ADD_CHECKED,\n+    SUB, \n+    SUB_CHECKED,\n+};\n+\n+template <typename T>\n+using is_unsigned_integer_value = bool_constant<is_integral_v<T> && is_unsigned_v<T>>;\n+\n+template <typename T>\n+using is_signed_integer_value = bool_constant<is_integral_v<T> && is_signed_v<T>>;\n+\n+template <typename T, typename R = T>\n+using enable_if_signed_integer_t = enable_if_t<is_signed_integer_value<T>::value, R>;\n+\n+template <typename T, typename R = T>\n+using enable_if_unsigned_integer_t = enable_if_t<is_unsigned_integer_value<T>::value, R>;\n+\n+template <typename T, typename R = T>\n+using enable_if_integer_t = enable_if_t<\n+    is_signed_integer_value<T>::value || is_unsigned_integer_value<T>::value, R>;\n+\n+template <typename T, typename R = T>\n+using enable_if_floating_t = enable_if_t<is_floating_point_v<T>, R>;\n+\n+struct Add {\n+    template <typename T, typename Arg0, typename Arg1>\n+    static constexpr enable_if_floating_t<T> Call(Arg0 left, Arg1 right, bool*) {\n+        return left + right;\n+    }\n+\n+    template <typename T, typename Arg0, typename Arg1>\n+    static constexpr enable_if_integer_t<T> Call(Arg0 left, Arg1 right, bool*) {\n+        return left + right;\n+    }\n+};\n+\n+struct Sub {\n+    template <typename T, typename Arg0, typename Arg1>\n+    static constexpr enable_if_floating_t<T> Call(Arg0 left, Arg1 right, bool*) {\n+        return left - right;\n+    }\n+\n+    template <typename T, typename Arg0, typename Arg1>\n+    static constexpr enable_if_integer_t<T> Call(Arg0 left, Arg1 right, bool*) {\n+        return left - right;\n+    }\n+};\n+\n+struct AddChecked {\n+    template <typename T, typename Arg0, typename Arg1>\n+    static constexpr enable_if_floating_t<T> Call(Arg0 left, Arg1 right, bool*) {\n+        return left + right;\n+    }\n+\n+    template <typename T, typename Arg0, typename Arg1>\n+    static constexpr enable_if_integer_t<T> Call(Arg0 left, Arg1 right, bool* failure) {\n\nReview Comment:\n   that's a good idea, i didn't even know about `if constexpr` until now :) I'll update this\n\n\n\n",
                    "created": "2022-09-28T14:43:08.501+0000",
                    "updated": "2022-09-28T14:43:08.501+0000",
                    "started": "2022-09-28T14:43:08.500+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812952",
                    "issueId": "13483547"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812953",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #14255:\nURL: https://github.com/apache/arrow/pull/14255#discussion_r982502834\n\n\n##########\ngo/arrow/compute/arithmetic.go:\n##########\n@@ -0,0 +1,155 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package compute\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/kernels\"\n+)\n+\n+type arithmeticFunction struct {\n+\tScalarFunction\n+}\n+\n+func (fn *arithmeticFunction) checkDecimals(vals ...arrow.DataType) error {\n+\tif !hasDecimal(vals...) {\n+\t\treturn nil\n+\t}\n+\n+\tif len(vals) != 2 {\n+\t\treturn nil\n+\t}\n+\n+\top := fn.name[:strings.Index(fn.name, \"_\")]\n+\tswitch op {\n+\tcase \"add\", \"subtract\":\n+\t\treturn castBinaryDecimalArgs(decPromoteAdd, vals...)\n+\tcase \"multiply\":\n+\t\treturn castBinaryDecimalArgs(decPromoteMultiply, vals...)\n+\tcase \"divide\":\n+\t\treturn castBinaryDecimalArgs(decPromoteDivide, vals...)\n+\tdefault:\n+\t\treturn fmt.Errorf(\"%w: invalid decimal function: %s\", arrow.ErrInvalid, fn.name)\n+\t}\n+}\n+\n+func (fn *arithmeticFunction) DispatchBest(vals ...arrow.DataType) (exec.Kernel, error) {\n+\tif err := fn.checkArity(len(vals)); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif err := fn.checkDecimals(vals...); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif kn, err := fn.DispatchExact(vals...); err == nil {\n+\t\treturn kn, nil\n+\t}\n+\n+\tensureDictionaryDecoded(vals...)\n+\n+\t// only promote types for binary funcs\n+\tif len(vals) == 2 {\n+\t\treplaceNullWithOtherType(vals...)\n+\t\tif unit, istime := commonTemporalResolution(vals...); istime {\n+\t\t\treplaceTemporalTypes(unit, vals...)\n+\t\t} else {\n+\t\t\tif dt := commonNumeric(vals...); dt != nil {\n+\t\t\t\treplaceTypes(dt, vals...)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn fn.DispatchExact(vals...)\n+}\n+\n+var (\n+\taddDoc FunctionDoc\n+)\n+\n+func RegisterScalarArithmetic(reg FunctionRegistry) {\n+\taddFn := &arithmeticFunction{*NewScalarFunction(\"add\", Binary(), addDoc)}\n+\tfor _, k := range kernels.GetArithmeticKernels(kernels.OpAdd) {\n+\t\tif err := addFn.AddKernel(k); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}\n+\n+\treg.AddFunction(addFn, false)\n+\n+\taddCheckedFn := &arithmeticFunction{*NewScalarFunction(\"add_checked\", Binary(), addDoc)}\n\nReview Comment:\n   Personally i think unchecked arithmetic is worth adding for performance reasons. If the caller knows that the data will never provide a case which can overflow (or doesn't care if it does) then in the case of large amounts of data it can provide significant performance benefits.\r\n   \r\n   That said, I think I agree with you to make the default be checked and have a separate `add_unchecked`. I'll update it\n\n\n\n",
                    "created": "2022-09-28T14:45:48.698+0000",
                    "updated": "2022-09-28T14:45:48.698+0000",
                    "started": "2022-09-28T14:45:48.698+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812953",
                    "issueId": "13483547"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812954",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #14255:\nURL: https://github.com/apache/arrow/pull/14255#discussion_r982508505\n\n\n##########\ngo/arrow/compute/arithmetic_test.go:\n##########\n@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package compute_test\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/array\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/apache/arrow/go/v10/arrow/scalar\"\n+\t\"github.com/stretchr/testify/suite\"\n+)\n+\n+type binaryFunc = func(context.Context, compute.ArithmeticOptions, compute.Datum, compute.Datum) (compute.Datum, error)\n+\n+type BinaryArithmeticSuite[T exec.NumericTypes] struct {\n\nReview Comment:\n   Haha, Generics were released with go1.18 which came out back in March this year. Since we maintain compatibility with current version - 2 (go1.17) in the existing libs I haven't updated other areas that could benefit from the generics. But I made the `compute` pkg a separate module that requires go1.18 so I can use the generics :smile:\n\n\n\n",
                    "created": "2022-09-28T14:50:24.178+0000",
                    "updated": "2022-09-28T14:50:24.178+0000",
                    "started": "2022-09-28T14:50:24.178+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812954",
                    "issueId": "13483547"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812955",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #14255:\nURL: https://github.com/apache/arrow/pull/14255#discussion_r982510945\n\n\n##########\ngo/arrow/compute/arithmetic_test.go:\n##########\n@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package compute_test\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/array\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/apache/arrow/go/v10/arrow/scalar\"\n+\t\"github.com/stretchr/testify/suite\"\n+)\n+\n+type binaryFunc = func(context.Context, compute.ArithmeticOptions, compute.Datum, compute.Datum) (compute.Datum, error)\n+\n+type BinaryArithmeticSuite[T exec.NumericTypes] struct {\n+\tsuite.Suite\n+\n+\tmem  *memory.CheckedAllocator\n+\topts compute.ArithmeticOptions\n+\tctx  context.Context\n+}\n+\n+func (BinaryArithmeticSuite[T]) DataType() arrow.DataType {\n+\treturn exec.GetDataType[T]()\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) SetupTest() {\n+\tb.mem = memory.NewCheckedAllocator(memory.DefaultAllocator)\n+\tb.opts.CheckOverflow = false\n+\tb.ctx = compute.WithAllocator(context.TODO(), b.mem)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) TearDownTest() {\n+\tb.mem.AssertSize(b.T(), 0)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeNullScalar() scalar.Scalar {\n+\treturn scalar.MakeNullScalar(b.DataType())\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeScalar(val T) scalar.Scalar {\n+\treturn scalar.MakeScalar(val)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalars(fn binaryFunc, lhs, rhs T, expected T) {\n+\tleft, right := b.makeScalar(lhs), b.makeScalar(rhs)\n+\texp := b.makeScalar(expected)\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: left}, &compute.ScalarDatum{Value: right})\n+\tb.NoError(err)\n+\tsc := actual.(*compute.ScalarDatum).Value\n+\n+\tb.Truef(scalar.Equals(exp, sc), \"expected: %s\\ngot: %s\", exp, sc)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScArr(fn binaryFunc, lhs T, rhs, expected string) {\n+\tleft := b.makeScalar(lhs)\n+\tb.assertBinopScalarArr(fn, left, rhs, expected)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalarArr(fn binaryFunc, lhs scalar.Scalar, rhs, expected string) {\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: lhs}, &compute.ArrayDatum{Value: right.Data()})\n+\tb.NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: exp.Data()}, actual)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrSc(fn binaryFunc, lhs string, rhs T, expected string) {\n+\tright := b.makeScalar(rhs)\n+\tb.assertBinopArrScalar(fn, lhs, right, expected)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrScalar(fn binaryFunc, lhs string, rhs scalar.Scalar, expected string) {\n+\tleft, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(lhs))\n+\tdefer left.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ArrayDatum{Value: left.Data()}, &compute.ScalarDatum{Value: rhs})\n+\tb.NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: exp.Data()}, actual)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrays(fn binaryFunc, lhs, rhs, expected string) {\n+\tleft, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(lhs))\n+\tdefer left.Release()\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tb.assertBinop(fn, left, right, exp)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinop(fn binaryFunc, left, right, expected arrow.Array) {\n+\tactual, err := fn(b.ctx, b.opts, &compute.ArrayDatum{Value: left.Data()}, &compute.ArrayDatum{Value: right.Data()})\n+\tb.Require().NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: expected.Data()}, actual)\n+\n+\t// also check (Scalar, Scalar) operations\n\nReview Comment:\n   What do you mean? The difficulty with automatically checking `(Array, Scalar)` and `(Scalar, Array)` automatically is that not all operations are commutative so I can't just use the same expected result.\n\n\n\n",
                    "created": "2022-09-28T14:52:24.393+0000",
                    "updated": "2022-09-28T14:52:24.393+0000",
                    "started": "2022-09-28T14:52:24.392+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812955",
                    "issueId": "13483547"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812957",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #14255:\nURL: https://github.com/apache/arrow/pull/14255#discussion_r982513264\n\n\n##########\ngo/arrow/compute/arithmetic_test.go:\n##########\n@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package compute_test\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/array\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/apache/arrow/go/v10/arrow/scalar\"\n+\t\"github.com/stretchr/testify/suite\"\n+)\n+\n+type binaryFunc = func(context.Context, compute.ArithmeticOptions, compute.Datum, compute.Datum) (compute.Datum, error)\n+\n+type BinaryArithmeticSuite[T exec.NumericTypes] struct {\n+\tsuite.Suite\n+\n+\tmem  *memory.CheckedAllocator\n+\topts compute.ArithmeticOptions\n+\tctx  context.Context\n+}\n+\n+func (BinaryArithmeticSuite[T]) DataType() arrow.DataType {\n+\treturn exec.GetDataType[T]()\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) SetupTest() {\n+\tb.mem = memory.NewCheckedAllocator(memory.DefaultAllocator)\n+\tb.opts.CheckOverflow = false\n+\tb.ctx = compute.WithAllocator(context.TODO(), b.mem)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) TearDownTest() {\n+\tb.mem.AssertSize(b.T(), 0)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeNullScalar() scalar.Scalar {\n+\treturn scalar.MakeNullScalar(b.DataType())\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeScalar(val T) scalar.Scalar {\n+\treturn scalar.MakeScalar(val)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalars(fn binaryFunc, lhs, rhs T, expected T) {\n+\tleft, right := b.makeScalar(lhs), b.makeScalar(rhs)\n+\texp := b.makeScalar(expected)\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: left}, &compute.ScalarDatum{Value: right})\n+\tb.NoError(err)\n+\tsc := actual.(*compute.ScalarDatum).Value\n+\n+\tb.Truef(scalar.Equals(exp, sc), \"expected: %s\\ngot: %s\", exp, sc)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScArr(fn binaryFunc, lhs T, rhs, expected string) {\n+\tleft := b.makeScalar(lhs)\n+\tb.assertBinopScalarArr(fn, left, rhs, expected)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalarArr(fn binaryFunc, lhs scalar.Scalar, rhs, expected string) {\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: lhs}, &compute.ArrayDatum{Value: right.Data()})\n+\tb.NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: exp.Data()}, actual)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrSc(fn binaryFunc, lhs string, rhs T, expected string) {\n+\tright := b.makeScalar(rhs)\n+\tb.assertBinopArrScalar(fn, lhs, right, expected)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrScalar(fn binaryFunc, lhs string, rhs scalar.Scalar, expected string) {\n+\tleft, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(lhs))\n+\tdefer left.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ArrayDatum{Value: left.Data()}, &compute.ScalarDatum{Value: rhs})\n+\tb.NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: exp.Data()}, actual)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrays(fn binaryFunc, lhs, rhs, expected string) {\n+\tleft, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(lhs))\n+\tdefer left.Release()\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tb.assertBinop(fn, left, right, exp)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinop(fn binaryFunc, left, right, expected arrow.Array) {\n+\tactual, err := fn(b.ctx, b.opts, &compute.ArrayDatum{Value: left.Data()}, &compute.ArrayDatum{Value: right.Data()})\n+\tb.Require().NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: expected.Data()}, actual)\n+\n+\t// also check (Scalar, Scalar) operations\n\nReview Comment:\n   Hmm, scratch that, sorry.\n\n\n\n",
                    "created": "2022-09-28T14:54:09.858+0000",
                    "updated": "2022-09-28T14:54:09.858+0000",
                    "started": "2022-09-28T14:54:09.858+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812957",
                    "issueId": "13483547"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812962",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #14255:\nURL: https://github.com/apache/arrow/pull/14255#discussion_r982516764\n\n\n##########\ngo/arrow/compute/arithmetic_test.go:\n##########\n@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package compute_test\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/array\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute\"\n+\t\"github.com/apache/arrow/go/v10/arrow/compute/internal/exec\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/apache/arrow/go/v10/arrow/scalar\"\n+\t\"github.com/stretchr/testify/suite\"\n+)\n+\n+type binaryFunc = func(context.Context, compute.ArithmeticOptions, compute.Datum, compute.Datum) (compute.Datum, error)\n+\n+type BinaryArithmeticSuite[T exec.NumericTypes] struct {\n+\tsuite.Suite\n+\n+\tmem  *memory.CheckedAllocator\n+\topts compute.ArithmeticOptions\n+\tctx  context.Context\n+}\n+\n+func (BinaryArithmeticSuite[T]) DataType() arrow.DataType {\n+\treturn exec.GetDataType[T]()\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) SetupTest() {\n+\tb.mem = memory.NewCheckedAllocator(memory.DefaultAllocator)\n+\tb.opts.CheckOverflow = false\n+\tb.ctx = compute.WithAllocator(context.TODO(), b.mem)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) TearDownTest() {\n+\tb.mem.AssertSize(b.T(), 0)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeNullScalar() scalar.Scalar {\n+\treturn scalar.MakeNullScalar(b.DataType())\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) makeScalar(val T) scalar.Scalar {\n+\treturn scalar.MakeScalar(val)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalars(fn binaryFunc, lhs, rhs T, expected T) {\n+\tleft, right := b.makeScalar(lhs), b.makeScalar(rhs)\n+\texp := b.makeScalar(expected)\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: left}, &compute.ScalarDatum{Value: right})\n+\tb.NoError(err)\n+\tsc := actual.(*compute.ScalarDatum).Value\n+\n+\tb.Truef(scalar.Equals(exp, sc), \"expected: %s\\ngot: %s\", exp, sc)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScArr(fn binaryFunc, lhs T, rhs, expected string) {\n+\tleft := b.makeScalar(lhs)\n+\tb.assertBinopScalarArr(fn, left, rhs, expected)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopScalarArr(fn binaryFunc, lhs scalar.Scalar, rhs, expected string) {\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: lhs}, &compute.ArrayDatum{Value: right.Data()})\n+\tb.NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: exp.Data()}, actual)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrSc(fn binaryFunc, lhs string, rhs T, expected string) {\n+\tright := b.makeScalar(rhs)\n+\tb.assertBinopArrScalar(fn, lhs, right, expected)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrScalar(fn binaryFunc, lhs string, rhs scalar.Scalar, expected string) {\n+\tleft, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(lhs))\n+\tdefer left.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tactual, err := fn(b.ctx, b.opts, &compute.ArrayDatum{Value: left.Data()}, &compute.ScalarDatum{Value: rhs})\n+\tb.NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: exp.Data()}, actual)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopArrays(fn binaryFunc, lhs, rhs, expected string) {\n+\tleft, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(lhs))\n+\tdefer left.Release()\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\texp, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(expected))\n+\tdefer exp.Release()\n+\n+\tb.assertBinop(fn, left, right, exp)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinop(fn binaryFunc, left, right, expected arrow.Array) {\n+\tactual, err := fn(b.ctx, b.opts, &compute.ArrayDatum{Value: left.Data()}, &compute.ArrayDatum{Value: right.Data()})\n+\tb.Require().NoError(err)\n+\tdefer actual.Release()\n+\tassertDatumsEqual(b.T(), &compute.ArrayDatum{Value: expected.Data()}, actual)\n+\n+\t// also check (Scalar, Scalar) operations\n+\tfor i := 0; i < expected.Len(); i++ {\n+\t\ts, err := scalar.GetScalar(expected, i)\n+\t\tb.Require().NoError(err)\n+\t\tlhs, _ := scalar.GetScalar(left, i)\n+\t\trhs, _ := scalar.GetScalar(right, i)\n+\n+\t\tactual, err := fn(b.ctx, b.opts, &compute.ScalarDatum{Value: lhs}, &compute.ScalarDatum{Value: rhs})\n+\t\tb.NoError(err)\n+\t\tb.Truef(scalar.Equals(s, actual.(*compute.ScalarDatum).Value), \"expected: %s\\ngot: %s\", s, actual)\n+\t}\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) setOverflowCheck(value bool) {\n+\tb.opts.CheckOverflow = value\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) assertBinopErr(fn binaryFunc, lhs, rhs, expectedMsg string) {\n+\tleft, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(lhs))\n+\tdefer left.Release()\n+\tright, _, _ := array.FromJSON(b.mem, b.DataType(), strings.NewReader(rhs))\n+\tdefer right.Release()\n+\n+\t_, err := fn(b.ctx, b.opts, &compute.ArrayDatum{left.Data()}, &compute.ArrayDatum{Value: right.Data()})\n+\tb.ErrorIs(err, arrow.ErrInvalid)\n+\tb.ErrorContains(err, expectedMsg)\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) TestAdd() {\n+\tb.Run(b.DataType().String(), func() {\n+\t\tfor _, overflow := range []bool{false, true} {\n+\t\t\tb.Run(fmt.Sprintf(\"overflow=%t\", overflow), func() {\n+\t\t\t\tb.setOverflowCheck(overflow)\n+\n+\t\t\t\tb.assertBinopArrays(compute.Add, `[]`, `[]`, `[]`)\n+\t\t\t\tb.assertBinopArrays(compute.Add, `[3, 2, 6]`, `[1, 0, 2]`, `[4, 2, 8]`)\n+\t\t\t\t// nulls on one side\n+\t\t\t\tb.assertBinopArrays(compute.Add, `[null, 1, null]`, `[3, 4, 5]`, `[null, 5, null]`)\n+\t\t\t\tb.assertBinopArrays(compute.Add, `[3, 4, 5]`, `[null, 1, null]`, `[null, 5, null]`)\n+\t\t\t\t// nulls on both sides\n+\t\t\t\tb.assertBinopArrays(compute.Add, `[null, 1, 2]`, `[3, 4, null]`, `[null, 5, null]`)\n+\t\t\t\t// all nulls\n+\t\t\t\tb.assertBinopArrays(compute.Add, `[null]`, `[null]`, `[null]`)\n+\n+\t\t\t\t// scalar on the left\n+\t\t\t\tb.assertBinopScArr(compute.Add, 3, `[1, 2]`, `[4, 5]`)\n+\t\t\t\tb.assertBinopScArr(compute.Add, 3, `[null, 2]`, `[null, 5]`)\n+\t\t\t\tb.assertBinopScalarArr(compute.Add, b.makeNullScalar(), `[1, 2]`, `[null, null]`)\n+\t\t\t\tb.assertBinopScalarArr(compute.Add, b.makeNullScalar(), `[null, 2]`, `[null, null]`)\n+\t\t\t\t// scalar on the right\n+\t\t\t\tb.assertBinopArrSc(compute.Add, `[1, 2]`, 3, `[4, 5]`)\n+\t\t\t\tb.assertBinopArrSc(compute.Add, `[null, 2]`, 3, `[null, 5]`)\n+\t\t\t\tb.assertBinopArrScalar(compute.Add, `[1, 2]`, b.makeNullScalar(), `[null, null]`)\n+\t\t\t\tb.assertBinopArrScalar(compute.Add, `[null, 2]`, b.makeNullScalar(), `[null, null]`)\n+\t\t\t})\n+\t\t}\n+\t})\n+}\n+\n+func (b *BinaryArithmeticSuite[T]) TestSub() {\n+\tb.Run(b.DataType().String(), func() {\n+\t\tfor _, overflow := range []bool{false, true} {\n+\t\t\tb.Run(fmt.Sprintf(\"overflow=%t\", overflow), func() {\n+\t\t\t\tb.setOverflowCheck(overflow)\n+\n+\t\t\t\tb.assertBinopArrays(compute.Subtract, `[]`, `[]`, `[]`)\n+\t\t\t\tb.assertBinopArrays(compute.Subtract, `[3, 2, 6]`, `[1, 0, 2]`, `[2, 2, 4]`)\n+\t\t\t\t// nulls on one side\n+\t\t\t\tb.assertBinopArrays(compute.Subtract, `[null, 4, null]`, `[2, 1, 0]`, `[null, 3, null]`)\n+\t\t\t\tb.assertBinopArrays(compute.Subtract, `[3, 4, 5]`, `[null, 1, null]`, `[null, 3, null]`)\n+\t\t\t\t// nulls on both sides\n+\t\t\t\tb.assertBinopArrays(compute.Subtract, `[null, 4, 3]`, `[2, 1, null]`, `[null, 3, null]`)\n+\t\t\t\t// all nulls\n+\t\t\t\tb.assertBinopArrays(compute.Subtract, `[null]`, `[null]`, `[null]`)\n+\n+\t\t\t\t// scalar on the left\n+\t\t\t\tb.assertBinopScArr(compute.Subtract, 3, `[1, 2]`, `[2, 1]`)\n+\t\t\t\tb.assertBinopScArr(compute.Subtract, 3, `[null, 2]`, `[null, 1]`)\n+\t\t\t\tb.assertBinopScalarArr(compute.Subtract, b.makeNullScalar(), `[1, 2]`, `[null, null]`)\n+\t\t\t\tb.assertBinopScalarArr(compute.Subtract, b.makeNullScalar(), `[null, 2]`, `[null, null]`)\n+\t\t\t\t// scalar on the right\n+\t\t\t\tb.assertBinopArrSc(compute.Subtract, `[4, 5]`, 3, `[1, 2]`)\n+\t\t\t\tb.assertBinopArrSc(compute.Subtract, `[null, 5]`, 3, `[null, 2]`)\n+\t\t\t\tb.assertBinopArrScalar(compute.Subtract, `[1, 2]`, b.makeNullScalar(), `[null, null]`)\n+\t\t\t\tb.assertBinopArrScalar(compute.Subtract, `[null, 2]`, b.makeNullScalar(), `[null, null]`)\n+\t\t\t})\n+\t\t}\n+\t})\n+}\n+\n+func TestBinaryArithmetic(t *testing.T) {\n+\tsuite.Run(t, new(BinaryArithmeticSuite[int8]))\n\nReview Comment:\n   One benefit of Go is that the compile times are super fast (even with Generics). There isn't really a good way to loop over the data types at compile time, and looping over a slice of  `DataType` instead loses the easy type-safety of the Scalar assertion methods. I'll see what I can come up with in this case\n\n\n\n",
                    "created": "2022-09-28T14:56:55.075+0000",
                    "updated": "2022-09-28T14:56:55.075+0000",
                    "started": "2022-09-28T14:56:55.075+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812962",
                    "issueId": "13483547"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812965",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #14255:\nURL: https://github.com/apache/arrow/pull/14255#discussion_r982521622\n\n\n##########\ngo/arrow/compute/internal/exec/utils.go:\n##########\n@@ -135,6 +135,13 @@ func Min[T constraints.Ordered](a, b T) T {\n \treturn b\n }\n \n+func Max[T constraints.Ordered](a, b T) T {\n\nReview Comment:\n   In the cases where I'm using this, I don't need it to be well-behaved for signed zeros. If i need that behavior then I can cast to `float64` and use `math.Max()` which will be well-behaved for signed zeros\n\n\n\n",
                    "created": "2022-09-28T15:00:45.434+0000",
                    "updated": "2022-09-28T15:00:45.434+0000",
                    "started": "2022-09-28T15:00:45.433+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812965",
                    "issueId": "13483547"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812966",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #14255:\nURL: https://github.com/apache/arrow/pull/14255#discussion_r982525111\n\n\n##########\ngo/arrow/compute/internal/exec/utils.go:\n##########\n@@ -172,6 +179,11 @@ func GetDataType[T NumericTypes | bool | string]() arrow.DataType {\n \treturn typMap[reflect.TypeOf(z)]\n }\n \n+func GetType[T NumericTypes | bool | string]() arrow.Type {\n\nReview Comment:\n   I'll add the docstring, it returns the appropriate `arrow.Type` enum value given the type used in the generic.\r\n   \r\n   It also doesn't make sense to define this for parametric types or allow non-primitive types such as random structs.\n\n\n\n",
                    "created": "2022-09-28T15:03:40.800+0000",
                    "updated": "2022-09-28T15:03:40.800+0000",
                    "started": "2022-09-28T15:03:40.799+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812966",
                    "issueId": "13483547"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812970",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #14255:\nURL: https://github.com/apache/arrow/pull/14255#discussion_r982528106\n\n\n##########\ngo/arrow/compute/internal/exec/utils.go:\n##########\n@@ -172,6 +179,11 @@ func GetDataType[T NumericTypes | bool | string]() arrow.DataType {\n \treturn typMap[reflect.TypeOf(z)]\n }\n \n+func GetType[T NumericTypes | bool | string]() arrow.Type {\n+\tvar z T\n+\treturn typMap[reflect.TypeOf(z)].ID()\n\nReview Comment:\n   unfortunately I'm pretty sure there is an actual map lookup at runtime, making this not something you'd want to do in a tight loop. I primarily use it during function registration with generics and then use a closure around the result when creating the kernels\n\n\n\n",
                    "created": "2022-09-28T15:06:05.956+0000",
                    "updated": "2022-09-28T15:06:05.956+0000",
                    "started": "2022-09-28T15:06:05.956+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812970",
                    "issueId": "13483547"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812972",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #14255:\nURL: https://github.com/apache/arrow/pull/14255#discussion_r982528758\n\n\n##########\ngo/arrow/compute/internal/kernels/_lib/base_arithmetic.cc:\n##########\n@@ -0,0 +1,255 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <arch.h>\n+#include <stdint.h>\n+#include \"types.h\"\n+#include \"vendored/safe-math.h\"\n+\n+// Define functions AddWithOverflow, SubtractWithOverflow, MultiplyWithOverflow\n+// with the signature `bool(T u, T v, T* out)` where T is an integer type.\n+// On overflow, these functions return true.  Otherwise, false is returned\n+// and `out` is updated with the result of the operation.\n+\n+#define OP_WITH_OVERFLOW(_func_name, _psnip_op, _type, _psnip_type) \\\n+  static inline bool _func_name(_type u, _type v, _type* out) {     \\\n+    return !psnip_safe_##_psnip_type##_##_psnip_op(out, u, v);      \\\n+  }\n+\n+#define OPS_WITH_OVERFLOW(_func_name, _psnip_op)            \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int8_t, int8)     \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int16_t, int16)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int32_t, int32)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, int64_t, int64)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint8_t, uint8)   \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint16_t, uint16) \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint32_t, uint32) \\\n+  OP_WITH_OVERFLOW(_func_name, _psnip_op, uint64_t, uint64)\n+\n+OPS_WITH_OVERFLOW(AddWithOverflow, add)\n+OPS_WITH_OVERFLOW(SubtractWithOverflow, sub)\n+OPS_WITH_OVERFLOW(MultiplyWithOverflow, mul)\n+OPS_WITH_OVERFLOW(DivideWithOverflow, div)\n+\n+// Corresponds to equivalent ArithmeticOp enum in base_arithmetic.go\n+// for passing across which operation to perform. This allows simpler\n+// implementation at the cost of having to pass the extra int8 and\n+// perform a switch.\n+//\n+// In cases of small arrays, this is completely negligible. In cases\n+// of large arrays, the time saved by using SIMD here is significantly\n+// worth the cost.\n+enum class optype : int8_t {\n+    ADD,\n+    ADD_CHECKED,\n+    SUB, \n+    SUB_CHECKED,\n+};\n+\n+template <typename T>\n+using is_unsigned_integer_value = bool_constant<is_integral_v<T> && is_unsigned_v<T>>;\n+\n+template <typename T>\n+using is_signed_integer_value = bool_constant<is_integral_v<T> && is_signed_v<T>>;\n+\n+template <typename T, typename R = T>\n+using enable_if_signed_integer_t = enable_if_t<is_signed_integer_value<T>::value, R>;\n+\n+template <typename T, typename R = T>\n+using enable_if_unsigned_integer_t = enable_if_t<is_unsigned_integer_value<T>::value, R>;\n+\n+template <typename T, typename R = T>\n+using enable_if_integer_t = enable_if_t<\n+    is_signed_integer_value<T>::value || is_unsigned_integer_value<T>::value, R>;\n+\n+template <typename T, typename R = T>\n+using enable_if_floating_t = enable_if_t<is_floating_point_v<T>, R>;\n+\n+struct Add {\n\nReview Comment:\n   I did, and I wasn't aware of `if constexpr` until I saw @cyb70289's comment, i'll update this to make it cleaner.\n\n\n\n",
                    "created": "2022-09-28T15:06:40.990+0000",
                    "updated": "2022-09-28T15:06:40.990+0000",
                    "started": "2022-09-28T15:06:40.989+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812972",
                    "issueId": "13483547"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812974",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #14255:\nURL: https://github.com/apache/arrow/pull/14255#discussion_r982530895\n\n\n##########\ngo/arrow/compute/internal/kernels/_lib/types.h:\n##########\n@@ -0,0 +1,477 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// corresponds to datatype.go's arrow.Type\n+enum class arrtype : int {\n+    NULL,\n+    BOOL,\n+    UINT8,\n+    INT8,\n+    UINT16,\n+    INT16,\n+    UINT32,\n+    INT32,\n+    UINT64,\n+    INT64,\n+    FLOAT16,\n+    FLOAT32,\n+    FLOAT64\n+};\n+\n+// The following is copied from <type_traits> since we use -target \n\nReview Comment:\n   it is from libstdc++, we can't copy it here because GPLv3 isn't compatible with Apache v2 license? because we are distributing the source etc.\n\n\n\n",
                    "created": "2022-09-28T15:08:26.125+0000",
                    "updated": "2022-09-28T15:08:26.125+0000",
                    "started": "2022-09-28T15:08:26.125+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812974",
                    "issueId": "13483547"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/worklog/812975",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #14255:\nURL: https://github.com/apache/arrow/pull/14255#discussion_r982531541\n\n\n##########\ngo/arrow/compute/internal/kernels/_lib/base_arithmetic_avx2_amd64.s:\n##########\n@@ -0,0 +1,12469 @@\n+\t.text\n\nReview Comment:\n   It should already be marked as such, `.gitattributes` has `go/**/*.s linguist-generated=true` in it already\n\n\n\n",
                    "created": "2022-09-28T15:08:56.144+0000",
                    "updated": "2022-09-28T15:08:56.144+0000",
                    "started": "2022-09-28T15:08:56.144+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "812975",
                    "issueId": "13483547"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 40200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@76247cfa[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@14cf6280[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@10658b7b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7fd12095[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@15533f2b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@4f1e4e76[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@739c2abd[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@53f69d3[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@919b438[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@34c92693[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@26123b75[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@581daf95[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 40200,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Oct 20 15:17:57 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-10-20T15:17:57.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17871/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2022-09-27T21:34:10.000+0000",
        "updated": "2022-10-20T15:17:57.000+0000",
        "timeoriginalestimate": null,
        "description": "Uses add, add_checked, sub, and sub_checked as the initial implementation, only for integral types and float32/float64.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "11h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 40200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Go] Implement Initial Scalar Binary Arithmetic Infrastructure",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13483547/comment/17621185",
                    "id": "17621185",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=zeroshade",
                        "name": "zeroshade",
                        "key": "zeroshade",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=zeroshade&avatarId=31230",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=zeroshade&avatarId=31230",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=zeroshade&avatarId=31230",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=zeroshade&avatarId=31230"
                        },
                        "displayName": "Matthew Topol",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 14255\n[https://github.com/apache/arrow/pull/14255]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=zeroshade",
                        "name": "zeroshade",
                        "key": "zeroshade",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=zeroshade&avatarId=31230",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=zeroshade&avatarId=31230",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=zeroshade&avatarId=31230",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=zeroshade&avatarId=31230"
                        },
                        "displayName": "Matthew Topol",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2022-10-20T15:17:57.832+0000",
                    "updated": "2022-10-20T15:17:57.832+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z18weo:",
        "customfield_12314139": null
    }
}