{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13234356",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356",
    "key": "ARROW-5378",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12344925",
                "id": "12344925",
                "description": "",
                "name": "0.14.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-07-04"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "filesystem",
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12561265",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12561265",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "outwardIssue": {
                    "id": "13234649",
                    "key": "ARROW-5389",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234649",
                    "fields": {
                        "summary": "[C++] Add an internal temporary directory API",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "aggregateprogress": {
            "progress": 15000,
            "total": 15000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 15000,
            "total": 15000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-5378/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 26,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/247436",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379\n \n \n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-23T14:39:47.010+0000",
                    "updated": "2019-05-23T14:39:47.010+0000",
                    "started": "2019-05-23T14:39:47.010+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "247436",
                    "issueId": "13234356"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/249022",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379#issuecomment-496302296\n \n \n   I will review this in the next day or so\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-27T20:43:08.909+0000",
                    "updated": "2019-05-27T20:43:08.909+0000",
                    "started": "2019-05-27T20:43:08.908+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "249022",
                    "issueId": "13234356"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/250393",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on pull request #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379#discussion_r288690782\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/localfs.h\n ##########\n @@ -0,0 +1,63 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/filesystem/filesystem.h\"\n+\n+namespace arrow {\n+namespace fs {\n+\n+// XXX\n \n Review comment:\n   :wave: \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-29T19:10:11.991+0000",
                    "updated": "2019-05-29T19:10:11.991+0000",
                    "started": "2019-05-29T19:10:11.991+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "250393",
                    "issueId": "13234356"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/250395",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on pull request #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379#discussion_r288685002\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/localfs.cc\n ##########\n @@ -0,0 +1,387 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <chrono>\n+#include <cstring>\n+#include <utility>\n+\n+#ifdef _WIN32\n+#include \"arrow/util/windows_compatibility.h\"\n+#else\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdio.h>\n+#include <sys/stat.h>\n+#endif\n+\n+#include <boost/filesystem.hpp>\n+\n+#include \"arrow/filesystem/localfs.h\"\n+#include \"arrow/filesystem/util-internal.h\"\n+#include \"arrow/io/file.h\"\n+#include \"arrow/util/io-util.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace fs {\n+\n+namespace bfs = ::boost::filesystem;\n+\n+using ::arrow::internal::NativePathString;\n+using ::arrow::internal::PlatformFilename;\n+\n+namespace {\n+\n+#define BOOST_FILESYSTEM_TRY try {\n+#define BOOST_FILESYSTEM_CATCH           \\\n+  }                                      \\\n+  catch (bfs::filesystem_error & _err) { \\\n+    return ToStatus(_err);               \\\n+  }\n+\n+// NOTE: catching filesystem_error gives more context than system::error_code\n+// (it includes the file path(s) in the error message)\n+\n+Status ToStatus(const bfs::filesystem_error& err) { return Status::IOError(err.what()); }\n+\n+template <typename... Args>\n+Status ErrnoToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::ErrnoMessage(errno);\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+#ifdef _WIN32\n+\n+std::string NativeToString(const NativePathString& ns) {\n+  PlatformFilename fn(ns);\n+  return fn.ToString();\n+}\n+\n+template <typename... Args>\n+Status WinErrorToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::WinErrorMessage(GetLastError());\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+TimePoint ToTimePoint(FILETIME ft) {\n+  // Hundreds of nanoseconds between January 1, 1601 (UTC) and the Unix epoch.\n+  static constexpr int64_t kFileTimeEpoch = 11644473600LL * 10000000;\n+\n+  int64_t hundreds = (static_cast<int64_t>(ft.dwHighDateTime) << 32) + ft.dwLowDateTime -\n+                     kFileTimeEpoch;  // hundreds of ns since Unix epoch\n+  std::chrono::nanoseconds ns_count(100 * hundreds);\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats FileInformationToFileStat(const BY_HANDLE_FILE_INFORMATION& info) {\n+  FileStats st;\n+  if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n+    // Regular file\n+    st.set_type(FileType::File);\n+    st.set_size((static_cast<int64_t>(info.nFileSizeHigh) << 32) + info.nFileSizeLow);\n+  }\n+  st.set_mtime(ToTimePoint(info.ftLastWriteTime));\n+  return st;\n+}\n+\n+Status StatFile(const std::wstring& path, FileStats* out) {\n+  HANDLE h;\n+  std::string bytes_path = NativeToString(path);\n+\n+  /* Inspired by CPython, see Modules/posixmodule.c */\n+  h = CreateFileW(path.c_str(), FILE_READ_ATTRIBUTES, /* desired access */\n+                  0,                                  /* share mode */\n+                  NULL,                               /* security attributes */\n+                  OPEN_EXISTING,\n+                  /* FILE_FLAG_BACKUP_SEMANTICS is required to open a directory */\n+                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n+\n+  if (h == INVALID_HANDLE_VALUE) {\n+    DWORD err = GetLastError();\n+    if (err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND) {\n+      out->set_path(bytes_path);\n+      out->set_type(FileType::NonExistent);\n+      out->set_mtime(kNoTime);\n+      out->set_size(kNoSize);\n+      return Status::OK();\n+    } else {\n+      return WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    }\n+  }\n+  BY_HANDLE_FILE_INFORMATION info;\n+  if (!GetFileInformationByHandle(h, &info)) {\n+    Status st =\n+        WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    CloseHandle(h);\n+    return st;\n+  }\n+  CloseHandle(h);\n+  *out = FileInformationToFileStat(info);\n+  out->set_path(bytes_path);\n+  return Status::OK();\n+}\n+\n+#else  // POSIX systems\n+\n+TimePoint ToTimePoint(const struct timespec& s) {\n+  std::chrono::nanoseconds ns_count(static_cast<int64_t>(s.tv_sec) * 1000000000 +\n+                                    static_cast<int64_t>(s.tv_nsec));\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats StatToFileStat(const struct stat& s) {\n+  FileStats st;\n+  if (S_ISREG(s.st_mode)) {\n+    st.set_type(FileType::File);\n+    st.set_size(static_cast<int64_t>(s.st_size));\n+  } else if (S_ISDIR(s.st_mode)) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n+    st.set_type(FileType::Unknown);\n+    st.set_size(kNoSize);\n+  }\n+#ifdef __APPLE__\n+  // macOS doesn't use the POSIX-compliant spelling\n+  st.set_mtime(ToTimePoint(s.st_mtimespec));\n+#else\n+  st.set_mtime(ToTimePoint(s.st_mtim));\n+#endif\n+  return st;\n+}\n+\n+Status StatFile(const std::string& path, FileStats* out) {\n+  struct stat s;\n+  int r = stat(path.c_str(), &s);\n+  if (r == -1) {\n+    if (errno == ENOENT || errno == ENOTDIR || errno == ELOOP) {\n+      out->set_type(FileType::NonExistent);\n+      out->set_mtime(kNoTime);\n+      out->set_size(kNoSize);\n+    } else {\n+      return ErrnoToStatus(\"Failed stat()ing path '\", path, \"'\");\n+    }\n+  } else {\n+    *out = StatToFileStat(s);\n+  }\n+  out->set_path(path);\n+  return Status::OK();\n+}\n+\n+#endif\n+\n+Status StatSelector(const NativePathString& path, const Selector& select,\n+                    std::vector<FileStats>* out) {\n+  bfs::path p(path);\n+\n+  if (select.allow_non_existent) {\n+    bfs::file_status st;\n+    BOOST_FILESYSTEM_TRY\n+    st = bfs::status(p);\n+    BOOST_FILESYSTEM_CATCH\n+    if (st.type() == bfs::file_not_found) {\n+      return Status::OK();\n+    }\n+  }\n+\n+  BOOST_FILESYSTEM_TRY\n+  for (const auto& entry : bfs::directory_iterator(p)) {\n+    FileStats st;\n+    NativePathString ns = entry.path().native();\n+    RETURN_NOT_OK(StatFile(ns, &st));\n+    if (st.type() != FileType::NonExistent) {\n+      out->push_back(std::move(st));\n+    }\n+    if (select.recursive && st.type() == FileType::Directory) {\n+      RETURN_NOT_OK(StatSelector(ns, select, out));\n+    }\n+  }\n+  BOOST_FILESYSTEM_CATCH\n+\n+  return Status::OK();\n+}\n+\n+}  // namespace\n+\n+LocalFileSystem::LocalFileSystem() {}\n+\n+LocalFileSystem::~LocalFileSystem() {}\n+\n+Status LocalFileSystem::GetTargetStats(const std::string& path, FileStats* out) {\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  return StatFile(fn.ToNative(), out);\n+}\n+\n+Status LocalFileSystem::GetTargetStats(const Selector& select,\n+                                       std::vector<FileStats>* out) {\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(select.base_dir, &fn));\n+  out->clear();\n+  return StatSelector(fn.ToNative(), select, out);\n+}\n+\n+Status LocalFileSystem::CreateDir(const std::string& path, bool recursive) {\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  if (recursive) {\n+    return ::arrow::internal::CreateDirTree(fn);\n+  } else {\n+    return ::arrow::internal::CreateDir(fn);\n+  }\n+}\n+\n+Status LocalFileSystem::DeleteDir(const std::string& path) {\n+  bool deleted = false;\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(::arrow::internal::DeleteDirTree(fn, &deleted));\n+  if (deleted) {\n+    return Status::OK();\n+  } else {\n+    return Status::IOError(\"Directory does not exist: '\", path, \"'\");\n+  }\n+}\n+\n+Status LocalFileSystem::DeleteFile(const std::string& path) {\n+  bool deleted = false;\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(::arrow::internal::DeleteFile(fn, &deleted));\n+  if (deleted) {\n+    return Status::OK();\n+  } else {\n+    return Status::IOError(\"File does not exist: '\", path, \"'\");\n+  }\n+}\n+\n+Status LocalFileSystem::Move(const std::string& src, const std::string& dest) {\n+  PlatformFilename sfn, dfn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(src, &sfn));\n+  RETURN_NOT_OK(PlatformFilename::FromString(dest, &dfn));\n+\n+#ifdef _WIN32\n+  if (!MoveFileExW(sfn.ToNative().c_str(), dfn.ToNative().c_str(),\n+                   MOVEFILE_REPLACE_EXISTING)) {\n+    return WinErrorToStatus(\"Failed renaming '\", sfn.ToString(), \"' to '\", dfn.ToString(),\n+                            \"': \");\n+  }\n+#else\n+  if (rename(sfn.ToNative().c_str(), dfn.ToNative().c_str()) == -1) {\n+    return ErrnoToStatus(\"Failed renaming '\", sfn.ToString(), \"' to '\", dfn.ToString(),\n+                         \"': \");\n+  }\n+#endif\n+  return Status::OK();\n+}\n+\n+Status LocalFileSystem::CopyFile(const std::string& src, const std::string& dest) {\n+  PlatformFilename sfn, dfn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(src, &sfn));\n+  RETURN_NOT_OK(PlatformFilename::FromString(dest, &dfn));\n+  // XXX should we use fstat() to compare inodes?\n \n Review comment:\n   For reference, it would also catch hardlinks but not symlinks.\r\n   \r\n   ```\r\n   01:fsaintjacques/ $ touch herp\r\n   01:fsaintjacques/ $ ln -s herp derp\r\n   01:fsaintjacques/ $ ln herp merp\r\n   01:fsaintjacques/ $ stat herp derp merp\r\n     File: herp\r\n     Size: 0               Blocks: 0          IO Block: 4096   regular empty file\r\n   Device: 10302h/66306d   Inode: 10622250    Links: 2\r\n   ...\r\n     File: derp -> herp\r\n     Size: 4               Blocks: 0          IO Block: 4096   symbolic link\r\n   Device: 10302h/66306d   Inode: 10629003    Links: 1\r\n   ...\r\n     File: merp\r\n     Size: 0               Blocks: 0          IO Block: 4096   regular empty file\r\n   Device: 10302h/66306d   Inode: 10622250    Links: 2\r\n   ...\r\n   ```\r\n   And I suspect this is filesystem (ext4, ...) dependent. I would say, drop this idea since hardlink usage is rare.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-29T19:10:14.594+0000",
                    "updated": "2019-05-29T19:10:14.594+0000",
                    "started": "2019-05-29T19:10:14.593+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "250395",
                    "issueId": "13234356"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/250396",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on pull request #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379#discussion_r288681514\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/localfs.cc\n ##########\n @@ -0,0 +1,387 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <chrono>\n+#include <cstring>\n+#include <utility>\n+\n+#ifdef _WIN32\n+#include \"arrow/util/windows_compatibility.h\"\n+#else\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdio.h>\n+#include <sys/stat.h>\n+#endif\n+\n+#include <boost/filesystem.hpp>\n+\n+#include \"arrow/filesystem/localfs.h\"\n+#include \"arrow/filesystem/util-internal.h\"\n+#include \"arrow/io/file.h\"\n+#include \"arrow/util/io-util.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace fs {\n+\n+namespace bfs = ::boost::filesystem;\n+\n+using ::arrow::internal::NativePathString;\n+using ::arrow::internal::PlatformFilename;\n+\n+namespace {\n+\n+#define BOOST_FILESYSTEM_TRY try {\n+#define BOOST_FILESYSTEM_CATCH           \\\n+  }                                      \\\n+  catch (bfs::filesystem_error & _err) { \\\n+    return ToStatus(_err);               \\\n+  }\n+\n+// NOTE: catching filesystem_error gives more context than system::error_code\n+// (it includes the file path(s) in the error message)\n+\n+Status ToStatus(const bfs::filesystem_error& err) { return Status::IOError(err.what()); }\n+\n+template <typename... Args>\n+Status ErrnoToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::ErrnoMessage(errno);\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+#ifdef _WIN32\n+\n+std::string NativeToString(const NativePathString& ns) {\n+  PlatformFilename fn(ns);\n+  return fn.ToString();\n+}\n+\n+template <typename... Args>\n+Status WinErrorToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::WinErrorMessage(GetLastError());\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+TimePoint ToTimePoint(FILETIME ft) {\n+  // Hundreds of nanoseconds between January 1, 1601 (UTC) and the Unix epoch.\n+  static constexpr int64_t kFileTimeEpoch = 11644473600LL * 10000000;\n+\n+  int64_t hundreds = (static_cast<int64_t>(ft.dwHighDateTime) << 32) + ft.dwLowDateTime -\n+                     kFileTimeEpoch;  // hundreds of ns since Unix epoch\n+  std::chrono::nanoseconds ns_count(100 * hundreds);\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats FileInformationToFileStat(const BY_HANDLE_FILE_INFORMATION& info) {\n+  FileStats st;\n+  if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n+    // Regular file\n+    st.set_type(FileType::File);\n+    st.set_size((static_cast<int64_t>(info.nFileSizeHigh) << 32) + info.nFileSizeLow);\n+  }\n+  st.set_mtime(ToTimePoint(info.ftLastWriteTime));\n+  return st;\n+}\n+\n+Status StatFile(const std::wstring& path, FileStats* out) {\n+  HANDLE h;\n+  std::string bytes_path = NativeToString(path);\n+\n+  /* Inspired by CPython, see Modules/posixmodule.c */\n+  h = CreateFileW(path.c_str(), FILE_READ_ATTRIBUTES, /* desired access */\n+                  0,                                  /* share mode */\n+                  NULL,                               /* security attributes */\n+                  OPEN_EXISTING,\n+                  /* FILE_FLAG_BACKUP_SEMANTICS is required to open a directory */\n+                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n+\n+  if (h == INVALID_HANDLE_VALUE) {\n+    DWORD err = GetLastError();\n+    if (err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND) {\n+      out->set_path(bytes_path);\n+      out->set_type(FileType::NonExistent);\n+      out->set_mtime(kNoTime);\n+      out->set_size(kNoSize);\n+      return Status::OK();\n+    } else {\n+      return WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    }\n+  }\n+  BY_HANDLE_FILE_INFORMATION info;\n+  if (!GetFileInformationByHandle(h, &info)) {\n+    Status st =\n+        WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    CloseHandle(h);\n+    return st;\n+  }\n+  CloseHandle(h);\n+  *out = FileInformationToFileStat(info);\n+  out->set_path(bytes_path);\n+  return Status::OK();\n+}\n+\n+#else  // POSIX systems\n+\n+TimePoint ToTimePoint(const struct timespec& s) {\n+  std::chrono::nanoseconds ns_count(static_cast<int64_t>(s.tv_sec) * 1000000000 +\n+                                    static_cast<int64_t>(s.tv_nsec));\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats StatToFileStat(const struct stat& s) {\n+  FileStats st;\n+  if (S_ISREG(s.st_mode)) {\n+    st.set_type(FileType::File);\n+    st.set_size(static_cast<int64_t>(s.st_size));\n+  } else if (S_ISDIR(s.st_mode)) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n \n Review comment:\n   What about symlinks? Should we follow, or leave it like this, this could break logic that switch on the file type (or any indirect attribute like size). I think it's worth opening a followup ticket.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-29T19:10:14.670+0000",
                    "updated": "2019-05-29T19:10:14.670+0000",
                    "started": "2019-05-29T19:10:14.670+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "250396",
                    "issueId": "13234356"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/250397",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on pull request #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379#discussion_r288695516\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/localfs.cc\n ##########\n @@ -0,0 +1,387 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <chrono>\n+#include <cstring>\n+#include <utility>\n+\n+#ifdef _WIN32\n+#include \"arrow/util/windows_compatibility.h\"\n+#else\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdio.h>\n+#include <sys/stat.h>\n+#endif\n+\n+#include <boost/filesystem.hpp>\n+\n+#include \"arrow/filesystem/localfs.h\"\n+#include \"arrow/filesystem/util-internal.h\"\n+#include \"arrow/io/file.h\"\n+#include \"arrow/util/io-util.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace fs {\n+\n+namespace bfs = ::boost::filesystem;\n+\n+using ::arrow::internal::NativePathString;\n+using ::arrow::internal::PlatformFilename;\n+\n+namespace {\n+\n+#define BOOST_FILESYSTEM_TRY try {\n+#define BOOST_FILESYSTEM_CATCH           \\\n+  }                                      \\\n+  catch (bfs::filesystem_error & _err) { \\\n+    return ToStatus(_err);               \\\n+  }\n+\n+// NOTE: catching filesystem_error gives more context than system::error_code\n+// (it includes the file path(s) in the error message)\n+\n+Status ToStatus(const bfs::filesystem_error& err) { return Status::IOError(err.what()); }\n+\n+template <typename... Args>\n+Status ErrnoToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::ErrnoMessage(errno);\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+#ifdef _WIN32\n+\n+std::string NativeToString(const NativePathString& ns) {\n+  PlatformFilename fn(ns);\n+  return fn.ToString();\n+}\n+\n+template <typename... Args>\n+Status WinErrorToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::WinErrorMessage(GetLastError());\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+TimePoint ToTimePoint(FILETIME ft) {\n+  // Hundreds of nanoseconds between January 1, 1601 (UTC) and the Unix epoch.\n+  static constexpr int64_t kFileTimeEpoch = 11644473600LL * 10000000;\n+\n+  int64_t hundreds = (static_cast<int64_t>(ft.dwHighDateTime) << 32) + ft.dwLowDateTime -\n+                     kFileTimeEpoch;  // hundreds of ns since Unix epoch\n+  std::chrono::nanoseconds ns_count(100 * hundreds);\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats FileInformationToFileStat(const BY_HANDLE_FILE_INFORMATION& info) {\n+  FileStats st;\n+  if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n+    // Regular file\n+    st.set_type(FileType::File);\n+    st.set_size((static_cast<int64_t>(info.nFileSizeHigh) << 32) + info.nFileSizeLow);\n+  }\n+  st.set_mtime(ToTimePoint(info.ftLastWriteTime));\n+  return st;\n+}\n+\n+Status StatFile(const std::wstring& path, FileStats* out) {\n+  HANDLE h;\n+  std::string bytes_path = NativeToString(path);\n+\n+  /* Inspired by CPython, see Modules/posixmodule.c */\n+  h = CreateFileW(path.c_str(), FILE_READ_ATTRIBUTES, /* desired access */\n+                  0,                                  /* share mode */\n+                  NULL,                               /* security attributes */\n+                  OPEN_EXISTING,\n+                  /* FILE_FLAG_BACKUP_SEMANTICS is required to open a directory */\n+                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n+\n+  if (h == INVALID_HANDLE_VALUE) {\n+    DWORD err = GetLastError();\n+    if (err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND) {\n+      out->set_path(bytes_path);\n+      out->set_type(FileType::NonExistent);\n+      out->set_mtime(kNoTime);\n+      out->set_size(kNoSize);\n+      return Status::OK();\n+    } else {\n+      return WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    }\n+  }\n+  BY_HANDLE_FILE_INFORMATION info;\n+  if (!GetFileInformationByHandle(h, &info)) {\n+    Status st =\n+        WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    CloseHandle(h);\n+    return st;\n+  }\n+  CloseHandle(h);\n+  *out = FileInformationToFileStat(info);\n+  out->set_path(bytes_path);\n+  return Status::OK();\n+}\n+\n+#else  // POSIX systems\n+\n+TimePoint ToTimePoint(const struct timespec& s) {\n+  std::chrono::nanoseconds ns_count(static_cast<int64_t>(s.tv_sec) * 1000000000 +\n+                                    static_cast<int64_t>(s.tv_nsec));\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats StatToFileStat(const struct stat& s) {\n+  FileStats st;\n+  if (S_ISREG(s.st_mode)) {\n+    st.set_type(FileType::File);\n+    st.set_size(static_cast<int64_t>(s.st_size));\n+  } else if (S_ISDIR(s.st_mode)) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n+    st.set_type(FileType::Unknown);\n+    st.set_size(kNoSize);\n+  }\n+#ifdef __APPLE__\n+  // macOS doesn't use the POSIX-compliant spelling\n+  st.set_mtime(ToTimePoint(s.st_mtimespec));\n+#else\n+  st.set_mtime(ToTimePoint(s.st_mtim));\n+#endif\n+  return st;\n+}\n+\n+Status StatFile(const std::string& path, FileStats* out) {\n+  struct stat s;\n+  int r = stat(path.c_str(), &s);\n+  if (r == -1) {\n+    if (errno == ENOENT || errno == ENOTDIR || errno == ELOOP) {\n+      out->set_type(FileType::NonExistent);\n+      out->set_mtime(kNoTime);\n+      out->set_size(kNoSize);\n+    } else {\n+      return ErrnoToStatus(\"Failed stat()ing path '\", path, \"'\");\n+    }\n+  } else {\n+    *out = StatToFileStat(s);\n+  }\n+  out->set_path(path);\n+  return Status::OK();\n+}\n+\n+#endif\n+\n+Status StatSelector(const NativePathString& path, const Selector& select,\n+                    std::vector<FileStats>* out) {\n+  bfs::path p(path);\n+\n+  if (select.allow_non_existent) {\n+    bfs::file_status st;\n+    BOOST_FILESYSTEM_TRY\n+    st = bfs::status(p);\n+    BOOST_FILESYSTEM_CATCH\n+    if (st.type() == bfs::file_not_found) {\n+      return Status::OK();\n+    }\n+  }\n+\n+  BOOST_FILESYSTEM_TRY\n+  for (const auto& entry : bfs::directory_iterator(p)) {\n+    FileStats st;\n+    NativePathString ns = entry.path().native();\n+    RETURN_NOT_OK(StatFile(ns, &st));\n+    if (st.type() != FileType::NonExistent) {\n+      out->push_back(std::move(st));\n+    }\n+    if (select.recursive && st.type() == FileType::Directory) {\n+      RETURN_NOT_OK(StatSelector(ns, select, out));\n+    }\n+  }\n+  BOOST_FILESYSTEM_CATCH\n+\n+  return Status::OK();\n+}\n+\n+}  // namespace\n+\n+LocalFileSystem::LocalFileSystem() {}\n+\n+LocalFileSystem::~LocalFileSystem() {}\n+\n+Status LocalFileSystem::GetTargetStats(const std::string& path, FileStats* out) {\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  return StatFile(fn.ToNative(), out);\n+}\n+\n+Status LocalFileSystem::GetTargetStats(const Selector& select,\n+                                       std::vector<FileStats>* out) {\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(select.base_dir, &fn));\n+  out->clear();\n+  return StatSelector(fn.ToNative(), select, out);\n+}\n+\n+Status LocalFileSystem::CreateDir(const std::string& path, bool recursive) {\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  if (recursive) {\n+    return ::arrow::internal::CreateDirTree(fn);\n+  } else {\n+    return ::arrow::internal::CreateDir(fn);\n+  }\n+}\n+\n+Status LocalFileSystem::DeleteDir(const std::string& path) {\n+  bool deleted = false;\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(::arrow::internal::DeleteDirTree(fn, &deleted));\n+  if (deleted) {\n+    return Status::OK();\n+  } else {\n+    return Status::IOError(\"Directory does not exist: '\", path, \"'\");\n+  }\n+}\n+\n+Status LocalFileSystem::DeleteFile(const std::string& path) {\n+  bool deleted = false;\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(::arrow::internal::DeleteFile(fn, &deleted));\n+  if (deleted) {\n+    return Status::OK();\n+  } else {\n+    return Status::IOError(\"File does not exist: '\", path, \"'\");\n+  }\n+}\n+\n+Status LocalFileSystem::Move(const std::string& src, const std::string& dest) {\n+  PlatformFilename sfn, dfn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(src, &sfn));\n+  RETURN_NOT_OK(PlatformFilename::FromString(dest, &dfn));\n+\n+#ifdef _WIN32\n+  if (!MoveFileExW(sfn.ToNative().c_str(), dfn.ToNative().c_str(),\n+                   MOVEFILE_REPLACE_EXISTING)) {\n+    return WinErrorToStatus(\"Failed renaming '\", sfn.ToString(), \"' to '\", dfn.ToString(),\n+                            \"': \");\n+  }\n+#else\n+  if (rename(sfn.ToNative().c_str(), dfn.ToNative().c_str()) == -1) {\n+    return ErrnoToStatus(\"Failed renaming '\", sfn.ToString(), \"' to '\", dfn.ToString(),\n+                         \"': \");\n+  }\n+#endif\n+  return Status::OK();\n+}\n+\n+Status LocalFileSystem::CopyFile(const std::string& src, const std::string& dest) {\n+  PlatformFilename sfn, dfn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(src, &sfn));\n+  RETURN_NOT_OK(PlatformFilename::FromString(dest, &dfn));\n+  // XXX should we use fstat() to compare inodes?\n+  if (sfn.ToNative() == dfn.ToNative()) {\n+    return Status::OK();\n+  }\n+\n+#ifdef _WIN32\n+  if (!CopyFileW(sfn.ToNative().c_str(), dfn.ToNative().c_str(),\n+                 FALSE /* bFailIfExists */)) {\n+    return WinErrorToStatus(\"Failed copying '\", sfn.ToString(), \"' to '\", dfn.ToString(),\n+                            \"': \");\n+  }\n+  return Status::OK();\n+#else\n+  std::shared_ptr<io::InputStream> is;\n+  std::shared_ptr<io::OutputStream> os;\n+  RETURN_NOT_OK(OpenInputStream(src, &is));\n+  RETURN_NOT_OK(OpenOutputStream(dest, &os));\n+  RETURN_NOT_OK(internal::CopyStream(is, os, 1024 * 1024 /* chunk_size */));\n+  RETURN_NOT_OK(os->Close());\n+  return is->Close();\n+#endif\n+}\n+\n+Status LocalFileSystem::OpenInputStream(const std::string& path,\n+                                        std::shared_ptr<io::InputStream>* out) {\n+  PlatformFilename fn;\n+  int fd;\n+  std::shared_ptr<io::ReadableFile> file;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(::arrow::internal::FileOpenReadable(fn, &fd));\n+  Status st = io::ReadableFile::Open(fd, &file);\n+  if (!st.ok()) {\n+    ARROW_UNUSED(::arrow::internal::FileClose(fd));\n+  }\n+  *out = std::move(file);\n+  return st;\n+}\n+\n+Status LocalFileSystem::OpenInputFile(const std::string& path,\n+                                      std::shared_ptr<io::RandomAccessFile>* out) {\n+  PlatformFilename fn;\n+  int fd;\n+  std::shared_ptr<io::ReadableFile> file;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(::arrow::internal::FileOpenReadable(fn, &fd));\n+  Status st = io::ReadableFile::Open(fd, &file);\n+  if (!st.ok()) {\n+    ARROW_UNUSED(::arrow::internal::FileClose(fd));\n+  }\n+  *out = std::move(file);\n+  return st;\n+}\n+\n+Status LocalFileSystem::OpenOutputStream(const std::string& path,\n+                                         std::shared_ptr<io::OutputStream>* out) {\n+  PlatformFilename fn;\n+  int fd;\n+  bool write_only = true;\n+  bool truncate = true;\n+  bool append = false;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(\n+      ::arrow::internal::FileOpenWritable(fn, write_only, truncate, append, &fd));\n+  Status st = io::FileOutputStream::Open(fd, out);\n+  if (!st.ok()) {\n+    ARROW_UNUSED(::arrow::internal::FileClose(fd));\n+  }\n+  return st;\n+}\n+\n+Status LocalFileSystem::OpenAppendStream(const std::string& path,\n+                                         std::shared_ptr<io::OutputStream>* out) {\n+  PlatformFilename fn;\n \n Review comment:\n   if only `truncate` changes, add a protected function and dispatch with only the difference (such that you don't repeat the body twice).\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-29T19:10:14.740+0000",
                    "updated": "2019-05-29T19:10:14.740+0000",
                    "started": "2019-05-29T19:10:14.740+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "250397",
                    "issueId": "13234356"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/250398",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on pull request #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379#discussion_r288674444\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/filesystem.h\n ##########\n @@ -179,5 +194,48 @@ class ARROW_EXPORT FileSystem {\n                                   std::shared_ptr<io::OutputStream>* out) = 0;\n };\n \n+// XXX\n \n Review comment:\n   :wave: \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-29T19:10:15.659+0000",
                    "updated": "2019-05-29T19:10:15.659+0000",
                    "started": "2019-05-29T19:10:15.659+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "250398",
                    "issueId": "13234356"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/250436",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379#discussion_r288739588\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/localfs.cc\n ##########\n @@ -0,0 +1,387 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <chrono>\n+#include <cstring>\n+#include <utility>\n+\n+#ifdef _WIN32\n+#include \"arrow/util/windows_compatibility.h\"\n+#else\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdio.h>\n+#include <sys/stat.h>\n+#endif\n+\n+#include <boost/filesystem.hpp>\n+\n+#include \"arrow/filesystem/localfs.h\"\n+#include \"arrow/filesystem/util-internal.h\"\n+#include \"arrow/io/file.h\"\n+#include \"arrow/util/io-util.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace fs {\n+\n+namespace bfs = ::boost::filesystem;\n+\n+using ::arrow::internal::NativePathString;\n+using ::arrow::internal::PlatformFilename;\n+\n+namespace {\n+\n+#define BOOST_FILESYSTEM_TRY try {\n+#define BOOST_FILESYSTEM_CATCH           \\\n+  }                                      \\\n+  catch (bfs::filesystem_error & _err) { \\\n+    return ToStatus(_err);               \\\n+  }\n+\n+// NOTE: catching filesystem_error gives more context than system::error_code\n+// (it includes the file path(s) in the error message)\n+\n+Status ToStatus(const bfs::filesystem_error& err) { return Status::IOError(err.what()); }\n+\n+template <typename... Args>\n+Status ErrnoToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::ErrnoMessage(errno);\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+#ifdef _WIN32\n+\n+std::string NativeToString(const NativePathString& ns) {\n+  PlatformFilename fn(ns);\n+  return fn.ToString();\n+}\n+\n+template <typename... Args>\n+Status WinErrorToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::WinErrorMessage(GetLastError());\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+TimePoint ToTimePoint(FILETIME ft) {\n+  // Hundreds of nanoseconds between January 1, 1601 (UTC) and the Unix epoch.\n+  static constexpr int64_t kFileTimeEpoch = 11644473600LL * 10000000;\n+\n+  int64_t hundreds = (static_cast<int64_t>(ft.dwHighDateTime) << 32) + ft.dwLowDateTime -\n+                     kFileTimeEpoch;  // hundreds of ns since Unix epoch\n+  std::chrono::nanoseconds ns_count(100 * hundreds);\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats FileInformationToFileStat(const BY_HANDLE_FILE_INFORMATION& info) {\n+  FileStats st;\n+  if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n+    // Regular file\n+    st.set_type(FileType::File);\n+    st.set_size((static_cast<int64_t>(info.nFileSizeHigh) << 32) + info.nFileSizeLow);\n+  }\n+  st.set_mtime(ToTimePoint(info.ftLastWriteTime));\n+  return st;\n+}\n+\n+Status StatFile(const std::wstring& path, FileStats* out) {\n+  HANDLE h;\n+  std::string bytes_path = NativeToString(path);\n+\n+  /* Inspired by CPython, see Modules/posixmodule.c */\n+  h = CreateFileW(path.c_str(), FILE_READ_ATTRIBUTES, /* desired access */\n+                  0,                                  /* share mode */\n+                  NULL,                               /* security attributes */\n+                  OPEN_EXISTING,\n+                  /* FILE_FLAG_BACKUP_SEMANTICS is required to open a directory */\n+                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n+\n+  if (h == INVALID_HANDLE_VALUE) {\n+    DWORD err = GetLastError();\n+    if (err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND) {\n+      out->set_path(bytes_path);\n+      out->set_type(FileType::NonExistent);\n+      out->set_mtime(kNoTime);\n+      out->set_size(kNoSize);\n+      return Status::OK();\n+    } else {\n+      return WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    }\n+  }\n+  BY_HANDLE_FILE_INFORMATION info;\n+  if (!GetFileInformationByHandle(h, &info)) {\n+    Status st =\n+        WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    CloseHandle(h);\n+    return st;\n+  }\n+  CloseHandle(h);\n+  *out = FileInformationToFileStat(info);\n+  out->set_path(bytes_path);\n+  return Status::OK();\n+}\n+\n+#else  // POSIX systems\n+\n+TimePoint ToTimePoint(const struct timespec& s) {\n+  std::chrono::nanoseconds ns_count(static_cast<int64_t>(s.tv_sec) * 1000000000 +\n+                                    static_cast<int64_t>(s.tv_nsec));\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats StatToFileStat(const struct stat& s) {\n+  FileStats st;\n+  if (S_ISREG(s.st_mode)) {\n+    st.set_type(FileType::File);\n+    st.set_size(static_cast<int64_t>(s.st_size));\n+  } else if (S_ISDIR(s.st_mode)) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n \n Review comment:\n   Symlinks are automatically followed by `stat()`. \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-29T19:50:21.364+0000",
                    "updated": "2019-05-29T19:50:21.364+0000",
                    "started": "2019-05-29T19:50:21.363+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "250436",
                    "issueId": "13234356"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/250437",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379#discussion_r288740885\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/localfs.cc\n ##########\n @@ -0,0 +1,387 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <chrono>\n+#include <cstring>\n+#include <utility>\n+\n+#ifdef _WIN32\n+#include \"arrow/util/windows_compatibility.h\"\n+#else\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdio.h>\n+#include <sys/stat.h>\n+#endif\n+\n+#include <boost/filesystem.hpp>\n+\n+#include \"arrow/filesystem/localfs.h\"\n+#include \"arrow/filesystem/util-internal.h\"\n+#include \"arrow/io/file.h\"\n+#include \"arrow/util/io-util.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace fs {\n+\n+namespace bfs = ::boost::filesystem;\n+\n+using ::arrow::internal::NativePathString;\n+using ::arrow::internal::PlatformFilename;\n+\n+namespace {\n+\n+#define BOOST_FILESYSTEM_TRY try {\n+#define BOOST_FILESYSTEM_CATCH           \\\n+  }                                      \\\n+  catch (bfs::filesystem_error & _err) { \\\n+    return ToStatus(_err);               \\\n+  }\n+\n+// NOTE: catching filesystem_error gives more context than system::error_code\n+// (it includes the file path(s) in the error message)\n+\n+Status ToStatus(const bfs::filesystem_error& err) { return Status::IOError(err.what()); }\n+\n+template <typename... Args>\n+Status ErrnoToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::ErrnoMessage(errno);\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+#ifdef _WIN32\n+\n+std::string NativeToString(const NativePathString& ns) {\n+  PlatformFilename fn(ns);\n+  return fn.ToString();\n+}\n+\n+template <typename... Args>\n+Status WinErrorToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::WinErrorMessage(GetLastError());\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+TimePoint ToTimePoint(FILETIME ft) {\n+  // Hundreds of nanoseconds between January 1, 1601 (UTC) and the Unix epoch.\n+  static constexpr int64_t kFileTimeEpoch = 11644473600LL * 10000000;\n+\n+  int64_t hundreds = (static_cast<int64_t>(ft.dwHighDateTime) << 32) + ft.dwLowDateTime -\n+                     kFileTimeEpoch;  // hundreds of ns since Unix epoch\n+  std::chrono::nanoseconds ns_count(100 * hundreds);\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats FileInformationToFileStat(const BY_HANDLE_FILE_INFORMATION& info) {\n+  FileStats st;\n+  if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n+    // Regular file\n+    st.set_type(FileType::File);\n+    st.set_size((static_cast<int64_t>(info.nFileSizeHigh) << 32) + info.nFileSizeLow);\n+  }\n+  st.set_mtime(ToTimePoint(info.ftLastWriteTime));\n+  return st;\n+}\n+\n+Status StatFile(const std::wstring& path, FileStats* out) {\n+  HANDLE h;\n+  std::string bytes_path = NativeToString(path);\n+\n+  /* Inspired by CPython, see Modules/posixmodule.c */\n+  h = CreateFileW(path.c_str(), FILE_READ_ATTRIBUTES, /* desired access */\n+                  0,                                  /* share mode */\n+                  NULL,                               /* security attributes */\n+                  OPEN_EXISTING,\n+                  /* FILE_FLAG_BACKUP_SEMANTICS is required to open a directory */\n+                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n+\n+  if (h == INVALID_HANDLE_VALUE) {\n+    DWORD err = GetLastError();\n+    if (err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND) {\n+      out->set_path(bytes_path);\n+      out->set_type(FileType::NonExistent);\n+      out->set_mtime(kNoTime);\n+      out->set_size(kNoSize);\n+      return Status::OK();\n+    } else {\n+      return WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    }\n+  }\n+  BY_HANDLE_FILE_INFORMATION info;\n+  if (!GetFileInformationByHandle(h, &info)) {\n+    Status st =\n+        WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    CloseHandle(h);\n+    return st;\n+  }\n+  CloseHandle(h);\n+  *out = FileInformationToFileStat(info);\n+  out->set_path(bytes_path);\n+  return Status::OK();\n+}\n+\n+#else  // POSIX systems\n+\n+TimePoint ToTimePoint(const struct timespec& s) {\n+  std::chrono::nanoseconds ns_count(static_cast<int64_t>(s.tv_sec) * 1000000000 +\n+                                    static_cast<int64_t>(s.tv_nsec));\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats StatToFileStat(const struct stat& s) {\n+  FileStats st;\n+  if (S_ISREG(s.st_mode)) {\n+    st.set_type(FileType::File);\n+    st.set_size(static_cast<int64_t>(s.st_size));\n+  } else if (S_ISDIR(s.st_mode)) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n+    st.set_type(FileType::Unknown);\n+    st.set_size(kNoSize);\n+  }\n+#ifdef __APPLE__\n+  // macOS doesn't use the POSIX-compliant spelling\n+  st.set_mtime(ToTimePoint(s.st_mtimespec));\n+#else\n+  st.set_mtime(ToTimePoint(s.st_mtim));\n+#endif\n+  return st;\n+}\n+\n+Status StatFile(const std::string& path, FileStats* out) {\n+  struct stat s;\n+  int r = stat(path.c_str(), &s);\n+  if (r == -1) {\n+    if (errno == ENOENT || errno == ENOTDIR || errno == ELOOP) {\n+      out->set_type(FileType::NonExistent);\n+      out->set_mtime(kNoTime);\n+      out->set_size(kNoSize);\n+    } else {\n+      return ErrnoToStatus(\"Failed stat()ing path '\", path, \"'\");\n+    }\n+  } else {\n+    *out = StatToFileStat(s);\n+  }\n+  out->set_path(path);\n+  return Status::OK();\n+}\n+\n+#endif\n+\n+Status StatSelector(const NativePathString& path, const Selector& select,\n+                    std::vector<FileStats>* out) {\n+  bfs::path p(path);\n+\n+  if (select.allow_non_existent) {\n+    bfs::file_status st;\n+    BOOST_FILESYSTEM_TRY\n+    st = bfs::status(p);\n+    BOOST_FILESYSTEM_CATCH\n+    if (st.type() == bfs::file_not_found) {\n+      return Status::OK();\n+    }\n+  }\n+\n+  BOOST_FILESYSTEM_TRY\n+  for (const auto& entry : bfs::directory_iterator(p)) {\n+    FileStats st;\n+    NativePathString ns = entry.path().native();\n+    RETURN_NOT_OK(StatFile(ns, &st));\n+    if (st.type() != FileType::NonExistent) {\n+      out->push_back(std::move(st));\n+    }\n+    if (select.recursive && st.type() == FileType::Directory) {\n+      RETURN_NOT_OK(StatSelector(ns, select, out));\n+    }\n+  }\n+  BOOST_FILESYSTEM_CATCH\n+\n+  return Status::OK();\n+}\n+\n+}  // namespace\n+\n+LocalFileSystem::LocalFileSystem() {}\n+\n+LocalFileSystem::~LocalFileSystem() {}\n+\n+Status LocalFileSystem::GetTargetStats(const std::string& path, FileStats* out) {\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  return StatFile(fn.ToNative(), out);\n+}\n+\n+Status LocalFileSystem::GetTargetStats(const Selector& select,\n+                                       std::vector<FileStats>* out) {\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(select.base_dir, &fn));\n+  out->clear();\n+  return StatSelector(fn.ToNative(), select, out);\n+}\n+\n+Status LocalFileSystem::CreateDir(const std::string& path, bool recursive) {\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  if (recursive) {\n+    return ::arrow::internal::CreateDirTree(fn);\n+  } else {\n+    return ::arrow::internal::CreateDir(fn);\n+  }\n+}\n+\n+Status LocalFileSystem::DeleteDir(const std::string& path) {\n+  bool deleted = false;\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(::arrow::internal::DeleteDirTree(fn, &deleted));\n+  if (deleted) {\n+    return Status::OK();\n+  } else {\n+    return Status::IOError(\"Directory does not exist: '\", path, \"'\");\n+  }\n+}\n+\n+Status LocalFileSystem::DeleteFile(const std::string& path) {\n+  bool deleted = false;\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(::arrow::internal::DeleteFile(fn, &deleted));\n+  if (deleted) {\n+    return Status::OK();\n+  } else {\n+    return Status::IOError(\"File does not exist: '\", path, \"'\");\n+  }\n+}\n+\n+Status LocalFileSystem::Move(const std::string& src, const std::string& dest) {\n+  PlatformFilename sfn, dfn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(src, &sfn));\n+  RETURN_NOT_OK(PlatformFilename::FromString(dest, &dfn));\n+\n+#ifdef _WIN32\n+  if (!MoveFileExW(sfn.ToNative().c_str(), dfn.ToNative().c_str(),\n+                   MOVEFILE_REPLACE_EXISTING)) {\n+    return WinErrorToStatus(\"Failed renaming '\", sfn.ToString(), \"' to '\", dfn.ToString(),\n+                            \"': \");\n+  }\n+#else\n+  if (rename(sfn.ToNative().c_str(), dfn.ToNative().c_str()) == -1) {\n+    return ErrnoToStatus(\"Failed renaming '\", sfn.ToString(), \"' to '\", dfn.ToString(),\n+                         \"': \");\n+  }\n+#endif\n+  return Status::OK();\n+}\n+\n+Status LocalFileSystem::CopyFile(const std::string& src, const std::string& dest) {\n+  PlatformFilename sfn, dfn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(src, &sfn));\n+  RETURN_NOT_OK(PlatformFilename::FromString(dest, &dfn));\n+  // XXX should we use fstat() to compare inodes?\n \n Review comment:\n   Perhaps. Keeping the XXX is fine, though.\r\n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-29T19:53:47.844+0000",
                    "updated": "2019-05-29T19:53:47.844+0000",
                    "started": "2019-05-29T19:53:47.843+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "250437",
                    "issueId": "13234356"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/250579",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379#discussion_r288796479\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/localfs.cc\n ##########\n @@ -0,0 +1,387 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <chrono>\n+#include <cstring>\n+#include <utility>\n+\n+#ifdef _WIN32\n+#include \"arrow/util/windows_compatibility.h\"\n+#else\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdio.h>\n+#include <sys/stat.h>\n+#endif\n+\n+#include <boost/filesystem.hpp>\n+\n+#include \"arrow/filesystem/localfs.h\"\n+#include \"arrow/filesystem/util-internal.h\"\n+#include \"arrow/io/file.h\"\n+#include \"arrow/util/io-util.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace fs {\n+\n+namespace bfs = ::boost::filesystem;\n+\n+using ::arrow::internal::NativePathString;\n+using ::arrow::internal::PlatformFilename;\n+\n+namespace {\n+\n+#define BOOST_FILESYSTEM_TRY try {\n+#define BOOST_FILESYSTEM_CATCH           \\\n+  }                                      \\\n+  catch (bfs::filesystem_error & _err) { \\\n+    return ToStatus(_err);               \\\n+  }\n+\n+// NOTE: catching filesystem_error gives more context than system::error_code\n+// (it includes the file path(s) in the error message)\n+\n+Status ToStatus(const bfs::filesystem_error& err) { return Status::IOError(err.what()); }\n+\n+template <typename... Args>\n+Status ErrnoToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::ErrnoMessage(errno);\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+#ifdef _WIN32\n+\n+std::string NativeToString(const NativePathString& ns) {\n+  PlatformFilename fn(ns);\n+  return fn.ToString();\n+}\n+\n+template <typename... Args>\n+Status WinErrorToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::WinErrorMessage(GetLastError());\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+TimePoint ToTimePoint(FILETIME ft) {\n+  // Hundreds of nanoseconds between January 1, 1601 (UTC) and the Unix epoch.\n+  static constexpr int64_t kFileTimeEpoch = 11644473600LL * 10000000;\n+\n+  int64_t hundreds = (static_cast<int64_t>(ft.dwHighDateTime) << 32) + ft.dwLowDateTime -\n+                     kFileTimeEpoch;  // hundreds of ns since Unix epoch\n+  std::chrono::nanoseconds ns_count(100 * hundreds);\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats FileInformationToFileStat(const BY_HANDLE_FILE_INFORMATION& info) {\n+  FileStats st;\n+  if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n+    // Regular file\n+    st.set_type(FileType::File);\n+    st.set_size((static_cast<int64_t>(info.nFileSizeHigh) << 32) + info.nFileSizeLow);\n+  }\n+  st.set_mtime(ToTimePoint(info.ftLastWriteTime));\n+  return st;\n+}\n+\n+Status StatFile(const std::wstring& path, FileStats* out) {\n+  HANDLE h;\n+  std::string bytes_path = NativeToString(path);\n+\n+  /* Inspired by CPython, see Modules/posixmodule.c */\n+  h = CreateFileW(path.c_str(), FILE_READ_ATTRIBUTES, /* desired access */\n+                  0,                                  /* share mode */\n+                  NULL,                               /* security attributes */\n+                  OPEN_EXISTING,\n+                  /* FILE_FLAG_BACKUP_SEMANTICS is required to open a directory */\n+                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n+\n+  if (h == INVALID_HANDLE_VALUE) {\n+    DWORD err = GetLastError();\n+    if (err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND) {\n+      out->set_path(bytes_path);\n+      out->set_type(FileType::NonExistent);\n+      out->set_mtime(kNoTime);\n+      out->set_size(kNoSize);\n+      return Status::OK();\n+    } else {\n+      return WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    }\n+  }\n+  BY_HANDLE_FILE_INFORMATION info;\n+  if (!GetFileInformationByHandle(h, &info)) {\n+    Status st =\n+        WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    CloseHandle(h);\n+    return st;\n+  }\n+  CloseHandle(h);\n+  *out = FileInformationToFileStat(info);\n+  out->set_path(bytes_path);\n+  return Status::OK();\n+}\n+\n+#else  // POSIX systems\n+\n+TimePoint ToTimePoint(const struct timespec& s) {\n+  std::chrono::nanoseconds ns_count(static_cast<int64_t>(s.tv_sec) * 1000000000 +\n+                                    static_cast<int64_t>(s.tv_nsec));\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats StatToFileStat(const struct stat& s) {\n+  FileStats st;\n+  if (S_ISREG(s.st_mode)) {\n+    st.set_type(FileType::File);\n+    st.set_size(static_cast<int64_t>(s.st_size));\n+  } else if (S_ISDIR(s.st_mode)) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n+    st.set_type(FileType::Unknown);\n+    st.set_size(kNoSize);\n+  }\n+#ifdef __APPLE__\n+  // macOS doesn't use the POSIX-compliant spelling\n+  st.set_mtime(ToTimePoint(s.st_mtimespec));\n+#else\n+  st.set_mtime(ToTimePoint(s.st_mtim));\n+#endif\n+  return st;\n+}\n+\n+Status StatFile(const std::string& path, FileStats* out) {\n+  struct stat s;\n+  int r = stat(path.c_str(), &s);\n+  if (r == -1) {\n+    if (errno == ENOENT || errno == ENOTDIR || errno == ELOOP) {\n+      out->set_type(FileType::NonExistent);\n+      out->set_mtime(kNoTime);\n+      out->set_size(kNoSize);\n+    } else {\n+      return ErrnoToStatus(\"Failed stat()ing path '\", path, \"'\");\n+    }\n+  } else {\n+    *out = StatToFileStat(s);\n+  }\n+  out->set_path(path);\n+  return Status::OK();\n+}\n+\n+#endif\n+\n+Status StatSelector(const NativePathString& path, const Selector& select,\n+                    std::vector<FileStats>* out) {\n+  bfs::path p(path);\n+\n+  if (select.allow_non_existent) {\n+    bfs::file_status st;\n+    BOOST_FILESYSTEM_TRY\n+    st = bfs::status(p);\n+    BOOST_FILESYSTEM_CATCH\n+    if (st.type() == bfs::file_not_found) {\n+      return Status::OK();\n+    }\n+  }\n+\n+  BOOST_FILESYSTEM_TRY\n+  for (const auto& entry : bfs::directory_iterator(p)) {\n+    FileStats st;\n+    NativePathString ns = entry.path().native();\n+    RETURN_NOT_OK(StatFile(ns, &st));\n+    if (st.type() != FileType::NonExistent) {\n+      out->push_back(std::move(st));\n+    }\n+    if (select.recursive && st.type() == FileType::Directory) {\n+      RETURN_NOT_OK(StatSelector(ns, select, out));\n+    }\n+  }\n+  BOOST_FILESYSTEM_CATCH\n+\n+  return Status::OK();\n+}\n+\n+}  // namespace\n+\n+LocalFileSystem::LocalFileSystem() {}\n+\n+LocalFileSystem::~LocalFileSystem() {}\n+\n+Status LocalFileSystem::GetTargetStats(const std::string& path, FileStats* out) {\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  return StatFile(fn.ToNative(), out);\n+}\n+\n+Status LocalFileSystem::GetTargetStats(const Selector& select,\n+                                       std::vector<FileStats>* out) {\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(select.base_dir, &fn));\n+  out->clear();\n+  return StatSelector(fn.ToNative(), select, out);\n+}\n+\n+Status LocalFileSystem::CreateDir(const std::string& path, bool recursive) {\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  if (recursive) {\n+    return ::arrow::internal::CreateDirTree(fn);\n+  } else {\n+    return ::arrow::internal::CreateDir(fn);\n+  }\n+}\n+\n+Status LocalFileSystem::DeleteDir(const std::string& path) {\n+  bool deleted = false;\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(::arrow::internal::DeleteDirTree(fn, &deleted));\n+  if (deleted) {\n+    return Status::OK();\n+  } else {\n+    return Status::IOError(\"Directory does not exist: '\", path, \"'\");\n+  }\n+}\n+\n+Status LocalFileSystem::DeleteFile(const std::string& path) {\n+  bool deleted = false;\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(::arrow::internal::DeleteFile(fn, &deleted));\n+  if (deleted) {\n+    return Status::OK();\n+  } else {\n+    return Status::IOError(\"File does not exist: '\", path, \"'\");\n+  }\n+}\n+\n+Status LocalFileSystem::Move(const std::string& src, const std::string& dest) {\n+  PlatformFilename sfn, dfn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(src, &sfn));\n+  RETURN_NOT_OK(PlatformFilename::FromString(dest, &dfn));\n+\n+#ifdef _WIN32\n+  if (!MoveFileExW(sfn.ToNative().c_str(), dfn.ToNative().c_str(),\n+                   MOVEFILE_REPLACE_EXISTING)) {\n+    return WinErrorToStatus(\"Failed renaming '\", sfn.ToString(), \"' to '\", dfn.ToString(),\n+                            \"': \");\n+  }\n+#else\n+  if (rename(sfn.ToNative().c_str(), dfn.ToNative().c_str()) == -1) {\n+    return ErrnoToStatus(\"Failed renaming '\", sfn.ToString(), \"' to '\", dfn.ToString(),\n+                         \"': \");\n+  }\n+#endif\n+  return Status::OK();\n+}\n+\n+Status LocalFileSystem::CopyFile(const std::string& src, const std::string& dest) {\n+  PlatformFilename sfn, dfn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(src, &sfn));\n+  RETURN_NOT_OK(PlatformFilename::FromString(dest, &dfn));\n+  // XXX should we use fstat() to compare inodes?\n+  if (sfn.ToNative() == dfn.ToNative()) {\n+    return Status::OK();\n+  }\n+\n+#ifdef _WIN32\n+  if (!CopyFileW(sfn.ToNative().c_str(), dfn.ToNative().c_str(),\n+                 FALSE /* bFailIfExists */)) {\n+    return WinErrorToStatus(\"Failed copying '\", sfn.ToString(), \"' to '\", dfn.ToString(),\n+                            \"': \");\n+  }\n+  return Status::OK();\n+#else\n+  std::shared_ptr<io::InputStream> is;\n+  std::shared_ptr<io::OutputStream> os;\n+  RETURN_NOT_OK(OpenInputStream(src, &is));\n+  RETURN_NOT_OK(OpenOutputStream(dest, &os));\n+  RETURN_NOT_OK(internal::CopyStream(is, os, 1024 * 1024 /* chunk_size */));\n+  RETURN_NOT_OK(os->Close());\n+  return is->Close();\n+#endif\n+}\n+\n+Status LocalFileSystem::OpenInputStream(const std::string& path,\n+                                        std::shared_ptr<io::InputStream>* out) {\n+  PlatformFilename fn;\n+  int fd;\n+  std::shared_ptr<io::ReadableFile> file;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(::arrow::internal::FileOpenReadable(fn, &fd));\n \n Review comment:\n   Is there an advantage to not let `ReadableFile::Open` do the work of calling `internal::FileOpenReadable`?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-29T22:47:01.102+0000",
                    "updated": "2019-05-29T22:47:01.102+0000",
                    "started": "2019-05-29T22:47:01.101+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "250579",
                    "issueId": "13234356"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/250580",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379#discussion_r288795025\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/localfs.cc\n ##########\n @@ -0,0 +1,387 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <chrono>\n+#include <cstring>\n+#include <utility>\n+\n+#ifdef _WIN32\n+#include \"arrow/util/windows_compatibility.h\"\n+#else\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdio.h>\n+#include <sys/stat.h>\n+#endif\n+\n+#include <boost/filesystem.hpp>\n+\n+#include \"arrow/filesystem/localfs.h\"\n+#include \"arrow/filesystem/util-internal.h\"\n+#include \"arrow/io/file.h\"\n+#include \"arrow/util/io-util.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace fs {\n+\n+namespace bfs = ::boost::filesystem;\n+\n+using ::arrow::internal::NativePathString;\n+using ::arrow::internal::PlatformFilename;\n+\n+namespace {\n+\n+#define BOOST_FILESYSTEM_TRY try {\n+#define BOOST_FILESYSTEM_CATCH           \\\n+  }                                      \\\n+  catch (bfs::filesystem_error & _err) { \\\n+    return ToStatus(_err);               \\\n+  }\n+\n+// NOTE: catching filesystem_error gives more context than system::error_code\n+// (it includes the file path(s) in the error message)\n+\n+Status ToStatus(const bfs::filesystem_error& err) { return Status::IOError(err.what()); }\n+\n+template <typename... Args>\n+Status ErrnoToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::ErrnoMessage(errno);\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+#ifdef _WIN32\n+\n+std::string NativeToString(const NativePathString& ns) {\n+  PlatformFilename fn(ns);\n+  return fn.ToString();\n+}\n+\n+template <typename... Args>\n+Status WinErrorToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::WinErrorMessage(GetLastError());\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+TimePoint ToTimePoint(FILETIME ft) {\n+  // Hundreds of nanoseconds between January 1, 1601 (UTC) and the Unix epoch.\n+  static constexpr int64_t kFileTimeEpoch = 11644473600LL * 10000000;\n+\n+  int64_t hundreds = (static_cast<int64_t>(ft.dwHighDateTime) << 32) + ft.dwLowDateTime -\n+                     kFileTimeEpoch;  // hundreds of ns since Unix epoch\n+  std::chrono::nanoseconds ns_count(100 * hundreds);\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats FileInformationToFileStat(const BY_HANDLE_FILE_INFORMATION& info) {\n+  FileStats st;\n+  if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n+    // Regular file\n+    st.set_type(FileType::File);\n+    st.set_size((static_cast<int64_t>(info.nFileSizeHigh) << 32) + info.nFileSizeLow);\n+  }\n+  st.set_mtime(ToTimePoint(info.ftLastWriteTime));\n+  return st;\n+}\n+\n+Status StatFile(const std::wstring& path, FileStats* out) {\n+  HANDLE h;\n+  std::string bytes_path = NativeToString(path);\n+\n+  /* Inspired by CPython, see Modules/posixmodule.c */\n+  h = CreateFileW(path.c_str(), FILE_READ_ATTRIBUTES, /* desired access */\n+                  0,                                  /* share mode */\n+                  NULL,                               /* security attributes */\n+                  OPEN_EXISTING,\n+                  /* FILE_FLAG_BACKUP_SEMANTICS is required to open a directory */\n+                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n+\n+  if (h == INVALID_HANDLE_VALUE) {\n+    DWORD err = GetLastError();\n+    if (err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND) {\n+      out->set_path(bytes_path);\n+      out->set_type(FileType::NonExistent);\n+      out->set_mtime(kNoTime);\n+      out->set_size(kNoSize);\n+      return Status::OK();\n+    } else {\n+      return WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    }\n+  }\n+  BY_HANDLE_FILE_INFORMATION info;\n+  if (!GetFileInformationByHandle(h, &info)) {\n+    Status st =\n+        WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    CloseHandle(h);\n+    return st;\n+  }\n+  CloseHandle(h);\n+  *out = FileInformationToFileStat(info);\n+  out->set_path(bytes_path);\n+  return Status::OK();\n+}\n+\n+#else  // POSIX systems\n+\n+TimePoint ToTimePoint(const struct timespec& s) {\n+  std::chrono::nanoseconds ns_count(static_cast<int64_t>(s.tv_sec) * 1000000000 +\n+                                    static_cast<int64_t>(s.tv_nsec));\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats StatToFileStat(const struct stat& s) {\n+  FileStats st;\n+  if (S_ISREG(s.st_mode)) {\n+    st.set_type(FileType::File);\n+    st.set_size(static_cast<int64_t>(s.st_size));\n+  } else if (S_ISDIR(s.st_mode)) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n+    st.set_type(FileType::Unknown);\n+    st.set_size(kNoSize);\n+  }\n+#ifdef __APPLE__\n+  // macOS doesn't use the POSIX-compliant spelling\n \n Review comment:\n   So much for the \"P\" in POSIX\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-29T22:47:02.440+0000",
                    "updated": "2019-05-29T22:47:02.440+0000",
                    "started": "2019-05-29T22:47:02.440+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "250580",
                    "issueId": "13234356"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/250581",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379#discussion_r288791266\n \n \n\n ##########\n File path: cpp/src/arrow/util/io-util.cc\n ##########\n @@ -373,8 +419,22 @@ Status FileOpenReadable(const PlatformFilename& file_name, int* fd) {\n                            _O_RDONLY | _O_BINARY | _O_NOINHERIT, _SH_DENYNO, _S_IREAD);\n   ret = *fd;\n #else\n-  ret = *fd = open(file_name.ToNative().c_str(), O_RDONLY | O_BINARY);\n \n Review comment:\n   Does O_BINARY actually do anything here?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-29T22:47:02.445+0000",
                    "updated": "2019-05-29T22:47:02.445+0000",
                    "started": "2019-05-29T22:47:02.445+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "250581",
                    "issueId": "13234356"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/250582",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379#discussion_r288797596\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/util-internal.cc\n ##########\n @@ -0,0 +1,45 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/filesystem/util-internal.h\"\n+#include \"arrow/buffer.h\"\n+\n+namespace arrow {\n+namespace fs {\n+namespace internal {\n+\n+Status CopyStream(const std::shared_ptr<io::InputStream>& src,\n+                  const std::shared_ptr<io::OutputStream>& dest, int64_t chunk_size) {\n+  std::shared_ptr<Buffer> chunk;\n+  int64_t bytes_read;\n+\n+  RETURN_NOT_OK(AllocateBuffer(chunk_size, &chunk));\n+  while (true) {\n+    RETURN_NOT_OK(src->Read(chunk_size, &bytes_read, chunk->mutable_data()));\n+    if (bytes_read == 0) {\n+      // EOF\n+      break;\n+    }\n+    RETURN_NOT_OK(dest->Write(chunk->data(), bytes_read));\n \n Review comment:\n   No action necessary now, but at some point we may need to optimize this for higher-latency filesystems (i.e. reading the next chunk while the call to `Write` blocks -- it shouldn't really block as you've pointed out with local filesystems but with S3 etc. it will)\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-29T22:47:02.548+0000",
                    "updated": "2019-05-29T22:47:02.548+0000",
                    "started": "2019-05-29T22:47:02.547+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "250582",
                    "issueId": "13234356"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/250583",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379#discussion_r288795304\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/localfs.cc\n ##########\n @@ -0,0 +1,387 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <chrono>\n+#include <cstring>\n+#include <utility>\n+\n+#ifdef _WIN32\n+#include \"arrow/util/windows_compatibility.h\"\n+#else\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdio.h>\n+#include <sys/stat.h>\n+#endif\n+\n+#include <boost/filesystem.hpp>\n+\n+#include \"arrow/filesystem/localfs.h\"\n+#include \"arrow/filesystem/util-internal.h\"\n+#include \"arrow/io/file.h\"\n+#include \"arrow/util/io-util.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace fs {\n+\n+namespace bfs = ::boost::filesystem;\n+\n+using ::arrow::internal::NativePathString;\n+using ::arrow::internal::PlatformFilename;\n+\n+namespace {\n+\n+#define BOOST_FILESYSTEM_TRY try {\n+#define BOOST_FILESYSTEM_CATCH           \\\n+  }                                      \\\n+  catch (bfs::filesystem_error & _err) { \\\n+    return ToStatus(_err);               \\\n+  }\n+\n+// NOTE: catching filesystem_error gives more context than system::error_code\n+// (it includes the file path(s) in the error message)\n+\n+Status ToStatus(const bfs::filesystem_error& err) { return Status::IOError(err.what()); }\n+\n+template <typename... Args>\n+Status ErrnoToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::ErrnoMessage(errno);\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+#ifdef _WIN32\n+\n+std::string NativeToString(const NativePathString& ns) {\n+  PlatformFilename fn(ns);\n+  return fn.ToString();\n+}\n+\n+template <typename... Args>\n+Status WinErrorToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::WinErrorMessage(GetLastError());\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+TimePoint ToTimePoint(FILETIME ft) {\n+  // Hundreds of nanoseconds between January 1, 1601 (UTC) and the Unix epoch.\n+  static constexpr int64_t kFileTimeEpoch = 11644473600LL * 10000000;\n+\n+  int64_t hundreds = (static_cast<int64_t>(ft.dwHighDateTime) << 32) + ft.dwLowDateTime -\n+                     kFileTimeEpoch;  // hundreds of ns since Unix epoch\n+  std::chrono::nanoseconds ns_count(100 * hundreds);\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats FileInformationToFileStat(const BY_HANDLE_FILE_INFORMATION& info) {\n+  FileStats st;\n+  if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n+    // Regular file\n+    st.set_type(FileType::File);\n+    st.set_size((static_cast<int64_t>(info.nFileSizeHigh) << 32) + info.nFileSizeLow);\n+  }\n+  st.set_mtime(ToTimePoint(info.ftLastWriteTime));\n+  return st;\n+}\n+\n+Status StatFile(const std::wstring& path, FileStats* out) {\n+  HANDLE h;\n+  std::string bytes_path = NativeToString(path);\n+\n+  /* Inspired by CPython, see Modules/posixmodule.c */\n+  h = CreateFileW(path.c_str(), FILE_READ_ATTRIBUTES, /* desired access */\n+                  0,                                  /* share mode */\n+                  NULL,                               /* security attributes */\n+                  OPEN_EXISTING,\n+                  /* FILE_FLAG_BACKUP_SEMANTICS is required to open a directory */\n+                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n+\n+  if (h == INVALID_HANDLE_VALUE) {\n+    DWORD err = GetLastError();\n+    if (err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND) {\n+      out->set_path(bytes_path);\n+      out->set_type(FileType::NonExistent);\n+      out->set_mtime(kNoTime);\n+      out->set_size(kNoSize);\n+      return Status::OK();\n+    } else {\n+      return WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    }\n+  }\n+  BY_HANDLE_FILE_INFORMATION info;\n+  if (!GetFileInformationByHandle(h, &info)) {\n+    Status st =\n+        WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    CloseHandle(h);\n+    return st;\n+  }\n+  CloseHandle(h);\n+  *out = FileInformationToFileStat(info);\n+  out->set_path(bytes_path);\n+  return Status::OK();\n+}\n+\n+#else  // POSIX systems\n+\n+TimePoint ToTimePoint(const struct timespec& s) {\n+  std::chrono::nanoseconds ns_count(static_cast<int64_t>(s.tv_sec) * 1000000000 +\n+                                    static_cast<int64_t>(s.tv_nsec));\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats StatToFileStat(const struct stat& s) {\n+  FileStats st;\n+  if (S_ISREG(s.st_mode)) {\n+    st.set_type(FileType::File);\n+    st.set_size(static_cast<int64_t>(s.st_size));\n+  } else if (S_ISDIR(s.st_mode)) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n+    st.set_type(FileType::Unknown);\n+    st.set_size(kNoSize);\n+  }\n+#ifdef __APPLE__\n+  // macOS doesn't use the POSIX-compliant spelling\n+  st.set_mtime(ToTimePoint(s.st_mtimespec));\n+#else\n+  st.set_mtime(ToTimePoint(s.st_mtim));\n+#endif\n+  return st;\n+}\n+\n+Status StatFile(const std::string& path, FileStats* out) {\n+  struct stat s;\n+  int r = stat(path.c_str(), &s);\n+  if (r == -1) {\n+    if (errno == ENOENT || errno == ENOTDIR || errno == ELOOP) {\n \n Review comment:\n   Testing the ELOOP case seems like it would be fun\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-29T22:47:02.583+0000",
                    "updated": "2019-05-29T22:47:02.583+0000",
                    "started": "2019-05-29T22:47:02.583+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "250583",
                    "issueId": "13234356"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/250847",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379#discussion_r288917273\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/localfs.cc\n ##########\n @@ -0,0 +1,387 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <chrono>\n+#include <cstring>\n+#include <utility>\n+\n+#ifdef _WIN32\n+#include \"arrow/util/windows_compatibility.h\"\n+#else\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdio.h>\n+#include <sys/stat.h>\n+#endif\n+\n+#include <boost/filesystem.hpp>\n+\n+#include \"arrow/filesystem/localfs.h\"\n+#include \"arrow/filesystem/util-internal.h\"\n+#include \"arrow/io/file.h\"\n+#include \"arrow/util/io-util.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace fs {\n+\n+namespace bfs = ::boost::filesystem;\n+\n+using ::arrow::internal::NativePathString;\n+using ::arrow::internal::PlatformFilename;\n+\n+namespace {\n+\n+#define BOOST_FILESYSTEM_TRY try {\n+#define BOOST_FILESYSTEM_CATCH           \\\n+  }                                      \\\n+  catch (bfs::filesystem_error & _err) { \\\n+    return ToStatus(_err);               \\\n+  }\n+\n+// NOTE: catching filesystem_error gives more context than system::error_code\n+// (it includes the file path(s) in the error message)\n+\n+Status ToStatus(const bfs::filesystem_error& err) { return Status::IOError(err.what()); }\n+\n+template <typename... Args>\n+Status ErrnoToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::ErrnoMessage(errno);\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+#ifdef _WIN32\n+\n+std::string NativeToString(const NativePathString& ns) {\n+  PlatformFilename fn(ns);\n+  return fn.ToString();\n+}\n+\n+template <typename... Args>\n+Status WinErrorToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::WinErrorMessage(GetLastError());\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+TimePoint ToTimePoint(FILETIME ft) {\n+  // Hundreds of nanoseconds between January 1, 1601 (UTC) and the Unix epoch.\n+  static constexpr int64_t kFileTimeEpoch = 11644473600LL * 10000000;\n+\n+  int64_t hundreds = (static_cast<int64_t>(ft.dwHighDateTime) << 32) + ft.dwLowDateTime -\n+                     kFileTimeEpoch;  // hundreds of ns since Unix epoch\n+  std::chrono::nanoseconds ns_count(100 * hundreds);\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats FileInformationToFileStat(const BY_HANDLE_FILE_INFORMATION& info) {\n+  FileStats st;\n+  if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n+    // Regular file\n+    st.set_type(FileType::File);\n+    st.set_size((static_cast<int64_t>(info.nFileSizeHigh) << 32) + info.nFileSizeLow);\n+  }\n+  st.set_mtime(ToTimePoint(info.ftLastWriteTime));\n+  return st;\n+}\n+\n+Status StatFile(const std::wstring& path, FileStats* out) {\n+  HANDLE h;\n+  std::string bytes_path = NativeToString(path);\n+\n+  /* Inspired by CPython, see Modules/posixmodule.c */\n+  h = CreateFileW(path.c_str(), FILE_READ_ATTRIBUTES, /* desired access */\n+                  0,                                  /* share mode */\n+                  NULL,                               /* security attributes */\n+                  OPEN_EXISTING,\n+                  /* FILE_FLAG_BACKUP_SEMANTICS is required to open a directory */\n+                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n+\n+  if (h == INVALID_HANDLE_VALUE) {\n+    DWORD err = GetLastError();\n+    if (err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND) {\n+      out->set_path(bytes_path);\n+      out->set_type(FileType::NonExistent);\n+      out->set_mtime(kNoTime);\n+      out->set_size(kNoSize);\n+      return Status::OK();\n+    } else {\n+      return WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    }\n+  }\n+  BY_HANDLE_FILE_INFORMATION info;\n+  if (!GetFileInformationByHandle(h, &info)) {\n+    Status st =\n+        WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    CloseHandle(h);\n+    return st;\n+  }\n+  CloseHandle(h);\n+  *out = FileInformationToFileStat(info);\n+  out->set_path(bytes_path);\n+  return Status::OK();\n+}\n+\n+#else  // POSIX systems\n+\n+TimePoint ToTimePoint(const struct timespec& s) {\n+  std::chrono::nanoseconds ns_count(static_cast<int64_t>(s.tv_sec) * 1000000000 +\n+                                    static_cast<int64_t>(s.tv_nsec));\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats StatToFileStat(const struct stat& s) {\n+  FileStats st;\n+  if (S_ISREG(s.st_mode)) {\n+    st.set_type(FileType::File);\n+    st.set_size(static_cast<int64_t>(s.st_size));\n+  } else if (S_ISDIR(s.st_mode)) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n \n Review comment:\n   To elaborate a bit: symlinks are deliberately followed. The filesystem API is not a faithful representation of what can happen in a filesystem, it's a very simplified view that's enough for managing simple, possibly nested, collections of files.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-30T09:16:22.285+0000",
                    "updated": "2019-05-30T09:16:22.285+0000",
                    "started": "2019-05-30T09:16:22.284+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "250847",
                    "issueId": "13234356"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/250848",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379#discussion_r288917359\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/localfs.cc\n ##########\n @@ -0,0 +1,387 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <chrono>\n+#include <cstring>\n+#include <utility>\n+\n+#ifdef _WIN32\n+#include \"arrow/util/windows_compatibility.h\"\n+#else\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdio.h>\n+#include <sys/stat.h>\n+#endif\n+\n+#include <boost/filesystem.hpp>\n+\n+#include \"arrow/filesystem/localfs.h\"\n+#include \"arrow/filesystem/util-internal.h\"\n+#include \"arrow/io/file.h\"\n+#include \"arrow/util/io-util.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace fs {\n+\n+namespace bfs = ::boost::filesystem;\n+\n+using ::arrow::internal::NativePathString;\n+using ::arrow::internal::PlatformFilename;\n+\n+namespace {\n+\n+#define BOOST_FILESYSTEM_TRY try {\n+#define BOOST_FILESYSTEM_CATCH           \\\n+  }                                      \\\n+  catch (bfs::filesystem_error & _err) { \\\n+    return ToStatus(_err);               \\\n+  }\n+\n+// NOTE: catching filesystem_error gives more context than system::error_code\n+// (it includes the file path(s) in the error message)\n+\n+Status ToStatus(const bfs::filesystem_error& err) { return Status::IOError(err.what()); }\n+\n+template <typename... Args>\n+Status ErrnoToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::ErrnoMessage(errno);\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+#ifdef _WIN32\n+\n+std::string NativeToString(const NativePathString& ns) {\n+  PlatformFilename fn(ns);\n+  return fn.ToString();\n+}\n+\n+template <typename... Args>\n+Status WinErrorToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::WinErrorMessage(GetLastError());\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+TimePoint ToTimePoint(FILETIME ft) {\n+  // Hundreds of nanoseconds between January 1, 1601 (UTC) and the Unix epoch.\n+  static constexpr int64_t kFileTimeEpoch = 11644473600LL * 10000000;\n+\n+  int64_t hundreds = (static_cast<int64_t>(ft.dwHighDateTime) << 32) + ft.dwLowDateTime -\n+                     kFileTimeEpoch;  // hundreds of ns since Unix epoch\n+  std::chrono::nanoseconds ns_count(100 * hundreds);\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats FileInformationToFileStat(const BY_HANDLE_FILE_INFORMATION& info) {\n+  FileStats st;\n+  if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n+    // Regular file\n+    st.set_type(FileType::File);\n+    st.set_size((static_cast<int64_t>(info.nFileSizeHigh) << 32) + info.nFileSizeLow);\n+  }\n+  st.set_mtime(ToTimePoint(info.ftLastWriteTime));\n+  return st;\n+}\n+\n+Status StatFile(const std::wstring& path, FileStats* out) {\n+  HANDLE h;\n+  std::string bytes_path = NativeToString(path);\n+\n+  /* Inspired by CPython, see Modules/posixmodule.c */\n+  h = CreateFileW(path.c_str(), FILE_READ_ATTRIBUTES, /* desired access */\n+                  0,                                  /* share mode */\n+                  NULL,                               /* security attributes */\n+                  OPEN_EXISTING,\n+                  /* FILE_FLAG_BACKUP_SEMANTICS is required to open a directory */\n+                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n+\n+  if (h == INVALID_HANDLE_VALUE) {\n+    DWORD err = GetLastError();\n+    if (err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND) {\n+      out->set_path(bytes_path);\n+      out->set_type(FileType::NonExistent);\n+      out->set_mtime(kNoTime);\n+      out->set_size(kNoSize);\n+      return Status::OK();\n+    } else {\n+      return WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    }\n+  }\n+  BY_HANDLE_FILE_INFORMATION info;\n+  if (!GetFileInformationByHandle(h, &info)) {\n+    Status st =\n+        WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    CloseHandle(h);\n+    return st;\n+  }\n+  CloseHandle(h);\n+  *out = FileInformationToFileStat(info);\n+  out->set_path(bytes_path);\n+  return Status::OK();\n+}\n+\n+#else  // POSIX systems\n+\n+TimePoint ToTimePoint(const struct timespec& s) {\n+  std::chrono::nanoseconds ns_count(static_cast<int64_t>(s.tv_sec) * 1000000000 +\n+                                    static_cast<int64_t>(s.tv_nsec));\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats StatToFileStat(const struct stat& s) {\n+  FileStats st;\n+  if (S_ISREG(s.st_mode)) {\n+    st.set_type(FileType::File);\n+    st.set_size(static_cast<int64_t>(s.st_size));\n+  } else if (S_ISDIR(s.st_mode)) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n+    st.set_type(FileType::Unknown);\n+    st.set_size(kNoSize);\n+  }\n+#ifdef __APPLE__\n+  // macOS doesn't use the POSIX-compliant spelling\n+  st.set_mtime(ToTimePoint(s.st_mtimespec));\n+#else\n+  st.set_mtime(ToTimePoint(s.st_mtim));\n+#endif\n+  return st;\n+}\n+\n+Status StatFile(const std::string& path, FileStats* out) {\n+  struct stat s;\n+  int r = stat(path.c_str(), &s);\n+  if (r == -1) {\n+    if (errno == ENOENT || errno == ENOTDIR || errno == ELOOP) {\n+      out->set_type(FileType::NonExistent);\n+      out->set_mtime(kNoTime);\n+      out->set_size(kNoSize);\n+    } else {\n+      return ErrnoToStatus(\"Failed stat()ing path '\", path, \"'\");\n+    }\n+  } else {\n+    *out = StatToFileStat(s);\n+  }\n+  out->set_path(path);\n+  return Status::OK();\n+}\n+\n+#endif\n+\n+Status StatSelector(const NativePathString& path, const Selector& select,\n+                    std::vector<FileStats>* out) {\n+  bfs::path p(path);\n+\n+  if (select.allow_non_existent) {\n+    bfs::file_status st;\n+    BOOST_FILESYSTEM_TRY\n+    st = bfs::status(p);\n+    BOOST_FILESYSTEM_CATCH\n+    if (st.type() == bfs::file_not_found) {\n+      return Status::OK();\n+    }\n+  }\n+\n+  BOOST_FILESYSTEM_TRY\n+  for (const auto& entry : bfs::directory_iterator(p)) {\n+    FileStats st;\n+    NativePathString ns = entry.path().native();\n+    RETURN_NOT_OK(StatFile(ns, &st));\n+    if (st.type() != FileType::NonExistent) {\n+      out->push_back(std::move(st));\n+    }\n+    if (select.recursive && st.type() == FileType::Directory) {\n+      RETURN_NOT_OK(StatSelector(ns, select, out));\n+    }\n+  }\n+  BOOST_FILESYSTEM_CATCH\n+\n+  return Status::OK();\n+}\n+\n+}  // namespace\n+\n+LocalFileSystem::LocalFileSystem() {}\n+\n+LocalFileSystem::~LocalFileSystem() {}\n+\n+Status LocalFileSystem::GetTargetStats(const std::string& path, FileStats* out) {\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  return StatFile(fn.ToNative(), out);\n+}\n+\n+Status LocalFileSystem::GetTargetStats(const Selector& select,\n+                                       std::vector<FileStats>* out) {\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(select.base_dir, &fn));\n+  out->clear();\n+  return StatSelector(fn.ToNative(), select, out);\n+}\n+\n+Status LocalFileSystem::CreateDir(const std::string& path, bool recursive) {\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  if (recursive) {\n+    return ::arrow::internal::CreateDirTree(fn);\n+  } else {\n+    return ::arrow::internal::CreateDir(fn);\n+  }\n+}\n+\n+Status LocalFileSystem::DeleteDir(const std::string& path) {\n+  bool deleted = false;\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(::arrow::internal::DeleteDirTree(fn, &deleted));\n+  if (deleted) {\n+    return Status::OK();\n+  } else {\n+    return Status::IOError(\"Directory does not exist: '\", path, \"'\");\n+  }\n+}\n+\n+Status LocalFileSystem::DeleteFile(const std::string& path) {\n+  bool deleted = false;\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(::arrow::internal::DeleteFile(fn, &deleted));\n+  if (deleted) {\n+    return Status::OK();\n+  } else {\n+    return Status::IOError(\"File does not exist: '\", path, \"'\");\n+  }\n+}\n+\n+Status LocalFileSystem::Move(const std::string& src, const std::string& dest) {\n+  PlatformFilename sfn, dfn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(src, &sfn));\n+  RETURN_NOT_OK(PlatformFilename::FromString(dest, &dfn));\n+\n+#ifdef _WIN32\n+  if (!MoveFileExW(sfn.ToNative().c_str(), dfn.ToNative().c_str(),\n+                   MOVEFILE_REPLACE_EXISTING)) {\n+    return WinErrorToStatus(\"Failed renaming '\", sfn.ToString(), \"' to '\", dfn.ToString(),\n+                            \"': \");\n+  }\n+#else\n+  if (rename(sfn.ToNative().c_str(), dfn.ToNative().c_str()) == -1) {\n+    return ErrnoToStatus(\"Failed renaming '\", sfn.ToString(), \"' to '\", dfn.ToString(),\n+                         \"': \");\n+  }\n+#endif\n+  return Status::OK();\n+}\n+\n+Status LocalFileSystem::CopyFile(const std::string& src, const std::string& dest) {\n+  PlatformFilename sfn, dfn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(src, &sfn));\n+  RETURN_NOT_OK(PlatformFilename::FromString(dest, &dfn));\n+  // XXX should we use fstat() to compare inodes?\n+  if (sfn.ToNative() == dfn.ToNative()) {\n+    return Status::OK();\n+  }\n+\n+#ifdef _WIN32\n+  if (!CopyFileW(sfn.ToNative().c_str(), dfn.ToNative().c_str(),\n+                 FALSE /* bFailIfExists */)) {\n+    return WinErrorToStatus(\"Failed copying '\", sfn.ToString(), \"' to '\", dfn.ToString(),\n+                            \"': \");\n+  }\n+  return Status::OK();\n+#else\n+  std::shared_ptr<io::InputStream> is;\n+  std::shared_ptr<io::OutputStream> os;\n+  RETURN_NOT_OK(OpenInputStream(src, &is));\n+  RETURN_NOT_OK(OpenOutputStream(dest, &os));\n+  RETURN_NOT_OK(internal::CopyStream(is, os, 1024 * 1024 /* chunk_size */));\n+  RETURN_NOT_OK(os->Close());\n+  return is->Close();\n+#endif\n+}\n+\n+Status LocalFileSystem::OpenInputStream(const std::string& path,\n+                                        std::shared_ptr<io::InputStream>* out) {\n+  PlatformFilename fn;\n+  int fd;\n+  std::shared_ptr<io::ReadableFile> file;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(::arrow::internal::FileOpenReadable(fn, &fd));\n+  Status st = io::ReadableFile::Open(fd, &file);\n+  if (!st.ok()) {\n+    ARROW_UNUSED(::arrow::internal::FileClose(fd));\n+  }\n+  *out = std::move(file);\n+  return st;\n+}\n+\n+Status LocalFileSystem::OpenInputFile(const std::string& path,\n+                                      std::shared_ptr<io::RandomAccessFile>* out) {\n+  PlatformFilename fn;\n+  int fd;\n+  std::shared_ptr<io::ReadableFile> file;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(::arrow::internal::FileOpenReadable(fn, &fd));\n+  Status st = io::ReadableFile::Open(fd, &file);\n+  if (!st.ok()) {\n+    ARROW_UNUSED(::arrow::internal::FileClose(fd));\n+  }\n+  *out = std::move(file);\n+  return st;\n+}\n+\n+Status LocalFileSystem::OpenOutputStream(const std::string& path,\n+                                         std::shared_ptr<io::OutputStream>* out) {\n+  PlatformFilename fn;\n+  int fd;\n+  bool write_only = true;\n+  bool truncate = true;\n+  bool append = false;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(\n+      ::arrow::internal::FileOpenWritable(fn, write_only, truncate, append, &fd));\n+  Status st = io::FileOutputStream::Open(fd, out);\n+  if (!st.ok()) {\n+    ARROW_UNUSED(::arrow::internal::FileClose(fd));\n+  }\n+  return st;\n+}\n+\n+Status LocalFileSystem::OpenAppendStream(const std::string& path,\n+                                         std::shared_ptr<io::OutputStream>* out) {\n+  PlatformFilename fn;\n \n Review comment:\n   Will do.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-30T09:16:41.249+0000",
                    "updated": "2019-05-30T09:16:41.249+0000",
                    "started": "2019-05-30T09:16:41.248+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "250848",
                    "issueId": "13234356"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/250851",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379#discussion_r288917847\n \n \n\n ##########\n File path: cpp/src/arrow/util/io-util.cc\n ##########\n @@ -373,8 +419,22 @@ Status FileOpenReadable(const PlatformFilename& file_name, int* fd) {\n                            _O_RDONLY | _O_BINARY | _O_NOINHERIT, _SH_DENYNO, _S_IREAD);\n   ret = *fd;\n #else\n-  ret = *fd = open(file_name.ToNative().c_str(), O_RDONLY | O_BINARY);\n \n Review comment:\n   On POSIX it was defined to 0, so no. On Windows it's required to avoid automatic newline translation.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-30T09:18:00.086+0000",
                    "updated": "2019-05-30T09:18:00.086+0000",
                    "started": "2019-05-30T09:18:00.084+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "250851",
                    "issueId": "13234356"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/250852",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379#discussion_r288918191\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/util-internal.cc\n ##########\n @@ -0,0 +1,45 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/filesystem/util-internal.h\"\n+#include \"arrow/buffer.h\"\n+\n+namespace arrow {\n+namespace fs {\n+namespace internal {\n+\n+Status CopyStream(const std::shared_ptr<io::InputStream>& src,\n+                  const std::shared_ptr<io::OutputStream>& dest, int64_t chunk_size) {\n+  std::shared_ptr<Buffer> chunk;\n+  int64_t bytes_read;\n+\n+  RETURN_NOT_OK(AllocateBuffer(chunk_size, &chunk));\n+  while (true) {\n+    RETURN_NOT_OK(src->Read(chunk_size, &bytes_read, chunk->mutable_data()));\n+    if (bytes_read == 0) {\n+      // EOF\n+      break;\n+    }\n+    RETURN_NOT_OK(dest->Write(chunk->data(), bytes_read));\n \n Review comment:\n   My hope is that remote filesystems expose an API to copy files without going through the client...\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-30T09:19:08.934+0000",
                    "updated": "2019-05-30T09:19:08.934+0000",
                    "started": "2019-05-30T09:19:08.932+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "250852",
                    "issueId": "13234356"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/250854",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379#discussion_r288919316\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/localfs.cc\n ##########\n @@ -0,0 +1,387 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <chrono>\n+#include <cstring>\n+#include <utility>\n+\n+#ifdef _WIN32\n+#include \"arrow/util/windows_compatibility.h\"\n+#else\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdio.h>\n+#include <sys/stat.h>\n+#endif\n+\n+#include <boost/filesystem.hpp>\n+\n+#include \"arrow/filesystem/localfs.h\"\n+#include \"arrow/filesystem/util-internal.h\"\n+#include \"arrow/io/file.h\"\n+#include \"arrow/util/io-util.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace fs {\n+\n+namespace bfs = ::boost::filesystem;\n+\n+using ::arrow::internal::NativePathString;\n+using ::arrow::internal::PlatformFilename;\n+\n+namespace {\n+\n+#define BOOST_FILESYSTEM_TRY try {\n+#define BOOST_FILESYSTEM_CATCH           \\\n+  }                                      \\\n+  catch (bfs::filesystem_error & _err) { \\\n+    return ToStatus(_err);               \\\n+  }\n+\n+// NOTE: catching filesystem_error gives more context than system::error_code\n+// (it includes the file path(s) in the error message)\n+\n+Status ToStatus(const bfs::filesystem_error& err) { return Status::IOError(err.what()); }\n+\n+template <typename... Args>\n+Status ErrnoToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::ErrnoMessage(errno);\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+#ifdef _WIN32\n+\n+std::string NativeToString(const NativePathString& ns) {\n+  PlatformFilename fn(ns);\n+  return fn.ToString();\n+}\n+\n+template <typename... Args>\n+Status WinErrorToStatus(Args&&... args) {\n+  auto err_string = ::arrow::internal::WinErrorMessage(GetLastError());\n+  return Status::IOError(std::forward<Args>(args)..., err_string);\n+}\n+\n+TimePoint ToTimePoint(FILETIME ft) {\n+  // Hundreds of nanoseconds between January 1, 1601 (UTC) and the Unix epoch.\n+  static constexpr int64_t kFileTimeEpoch = 11644473600LL * 10000000;\n+\n+  int64_t hundreds = (static_cast<int64_t>(ft.dwHighDateTime) << 32) + ft.dwLowDateTime -\n+                     kFileTimeEpoch;  // hundreds of ns since Unix epoch\n+  std::chrono::nanoseconds ns_count(100 * hundreds);\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats FileInformationToFileStat(const BY_HANDLE_FILE_INFORMATION& info) {\n+  FileStats st;\n+  if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n+    // Regular file\n+    st.set_type(FileType::File);\n+    st.set_size((static_cast<int64_t>(info.nFileSizeHigh) << 32) + info.nFileSizeLow);\n+  }\n+  st.set_mtime(ToTimePoint(info.ftLastWriteTime));\n+  return st;\n+}\n+\n+Status StatFile(const std::wstring& path, FileStats* out) {\n+  HANDLE h;\n+  std::string bytes_path = NativeToString(path);\n+\n+  /* Inspired by CPython, see Modules/posixmodule.c */\n+  h = CreateFileW(path.c_str(), FILE_READ_ATTRIBUTES, /* desired access */\n+                  0,                                  /* share mode */\n+                  NULL,                               /* security attributes */\n+                  OPEN_EXISTING,\n+                  /* FILE_FLAG_BACKUP_SEMANTICS is required to open a directory */\n+                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n+\n+  if (h == INVALID_HANDLE_VALUE) {\n+    DWORD err = GetLastError();\n+    if (err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND) {\n+      out->set_path(bytes_path);\n+      out->set_type(FileType::NonExistent);\n+      out->set_mtime(kNoTime);\n+      out->set_size(kNoSize);\n+      return Status::OK();\n+    } else {\n+      return WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    }\n+  }\n+  BY_HANDLE_FILE_INFORMATION info;\n+  if (!GetFileInformationByHandle(h, &info)) {\n+    Status st =\n+        WinErrorToStatus(\"Failed querying information for path '\", bytes_path, \"'\");\n+    CloseHandle(h);\n+    return st;\n+  }\n+  CloseHandle(h);\n+  *out = FileInformationToFileStat(info);\n+  out->set_path(bytes_path);\n+  return Status::OK();\n+}\n+\n+#else  // POSIX systems\n+\n+TimePoint ToTimePoint(const struct timespec& s) {\n+  std::chrono::nanoseconds ns_count(static_cast<int64_t>(s.tv_sec) * 1000000000 +\n+                                    static_cast<int64_t>(s.tv_nsec));\n+  return TimePoint(std::chrono::duration_cast<TimePoint::duration>(ns_count));\n+}\n+\n+FileStats StatToFileStat(const struct stat& s) {\n+  FileStats st;\n+  if (S_ISREG(s.st_mode)) {\n+    st.set_type(FileType::File);\n+    st.set_size(static_cast<int64_t>(s.st_size));\n+  } else if (S_ISDIR(s.st_mode)) {\n+    st.set_type(FileType::Directory);\n+    st.set_size(kNoSize);\n+  } else {\n+    st.set_type(FileType::Unknown);\n+    st.set_size(kNoSize);\n+  }\n+#ifdef __APPLE__\n+  // macOS doesn't use the POSIX-compliant spelling\n+  st.set_mtime(ToTimePoint(s.st_mtimespec));\n+#else\n+  st.set_mtime(ToTimePoint(s.st_mtim));\n+#endif\n+  return st;\n+}\n+\n+Status StatFile(const std::string& path, FileStats* out) {\n+  struct stat s;\n+  int r = stat(path.c_str(), &s);\n+  if (r == -1) {\n+    if (errno == ENOENT || errno == ENOTDIR || errno == ELOOP) {\n+      out->set_type(FileType::NonExistent);\n+      out->set_mtime(kNoTime);\n+      out->set_size(kNoSize);\n+    } else {\n+      return ErrnoToStatus(\"Failed stat()ing path '\", path, \"'\");\n+    }\n+  } else {\n+    *out = StatToFileStat(s);\n+  }\n+  out->set_path(path);\n+  return Status::OK();\n+}\n+\n+#endif\n+\n+Status StatSelector(const NativePathString& path, const Selector& select,\n+                    std::vector<FileStats>* out) {\n+  bfs::path p(path);\n+\n+  if (select.allow_non_existent) {\n+    bfs::file_status st;\n+    BOOST_FILESYSTEM_TRY\n+    st = bfs::status(p);\n+    BOOST_FILESYSTEM_CATCH\n+    if (st.type() == bfs::file_not_found) {\n+      return Status::OK();\n+    }\n+  }\n+\n+  BOOST_FILESYSTEM_TRY\n+  for (const auto& entry : bfs::directory_iterator(p)) {\n+    FileStats st;\n+    NativePathString ns = entry.path().native();\n+    RETURN_NOT_OK(StatFile(ns, &st));\n+    if (st.type() != FileType::NonExistent) {\n+      out->push_back(std::move(st));\n+    }\n+    if (select.recursive && st.type() == FileType::Directory) {\n+      RETURN_NOT_OK(StatSelector(ns, select, out));\n+    }\n+  }\n+  BOOST_FILESYSTEM_CATCH\n+\n+  return Status::OK();\n+}\n+\n+}  // namespace\n+\n+LocalFileSystem::LocalFileSystem() {}\n+\n+LocalFileSystem::~LocalFileSystem() {}\n+\n+Status LocalFileSystem::GetTargetStats(const std::string& path, FileStats* out) {\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  return StatFile(fn.ToNative(), out);\n+}\n+\n+Status LocalFileSystem::GetTargetStats(const Selector& select,\n+                                       std::vector<FileStats>* out) {\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(select.base_dir, &fn));\n+  out->clear();\n+  return StatSelector(fn.ToNative(), select, out);\n+}\n+\n+Status LocalFileSystem::CreateDir(const std::string& path, bool recursive) {\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  if (recursive) {\n+    return ::arrow::internal::CreateDirTree(fn);\n+  } else {\n+    return ::arrow::internal::CreateDir(fn);\n+  }\n+}\n+\n+Status LocalFileSystem::DeleteDir(const std::string& path) {\n+  bool deleted = false;\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(::arrow::internal::DeleteDirTree(fn, &deleted));\n+  if (deleted) {\n+    return Status::OK();\n+  } else {\n+    return Status::IOError(\"Directory does not exist: '\", path, \"'\");\n+  }\n+}\n+\n+Status LocalFileSystem::DeleteFile(const std::string& path) {\n+  bool deleted = false;\n+  PlatformFilename fn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(::arrow::internal::DeleteFile(fn, &deleted));\n+  if (deleted) {\n+    return Status::OK();\n+  } else {\n+    return Status::IOError(\"File does not exist: '\", path, \"'\");\n+  }\n+}\n+\n+Status LocalFileSystem::Move(const std::string& src, const std::string& dest) {\n+  PlatformFilename sfn, dfn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(src, &sfn));\n+  RETURN_NOT_OK(PlatformFilename::FromString(dest, &dfn));\n+\n+#ifdef _WIN32\n+  if (!MoveFileExW(sfn.ToNative().c_str(), dfn.ToNative().c_str(),\n+                   MOVEFILE_REPLACE_EXISTING)) {\n+    return WinErrorToStatus(\"Failed renaming '\", sfn.ToString(), \"' to '\", dfn.ToString(),\n+                            \"': \");\n+  }\n+#else\n+  if (rename(sfn.ToNative().c_str(), dfn.ToNative().c_str()) == -1) {\n+    return ErrnoToStatus(\"Failed renaming '\", sfn.ToString(), \"' to '\", dfn.ToString(),\n+                         \"': \");\n+  }\n+#endif\n+  return Status::OK();\n+}\n+\n+Status LocalFileSystem::CopyFile(const std::string& src, const std::string& dest) {\n+  PlatformFilename sfn, dfn;\n+  RETURN_NOT_OK(PlatformFilename::FromString(src, &sfn));\n+  RETURN_NOT_OK(PlatformFilename::FromString(dest, &dfn));\n+  // XXX should we use fstat() to compare inodes?\n+  if (sfn.ToNative() == dfn.ToNative()) {\n+    return Status::OK();\n+  }\n+\n+#ifdef _WIN32\n+  if (!CopyFileW(sfn.ToNative().c_str(), dfn.ToNative().c_str(),\n+                 FALSE /* bFailIfExists */)) {\n+    return WinErrorToStatus(\"Failed copying '\", sfn.ToString(), \"' to '\", dfn.ToString(),\n+                            \"': \");\n+  }\n+  return Status::OK();\n+#else\n+  std::shared_ptr<io::InputStream> is;\n+  std::shared_ptr<io::OutputStream> os;\n+  RETURN_NOT_OK(OpenInputStream(src, &is));\n+  RETURN_NOT_OK(OpenOutputStream(dest, &os));\n+  RETURN_NOT_OK(internal::CopyStream(is, os, 1024 * 1024 /* chunk_size */));\n+  RETURN_NOT_OK(os->Close());\n+  return is->Close();\n+#endif\n+}\n+\n+Status LocalFileSystem::OpenInputStream(const std::string& path,\n+                                        std::shared_ptr<io::InputStream>* out) {\n+  PlatformFilename fn;\n+  int fd;\n+  std::shared_ptr<io::ReadableFile> file;\n+  RETURN_NOT_OK(PlatformFilename::FromString(path, &fn));\n+  RETURN_NOT_OK(::arrow::internal::FileOpenReadable(fn, &fd));\n \n Review comment:\n   Good question. It looks like it should actually do the same work :-)\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-30T09:22:57.319+0000",
                    "updated": "2019-05-30T09:22:57.319+0000",
                    "started": "2019-05-30T09:22:57.319+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "250854",
                    "issueId": "13234356"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/worklog/250893",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on issue #4379: ARROW-5378: [C++] Local filesystem implementation\nURL: https://github.com/apache/arrow/pull/4379#issuecomment-497292854\n \n \n   I think I've addressed the review comments. Hopefully CI will not bark.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-30T11:03:32.106+0000",
                    "updated": "2019-05-30T11:03:32.106+0000",
                    "started": "2019-05-30T11:03:32.106+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "250893",
                    "issueId": "13234356"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 15000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@46e64e9b[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2b6dd8c[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4c72b593[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@781c4b2c[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@343103db[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@290cf397[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@708b1508[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@6ad4651e[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@56478c44[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@18195d50[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3092380e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@79275797[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 15000,
        "customfield_12312520": null,
        "customfield_12312521": "Thu May 30 17:12:27 UTC 2019",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2019-05-30T17:12:27.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-5378/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2019-05-20T16:29:40.000+0000",
        "updated": "2019-05-30T17:12:41.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 15000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Add local FileSystem implementation",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13234356/comment/16852090",
                    "id": "16852090",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 4379\n[https://github.com/apache/arrow/pull/4379]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2019-05-30T17:12:27.892+0000",
                    "updated": "2019-05-30T17:12:27.892+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z02v68:",
        "customfield_12314139": null
    }
}