{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13447905",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447905",
    "key": "ARROW-16707",
    "fields": {
        "fixVersions": [],
        "resolution": null,
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=willayd",
            "name": "willayd",
            "key": "willayd",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=willayd&avatarId=49036",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=willayd&avatarId=49036",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=willayd&avatarId=49036",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=willayd&avatarId=49036"
            },
            "displayName": "Will Ayd",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/3",
            "description": "This issue is being actively worked on at the moment by the assignee.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/inprogress.png",
            "name": "In Progress",
            "id": "3",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/4",
                "id": 4,
                "key": "indeterminate",
                "colorName": "yellow",
                "name": "In Progress"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "aggregateprogress": {
            "progress": 8400,
            "total": 8400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 8400,
            "total": 8400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16707/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 14,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447905/worklog/820189",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "WillAyd commented on code in PR #14505:\nURL: https://github.com/apache/arrow/pull/14505#discussion_r1004837884\n\n\n##########\ncpp/src/arrow/compute/kernels/vector_sort_test.cc:\n##########\n@@ -2182,5 +2185,24 @@ TEST(TestRankForFixedSizeBinary, RankFixedSizeBinary) {\n       ArrayFromJSON(binary_type, R\"([\"aaa\", \"   \", \"eee\", null, \"eee\", null, \"   \"])\"));\n }\n \n+\n+TEST(TestRankForReal, RankRealChunked) {\n\nReview Comment:\n   Here I have created the Chunk test as a separate item, which duplicates all of the looping logic. If we didn't want to do that, could also just implement the ChunkedArray constructors in the existing tests. \r\n   \r\n   I think most tests go with this pattern, so happy to continue and copy over all of the rest of the type tests if that's what we want\n\n\n\n##########\ncpp/src/arrow/compute/kernels/vector_sort.cc:\n##########\n@@ -2078,6 +2078,293 @@ class ArrayRanker : public TypeVisitor {\n   Datum* output_;\n };\n \n+class ChunkedArrayRanker : public TypeVisitor {\n+ public:\n+  // TODO: here we accept order / null_placement / tiebreaker as separate arguments\n+  // whereas the ArrayRanker accepts them as the RankOptions struct; this is consistent\n+  // with ArraySorter / ChunkedArraySorter, so likely should refactor ArrayRanker\n+  ChunkedArrayRanker(ExecContext* ctx, uint64_t* indices_begin, uint64_t* indices_end,\n+                     const ChunkedArray& chunked_array, const SortOrder order,\n+                     const NullPlacement null_placement, const RankOptions::Tiebreaker tiebreaker, Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        indices_begin_(indices_begin),\n+        indices_end_(indices_end),\n+        chunked_array_(chunked_array),\n+        physical_type_(GetPhysicalType(chunked_array.type())),\n+        physical_chunks_(GetPhysicalChunks(chunked_array_, physical_type_)),\n+        order_(order),\n+        null_placement_(null_placement),\n+        tiebreaker_(tiebreaker),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return RankInternal<TYPE>(); }\n+\n+  VISIT_SORTABLE_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status RankInternal() {\n+    using GetView = GetViewType<InType>;\n+    using T = typename GetViewType<InType>::T;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    const auto num_chunks = chunked_array_.num_chunks();\n+    if (num_chunks == 0) {\n+      return Status::OK();\n+    }\n+    const auto arrays = GetArrayPointers(physical_chunks_);\n+\n+    ArraySortOptions array_options(order_, null_placement_);\n+\n+    ARROW_ASSIGN_OR_RAISE(auto array_sorter, GetArraySorter(*physical_type_));\n+\n+    // See related ChunkedArraySort method for comments\n\nReview Comment:\n   This and the next 20 lines of merging code is copied from the ChunkedArraySort implementation. Could refactor to make it a function each class could call instead I think\n\n\n\n##########\ncpp/src/arrow/compute/kernels/vector_sort.cc:\n##########\n@@ -2078,6 +2078,293 @@ class ArrayRanker : public TypeVisitor {\n   Datum* output_;\n };\n \n+class ChunkedArrayRanker : public TypeVisitor {\n+ public:\n+  // TODO: here we accept order / null_placement / tiebreaker as separate arguments\n+  // whereas the ArrayRanker accepts them as the RankOptions struct; this is consistent\n+  // with ArraySorter / ChunkedArraySorter, so likely should refactor ArrayRanker\n+  ChunkedArrayRanker(ExecContext* ctx, uint64_t* indices_begin, uint64_t* indices_end,\n+                     const ChunkedArray& chunked_array, const SortOrder order,\n+                     const NullPlacement null_placement, const RankOptions::Tiebreaker tiebreaker, Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        indices_begin_(indices_begin),\n+        indices_end_(indices_end),\n+        chunked_array_(chunked_array),\n+        physical_type_(GetPhysicalType(chunked_array.type())),\n+        physical_chunks_(GetPhysicalChunks(chunked_array_, physical_type_)),\n+        order_(order),\n+        null_placement_(null_placement),\n+        tiebreaker_(tiebreaker),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return RankInternal<TYPE>(); }\n+\n+  VISIT_SORTABLE_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status RankInternal() {\n+    using GetView = GetViewType<InType>;\n+    using T = typename GetViewType<InType>::T;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    const auto num_chunks = chunked_array_.num_chunks();\n+    if (num_chunks == 0) {\n+      return Status::OK();\n+    }\n+    const auto arrays = GetArrayPointers(physical_chunks_);\n+\n+    ArraySortOptions array_options(order_, null_placement_);\n+\n+    ARROW_ASSIGN_OR_RAISE(auto array_sorter, GetArraySorter(*physical_type_));\n+\n+    // See related ChunkedArraySort method for comments\n+    std::vector<NullPartitionResult> sorted(num_chunks);\n+    int64_t begin_offset = 0;\n+    int64_t end_offset = 0;\n+    int64_t null_count = 0;\n+    for (int i = 0; i < num_chunks; ++i) {\n+      const auto array = checked_cast<const ArrayType*>(arrays[i]);\n+      end_offset += array->length();\n+      null_count += array->null_count();\n+      sorted[i] = array_sorter(indices_begin_ + begin_offset, indices_begin_ + end_offset,\n+                               *array, begin_offset, array_options);\n+      begin_offset = end_offset;\n+    }\n+    DCHECK_EQ(end_offset, indices_end_ - indices_begin_);\n+\n+    if (sorted.size() > 1) {\n+      auto merge_nulls = [&](uint64_t* nulls_begin, uint64_t* nulls_middle,\n+                             uint64_t* nulls_end, uint64_t* temp_indices,\n+                             int64_t null_count) {\n+        if (has_null_like_values<typename ArrayType::TypeClass>::value) {\n+          PartitionNullsOnly<StablePartitioner>(nulls_begin, nulls_end,\n+                                                ChunkedArrayResolver(arrays), null_count,\n+                                                null_placement_);\n+        }\n+      };\n+      auto merge_non_nulls = [&](uint64_t* range_begin, uint64_t* range_middle,\n+                                 uint64_t* range_end, uint64_t* temp_indices) {\n+        MergeNonNulls<ArrayType>(range_begin, range_middle, range_end, arrays,\n+                                 temp_indices);\n+      };\n+\n+      MergeImpl merge_impl{null_placement_, std::move(merge_nulls),\n+                           std::move(merge_non_nulls)};\n+      // std::merge is only called on non-null values, so size temp indices accordingly\n+      RETURN_NOT_OK(merge_impl.Init(ctx_, indices_end_ - indices_begin_ - null_count));\n+\n+      while (sorted.size() > 1) {\n+        auto out_it = sorted.begin();\n+        auto it = sorted.begin();\n+        while (it < sorted.end() - 1) {\n+          const auto& left = *it++;\n+          const auto& right = *it++;\n+          DCHECK_EQ(left.overall_end(), right.overall_begin());\n+          const auto merged = merge_impl.Merge(left, right, null_count);\n+          *out_it++ = merged;\n+        }\n+        if (it < sorted.end()) {\n+          *out_it++ = *it++;\n+        }\n+        sorted.erase(out_it, sorted.end());\n+      }\n+    }\n+\n+    DCHECK_EQ(sorted.size(), 1);\n+    DCHECK_EQ(sorted[0].overall_begin(), indices_begin_);\n+    DCHECK_EQ(sorted[0].overall_end(), indices_end_);\n+    // Note that \"nulls\" can also include NaNs, hence the >= check\n+    DCHECK_GE(sorted[0].null_count(), null_count);\n+\n+    auto length = indices_end_ - indices_begin_;\n+    ARROW_ASSIGN_OR_RAISE(auto rankings,\n+                          MakeMutableUInt64Array(uint64(), length, ctx_->memory_pool()));\n+    auto out_begin = rankings->GetMutableValues<uint64_t>(1);\n+    uint64_t rank;\n+\n+    switch (tiebreaker_) {\n+      case RankOptions::Dense: {\n+        T curr_value, prev_value{};\n+        rank = 0;\n+\n+        if (null_placement_ == NullPlacement::AtStart && sorted[0].null_count() > 0) {\n+          rank++;\n+          for (auto it = sorted[0].nulls_begin; it < sorted[0].nulls_end; it++) {\n+            out_begin[*it] = rank;\n+          }\n+        }\n+\n+        for (auto it = sorted[0].non_nulls_begin; it < sorted[0].non_nulls_end; it++) {\n+          // Below code wasn't working for string specialization as -> value returned a buffer\n+          // but T is a basic_string_view\n+          // using ScalarType = typename TypeTraits<InType>::ScalarType;\n+          // auto scalar = std::dynamic_pointer_cast<ScalarType>(\n+          //   chunked_array_.GetScalar(*it).ValueOrDie());\n+          // curr_value = scalar->value;\n+          // TODO: can we use chunk_resolver_ from chunked array externally?          \n+          if (*it >= 2) {\n\nReview Comment:\n   This is hacked together just to work for the provided test case but obviously needs a better implementation. I wasn't sure what the best approach was to get the logical value from a particular index in a ChunkedArray. Alternately we can bypass the ChunkedArray and try to use the `arrays` variable, but I don't know that that would be any cleaner\n\n\n\n##########\ncpp/src/arrow/compute/kernels/vector_sort.cc:\n##########\n@@ -2078,6 +2078,293 @@ class ArrayRanker : public TypeVisitor {\n   Datum* output_;\n };\n \n+class ChunkedArrayRanker : public TypeVisitor {\n+ public:\n+  // TODO: here we accept order / null_placement / tiebreaker as separate arguments\n+  // whereas the ArrayRanker accepts them as the RankOptions struct; this is consistent\n+  // with ArraySorter / ChunkedArraySorter, so likely should refactor ArrayRanker\n+  ChunkedArrayRanker(ExecContext* ctx, uint64_t* indices_begin, uint64_t* indices_end,\n+                     const ChunkedArray& chunked_array, const SortOrder order,\n+                     const NullPlacement null_placement, const RankOptions::Tiebreaker tiebreaker, Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        indices_begin_(indices_begin),\n+        indices_end_(indices_end),\n+        chunked_array_(chunked_array),\n+        physical_type_(GetPhysicalType(chunked_array.type())),\n+        physical_chunks_(GetPhysicalChunks(chunked_array_, physical_type_)),\n+        order_(order),\n+        null_placement_(null_placement),\n+        tiebreaker_(tiebreaker),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return RankInternal<TYPE>(); }\n+\n+  VISIT_SORTABLE_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status RankInternal() {\n+    using GetView = GetViewType<InType>;\n+    using T = typename GetViewType<InType>::T;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    const auto num_chunks = chunked_array_.num_chunks();\n+    if (num_chunks == 0) {\n+      return Status::OK();\n+    }\n+    const auto arrays = GetArrayPointers(physical_chunks_);\n+\n+    ArraySortOptions array_options(order_, null_placement_);\n+\n+    ARROW_ASSIGN_OR_RAISE(auto array_sorter, GetArraySorter(*physical_type_));\n+\n+    // See related ChunkedArraySort method for comments\n+    std::vector<NullPartitionResult> sorted(num_chunks);\n+    int64_t begin_offset = 0;\n+    int64_t end_offset = 0;\n+    int64_t null_count = 0;\n+    for (int i = 0; i < num_chunks; ++i) {\n+      const auto array = checked_cast<const ArrayType*>(arrays[i]);\n+      end_offset += array->length();\n+      null_count += array->null_count();\n+      sorted[i] = array_sorter(indices_begin_ + begin_offset, indices_begin_ + end_offset,\n+                               *array, begin_offset, array_options);\n+      begin_offset = end_offset;\n+    }\n+    DCHECK_EQ(end_offset, indices_end_ - indices_begin_);\n+\n+    if (sorted.size() > 1) {\n+      auto merge_nulls = [&](uint64_t* nulls_begin, uint64_t* nulls_middle,\n+                             uint64_t* nulls_end, uint64_t* temp_indices,\n+                             int64_t null_count) {\n+        if (has_null_like_values<typename ArrayType::TypeClass>::value) {\n+          PartitionNullsOnly<StablePartitioner>(nulls_begin, nulls_end,\n+                                                ChunkedArrayResolver(arrays), null_count,\n+                                                null_placement_);\n+        }\n+      };\n+      auto merge_non_nulls = [&](uint64_t* range_begin, uint64_t* range_middle,\n+                                 uint64_t* range_end, uint64_t* temp_indices) {\n+        MergeNonNulls<ArrayType>(range_begin, range_middle, range_end, arrays,\n+                                 temp_indices);\n+      };\n+\n+      MergeImpl merge_impl{null_placement_, std::move(merge_nulls),\n+                           std::move(merge_non_nulls)};\n+      // std::merge is only called on non-null values, so size temp indices accordingly\n+      RETURN_NOT_OK(merge_impl.Init(ctx_, indices_end_ - indices_begin_ - null_count));\n+\n+      while (sorted.size() > 1) {\n+        auto out_it = sorted.begin();\n+        auto it = sorted.begin();\n+        while (it < sorted.end() - 1) {\n+          const auto& left = *it++;\n+          const auto& right = *it++;\n+          DCHECK_EQ(left.overall_end(), right.overall_begin());\n+          const auto merged = merge_impl.Merge(left, right, null_count);\n+          *out_it++ = merged;\n+        }\n+        if (it < sorted.end()) {\n+          *out_it++ = *it++;\n+        }\n+        sorted.erase(out_it, sorted.end());\n+      }\n+    }\n+\n+    DCHECK_EQ(sorted.size(), 1);\n+    DCHECK_EQ(sorted[0].overall_begin(), indices_begin_);\n+    DCHECK_EQ(sorted[0].overall_end(), indices_end_);\n+    // Note that \"nulls\" can also include NaNs, hence the >= check\n+    DCHECK_GE(sorted[0].null_count(), null_count);\n+\n+    auto length = indices_end_ - indices_begin_;\n+    ARROW_ASSIGN_OR_RAISE(auto rankings,\n+                          MakeMutableUInt64Array(uint64(), length, ctx_->memory_pool()));\n+    auto out_begin = rankings->GetMutableValues<uint64_t>(1);\n+    uint64_t rank;\n+\n+    switch (tiebreaker_) {\n\nReview Comment:\n   Except for nuance around how to retrieve a value from an array at a particular index in a performant manner, this Rank algorithm is copy / paste from the `ArrayRanker` class, so likely can refactor into a function outside of the classes\n\n\n\n",
                    "created": "2022-10-25T18:35:19.087+0000",
                    "updated": "2022-10-25T18:35:19.087+0000",
                    "started": "2022-10-25T18:35:19.087+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "820189",
                    "issueId": "13447905"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447905/worklog/820219",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #14505:\nURL: https://github.com/apache/arrow/pull/14505#issuecomment-1291066765\n\n   https://issues.apache.org/jira/browse/ARROW-16707\n\n\n",
                    "created": "2022-10-25T19:57:38.856+0000",
                    "updated": "2022-10-25T19:57:38.856+0000",
                    "started": "2022-10-25T19:57:38.855+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "820219",
                    "issueId": "13447905"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447905/worklog/820220",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #14505:\nURL: https://github.com/apache/arrow/pull/14505#issuecomment-1291066800\n\n   :warning: Ticket **has not been started in JIRA**, please click 'Start Progress'.\n\n\n",
                    "created": "2022-10-25T19:57:40.730+0000",
                    "updated": "2022-10-25T19:57:40.730+0000",
                    "started": "2022-10-25T19:57:40.730+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "820220",
                    "issueId": "13447905"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447905/worklog/820769",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "WillAyd commented on code in PR #14505:\nURL: https://github.com/apache/arrow/pull/14505#discussion_r1006264959\n\n\n##########\ncpp/src/arrow/compute/kernels/vector_sort.cc:\n##########\n@@ -2078,6 +2078,293 @@ class ArrayRanker : public TypeVisitor {\n   Datum* output_;\n };\n \n+class ChunkedArrayRanker : public TypeVisitor {\n+ public:\n+  // TODO: here we accept order / null_placement / tiebreaker as separate arguments\n+  // whereas the ArrayRanker accepts them as the RankOptions struct; this is consistent\n+  // with ArraySorter / ChunkedArraySorter, so likely should refactor ArrayRanker\n+  ChunkedArrayRanker(ExecContext* ctx, uint64_t* indices_begin, uint64_t* indices_end,\n+                     const ChunkedArray& chunked_array, const SortOrder order,\n+                     const NullPlacement null_placement, const RankOptions::Tiebreaker tiebreaker, Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        indices_begin_(indices_begin),\n+        indices_end_(indices_end),\n+        chunked_array_(chunked_array),\n+        physical_type_(GetPhysicalType(chunked_array.type())),\n+        physical_chunks_(GetPhysicalChunks(chunked_array_, physical_type_)),\n+        order_(order),\n+        null_placement_(null_placement),\n+        tiebreaker_(tiebreaker),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return RankInternal<TYPE>(); }\n+\n+  VISIT_SORTABLE_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status RankInternal() {\n+    using GetView = GetViewType<InType>;\n+    using T = typename GetViewType<InType>::T;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    const auto num_chunks = chunked_array_.num_chunks();\n+    if (num_chunks == 0) {\n+      return Status::OK();\n+    }\n+    const auto arrays = GetArrayPointers(physical_chunks_);\n+\n+    ArraySortOptions array_options(order_, null_placement_);\n+\n+    ARROW_ASSIGN_OR_RAISE(auto array_sorter, GetArraySorter(*physical_type_));\n+\n+    // See related ChunkedArraySort method for comments\n+    std::vector<NullPartitionResult> sorted(num_chunks);\n+    int64_t begin_offset = 0;\n+    int64_t end_offset = 0;\n+    int64_t null_count = 0;\n+    for (int i = 0; i < num_chunks; ++i) {\n+      const auto array = checked_cast<const ArrayType*>(arrays[i]);\n+      end_offset += array->length();\n+      null_count += array->null_count();\n+      sorted[i] = array_sorter(indices_begin_ + begin_offset, indices_begin_ + end_offset,\n+                               *array, begin_offset, array_options);\n+      begin_offset = end_offset;\n+    }\n+    DCHECK_EQ(end_offset, indices_end_ - indices_begin_);\n+\n+    if (sorted.size() > 1) {\n+      auto merge_nulls = [&](uint64_t* nulls_begin, uint64_t* nulls_middle,\n+                             uint64_t* nulls_end, uint64_t* temp_indices,\n+                             int64_t null_count) {\n+        if (has_null_like_values<typename ArrayType::TypeClass>::value) {\n+          PartitionNullsOnly<StablePartitioner>(nulls_begin, nulls_end,\n+                                                ChunkedArrayResolver(arrays), null_count,\n+                                                null_placement_);\n+        }\n+      };\n+      auto merge_non_nulls = [&](uint64_t* range_begin, uint64_t* range_middle,\n+                                 uint64_t* range_end, uint64_t* temp_indices) {\n+        MergeNonNulls<ArrayType>(range_begin, range_middle, range_end, arrays,\n+                                 temp_indices);\n+      };\n+\n+      MergeImpl merge_impl{null_placement_, std::move(merge_nulls),\n+                           std::move(merge_non_nulls)};\n+      // std::merge is only called on non-null values, so size temp indices accordingly\n+      RETURN_NOT_OK(merge_impl.Init(ctx_, indices_end_ - indices_begin_ - null_count));\n+\n+      while (sorted.size() > 1) {\n+        auto out_it = sorted.begin();\n+        auto it = sorted.begin();\n+        while (it < sorted.end() - 1) {\n+          const auto& left = *it++;\n+          const auto& right = *it++;\n+          DCHECK_EQ(left.overall_end(), right.overall_begin());\n+          const auto merged = merge_impl.Merge(left, right, null_count);\n+          *out_it++ = merged;\n+        }\n+        if (it < sorted.end()) {\n+          *out_it++ = *it++;\n+        }\n+        sorted.erase(out_it, sorted.end());\n+      }\n+    }\n+\n+    DCHECK_EQ(sorted.size(), 1);\n+    DCHECK_EQ(sorted[0].overall_begin(), indices_begin_);\n+    DCHECK_EQ(sorted[0].overall_end(), indices_end_);\n+    // Note that \"nulls\" can also include NaNs, hence the >= check\n+    DCHECK_GE(sorted[0].null_count(), null_count);\n+\n+    auto length = indices_end_ - indices_begin_;\n+    ARROW_ASSIGN_OR_RAISE(auto rankings,\n+                          MakeMutableUInt64Array(uint64(), length, ctx_->memory_pool()));\n+    auto out_begin = rankings->GetMutableValues<uint64_t>(1);\n+    uint64_t rank;\n+\n+    switch (tiebreaker_) {\n+      case RankOptions::Dense: {\n+        T curr_value, prev_value{};\n+        rank = 0;\n+\n+        if (null_placement_ == NullPlacement::AtStart && sorted[0].null_count() > 0) {\n+          rank++;\n+          for (auto it = sorted[0].nulls_begin; it < sorted[0].nulls_end; it++) {\n+            out_begin[*it] = rank;\n+          }\n+        }\n+\n+        for (auto it = sorted[0].non_nulls_begin; it < sorted[0].non_nulls_end; it++) {\n+          // Below code wasn't working for string specialization as -> value returned a buffer\n+          // but T is a basic_string_view\n+          // using ScalarType = typename TypeTraits<InType>::ScalarType;\n+          // auto scalar = std::dynamic_pointer_cast<ScalarType>(\n+          //   chunked_array_.GetScalar(*it).ValueOrDie());\n+          // curr_value = scalar->value;\n+          // TODO: can we use chunk_resolver_ from chunked array externally?          \n+          if (*it >= 2) {\n\nReview Comment:\n   My current best guess is to execute `take` with the indices and iterate over that result. I don't know that I've seen that pattern internally yet so happy to go a different route if that is too heavy handed\n\n\n\n",
                    "created": "2022-10-26T23:16:41.737+0000",
                    "updated": "2022-10-26T23:16:41.737+0000",
                    "started": "2022-10-26T23:16:41.737+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "820769",
                    "issueId": "13447905"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447905/worklog/820770",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "WillAyd commented on code in PR #14505:\nURL: https://github.com/apache/arrow/pull/14505#discussion_r1006264959\n\n\n##########\ncpp/src/arrow/compute/kernels/vector_sort.cc:\n##########\n@@ -2078,6 +2078,293 @@ class ArrayRanker : public TypeVisitor {\n   Datum* output_;\n };\n \n+class ChunkedArrayRanker : public TypeVisitor {\n+ public:\n+  // TODO: here we accept order / null_placement / tiebreaker as separate arguments\n+  // whereas the ArrayRanker accepts them as the RankOptions struct; this is consistent\n+  // with ArraySorter / ChunkedArraySorter, so likely should refactor ArrayRanker\n+  ChunkedArrayRanker(ExecContext* ctx, uint64_t* indices_begin, uint64_t* indices_end,\n+                     const ChunkedArray& chunked_array, const SortOrder order,\n+                     const NullPlacement null_placement, const RankOptions::Tiebreaker tiebreaker, Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        indices_begin_(indices_begin),\n+        indices_end_(indices_end),\n+        chunked_array_(chunked_array),\n+        physical_type_(GetPhysicalType(chunked_array.type())),\n+        physical_chunks_(GetPhysicalChunks(chunked_array_, physical_type_)),\n+        order_(order),\n+        null_placement_(null_placement),\n+        tiebreaker_(tiebreaker),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return RankInternal<TYPE>(); }\n+\n+  VISIT_SORTABLE_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status RankInternal() {\n+    using GetView = GetViewType<InType>;\n+    using T = typename GetViewType<InType>::T;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    const auto num_chunks = chunked_array_.num_chunks();\n+    if (num_chunks == 0) {\n+      return Status::OK();\n+    }\n+    const auto arrays = GetArrayPointers(physical_chunks_);\n+\n+    ArraySortOptions array_options(order_, null_placement_);\n+\n+    ARROW_ASSIGN_OR_RAISE(auto array_sorter, GetArraySorter(*physical_type_));\n+\n+    // See related ChunkedArraySort method for comments\n+    std::vector<NullPartitionResult> sorted(num_chunks);\n+    int64_t begin_offset = 0;\n+    int64_t end_offset = 0;\n+    int64_t null_count = 0;\n+    for (int i = 0; i < num_chunks; ++i) {\n+      const auto array = checked_cast<const ArrayType*>(arrays[i]);\n+      end_offset += array->length();\n+      null_count += array->null_count();\n+      sorted[i] = array_sorter(indices_begin_ + begin_offset, indices_begin_ + end_offset,\n+                               *array, begin_offset, array_options);\n+      begin_offset = end_offset;\n+    }\n+    DCHECK_EQ(end_offset, indices_end_ - indices_begin_);\n+\n+    if (sorted.size() > 1) {\n+      auto merge_nulls = [&](uint64_t* nulls_begin, uint64_t* nulls_middle,\n+                             uint64_t* nulls_end, uint64_t* temp_indices,\n+                             int64_t null_count) {\n+        if (has_null_like_values<typename ArrayType::TypeClass>::value) {\n+          PartitionNullsOnly<StablePartitioner>(nulls_begin, nulls_end,\n+                                                ChunkedArrayResolver(arrays), null_count,\n+                                                null_placement_);\n+        }\n+      };\n+      auto merge_non_nulls = [&](uint64_t* range_begin, uint64_t* range_middle,\n+                                 uint64_t* range_end, uint64_t* temp_indices) {\n+        MergeNonNulls<ArrayType>(range_begin, range_middle, range_end, arrays,\n+                                 temp_indices);\n+      };\n+\n+      MergeImpl merge_impl{null_placement_, std::move(merge_nulls),\n+                           std::move(merge_non_nulls)};\n+      // std::merge is only called on non-null values, so size temp indices accordingly\n+      RETURN_NOT_OK(merge_impl.Init(ctx_, indices_end_ - indices_begin_ - null_count));\n+\n+      while (sorted.size() > 1) {\n+        auto out_it = sorted.begin();\n+        auto it = sorted.begin();\n+        while (it < sorted.end() - 1) {\n+          const auto& left = *it++;\n+          const auto& right = *it++;\n+          DCHECK_EQ(left.overall_end(), right.overall_begin());\n+          const auto merged = merge_impl.Merge(left, right, null_count);\n+          *out_it++ = merged;\n+        }\n+        if (it < sorted.end()) {\n+          *out_it++ = *it++;\n+        }\n+        sorted.erase(out_it, sorted.end());\n+      }\n+    }\n+\n+    DCHECK_EQ(sorted.size(), 1);\n+    DCHECK_EQ(sorted[0].overall_begin(), indices_begin_);\n+    DCHECK_EQ(sorted[0].overall_end(), indices_end_);\n+    // Note that \"nulls\" can also include NaNs, hence the >= check\n+    DCHECK_GE(sorted[0].null_count(), null_count);\n+\n+    auto length = indices_end_ - indices_begin_;\n+    ARROW_ASSIGN_OR_RAISE(auto rankings,\n+                          MakeMutableUInt64Array(uint64(), length, ctx_->memory_pool()));\n+    auto out_begin = rankings->GetMutableValues<uint64_t>(1);\n+    uint64_t rank;\n+\n+    switch (tiebreaker_) {\n+      case RankOptions::Dense: {\n+        T curr_value, prev_value{};\n+        rank = 0;\n+\n+        if (null_placement_ == NullPlacement::AtStart && sorted[0].null_count() > 0) {\n+          rank++;\n+          for (auto it = sorted[0].nulls_begin; it < sorted[0].nulls_end; it++) {\n+            out_begin[*it] = rank;\n+          }\n+        }\n+\n+        for (auto it = sorted[0].non_nulls_begin; it < sorted[0].non_nulls_end; it++) {\n+          // Below code wasn't working for string specialization as -> value returned a buffer\n+          // but T is a basic_string_view\n+          // using ScalarType = typename TypeTraits<InType>::ScalarType;\n+          // auto scalar = std::dynamic_pointer_cast<ScalarType>(\n+          //   chunked_array_.GetScalar(*it).ValueOrDie());\n+          // curr_value = scalar->value;\n+          // TODO: can we use chunk_resolver_ from chunked array externally?          \n+          if (*it >= 2) {\n\nReview Comment:\n   My current best guess is to execute `take` with the indices and iterate over that result via `ChunkedArrayIterator`. I don't know that I've seen that pattern internally yet so happy to go a different route if that is too heavy handed\n\n\n\n",
                    "created": "2022-10-26T23:17:57.506+0000",
                    "updated": "2022-10-26T23:17:57.506+0000",
                    "started": "2022-10-26T23:17:57.506+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "820770",
                    "issueId": "13447905"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447905/worklog/824303",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "WillAyd commented on PR #14505:\nURL: https://github.com/apache/arrow/pull/14505#issuecomment-1307661130\n\n   @pitrou @lidavidm if either of you have time to review would be appreciated as always. I think the CI failures are unrelated\n\n\n",
                    "created": "2022-11-08T18:32:35.477+0000",
                    "updated": "2022-11-08T18:32:35.477+0000",
                    "started": "2022-11-08T18:32:35.477+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824303",
                    "issueId": "13447905"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447905/worklog/824939",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on PR #14505:\nURL: https://github.com/apache/arrow/pull/14505#issuecomment-1310335239\n\n   Hey - I'll try to get to this soon but it may be a few more days\n\n\n",
                    "created": "2022-11-10T14:10:20.839+0000",
                    "updated": "2022-11-10T14:10:20.839+0000",
                    "started": "2022-11-10T14:10:20.838+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824939",
                    "issueId": "13447905"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447905/worklog/824961",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #14505:\nURL: https://github.com/apache/arrow/pull/14505#discussion_r1019255519\n\n\n##########\ncpp/src/arrow/compute/kernels/vector_sort.cc:\n##########\n@@ -2078,6 +2078,293 @@ class ArrayRanker : public TypeVisitor {\n   Datum* output_;\n };\n \n+class ChunkedArrayRanker : public TypeVisitor {\n+ public:\n+  // TODO: here we accept order / null_placement / tiebreaker as separate arguments\n+  // whereas the ArrayRanker accepts them as the RankOptions struct; this is consistent\n+  // with ArraySorter / ChunkedArraySorter, so likely should refactor ArrayRanker\n+  ChunkedArrayRanker(ExecContext* ctx, uint64_t* indices_begin, uint64_t* indices_end,\n+                     const ChunkedArray& chunked_array, const SortOrder order,\n+                     const NullPlacement null_placement, const RankOptions::Tiebreaker tiebreaker, Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        indices_begin_(indices_begin),\n+        indices_end_(indices_end),\n+        chunked_array_(chunked_array),\n+        physical_type_(GetPhysicalType(chunked_array.type())),\n+        physical_chunks_(GetPhysicalChunks(chunked_array_, physical_type_)),\n+        order_(order),\n+        null_placement_(null_placement),\n+        tiebreaker_(tiebreaker),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return RankInternal<TYPE>(); }\n+\n+  VISIT_SORTABLE_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status RankInternal() {\n+    using GetView = GetViewType<InType>;\n+    using T = typename GetViewType<InType>::T;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    const auto num_chunks = chunked_array_.num_chunks();\n+    if (num_chunks == 0) {\n+      return Status::OK();\n+    }\n+    const auto arrays = GetArrayPointers(physical_chunks_);\n+\n+    ArraySortOptions array_options(order_, null_placement_);\n+\n+    ARROW_ASSIGN_OR_RAISE(auto array_sorter, GetArraySorter(*physical_type_));\n+\n+    // See related ChunkedArraySort method for comments\n\nReview Comment:\n   It would be nice indeed. Or perhaps you can even call `ChunkedArraySort` directly?\n\n\n\n",
                    "created": "2022-11-10T15:08:25.589+0000",
                    "updated": "2022-11-10T15:08:25.589+0000",
                    "started": "2022-11-10T15:08:25.589+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824961",
                    "issueId": "13447905"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447905/worklog/824962",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #14505:\nURL: https://github.com/apache/arrow/pull/14505#discussion_r1019265314\n\n\n##########\ncpp/src/arrow/compute/kernels/vector_sort.cc:\n##########\n@@ -2078,6 +2078,261 @@ class ArrayRanker : public TypeVisitor {\n   Datum* output_;\n };\n \n+class ChunkedArrayRanker : public TypeVisitor {\n+ public:\n+  // TODO: here we accept order / null_placement / tiebreaker as separate arguments\n+  // whereas the ArrayRanker accepts them as the RankOptions struct; this is consistent\n+  // with ArraySorter / ChunkedArraySorter, so likely should refactor ArrayRanker\n+  ChunkedArrayRanker(ExecContext* ctx, uint64_t* indices_begin, uint64_t* indices_end,\n+                     const ChunkedArray& chunked_array, const SortOrder order,\n+                     const NullPlacement null_placement,\n+                     const RankOptions::Tiebreaker tiebreaker, Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        indices_begin_(indices_begin),\n+        indices_end_(indices_end),\n+        chunked_array_(chunked_array),\n+        physical_type_(GetPhysicalType(chunked_array.type())),\n+        physical_chunks_(GetPhysicalChunks(chunked_array_, physical_type_)),\n+        order_(order),\n+        null_placement_(null_placement),\n+        tiebreaker_(tiebreaker),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return RankInternal<TYPE>(); }\n+\n+  VISIT_SORTABLE_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status RankInternal() {\n+    using T = typename GetViewType<InType>::T;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    const auto num_chunks = chunked_array_.num_chunks();\n+    if (num_chunks == 0) {\n+      return Status::OK();\n+    }\n+    const auto arrays = GetArrayPointers(physical_chunks_);\n+\n+    ArraySortOptions array_options(order_, null_placement_);\n+\n+    ARROW_ASSIGN_OR_RAISE(auto array_sorter, GetArraySorter(*physical_type_));\n+\n+    // See related ChunkedArraySort method for comments\n+    std::vector<NullPartitionResult> sorted(num_chunks);\n+    int64_t begin_offset = 0;\n+    int64_t end_offset = 0;\n+    int64_t null_count = 0;\n+    for (int i = 0; i < num_chunks; ++i) {\n+      const auto array = checked_cast<const ArrayType*>(arrays[i]);\n+      end_offset += array->length();\n+      null_count += array->null_count();\n+      sorted[i] = array_sorter(indices_begin_ + begin_offset, indices_begin_ + end_offset,\n+                               *array, begin_offset, array_options);\n+      begin_offset = end_offset;\n+    }\n+    DCHECK_EQ(end_offset, indices_end_ - indices_begin_);\n+\n+    auto resolver = ChunkedArrayResolver(arrays);\n+    if (sorted.size() > 1) {\n+      auto merge_nulls = [&](uint64_t* nulls_begin, uint64_t* nulls_middle,\n+                             uint64_t* nulls_end, uint64_t* temp_indices,\n+                             int64_t null_count) {\n+        if (has_null_like_values<typename ArrayType::TypeClass>::value) {\n+          PartitionNullsOnly<StablePartitioner>(nulls_begin, nulls_end, resolver,\n+                                                null_count, null_placement_);\n+        }\n+      };\n+      auto merge_non_nulls = [&](uint64_t* range_begin, uint64_t* range_middle,\n+                                 uint64_t* range_end, uint64_t* temp_indices) {\n+        MergeNonNulls<ArrayType>(range_begin, range_middle, range_end, arrays,\n+                                 temp_indices);\n+      };\n+\n+      MergeImpl merge_impl{null_placement_, std::move(merge_nulls),\n+                           std::move(merge_non_nulls)};\n+      // std::merge is only called on non-null values, so size temp indices accordingly\n+      RETURN_NOT_OK(merge_impl.Init(ctx_, indices_end_ - indices_begin_ - null_count));\n+\n+      while (sorted.size() > 1) {\n+        auto out_it = sorted.begin();\n+        auto it = sorted.begin();\n+        while (it < sorted.end() - 1) {\n+          const auto& left = *it++;\n+          const auto& right = *it++;\n+          DCHECK_EQ(left.overall_end(), right.overall_begin());\n+          const auto merged = merge_impl.Merge(left, right, null_count);\n+          *out_it++ = merged;\n+        }\n+        if (it < sorted.end()) {\n+          *out_it++ = *it++;\n+        }\n+        sorted.erase(out_it, sorted.end());\n+      }\n+    }\n+\n+    DCHECK_EQ(sorted.size(), 1);\n+    DCHECK_EQ(sorted[0].overall_begin(), indices_begin_);\n+    DCHECK_EQ(sorted[0].overall_end(), indices_end_);\n+    // Note that \"nulls\" can also include NaNs, hence the >= check\n+    DCHECK_GE(sorted[0].null_count(), null_count);\n+\n+    auto length = indices_end_ - indices_begin_;\n\nReview Comment:\n   I wonder if it's possible to share this with the contiguous array rank implementation.\r\n   IIUC the only different thing is value access. It should be doable to factor that out in a template class?\n\n\n\n",
                    "created": "2022-11-10T15:16:20.867+0000",
                    "updated": "2022-11-10T15:16:20.867+0000",
                    "started": "2022-11-10T15:16:20.867+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824962",
                    "issueId": "13447905"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447905/worklog/824963",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #14505:\nURL: https://github.com/apache/arrow/pull/14505#discussion_r1019266032\n\n\n##########\ncpp/src/arrow/compute/kernels/vector_sort_test.cc:\n##########\n@@ -2182,5 +2185,146 @@ TEST(TestRankForFixedSizeBinary, RankFixedSizeBinary) {\n       ArrayFromJSON(binary_type, R\"([\"aaa\", \"   \", \"eee\", null, \"eee\", null, \"   \"])\"));\n }\n \n+TEST(TestRankForReal, RankRealChunked) {\n+  for (auto real_type : ::arrow::FloatingPointTypes()) {\n+    for (auto null_placement : AllNullPlacements()) {\n+      for (auto tiebreaker : AllTiebreakers()) {\n+        for (auto order : AllOrders()) {\n+          AssertRankEmpty(real_type, order, null_placement, tiebreaker);\n+        }\n+\n+        AssertRankSimple(\n+            ChunkedArrayFromJSON(real_type, {\"[2.1, 3.2]\", \"[1.0, 0.0, 5.5]\"}),\n+            null_placement, tiebreaker);\n+      }\n+    }\n+    AssertRankAllTiebreakers(\n+        ChunkedArrayFromJSON(real_type, {\"[1.2, 0.0]\", \"[5.3, null, 5.3, null, 0.0]\"}));\n+  }\n+}\n+\n+TEST(TestRankForIntegral, RankIntegralChunked) {\n\nReview Comment:\n   Can you add some tests for zero chunks and/or empty chunks?\n\n\n\n",
                    "created": "2022-11-10T15:17:00.920+0000",
                    "updated": "2022-11-10T15:17:00.920+0000",
                    "started": "2022-11-10T15:17:00.919+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824963",
                    "issueId": "13447905"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447905/worklog/824968",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "WillAyd commented on code in PR #14505:\nURL: https://github.com/apache/arrow/pull/14505#discussion_r1019285497\n\n\n##########\ncpp/src/arrow/compute/kernels/vector_sort.cc:\n##########\n@@ -2078,6 +2078,293 @@ class ArrayRanker : public TypeVisitor {\n   Datum* output_;\n };\n \n+class ChunkedArrayRanker : public TypeVisitor {\n+ public:\n+  // TODO: here we accept order / null_placement / tiebreaker as separate arguments\n+  // whereas the ArrayRanker accepts them as the RankOptions struct; this is consistent\n+  // with ArraySorter / ChunkedArraySorter, so likely should refactor ArrayRanker\n+  ChunkedArrayRanker(ExecContext* ctx, uint64_t* indices_begin, uint64_t* indices_end,\n+                     const ChunkedArray& chunked_array, const SortOrder order,\n+                     const NullPlacement null_placement, const RankOptions::Tiebreaker tiebreaker, Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        indices_begin_(indices_begin),\n+        indices_end_(indices_end),\n+        chunked_array_(chunked_array),\n+        physical_type_(GetPhysicalType(chunked_array.type())),\n+        physical_chunks_(GetPhysicalChunks(chunked_array_, physical_type_)),\n+        order_(order),\n+        null_placement_(null_placement),\n+        tiebreaker_(tiebreaker),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return RankInternal<TYPE>(); }\n+\n+  VISIT_SORTABLE_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status RankInternal() {\n+    using GetView = GetViewType<InType>;\n+    using T = typename GetViewType<InType>::T;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    const auto num_chunks = chunked_array_.num_chunks();\n+    if (num_chunks == 0) {\n+      return Status::OK();\n+    }\n+    const auto arrays = GetArrayPointers(physical_chunks_);\n+\n+    ArraySortOptions array_options(order_, null_placement_);\n+\n+    ARROW_ASSIGN_OR_RAISE(auto array_sorter, GetArraySorter(*physical_type_));\n+\n+    // See related ChunkedArraySort method for comments\n\nReview Comment:\n   Yea was unsure how to best structure that. I could call ChunkedArraySort directly but then lose access to the NullPartitionResults which the ranking mechanism uses to assign ranks\n\n\n\n",
                    "created": "2022-11-10T15:33:12.246+0000",
                    "updated": "2022-11-10T15:33:12.246+0000",
                    "started": "2022-11-10T15:33:12.245+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824968",
                    "issueId": "13447905"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447905/worklog/824973",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "WillAyd commented on code in PR #14505:\nURL: https://github.com/apache/arrow/pull/14505#discussion_r1019308073\n\n\n##########\ncpp/src/arrow/compute/kernels/vector_sort.cc:\n##########\n@@ -2078,6 +2078,293 @@ class ArrayRanker : public TypeVisitor {\n   Datum* output_;\n };\n \n+class ChunkedArrayRanker : public TypeVisitor {\n+ public:\n+  // TODO: here we accept order / null_placement / tiebreaker as separate arguments\n+  // whereas the ArrayRanker accepts them as the RankOptions struct; this is consistent\n+  // with ArraySorter / ChunkedArraySorter, so likely should refactor ArrayRanker\n+  ChunkedArrayRanker(ExecContext* ctx, uint64_t* indices_begin, uint64_t* indices_end,\n+                     const ChunkedArray& chunked_array, const SortOrder order,\n+                     const NullPlacement null_placement, const RankOptions::Tiebreaker tiebreaker, Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        indices_begin_(indices_begin),\n+        indices_end_(indices_end),\n+        chunked_array_(chunked_array),\n+        physical_type_(GetPhysicalType(chunked_array.type())),\n+        physical_chunks_(GetPhysicalChunks(chunked_array_, physical_type_)),\n+        order_(order),\n+        null_placement_(null_placement),\n+        tiebreaker_(tiebreaker),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return RankInternal<TYPE>(); }\n+\n+  VISIT_SORTABLE_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status RankInternal() {\n+    using GetView = GetViewType<InType>;\n+    using T = typename GetViewType<InType>::T;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    const auto num_chunks = chunked_array_.num_chunks();\n+    if (num_chunks == 0) {\n+      return Status::OK();\n+    }\n+    const auto arrays = GetArrayPointers(physical_chunks_);\n+\n+    ArraySortOptions array_options(order_, null_placement_);\n+\n+    ARROW_ASSIGN_OR_RAISE(auto array_sorter, GetArraySorter(*physical_type_));\n+\n+    // See related ChunkedArraySort method for comments\n\nReview Comment:\n   I might try a precursor to this to refactor and make the NullPartition result easily accessible to both Sort and Rank implementations unless you disagree\n\n\n\n",
                    "created": "2022-11-10T15:46:07.839+0000",
                    "updated": "2022-11-10T15:46:07.839+0000",
                    "started": "2022-11-10T15:46:07.839+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824973",
                    "issueId": "13447905"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447905/worklog/824975",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #14505:\nURL: https://github.com/apache/arrow/pull/14505#discussion_r1019312562\n\n\n##########\ncpp/src/arrow/compute/kernels/vector_sort.cc:\n##########\n@@ -2078,6 +2078,293 @@ class ArrayRanker : public TypeVisitor {\n   Datum* output_;\n };\n \n+class ChunkedArrayRanker : public TypeVisitor {\n+ public:\n+  // TODO: here we accept order / null_placement / tiebreaker as separate arguments\n+  // whereas the ArrayRanker accepts them as the RankOptions struct; this is consistent\n+  // with ArraySorter / ChunkedArraySorter, so likely should refactor ArrayRanker\n+  ChunkedArrayRanker(ExecContext* ctx, uint64_t* indices_begin, uint64_t* indices_end,\n+                     const ChunkedArray& chunked_array, const SortOrder order,\n+                     const NullPlacement null_placement, const RankOptions::Tiebreaker tiebreaker, Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        indices_begin_(indices_begin),\n+        indices_end_(indices_end),\n+        chunked_array_(chunked_array),\n+        physical_type_(GetPhysicalType(chunked_array.type())),\n+        physical_chunks_(GetPhysicalChunks(chunked_array_, physical_type_)),\n+        order_(order),\n+        null_placement_(null_placement),\n+        tiebreaker_(tiebreaker),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return RankInternal<TYPE>(); }\n+\n+  VISIT_SORTABLE_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status RankInternal() {\n+    using GetView = GetViewType<InType>;\n+    using T = typename GetViewType<InType>::T;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    const auto num_chunks = chunked_array_.num_chunks();\n+    if (num_chunks == 0) {\n+      return Status::OK();\n+    }\n+    const auto arrays = GetArrayPointers(physical_chunks_);\n+\n+    ArraySortOptions array_options(order_, null_placement_);\n+\n+    ARROW_ASSIGN_OR_RAISE(auto array_sorter, GetArraySorter(*physical_type_));\n+\n+    // See related ChunkedArraySort method for comments\n\nReview Comment:\n   That sounds like a good idea. Perhaps an intermediate abstraction such as ArraySorter?\n\n\n\n",
                    "created": "2022-11-10T15:48:23.366+0000",
                    "updated": "2022-11-10T15:48:23.366+0000",
                    "started": "2022-11-10T15:48:23.365+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824975",
                    "issueId": "13447905"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447905/worklog/824976",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #14505:\nURL: https://github.com/apache/arrow/pull/14505#discussion_r1019313438\n\n\n##########\ncpp/src/arrow/compute/kernels/vector_sort.cc:\n##########\n@@ -2078,6 +2078,261 @@ class ArrayRanker : public TypeVisitor {\n   Datum* output_;\n };\n \n+class ChunkedArrayRanker : public TypeVisitor {\n+ public:\n+  // TODO: here we accept order / null_placement / tiebreaker as separate arguments\n+  // whereas the ArrayRanker accepts them as the RankOptions struct; this is consistent\n+  // with ArraySorter / ChunkedArraySorter, so likely should refactor ArrayRanker\n+  ChunkedArrayRanker(ExecContext* ctx, uint64_t* indices_begin, uint64_t* indices_end,\n+                     const ChunkedArray& chunked_array, const SortOrder order,\n+                     const NullPlacement null_placement,\n+                     const RankOptions::Tiebreaker tiebreaker, Datum* output)\n+      : TypeVisitor(),\n+        ctx_(ctx),\n+        indices_begin_(indices_begin),\n+        indices_end_(indices_end),\n+        chunked_array_(chunked_array),\n+        physical_type_(GetPhysicalType(chunked_array.type())),\n+        physical_chunks_(GetPhysicalChunks(chunked_array_, physical_type_)),\n+        order_(order),\n+        null_placement_(null_placement),\n+        tiebreaker_(tiebreaker),\n+        output_(output) {}\n+\n+  Status Run() { return physical_type_->Accept(this); }\n+\n+#define VISIT(TYPE) \\\n+  Status Visit(const TYPE& type) { return RankInternal<TYPE>(); }\n+\n+  VISIT_SORTABLE_PHYSICAL_TYPES(VISIT)\n+\n+#undef VISIT\n+\n+  template <typename InType>\n+  Status RankInternal() {\n+    using T = typename GetViewType<InType>::T;\n+    using ArrayType = typename TypeTraits<InType>::ArrayType;\n+\n+    const auto num_chunks = chunked_array_.num_chunks();\n+    if (num_chunks == 0) {\n+      return Status::OK();\n+    }\n+    const auto arrays = GetArrayPointers(physical_chunks_);\n+\n+    ArraySortOptions array_options(order_, null_placement_);\n+\n+    ARROW_ASSIGN_OR_RAISE(auto array_sorter, GetArraySorter(*physical_type_));\n+\n+    // See related ChunkedArraySort method for comments\n+    std::vector<NullPartitionResult> sorted(num_chunks);\n+    int64_t begin_offset = 0;\n+    int64_t end_offset = 0;\n+    int64_t null_count = 0;\n+    for (int i = 0; i < num_chunks; ++i) {\n+      const auto array = checked_cast<const ArrayType*>(arrays[i]);\n+      end_offset += array->length();\n+      null_count += array->null_count();\n+      sorted[i] = array_sorter(indices_begin_ + begin_offset, indices_begin_ + end_offset,\n+                               *array, begin_offset, array_options);\n+      begin_offset = end_offset;\n+    }\n+    DCHECK_EQ(end_offset, indices_end_ - indices_begin_);\n+\n+    auto resolver = ChunkedArrayResolver(arrays);\n+    if (sorted.size() > 1) {\n+      auto merge_nulls = [&](uint64_t* nulls_begin, uint64_t* nulls_middle,\n+                             uint64_t* nulls_end, uint64_t* temp_indices,\n+                             int64_t null_count) {\n+        if (has_null_like_values<typename ArrayType::TypeClass>::value) {\n+          PartitionNullsOnly<StablePartitioner>(nulls_begin, nulls_end, resolver,\n+                                                null_count, null_placement_);\n+        }\n+      };\n+      auto merge_non_nulls = [&](uint64_t* range_begin, uint64_t* range_middle,\n+                                 uint64_t* range_end, uint64_t* temp_indices) {\n+        MergeNonNulls<ArrayType>(range_begin, range_middle, range_end, arrays,\n+                                 temp_indices);\n+      };\n+\n+      MergeImpl merge_impl{null_placement_, std::move(merge_nulls),\n+                           std::move(merge_non_nulls)};\n+      // std::merge is only called on non-null values, so size temp indices accordingly\n+      RETURN_NOT_OK(merge_impl.Init(ctx_, indices_end_ - indices_begin_ - null_count));\n+\n+      while (sorted.size() > 1) {\n+        auto out_it = sorted.begin();\n+        auto it = sorted.begin();\n+        while (it < sorted.end() - 1) {\n+          const auto& left = *it++;\n+          const auto& right = *it++;\n+          DCHECK_EQ(left.overall_end(), right.overall_begin());\n+          const auto merged = merge_impl.Merge(left, right, null_count);\n+          *out_it++ = merged;\n+        }\n+        if (it < sorted.end()) {\n+          *out_it++ = *it++;\n+        }\n+        sorted.erase(out_it, sorted.end());\n+      }\n+    }\n+\n+    DCHECK_EQ(sorted.size(), 1);\n+    DCHECK_EQ(sorted[0].overall_begin(), indices_begin_);\n+    DCHECK_EQ(sorted[0].overall_end(), indices_end_);\n+    // Note that \"nulls\" can also include NaNs, hence the >= check\n+    DCHECK_GE(sorted[0].null_count(), null_count);\n+\n+    auto length = indices_end_ - indices_begin_;\n\nReview Comment:\n   (or a template callable arg of some kind; do note that we use C++17 now so metaprogramming becomes more comfortable :-))\n\n\n\n",
                    "created": "2022-11-10T15:48:58.022+0000",
                    "updated": "2022-11-10T15:48:58.022+0000",
                    "started": "2022-11-10T15:48:58.022+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824976",
                    "issueId": "13447905"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 8400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@2a421e85[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3a1c61c4[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5289c7ff[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@b429e2b[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@176618c7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@55f3f7cd[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@495964b3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@56750875[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@71f2825c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@3bf55e30[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@398bd901[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@474348e5[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 8400,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Oct 13 17:51:27 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": null,
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16707/watchers",
            "watchCount": 4,
            "isWatching": false
        },
        "created": "2022-06-01T11:03:18.000+0000",
        "updated": "2022-11-10T15:48:58.000+0000",
        "timeoriginalestimate": null,
        "description": "In ARROW-16234 the rank kernel was implemented for plain arrays, it should also be implemented for chunked arrays.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 8400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Implement Rank kernel on chunked arrays",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447905/comment/17544814",
                    "id": "17544814",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "cc [~willayd]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2022-06-01T11:04:01.433+0000",
                    "updated": "2022-06-01T11:04:01.433+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447905/comment/17544929",
                    "id": "17544929",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=willayd",
                        "name": "willayd",
                        "key": "willayd",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=willayd&avatarId=49036",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=willayd&avatarId=49036",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=willayd&avatarId=49036",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=willayd&avatarId=49036"
                        },
                        "displayName": "Will Ayd",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "I'll take this one",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=willayd",
                        "name": "willayd",
                        "key": "willayd",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=willayd&avatarId=49036",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=willayd&avatarId=49036",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=willayd&avatarId=49036",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=willayd&avatarId=49036"
                        },
                        "displayName": "Will Ayd",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-06-01T14:09:54.136+0000",
                    "updated": "2022-06-01T14:09:54.136+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13447905/comment/17617223",
                    "id": "17617223",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=arrowjira",
                        "name": "arrowjira",
                        "key": "arrowjira",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Apache Arrow JIRA Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "This issue was last updated over 90 days ago, which may be an indication it is no longer being actively worked. To better reflect the current state, the issue is being unassigned per [project policy|https://arrow.apache.org/docs/dev/developers/bug_reports.html#issue-assignment]. Please feel free to re-take assignment of the issue if it is being actively worked, or if you plan to start that work soon.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=arrowjira",
                        "name": "arrowjira",
                        "key": "arrowjira",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Apache Arrow JIRA Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-10-13T17:51:27.206+0000",
                    "updated": "2022-10-13T17:51:27.206+0000"
                }
            ],
            "maxResults": 3,
            "total": 3,
            "startAt": 0
        },
        "customfield_12311820": "0|z12v6o:",
        "customfield_12314139": null
    }
}