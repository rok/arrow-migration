{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13182553",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553",
    "key": "ARROW-3162",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343937",
                "id": "12343937",
                "description": "",
                "name": "0.13.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-04-01"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "flight",
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12334621",
                "id": "12334621",
                "name": "FlightRPC"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328936",
                "id": "12328936",
                "name": "Python"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 27600,
            "total": 27600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 27600,
            "total": 27600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3162/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 61,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195149",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "codecov-io commented on issue #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#issuecomment-461058004\n \n \n   # [Codecov](https://codecov.io/gh/apache/arrow/pull/3566?src=pr&el=h1) Report\n   > Merging [#3566](https://codecov.io/gh/apache/arrow/pull/3566?src=pr&el=desc) into [master](https://codecov.io/gh/apache/arrow/commit/4004b725c952187522dd77cdc3151dca664e2148?src=pr&el=desc) will **increase** coverage by `0.85%`.\n   > The diff coverage is `41.17%`.\n   \n   [![Impacted file tree graph](https://codecov.io/gh/apache/arrow/pull/3566/graphs/tree.svg?width=650&token=LpTCFbqVT1&height=150&src=pr)](https://codecov.io/gh/apache/arrow/pull/3566?src=pr&el=tree)\n   \n   ```diff\n   @@            Coverage Diff             @@\n   ##           master    #3566      +/-   ##\n   ==========================================\n   + Coverage   87.82%   88.67%   +0.85%     \n   ==========================================\n     Files         666      537     -129     \n     Lines       82371    73408    -8963     \n     Branches     1069        0    -1069     \n   ==========================================\n   - Hits        72341    65098    -7243     \n   + Misses       9919     8310    -1609     \n   + Partials      111        0     -111\n   ```\n   \n   \n   | [Impacted Files](https://codecov.io/gh/apache/arrow/pull/3566?src=pr&el=tree) | Coverage \u0394 | |\n   |---|---|---|\n   | [python/pyarrow/includes/common.pxd](https://codecov.io/gh/apache/arrow/pull/3566/diff?src=pr&el=tree#diff-cHl0aG9uL3B5YXJyb3cvaW5jbHVkZXMvY29tbW9uLnB4ZA==) | `75% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [python/pyarrow/lib.pxd](https://codecov.io/gh/apache/arrow/pull/3566/diff?src=pr&el=tree#diff-cHl0aG9uL3B5YXJyb3cvbGliLnB4ZA==) | `0% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [python/pyarrow/ipc.pxi](https://codecov.io/gh/apache/arrow/pull/3566/diff?src=pr&el=tree#diff-cHl0aG9uL3B5YXJyb3cvaXBjLnB4aQ==) | `66.15% <41.17%> (-1.39%)` | :arrow_down: |\n   | [go/arrow/math/uint64\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/3566/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWF0aC91aW50NjRfYW1kNjQuZ28=) | | |\n   | [go/arrow/memory/memory\\_avx2\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/3566/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWVtb3J5L21lbW9yeV9hdngyX2FtZDY0Lmdv) | | |\n   | [js/src/enum.ts](https://codecov.io/gh/apache/arrow/pull/3566/diff?src=pr&el=tree#diff-anMvc3JjL2VudW0udHM=) | | |\n   | [go/arrow/array/builder.go](https://codecov.io/gh/apache/arrow/pull/3566/diff?src=pr&el=tree#diff-Z28vYXJyb3cvYXJyYXkvYnVpbGRlci5nbw==) | | |\n   | [js/src/Arrow.node.ts](https://codecov.io/gh/apache/arrow/pull/3566/diff?src=pr&el=tree#diff-anMvc3JjL0Fycm93Lm5vZGUudHM=) | | |\n   | [js/src/schema.ts](https://codecov.io/gh/apache/arrow/pull/3566/diff?src=pr&el=tree#diff-anMvc3JjL3NjaGVtYS50cw==) | | |\n   | [go/arrow/type\\_traits\\_boolean.go](https://codecov.io/gh/apache/arrow/pull/3566/diff?src=pr&el=tree#diff-Z28vYXJyb3cvdHlwZV90cmFpdHNfYm9vbGVhbi5nbw==) | | |\n   | ... and [123 more](https://codecov.io/gh/apache/arrow/pull/3566/diff?src=pr&el=tree-more) | |\n   \n   ------\n   \n   [Continue to review full report at Codecov](https://codecov.io/gh/apache/arrow/pull/3566?src=pr&el=continue).\n   > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n   > `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n   > Powered by [Codecov](https://codecov.io/gh/apache/arrow/pull/3566?src=pr&el=footer). Last update [4004b72...1977c45](https://codecov.io/gh/apache/arrow/pull/3566?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-06T15:11:05.946+0000",
                    "updated": "2019-02-06T15:11:05.946+0000",
                    "started": "2019-02-06T15:11:05.945+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195149",
                    "issueId": "13182553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195734",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on issue #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#issuecomment-461489654\n \n \n   Sorry for the delay. I have a flu, but will try to review this shortly.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-07T16:10:06.670+0000",
                    "updated": "2019-02-07T16:10:06.670+0000",
                    "started": "2019-02-07T16:10:06.669+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195734",
                    "issueId": "13182553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195751",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#discussion_r254770963\n \n \n\n ##########\n File path: python/pyarrow/_flight.pyx\n ##########\n @@ -0,0 +1,454 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from cython.operator cimport dereference as deref\n+\n+from pyarrow.compat import tobytes\n+from pyarrow.lib cimport *\n+from pyarrow.includes.libarrow_flight cimport *\n+from pyarrow.ipc import _ReadPandasOption\n+import pyarrow.lib as lib\n+\n+\n+cdef class Action:\n+    \"\"\"An action executable on a Flight service.\"\"\"\n+    cdef:\n+        CAction action\n+\n+    def __init__(self, action_type, buf):\n+        self.action.type = tobytes(action_type)\n+        self.action.body = pyarrow_unwrap_buffer(buf)\n+\n+    @property\n+    def type(self):\n+        return self.action.type\n+\n+    def body(self):\n+        return pyarrow_wrap_buffer(self.action.body)\n+\n+\n+cdef class ActionType:\n+    \"\"\"A type of action executable on a Flight service.\"\"\"\n+    cdef:\n+        CActionType action_type\n+\n+    @property\n+    def type(self):\n+        return self.action_type.type\n \n Review comment:\n   `frombytes` here as well.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-07T17:05:12.500+0000",
                    "updated": "2019-02-07T17:05:12.500+0000",
                    "started": "2019-02-07T17:05:12.500+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195751",
                    "issueId": "13182553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195752",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#discussion_r254751049\n \n \n\n ##########\n File path: python/pyarrow/ipc.pxi\n ##########\n @@ -291,6 +280,25 @@ cdef class _RecordBatchReader:\n         return pyarrow_wrap_table(table)\n \n \n+cdef class _RecordBatchReader(_CRecordBatchReader):\n \n Review comment:\n   Why are you defining those two different classes `_CRecordBatchReader` and `_RecordBatchReader`?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-07T17:05:13.418+0000",
                    "updated": "2019-02-07T17:05:13.418+0000",
                    "started": "2019-02-07T17:05:13.418+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195752",
                    "issueId": "13182553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195753",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#discussion_r254752408\n \n \n\n ##########\n File path: python/pyarrow/ipc.pxi\n ##########\n @@ -222,6 +202,33 @@ cdef class _RecordBatchWriter:\n         with nogil:\n             check_status(self.writer.get().Close())\n \n+    def __enter__(self):\n+        return self\n+\n+    def __exit__(self, exc_type, exc_val, exc_tb):\n+        self.close()\n+\n+\n+cdef class _RecordBatchWriter(_CRecordBatchWriter):\n \n Review comment:\n   Why are you defining those two different classes `_CRecordBatchWriter` and `_RecordBatchWriter`?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-07T17:05:16.102+0000",
                    "updated": "2019-02-07T17:05:16.102+0000",
                    "started": "2019-02-07T17:05:16.101+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195753",
                    "issueId": "13182553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195754",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#discussion_r254772856\n \n \n\n ##########\n File path: python/pyarrow/_flight.pyx\n ##########\n @@ -0,0 +1,454 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from cython.operator cimport dereference as deref\n+\n+from pyarrow.compat import tobytes\n+from pyarrow.lib cimport *\n+from pyarrow.includes.libarrow_flight cimport *\n+from pyarrow.ipc import _ReadPandasOption\n+import pyarrow.lib as lib\n+\n+\n+cdef class Action:\n+    \"\"\"An action executable on a Flight service.\"\"\"\n+    cdef:\n+        CAction action\n+\n+    def __init__(self, action_type, buf):\n+        self.action.type = tobytes(action_type)\n+        self.action.body = pyarrow_unwrap_buffer(buf)\n+\n+    @property\n+    def type(self):\n+        return self.action.type\n+\n+    def body(self):\n+        return pyarrow_wrap_buffer(self.action.body)\n+\n+\n+cdef class ActionType:\n+    \"\"\"A type of action executable on a Flight service.\"\"\"\n+    cdef:\n+        CActionType action_type\n+\n+    @property\n+    def type(self):\n+        return self.action_type.type\n+\n+    @property\n+    def description(self):\n+        return self.action_type.description\n+\n+    def make_action(self, buf):\n+        \"\"\"Create an Action with this type.\"\"\"\n+        return Action(self.type, buf)\n+\n+    def __repr__(self):\n+        return '<ActionType type={} description={}>'.format(\n+            self.type, self.description)\n+\n+\n+cdef class Result:\n+    \"\"\"A result from executing an Action.\"\"\"\n+    cdef:\n+        unique_ptr[CResult] result\n+\n+    def body(self):\n \n Review comment:\n   Why not make this a property?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-07T17:05:17.301+0000",
                    "updated": "2019-02-07T17:05:17.301+0000",
                    "started": "2019-02-07T17:05:17.296+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195754",
                    "issueId": "13182553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195755",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#discussion_r254759883\n \n \n\n ##########\n File path: python/pyarrow/_flight.pyx\n ##########\n @@ -0,0 +1,454 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from cython.operator cimport dereference as deref\n+\n+from pyarrow.compat import tobytes\n+from pyarrow.lib cimport *\n+from pyarrow.includes.libarrow_flight cimport *\n+from pyarrow.ipc import _ReadPandasOption\n+import pyarrow.lib as lib\n+\n+\n+cdef class Action:\n+    \"\"\"An action executable on a Flight service.\"\"\"\n+    cdef:\n+        CAction action\n+\n+    def __init__(self, action_type, buf):\n+        self.action.type = tobytes(action_type)\n+        self.action.body = pyarrow_unwrap_buffer(buf)\n+\n+    @property\n+    def type(self):\n+        return self.action.type\n+\n+    def body(self):\n+        return pyarrow_wrap_buffer(self.action.body)\n+\n+\n+cdef class ActionType:\n+    \"\"\"A type of action executable on a Flight service.\"\"\"\n+    cdef:\n+        CActionType action_type\n+\n+    @property\n+    def type(self):\n+        return self.action_type.type\n+\n+    @property\n+    def description(self):\n+        return self.action_type.description\n+\n+    def make_action(self, buf):\n+        \"\"\"Create an Action with this type.\"\"\"\n+        return Action(self.type, buf)\n+\n+    def __repr__(self):\n+        return '<ActionType type={} description={}>'.format(\n+            self.type, self.description)\n+\n+\n+cdef class Result:\n+    \"\"\"A result from executing an Action.\"\"\"\n+    cdef:\n+        unique_ptr[CResult] result\n+\n+    def body(self):\n+        \"\"\"Get the Buffer containing the result.\"\"\"\n+        return pyarrow_wrap_buffer(self.result.get().body)\n+\n+\n+cdef class FlightDescriptor:\n+    \"\"\"A description of a data stream available from a Flight service.\"\"\"\n+    cdef:\n+        CFlightDescriptor descriptor\n+\n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"`pyarrow.flight.FlightDescriptor.for_{path,command}` \"\n+                        \"function instead.\"\n+                        .format(self.__class__.__name__))\n+\n+    @staticmethod\n+    def for_path(*path):\n+        \"\"\"Create a FlightDescriptor for a resource path.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor.type = DescriptorTypePath\n+        result.descriptor.path = [tobytes(p) for p in path]\n+        return result\n+\n+    @staticmethod\n+    def for_command(command):\n+        \"\"\"Create a FlightDescriptor for an opaque command.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor.type = DescriptorTypePath\n+        result.descriptor.cmd = tobytes(command)\n+        return result\n+\n+    def descriptor_type(self):\n+        # TODO: create a real enum? (wouldn't work in Python < 3.4\n+        # without additional dependency)\n+        if self.descriptor.type == DescriptorTypeUnknown:\n+            return \"unknown\"\n+        elif self.descriptor.type == DescriptorTypePath:\n+            return \"path\"\n+        elif self.descriptor.type == DescriptorTypeCmd:\n+            return \"command\"\n+        raise RuntimeError(\"Invalid descriptor type!\")\n+\n+    def command(self):\n+        \"\"\"Get the command for this descriptor.\"\"\"\n+        if self.descriptor_type() != \"command\":\n+            # TODO: raise exception instead?\n+            return None\n+        return self.descriptor.cmd\n+\n+    def path(self):\n+        \"\"\"Get the path for this descriptor.\"\"\"\n+        if self.descriptor_type() != \"path\":\n+            return None\n+        return self.descriptor.path\n+\n+    def __repr__(self):\n+        return \"<FlightDescriptor type: {!r}>\".format(self.descriptor_type())\n+\n+\n+class Ticket:\n+    \"\"\"A ticket for requesting a Flight stream.\"\"\"\n+    def __init__(self, ticket):\n+        self.ticket = ticket\n+\n+\n+class Location:\n+    \"\"\"A location where a Flight stream is available.\"\"\"\n+    def __init__(self, host, port):\n+        self.host = host\n+        self.port = port\n+\n+    def __repr__(self):\n+        return '<Location host={} port={}>'.format(self.host, self.port)\n+\n+\n+cdef class FlightEndpoint:\n+    \"\"\"A Flight stream, along with the ticket and locations to access it.\"\"\"\n+    cdef:\n+        CFlightEndpoint endpoint\n+\n+    @staticmethod\n+    def create(ticket, locations):\n+        cdef:\n+            CFlightEndpoint c_endpoint = CFlightEndpoint()\n+            CLocation c_location = CLocation()\n+\n+        if isinstance(ticket, Ticket):\n+            c_endpoint.ticket.ticket = ticket.ticket\n+        else:\n+            c_endpoint.ticket.ticket = ticket\n+\n+        for location in locations:\n+            c_location.host = location.host\n+            c_location.port = location.port\n+            c_endpoint.locations.push_back(c_location)\n+\n+        result = FlightEndpoint()\n+        result.endpoint = c_endpoint\n+        return result\n+\n+    def ticket(self):\n+        return Ticket(self.endpoint.ticket.ticket)\n+\n+    def locations(self):\n+        return [Location(location.host, location.port)\n+                for location in self.endpoint.locations]\n+\n+\n+cdef class FlightInfo:\n+    \"\"\"A description of a Flight stream.\"\"\"\n+    cdef:\n+        unique_ptr[CFlightInfo] info\n+\n+    @staticmethod\n+    def create(Schema schema, FlightDescriptor descriptor, endpoints,\n+               total_records, total_bytes):\n+        cdef:\n+            FlightInfo result = FlightInfo()\n+            shared_ptr[CSchema] c_schema = pyarrow_unwrap_schema(schema)\n+            vector[CFlightEndpoint] c_endpoints\n+\n+        for endpoint in endpoints:\n+            if isinstance(endpoint, FlightEndpoint):\n+                c_endpoints.push_back((<FlightEndpoint> endpoint).endpoint)\n+            else:\n+                raise TypeError('Endpoint {} is not instance of'\n+                                ' FlightEndpoint'.format(endpoint))\n+\n+        check_status(CreateFlightInfo(c_schema,\n+                                      descriptor.descriptor,\n+                                      c_endpoints,\n+                                      total_records,\n+                                      total_bytes, &result.info))\n+        return result\n+\n+    @property\n+    def total_records(self):\n+        \"\"\"The total record count of this flight, or -1 if unknown.\"\"\"\n+        return self.info.get().total_records()\n+\n+    @property\n+    def total_bytes(self):\n+        \"\"\"The size in bytes of the data in this flight, or -1 if unknown.\"\"\"\n+        return self.info.get().total_bytes()\n+\n+    def schema(self):\n+        \"\"\"The schema of the data in this flight.\"\"\"\n+        cdef:\n+            shared_ptr[CSchema] schema\n+        check_status(self.info.get().GetSchema(&schema))\n+        return pyarrow_wrap_schema(schema)\n+\n+    def descriptor(self):\n+        \"\"\"The descriptor of the data in this flight.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor = self.info.get().descriptor()\n+        return result\n+\n+    def endpoints(self):\n+        \"\"\"The endpoints where this flight is available.\"\"\"\n+        # TODO: get Cython to iterate over reference directly\n+        cdef:\n+            vector[CFlightEndpoint] endpoints = self.info.get().endpoints()\n+\n+        result = []\n+        for endpoint in endpoints:\n+            py_endpoint = FlightEndpoint()\n+            py_endpoint.endpoint = endpoint\n+            result.append(py_endpoint)\n+        return result\n+\n+\n+cdef class FlightRecordBatchReader(_CRecordBatchReader, _ReadPandasOption):\n+    cdef dict __dict__\n+\n+\n+cdef class FlightRecordBatchWriter(_CRecordBatchWriter):\n+    pass\n+\n+\n+cdef class FlightClient:\n+    \"\"\"A client to a Flight service.\"\"\"\n+    cdef:\n+        unique_ptr[CFlightClient] client\n+\n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"`pyarrow.flight.FlightClient.connect` instead.\"\n+                        .format(self.__class__.__name__))\n+\n+    @staticmethod\n+    def connect(host, port):\n+        \"\"\"Connect to a Flight service on the given host and port.\"\"\"\n+        cdef:\n+            FlightClient result = FlightClient.__new__(FlightClient)\n+            int c_port = port\n+            c_string c_host = tobytes(host)\n+\n+        with nogil:\n+            check_status(CFlightClient.Connect(c_host, c_port, &result.client))\n+\n+        return result\n+\n+    def list_actions(self):\n+        \"\"\"List the actions available on a service.\"\"\"\n+        cdef:\n+            vector[CActionType] results\n+\n+        with nogil:\n+            check_status(self.client.get().ListActions(&results))\n+\n+        result = []\n+        for action_type in results:\n+            py_action = ActionType()\n+            py_action.action_type = action_type\n+            result.append(py_action)\n+\n+        return result\n+\n+    def do_action(self, action: Action):\n+        \"\"\"Execute an action on a service.\"\"\"\n+        cdef:\n+            unique_ptr[CResultStream] results\n+        with nogil:\n+            check_status(self.client.get().DoAction(action.action, &results))\n+\n+        while True:\n+            result = Result()\n+            with nogil:\n+                check_status(results.get().Next(&result.result))\n+                if result.result == NULL:\n+                    break\n+            yield result\n+\n+    def list_flights(self):\n+        \"\"\"List the flights available on a service.\"\"\"\n+        cdef:\n+            unique_ptr[CFlightListing] listing\n+\n+        with nogil:\n+            check_status(self.client.get().ListFlights(&listing))\n+\n+        while True:\n+            result = FlightInfo()\n+            check_status(listing.get().Next(&result.info))\n+            if result.info == NULL:\n+                break\n+            yield result\n+\n+    def get_flight_info(self, descriptor: FlightDescriptor):\n+        \"\"\"Request information about an available flight.\"\"\"\n+        result = FlightInfo()\n+\n+        with nogil:\n+            check_status(self.client.get().GetFlightInfo(\n+                descriptor.descriptor, &result.info))\n+\n+        return result\n+\n+    def do_get(self, ticket: Ticket, schema: Schema):\n+        \"\"\"Request the data for a flight.\"\"\"\n+        cdef:\n+            # TODO: introduce unwrap\n+            CTicket c_ticket\n+            shared_ptr[CSchema] c_schema = pyarrow_unwrap_schema(schema)\n+            unique_ptr[CRecordBatchReader] reader\n+\n+        c_ticket.ticket = ticket.ticket\n+        check_status(self.client.get().DoGet(c_ticket, c_schema, &reader))\n+        result = FlightRecordBatchReader()\n+        result.reader.reset(reader.release())\n+        return result\n+\n+    def do_put(self, descriptor: FlightDescriptor, schema: Schema):\n+        \"\"\"Upload data to a flight.\"\"\"\n+        cdef:\n+            shared_ptr[CSchema] c_schema = pyarrow_unwrap_schema(schema)\n+            unique_ptr[CRecordBatchWriter] writer\n+\n+        check_status(self.client.get().DoPut(\n+            descriptor.descriptor, c_schema, &writer))\n+        result = FlightRecordBatchWriter()\n+        result.writer.reset(writer.release())\n+        return result\n+\n+\n+cdef class FlightDataStream:\n+    cdef:\n+        unique_ptr[CFlightDataStream] stream\n+\n+\n+cdef class RecordBatchStream(FlightDataStream):\n+    def __init__(self, reader):\n+        # TODO: we don't really expose the readers in Python.\n+        # self.stream.reset(None)\n+        pass\n+\n+\n+cdef CStatus _get_flight_info(void* self, CFlightDescriptor c_descriptor,\n+                              unique_ptr[CFlightInfo]* info):\n+    \"\"\"Callback for implementing Flight servers in Python.\"\"\"\n+    cdef FlightDescriptor descriptor = \\\n+        FlightDescriptor.__new__(FlightDescriptor)\n+    try:\n+        descriptor.descriptor = c_descriptor\n+        result = (<object> self).get_flight_info(descriptor)\n+        print(result)\n+        if not result:\n+            info.reset(NULL)\n+            # TODO:\n+        else:\n+            # TODO:\n+            pass\n+        return CStatus_OK()\n+    except NotImplemented as err:\n+        return CStatus_NotImplemented(repr(err).encode('utf-8'))\n \n Review comment:\n   Instead of doing this, check the Python error state on the C++ side using `arrow::py::CheckPyError()`.\r\n   (and in the Python side callbacks, just return `void`)\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-07T17:05:17.939+0000",
                    "updated": "2019-02-07T17:05:17.939+0000",
                    "started": "2019-02-07T17:05:17.939+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195755",
                    "issueId": "13182553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195756",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#discussion_r254760437\n \n \n\n ##########\n File path: python/pyarrow/_flight.pyx\n ##########\n @@ -0,0 +1,454 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from cython.operator cimport dereference as deref\n+\n+from pyarrow.compat import tobytes\n+from pyarrow.lib cimport *\n+from pyarrow.includes.libarrow_flight cimport *\n+from pyarrow.ipc import _ReadPandasOption\n+import pyarrow.lib as lib\n+\n+\n+cdef class Action:\n+    \"\"\"An action executable on a Flight service.\"\"\"\n+    cdef:\n+        CAction action\n+\n+    def __init__(self, action_type, buf):\n+        self.action.type = tobytes(action_type)\n+        self.action.body = pyarrow_unwrap_buffer(buf)\n+\n+    @property\n+    def type(self):\n+        return self.action.type\n+\n+    def body(self):\n+        return pyarrow_wrap_buffer(self.action.body)\n+\n+\n+cdef class ActionType:\n+    \"\"\"A type of action executable on a Flight service.\"\"\"\n+    cdef:\n+        CActionType action_type\n+\n+    @property\n+    def type(self):\n+        return self.action_type.type\n+\n+    @property\n+    def description(self):\n+        return self.action_type.description\n+\n+    def make_action(self, buf):\n+        \"\"\"Create an Action with this type.\"\"\"\n+        return Action(self.type, buf)\n+\n+    def __repr__(self):\n+        return '<ActionType type={} description={}>'.format(\n+            self.type, self.description)\n+\n+\n+cdef class Result:\n+    \"\"\"A result from executing an Action.\"\"\"\n+    cdef:\n+        unique_ptr[CResult] result\n+\n+    def body(self):\n+        \"\"\"Get the Buffer containing the result.\"\"\"\n+        return pyarrow_wrap_buffer(self.result.get().body)\n+\n+\n+cdef class FlightDescriptor:\n+    \"\"\"A description of a data stream available from a Flight service.\"\"\"\n+    cdef:\n+        CFlightDescriptor descriptor\n+\n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"`pyarrow.flight.FlightDescriptor.for_{path,command}` \"\n+                        \"function instead.\"\n+                        .format(self.__class__.__name__))\n+\n+    @staticmethod\n+    def for_path(*path):\n+        \"\"\"Create a FlightDescriptor for a resource path.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor.type = DescriptorTypePath\n+        result.descriptor.path = [tobytes(p) for p in path]\n+        return result\n+\n+    @staticmethod\n+    def for_command(command):\n+        \"\"\"Create a FlightDescriptor for an opaque command.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor.type = DescriptorTypePath\n+        result.descriptor.cmd = tobytes(command)\n+        return result\n+\n+    def descriptor_type(self):\n+        # TODO: create a real enum? (wouldn't work in Python < 3.4\n+        # without additional dependency)\n+        if self.descriptor.type == DescriptorTypeUnknown:\n+            return \"unknown\"\n+        elif self.descriptor.type == DescriptorTypePath:\n+            return \"path\"\n+        elif self.descriptor.type == DescriptorTypeCmd:\n+            return \"command\"\n+        raise RuntimeError(\"Invalid descriptor type!\")\n+\n+    def command(self):\n+        \"\"\"Get the command for this descriptor.\"\"\"\n+        if self.descriptor_type() != \"command\":\n+            # TODO: raise exception instead?\n+            return None\n+        return self.descriptor.cmd\n+\n+    def path(self):\n+        \"\"\"Get the path for this descriptor.\"\"\"\n+        if self.descriptor_type() != \"path\":\n+            return None\n+        return self.descriptor.path\n+\n+    def __repr__(self):\n+        return \"<FlightDescriptor type: {!r}>\".format(self.descriptor_type())\n+\n+\n+class Ticket:\n+    \"\"\"A ticket for requesting a Flight stream.\"\"\"\n+    def __init__(self, ticket):\n+        self.ticket = ticket\n+\n+\n+class Location:\n+    \"\"\"A location where a Flight stream is available.\"\"\"\n+    def __init__(self, host, port):\n+        self.host = host\n+        self.port = port\n+\n+    def __repr__(self):\n+        return '<Location host={} port={}>'.format(self.host, self.port)\n+\n+\n+cdef class FlightEndpoint:\n+    \"\"\"A Flight stream, along with the ticket and locations to access it.\"\"\"\n+    cdef:\n+        CFlightEndpoint endpoint\n+\n+    @staticmethod\n+    def create(ticket, locations):\n+        cdef:\n+            CFlightEndpoint c_endpoint = CFlightEndpoint()\n+            CLocation c_location = CLocation()\n+\n+        if isinstance(ticket, Ticket):\n+            c_endpoint.ticket.ticket = ticket.ticket\n+        else:\n+            c_endpoint.ticket.ticket = ticket\n+\n+        for location in locations:\n+            c_location.host = location.host\n+            c_location.port = location.port\n+            c_endpoint.locations.push_back(c_location)\n+\n+        result = FlightEndpoint()\n+        result.endpoint = c_endpoint\n+        return result\n+\n+    def ticket(self):\n+        return Ticket(self.endpoint.ticket.ticket)\n+\n+    def locations(self):\n+        return [Location(location.host, location.port)\n+                for location in self.endpoint.locations]\n+\n+\n+cdef class FlightInfo:\n+    \"\"\"A description of a Flight stream.\"\"\"\n+    cdef:\n+        unique_ptr[CFlightInfo] info\n+\n+    @staticmethod\n+    def create(Schema schema, FlightDescriptor descriptor, endpoints,\n+               total_records, total_bytes):\n+        cdef:\n+            FlightInfo result = FlightInfo()\n+            shared_ptr[CSchema] c_schema = pyarrow_unwrap_schema(schema)\n+            vector[CFlightEndpoint] c_endpoints\n+\n+        for endpoint in endpoints:\n+            if isinstance(endpoint, FlightEndpoint):\n+                c_endpoints.push_back((<FlightEndpoint> endpoint).endpoint)\n+            else:\n+                raise TypeError('Endpoint {} is not instance of'\n+                                ' FlightEndpoint'.format(endpoint))\n+\n+        check_status(CreateFlightInfo(c_schema,\n+                                      descriptor.descriptor,\n+                                      c_endpoints,\n+                                      total_records,\n+                                      total_bytes, &result.info))\n+        return result\n+\n+    @property\n+    def total_records(self):\n+        \"\"\"The total record count of this flight, or -1 if unknown.\"\"\"\n+        return self.info.get().total_records()\n+\n+    @property\n+    def total_bytes(self):\n+        \"\"\"The size in bytes of the data in this flight, or -1 if unknown.\"\"\"\n+        return self.info.get().total_bytes()\n+\n+    def schema(self):\n+        \"\"\"The schema of the data in this flight.\"\"\"\n+        cdef:\n+            shared_ptr[CSchema] schema\n+        check_status(self.info.get().GetSchema(&schema))\n+        return pyarrow_wrap_schema(schema)\n+\n+    def descriptor(self):\n+        \"\"\"The descriptor of the data in this flight.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor = self.info.get().descriptor()\n+        return result\n+\n+    def endpoints(self):\n+        \"\"\"The endpoints where this flight is available.\"\"\"\n+        # TODO: get Cython to iterate over reference directly\n+        cdef:\n+            vector[CFlightEndpoint] endpoints = self.info.get().endpoints()\n+\n+        result = []\n+        for endpoint in endpoints:\n+            py_endpoint = FlightEndpoint()\n+            py_endpoint.endpoint = endpoint\n+            result.append(py_endpoint)\n+        return result\n+\n+\n+cdef class FlightRecordBatchReader(_CRecordBatchReader, _ReadPandasOption):\n+    cdef dict __dict__\n+\n+\n+cdef class FlightRecordBatchWriter(_CRecordBatchWriter):\n+    pass\n+\n+\n+cdef class FlightClient:\n+    \"\"\"A client to a Flight service.\"\"\"\n+    cdef:\n+        unique_ptr[CFlightClient] client\n+\n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"`pyarrow.flight.FlightClient.connect` instead.\"\n+                        .format(self.__class__.__name__))\n+\n+    @staticmethod\n+    def connect(host, port):\n+        \"\"\"Connect to a Flight service on the given host and port.\"\"\"\n+        cdef:\n+            FlightClient result = FlightClient.__new__(FlightClient)\n+            int c_port = port\n+            c_string c_host = tobytes(host)\n+\n+        with nogil:\n+            check_status(CFlightClient.Connect(c_host, c_port, &result.client))\n+\n+        return result\n+\n+    def list_actions(self):\n+        \"\"\"List the actions available on a service.\"\"\"\n+        cdef:\n+            vector[CActionType] results\n+\n+        with nogil:\n+            check_status(self.client.get().ListActions(&results))\n+\n+        result = []\n+        for action_type in results:\n+            py_action = ActionType()\n+            py_action.action_type = action_type\n+            result.append(py_action)\n+\n+        return result\n+\n+    def do_action(self, action: Action):\n+        \"\"\"Execute an action on a service.\"\"\"\n+        cdef:\n+            unique_ptr[CResultStream] results\n+        with nogil:\n+            check_status(self.client.get().DoAction(action.action, &results))\n+\n+        while True:\n+            result = Result()\n+            with nogil:\n+                check_status(results.get().Next(&result.result))\n+                if result.result == NULL:\n+                    break\n+            yield result\n+\n+    def list_flights(self):\n+        \"\"\"List the flights available on a service.\"\"\"\n+        cdef:\n+            unique_ptr[CFlightListing] listing\n+\n+        with nogil:\n+            check_status(self.client.get().ListFlights(&listing))\n+\n+        while True:\n+            result = FlightInfo()\n+            check_status(listing.get().Next(&result.info))\n+            if result.info == NULL:\n+                break\n+            yield result\n+\n+    def get_flight_info(self, descriptor: FlightDescriptor):\n+        \"\"\"Request information about an available flight.\"\"\"\n+        result = FlightInfo()\n+\n+        with nogil:\n+            check_status(self.client.get().GetFlightInfo(\n+                descriptor.descriptor, &result.info))\n+\n+        return result\n+\n+    def do_get(self, ticket: Ticket, schema: Schema):\n+        \"\"\"Request the data for a flight.\"\"\"\n+        cdef:\n+            # TODO: introduce unwrap\n+            CTicket c_ticket\n+            shared_ptr[CSchema] c_schema = pyarrow_unwrap_schema(schema)\n+            unique_ptr[CRecordBatchReader] reader\n+\n+        c_ticket.ticket = ticket.ticket\n+        check_status(self.client.get().DoGet(c_ticket, c_schema, &reader))\n+        result = FlightRecordBatchReader()\n+        result.reader.reset(reader.release())\n+        return result\n+\n+    def do_put(self, descriptor: FlightDescriptor, schema: Schema):\n+        \"\"\"Upload data to a flight.\"\"\"\n+        cdef:\n+            shared_ptr[CSchema] c_schema = pyarrow_unwrap_schema(schema)\n+            unique_ptr[CRecordBatchWriter] writer\n+\n+        check_status(self.client.get().DoPut(\n+            descriptor.descriptor, c_schema, &writer))\n+        result = FlightRecordBatchWriter()\n+        result.writer.reset(writer.release())\n+        return result\n+\n+\n+cdef class FlightDataStream:\n+    cdef:\n+        unique_ptr[CFlightDataStream] stream\n+\n+\n+cdef class RecordBatchStream(FlightDataStream):\n+    def __init__(self, reader):\n+        # TODO: we don't really expose the readers in Python.\n+        # self.stream.reset(None)\n+        pass\n+\n+\n+cdef CStatus _get_flight_info(void* self, CFlightDescriptor c_descriptor,\n+                              unique_ptr[CFlightInfo]* info):\n+    \"\"\"Callback for implementing Flight servers in Python.\"\"\"\n+    cdef FlightDescriptor descriptor = \\\n+        FlightDescriptor.__new__(FlightDescriptor)\n+    try:\n+        descriptor.descriptor = c_descriptor\n+        result = (<object> self).get_flight_info(descriptor)\n+        print(result)\n+        if not result:\n+            info.reset(NULL)\n+            # TODO:\n+        else:\n+            # TODO:\n+            pass\n+        return CStatus_OK()\n+    except NotImplemented as err:\n+        return CStatus_NotImplemented(repr(err).encode('utf-8'))\n+    except Exception as err:\n+        return CStatus_UnknownError(repr(err).encode('utf-8'))\n+    # TODO: KeyError\n+\n+\n+cdef CStatus _do_put(void* self, unique_ptr[CFlightMessageReader] reader):\n+    \"\"\"Callback for implementing Flight servers in Python.\"\"\"\n+    cdef:\n+        FlightRecordBatchReader py_reader = FlightRecordBatchReader()\n+        FlightDescriptor descriptor = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+\n+    descriptor.descriptor = reader.get().descriptor()\n+    py_reader.reader.reset(reader.release())\n+    try:\n+        result = (<object> self).do_put(descriptor, py_reader)\n+        return CStatus_OK()\n+    except Exception as err:\n+        print(err)\n+        return CStatus_UnknownError(repr(err).encode('utf-8'))\n+\n+\n+cdef CStatus _do_get(void* self, CTicket ticket,\n+                     unique_ptr[CFlightDataStream]* stream):\n+    \"\"\"Callback for implementing Flight servers in Python.\"\"\"\n+    py_ticket = Ticket()\n+    py_ticket.ticket = ticket.ticket\n+    try:\n+        result = (<object> self).do_get(py_ticket)\n+        if not isinstance(result, FlightDataStream):\n+            raise TypeError(\"FlightServerBase.do_get must return \"\n+                            \"a FlightDataStream\")\n+        stream[0] = move((<FlightDataStream> result).stream)\n+        return CStatus_OK()\n+    except Exception as err:\n+        print(err)\n+        return CStatus_UnknownError(repr(err).encode('utf-8'))\n+\n+\n+cdef class FlightServerBase:\n+    \"\"\"A Flight service definition.\"\"\"\n+\n+    cdef:\n+        unique_ptr[PyFlightServer] server\n+\n+    def run(self, port):\n+        # TODO: share one vtable between instances\n \n Review comment:\n   I don't think that's useful. It's just a thin struct.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-07T17:05:17.944+0000",
                    "updated": "2019-02-07T17:05:17.944+0000",
                    "started": "2019-02-07T17:05:17.943+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195756",
                    "issueId": "13182553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195757",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#discussion_r254772927\n \n \n\n ##########\n File path: python/pyarrow/_flight.pyx\n ##########\n @@ -0,0 +1,454 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from cython.operator cimport dereference as deref\n+\n+from pyarrow.compat import tobytes\n+from pyarrow.lib cimport *\n+from pyarrow.includes.libarrow_flight cimport *\n+from pyarrow.ipc import _ReadPandasOption\n+import pyarrow.lib as lib\n+\n+\n+cdef class Action:\n+    \"\"\"An action executable on a Flight service.\"\"\"\n+    cdef:\n+        CAction action\n+\n+    def __init__(self, action_type, buf):\n+        self.action.type = tobytes(action_type)\n+        self.action.body = pyarrow_unwrap_buffer(buf)\n+\n+    @property\n+    def type(self):\n+        return self.action.type\n+\n+    def body(self):\n+        return pyarrow_wrap_buffer(self.action.body)\n+\n+\n+cdef class ActionType:\n+    \"\"\"A type of action executable on a Flight service.\"\"\"\n+    cdef:\n+        CActionType action_type\n+\n+    @property\n+    def type(self):\n+        return self.action_type.type\n+\n+    @property\n+    def description(self):\n+        return self.action_type.description\n+\n+    def make_action(self, buf):\n+        \"\"\"Create an Action with this type.\"\"\"\n+        return Action(self.type, buf)\n+\n+    def __repr__(self):\n+        return '<ActionType type={} description={}>'.format(\n+            self.type, self.description)\n+\n+\n+cdef class Result:\n+    \"\"\"A result from executing an Action.\"\"\"\n+    cdef:\n+        unique_ptr[CResult] result\n+\n+    def body(self):\n+        \"\"\"Get the Buffer containing the result.\"\"\"\n+        return pyarrow_wrap_buffer(self.result.get().body)\n+\n+\n+cdef class FlightDescriptor:\n+    \"\"\"A description of a data stream available from a Flight service.\"\"\"\n+    cdef:\n+        CFlightDescriptor descriptor\n+\n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"`pyarrow.flight.FlightDescriptor.for_{path,command}` \"\n+                        \"function instead.\"\n+                        .format(self.__class__.__name__))\n+\n+    @staticmethod\n+    def for_path(*path):\n+        \"\"\"Create a FlightDescriptor for a resource path.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor.type = DescriptorTypePath\n+        result.descriptor.path = [tobytes(p) for p in path]\n+        return result\n+\n+    @staticmethod\n+    def for_command(command):\n+        \"\"\"Create a FlightDescriptor for an opaque command.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor.type = DescriptorTypePath\n+        result.descriptor.cmd = tobytes(command)\n+        return result\n+\n+    def descriptor_type(self):\n \n Review comment:\n   Perhaps a property as well?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-07T17:05:17.950+0000",
                    "updated": "2019-02-07T17:05:17.950+0000",
                    "started": "2019-02-07T17:05:17.949+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195757",
                    "issueId": "13182553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195758",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#discussion_r254780300\n \n \n\n ##########\n File path: python/pyarrow/_flight.pyx\n ##########\n @@ -0,0 +1,454 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from cython.operator cimport dereference as deref\n+\n+from pyarrow.compat import tobytes\n+from pyarrow.lib cimport *\n+from pyarrow.includes.libarrow_flight cimport *\n+from pyarrow.ipc import _ReadPandasOption\n+import pyarrow.lib as lib\n+\n+\n+cdef class Action:\n+    \"\"\"An action executable on a Flight service.\"\"\"\n+    cdef:\n+        CAction action\n+\n+    def __init__(self, action_type, buf):\n+        self.action.type = tobytes(action_type)\n+        self.action.body = pyarrow_unwrap_buffer(buf)\n+\n+    @property\n+    def type(self):\n+        return self.action.type\n+\n+    def body(self):\n+        return pyarrow_wrap_buffer(self.action.body)\n+\n+\n+cdef class ActionType:\n+    \"\"\"A type of action executable on a Flight service.\"\"\"\n+    cdef:\n+        CActionType action_type\n+\n+    @property\n+    def type(self):\n+        return self.action_type.type\n+\n+    @property\n+    def description(self):\n+        return self.action_type.description\n+\n+    def make_action(self, buf):\n+        \"\"\"Create an Action with this type.\"\"\"\n+        return Action(self.type, buf)\n+\n+    def __repr__(self):\n+        return '<ActionType type={} description={}>'.format(\n+            self.type, self.description)\n+\n+\n+cdef class Result:\n+    \"\"\"A result from executing an Action.\"\"\"\n+    cdef:\n+        unique_ptr[CResult] result\n+\n+    def body(self):\n+        \"\"\"Get the Buffer containing the result.\"\"\"\n+        return pyarrow_wrap_buffer(self.result.get().body)\n+\n+\n+cdef class FlightDescriptor:\n+    \"\"\"A description of a data stream available from a Flight service.\"\"\"\n+    cdef:\n+        CFlightDescriptor descriptor\n+\n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"`pyarrow.flight.FlightDescriptor.for_{path,command}` \"\n+                        \"function instead.\"\n+                        .format(self.__class__.__name__))\n+\n+    @staticmethod\n+    def for_path(*path):\n+        \"\"\"Create a FlightDescriptor for a resource path.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor.type = DescriptorTypePath\n+        result.descriptor.path = [tobytes(p) for p in path]\n+        return result\n+\n+    @staticmethod\n+    def for_command(command):\n+        \"\"\"Create a FlightDescriptor for an opaque command.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor.type = DescriptorTypePath\n+        result.descriptor.cmd = tobytes(command)\n+        return result\n+\n+    def descriptor_type(self):\n+        # TODO: create a real enum? (wouldn't work in Python < 3.4\n+        # without additional dependency)\n+        if self.descriptor.type == DescriptorTypeUnknown:\n+            return \"unknown\"\n+        elif self.descriptor.type == DescriptorTypePath:\n+            return \"path\"\n+        elif self.descriptor.type == DescriptorTypeCmd:\n+            return \"command\"\n+        raise RuntimeError(\"Invalid descriptor type!\")\n+\n+    def command(self):\n+        \"\"\"Get the command for this descriptor.\"\"\"\n+        if self.descriptor_type() != \"command\":\n+            # TODO: raise exception instead?\n+            return None\n+        return self.descriptor.cmd\n+\n+    def path(self):\n+        \"\"\"Get the path for this descriptor.\"\"\"\n+        if self.descriptor_type() != \"path\":\n+            return None\n+        return self.descriptor.path\n+\n+    def __repr__(self):\n+        return \"<FlightDescriptor type: {!r}>\".format(self.descriptor_type())\n+\n+\n+class Ticket:\n+    \"\"\"A ticket for requesting a Flight stream.\"\"\"\n+    def __init__(self, ticket):\n+        self.ticket = ticket\n+\n+\n+class Location:\n+    \"\"\"A location where a Flight stream is available.\"\"\"\n+    def __init__(self, host, port):\n+        self.host = host\n+        self.port = port\n+\n+    def __repr__(self):\n+        return '<Location host={} port={}>'.format(self.host, self.port)\n+\n+\n+cdef class FlightEndpoint:\n+    \"\"\"A Flight stream, along with the ticket and locations to access it.\"\"\"\n+    cdef:\n+        CFlightEndpoint endpoint\n+\n+    @staticmethod\n+    def create(ticket, locations):\n+        cdef:\n+            CFlightEndpoint c_endpoint = CFlightEndpoint()\n+            CLocation c_location = CLocation()\n+\n+        if isinstance(ticket, Ticket):\n+            c_endpoint.ticket.ticket = ticket.ticket\n+        else:\n+            c_endpoint.ticket.ticket = ticket\n+\n+        for location in locations:\n+            c_location.host = location.host\n+            c_location.port = location.port\n+            c_endpoint.locations.push_back(c_location)\n+\n+        result = FlightEndpoint()\n+        result.endpoint = c_endpoint\n+        return result\n+\n+    def ticket(self):\n+        return Ticket(self.endpoint.ticket.ticket)\n+\n+    def locations(self):\n+        return [Location(location.host, location.port)\n+                for location in self.endpoint.locations]\n+\n+\n+cdef class FlightInfo:\n+    \"\"\"A description of a Flight stream.\"\"\"\n+    cdef:\n+        unique_ptr[CFlightInfo] info\n+\n+    @staticmethod\n+    def create(Schema schema, FlightDescriptor descriptor, endpoints,\n+               total_records, total_bytes):\n+        cdef:\n+            FlightInfo result = FlightInfo()\n+            shared_ptr[CSchema] c_schema = pyarrow_unwrap_schema(schema)\n+            vector[CFlightEndpoint] c_endpoints\n+\n+        for endpoint in endpoints:\n+            if isinstance(endpoint, FlightEndpoint):\n+                c_endpoints.push_back((<FlightEndpoint> endpoint).endpoint)\n+            else:\n+                raise TypeError('Endpoint {} is not instance of'\n+                                ' FlightEndpoint'.format(endpoint))\n+\n+        check_status(CreateFlightInfo(c_schema,\n+                                      descriptor.descriptor,\n+                                      c_endpoints,\n+                                      total_records,\n+                                      total_bytes, &result.info))\n+        return result\n+\n+    @property\n+    def total_records(self):\n+        \"\"\"The total record count of this flight, or -1 if unknown.\"\"\"\n+        return self.info.get().total_records()\n+\n+    @property\n+    def total_bytes(self):\n+        \"\"\"The size in bytes of the data in this flight, or -1 if unknown.\"\"\"\n+        return self.info.get().total_bytes()\n+\n+    def schema(self):\n \n Review comment:\n   This and the following should probably be properties as well.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-07T17:05:17.985+0000",
                    "updated": "2019-02-07T17:05:17.985+0000",
                    "started": "2019-02-07T17:05:17.984+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195758",
                    "issueId": "13182553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195759",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#discussion_r254753767\n \n \n\n ##########\n File path: python/pyarrow/_flight.pxd\n ##########\n @@ -0,0 +1,18 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n \n Review comment:\n   You needn't create an empty file.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-07T17:05:17.997+0000",
                    "updated": "2019-02-07T17:05:17.997+0000",
                    "started": "2019-02-07T17:05:17.997+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195759",
                    "issueId": "13182553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195760",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#discussion_r254774417\n \n \n\n ##########\n File path: python/pyarrow/_flight.pyx\n ##########\n @@ -0,0 +1,454 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from cython.operator cimport dereference as deref\n+\n+from pyarrow.compat import tobytes\n+from pyarrow.lib cimport *\n+from pyarrow.includes.libarrow_flight cimport *\n+from pyarrow.ipc import _ReadPandasOption\n+import pyarrow.lib as lib\n+\n+\n+cdef class Action:\n+    \"\"\"An action executable on a Flight service.\"\"\"\n+    cdef:\n+        CAction action\n+\n+    def __init__(self, action_type, buf):\n+        self.action.type = tobytes(action_type)\n+        self.action.body = pyarrow_unwrap_buffer(buf)\n+\n+    @property\n+    def type(self):\n+        return self.action.type\n+\n+    def body(self):\n+        return pyarrow_wrap_buffer(self.action.body)\n+\n+\n+cdef class ActionType:\n+    \"\"\"A type of action executable on a Flight service.\"\"\"\n+    cdef:\n+        CActionType action_type\n+\n+    @property\n+    def type(self):\n+        return self.action_type.type\n+\n+    @property\n+    def description(self):\n+        return self.action_type.description\n+\n+    def make_action(self, buf):\n+        \"\"\"Create an Action with this type.\"\"\"\n+        return Action(self.type, buf)\n+\n+    def __repr__(self):\n+        return '<ActionType type={} description={}>'.format(\n+            self.type, self.description)\n+\n+\n+cdef class Result:\n+    \"\"\"A result from executing an Action.\"\"\"\n+    cdef:\n+        unique_ptr[CResult] result\n+\n+    def body(self):\n+        \"\"\"Get the Buffer containing the result.\"\"\"\n+        return pyarrow_wrap_buffer(self.result.get().body)\n+\n+\n+cdef class FlightDescriptor:\n+    \"\"\"A description of a data stream available from a Flight service.\"\"\"\n+    cdef:\n+        CFlightDescriptor descriptor\n+\n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"`pyarrow.flight.FlightDescriptor.for_{path,command}` \"\n+                        \"function instead.\"\n+                        .format(self.__class__.__name__))\n+\n+    @staticmethod\n+    def for_path(*path):\n+        \"\"\"Create a FlightDescriptor for a resource path.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor.type = DescriptorTypePath\n+        result.descriptor.path = [tobytes(p) for p in path]\n+        return result\n+\n+    @staticmethod\n+    def for_command(command):\n+        \"\"\"Create a FlightDescriptor for an opaque command.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor.type = DescriptorTypePath\n+        result.descriptor.cmd = tobytes(command)\n+        return result\n+\n+    def descriptor_type(self):\n+        # TODO: create a real enum? (wouldn't work in Python < 3.4\n+        # without additional dependency)\n+        if self.descriptor.type == DescriptorTypeUnknown:\n+            return \"unknown\"\n+        elif self.descriptor.type == DescriptorTypePath:\n+            return \"path\"\n+        elif self.descriptor.type == DescriptorTypeCmd:\n+            return \"command\"\n+        raise RuntimeError(\"Invalid descriptor type!\")\n+\n+    def command(self):\n+        \"\"\"Get the command for this descriptor.\"\"\"\n+        if self.descriptor_type() != \"command\":\n+            # TODO: raise exception instead?\n+            return None\n+        return self.descriptor.cmd\n+\n+    def path(self):\n+        \"\"\"Get the path for this descriptor.\"\"\"\n+        if self.descriptor_type() != \"path\":\n+            return None\n+        return self.descriptor.path\n+\n+    def __repr__(self):\n+        return \"<FlightDescriptor type: {!r}>\".format(self.descriptor_type())\n+\n+\n+class Ticket:\n+    \"\"\"A ticket for requesting a Flight stream.\"\"\"\n+    def __init__(self, ticket):\n+        self.ticket = ticket\n+\n+\n+class Location:\n+    \"\"\"A location where a Flight stream is available.\"\"\"\n+    def __init__(self, host, port):\n+        self.host = host\n+        self.port = port\n+\n+    def __repr__(self):\n+        return '<Location host={} port={}>'.format(self.host, self.port)\n+\n+\n+cdef class FlightEndpoint:\n+    \"\"\"A Flight stream, along with the ticket and locations to access it.\"\"\"\n+    cdef:\n+        CFlightEndpoint endpoint\n+\n+    @staticmethod\n+    def create(ticket, locations):\n+        cdef:\n+            CFlightEndpoint c_endpoint = CFlightEndpoint()\n+            CLocation c_location = CLocation()\n+\n+        if isinstance(ticket, Ticket):\n+            c_endpoint.ticket.ticket = ticket.ticket\n+        else:\n+            c_endpoint.ticket.ticket = ticket\n+\n+        for location in locations:\n+            c_location.host = location.host\n \n Review comment:\n   Probably `tobytes`?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-07T17:05:18.000+0000",
                    "updated": "2019-02-07T17:05:18.000+0000",
                    "started": "2019-02-07T17:05:17.999+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195760",
                    "issueId": "13182553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195761",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#discussion_r254768245\n \n \n\n ##########\n File path: python/pyarrow/_flight.pyx\n ##########\n @@ -0,0 +1,454 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from cython.operator cimport dereference as deref\n+\n+from pyarrow.compat import tobytes\n+from pyarrow.lib cimport *\n+from pyarrow.includes.libarrow_flight cimport *\n+from pyarrow.ipc import _ReadPandasOption\n+import pyarrow.lib as lib\n+\n+\n+cdef class Action:\n+    \"\"\"An action executable on a Flight service.\"\"\"\n+    cdef:\n+        CAction action\n+\n+    def __init__(self, action_type, buf):\n+        self.action.type = tobytes(action_type)\n+        self.action.body = pyarrow_unwrap_buffer(buf)\n \n Review comment:\n   We want to accept all kinds of bytes-like objects, so this should use `as_buffer`.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-07T17:05:18.028+0000",
                    "updated": "2019-02-07T17:05:18.028+0000",
                    "started": "2019-02-07T17:05:18.027+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195761",
                    "issueId": "13182553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195762",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#discussion_r254756380\n \n \n\n ##########\n File path: cpp/src/arrow/python/flight.h\n ##########\n @@ -0,0 +1,80 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef PYARROW_FLIGHT_H\n+#define PYARROW_FLIGHT_H\n+\n+#include <memory>\n+#include <vector>\n+\n+#include \"arrow/flight/api.h\"\n+#include \"arrow/python/common.h\"\n+#include \"arrow/python/config.h\"\n+\n+namespace arrow {\n+\n+namespace py {\n+\n+namespace flight {\n+\n+/// \\brief A table of function pointers for calling from C++ into\n+/// Python.\n+class ARROW_PYTHON_EXPORT PyFlightServerVtable {\n+ public:\n+  std::function<Status(PyObject*, const arrow::flight::FlightDescriptor&,\n+                       std::unique_ptr<arrow::flight::FlightInfo>*)>\n+      get_flight_info;\n+  std::function<Status(PyObject*, std::unique_ptr<arrow::flight::FlightMessageReader>)>\n+      do_put;\n+  std::function<Status(PyObject*, const arrow::flight::Ticket&,\n+                       std::unique_ptr<arrow::flight::FlightDataStream>*)>\n+      do_get;\n+};\n+\n+class ARROW_PYTHON_EXPORT PyFlightServer : public arrow::flight::FlightServerBase {\n+ public:\n+  explicit PyFlightServer(PyObject* server, PyFlightServerVtable vtable);\n+  ~PyFlightServer() override;\n+\n+  Status ListFlights(const arrow::flight::Criteria* criteria,\n+                     std::unique_ptr<arrow::flight::FlightListing>* listings) override;\n+  Status GetFlightInfo(const arrow::flight::FlightDescriptor& request,\n+                       std::unique_ptr<arrow::flight::FlightInfo>* info) override;\n+  Status DoGet(const arrow::flight::Ticket& request,\n+               std::unique_ptr<arrow::flight::FlightDataStream>* stream) override;\n+  Status DoPut(std::unique_ptr<arrow::flight::FlightMessageReader> reader) override;\n+  Status DoAction(const arrow::flight::Action& action,\n+                  std::unique_ptr<arrow::flight::ResultStream>* result) override;\n+  Status ListActions(std::vector<arrow::flight::ActionType>* actions) override;\n+\n+ private:\n+  PyObject* server_;\n \n Review comment:\n   Should use a `OwnedRefNoGIL`, so that the `PyFlightServer` destructor may be called without the GIL held.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-07T17:05:18.033+0000",
                    "updated": "2019-02-07T17:05:18.033+0000",
                    "started": "2019-02-07T17:05:18.033+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195762",
                    "issueId": "13182553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195763",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#discussion_r254771027\n \n \n\n ##########\n File path: python/pyarrow/_flight.pyx\n ##########\n @@ -0,0 +1,454 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from cython.operator cimport dereference as deref\n+\n+from pyarrow.compat import tobytes\n+from pyarrow.lib cimport *\n+from pyarrow.includes.libarrow_flight cimport *\n+from pyarrow.ipc import _ReadPandasOption\n+import pyarrow.lib as lib\n+\n+\n+cdef class Action:\n+    \"\"\"An action executable on a Flight service.\"\"\"\n+    cdef:\n+        CAction action\n+\n+    def __init__(self, action_type, buf):\n+        self.action.type = tobytes(action_type)\n+        self.action.body = pyarrow_unwrap_buffer(buf)\n+\n+    @property\n+    def type(self):\n+        return self.action.type\n+\n+    def body(self):\n+        return pyarrow_wrap_buffer(self.action.body)\n+\n+\n+cdef class ActionType:\n+    \"\"\"A type of action executable on a Flight service.\"\"\"\n+    cdef:\n+        CActionType action_type\n+\n+    @property\n+    def type(self):\n+        return self.action_type.type\n+\n+    @property\n+    def description(self):\n+        return self.action_type.description\n \n Review comment:\n   and here as well\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-07T17:05:18.034+0000",
                    "updated": "2019-02-07T17:05:18.034+0000",
                    "started": "2019-02-07T17:05:18.033+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195763",
                    "issueId": "13182553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195764",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#discussion_r254777768\n \n \n\n ##########\n File path: python/pyarrow/_flight.pyx\n ##########\n @@ -0,0 +1,454 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from cython.operator cimport dereference as deref\n+\n+from pyarrow.compat import tobytes\n+from pyarrow.lib cimport *\n+from pyarrow.includes.libarrow_flight cimport *\n+from pyarrow.ipc import _ReadPandasOption\n+import pyarrow.lib as lib\n+\n+\n+cdef class Action:\n+    \"\"\"An action executable on a Flight service.\"\"\"\n+    cdef:\n+        CAction action\n+\n+    def __init__(self, action_type, buf):\n+        self.action.type = tobytes(action_type)\n+        self.action.body = pyarrow_unwrap_buffer(buf)\n+\n+    @property\n+    def type(self):\n+        return self.action.type\n+\n+    def body(self):\n+        return pyarrow_wrap_buffer(self.action.body)\n+\n+\n+cdef class ActionType:\n+    \"\"\"A type of action executable on a Flight service.\"\"\"\n+    cdef:\n+        CActionType action_type\n+\n+    @property\n+    def type(self):\n+        return self.action_type.type\n+\n+    @property\n+    def description(self):\n+        return self.action_type.description\n+\n+    def make_action(self, buf):\n+        \"\"\"Create an Action with this type.\"\"\"\n+        return Action(self.type, buf)\n+\n+    def __repr__(self):\n+        return '<ActionType type={} description={}>'.format(\n+            self.type, self.description)\n+\n+\n+cdef class Result:\n+    \"\"\"A result from executing an Action.\"\"\"\n+    cdef:\n+        unique_ptr[CResult] result\n+\n+    def body(self):\n+        \"\"\"Get the Buffer containing the result.\"\"\"\n+        return pyarrow_wrap_buffer(self.result.get().body)\n+\n+\n+cdef class FlightDescriptor:\n+    \"\"\"A description of a data stream available from a Flight service.\"\"\"\n+    cdef:\n+        CFlightDescriptor descriptor\n+\n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"`pyarrow.flight.FlightDescriptor.for_{path,command}` \"\n+                        \"function instead.\"\n+                        .format(self.__class__.__name__))\n+\n+    @staticmethod\n+    def for_path(*path):\n+        \"\"\"Create a FlightDescriptor for a resource path.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor.type = DescriptorTypePath\n+        result.descriptor.path = [tobytes(p) for p in path]\n+        return result\n+\n+    @staticmethod\n+    def for_command(command):\n+        \"\"\"Create a FlightDescriptor for an opaque command.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor.type = DescriptorTypePath\n+        result.descriptor.cmd = tobytes(command)\n+        return result\n+\n+    def descriptor_type(self):\n+        # TODO: create a real enum? (wouldn't work in Python < 3.4\n+        # without additional dependency)\n+        if self.descriptor.type == DescriptorTypeUnknown:\n+            return \"unknown\"\n+        elif self.descriptor.type == DescriptorTypePath:\n+            return \"path\"\n+        elif self.descriptor.type == DescriptorTypeCmd:\n+            return \"command\"\n+        raise RuntimeError(\"Invalid descriptor type!\")\n+\n+    def command(self):\n+        \"\"\"Get the command for this descriptor.\"\"\"\n+        if self.descriptor_type() != \"command\":\n+            # TODO: raise exception instead?\n+            return None\n+        return self.descriptor.cmd\n+\n+    def path(self):\n+        \"\"\"Get the path for this descriptor.\"\"\"\n+        if self.descriptor_type() != \"path\":\n+            return None\n+        return self.descriptor.path\n+\n+    def __repr__(self):\n+        return \"<FlightDescriptor type: {!r}>\".format(self.descriptor_type())\n+\n+\n+class Ticket:\n+    \"\"\"A ticket for requesting a Flight stream.\"\"\"\n+    def __init__(self, ticket):\n+        self.ticket = ticket\n+\n+\n+class Location:\n+    \"\"\"A location where a Flight stream is available.\"\"\"\n+    def __init__(self, host, port):\n+        self.host = host\n+        self.port = port\n+\n+    def __repr__(self):\n+        return '<Location host={} port={}>'.format(self.host, self.port)\n+\n+\n+cdef class FlightEndpoint:\n+    \"\"\"A Flight stream, along with the ticket and locations to access it.\"\"\"\n+    cdef:\n+        CFlightEndpoint endpoint\n+\n+    @staticmethod\n+    def create(ticket, locations):\n+        cdef:\n+            CFlightEndpoint c_endpoint = CFlightEndpoint()\n+            CLocation c_location = CLocation()\n+\n+        if isinstance(ticket, Ticket):\n+            c_endpoint.ticket.ticket = ticket.ticket\n+        else:\n+            c_endpoint.ticket.ticket = ticket\n+\n+        for location in locations:\n+            c_location.host = location.host\n+            c_location.port = location.port\n+            c_endpoint.locations.push_back(c_location)\n+\n+        result = FlightEndpoint()\n+        result.endpoint = c_endpoint\n+        return result\n+\n+    def ticket(self):\n+        return Ticket(self.endpoint.ticket.ticket)\n+\n+    def locations(self):\n+        return [Location(location.host, location.port)\n+                for location in self.endpoint.locations]\n+\n+\n+cdef class FlightInfo:\n+    \"\"\"A description of a Flight stream.\"\"\"\n+    cdef:\n+        unique_ptr[CFlightInfo] info\n+\n+    @staticmethod\n+    def create(Schema schema, FlightDescriptor descriptor, endpoints,\n+               total_records, total_bytes):\n+        cdef:\n+            FlightInfo result = FlightInfo()\n+            shared_ptr[CSchema] c_schema = pyarrow_unwrap_schema(schema)\n+            vector[CFlightEndpoint] c_endpoints\n+\n+        for endpoint in endpoints:\n+            if isinstance(endpoint, FlightEndpoint):\n+                c_endpoints.push_back((<FlightEndpoint> endpoint).endpoint)\n+            else:\n+                raise TypeError('Endpoint {} is not instance of'\n+                                ' FlightEndpoint'.format(endpoint))\n+\n+        check_status(CreateFlightInfo(c_schema,\n+                                      descriptor.descriptor,\n+                                      c_endpoints,\n+                                      total_records,\n+                                      total_bytes, &result.info))\n+        return result\n+\n+    @property\n+    def total_records(self):\n+        \"\"\"The total record count of this flight, or -1 if unknown.\"\"\"\n+        return self.info.get().total_records()\n+\n+    @property\n+    def total_bytes(self):\n+        \"\"\"The size in bytes of the data in this flight, or -1 if unknown.\"\"\"\n+        return self.info.get().total_bytes()\n+\n+    def schema(self):\n+        \"\"\"The schema of the data in this flight.\"\"\"\n+        cdef:\n+            shared_ptr[CSchema] schema\n+        check_status(self.info.get().GetSchema(&schema))\n+        return pyarrow_wrap_schema(schema)\n+\n+    def descriptor(self):\n+        \"\"\"The descriptor of the data in this flight.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor = self.info.get().descriptor()\n+        return result\n+\n+    def endpoints(self):\n+        \"\"\"The endpoints where this flight is available.\"\"\"\n+        # TODO: get Cython to iterate over reference directly\n+        cdef:\n+            vector[CFlightEndpoint] endpoints = self.info.get().endpoints()\n+\n+        result = []\n+        for endpoint in endpoints:\n+            py_endpoint = FlightEndpoint()\n+            py_endpoint.endpoint = endpoint\n+            result.append(py_endpoint)\n+        return result\n+\n+\n+cdef class FlightRecordBatchReader(_CRecordBatchReader, _ReadPandasOption):\n+    cdef dict __dict__\n+\n+\n+cdef class FlightRecordBatchWriter(_CRecordBatchWriter):\n+    pass\n+\n+\n+cdef class FlightClient:\n+    \"\"\"A client to a Flight service.\"\"\"\n+    cdef:\n+        unique_ptr[CFlightClient] client\n+\n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"`pyarrow.flight.FlightClient.connect` instead.\"\n+                        .format(self.__class__.__name__))\n+\n+    @staticmethod\n+    def connect(host, port):\n+        \"\"\"Connect to a Flight service on the given host and port.\"\"\"\n+        cdef:\n+            FlightClient result = FlightClient.__new__(FlightClient)\n+            int c_port = port\n+            c_string c_host = tobytes(host)\n+\n+        with nogil:\n+            check_status(CFlightClient.Connect(c_host, c_port, &result.client))\n+\n+        return result\n+\n+    def list_actions(self):\n+        \"\"\"List the actions available on a service.\"\"\"\n+        cdef:\n+            vector[CActionType] results\n+\n+        with nogil:\n+            check_status(self.client.get().ListActions(&results))\n+\n+        result = []\n+        for action_type in results:\n+            py_action = ActionType()\n+            py_action.action_type = action_type\n+            result.append(py_action)\n+\n+        return result\n+\n+    def do_action(self, action: Action):\n+        \"\"\"Execute an action on a service.\"\"\"\n+        cdef:\n+            unique_ptr[CResultStream] results\n+        with nogil:\n+            check_status(self.client.get().DoAction(action.action, &results))\n+\n+        while True:\n+            result = Result()\n+            with nogil:\n+                check_status(results.get().Next(&result.result))\n+                if result.result == NULL:\n+                    break\n+            yield result\n+\n+    def list_flights(self):\n+        \"\"\"List the flights available on a service.\"\"\"\n+        cdef:\n+            unique_ptr[CFlightListing] listing\n+\n+        with nogil:\n+            check_status(self.client.get().ListFlights(&listing))\n+\n+        while True:\n+            result = FlightInfo()\n+            check_status(listing.get().Next(&result.info))\n \n Review comment:\n   Should add `with nogil` to cover network latencies.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-07T17:05:18.036+0000",
                    "updated": "2019-02-07T17:05:18.036+0000",
                    "started": "2019-02-07T17:05:18.035+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195764",
                    "issueId": "13182553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195765",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#discussion_r254770875\n \n \n\n ##########\n File path: python/pyarrow/_flight.pyx\n ##########\n @@ -0,0 +1,454 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from cython.operator cimport dereference as deref\n+\n+from pyarrow.compat import tobytes\n+from pyarrow.lib cimport *\n+from pyarrow.includes.libarrow_flight cimport *\n+from pyarrow.ipc import _ReadPandasOption\n+import pyarrow.lib as lib\n+\n+\n+cdef class Action:\n+    \"\"\"An action executable on a Flight service.\"\"\"\n+    cdef:\n+        CAction action\n+\n+    def __init__(self, action_type, buf):\n+        self.action.type = tobytes(action_type)\n+        self.action.body = pyarrow_unwrap_buffer(buf)\n+\n+    @property\n+    def type(self):\n+        return self.action.type\n \n Review comment:\n   If the action type is semantically a string, I'd say call `frombytes` here.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-07T17:05:18.036+0000",
                    "updated": "2019-02-07T17:05:18.036+0000",
                    "started": "2019-02-07T17:05:18.036+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195765",
                    "issueId": "13182553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195766",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#discussion_r254777315\n \n \n\n ##########\n File path: python/pyarrow/_flight.pyx\n ##########\n @@ -0,0 +1,454 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from cython.operator cimport dereference as deref\n+\n+from pyarrow.compat import tobytes\n+from pyarrow.lib cimport *\n+from pyarrow.includes.libarrow_flight cimport *\n+from pyarrow.ipc import _ReadPandasOption\n+import pyarrow.lib as lib\n+\n+\n+cdef class Action:\n+    \"\"\"An action executable on a Flight service.\"\"\"\n+    cdef:\n+        CAction action\n+\n+    def __init__(self, action_type, buf):\n+        self.action.type = tobytes(action_type)\n+        self.action.body = pyarrow_unwrap_buffer(buf)\n+\n+    @property\n+    def type(self):\n+        return self.action.type\n+\n+    def body(self):\n+        return pyarrow_wrap_buffer(self.action.body)\n+\n+\n+cdef class ActionType:\n+    \"\"\"A type of action executable on a Flight service.\"\"\"\n+    cdef:\n+        CActionType action_type\n+\n+    @property\n+    def type(self):\n+        return self.action_type.type\n+\n+    @property\n+    def description(self):\n+        return self.action_type.description\n+\n+    def make_action(self, buf):\n+        \"\"\"Create an Action with this type.\"\"\"\n+        return Action(self.type, buf)\n+\n+    def __repr__(self):\n+        return '<ActionType type={} description={}>'.format(\n+            self.type, self.description)\n+\n+\n+cdef class Result:\n+    \"\"\"A result from executing an Action.\"\"\"\n+    cdef:\n+        unique_ptr[CResult] result\n+\n+    def body(self):\n+        \"\"\"Get the Buffer containing the result.\"\"\"\n+        return pyarrow_wrap_buffer(self.result.get().body)\n+\n+\n+cdef class FlightDescriptor:\n+    \"\"\"A description of a data stream available from a Flight service.\"\"\"\n+    cdef:\n+        CFlightDescriptor descriptor\n+\n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"`pyarrow.flight.FlightDescriptor.for_{path,command}` \"\n+                        \"function instead.\"\n+                        .format(self.__class__.__name__))\n+\n+    @staticmethod\n+    def for_path(*path):\n+        \"\"\"Create a FlightDescriptor for a resource path.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor.type = DescriptorTypePath\n+        result.descriptor.path = [tobytes(p) for p in path]\n+        return result\n+\n+    @staticmethod\n+    def for_command(command):\n+        \"\"\"Create a FlightDescriptor for an opaque command.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor.type = DescriptorTypePath\n+        result.descriptor.cmd = tobytes(command)\n+        return result\n+\n+    def descriptor_type(self):\n+        # TODO: create a real enum? (wouldn't work in Python < 3.4\n+        # without additional dependency)\n+        if self.descriptor.type == DescriptorTypeUnknown:\n+            return \"unknown\"\n+        elif self.descriptor.type == DescriptorTypePath:\n+            return \"path\"\n+        elif self.descriptor.type == DescriptorTypeCmd:\n+            return \"command\"\n+        raise RuntimeError(\"Invalid descriptor type!\")\n+\n+    def command(self):\n+        \"\"\"Get the command for this descriptor.\"\"\"\n+        if self.descriptor_type() != \"command\":\n+            # TODO: raise exception instead?\n+            return None\n+        return self.descriptor.cmd\n+\n+    def path(self):\n+        \"\"\"Get the path for this descriptor.\"\"\"\n+        if self.descriptor_type() != \"path\":\n+            return None\n+        return self.descriptor.path\n+\n+    def __repr__(self):\n+        return \"<FlightDescriptor type: {!r}>\".format(self.descriptor_type())\n+\n+\n+class Ticket:\n+    \"\"\"A ticket for requesting a Flight stream.\"\"\"\n+    def __init__(self, ticket):\n+        self.ticket = ticket\n+\n+\n+class Location:\n+    \"\"\"A location where a Flight stream is available.\"\"\"\n+    def __init__(self, host, port):\n+        self.host = host\n+        self.port = port\n+\n+    def __repr__(self):\n+        return '<Location host={} port={}>'.format(self.host, self.port)\n+\n+\n+cdef class FlightEndpoint:\n+    \"\"\"A Flight stream, along with the ticket and locations to access it.\"\"\"\n+    cdef:\n+        CFlightEndpoint endpoint\n+\n+    @staticmethod\n+    def create(ticket, locations):\n+        cdef:\n+            CFlightEndpoint c_endpoint = CFlightEndpoint()\n+            CLocation c_location = CLocation()\n+\n+        if isinstance(ticket, Ticket):\n+            c_endpoint.ticket.ticket = ticket.ticket\n+        else:\n+            c_endpoint.ticket.ticket = ticket\n+\n+        for location in locations:\n+            c_location.host = location.host\n+            c_location.port = location.port\n+            c_endpoint.locations.push_back(c_location)\n+\n+        result = FlightEndpoint()\n+        result.endpoint = c_endpoint\n+        return result\n+\n+    def ticket(self):\n+        return Ticket(self.endpoint.ticket.ticket)\n+\n+    def locations(self):\n+        return [Location(location.host, location.port)\n+                for location in self.endpoint.locations]\n+\n+\n+cdef class FlightInfo:\n+    \"\"\"A description of a Flight stream.\"\"\"\n+    cdef:\n+        unique_ptr[CFlightInfo] info\n+\n+    @staticmethod\n+    def create(Schema schema, FlightDescriptor descriptor, endpoints,\n+               total_records, total_bytes):\n+        cdef:\n+            FlightInfo result = FlightInfo()\n+            shared_ptr[CSchema] c_schema = pyarrow_unwrap_schema(schema)\n+            vector[CFlightEndpoint] c_endpoints\n+\n+        for endpoint in endpoints:\n+            if isinstance(endpoint, FlightEndpoint):\n+                c_endpoints.push_back((<FlightEndpoint> endpoint).endpoint)\n+            else:\n+                raise TypeError('Endpoint {} is not instance of'\n+                                ' FlightEndpoint'.format(endpoint))\n+\n+        check_status(CreateFlightInfo(c_schema,\n+                                      descriptor.descriptor,\n+                                      c_endpoints,\n+                                      total_records,\n+                                      total_bytes, &result.info))\n+        return result\n+\n+    @property\n+    def total_records(self):\n+        \"\"\"The total record count of this flight, or -1 if unknown.\"\"\"\n+        return self.info.get().total_records()\n+\n+    @property\n+    def total_bytes(self):\n+        \"\"\"The size in bytes of the data in this flight, or -1 if unknown.\"\"\"\n+        return self.info.get().total_bytes()\n+\n+    def schema(self):\n+        \"\"\"The schema of the data in this flight.\"\"\"\n+        cdef:\n+            shared_ptr[CSchema] schema\n+        check_status(self.info.get().GetSchema(&schema))\n+        return pyarrow_wrap_schema(schema)\n+\n+    def descriptor(self):\n+        \"\"\"The descriptor of the data in this flight.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor = self.info.get().descriptor()\n+        return result\n+\n+    def endpoints(self):\n+        \"\"\"The endpoints where this flight is available.\"\"\"\n+        # TODO: get Cython to iterate over reference directly\n+        cdef:\n+            vector[CFlightEndpoint] endpoints = self.info.get().endpoints()\n+\n+        result = []\n+        for endpoint in endpoints:\n+            py_endpoint = FlightEndpoint()\n+            py_endpoint.endpoint = endpoint\n+            result.append(py_endpoint)\n+        return result\n+\n+\n+cdef class FlightRecordBatchReader(_CRecordBatchReader, _ReadPandasOption):\n+    cdef dict __dict__\n+\n+\n+cdef class FlightRecordBatchWriter(_CRecordBatchWriter):\n+    pass\n+\n+\n+cdef class FlightClient:\n+    \"\"\"A client to a Flight service.\"\"\"\n+    cdef:\n+        unique_ptr[CFlightClient] client\n+\n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"`pyarrow.flight.FlightClient.connect` instead.\"\n+                        .format(self.__class__.__name__))\n+\n+    @staticmethod\n+    def connect(host, port):\n+        \"\"\"Connect to a Flight service on the given host and port.\"\"\"\n+        cdef:\n+            FlightClient result = FlightClient.__new__(FlightClient)\n+            int c_port = port\n+            c_string c_host = tobytes(host)\n+\n+        with nogil:\n+            check_status(CFlightClient.Connect(c_host, c_port, &result.client))\n+\n+        return result\n+\n+    def list_actions(self):\n+        \"\"\"List the actions available on a service.\"\"\"\n+        cdef:\n+            vector[CActionType] results\n+\n+        with nogil:\n+            check_status(self.client.get().ListActions(&results))\n+\n+        result = []\n+        for action_type in results:\n+            py_action = ActionType()\n+            py_action.action_type = action_type\n+            result.append(py_action)\n+\n+        return result\n+\n+    def do_action(self, action: Action):\n+        \"\"\"Execute an action on a service.\"\"\"\n+        cdef:\n+            unique_ptr[CResultStream] results\n+        with nogil:\n+            check_status(self.client.get().DoAction(action.action, &results))\n+\n+        while True:\n+            result = Result()\n+            with nogil:\n+                check_status(results.get().Next(&result.result))\n+                if result.result == NULL:\n+                    break\n+            yield result\n+\n+    def list_flights(self):\n+        \"\"\"List the flights available on a service.\"\"\"\n+        cdef:\n+            unique_ptr[CFlightListing] listing\n+\n+        with nogil:\n+            check_status(self.client.get().ListFlights(&listing))\n+\n+        while True:\n+            result = FlightInfo()\n+            check_status(listing.get().Next(&result.info))\n+            if result.info == NULL:\n+                break\n+            yield result\n+\n+    def get_flight_info(self, descriptor: FlightDescriptor):\n+        \"\"\"Request information about an available flight.\"\"\"\n+        result = FlightInfo()\n+\n+        with nogil:\n+            check_status(self.client.get().GetFlightInfo(\n+                descriptor.descriptor, &result.info))\n+\n+        return result\n+\n+    def do_get(self, ticket: Ticket, schema: Schema):\n+        \"\"\"Request the data for a flight.\"\"\"\n+        cdef:\n+            # TODO: introduce unwrap\n+            CTicket c_ticket\n+            shared_ptr[CSchema] c_schema = pyarrow_unwrap_schema(schema)\n+            unique_ptr[CRecordBatchReader] reader\n+\n+        c_ticket.ticket = ticket.ticket\n+        check_status(self.client.get().DoGet(c_ticket, c_schema, &reader))\n \n Review comment:\n   Should add `with nogil`.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-07T17:05:18.043+0000",
                    "updated": "2019-02-07T17:05:18.043+0000",
                    "started": "2019-02-07T17:05:18.043+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195766",
                    "issueId": "13182553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195767",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#discussion_r254779933\n \n \n\n ##########\n File path: python/pyarrow/_flight.pyx\n ##########\n @@ -0,0 +1,454 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from cython.operator cimport dereference as deref\n+\n+from pyarrow.compat import tobytes\n+from pyarrow.lib cimport *\n+from pyarrow.includes.libarrow_flight cimport *\n+from pyarrow.ipc import _ReadPandasOption\n+import pyarrow.lib as lib\n+\n+\n+cdef class Action:\n+    \"\"\"An action executable on a Flight service.\"\"\"\n+    cdef:\n+        CAction action\n+\n+    def __init__(self, action_type, buf):\n+        self.action.type = tobytes(action_type)\n+        self.action.body = pyarrow_unwrap_buffer(buf)\n+\n+    @property\n+    def type(self):\n+        return self.action.type\n+\n+    def body(self):\n+        return pyarrow_wrap_buffer(self.action.body)\n+\n+\n+cdef class ActionType:\n+    \"\"\"A type of action executable on a Flight service.\"\"\"\n+    cdef:\n+        CActionType action_type\n+\n+    @property\n+    def type(self):\n+        return self.action_type.type\n+\n+    @property\n+    def description(self):\n+        return self.action_type.description\n+\n+    def make_action(self, buf):\n+        \"\"\"Create an Action with this type.\"\"\"\n+        return Action(self.type, buf)\n+\n+    def __repr__(self):\n+        return '<ActionType type={} description={}>'.format(\n+            self.type, self.description)\n+\n+\n+cdef class Result:\n+    \"\"\"A result from executing an Action.\"\"\"\n+    cdef:\n+        unique_ptr[CResult] result\n+\n+    def body(self):\n+        \"\"\"Get the Buffer containing the result.\"\"\"\n+        return pyarrow_wrap_buffer(self.result.get().body)\n+\n+\n+cdef class FlightDescriptor:\n+    \"\"\"A description of a data stream available from a Flight service.\"\"\"\n+    cdef:\n+        CFlightDescriptor descriptor\n+\n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"`pyarrow.flight.FlightDescriptor.for_{path,command}` \"\n+                        \"function instead.\"\n+                        .format(self.__class__.__name__))\n+\n+    @staticmethod\n+    def for_path(*path):\n+        \"\"\"Create a FlightDescriptor for a resource path.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor.type = DescriptorTypePath\n+        result.descriptor.path = [tobytes(p) for p in path]\n+        return result\n+\n+    @staticmethod\n+    def for_command(command):\n+        \"\"\"Create a FlightDescriptor for an opaque command.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor.type = DescriptorTypePath\n+        result.descriptor.cmd = tobytes(command)\n+        return result\n+\n+    def descriptor_type(self):\n+        # TODO: create a real enum? (wouldn't work in Python < 3.4\n+        # without additional dependency)\n+        if self.descriptor.type == DescriptorTypeUnknown:\n+            return \"unknown\"\n+        elif self.descriptor.type == DescriptorTypePath:\n+            return \"path\"\n+        elif self.descriptor.type == DescriptorTypeCmd:\n+            return \"command\"\n+        raise RuntimeError(\"Invalid descriptor type!\")\n+\n+    def command(self):\n+        \"\"\"Get the command for this descriptor.\"\"\"\n+        if self.descriptor_type() != \"command\":\n+            # TODO: raise exception instead?\n+            return None\n+        return self.descriptor.cmd\n+\n+    def path(self):\n+        \"\"\"Get the path for this descriptor.\"\"\"\n+        if self.descriptor_type() != \"path\":\n+            return None\n+        return self.descriptor.path\n+\n+    def __repr__(self):\n+        return \"<FlightDescriptor type: {!r}>\".format(self.descriptor_type())\n+\n+\n+class Ticket:\n+    \"\"\"A ticket for requesting a Flight stream.\"\"\"\n+    def __init__(self, ticket):\n+        self.ticket = ticket\n+\n+\n+class Location:\n+    \"\"\"A location where a Flight stream is available.\"\"\"\n+    def __init__(self, host, port):\n+        self.host = host\n+        self.port = port\n+\n+    def __repr__(self):\n+        return '<Location host={} port={}>'.format(self.host, self.port)\n+\n+\n+cdef class FlightEndpoint:\n+    \"\"\"A Flight stream, along with the ticket and locations to access it.\"\"\"\n+    cdef:\n+        CFlightEndpoint endpoint\n+\n+    @staticmethod\n+    def create(ticket, locations):\n+        cdef:\n+            CFlightEndpoint c_endpoint = CFlightEndpoint()\n+            CLocation c_location = CLocation()\n+\n+        if isinstance(ticket, Ticket):\n+            c_endpoint.ticket.ticket = ticket.ticket\n+        else:\n+            c_endpoint.ticket.ticket = ticket\n+\n+        for location in locations:\n+            c_location.host = location.host\n+            c_location.port = location.port\n+            c_endpoint.locations.push_back(c_location)\n+\n+        result = FlightEndpoint()\n+        result.endpoint = c_endpoint\n+        return result\n+\n+    def ticket(self):\n+        return Ticket(self.endpoint.ticket.ticket)\n+\n+    def locations(self):\n+        return [Location(location.host, location.port)\n+                for location in self.endpoint.locations]\n+\n+\n+cdef class FlightInfo:\n+    \"\"\"A description of a Flight stream.\"\"\"\n+    cdef:\n+        unique_ptr[CFlightInfo] info\n+\n+    @staticmethod\n+    def create(Schema schema, FlightDescriptor descriptor, endpoints,\n \n Review comment:\n   Why not make this the `FlightInfo` constructor instead?\r\n   \r\n   In any case, you should add a docstring.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-07T17:05:18.047+0000",
                    "updated": "2019-02-07T17:05:18.047+0000",
                    "started": "2019-02-07T17:05:18.046+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195767",
                    "issueId": "13182553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/worklog/195768",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #3566: [WIP] ARROW-3162: Flight Python bindings\nURL: https://github.com/apache/arrow/pull/3566#discussion_r254779179\n \n \n\n ##########\n File path: python/pyarrow/_flight.pyx\n ##########\n @@ -0,0 +1,454 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from cython.operator cimport dereference as deref\n+\n+from pyarrow.compat import tobytes\n+from pyarrow.lib cimport *\n+from pyarrow.includes.libarrow_flight cimport *\n+from pyarrow.ipc import _ReadPandasOption\n+import pyarrow.lib as lib\n+\n+\n+cdef class Action:\n+    \"\"\"An action executable on a Flight service.\"\"\"\n+    cdef:\n+        CAction action\n+\n+    def __init__(self, action_type, buf):\n+        self.action.type = tobytes(action_type)\n+        self.action.body = pyarrow_unwrap_buffer(buf)\n+\n+    @property\n+    def type(self):\n+        return self.action.type\n+\n+    def body(self):\n+        return pyarrow_wrap_buffer(self.action.body)\n+\n+\n+cdef class ActionType:\n+    \"\"\"A type of action executable on a Flight service.\"\"\"\n+    cdef:\n+        CActionType action_type\n+\n+    @property\n+    def type(self):\n+        return self.action_type.type\n+\n+    @property\n+    def description(self):\n+        return self.action_type.description\n+\n+    def make_action(self, buf):\n+        \"\"\"Create an Action with this type.\"\"\"\n+        return Action(self.type, buf)\n+\n+    def __repr__(self):\n+        return '<ActionType type={} description={}>'.format(\n+            self.type, self.description)\n+\n+\n+cdef class Result:\n+    \"\"\"A result from executing an Action.\"\"\"\n+    cdef:\n+        unique_ptr[CResult] result\n+\n+    def body(self):\n+        \"\"\"Get the Buffer containing the result.\"\"\"\n+        return pyarrow_wrap_buffer(self.result.get().body)\n+\n+\n+cdef class FlightDescriptor:\n+    \"\"\"A description of a data stream available from a Flight service.\"\"\"\n+    cdef:\n+        CFlightDescriptor descriptor\n+\n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"`pyarrow.flight.FlightDescriptor.for_{path,command}` \"\n+                        \"function instead.\"\n+                        .format(self.__class__.__name__))\n+\n+    @staticmethod\n+    def for_path(*path):\n+        \"\"\"Create a FlightDescriptor for a resource path.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor.type = DescriptorTypePath\n+        result.descriptor.path = [tobytes(p) for p in path]\n+        return result\n+\n+    @staticmethod\n+    def for_command(command):\n+        \"\"\"Create a FlightDescriptor for an opaque command.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor.type = DescriptorTypePath\n+        result.descriptor.cmd = tobytes(command)\n+        return result\n+\n+    def descriptor_type(self):\n+        # TODO: create a real enum? (wouldn't work in Python < 3.4\n+        # without additional dependency)\n+        if self.descriptor.type == DescriptorTypeUnknown:\n+            return \"unknown\"\n+        elif self.descriptor.type == DescriptorTypePath:\n+            return \"path\"\n+        elif self.descriptor.type == DescriptorTypeCmd:\n+            return \"command\"\n+        raise RuntimeError(\"Invalid descriptor type!\")\n+\n+    def command(self):\n+        \"\"\"Get the command for this descriptor.\"\"\"\n+        if self.descriptor_type() != \"command\":\n+            # TODO: raise exception instead?\n+            return None\n+        return self.descriptor.cmd\n+\n+    def path(self):\n+        \"\"\"Get the path for this descriptor.\"\"\"\n+        if self.descriptor_type() != \"path\":\n+            return None\n+        return self.descriptor.path\n+\n+    def __repr__(self):\n+        return \"<FlightDescriptor type: {!r}>\".format(self.descriptor_type())\n+\n+\n+class Ticket:\n+    \"\"\"A ticket for requesting a Flight stream.\"\"\"\n+    def __init__(self, ticket):\n+        self.ticket = ticket\n+\n+\n+class Location:\n+    \"\"\"A location where a Flight stream is available.\"\"\"\n+    def __init__(self, host, port):\n+        self.host = host\n+        self.port = port\n+\n+    def __repr__(self):\n+        return '<Location host={} port={}>'.format(self.host, self.port)\n+\n+\n+cdef class FlightEndpoint:\n+    \"\"\"A Flight stream, along with the ticket and locations to access it.\"\"\"\n+    cdef:\n+        CFlightEndpoint endpoint\n+\n+    @staticmethod\n+    def create(ticket, locations):\n+        cdef:\n+            CFlightEndpoint c_endpoint = CFlightEndpoint()\n+            CLocation c_location = CLocation()\n+\n+        if isinstance(ticket, Ticket):\n+            c_endpoint.ticket.ticket = ticket.ticket\n+        else:\n+            c_endpoint.ticket.ticket = ticket\n+\n+        for location in locations:\n+            c_location.host = location.host\n+            c_location.port = location.port\n+            c_endpoint.locations.push_back(c_location)\n+\n+        result = FlightEndpoint()\n+        result.endpoint = c_endpoint\n+        return result\n+\n+    def ticket(self):\n+        return Ticket(self.endpoint.ticket.ticket)\n+\n+    def locations(self):\n+        return [Location(location.host, location.port)\n+                for location in self.endpoint.locations]\n+\n+\n+cdef class FlightInfo:\n+    \"\"\"A description of a Flight stream.\"\"\"\n+    cdef:\n+        unique_ptr[CFlightInfo] info\n+\n+    @staticmethod\n+    def create(Schema schema, FlightDescriptor descriptor, endpoints,\n+               total_records, total_bytes):\n+        cdef:\n+            FlightInfo result = FlightInfo()\n+            shared_ptr[CSchema] c_schema = pyarrow_unwrap_schema(schema)\n+            vector[CFlightEndpoint] c_endpoints\n+\n+        for endpoint in endpoints:\n+            if isinstance(endpoint, FlightEndpoint):\n+                c_endpoints.push_back((<FlightEndpoint> endpoint).endpoint)\n+            else:\n+                raise TypeError('Endpoint {} is not instance of'\n+                                ' FlightEndpoint'.format(endpoint))\n+\n+        check_status(CreateFlightInfo(c_schema,\n+                                      descriptor.descriptor,\n+                                      c_endpoints,\n+                                      total_records,\n+                                      total_bytes, &result.info))\n+        return result\n+\n+    @property\n+    def total_records(self):\n+        \"\"\"The total record count of this flight, or -1 if unknown.\"\"\"\n+        return self.info.get().total_records()\n+\n+    @property\n+    def total_bytes(self):\n+        \"\"\"The size in bytes of the data in this flight, or -1 if unknown.\"\"\"\n+        return self.info.get().total_bytes()\n+\n+    def schema(self):\n+        \"\"\"The schema of the data in this flight.\"\"\"\n+        cdef:\n+            shared_ptr[CSchema] schema\n+        check_status(self.info.get().GetSchema(&schema))\n+        return pyarrow_wrap_schema(schema)\n+\n+    def descriptor(self):\n+        \"\"\"The descriptor of the data in this flight.\"\"\"\n+        cdef FlightDescriptor result = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+        result.descriptor = self.info.get().descriptor()\n+        return result\n+\n+    def endpoints(self):\n+        \"\"\"The endpoints where this flight is available.\"\"\"\n+        # TODO: get Cython to iterate over reference directly\n+        cdef:\n+            vector[CFlightEndpoint] endpoints = self.info.get().endpoints()\n+\n+        result = []\n+        for endpoint in endpoints:\n+            py_endpoint = FlightEndpoint()\n+            py_endpoint.endpoint = endpoint\n+            result.append(py_endpoint)\n+        return result\n+\n+\n+cdef class FlightRecordBatchReader(_CRecordBatchReader, _ReadPandasOption):\n+    cdef dict __dict__\n+\n+\n+cdef class FlightRecordBatchWriter(_CRecordBatchWriter):\n+    pass\n+\n+\n+cdef class FlightClient:\n+    \"\"\"A client to a Flight service.\"\"\"\n+    cdef:\n+        unique_ptr[CFlightClient] client\n+\n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"`pyarrow.flight.FlightClient.connect` instead.\"\n+                        .format(self.__class__.__name__))\n+\n+    @staticmethod\n+    def connect(host, port):\n+        \"\"\"Connect to a Flight service on the given host and port.\"\"\"\n+        cdef:\n+            FlightClient result = FlightClient.__new__(FlightClient)\n+            int c_port = port\n+            c_string c_host = tobytes(host)\n+\n+        with nogil:\n+            check_status(CFlightClient.Connect(c_host, c_port, &result.client))\n+\n+        return result\n+\n+    def list_actions(self):\n+        \"\"\"List the actions available on a service.\"\"\"\n+        cdef:\n+            vector[CActionType] results\n+\n+        with nogil:\n+            check_status(self.client.get().ListActions(&results))\n+\n+        result = []\n+        for action_type in results:\n+            py_action = ActionType()\n+            py_action.action_type = action_type\n+            result.append(py_action)\n+\n+        return result\n+\n+    def do_action(self, action: Action):\n+        \"\"\"Execute an action on a service.\"\"\"\n+        cdef:\n+            unique_ptr[CResultStream] results\n+        with nogil:\n+            check_status(self.client.get().DoAction(action.action, &results))\n+\n+        while True:\n+            result = Result()\n+            with nogil:\n+                check_status(results.get().Next(&result.result))\n+                if result.result == NULL:\n+                    break\n+            yield result\n+\n+    def list_flights(self):\n+        \"\"\"List the flights available on a service.\"\"\"\n+        cdef:\n+            unique_ptr[CFlightListing] listing\n+\n+        with nogil:\n+            check_status(self.client.get().ListFlights(&listing))\n+\n+        while True:\n+            result = FlightInfo()\n+            check_status(listing.get().Next(&result.info))\n+            if result.info == NULL:\n+                break\n+            yield result\n+\n+    def get_flight_info(self, descriptor: FlightDescriptor):\n+        \"\"\"Request information about an available flight.\"\"\"\n+        result = FlightInfo()\n+\n+        with nogil:\n+            check_status(self.client.get().GetFlightInfo(\n+                descriptor.descriptor, &result.info))\n+\n+        return result\n+\n+    def do_get(self, ticket: Ticket, schema: Schema):\n+        \"\"\"Request the data for a flight.\"\"\"\n+        cdef:\n+            # TODO: introduce unwrap\n+            CTicket c_ticket\n+            shared_ptr[CSchema] c_schema = pyarrow_unwrap_schema(schema)\n+            unique_ptr[CRecordBatchReader] reader\n+\n+        c_ticket.ticket = ticket.ticket\n+        check_status(self.client.get().DoGet(c_ticket, c_schema, &reader))\n+        result = FlightRecordBatchReader()\n+        result.reader.reset(reader.release())\n+        return result\n+\n+    def do_put(self, descriptor: FlightDescriptor, schema: Schema):\n+        \"\"\"Upload data to a flight.\"\"\"\n+        cdef:\n+            shared_ptr[CSchema] c_schema = pyarrow_unwrap_schema(schema)\n+            unique_ptr[CRecordBatchWriter] writer\n+\n+        check_status(self.client.get().DoPut(\n+            descriptor.descriptor, c_schema, &writer))\n+        result = FlightRecordBatchWriter()\n+        result.writer.reset(writer.release())\n+        return result\n+\n+\n+cdef class FlightDataStream:\n+    cdef:\n+        unique_ptr[CFlightDataStream] stream\n+\n+\n+cdef class RecordBatchStream(FlightDataStream):\n+    def __init__(self, reader):\n+        # TODO: we don't really expose the readers in Python.\n+        # self.stream.reset(None)\n+        pass\n+\n+\n+cdef CStatus _get_flight_info(void* self, CFlightDescriptor c_descriptor,\n+                              unique_ptr[CFlightInfo]* info):\n+    \"\"\"Callback for implementing Flight servers in Python.\"\"\"\n+    cdef FlightDescriptor descriptor = \\\n+        FlightDescriptor.__new__(FlightDescriptor)\n+    try:\n+        descriptor.descriptor = c_descriptor\n+        result = (<object> self).get_flight_info(descriptor)\n+        print(result)\n+        if not result:\n+            info.reset(NULL)\n+            # TODO:\n+        else:\n+            # TODO:\n+            pass\n+        return CStatus_OK()\n+    except NotImplemented as err:\n+        return CStatus_NotImplemented(repr(err).encode('utf-8'))\n+    except Exception as err:\n+        return CStatus_UnknownError(repr(err).encode('utf-8'))\n+    # TODO: KeyError\n+\n+\n+cdef CStatus _do_put(void* self, unique_ptr[CFlightMessageReader] reader):\n+    \"\"\"Callback for implementing Flight servers in Python.\"\"\"\n+    cdef:\n+        FlightRecordBatchReader py_reader = FlightRecordBatchReader()\n+        FlightDescriptor descriptor = \\\n+            FlightDescriptor.__new__(FlightDescriptor)\n+\n+    descriptor.descriptor = reader.get().descriptor()\n+    py_reader.reader.reset(reader.release())\n+    try:\n+        result = (<object> self).do_put(descriptor, py_reader)\n+        return CStatus_OK()\n+    except Exception as err:\n+        print(err)\n+        return CStatus_UnknownError(repr(err).encode('utf-8'))\n+\n+\n+cdef CStatus _do_get(void* self, CTicket ticket,\n+                     unique_ptr[CFlightDataStream]* stream):\n+    \"\"\"Callback for implementing Flight servers in Python.\"\"\"\n+    py_ticket = Ticket()\n+    py_ticket.ticket = ticket.ticket\n+    try:\n+        result = (<object> self).do_get(py_ticket)\n+        if not isinstance(result, FlightDataStream):\n+            raise TypeError(\"FlightServerBase.do_get must return \"\n+                            \"a FlightDataStream\")\n+        stream[0] = move((<FlightDataStream> result).stream)\n+        return CStatus_OK()\n+    except Exception as err:\n+        print(err)\n+        return CStatus_UnknownError(repr(err).encode('utf-8'))\n+\n+\n+cdef class FlightServerBase:\n+    \"\"\"A Flight service definition.\"\"\"\n+\n+    cdef:\n+        unique_ptr[PyFlightServer] server\n+\n+    def run(self, port):\n+        # TODO: share one vtable between instances\n+        cdef:\n+            PyFlightServerVtable vtable = PyFlightServerVtable()\n+        vtable.get_flight_info = &_get_flight_info\n+        vtable.do_put = &_do_put\n+        vtable.do_get = &_do_get\n+        self.server.reset(new PyFlightServer(self, vtable))\n+        self.server.get().Run(port)\n \n Review comment:\n   Should certainly run without the GIL, no?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-07T17:05:18.050+0000",
                    "updated": "2019-02-07T17:05:18.050+0000",
                    "started": "2019-02-07T17:05:18.049+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "195768",
                    "issueId": "13182553"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 27600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@59db3871[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@75dac010[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@51a1f7be[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@725877da[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@12ff3b65[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@9f72ff7[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@57353570[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@66e26eeb[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@dad4541[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@3d954b94[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@437567e3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@3615cc50[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 27600,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Feb 26 19:51:52 UTC 2019",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2019-02-26T19:51:52.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3162/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2018-09-03T00:23:54.000+0000",
        "updated": "2019-02-26T20:02:41.000+0000",
        "timeoriginalestimate": null,
        "description": "While it will be straightforward to offer a Flight client to Python users, enabling _servers_ to be written _in Python_ will require a glue class to invoke methods on a provided server implementation, coercing to and from various Python objects and Arrow wrapper classes",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "7h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 27600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Python] Enable Flight servers to be implemented in pure Python",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/comment/16624024",
                    "id": "16624024",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "The likely way to accomplish this will be to create an implementation of {{arrow::flight::FlightServerBase}} in libarrow_python that takes the Python class implementing specific callback functions having a certain API. Opaque data from the server API will be passed to Python as pyarrow.Buffer objects or PyBytes as appropriate",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-09-21T18:38:28.518+0000",
                    "updated": "2018-09-21T18:38:28.518+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/comment/16768535",
                    "id": "16768535",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 3566\n[https://github.com/apache/arrow/pull/3566]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2019-02-14T17:17:16.066+0000",
                    "updated": "2019-02-14T17:17:16.066+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/comment/16768540",
                    "id": "16768540",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Not quite done yet - there will be another PR or two to sort things out fully.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2019-02-14T17:19:37.605+0000",
                    "updated": "2019-02-14T17:19:37.605+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182553/comment/16778511",
                    "id": "16778511",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 3712\n[https://github.com/apache/arrow/pull/3712]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2019-02-26T19:51:52.733+0000",
                    "updated": "2019-02-26T19:51:52.733+0000"
                }
            ],
            "maxResults": 4,
            "total": 4,
            "startAt": 0
        },
        "customfield_12311820": "0|i3xnvj:",
        "customfield_12314139": null
    }
}