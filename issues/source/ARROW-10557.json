{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13339965",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965",
    "key": "ARROW-10557",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349983",
                "id": "12349983",
                "description": "",
                "name": "5.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-07-28"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12608917",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12608917",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13042654",
                    "key": "ARROW-555",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13042654",
                    "fields": {
                        "summary": "[C++] String algorithm library for StringArray/BinaryArray",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12616685",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12616685",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13381920",
                    "key": "ARROW-12948",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13381920",
                    "fields": {
                        "summary": "[C++] Add string slice replace kernel",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12605133",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12605133",
                "type": {
                    "id": "12310040",
                    "name": "Required",
                    "inward": "is required by",
                    "outward": "requires",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310040"
                },
                "outwardIssue": {
                    "id": "13311354",
                    "key": "ARROW-9128",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354",
                    "fields": {
                        "summary": "[C++] Implement string space trimming kernels: trim, ltrim, and rtrim",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12608102",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12608102",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "inwardIssue": {
                    "id": "13335348",
                    "key": "ARROW-10305",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335348",
                    "fields": {
                        "summary": "[R] Filter with regular expressions",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=maartenbreddels",
            "name": "maartenbreddels",
            "key": "maartenbreddels",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Maarten Breddels",
            "active": true,
            "timeZone": "Europe/Amsterdam"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=maartenbreddels",
            "name": "maartenbreddels",
            "key": "maartenbreddels",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Maarten Breddels",
            "active": true,
            "timeZone": "Europe/Amsterdam"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=maartenbreddels",
            "name": "maartenbreddels",
            "key": "maartenbreddels",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Maarten Breddels",
            "active": true,
            "timeZone": "Europe/Amsterdam"
        },
        "aggregateprogress": {
            "progress": 10800,
            "total": 10800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 10800,
            "total": 10800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10557/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 18,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/worklog/527784",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels opened a new pull request #9000:\nURL: https://github.com/apache/arrow/pull/9000\n\n\n   Needs a rebase after https://github.com/apache/arrow/pull/8621 is merged\r\n   \r\n   I totally agree with https://github.com/python/cpython/blob/c9bc290dd6e3994a4ead2a224178bcba86f0c0e4/Objects/sliceobject.c#L252 \r\n   \r\n   This was tricky to get right, the main difficulty is in manually dealing with reverse iterators. Therefore I put on extra guardrails by having the Python unittests cover a lot of cases. All edge cases detected by this are translated to the C++ unittest suite, so we could reduce them to reduce pytest execution cost (I added 1 second).\r\n   \r\n   Slicing is based on Python, `[start, stop)` inclusive/exclusive semantics, where an index refers to a codeunit (like Python apparently, badly documented), and negative indices start counting from the right. `step != 0` is supported, like Python. \r\n   \r\n   The only thing we cannot support easily, are things like reversing a string, since in Python one can do `s[::-1]` or `s[-1::-1]`, but we don't support empty values with the Option machinery (we model this as an c-`int64`). To mimic this, we can do `pc.utf8_slice_codeunits(ar, start=-1, end=-sys.maxsize, step=-1)` (i.e. a very large negative value). \r\n   \r\n   For instance, libraries such as Pandas and Vaex can do sth like that, confirmed to be working by modifying the unittest like this:\r\n   ```python\r\n   import sys\r\n   @pytest.mark.parametrize('start', list(range(-6, 6)) + [None])\r\n   @pytest.mark.parametrize('stop', list(range(-6, 6)) + [None])\r\n   @pytest.mark.parametrize('step', [-3, -2, -1, 1, 2, 3])\r\n   def test_slice_compatibility(start,stop, step):\r\n       input = pa.array([\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\", \"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\r\n       expected = pa.array([k.as_py()[start:stop:step] for k in input])\r\n       if start is None:\r\n           start = -sys.maxsize if step > 0 else sys.maxsize\r\n       if stop is None:\r\n           stop = sys.maxsize if step > 0 else -sys.maxsize\r\n       result = pc.utf8_slice_codeunits(input, start=start, stop=stop, step=step)\r\n       assert expected.equals(result)\r\n   ```\r\n   \r\n   So libraries using this can implement the full Python behavior with this workaround.\r\n   \r\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-23T19:15:20.279+0000",
                    "updated": "2020-12-23T19:15:20.279+0000",
                    "started": "2020-12-23T19:15:20.279+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "527784",
                    "issueId": "13339965"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/worklog/527794",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #9000:\nURL: https://github.com/apache/arrow/pull/9000#issuecomment-750439841\n\n\n   https://issues.apache.org/jira/browse/ARROW-10557\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-23T19:25:17.748+0000",
                    "updated": "2020-12-23T19:25:17.748+0000",
                    "started": "2020-12-23T19:25:17.747+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "527794",
                    "issueId": "13339965"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/worklog/530630",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on pull request #9000:\nURL: https://github.com/apache/arrow/pull/9000#issuecomment-753949183\n\n\n   @pitrou this is ready for review\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-04T12:31:46.730+0000",
                    "updated": "2021-01-04T12:31:46.730+0000",
                    "started": "2021-01-04T12:31:46.729+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "530630",
                    "issueId": "13339965"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/worklog/530802",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #9000:\nURL: https://github.com/apache/arrow/pull/9000#issuecomment-754131925\n\n\n   > All edge cases detected by this are translated to the C++ unittest suite, so we could reduce them to reduce pytest execution cost (I added 1 second).\r\n   \r\n   You could instead use regular for loops instead of the pytest parametrization \"magic\". It would probably remove a lot of overhead.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-04T18:15:19.262+0000",
                    "updated": "2021-01-04T18:15:19.262+0000",
                    "started": "2021-01-04T18:15:19.262+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "530802",
                    "issueId": "13339965"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/worklog/530804",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #9000:\nURL: https://github.com/apache/arrow/pull/9000#issuecomment-754133254\n\n\n   I'll think I'll do a full review once the (lr)trim PR is merged, it will be easier.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-04T18:17:49.006+0000",
                    "updated": "2021-01-04T18:17:49.006+0000",
                    "started": "2021-01-04T18:17:49.005+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "530804",
                    "issueId": "13339965"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/worklog/548784",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on pull request #9000:\nURL: https://github.com/apache/arrow/pull/9000#issuecomment-774182240\n\n\n   \ud83d\udc4b checking back in here. The PR on which this was based has merged, so this can be rebased now\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-05T17:43:06.616+0000",
                    "updated": "2021-02-05T17:43:06.616+0000",
                    "started": "2021-02-05T17:43:06.616+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "548784",
                    "issueId": "13339965"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/worklog/565283",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on pull request #9000:\nURL: https://github.com/apache/arrow/pull/9000#issuecomment-797451974\n\n\n   @pitrou this is ready for review, the failure seems unrelated (minio)\r\n   \r\n   Sorry for taking so long to get back at this, I hope we can get this, and my other open string-PRs sorted out soon!\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-12T12:11:27.180+0000",
                    "updated": "2021-03-12T12:11:27.180+0000",
                    "started": "2021-03-12T12:11:27.179+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "565283",
                    "issueId": "13339965"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/worklog/567010",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #9000:\nURL: https://github.com/apache/arrow/pull/9000#discussion_r595224446\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -427,6 +427,189 @@ void AddMatchSubstring(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// Slicing\n+\n+template <typename Type, typename Derived>\n+struct SliceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<SliceOptions>;\n+  SliceOptions options;\n+\n+  explicit SliceBase(SliceOptions options) : options(options) {}\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    SliceOptions options = State::Get(ctx);\n+    if (options.step == 0) {\n+      ctx->SetStatus(Status::Invalid(\"Slice step cannot be zero\"));\n+      return;\n+    }\n+    Derived(options).Execute(ctx, batch, out);\n+  }\n+\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+#define PROPAGATE_FALSE(expr)         \\\n+  do {                                \\\n+    if (ARROW_PREDICT_FALSE(!expr)) { \\\n+      return false;                   \\\n+    }                                 \\\n+  } while (0)\n+\n+template <typename Type>\n+struct SliceCodeunits : SliceBase<Type, SliceCodeunits<Type>> {\n+  using Base = SliceBase<Type, SliceCodeunits<Type>>;\n+  using offset_type = typename Base::offset_type;\n+  using Base::Base;\n+\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* begin_sliced = begin;\n+    const uint8_t* end_sliced = end;\n+    SliceOptions& options = this->options;\n+\n+    if (options.step >= 1) {\n\nReview comment:\n       The combinatory explosion in `if` branches seems a bit gratuitous? Abstractly it seems you should be able to do:\r\n   ```c++\r\n   // Compute begin_sliced\r\n   if (options.start >= 0) {\r\n     PROPAGATE_FALSE(\r\n               arrow::util::UTF8AdvanceCodepoints(begin, end, &begin_sliced, options.start));\r\n   } else {\r\n     PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepointsReverse(\r\n               begin, end, &begin_sliced, -options.start));\r\n   }\r\n   // Compute end_sliced\r\n   if (options.stop >= 0) {\r\n     PROPAGATE_FALSE(\r\n               arrow::util::UTF8AdvanceCodepoints(begin, end, &end_sliced, options.stop));\r\n   } else {\r\n     PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepointsReverse(\r\n               begin, end, &end_sliced, -options.stop));\r\n   }\r\n   if (options.step > 0) {\r\n     if (end_sliced < begin_sliced) {\r\n       // empty slice\r\n       *output_written = 0;\r\n       return true;\r\n     }\r\n     // ...\r\n   }\r\n   else {\r\n     DCHECK_LT(options.step, 0);\r\n     if (end_sliced > begin_sliced) {\r\n       // empty slice\r\n       *output_written = 0;\r\n       return true;\r\n     }\r\n     // ...\r\n   }\r\n   ```\r\n   \n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string_test.cc\n##########\n@@ -462,6 +462,107 @@ TYPED_TEST(TestStringKernels, TrimUTF8) {\n }\n #endif\n \n+// produce test data with e.g.:\n+// repr([k[-3:1] for k in [\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\", \"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"]]).replace(\"'\", '\"')\n+\n+#ifdef ARROW_WITH_UTF8PROC\n+TYPED_TEST(TestStringKernels, SliceCodeunitsBasic) {\n+  SliceOptions options{2, 4};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"foo\", \"fo\", null, \"foo bar\"])\",\n+                   this->type(), R\"([\"o\", \"\", null, \"o \"])\", &options);\n+  SliceOptions options_2{2, 3};\n+  // ensure we slice in codeunits, not graphmemes\n\nReview comment:\n       \"graphemes\"\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -427,6 +427,189 @@ void AddMatchSubstring(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// Slicing\n+\n+template <typename Type, typename Derived>\n+struct SliceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<SliceOptions>;\n+  SliceOptions options;\n+\n+  explicit SliceBase(SliceOptions options) : options(options) {}\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    SliceOptions options = State::Get(ctx);\n+    if (options.step == 0) {\n+      ctx->SetStatus(Status::Invalid(\"Slice step cannot be zero\"));\n+      return;\n+    }\n+    Derived(options).Execute(ctx, batch, out);\n+  }\n+\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+#define PROPAGATE_FALSE(expr)         \\\n+  do {                                \\\n+    if (ARROW_PREDICT_FALSE(!expr)) { \\\n+      return false;                   \\\n+    }                                 \\\n+  } while (0)\n+\n+template <typename Type>\n+struct SliceCodeunits : SliceBase<Type, SliceCodeunits<Type>> {\n+  using Base = SliceBase<Type, SliceCodeunits<Type>>;\n+  using offset_type = typename Base::offset_type;\n+  using Base::Base;\n+\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* begin_sliced = begin;\n+    const uint8_t* end_sliced = end;\n+    SliceOptions& options = this->options;\n\nReview comment:\n       `const&`\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string_test.cc\n##########\n@@ -462,6 +462,107 @@ TYPED_TEST(TestStringKernels, TrimUTF8) {\n }\n #endif\n \n+// produce test data with e.g.:\n+// repr([k[-3:1] for k in [\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\", \"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"]]).replace(\"'\", '\"')\n+\n+#ifdef ARROW_WITH_UTF8PROC\n+TYPED_TEST(TestStringKernels, SliceCodeunitsBasic) {\n+  SliceOptions options{2, 4};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"foo\", \"fo\", null, \"foo bar\"])\",\n+                   this->type(), R\"([\"o\", \"\", null, \"o \"])\", &options);\n+  SliceOptions options_2{2, 3};\n+  // ensure we slice in codeunits, not graphmemes\n+  // a\\u0308 is a\u0308, which is 1 graphmeme (character), but two codepoints\n+  // \\u0308 in utf8 encoding is \\xcc\\x88\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"a\u0308a\u0308\", \"ba\u0308\"])\", this->type(),\n+                   \"[\\\"a\\\", \\\"\\xcc\\x88\\\"]\", &options_2);\n+  SliceOptions options_empty_pos{6, 6};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\u00f6\u00f5\"])\", this->type(), R\"([\"\",\n+  \"\"])\",\n+                   &options_empty_pos);\n+  SliceOptions options_empty_neg{-6, -6};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\u00f6\u00f5\"])\", this->type(), R\"([\"\",\n+  \"\"])\",\n+                   &options_empty_neg);\n+  SliceOptions options_empty_neg_to_zero{-6, 0};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\u00f6\u00f5\"])\", this->type(), R\"([\"\", \"\"])\",\n+                   &options_empty_neg_to_zero);\n+\n+  // end is beyond 0, but before start (hence empty)\n+  SliceOptions options_edgecase_1{-3, 1};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\", this->type(), R\"([\"\"])\",\n+                   &options_edgecase_1);\n+\n+  // this is a safeguard agains an optimization path possible, but actually a tricky case\n+  SliceOptions options_edgecase_2{-6, -2};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\", this->type(), R\"([\"\ud835\udc53\u00f6\u00f5\"])\",\n+                   &options_edgecase_2);\n+}\n+\n\nReview comment:\n       By the way, what happens if I call `utf8_slice_codeunits` without an options instance? Should you add a test for that?\n\n##########\nFile path: docs/source/cpp/compute.rst\n##########\n@@ -553,6 +553,25 @@ when a positive ``max_splits`` is given.\n   as separator.\n \n \n+Slicing\n+~~~~~~~\n+\n+These function transform each sequence of the array to a subsequence, following Python slicing semantics.\n+\n++--------------------------+------------+-------------------------+-------------------+----------------------------------+---------+\n+| Function name            | Arity      | Input types             | Output type       | Options class                    | Notes   |\n++==========================+============+=========================+===================+==================================+=========+\n+| utf8_slice_codepoints    | Unary      | String-like             | String-like         | :struct:`SliceOptions`         | \\(1)    |\n++--------------------------+------------+-------------------------+-------------------+----------------------------------+---------+\n+\n+\n+* \\(1) Slice string into a substring defined by (`start`, `stop`, `step`) as\n\nReview comment:\n       Need double-backticks in reST:\r\n   ```reST\r\n   * \\(1) Slice string into a substring defined by (``start``, ``stop``, ``step``) as\r\n   ```\n\n##########\nFile path: docs/source/cpp/compute.rst\n##########\n@@ -553,6 +553,25 @@ when a positive ``max_splits`` is given.\n   as separator.\n \n \n+Slicing\n+~~~~~~~\n+\n+These function transform each sequence of the array to a subsequence, following Python slicing semantics.\n+\n++--------------------------+------------+-------------------------+-------------------+----------------------------------+---------+\n+| Function name            | Arity      | Input types             | Output type       | Options class                    | Notes   |\n++==========================+============+=========================+===================+==================================+=========+\n+| utf8_slice_codepoints    | Unary      | String-like             | String-like         | :struct:`SliceOptions`         | \\(1)    |\n++--------------------------+------------+-------------------------+-------------------+----------------------------------+---------+\n+\n+\n+* \\(1) Slice string into a substring defined by (`start`, `stop`, `step`) as\n+given by `SliceOptions` where `start` is inclusive and `stop` is exclusive and\n\nReview comment:\n       Must probably indent these lines to be part of the bullet item (you can click \"view file\" to get a reST rendering in the Github UI).\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -427,6 +427,189 @@ void AddMatchSubstring(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// Slicing\n+\n+template <typename Type, typename Derived>\n+struct SliceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<SliceOptions>;\n+  SliceOptions options;\n+\n+  explicit SliceBase(SliceOptions options) : options(options) {}\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    SliceOptions options = State::Get(ctx);\n+    if (options.step == 0) {\n+      ctx->SetStatus(Status::Invalid(\"Slice step cannot be zero\"));\n+      return;\n+    }\n+    Derived(options).Execute(ctx, batch, out);\n+  }\n+\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+#define PROPAGATE_FALSE(expr)         \\\n+  do {                                \\\n+    if (ARROW_PREDICT_FALSE(!expr)) { \\\n+      return false;                   \\\n+    }                                 \\\n+  } while (0)\n+\n+template <typename Type>\n+struct SliceCodeunits : SliceBase<Type, SliceCodeunits<Type>> {\n+  using Base = SliceBase<Type, SliceCodeunits<Type>>;\n+  using offset_type = typename Base::offset_type;\n+  using Base::Base;\n+\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* begin_sliced = begin;\n+    const uint8_t* end_sliced = end;\n+    SliceOptions& options = this->options;\n+\n+    if (options.step >= 1) {\n+      if (options.start >= 0) {\n+        // start counting from the left\n+        PROPAGATE_FALSE(\n+            arrow::util::UTF8AdvanceCodepoints(begin, end, &begin_sliced, options.start));\n+        if (options.stop > options.start) {\n+          // continue counting from begin_sliced\n+          int64_t length = options.stop - options.start;\n+          PROPAGATE_FALSE(\n+              arrow::util::UTF8AdvanceCodepoints(begin_sliced, end, &end_sliced, length));\n+        } else if (options.stop < 0) {\n+          // or from the end (but we will never need to < begin_sliced)\n+          PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepointsReverse(\n+              begin_sliced, end, &end_sliced, -options.stop));\n+        } else {\n+          // zero length slice\n+          *output_written = 0;\n+          return true;\n+        }\n+      } else {\n+        // start counting from the right\n+        PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepointsReverse(\n+            begin, end, &begin_sliced, -options.start));\n+        if (options.stop > 0) {\n+          // continue counting from the left, we cannot start from begin_sliced because we\n+          // don't know how many codepoints are between begin and begin_sliced\n+          PROPAGATE_FALSE(\n+              arrow::util::UTF8AdvanceCodepoints(begin, end, &end_sliced, options.stop));\n+          // and therefore we also needs this\n+          if (end_sliced <= begin_sliced) {\n+            // zero length slice\n+            *output_written = 0;\n+            return true;\n+          }\n+        } else if ((options.stop < 0) && (options.stop > options.start)) {\n+          // stop is negative, but larger than start, so we count again from the right\n+          // in some cases we can optimize this, depending on the shortest path (from end\n+          // or begin_sliced), but begin_sliced and options.start can be 'out of sync',\n+          // for instance when start=-100, when the string length is only 10.\n+          PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepointsReverse(\n+              begin_sliced, end, &end_sliced, -options.stop));\n+        } else {\n+          // zero length slice\n+          *output_written = 0;\n+          return true;\n+        }\n+      }\n+      DCHECK(begin_sliced <= end_sliced);\n+      if (options.step == 1) {\n+        // fast case, where we simply can finish with a memcpy\n+        std::copy(begin_sliced, end_sliced, output);\n+        *output_written = static_cast<offset_type>(end_sliced - begin_sliced);\n+      } else {\n+        uint8_t* dest = output;\n+        const uint8_t* i = begin_sliced;\n+\n+        while (i < end_sliced) {\n+          uint32_t codepoint = 0;\n+          // write a single codepoint\n+          PROPAGATE_FALSE(arrow::util::UTF8Decode(&i, &codepoint));\n+          dest = arrow::util::UTF8Encode(dest, codepoint);\n+          // and skip the remainder\n+          int64_t skips = options.step - 1;\n+          while ((skips--) && (i < end_sliced)) {\n+            PROPAGATE_FALSE(arrow::util::UTF8Decode(&i, &codepoint));\n+          }\n+        }\n+        *output_written = static_cast<offset_type>(dest - output);\n+      }\n+      return true;\n+    } else {  // step < 0\n+      // serious +1 -1 kung fu because now begin_slice and end_slice act like reverse\n+      // iterators.\n+\n+      if (options.start >= 0) {\n+        // +1 because begin_sliced acts as as the end of a reverse iterator\n+        PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepoints(begin, end, &begin_sliced,\n+                                                           options.start + 1));\n+        // and make it point at the last codeunit of the previous codeunit\n+        begin_sliced--;\n+      } else {\n+        // -1 because start=-1 means the last codeunit, which is 0 advances\n+        PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepointsReverse(\n+            begin, end, &begin_sliced, -options.start - 1));\n+        // and make it point at the last codeunit of the previous codeunit\n+        begin_sliced--;\n+      }\n+      // similar to options.start\n+      if (options.stop >= 0) {\n+        PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepoints(begin, end, &end_sliced,\n+                                                           options.stop + 1));\n+        end_sliced--;\n+      } else {\n+        PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepointsReverse(begin, end, &end_sliced,\n+                                                                  -options.stop - 1));\n+        end_sliced--;\n+      }\n+\n+      uint8_t* dest = output;\n+      const uint8_t* i = begin_sliced;\n+\n+      while (i > end_sliced) {\n+        uint32_t codepoint = 0;\n+        // write a single codepoint\n+        PROPAGATE_FALSE(arrow::util::UTF8DecodeReverse(&i, &codepoint));\n+        dest = arrow::util::UTF8Encode(dest, codepoint);\n+        // and skip the remainder\n+        int64_t skips = -options.step - 1;\n+        while ((skips--) && (i > end_sliced)) {\n+          PROPAGATE_FALSE(arrow::util::UTF8DecodeReverse(&i, &codepoint));\n+        }\n+      }\n+      *output_written = static_cast<offset_type>(dest - output);\n+      return true;\n+    }\n+  }\n+};\n+\n+const FunctionDoc utf8_slice_codeunits_doc(\n+    \"Slice string \",\n+    (\"For each string in `strings`, slice into a substring defined by\\n\"\n+     \"`start`, `stop`, `step`) as given by `SliceOptions` where `start` is inclusive\\n\"\n+     \"and `stop` is exclusive and are measured in codeunits. If step is negative, the\\n\"\n+     \"string will be advanced in reversed order. A `step` of zero is considered an\\n\"\n+     \"error.\\n\"\n+     \"Null inputs emit null.\"),\n+    {\"strings\"}, \"SliceOptions\");\n+\n+void AddSlice(FunctionRegistry* registry) {\n\nReview comment:\n       Is there a reason we don't also add a `ascii_slice` for binary and string?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string_test.cc\n##########\n@@ -462,6 +462,107 @@ TYPED_TEST(TestStringKernels, TrimUTF8) {\n }\n #endif\n \n+// produce test data with e.g.:\n+// repr([k[-3:1] for k in [\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\", \"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"]]).replace(\"'\", '\"')\n+\n+#ifdef ARROW_WITH_UTF8PROC\n+TYPED_TEST(TestStringKernels, SliceCodeunitsBasic) {\n+  SliceOptions options{2, 4};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"foo\", \"fo\", null, \"foo bar\"])\",\n+                   this->type(), R\"([\"o\", \"\", null, \"o \"])\", &options);\n+  SliceOptions options_2{2, 3};\n+  // ensure we slice in codeunits, not graphmemes\n+  // a\\u0308 is a\u0308, which is 1 graphmeme (character), but two codepoints\n+  // \\u0308 in utf8 encoding is \\xcc\\x88\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"a\u0308a\u0308\", \"ba\u0308\"])\", this->type(),\n+                   \"[\\\"a\\\", \\\"\\xcc\\x88\\\"]\", &options_2);\n+  SliceOptions options_empty_pos{6, 6};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\u00f6\u00f5\"])\", this->type(), R\"([\"\",\n+  \"\"])\",\n+                   &options_empty_pos);\n+  SliceOptions options_empty_neg{-6, -6};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\u00f6\u00f5\"])\", this->type(), R\"([\"\",\n+  \"\"])\",\n+                   &options_empty_neg);\n+  SliceOptions options_empty_neg_to_zero{-6, 0};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\u00f6\u00f5\"])\", this->type(), R\"([\"\", \"\"])\",\n+                   &options_empty_neg_to_zero);\n+\n+  // end is beyond 0, but before start (hence empty)\n+  SliceOptions options_edgecase_1{-3, 1};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\", this->type(), R\"([\"\"])\",\n+                   &options_edgecase_1);\n+\n+  // this is a safeguard agains an optimization path possible, but actually a tricky case\n+  SliceOptions options_edgecase_2{-6, -2};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\", this->type(), R\"([\"\ud835\udc53\u00f6\u00f5\"])\",\n+                   &options_edgecase_2);\n+}\n+\n+TYPED_TEST(TestStringKernels, SliceCodeunitsPosPos) {\n+  SliceOptions options{2, 4};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\", \"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\",\n+                   this->type(), R\"([\"\", \"\", \"\", \"\u00f5\", \"\u00f5\u1e0d\", \"\u00f5\u1e0d\"])\", &options);\n+  SliceOptions options_step{1, 5, 2};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\", \"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\",\n+                   this->type(), R\"([\"\", \"\", \"\u00f6\", \"\u00f6\", \"\u00f6\u1e0d\", \"\u00f6\u1e0d\"])\", &options_step);\n+  SliceOptions options_step_neg{5, 1, -2};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\", \"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\",\n+                   this->type(), R\"([\"\", \"\", \"\", \"\u00f5\", \"\u1e0d\", \"\u0161\u00f5\"])\", &options_step_neg);\n+  options_step_neg.stop = 0;\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\",\"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\",\n+                   this->type(), R\"([\"\", \"\", \"\u00f6\", \"\u00f5\", \"\u1e0d\u00f6\", \"\u0161\u00f5\"])\", &options_step_neg);\n+}\n+\n+TYPED_TEST(TestStringKernels, SliceCodeunitsPosNeg) {\n+  SliceOptions options{2, -1};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\", \"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\",\n+                   this->type(), R\"([\"\", \"\", \"\", \"\", \"\u00f5\", \"\u00f5\u1e0d\"])\", &options);\n+  SliceOptions options_step{1, -1, 2};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"f\", \"f\u00f6\", \"f\u00f6o\", \"f\u00f6od\",\"food\u0161\"])\",\n+                   this->type(), R\"([\"\", \"\", \"\", \"\u00f6\", \"\u00f6\", \"od\"])\", &options_step);\n+  SliceOptions options_step_neg{3, -4, -2};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\",\"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\",\n+                   this->type(), R\"([\"\", \"\ud835\udc53\", \"\u00f6\", \"\u00f5\ud835\udc53\", \"\u1e0d\u00f6\", \"\u1e0d\"])\", &options_step_neg);\n+  options_step_neg.stop = -5;\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\",\"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\",\n+                   this->type(), R\"([\"\", \"\ud835\udc53\", \"\u00f6\", \"\u00f5\ud835\udc53\", \"\u1e0d\u00f6\", \"\u1e0d\u00f6\"])\",\n+                   &options_step_neg);\n+}\n+\n+TYPED_TEST(TestStringKernels, SliceCodeunitsNegNeg) {\n+  SliceOptions options{-2, -1};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\", \"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\",\n+                   this->type(), R\"([\"\", \"\", \"\ud835\udc53\", \"\u00f6\", \"\u00f5\", \"\u1e0d\"])\", &options);\n+  SliceOptions options_step{-4, -1, 2};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\", \"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\",\n+                   this->type(), R\"([\"\", \"\", \"\ud835\udc53\", \"\ud835\udc53\", \"\ud835\udc53\u00f5\", \"\u00f6\u1e0d\"])\", &options_step);\n+  SliceOptions options_step_neg{-1, -3, -2};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\", \"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\",\n+                   this->type(), R\"([\"\", \"\ud835\udc53\", \"\u00f6\", \"\u00f5\", \"\u1e0d\", \"\u0161\"])\", &options_step_neg);\n+  options_step_neg.stop = -4;\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\", \"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\",\n+                   this->type(), R\"([\"\", \"\ud835\udc53\", \"\u00f6\", \"\u00f5\ud835\udc53\", \"\u1e0d\u00f6\", \"\u0161\u00f5\"])\",\n+                   &options_step_neg);\n+}\n+\n+TYPED_TEST(TestStringKernels, SliceCodeunitsNegPos) {\n+  SliceOptions options{-2, 4};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\", \"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\",\n+                   this->type(), R\"([\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\u00f6\u00f5\", \"\u00f5\u1e0d\", \"\u1e0d\"])\", &options);\n+  SliceOptions options_step{-4, 4, 2};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\", \"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\",\n+                   this->type(), R\"([\"\", \"\ud835\udc53\", \"\ud835\udc53\", \"\ud835\udc53\u00f5\", \"\ud835\udc53\u00f5\", \"\u00f6\u1e0d\"])\", &options_step);\n+  SliceOptions options_step_neg{-1, 1, -2};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\", \"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\",\n+                   this->type(), R\"([\"\", \"\", \"\", \"\u00f5\", \"\u1e0d\", \"\u0161\u00f5\"])\", &options_step_neg);\n+  options_step_neg.stop = 0;\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\", \"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\",\n+                   this->type(), R\"([\"\", \"\", \"\u00f6\", \"\u00f5\", \"\u1e0d\u00f6\", \"\u0161\u00f5\"])\", &options_step_neg);\n+}\n+\n\nReview comment:\n       Nice tests, thank you!\n\n##########\nFile path: docs/source/cpp/compute.rst\n##########\n@@ -553,6 +553,25 @@ when a positive ``max_splits`` is given.\n   as separator.\n \n \n+Slicing\n+~~~~~~~\n+\n+These function transform each sequence of the array to a subsequence, following Python slicing semantics.\n+\n++--------------------------+------------+-------------------------+-------------------+----------------------------------+---------+\n+| Function name            | Arity      | Input types             | Output type       | Options class                    | Notes   |\n++==========================+============+=========================+===================+==================================+=========+\n+| utf8_slice_codepoints    | Unary      | String-like             | String-like         | :struct:`SliceOptions`         | \\(1)    |\n\nReview comment:\n       There is a slight alignment bug in your reST markup here.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -427,6 +427,189 @@ void AddMatchSubstring(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// Slicing\n+\n+template <typename Type, typename Derived>\n+struct SliceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<SliceOptions>;\n+  SliceOptions options;\n+\n+  explicit SliceBase(SliceOptions options) : options(options) {}\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    SliceOptions options = State::Get(ctx);\n+    if (options.step == 0) {\n+      ctx->SetStatus(Status::Invalid(\"Slice step cannot be zero\"));\n+      return;\n+    }\n+    Derived(options).Execute(ctx, batch, out);\n+  }\n+\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+#define PROPAGATE_FALSE(expr)         \\\n+  do {                                \\\n+    if (ARROW_PREDICT_FALSE(!expr)) { \\\n+      return false;                   \\\n+    }                                 \\\n+  } while (0)\n+\n+template <typename Type>\n+struct SliceCodeunits : SliceBase<Type, SliceCodeunits<Type>> {\n+  using Base = SliceBase<Type, SliceCodeunits<Type>>;\n+  using offset_type = typename Base::offset_type;\n+  using Base::Base;\n+\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n\nReview comment:\n       Note that most of this function is really identical regardless of the offset type. So instead you could define a `Utf8SliceBase` base class:\r\n   ```c++\r\n   struct Utf8SliceBase {\r\n     bool Transform(const uint8_t* input, int64_t input_string_ncodeunits,\r\n                    uint8_t* output, int64_t* output_written) {\r\n       // ...\r\n     }\r\n   };\r\n   ```\r\n   ... and inherit from that mixin class in concrete classes:\r\n   ```c++\r\n   template <typename Type>\r\n   struct SliceCodeunits : SliceBase<Type, SliceCodeunits<Type>>, Utf8SliceBase {\r\n     using Base = SliceBase<Type, SliceCodeunits<Type>>;\r\n     using offset_type = typename Base::offset_type;\r\n     using Base::Base;\r\n   \r\n     bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\r\n                    uint8_t* output, offset_type* output_written) {\r\n       int64_t output_written_64;\r\n       bool res = Utf8SliceBase::Transform(input, input_string_ncodeunits, output, &output_written_64);\r\n       *output_written = static_cast<offset_type>(output_written_64);\r\n       return res;\r\n     }\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-16T14:43:30.994+0000",
                    "updated": "2021-03-16T14:43:30.994+0000",
                    "started": "2021-03-16T14:43:30.994+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "567010",
                    "issueId": "13339965"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/worklog/572559",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on a change in pull request #9000:\nURL: https://github.com/apache/arrow/pull/9000#discussion_r602134300\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -427,6 +427,189 @@ void AddMatchSubstring(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// Slicing\n+\n+template <typename Type, typename Derived>\n+struct SliceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<SliceOptions>;\n+  SliceOptions options;\n+\n+  explicit SliceBase(SliceOptions options) : options(options) {}\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    SliceOptions options = State::Get(ctx);\n+    if (options.step == 0) {\n+      ctx->SetStatus(Status::Invalid(\"Slice step cannot be zero\"));\n+      return;\n+    }\n+    Derived(options).Execute(ctx, batch, out);\n+  }\n+\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+#define PROPAGATE_FALSE(expr)         \\\n+  do {                                \\\n+    if (ARROW_PREDICT_FALSE(!expr)) { \\\n+      return false;                   \\\n+    }                                 \\\n+  } while (0)\n+\n+template <typename Type>\n+struct SliceCodeunits : SliceBase<Type, SliceCodeunits<Type>> {\n+  using Base = SliceBase<Type, SliceCodeunits<Type>>;\n+  using offset_type = typename Base::offset_type;\n+  using Base::Base;\n+\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* begin_sliced = begin;\n+    const uint8_t* end_sliced = end;\n+    SliceOptions& options = this->options;\n+\n+    if (options.step >= 1) {\n+      if (options.start >= 0) {\n+        // start counting from the left\n+        PROPAGATE_FALSE(\n+            arrow::util::UTF8AdvanceCodepoints(begin, end, &begin_sliced, options.start));\n+        if (options.stop > options.start) {\n+          // continue counting from begin_sliced\n+          int64_t length = options.stop - options.start;\n+          PROPAGATE_FALSE(\n+              arrow::util::UTF8AdvanceCodepoints(begin_sliced, end, &end_sliced, length));\n+        } else if (options.stop < 0) {\n+          // or from the end (but we will never need to < begin_sliced)\n+          PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepointsReverse(\n+              begin_sliced, end, &end_sliced, -options.stop));\n+        } else {\n+          // zero length slice\n+          *output_written = 0;\n+          return true;\n+        }\n+      } else {\n+        // start counting from the right\n+        PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepointsReverse(\n+            begin, end, &begin_sliced, -options.start));\n+        if (options.stop > 0) {\n+          // continue counting from the left, we cannot start from begin_sliced because we\n+          // don't know how many codepoints are between begin and begin_sliced\n+          PROPAGATE_FALSE(\n+              arrow::util::UTF8AdvanceCodepoints(begin, end, &end_sliced, options.stop));\n+          // and therefore we also needs this\n+          if (end_sliced <= begin_sliced) {\n+            // zero length slice\n+            *output_written = 0;\n+            return true;\n+          }\n+        } else if ((options.stop < 0) && (options.stop > options.start)) {\n+          // stop is negative, but larger than start, so we count again from the right\n+          // in some cases we can optimize this, depending on the shortest path (from end\n+          // or begin_sliced), but begin_sliced and options.start can be 'out of sync',\n+          // for instance when start=-100, when the string length is only 10.\n+          PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepointsReverse(\n+              begin_sliced, end, &end_sliced, -options.stop));\n+        } else {\n+          // zero length slice\n+          *output_written = 0;\n+          return true;\n+        }\n+      }\n+      DCHECK(begin_sliced <= end_sliced);\n+      if (options.step == 1) {\n+        // fast case, where we simply can finish with a memcpy\n+        std::copy(begin_sliced, end_sliced, output);\n+        *output_written = static_cast<offset_type>(end_sliced - begin_sliced);\n+      } else {\n+        uint8_t* dest = output;\n+        const uint8_t* i = begin_sliced;\n+\n+        while (i < end_sliced) {\n+          uint32_t codepoint = 0;\n+          // write a single codepoint\n+          PROPAGATE_FALSE(arrow::util::UTF8Decode(&i, &codepoint));\n+          dest = arrow::util::UTF8Encode(dest, codepoint);\n+          // and skip the remainder\n+          int64_t skips = options.step - 1;\n+          while ((skips--) && (i < end_sliced)) {\n+            PROPAGATE_FALSE(arrow::util::UTF8Decode(&i, &codepoint));\n+          }\n+        }\n+        *output_written = static_cast<offset_type>(dest - output);\n+      }\n+      return true;\n+    } else {  // step < 0\n+      // serious +1 -1 kung fu because now begin_slice and end_slice act like reverse\n+      // iterators.\n+\n+      if (options.start >= 0) {\n+        // +1 because begin_sliced acts as as the end of a reverse iterator\n+        PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepoints(begin, end, &begin_sliced,\n+                                                           options.start + 1));\n+        // and make it point at the last codeunit of the previous codeunit\n+        begin_sliced--;\n+      } else {\n+        // -1 because start=-1 means the last codeunit, which is 0 advances\n+        PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepointsReverse(\n+            begin, end, &begin_sliced, -options.start - 1));\n+        // and make it point at the last codeunit of the previous codeunit\n+        begin_sliced--;\n+      }\n+      // similar to options.start\n+      if (options.stop >= 0) {\n+        PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepoints(begin, end, &end_sliced,\n+                                                           options.stop + 1));\n+        end_sliced--;\n+      } else {\n+        PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepointsReverse(begin, end, &end_sliced,\n+                                                                  -options.stop - 1));\n+        end_sliced--;\n+      }\n+\n+      uint8_t* dest = output;\n+      const uint8_t* i = begin_sliced;\n+\n+      while (i > end_sliced) {\n+        uint32_t codepoint = 0;\n+        // write a single codepoint\n+        PROPAGATE_FALSE(arrow::util::UTF8DecodeReverse(&i, &codepoint));\n+        dest = arrow::util::UTF8Encode(dest, codepoint);\n+        // and skip the remainder\n+        int64_t skips = -options.step - 1;\n+        while ((skips--) && (i > end_sliced)) {\n+          PROPAGATE_FALSE(arrow::util::UTF8DecodeReverse(&i, &codepoint));\n+        }\n+      }\n+      *output_written = static_cast<offset_type>(dest - output);\n+      return true;\n+    }\n+  }\n+};\n+\n+const FunctionDoc utf8_slice_codeunits_doc(\n+    \"Slice string \",\n+    (\"For each string in `strings`, slice into a substring defined by\\n\"\n+     \"`start`, `stop`, `step`) as given by `SliceOptions` where `start` is inclusive\\n\"\n+     \"and `stop` is exclusive and are measured in codeunits. If step is negative, the\\n\"\n+     \"string will be advanced in reversed order. A `step` of zero is considered an\\n\"\n+     \"error.\\n\"\n+     \"Null inputs emit null.\"),\n+    {\"strings\"}, \"SliceOptions\");\n+\n+void AddSlice(FunctionRegistry* registry) {\n\nReview comment:\n       No, just focussing on the harder problems first. \n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -427,6 +427,189 @@ void AddMatchSubstring(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// Slicing\n+\n+template <typename Type, typename Derived>\n+struct SliceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<SliceOptions>;\n+  SliceOptions options;\n+\n+  explicit SliceBase(SliceOptions options) : options(options) {}\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    SliceOptions options = State::Get(ctx);\n+    if (options.step == 0) {\n+      ctx->SetStatus(Status::Invalid(\"Slice step cannot be zero\"));\n+      return;\n+    }\n+    Derived(options).Execute(ctx, batch, out);\n+  }\n+\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+#define PROPAGATE_FALSE(expr)         \\\n+  do {                                \\\n+    if (ARROW_PREDICT_FALSE(!expr)) { \\\n+      return false;                   \\\n+    }                                 \\\n+  } while (0)\n+\n+template <typename Type>\n+struct SliceCodeunits : SliceBase<Type, SliceCodeunits<Type>> {\n+  using Base = SliceBase<Type, SliceCodeunits<Type>>;\n+  using offset_type = typename Base::offset_type;\n+  using Base::Base;\n+\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* begin_sliced = begin;\n+    const uint8_t* end_sliced = end;\n+    SliceOptions& options = this->options;\n+\n+    if (options.step >= 1) {\n\nReview comment:\n       The idea is that you don't start counting from the beginning or end twice when possible, e.g. if you do slice from -6 to -5, it's faster to not start counting code points from the end twice. It increases code complexity, that's the payoff.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -427,6 +427,189 @@ void AddMatchSubstring(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// Slicing\n+\n+template <typename Type, typename Derived>\n+struct SliceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<SliceOptions>;\n+  SliceOptions options;\n+\n+  explicit SliceBase(SliceOptions options) : options(options) {}\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    SliceOptions options = State::Get(ctx);\n+    if (options.step == 0) {\n+      ctx->SetStatus(Status::Invalid(\"Slice step cannot be zero\"));\n+      return;\n+    }\n+    Derived(options).Execute(ctx, batch, out);\n+  }\n+\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+#define PROPAGATE_FALSE(expr)         \\\n+  do {                                \\\n+    if (ARROW_PREDICT_FALSE(!expr)) { \\\n+      return false;                   \\\n+    }                                 \\\n+  } while (0)\n+\n+template <typename Type>\n+struct SliceCodeunits : SliceBase<Type, SliceCodeunits<Type>> {\n+  using Base = SliceBase<Type, SliceCodeunits<Type>>;\n+  using offset_type = typename Base::offset_type;\n+  using Base::Base;\n+\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n\nReview comment:\n       Yes, good catch. Put it in a function now.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-26T09:31:24.836+0000",
                    "updated": "2021-03-26T09:31:24.836+0000",
                    "started": "2021-03-26T09:31:24.836+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "572559",
                    "issueId": "13339965"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/worklog/572616",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on pull request #9000:\nURL: https://github.com/apache/arrow/pull/9000#issuecomment-808133974\n\n\n   Failure seems unrelated: `npm WARN tar ENOSPC: no space left on device, write`\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-26T11:20:19.061+0000",
                    "updated": "2021-03-26T11:20:19.061+0000",
                    "started": "2021-03-26T11:20:19.060+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "572616",
                    "issueId": "13339965"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/worklog/580299",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on pull request #9000:\nURL: https://github.com/apache/arrow/pull/9000#issuecomment-816951310\n\n\n   @pitrou @maartenbreddels is this ready to merge? Trying to mop up issues for 4.0\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-09T20:22:39.198+0000",
                    "updated": "2021-04-09T20:22:39.198+0000",
                    "started": "2021-04-09T20:22:39.197+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "580299",
                    "issueId": "13339965"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/worklog/581052",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #9000:\nURL: https://github.com/apache/arrow/pull/9000#issuecomment-817870808\n\n\n   @nealrichardson I need to review this again, sorry.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-12T14:42:46.375+0000",
                    "updated": "2021-04-12T14:42:46.375+0000",
                    "started": "2021-04-12T14:42:46.375+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "581052",
                    "issueId": "13339965"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/worklog/581083",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #9000:\nURL: https://github.com/apache/arrow/pull/9000#discussion_r611727515\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -447,6 +447,197 @@ void AddMatchSubstring(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// Slicing\n+\n+template <typename Type, typename Derived>\n+struct SliceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<SliceOptions>;\n+  SliceOptions options;\n+\n+  explicit SliceBase(SliceOptions options) : options(options) {}\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    SliceOptions options = State::Get(ctx);\n+    if (options.step == 0) {\n+      ctx->SetStatus(Status::Invalid(\"Slice step cannot be zero\"));\n+      return;\n+    }\n+    Derived(options).Execute(ctx, batch, out);\n+  }\n+\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+#define PROPAGATE_FALSE(expr)         \\\n\nReview comment:\n       Can you `#undef` this at the end?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -447,6 +447,197 @@ void AddMatchSubstring(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// Slicing\n+\n+template <typename Type, typename Derived>\n+struct SliceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<SliceOptions>;\n+  SliceOptions options;\n+\n+  explicit SliceBase(SliceOptions options) : options(options) {}\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    SliceOptions options = State::Get(ctx);\n+    if (options.step == 0) {\n+      ctx->SetStatus(Status::Invalid(\"Slice step cannot be zero\"));\n+      return;\n+    }\n+    Derived(options).Execute(ctx, batch, out);\n+  }\n+\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+#define PROPAGATE_FALSE(expr)         \\\n+  do {                                \\\n+    if (ARROW_PREDICT_FALSE(!expr)) { \\\n+      return false;                   \\\n+    }                                 \\\n+  } while (0)\n+\n+bool SliceCodeunitsTransform(const uint8_t* input, int64_t input_string_ncodeunits,\n+                             uint8_t* output, int64_t* output_written,\n+                             const SliceOptions& options) {\n+  const uint8_t* begin = input;\n+  const uint8_t* end = input + input_string_ncodeunits;\n+  const uint8_t* begin_sliced = begin;\n+  const uint8_t* end_sliced = end;\n+\n+  if (options.step >= 1) {\n+    if (options.start >= 0) {\n+      // start counting from the left\n+      PROPAGATE_FALSE(\n+          arrow::util::UTF8AdvanceCodepoints(begin, end, &begin_sliced, options.start));\n+      if (options.stop > options.start) {\n+        // continue counting from begin_sliced\n+        int64_t length = options.stop - options.start;\n+        PROPAGATE_FALSE(\n+            arrow::util::UTF8AdvanceCodepoints(begin_sliced, end, &end_sliced, length));\n+      } else if (options.stop < 0) {\n+        // or from the end (but we will never need to < begin_sliced)\n+        PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepointsReverse(\n+            begin_sliced, end, &end_sliced, -options.stop));\n+      } else {\n+        // zero length slice\n+        *output_written = 0;\n+        return true;\n+      }\n+    } else {\n+      // start counting from the right\n+      PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepointsReverse(begin, end, &begin_sliced,\n+                                                                -options.start));\n+      if (options.stop > 0) {\n+        // continue counting from the left, we cannot start from begin_sliced because we\n+        // don't know how many codepoints are between begin and begin_sliced\n\nReview comment:\n       Hmm... for `step < 0`, wouldn't it be more logical to first compute `end_sliced`? Presumably, you then can pass `end_sliced` as one of the boundaries for computing `begin_sliced`?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string_test.cc\n##########\n@@ -522,6 +522,113 @@ TYPED_TEST(TestStringKernels, TrimUTF8) {\n }\n #endif\n \n+// produce test data with e.g.:\n+// repr([k[-3:1] for k in [\"\", \"\ud835\udc53\", \"\ud835\udc53\u00f6\", \"\ud835\udc53\u00f6\u00f5\", \"\ud835\udc53\u00f6\u00f5\u1e0d\", \"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"]]).replace(\"'\", '\"')\n+\n+#ifdef ARROW_WITH_UTF8PROC\n+TYPED_TEST(TestStringKernels, SliceCodeunitsBasic) {\n+  SliceOptions options{2, 4};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"foo\", \"fo\", null, \"foo bar\"])\",\n+                   this->type(), R\"([\"o\", \"\", null, \"o \"])\", &options);\n+  SliceOptions options_2{2, 3};\n+  // ensure we slice in codeunits, not graphemes\n+  // a\\u0308 is a\u0308, which is 1 grapheme (character), but two codepoints\n+  // \\u0308 in utf8 encoding is \\xcc\\x88\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"a\u0308a\u0308\", \"ba\u0308\"])\", this->type(),\n+                   \"[\\\"a\\\", \\\"\\xcc\\x88\\\"]\", &options_2);\n+  SliceOptions options_empty_pos{6, 6};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\u00f6\u00f5\"])\", this->type(), R\"([\"\",\n+  \"\"])\",\n+                   &options_empty_pos);\n+  SliceOptions options_empty_neg{-6, -6};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\u00f6\u00f5\"])\", this->type(), R\"([\"\",\n+  \"\"])\",\n+                   &options_empty_neg);\n+  SliceOptions options_empty_neg_to_zero{-6, 0};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\", \"\ud835\udc53\u00f6\u00f5\"])\", this->type(), R\"([\"\", \"\"])\",\n+                   &options_empty_neg_to_zero);\n+\n+  // end is beyond 0, but before start (hence empty)\n+  SliceOptions options_edgecase_1{-3, 1};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\", this->type(), R\"([\"\"])\",\n+                   &options_edgecase_1);\n+\n+  // this is a safeguard agains an optimization path possible, but actually a tricky case\n+  SliceOptions options_edgecase_2{-6, -2};\n+  this->CheckUnary(\"utf8_slice_codeunits\", R\"([\"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\", this->type(), R\"([\"\ud835\udc53\u00f6\u00f5\"])\",\n+                   &options_edgecase_2);\n+\n+  auto input = ArrayFromJSON(this->type(), R\"([\"\ud835\udc53\u00f6\u00f5\u1e0d\u0161\"])\");\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid,\n+      testing::HasSubstr(\"Attempted to initialize KernelState from null FunctionOptions\"),\n+      CallFunction(\"utf8_slice_codeunits\", {input}));\n+}\n\nReview comment:\n       Also add a test with `stop = 0`?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -447,6 +447,197 @@ void AddMatchSubstring(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::move(func)));\n }\n \n+// Slicing\n+\n+template <typename Type, typename Derived>\n+struct SliceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<SliceOptions>;\n+  SliceOptions options;\n+\n+  explicit SliceBase(SliceOptions options) : options(options) {}\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    SliceOptions options = State::Get(ctx);\n+    if (options.step == 0) {\n+      ctx->SetStatus(Status::Invalid(\"Slice step cannot be zero\"));\n+      return;\n+    }\n+    Derived(options).Execute(ctx, batch, out);\n+  }\n+\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+#define PROPAGATE_FALSE(expr)         \\\n+  do {                                \\\n+    if (ARROW_PREDICT_FALSE(!expr)) { \\\n+      return false;                   \\\n+    }                                 \\\n+  } while (0)\n+\n+bool SliceCodeunitsTransform(const uint8_t* input, int64_t input_string_ncodeunits,\n+                             uint8_t* output, int64_t* output_written,\n+                             const SliceOptions& options) {\n+  const uint8_t* begin = input;\n+  const uint8_t* end = input + input_string_ncodeunits;\n+  const uint8_t* begin_sliced = begin;\n+  const uint8_t* end_sliced = end;\n+\n+  if (options.step >= 1) {\n+    if (options.start >= 0) {\n+      // start counting from the left\n+      PROPAGATE_FALSE(\n+          arrow::util::UTF8AdvanceCodepoints(begin, end, &begin_sliced, options.start));\n+      if (options.stop > options.start) {\n+        // continue counting from begin_sliced\n+        int64_t length = options.stop - options.start;\n+        PROPAGATE_FALSE(\n+            arrow::util::UTF8AdvanceCodepoints(begin_sliced, end, &end_sliced, length));\n+      } else if (options.stop < 0) {\n+        // or from the end (but we will never need to < begin_sliced)\n+        PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepointsReverse(\n+            begin_sliced, end, &end_sliced, -options.stop));\n+      } else {\n+        // zero length slice\n+        *output_written = 0;\n+        return true;\n+      }\n+    } else {\n+      // start counting from the right\n+      PROPAGATE_FALSE(arrow::util::UTF8AdvanceCodepointsReverse(begin, end, &begin_sliced,\n+                                                                -options.start));\n+      if (options.stop > 0) {\n+        // continue counting from the left, we cannot start from begin_sliced because we\n+        // don't know how many codepoints are between begin and begin_sliced\n\nReview comment:\n       Just a question btw, you don't need to act on this if you think it's unnecessary.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-12T15:25:26.228+0000",
                    "updated": "2021-04-12T15:25:26.228+0000",
                    "started": "2021-04-12T15:25:26.228+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "581083",
                    "issueId": "13339965"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/worklog/594064",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #9000:\nURL: https://github.com/apache/arrow/pull/9000#issuecomment-836875196\n\n\n   @maartenbreddels Do you want to update this PR?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-10T15:55:00.848+0000",
                    "updated": "2021-05-10T15:55:00.848+0000",
                    "started": "2021-05-10T15:55:00.848+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "594064",
                    "issueId": "13339965"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/worklog/605985",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #9000:\nURL: https://github.com/apache/arrow/pull/9000#issuecomment-853941435\n\n\n   I'm working on updating this.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-03T15:06:07.097+0000",
                    "updated": "2021-06-03T15:06:07.097+0000",
                    "started": "2021-06-03T15:06:07.097+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "605985",
                    "issueId": "13339965"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/worklog/606504",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #9000:\nURL: https://github.com/apache/arrow/pull/9000#issuecomment-853941435\n\n\n   I'm working on updating this.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-04T07:51:20.670+0000",
                    "updated": "2021-06-04T07:51:20.670+0000",
                    "started": "2021-06-04T07:51:20.670+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "606504",
                    "issueId": "13339965"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/worklog/607911",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou closed pull request #9000:\nURL: https://github.com/apache/arrow/pull/9000\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-07T14:31:44.375+0000",
                    "updated": "2021-06-07T14:31:44.375+0000",
                    "started": "2021-06-07T14:31:44.375+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "607911",
                    "issueId": "13339965"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/worklog/607912",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on pull request #9000:\nURL: https://github.com/apache/arrow/pull/9000#issuecomment-855982307\n\n\n   Thanks for picking this up @pitrou, I could not find the time to update it!\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-07T14:34:08.365+0000",
                    "updated": "2021-06-07T14:34:08.365+0000",
                    "started": "2021-06-07T14:34:08.365+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "607912",
                    "issueId": "13339965"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 10800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@287597b3[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@61f1d3cc[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7a3df701[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@153d2439[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4195bcc8[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@36e8093e[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@23f8751d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@5f1891b7[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@33871560[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@45505bd7[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@25608efd[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@3e6e26cf[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 10800,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Jun 07 14:31:34 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-06-07T14:31:34.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10557/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2020-11-11T11:45:45.000+0000",
        "updated": "2021-06-07T14:34:09.000+0000",
        "timeoriginalestimate": null,
        "description": "This should implement slicing scalar string values of strings arrays with Python semantics with start, stop ,step arguments. This may seem similar to lists, or binary array, but the string length semantics enter into this kernel, which does not need to equal the number of bytes, nor the number of codepoints (accents, etc should be skipped).\r\n\r\n\u00a0",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "3h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 10800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Add scalar string slicing/substring extract kernel ",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/comment/17251793",
                    "id": "17251793",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=maartenbreddels",
                        "name": "maartenbreddels",
                        "key": "maartenbreddels",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Maarten Breddels",
                        "active": true,
                        "timeZone": "Europe/Amsterdam"
                    },
                    "body": "This would be easier to implement using the tools in utf8.h (e.g. UTF8FindIfReverse) in that PR",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=maartenbreddels",
                        "name": "maartenbreddels",
                        "key": "maartenbreddels",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Maarten Breddels",
                        "active": true,
                        "timeZone": "Europe/Amsterdam"
                    },
                    "created": "2020-12-18T14:43:44.709+0000",
                    "updated": "2020-12-18T14:43:44.709+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965/comment/17358637",
                    "id": "17358637",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 9000\n[https://github.com/apache/arrow/pull/9000]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-06-07T14:31:34.239+0000",
                    "updated": "2021-06-07T14:31:34.239+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|z0kh74:",
        "customfield_12314139": null
    }
}