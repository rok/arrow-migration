{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13376844",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844",
    "key": "ARROW-12659",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351051",
                "id": "12351051",
                "description": "",
                "name": "8.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-05-06"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "dataset",
            "datasets",
            "expression",
            "expressions",
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12626621",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12626621",
                "type": {
                    "id": "10032",
                    "name": "Blocker",
                    "inward": "is blocked by",
                    "outward": "blocks",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10032"
                },
                "outwardIssue": {
                    "id": "13398759",
                    "key": "ARROW-13848",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13398759",
                    "fields": {
                        "summary": "[C++] and() in a dataset filter",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12633412",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12633412",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13422281",
                    "key": "ARROW-15312",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13422281",
                    "fields": {
                        "summary": "[R][C++] filtering a Parquet dataset with is.na() misses some rows",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/2",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/critical.svg",
                            "name": "Critical",
                            "id": "2"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
                            "id": "1",
                            "description": "A problem which impairs or prevents the functions of the product.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
                            "name": "Bug",
                            "subtask": false,
                            "avatarId": 21133
                        }
                    }
                }
            },
            {
                "id": "12619957",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12619957",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13360659",
                    "key": "ARROW-11762",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360659",
                    "fields": {
                        "summary": "[C++][Dataset] Refactor Partitioning to explicitly treat null and absent fields identically",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 24000,
            "total": 24000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 24000,
            "total": 24000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12659/votes",
            "votes": 1,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 40,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/594227",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10253:\nURL: https://github.com/apache/arrow/pull/10253#discussion_r629645983\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/file_parquet.cc\n##########\n@@ -198,16 +198,27 @@ static util::optional<compute::Expression> ColumnChunkStatisticsAsExpression(\n   auto maybe_min = min->CastTo(field->type());\n   auto maybe_max = max->CastTo(field->type());\n   if (maybe_min.ok() && maybe_max.ok()) {\n-    auto col_min = maybe_min.MoveValueUnsafe();\n-    auto col_max = maybe_max.MoveValueUnsafe();\n-    if (col_min->Equals(col_max)) {\n-      return compute::equal(std::move(field_expr), compute::literal(std::move(col_min)));\n+    min = maybe_min.MoveValueUnsafe();\n+    max = maybe_max.MoveValueUnsafe();\n+\n+    compute::Expression range;\n+    if (min->Equals(max)) {\n+      auto single_value = compute::equal(field_expr, compute::literal(std::move(min)));\n+\n+      if (statistics->null_count() == 0) {\n+        return single_value;\n+      }\n+      return compute::or_(std::move(single_value), is_null(std::move(field_expr)));\n     }\n \n     auto lower_bound =\n-        compute::greater_equal(field_expr, compute::literal(std::move(col_min)));\n-    auto upper_bound =\n-        compute::less_equal(std::move(field_expr), compute::literal(std::move(col_max)));\n+        compute::greater_equal(field_expr, compute::literal(std::move(min)));\n+    auto upper_bound = compute::less_equal(field_expr, compute::literal(std::move(max)));\n+\n+    if (statistics->null_count() == 0) {\n\nReview comment:\n       Was this meant to be `!= 0`?\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression_test.cc\n##########\n@@ -64,6 +64,12 @@ Expression cast(Expression argument, std::shared_ptr<DataType> to_type) {\n               compute::CastOptions::Safe(std::move(to_type)));\n }\n \n+Expression invert(Expression argument) { return call(\"invert\", {std::move(argument)}); }\n\nReview comment:\n       Isn't this `compute::not_`?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-10T20:30:41.631+0000",
                    "updated": "2021-05-10T20:30:41.631+0000",
                    "started": "2021-05-10T20:30:41.631+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "594227",
                    "issueId": "13376844"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/595470",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10253:\nURL: https://github.com/apache/arrow/pull/10253#discussion_r631235305\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/file_parquet.cc\n##########\n@@ -198,16 +198,27 @@ static util::optional<compute::Expression> ColumnChunkStatisticsAsExpression(\n   auto maybe_min = min->CastTo(field->type());\n   auto maybe_max = max->CastTo(field->type());\n   if (maybe_min.ok() && maybe_max.ok()) {\n-    auto col_min = maybe_min.MoveValueUnsafe();\n-    auto col_max = maybe_max.MoveValueUnsafe();\n-    if (col_min->Equals(col_max)) {\n-      return compute::equal(std::move(field_expr), compute::literal(std::move(col_min)));\n+    min = maybe_min.MoveValueUnsafe();\n+    max = maybe_max.MoveValueUnsafe();\n+\n+    compute::Expression range;\n+    if (min->Equals(max)) {\n+      auto single_value = compute::equal(field_expr, compute::literal(std::move(min)));\n+\n+      if (statistics->null_count() == 0) {\n+        return single_value;\n+      }\n+      return compute::or_(std::move(single_value), is_null(std::move(field_expr)));\n     }\n \n     auto lower_bound =\n-        compute::greater_equal(field_expr, compute::literal(std::move(col_min)));\n-    auto upper_bound =\n-        compute::less_equal(std::move(field_expr), compute::literal(std::move(col_max)));\n+        compute::greater_equal(field_expr, compute::literal(std::move(min)));\n+    auto upper_bound = compute::less_equal(field_expr, compute::literal(std::move(max)));\n+\n+    if (statistics->null_count() == 0) {\n\nReview comment:\n       whoops\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression_test.cc\n##########\n@@ -64,6 +64,12 @@ Expression cast(Expression argument, std::shared_ptr<DataType> to_type) {\n               compute::CastOptions::Safe(std::move(to_type)));\n }\n \n+Expression invert(Expression argument) { return call(\"invert\", {std::move(argument)}); }\n\nReview comment:\n       yes, forgot about that factory\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-12T17:08:33.925+0000",
                    "updated": "2021-05-12T17:08:33.925+0000",
                    "started": "2021-05-12T17:08:33.925+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "595470",
                    "issueId": "13376844"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/623522",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #10253:\nURL: https://github.com/apache/arrow/pull/10253#issuecomment-881343067\n\n\n   Closing for now\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-16T10:23:12.244+0000",
                    "updated": "2021-07-16T10:23:12.244+0000",
                    "started": "2021-07-16T10:23:12.244+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "623522",
                    "issueId": "13376844"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/623523",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz closed pull request #10253:\nURL: https://github.com/apache/arrow/pull/10253\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-16T10:23:15.482+0000",
                    "updated": "2021-07-16T10:23:15.482+0000",
                    "started": "2021-07-16T10:23:15.482+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "623523",
                    "issueId": "13376844"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/757091",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm opened a new pull request, #12891:\nURL: https://github.com/apache/arrow/pull/12891\n\n   This rebases #10253 and fixes it up to also address ARROW-15312, including a regression test. \r\n   \r\n   This refactors how inequalities, is_valid, and is_null are treated in expression simplification, and updates the guarantees that the Parquet/Datasets emits for row groups to properly reflect nullability.\n\n\n",
                    "created": "2022-04-14T17:03:30.385+0000",
                    "updated": "2022-04-14T17:03:30.385+0000",
                    "started": "2022-04-14T17:03:30.385+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "757091",
                    "issueId": "13376844"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/757093",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #12891:\nURL: https://github.com/apache/arrow/pull/12891#issuecomment-1099414550\n\n   https://issues.apache.org/jira/browse/ARROW-12659\n\n\n",
                    "created": "2022-04-14T17:03:50.977+0000",
                    "updated": "2022-04-14T17:03:50.977+0000",
                    "started": "2022-04-14T17:03:50.977+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "757093",
                    "issueId": "13376844"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/757094",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #12891:\nURL: https://github.com/apache/arrow/pull/12891#issuecomment-1099414572\n\n   :warning: Ticket **has not been started in JIRA**, please click 'Start Progress'.\n\n\n",
                    "created": "2022-04-14T17:03:52.831+0000",
                    "updated": "2022-04-14T17:03:52.831+0000",
                    "started": "2022-04-14T17:03:52.830+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "757094",
                    "issueId": "13376844"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/757220",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on PR #12891:\nURL: https://github.com/apache/arrow/pull/12891#issuecomment-1099606380\n\n   Hmm, it's crashing because `A == null[string]` is getting converted to `null[string]` by `FoldConstants`. But FilterNode assumes the mask has to be boolean.\n\n\n",
                    "created": "2022-04-14T20:45:50.527+0000",
                    "updated": "2022-04-14T20:45:50.527+0000",
                    "started": "2022-04-14T20:45:50.527+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "757220",
                    "issueId": "13376844"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/757221",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on PR #12891:\nURL: https://github.com/apache/arrow/pull/12891#issuecomment-1099607810\n\n   This needs to return a datum of the right type: https://github.com/apache/arrow/blob/63d2a9c856969a2c05e12ae8857a135bceaf45c1/cpp/src/arrow/compute/exec/expression.cc#L632-L640\n\n\n",
                    "created": "2022-04-14T20:47:57.354+0000",
                    "updated": "2022-04-14T20:47:57.354+0000",
                    "started": "2022-04-14T20:47:57.354+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "757221",
                    "issueId": "13376844"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/757442",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on code in PR #12891:\nURL: https://github.com/apache/arrow/pull/12891#discussion_r851338828\n\n\n##########\ncpp/src/arrow/compute/exec/expression.cc:\n##########\n@@ -682,46 +715,49 @@ std::vector<Expression> GuaranteeConjunctionMembers(\n   return FlattenedAssociativeChain(guaranteed_true_predicate).fringe;\n }\n \n-// Conjunction members which are represented in known_values are erased from\n-// conjunction_members\n-Status ExtractKnownFieldValuesImpl(\n-    std::vector<Expression>* conjunction_members,\n-    std::unordered_map<FieldRef, Datum, FieldRef::Hash>* known_values) {\n-  auto unconsumed_end =\n-      std::partition(conjunction_members->begin(), conjunction_members->end(),\n-                     [](const Expression& expr) {\n-                       // search for an equality conditions between a field and a literal\n-                       auto call = expr.call();\n-                       if (!call) return true;\n-\n-                       if (call->function_name == \"equal\") {\n-                         auto ref = call->arguments[0].field_ref();\n-                         auto lit = call->arguments[1].literal();\n-                         return !(ref && lit);\n-                       }\n-\n-                       if (call->function_name == \"is_null\") {\n-                         auto ref = call->arguments[0].field_ref();\n-                         return !ref;\n-                       }\n-\n-                       return true;\n-                     });\n-\n-  for (auto it = unconsumed_end; it != conjunction_members->end(); ++it) {\n-    auto call = CallNotNull(*it);\n-\n-    if (call->function_name == \"equal\") {\n-      auto ref = call->arguments[0].field_ref();\n-      auto lit = call->arguments[1].literal();\n-      known_values->emplace(*ref, *lit);\n-    } else if (call->function_name == \"is_null\") {\n-      auto ref = call->arguments[0].field_ref();\n-      known_values->emplace(*ref, Datum(std::make_shared<NullScalar>()));\n-    }\n+// equal(a, 2)\n\nReview Comment:\n   Do we want to provide more context here?\n\n\n\n##########\ncpp/src/arrow/dataset/file_parquet.cc:\n##########\n@@ -128,17 +128,30 @@ util::optional<compute::Expression> ColumnChunkStatisticsAsExpression(\n   auto maybe_min = min->CastTo(field->type());\n   auto maybe_max = max->CastTo(field->type());\n   if (maybe_min.ok() && maybe_max.ok()) {\n-    auto col_min = maybe_min.MoveValueUnsafe();\n-    auto col_max = maybe_max.MoveValueUnsafe();\n-    if (col_min->Equals(col_max)) {\n-      return compute::equal(std::move(field_expr), compute::literal(std::move(col_min)));\n+    min = maybe_min.MoveValueUnsafe();\n+    max = maybe_max.MoveValueUnsafe();\n+\n+    compute::Expression range;\n+    if (min->Equals(max)) {\n+      auto single_value = compute::equal(field_expr, compute::literal(std::move(min)));\n+\n+      if (statistics->null_count() == 0) {\n+        return compute::and_(single_value, compute::is_valid(field_expr));\n+      }\n+      return compute::or_(std::move(single_value), is_null(std::move(field_expr)));\n     }\n \n     auto lower_bound =\n-        compute::greater_equal(field_expr, compute::literal(std::move(col_min)));\n-    auto upper_bound =\n-        compute::less_equal(std::move(field_expr), compute::literal(std::move(col_max)));\n-    return compute::and_(std::move(lower_bound), std::move(upper_bound));\n+        compute::greater_equal(field_expr, compute::literal(std::move(min)));\n+    auto upper_bound = compute::less_equal(field_expr, compute::literal(std::move(max)));\n+\n+    if (statistics->null_count() != 0) {\n+      lower_bound = compute::or_(std::move(lower_bound), is_null(field_expr));\n+      upper_bound = compute::or_(std::move(upper_bound), is_null(std::move(field_expr)));\n+      return compute::and_(std::move(lower_bound), std::move(upper_bound));\n+    }\n+    return compute::and_(compute::and_(std::move(lower_bound), std::move(upper_bound)),\n+                         compute::is_valid(field_expr));\n   }\n\nReview Comment:\n   Do we want an arm for `statitics->null_count() == row_count`? In which case, we would just return `is_null(field_expr)`?\n\n\n\n##########\ncpp/src/arrow/compute/exec/expression.cc:\n##########\n@@ -682,46 +715,49 @@ std::vector<Expression> GuaranteeConjunctionMembers(\n   return FlattenedAssociativeChain(guaranteed_true_predicate).fringe;\n }\n \n-// Conjunction members which are represented in known_values are erased from\n-// conjunction_members\n-Status ExtractKnownFieldValuesImpl(\n-    std::vector<Expression>* conjunction_members,\n-    std::unordered_map<FieldRef, Datum, FieldRef::Hash>* known_values) {\n-  auto unconsumed_end =\n-      std::partition(conjunction_members->begin(), conjunction_members->end(),\n-                     [](const Expression& expr) {\n-                       // search for an equality conditions between a field and a literal\n-                       auto call = expr.call();\n-                       if (!call) return true;\n-\n-                       if (call->function_name == \"equal\") {\n-                         auto ref = call->arguments[0].field_ref();\n-                         auto lit = call->arguments[1].literal();\n-                         return !(ref && lit);\n-                       }\n-\n-                       if (call->function_name == \"is_null\") {\n-                         auto ref = call->arguments[0].field_ref();\n-                         return !ref;\n-                       }\n-\n-                       return true;\n-                     });\n-\n-  for (auto it = unconsumed_end; it != conjunction_members->end(); ++it) {\n-    auto call = CallNotNull(*it);\n-\n-    if (call->function_name == \"equal\") {\n-      auto ref = call->arguments[0].field_ref();\n-      auto lit = call->arguments[1].literal();\n-      known_values->emplace(*ref, *lit);\n-    } else if (call->function_name == \"is_null\") {\n-      auto ref = call->arguments[0].field_ref();\n-      known_values->emplace(*ref, Datum(std::make_shared<NullScalar>()));\n-    }\n+// equal(a, 2)\n+// is_null(a)\n+util::optional<std::pair<FieldRef, Datum>> ExtractKnownFieldValue(\n\nReview Comment:\n   nit: I don't love that this is different from below function names by only a single character. Maybe something like `ExtractSingleFieldvalue` or something similar?\n\n\n\n",
                    "created": "2022-04-15T16:46:48.697+0000",
                    "updated": "2022-04-15T16:46:48.697+0000",
                    "started": "2022-04-15T16:46:48.697+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "757442",
                    "issueId": "13376844"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/757912",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #12891:\nURL: https://github.com/apache/arrow/pull/12891#discussion_r852174446\n\n\n##########\ncpp/src/arrow/dataset/file_parquet.cc:\n##########\n@@ -128,17 +128,30 @@ util::optional<compute::Expression> ColumnChunkStatisticsAsExpression(\n   auto maybe_min = min->CastTo(field->type());\n   auto maybe_max = max->CastTo(field->type());\n   if (maybe_min.ok() && maybe_max.ok()) {\n-    auto col_min = maybe_min.MoveValueUnsafe();\n-    auto col_max = maybe_max.MoveValueUnsafe();\n-    if (col_min->Equals(col_max)) {\n-      return compute::equal(std::move(field_expr), compute::literal(std::move(col_min)));\n+    min = maybe_min.MoveValueUnsafe();\n+    max = maybe_max.MoveValueUnsafe();\n+\n+    compute::Expression range;\n+    if (min->Equals(max)) {\n+      auto single_value = compute::equal(field_expr, compute::literal(std::move(min)));\n+\n+      if (statistics->null_count() == 0) {\n+        return compute::and_(single_value, compute::is_valid(field_expr));\n+      }\n+      return compute::or_(std::move(single_value), is_null(std::move(field_expr)));\n     }\n \n     auto lower_bound =\n-        compute::greater_equal(field_expr, compute::literal(std::move(col_min)));\n-    auto upper_bound =\n-        compute::less_equal(std::move(field_expr), compute::literal(std::move(col_max)));\n-    return compute::and_(std::move(lower_bound), std::move(upper_bound));\n+        compute::greater_equal(field_expr, compute::literal(std::move(min)));\n+    auto upper_bound = compute::less_equal(field_expr, compute::literal(std::move(max)));\n+\n+    if (statistics->null_count() != 0) {\n+      lower_bound = compute::or_(std::move(lower_bound), is_null(field_expr));\n+      upper_bound = compute::or_(std::move(upper_bound), is_null(std::move(field_expr)));\n+      return compute::and_(std::move(lower_bound), std::move(upper_bound));\n+    }\n+    return compute::and_(compute::and_(std::move(lower_bound), std::move(upper_bound)),\n+                         compute::is_valid(field_expr));\n   }\n\nReview Comment:\n   I believe this is handled at https://github.com/apache/arrow/blob/fae66cba04aba6528ba7d6a8c225cff24c469ef2/cpp/src/arrow/dataset/file_parquet.cc#L118-L121\r\n   \r\n   Confusingly enough `num_values` does not include nulls. See this test which covers this already: https://github.com/apache/arrow/pull/12891/files#diff-d88654840d0432223c1617e8fd9289db0f4e6fff6b34e9f062861ef8eec724fcR256\r\n   \r\n   This writes each record batch to its own row group, so the test would fail if we didn't generate the proper guarantee for the all-null row group.\n\n\n\n",
                    "created": "2022-04-18T14:55:30.407+0000",
                    "updated": "2022-04-18T14:55:30.407+0000",
                    "started": "2022-04-18T14:55:30.407+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "757912",
                    "issueId": "13376844"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/757914",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #12891:\nURL: https://github.com/apache/arrow/pull/12891#discussion_r852176503\n\n\n##########\ncpp/src/arrow/compute/exec/expression.cc:\n##########\n@@ -682,46 +715,49 @@ std::vector<Expression> GuaranteeConjunctionMembers(\n   return FlattenedAssociativeChain(guaranteed_true_predicate).fringe;\n }\n \n-// Conjunction members which are represented in known_values are erased from\n-// conjunction_members\n-Status ExtractKnownFieldValuesImpl(\n-    std::vector<Expression>* conjunction_members,\n-    std::unordered_map<FieldRef, Datum, FieldRef::Hash>* known_values) {\n-  auto unconsumed_end =\n-      std::partition(conjunction_members->begin(), conjunction_members->end(),\n-                     [](const Expression& expr) {\n-                       // search for an equality conditions between a field and a literal\n-                       auto call = expr.call();\n-                       if (!call) return true;\n-\n-                       if (call->function_name == \"equal\") {\n-                         auto ref = call->arguments[0].field_ref();\n-                         auto lit = call->arguments[1].literal();\n-                         return !(ref && lit);\n-                       }\n-\n-                       if (call->function_name == \"is_null\") {\n-                         auto ref = call->arguments[0].field_ref();\n-                         return !ref;\n-                       }\n-\n-                       return true;\n-                     });\n-\n-  for (auto it = unconsumed_end; it != conjunction_members->end(); ++it) {\n-    auto call = CallNotNull(*it);\n-\n-    if (call->function_name == \"equal\") {\n-      auto ref = call->arguments[0].field_ref();\n-      auto lit = call->arguments[1].literal();\n-      known_values->emplace(*ref, *lit);\n-    } else if (call->function_name == \"is_null\") {\n-      auto ref = call->arguments[0].field_ref();\n-      known_values->emplace(*ref, Datum(std::make_shared<NullScalar>()));\n-    }\n+// equal(a, 2)\n+// is_null(a)\n+util::optional<std::pair<FieldRef, Datum>> ExtractKnownFieldValue(\n\nReview Comment:\n   Done.\n\n\n\n##########\ncpp/src/arrow/compute/exec/expression.cc:\n##########\n@@ -682,46 +715,49 @@ std::vector<Expression> GuaranteeConjunctionMembers(\n   return FlattenedAssociativeChain(guaranteed_true_predicate).fringe;\n }\n \n-// Conjunction members which are represented in known_values are erased from\n-// conjunction_members\n-Status ExtractKnownFieldValuesImpl(\n-    std::vector<Expression>* conjunction_members,\n-    std::unordered_map<FieldRef, Datum, FieldRef::Hash>* known_values) {\n-  auto unconsumed_end =\n-      std::partition(conjunction_members->begin(), conjunction_members->end(),\n-                     [](const Expression& expr) {\n-                       // search for an equality conditions between a field and a literal\n-                       auto call = expr.call();\n-                       if (!call) return true;\n-\n-                       if (call->function_name == \"equal\") {\n-                         auto ref = call->arguments[0].field_ref();\n-                         auto lit = call->arguments[1].literal();\n-                         return !(ref && lit);\n-                       }\n-\n-                       if (call->function_name == \"is_null\") {\n-                         auto ref = call->arguments[0].field_ref();\n-                         return !ref;\n-                       }\n-\n-                       return true;\n-                     });\n-\n-  for (auto it = unconsumed_end; it != conjunction_members->end(); ++it) {\n-    auto call = CallNotNull(*it);\n-\n-    if (call->function_name == \"equal\") {\n-      auto ref = call->arguments[0].field_ref();\n-      auto lit = call->arguments[1].literal();\n-      known_values->emplace(*ref, *lit);\n-    } else if (call->function_name == \"is_null\") {\n-      auto ref = call->arguments[0].field_ref();\n-      known_values->emplace(*ref, Datum(std::make_shared<NullScalar>()));\n-    }\n+// equal(a, 2)\n\nReview Comment:\n   I turned this into a docstring.\n\n\n\n",
                    "created": "2022-04-18T14:58:20.646+0000",
                    "updated": "2022-04-18T14:58:20.646+0000",
                    "started": "2022-04-18T14:58:20.646+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "757914",
                    "issueId": "13376844"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/757928",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on code in PR #12891:\nURL: https://github.com/apache/arrow/pull/12891#discussion_r852193507\n\n\n##########\ncpp/src/arrow/dataset/file_parquet.cc:\n##########\n@@ -128,17 +128,30 @@ util::optional<compute::Expression> ColumnChunkStatisticsAsExpression(\n   auto maybe_min = min->CastTo(field->type());\n   auto maybe_max = max->CastTo(field->type());\n   if (maybe_min.ok() && maybe_max.ok()) {\n-    auto col_min = maybe_min.MoveValueUnsafe();\n-    auto col_max = maybe_max.MoveValueUnsafe();\n-    if (col_min->Equals(col_max)) {\n-      return compute::equal(std::move(field_expr), compute::literal(std::move(col_min)));\n+    min = maybe_min.MoveValueUnsafe();\n+    max = maybe_max.MoveValueUnsafe();\n+\n+    compute::Expression range;\n+    if (min->Equals(max)) {\n+      auto single_value = compute::equal(field_expr, compute::literal(std::move(min)));\n+\n+      if (statistics->null_count() == 0) {\n+        return compute::and_(single_value, compute::is_valid(field_expr));\n+      }\n+      return compute::or_(std::move(single_value), is_null(std::move(field_expr)));\n     }\n \n     auto lower_bound =\n-        compute::greater_equal(field_expr, compute::literal(std::move(col_min)));\n-    auto upper_bound =\n-        compute::less_equal(std::move(field_expr), compute::literal(std::move(col_max)));\n-    return compute::and_(std::move(lower_bound), std::move(upper_bound));\n+        compute::greater_equal(field_expr, compute::literal(std::move(min)));\n+    auto upper_bound = compute::less_equal(field_expr, compute::literal(std::move(max)));\n+\n+    if (statistics->null_count() != 0) {\n+      lower_bound = compute::or_(std::move(lower_bound), is_null(field_expr));\n+      upper_bound = compute::or_(std::move(upper_bound), is_null(std::move(field_expr)));\n+      return compute::and_(std::move(lower_bound), std::move(upper_bound));\n+    }\n+    return compute::and_(compute::and_(std::move(lower_bound), std::move(upper_bound)),\n+                         compute::is_valid(field_expr));\n   }\n\nReview Comment:\n   Ah thanks for the pointer on `num_values`.\n\n\n\n",
                    "created": "2022-04-18T15:21:32.736+0000",
                    "updated": "2022-04-18T15:21:32.736+0000",
                    "started": "2022-04-18T15:21:32.735+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "757928",
                    "issueId": "13376844"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/758462",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on PR #12891:\nURL: https://github.com/apache/arrow/pull/12891#issuecomment-1102645188\n\n   CC @pitrou or @westonpace, any comments here?\n\n\n",
                    "created": "2022-04-19T13:22:22.340+0000",
                    "updated": "2022-04-19T13:22:22.340+0000",
                    "started": "2022-04-19T13:22:22.340+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "758462",
                    "issueId": "13376844"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/758538",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #12891:\nURL: https://github.com/apache/arrow/pull/12891#discussion_r853115172\n\n\n##########\ncpp/src/arrow/util/vector.h:\n##########\n@@ -77,9 +77,14 @@ std::vector<T> ReplaceVectorElement(const std::vector<T>& values, size_t index,\n }\n \n template <typename T, typename Predicate>\n-std::vector<T> FilterVector(std::vector<T> values, Predicate&& predicate) {\n-  auto new_end =\n-      std::remove_if(values.begin(), values.end(), std::forward<Predicate>(predicate));\n+std::vector<T> FilterVector(std::vector<T> values, Predicate&& predicate,\n+                            std::vector<T>* filtered_out = NULLPTR) {\n\nReview Comment:\n   I may be missing something, but it does not seem this third argument is used anywhere?\n\n\n\n##########\ncpp/src/arrow/compute/kernels/scalar_validity_test.cc:\n##########\n@@ -48,6 +48,23 @@ TEST_F(TestBooleanValidityKernels, ArrayIsValid) {\n                    \"[false, true, true, false]\");\n }\n \n+TEST_F(TestBooleanValidityKernels, TrueUnlessNull) {\n+  CheckScalarUnary(\"true_unless_null\", type_singleton(), \"[]\", type_singleton(), \"[]\");\n+  CheckScalarUnary(\"true_unless_null\", type_singleton(), \"[null]\", type_singleton(),\n+                   \"[null]\");\n+  CheckScalarUnary(\"true_unless_null\", type_singleton(), \"[0, 1]\", type_singleton(),\n+                   \"[true, true]\");\n+  CheckScalarUnary(\"true_unless_null\", type_singleton(), \"[null, 1, 0, null]\",\n+                   type_singleton(), \"[null, true, true, null]\");\n+}\n+\n+TEST_F(TestBooleanValidityKernels, IsValidIsNullNullType) {\n+  CheckScalarUnary(\"is_null\", std::make_shared<NullArray>(5),\n+                   ArrayFromJSON(boolean(), \"[true, true, true, true, true]\"));\n+  CheckScalarUnary(\"is_valid\", std::make_shared<NullArray>(5),\n+                   ArrayFromJSON(boolean(), \"[false, false, false, false, false]\"));\n\nReview Comment:\n   Can we also test \"true_unless_null\" here?\n\n\n\n##########\ncpp/src/arrow/compute/exec/expression.cc:\n##########\n@@ -305,19 +308,47 @@ bool Expression::IsNullLiteral() const {\n   return false;\n }\n \n-bool Expression::IsSatisfiable() const {\n-  if (type() && type()->id() == Type::NA) {\n-    return false;\n+namespace {\n+util::optional<compute::NullHandling::type> GetNullHandling(\n+    const Expression::Call& call) {\n+  DCHECK_NE(call.function, nullptr);\n+  if (call.function->kind() == compute::Function::SCALAR) {\n+    return static_cast<const compute::ScalarKernel*>(call.kernel)->null_handling;\n   }\n+  return util::nullopt;\n+}\n+}  // namespace\n+\n+bool Expression::IsSatisfiable() const {\n+  if (!type()) return true;\n+  if (type()->id() != Type::BOOL) return true;\n \n   if (auto lit = literal()) {\n     if (lit->null_count() == lit->length()) {\n       return false;\n     }\n \n-    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+    if (lit->is_scalar()) {\n       return lit->scalar_as<BooleanScalar>().value;\n     }\n+\n+    return true;\n+  }\n+\n+  if (field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  if (call->function_name == \"invert\") {\n\nReview Comment:\n   Can you add a comment explaining why this is useful?\n\n\n\n##########\ncpp/src/arrow/compute/exec/expression.cc:\n##########\n@@ -879,79 +918,183 @@ Result<Expression> Canonicalize(Expression expr, compute::ExecContext* exec_cont\n \n namespace {\n \n-Result<Expression> DirectComparisonSimplification(Expression expr,\n-                                                  const Expression::Call& guarantee) {\n-  return Modify(\n-      std::move(expr), [](Expression expr) { return expr; },\n-      [&guarantee](Expression expr, ...) -> Result<Expression> {\n-        auto call = expr.call();\n-        if (!call) return expr;\n+// An inequality comparison which a target Expression is known to satisfy. If nullable,\n+// the target may evaluate to null in addition to values satisfying the comparison.\n+struct Inequality {\n+  Comparison::type cmp;\n+  const FieldRef& target;\n+  const Datum& bound;\n\nReview Comment:\n   Would you like to add a comment explaining what the terms are? Is it `target <cmp> bound` or `bound <cmp> target`?\r\n   \n\n\n\n##########\ncpp/src/arrow/compute/exec/expression.cc:\n##########\n@@ -879,79 +918,183 @@ Result<Expression> Canonicalize(Expression expr, compute::ExecContext* exec_cont\n \n namespace {\n \n-Result<Expression> DirectComparisonSimplification(Expression expr,\n-                                                  const Expression::Call& guarantee) {\n-  return Modify(\n-      std::move(expr), [](Expression expr) { return expr; },\n-      [&guarantee](Expression expr, ...) -> Result<Expression> {\n-        auto call = expr.call();\n-        if (!call) return expr;\n+// An inequality comparison which a target Expression is known to satisfy. If nullable,\n+// the target may evaluate to null in addition to values satisfying the comparison.\n+struct Inequality {\n+  Comparison::type cmp;\n+  const FieldRef& target;\n+  const Datum& bound;\n+  bool nullable;\n+\n+  // Extract an Inequality if possible, derived from \"less\",\n+  // \"greater\", \"less_equal\", and \"greater_equal\" expressions,\n+  // possibly disjuncted with an \"is_null\" Expression.\n+  // cmp(a, 2)\n+  // cmp(a, 2) or is_null(a)\n+  static util::optional<Inequality> ExtractOne(const Expression& guarantee) {\n+    auto call = guarantee.call();\n+    if (!call) return util::nullopt;\n+\n+    if (call->function_name == \"or_kleene\") {\n+      // expect the LHS to be a usable field inequality\n+      auto out = ExtractOneFromComparison(call->arguments[0]);\n+      if (!out) return util::nullopt;\n+\n+      // expect the RHS to be an is_null expression\n+      auto call_rhs = call->arguments[1].call();\n+      if (!call_rhs) return util::nullopt;\n+      if (call_rhs->function_name != \"is_null\") return util::nullopt;\n+\n+      // ... and that it references the same target\n+      auto target = call_rhs->arguments[0].field_ref();\n+      if (!target) return util::nullopt;\n+      if (*target != out->target) return util::nullopt;\n+\n+      out->nullable = true;\n+      return out;\n+    }\n \n-        // Ensure both calls are comparisons with equal LHS and scalar RHS\n-        auto cmp = Comparison::Get(expr);\n-        auto cmp_guarantee = Comparison::Get(guarantee.function_name);\n+    // fall back to a simple comparison with no \"is_null\"\n+    return ExtractOneFromComparison(guarantee);\n+  }\n \n-        if (!cmp) return expr;\n-        if (!cmp_guarantee) return expr;\n+  static util::optional<Inequality> ExtractOneFromComparison(\n+      const Expression& guarantee) {\n+    auto call = guarantee.call();\n+    if (!call) return util::nullopt;\n \n-        const auto& lhs = Comparison::StripOrderPreservingCasts(call->arguments[0]);\n-        const auto& guarantee_lhs = guarantee.arguments[0];\n-        if (lhs != guarantee_lhs) return expr;\n+    if (auto cmp = Comparison::Get(call->function_name)) {\n+      // not_equal comparisons are not very usable as guarantees\n+      if (*cmp == Comparison::NOT_EQUAL) return util::nullopt;\n \n-        auto rhs = call->arguments[1].literal();\n-        auto guarantee_rhs = guarantee.arguments[1].literal();\n+      auto target = call->arguments[0].field_ref();\n+      if (!target) return util::nullopt;\n \n-        if (!rhs) return expr;\n-        if (!rhs->is_scalar()) return expr;\n+      auto bound = call->arguments[1].literal();\n+      if (!bound) return util::nullopt;\n+      if (!bound->is_scalar()) return util::nullopt;\n \n-        if (!guarantee_rhs) return expr;\n-        if (!guarantee_rhs->is_scalar()) return expr;\n+      return Inequality{*cmp, /*target=*/*target, *bound, /*nullable=*/false};\n+    }\n \n-        ARROW_ASSIGN_OR_RAISE(auto cmp_rhs_guarantee_rhs,\n-                              Comparison::Execute(*rhs, *guarantee_rhs));\n-        DCHECK_NE(cmp_rhs_guarantee_rhs, Comparison::NA);\n+    return util::nullopt;\n+  }\n \n-        if (cmp_rhs_guarantee_rhs == Comparison::EQUAL) {\n-          // RHS of filter is equal to RHS of guarantee\n+  /// The given expression simplifies to `value` if the inequality\n+  /// target is not nullable. Otherwise, it simplifies to either a\n+  /// call to true_unless_null or !true_unless_null.\n+  Result<Expression> simplified_to(const Expression& bound_target, bool value) const {\n+    if (!nullable) return literal(value);\n+\n+    ExecContext exec_context;\n+\n+    // Data may be null, so comparison will yield `value` - or null IFF the data was null\n+    //\n+    // true_unless_null is cheap; it purely reuses the validity bitmap for the values\n+    // buffer. Inversion is less cheap but we expect that term never to be evaluated\n+    // since invert(true_unless_null(x)) is not satisfiable.\n+    Expression::Call call;\n+    call.function_name = \"true_unless_null\";\n+    call.arguments = {bound_target};\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto true_unless_null,\n+        BindNonRecursive(std::move(call),\n+                         /*insert_implicit_casts=*/false, &exec_context));\n+    if (value) return true_unless_null;\n+\n+    Expression::Call invert;\n+    invert.function_name = \"invert\";\n+    invert.arguments = {std::move(true_unless_null)};\n+    return BindNonRecursive(std::move(invert),\n+                            /*insert_implicit_casts=*/false, &exec_context);\n+  }\n \n-          if ((*cmp & *cmp_guarantee) == *cmp_guarantee) {\n-            // guarantee is a subset of filter, so all data will be included\n-            // x > 1, x >= 1, x != 1 guaranteed by x > 1\n-            return literal(true);\n-          }\n+  /// \\brief Simplify the given expression given this inequality as a guarantee.\n+  Result<Expression> Simplify(Expression expr) {\n+    const auto& guarantee = *this;\n \n-          if ((*cmp & *cmp_guarantee) == 0) {\n-            // guarantee disjoint with filter, so all data will be excluded\n-            // x > 1, x >= 1, x != 1 unsatisfiable if x == 1\n-            return literal(false);\n-          }\n+    auto call = expr.call();\n+    if (!call) return expr;\n \n-          return expr;\n-        }\n+    auto cmp = Comparison::Get(expr);\n+    if (!cmp) return expr;\n \n-        if (*cmp_guarantee & cmp_rhs_guarantee_rhs) {\n-          // x > 1, x >= 1, x != 1 cannot use guarantee x >= 3\n-          return expr;\n-        }\n+    auto rhs = call->arguments[1].literal();\n+    if (!rhs) return expr;\n+    if (!rhs->is_scalar()) return expr;\n \n-        if (*cmp & Comparison::GetFlipped(cmp_rhs_guarantee_rhs)) {\n-          // x > 1, x >= 1, x != 1 guaranteed by x >= 3\n-          return literal(true);\n-        } else {\n-          // x < 1, x <= 1, x == 1 unsatisfiable if x >= 3\n-          return literal(false);\n-        }\n+    const auto& lhs = Comparison::StripOrderPreservingCasts(call->arguments[0]);\n+    if (!lhs.field_ref()) return expr;\n+    if (*lhs.field_ref() != guarantee.target) return expr;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto cmp_rhs_bound, Comparison::Execute(*rhs, guarantee.bound));\n+    DCHECK_NE(cmp_rhs_bound, Comparison::NA);\n+\n+    if (cmp_rhs_bound == Comparison::EQUAL) {\n+      // RHS of filter is equal to RHS of guarantee\n+\n+      if ((*cmp & guarantee.cmp) == guarantee.cmp) {\n+        // guarantee is a subset of filter, so all data will be included\n+        // x > 1, x >= 1, x != 1 guaranteed by x > 1\n+        return simplified_to(lhs, true);\n+      }\n+\n+      if ((*cmp & guarantee.cmp) == 0) {\n+        // guarantee disjoint with filter, so all data will be excluded\n+        // x > 1, x >= 1, x != 1 unsatisfiable if x == 1\n+        return simplified_to(lhs, false);\n+      }\n+\n+      return expr;\n+    }\n+\n+    if (guarantee.cmp & cmp_rhs_bound) {\n+      // x > 1, x >= 1, x != 1 cannot use guarantee x >= 3\n\nReview Comment:\n   Perhaps (with `rhs` being 1 and `bound` being 0):\r\n   ```c++\r\n   // x > 1, x >= 1, x != 1 cannot use guarantee x >= 0\r\n   // (where `guarantee.cmp` is GREATER_EQUAL, `cmp_rhs_bound` is GREATER)\r\n   ```\r\n   \n\n\n\n##########\ncpp/src/arrow/compute/exec/expression.cc:\n##########\n@@ -879,79 +918,183 @@ Result<Expression> Canonicalize(Expression expr, compute::ExecContext* exec_cont\n \n namespace {\n \n-Result<Expression> DirectComparisonSimplification(Expression expr,\n-                                                  const Expression::Call& guarantee) {\n-  return Modify(\n-      std::move(expr), [](Expression expr) { return expr; },\n-      [&guarantee](Expression expr, ...) -> Result<Expression> {\n-        auto call = expr.call();\n-        if (!call) return expr;\n+// An inequality comparison which a target Expression is known to satisfy. If nullable,\n+// the target may evaluate to null in addition to values satisfying the comparison.\n+struct Inequality {\n+  Comparison::type cmp;\n+  const FieldRef& target;\n+  const Datum& bound;\n+  bool nullable;\n+\n+  // Extract an Inequality if possible, derived from \"less\",\n+  // \"greater\", \"less_equal\", and \"greater_equal\" expressions,\n+  // possibly disjuncted with an \"is_null\" Expression.\n+  // cmp(a, 2)\n+  // cmp(a, 2) or is_null(a)\n+  static util::optional<Inequality> ExtractOne(const Expression& guarantee) {\n+    auto call = guarantee.call();\n+    if (!call) return util::nullopt;\n+\n+    if (call->function_name == \"or_kleene\") {\n+      // expect the LHS to be a usable field inequality\n+      auto out = ExtractOneFromComparison(call->arguments[0]);\n+      if (!out) return util::nullopt;\n+\n+      // expect the RHS to be an is_null expression\n+      auto call_rhs = call->arguments[1].call();\n+      if (!call_rhs) return util::nullopt;\n+      if (call_rhs->function_name != \"is_null\") return util::nullopt;\n+\n+      // ... and that it references the same target\n+      auto target = call_rhs->arguments[0].field_ref();\n+      if (!target) return util::nullopt;\n+      if (*target != out->target) return util::nullopt;\n+\n+      out->nullable = true;\n+      return out;\n+    }\n \n-        // Ensure both calls are comparisons with equal LHS and scalar RHS\n-        auto cmp = Comparison::Get(expr);\n-        auto cmp_guarantee = Comparison::Get(guarantee.function_name);\n+    // fall back to a simple comparison with no \"is_null\"\n+    return ExtractOneFromComparison(guarantee);\n+  }\n \n-        if (!cmp) return expr;\n-        if (!cmp_guarantee) return expr;\n+  static util::optional<Inequality> ExtractOneFromComparison(\n+      const Expression& guarantee) {\n+    auto call = guarantee.call();\n+    if (!call) return util::nullopt;\n \n-        const auto& lhs = Comparison::StripOrderPreservingCasts(call->arguments[0]);\n-        const auto& guarantee_lhs = guarantee.arguments[0];\n-        if (lhs != guarantee_lhs) return expr;\n+    if (auto cmp = Comparison::Get(call->function_name)) {\n+      // not_equal comparisons are not very usable as guarantees\n+      if (*cmp == Comparison::NOT_EQUAL) return util::nullopt;\n \n-        auto rhs = call->arguments[1].literal();\n-        auto guarantee_rhs = guarantee.arguments[1].literal();\n+      auto target = call->arguments[0].field_ref();\n+      if (!target) return util::nullopt;\n \n-        if (!rhs) return expr;\n-        if (!rhs->is_scalar()) return expr;\n+      auto bound = call->arguments[1].literal();\n+      if (!bound) return util::nullopt;\n+      if (!bound->is_scalar()) return util::nullopt;\n \n-        if (!guarantee_rhs) return expr;\n-        if (!guarantee_rhs->is_scalar()) return expr;\n+      return Inequality{*cmp, /*target=*/*target, *bound, /*nullable=*/false};\n+    }\n \n-        ARROW_ASSIGN_OR_RAISE(auto cmp_rhs_guarantee_rhs,\n-                              Comparison::Execute(*rhs, *guarantee_rhs));\n-        DCHECK_NE(cmp_rhs_guarantee_rhs, Comparison::NA);\n+    return util::nullopt;\n+  }\n \n-        if (cmp_rhs_guarantee_rhs == Comparison::EQUAL) {\n-          // RHS of filter is equal to RHS of guarantee\n+  /// The given expression simplifies to `value` if the inequality\n+  /// target is not nullable. Otherwise, it simplifies to either a\n+  /// call to true_unless_null or !true_unless_null.\n+  Result<Expression> simplified_to(const Expression& bound_target, bool value) const {\n+    if (!nullable) return literal(value);\n+\n+    ExecContext exec_context;\n+\n+    // Data may be null, so comparison will yield `value` - or null IFF the data was null\n+    //\n+    // true_unless_null is cheap; it purely reuses the validity bitmap for the values\n+    // buffer. Inversion is less cheap but we expect that term never to be evaluated\n+    // since invert(true_unless_null(x)) is not satisfiable.\n+    Expression::Call call;\n+    call.function_name = \"true_unless_null\";\n+    call.arguments = {bound_target};\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto true_unless_null,\n+        BindNonRecursive(std::move(call),\n+                         /*insert_implicit_casts=*/false, &exec_context));\n+    if (value) return true_unless_null;\n+\n+    Expression::Call invert;\n+    invert.function_name = \"invert\";\n+    invert.arguments = {std::move(true_unless_null)};\n+    return BindNonRecursive(std::move(invert),\n+                            /*insert_implicit_casts=*/false, &exec_context);\n+  }\n \n-          if ((*cmp & *cmp_guarantee) == *cmp_guarantee) {\n-            // guarantee is a subset of filter, so all data will be included\n-            // x > 1, x >= 1, x != 1 guaranteed by x > 1\n-            return literal(true);\n-          }\n+  /// \\brief Simplify the given expression given this inequality as a guarantee.\n+  Result<Expression> Simplify(Expression expr) {\n+    const auto& guarantee = *this;\n \n-          if ((*cmp & *cmp_guarantee) == 0) {\n-            // guarantee disjoint with filter, so all data will be excluded\n-            // x > 1, x >= 1, x != 1 unsatisfiable if x == 1\n-            return literal(false);\n-          }\n+    auto call = expr.call();\n+    if (!call) return expr;\n \n-          return expr;\n-        }\n+    auto cmp = Comparison::Get(expr);\n+    if (!cmp) return expr;\n \n-        if (*cmp_guarantee & cmp_rhs_guarantee_rhs) {\n-          // x > 1, x >= 1, x != 1 cannot use guarantee x >= 3\n-          return expr;\n-        }\n+    auto rhs = call->arguments[1].literal();\n+    if (!rhs) return expr;\n+    if (!rhs->is_scalar()) return expr;\n \n-        if (*cmp & Comparison::GetFlipped(cmp_rhs_guarantee_rhs)) {\n-          // x > 1, x >= 1, x != 1 guaranteed by x >= 3\n-          return literal(true);\n-        } else {\n-          // x < 1, x <= 1, x == 1 unsatisfiable if x >= 3\n-          return literal(false);\n-        }\n+    const auto& lhs = Comparison::StripOrderPreservingCasts(call->arguments[0]);\n+    if (!lhs.field_ref()) return expr;\n+    if (*lhs.field_ref() != guarantee.target) return expr;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto cmp_rhs_bound, Comparison::Execute(*rhs, guarantee.bound));\n+    DCHECK_NE(cmp_rhs_bound, Comparison::NA);\n+\n+    if (cmp_rhs_bound == Comparison::EQUAL) {\n+      // RHS of filter is equal to RHS of guarantee\n+\n+      if ((*cmp & guarantee.cmp) == guarantee.cmp) {\n+        // guarantee is a subset of filter, so all data will be included\n+        // x > 1, x >= 1, x != 1 guaranteed by x > 1\n+        return simplified_to(lhs, true);\n+      }\n+\n+      if ((*cmp & guarantee.cmp) == 0) {\n+        // guarantee disjoint with filter, so all data will be excluded\n+        // x > 1, x >= 1, x != 1 unsatisfiable if x == 1\n+        return simplified_to(lhs, false);\n+      }\n+\n+      return expr;\n+    }\n+\n+    if (guarantee.cmp & cmp_rhs_bound) {\n+      // x > 1, x >= 1, x != 1 cannot use guarantee x >= 3\n+      return expr;\n+    }\n+\n+    if (*cmp & Comparison::GetFlipped(cmp_rhs_bound)) {\n+      // x > 1, x >= 1, x != 1 guaranteed by x >= 3\n\nReview Comment:\n   Perhaps\r\n   ```suggestion\r\n         // x > 1, x >= 1, x != 1 guaranteed by x >= 3\r\n         // (where `guarantee.cmp` is GREATER_EQUAL, `cmp_rhs_bound` is LESS)\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/expression.cc:\n##########\n@@ -305,19 +308,47 @@ bool Expression::IsNullLiteral() const {\n   return false;\n }\n \n-bool Expression::IsSatisfiable() const {\n-  if (type() && type()->id() == Type::NA) {\n-    return false;\n+namespace {\n+util::optional<compute::NullHandling::type> GetNullHandling(\n+    const Expression::Call& call) {\n+  DCHECK_NE(call.function, nullptr);\n+  if (call.function->kind() == compute::Function::SCALAR) {\n+    return static_cast<const compute::ScalarKernel*>(call.kernel)->null_handling;\n   }\n+  return util::nullopt;\n+}\n+}  // namespace\n+\n+bool Expression::IsSatisfiable() const {\n+  if (!type()) return true;\n+  if (type()->id() != Type::BOOL) return true;\n \n   if (auto lit = literal()) {\n     if (lit->null_count() == lit->length()) {\n       return false;\n     }\n \n-    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+    if (lit->is_scalar()) {\n       return lit->scalar_as<BooleanScalar>().value;\n     }\n+\n+    return true;\n+  }\n+\n+  if (field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  if (call->function_name == \"invert\") {\n+    if (auto nested_call = call->arguments[0].call()) {\n+      if (nested_call->function_name == \"true_unless_null\") return false;\n+    }\n+  }\n+\n+  if (call->function_name == \"and_kleene\") {\n\nReview Comment:\n   Why specifically \"and_kleene\" but not \"and\"? Can you add a comment?\n\n\n\n##########\ncpp/src/arrow/dataset/file_parquet.cc:\n##########\n@@ -128,17 +128,30 @@ util::optional<compute::Expression> ColumnChunkStatisticsAsExpression(\n   auto maybe_min = min->CastTo(field->type());\n   auto maybe_max = max->CastTo(field->type());\n   if (maybe_min.ok() && maybe_max.ok()) {\n-    auto col_min = maybe_min.MoveValueUnsafe();\n-    auto col_max = maybe_max.MoveValueUnsafe();\n-    if (col_min->Equals(col_max)) {\n-      return compute::equal(std::move(field_expr), compute::literal(std::move(col_min)));\n+    min = maybe_min.MoveValueUnsafe();\n+    max = maybe_max.MoveValueUnsafe();\n+\n+    compute::Expression range;\n+    if (min->Equals(max)) {\n+      auto single_value = compute::equal(field_expr, compute::literal(std::move(min)));\n+\n+      if (statistics->null_count() == 0) {\n+        return compute::and_(single_value, compute::is_valid(field_expr));\n\nReview Comment:\n   Is it useful to add `is_valid` here? If a value is equal to `min` it implies it is valid.\n\n\n\n##########\ncpp/src/arrow/dataset/file_parquet.cc:\n##########\n@@ -128,17 +128,30 @@ util::optional<compute::Expression> ColumnChunkStatisticsAsExpression(\n   auto maybe_min = min->CastTo(field->type());\n   auto maybe_max = max->CastTo(field->type());\n   if (maybe_min.ok() && maybe_max.ok()) {\n-    auto col_min = maybe_min.MoveValueUnsafe();\n-    auto col_max = maybe_max.MoveValueUnsafe();\n-    if (col_min->Equals(col_max)) {\n-      return compute::equal(std::move(field_expr), compute::literal(std::move(col_min)));\n+    min = maybe_min.MoveValueUnsafe();\n+    max = maybe_max.MoveValueUnsafe();\n+\n+    compute::Expression range;\n+    if (min->Equals(max)) {\n+      auto single_value = compute::equal(field_expr, compute::literal(std::move(min)));\n+\n+      if (statistics->null_count() == 0) {\n+        return compute::and_(single_value, compute::is_valid(field_expr));\n+      }\n+      return compute::or_(std::move(single_value), is_null(std::move(field_expr)));\n     }\n \n     auto lower_bound =\n-        compute::greater_equal(field_expr, compute::literal(std::move(col_min)));\n-    auto upper_bound =\n-        compute::less_equal(std::move(field_expr), compute::literal(std::move(col_max)));\n-    return compute::and_(std::move(lower_bound), std::move(upper_bound));\n+        compute::greater_equal(field_expr, compute::literal(std::move(min)));\n+    auto upper_bound = compute::less_equal(field_expr, compute::literal(std::move(max)));\n+\n+    if (statistics->null_count() != 0) {\n+      lower_bound = compute::or_(std::move(lower_bound), is_null(field_expr));\n+      upper_bound = compute::or_(std::move(upper_bound), is_null(std::move(field_expr)));\n+      return compute::and_(std::move(lower_bound), std::move(upper_bound));\n+    }\n+    return compute::and_(compute::and_(std::move(lower_bound), std::move(upper_bound)),\n+                         compute::is_valid(field_expr));\n\nReview Comment:\n   This seems a bit pointlessly complicated, or I'm missing something? Why not:\r\n   ```suggestion\r\n       auto in_range = compute::and_(std::move(lower_bound), std::move(upper_bound));\r\n       if (statistics->null_count() != 0) {\r\n         return compute::or_(std::move(in_range), compute::is_null(field_expr));\r\n       }\r\n       return in_range;\r\n   ```\r\n   \n\n\n\n##########\ncpp/src/arrow/dataset/file_parquet.cc:\n##########\n@@ -128,17 +128,30 @@ util::optional<compute::Expression> ColumnChunkStatisticsAsExpression(\n   auto maybe_min = min->CastTo(field->type());\n   auto maybe_max = max->CastTo(field->type());\n   if (maybe_min.ok() && maybe_max.ok()) {\n-    auto col_min = maybe_min.MoveValueUnsafe();\n-    auto col_max = maybe_max.MoveValueUnsafe();\n-    if (col_min->Equals(col_max)) {\n-      return compute::equal(std::move(field_expr), compute::literal(std::move(col_min)));\n+    min = maybe_min.MoveValueUnsafe();\n+    max = maybe_max.MoveValueUnsafe();\n+\n+    compute::Expression range;\n\nReview Comment:\n   This variable doesn't seem used?\n\n\n\n##########\ncpp/src/arrow/compute/exec/expression.cc:\n##########\n@@ -879,79 +918,183 @@ Result<Expression> Canonicalize(Expression expr, compute::ExecContext* exec_cont\n \n namespace {\n \n-Result<Expression> DirectComparisonSimplification(Expression expr,\n-                                                  const Expression::Call& guarantee) {\n-  return Modify(\n-      std::move(expr), [](Expression expr) { return expr; },\n-      [&guarantee](Expression expr, ...) -> Result<Expression> {\n-        auto call = expr.call();\n-        if (!call) return expr;\n+// An inequality comparison which a target Expression is known to satisfy. If nullable,\n+// the target may evaluate to null in addition to values satisfying the comparison.\n+struct Inequality {\n+  Comparison::type cmp;\n+  const FieldRef& target;\n+  const Datum& bound;\n+  bool nullable;\n+\n+  // Extract an Inequality if possible, derived from \"less\",\n+  // \"greater\", \"less_equal\", and \"greater_equal\" expressions,\n+  // possibly disjuncted with an \"is_null\" Expression.\n+  // cmp(a, 2)\n+  // cmp(a, 2) or is_null(a)\n+  static util::optional<Inequality> ExtractOne(const Expression& guarantee) {\n+    auto call = guarantee.call();\n+    if (!call) return util::nullopt;\n+\n+    if (call->function_name == \"or_kleene\") {\n+      // expect the LHS to be a usable field inequality\n+      auto out = ExtractOneFromComparison(call->arguments[0]);\n+      if (!out) return util::nullopt;\n+\n+      // expect the RHS to be an is_null expression\n+      auto call_rhs = call->arguments[1].call();\n+      if (!call_rhs) return util::nullopt;\n+      if (call_rhs->function_name != \"is_null\") return util::nullopt;\n+\n+      // ... and that it references the same target\n+      auto target = call_rhs->arguments[0].field_ref();\n+      if (!target) return util::nullopt;\n+      if (*target != out->target) return util::nullopt;\n+\n+      out->nullable = true;\n+      return out;\n+    }\n \n-        // Ensure both calls are comparisons with equal LHS and scalar RHS\n-        auto cmp = Comparison::Get(expr);\n-        auto cmp_guarantee = Comparison::Get(guarantee.function_name);\n+    // fall back to a simple comparison with no \"is_null\"\n+    return ExtractOneFromComparison(guarantee);\n+  }\n \n-        if (!cmp) return expr;\n-        if (!cmp_guarantee) return expr;\n+  static util::optional<Inequality> ExtractOneFromComparison(\n+      const Expression& guarantee) {\n+    auto call = guarantee.call();\n+    if (!call) return util::nullopt;\n \n-        const auto& lhs = Comparison::StripOrderPreservingCasts(call->arguments[0]);\n-        const auto& guarantee_lhs = guarantee.arguments[0];\n-        if (lhs != guarantee_lhs) return expr;\n+    if (auto cmp = Comparison::Get(call->function_name)) {\n+      // not_equal comparisons are not very usable as guarantees\n+      if (*cmp == Comparison::NOT_EQUAL) return util::nullopt;\n \n-        auto rhs = call->arguments[1].literal();\n-        auto guarantee_rhs = guarantee.arguments[1].literal();\n+      auto target = call->arguments[0].field_ref();\n+      if (!target) return util::nullopt;\n \n-        if (!rhs) return expr;\n-        if (!rhs->is_scalar()) return expr;\n+      auto bound = call->arguments[1].literal();\n+      if (!bound) return util::nullopt;\n+      if (!bound->is_scalar()) return util::nullopt;\n \n-        if (!guarantee_rhs) return expr;\n-        if (!guarantee_rhs->is_scalar()) return expr;\n+      return Inequality{*cmp, /*target=*/*target, *bound, /*nullable=*/false};\n+    }\n \n-        ARROW_ASSIGN_OR_RAISE(auto cmp_rhs_guarantee_rhs,\n-                              Comparison::Execute(*rhs, *guarantee_rhs));\n-        DCHECK_NE(cmp_rhs_guarantee_rhs, Comparison::NA);\n+    return util::nullopt;\n+  }\n \n-        if (cmp_rhs_guarantee_rhs == Comparison::EQUAL) {\n-          // RHS of filter is equal to RHS of guarantee\n+  /// The given expression simplifies to `value` if the inequality\n+  /// target is not nullable. Otherwise, it simplifies to either a\n+  /// call to true_unless_null or !true_unless_null.\n+  Result<Expression> simplified_to(const Expression& bound_target, bool value) const {\n+    if (!nullable) return literal(value);\n+\n+    ExecContext exec_context;\n+\n+    // Data may be null, so comparison will yield `value` - or null IFF the data was null\n+    //\n+    // true_unless_null is cheap; it purely reuses the validity bitmap for the values\n+    // buffer. Inversion is less cheap but we expect that term never to be evaluated\n+    // since invert(true_unless_null(x)) is not satisfiable.\n+    Expression::Call call;\n+    call.function_name = \"true_unless_null\";\n+    call.arguments = {bound_target};\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto true_unless_null,\n+        BindNonRecursive(std::move(call),\n+                         /*insert_implicit_casts=*/false, &exec_context));\n+    if (value) return true_unless_null;\n+\n+    Expression::Call invert;\n+    invert.function_name = \"invert\";\n+    invert.arguments = {std::move(true_unless_null)};\n+    return BindNonRecursive(std::move(invert),\n+                            /*insert_implicit_casts=*/false, &exec_context);\n+  }\n \n-          if ((*cmp & *cmp_guarantee) == *cmp_guarantee) {\n-            // guarantee is a subset of filter, so all data will be included\n-            // x > 1, x >= 1, x != 1 guaranteed by x > 1\n-            return literal(true);\n-          }\n+  /// \\brief Simplify the given expression given this inequality as a guarantee.\n+  Result<Expression> Simplify(Expression expr) {\n+    const auto& guarantee = *this;\n \n-          if ((*cmp & *cmp_guarantee) == 0) {\n-            // guarantee disjoint with filter, so all data will be excluded\n-            // x > 1, x >= 1, x != 1 unsatisfiable if x == 1\n-            return literal(false);\n-          }\n+    auto call = expr.call();\n+    if (!call) return expr;\n \n-          return expr;\n-        }\n+    auto cmp = Comparison::Get(expr);\n+    if (!cmp) return expr;\n \n-        if (*cmp_guarantee & cmp_rhs_guarantee_rhs) {\n-          // x > 1, x >= 1, x != 1 cannot use guarantee x >= 3\n-          return expr;\n-        }\n+    auto rhs = call->arguments[1].literal();\n+    if (!rhs) return expr;\n+    if (!rhs->is_scalar()) return expr;\n \n-        if (*cmp & Comparison::GetFlipped(cmp_rhs_guarantee_rhs)) {\n-          // x > 1, x >= 1, x != 1 guaranteed by x >= 3\n-          return literal(true);\n-        } else {\n-          // x < 1, x <= 1, x == 1 unsatisfiable if x >= 3\n-          return literal(false);\n-        }\n+    const auto& lhs = Comparison::StripOrderPreservingCasts(call->arguments[0]);\n+    if (!lhs.field_ref()) return expr;\n+    if (*lhs.field_ref() != guarantee.target) return expr;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto cmp_rhs_bound, Comparison::Execute(*rhs, guarantee.bound));\n+    DCHECK_NE(cmp_rhs_bound, Comparison::NA);\n+\n+    if (cmp_rhs_bound == Comparison::EQUAL) {\n+      // RHS of filter is equal to RHS of guarantee\n+\n+      if ((*cmp & guarantee.cmp) == guarantee.cmp) {\n+        // guarantee is a subset of filter, so all data will be included\n+        // x > 1, x >= 1, x != 1 guaranteed by x > 1\n+        return simplified_to(lhs, true);\n+      }\n+\n+      if ((*cmp & guarantee.cmp) == 0) {\n+        // guarantee disjoint with filter, so all data will be excluded\n+        // x > 1, x >= 1, x != 1 unsatisfiable if x == 1\n+        return simplified_to(lhs, false);\n+      }\n+\n+      return expr;\n+    }\n+\n+    if (guarantee.cmp & cmp_rhs_bound) {\n\nReview Comment:\n   This is cryptic, what is this condition supposed to imply?\n\n\n\n##########\ncpp/src/arrow/compute/exec/expression.cc:\n##########\n@@ -879,79 +918,183 @@ Result<Expression> Canonicalize(Expression expr, compute::ExecContext* exec_cont\n \n namespace {\n \n-Result<Expression> DirectComparisonSimplification(Expression expr,\n-                                                  const Expression::Call& guarantee) {\n-  return Modify(\n-      std::move(expr), [](Expression expr) { return expr; },\n-      [&guarantee](Expression expr, ...) -> Result<Expression> {\n-        auto call = expr.call();\n-        if (!call) return expr;\n+// An inequality comparison which a target Expression is known to satisfy. If nullable,\n+// the target may evaluate to null in addition to values satisfying the comparison.\n+struct Inequality {\n+  Comparison::type cmp;\n+  const FieldRef& target;\n+  const Datum& bound;\n+  bool nullable;\n+\n+  // Extract an Inequality if possible, derived from \"less\",\n+  // \"greater\", \"less_equal\", and \"greater_equal\" expressions,\n+  // possibly disjuncted with an \"is_null\" Expression.\n+  // cmp(a, 2)\n+  // cmp(a, 2) or is_null(a)\n+  static util::optional<Inequality> ExtractOne(const Expression& guarantee) {\n+    auto call = guarantee.call();\n+    if (!call) return util::nullopt;\n+\n+    if (call->function_name == \"or_kleene\") {\n+      // expect the LHS to be a usable field inequality\n+      auto out = ExtractOneFromComparison(call->arguments[0]);\n+      if (!out) return util::nullopt;\n+\n+      // expect the RHS to be an is_null expression\n+      auto call_rhs = call->arguments[1].call();\n+      if (!call_rhs) return util::nullopt;\n+      if (call_rhs->function_name != \"is_null\") return util::nullopt;\n+\n+      // ... and that it references the same target\n+      auto target = call_rhs->arguments[0].field_ref();\n+      if (!target) return util::nullopt;\n+      if (*target != out->target) return util::nullopt;\n+\n+      out->nullable = true;\n+      return out;\n+    }\n \n-        // Ensure both calls are comparisons with equal LHS and scalar RHS\n-        auto cmp = Comparison::Get(expr);\n-        auto cmp_guarantee = Comparison::Get(guarantee.function_name);\n+    // fall back to a simple comparison with no \"is_null\"\n+    return ExtractOneFromComparison(guarantee);\n+  }\n \n-        if (!cmp) return expr;\n-        if (!cmp_guarantee) return expr;\n+  static util::optional<Inequality> ExtractOneFromComparison(\n+      const Expression& guarantee) {\n+    auto call = guarantee.call();\n+    if (!call) return util::nullopt;\n \n-        const auto& lhs = Comparison::StripOrderPreservingCasts(call->arguments[0]);\n-        const auto& guarantee_lhs = guarantee.arguments[0];\n-        if (lhs != guarantee_lhs) return expr;\n+    if (auto cmp = Comparison::Get(call->function_name)) {\n+      // not_equal comparisons are not very usable as guarantees\n+      if (*cmp == Comparison::NOT_EQUAL) return util::nullopt;\n \n-        auto rhs = call->arguments[1].literal();\n-        auto guarantee_rhs = guarantee.arguments[1].literal();\n+      auto target = call->arguments[0].field_ref();\n+      if (!target) return util::nullopt;\n \n-        if (!rhs) return expr;\n-        if (!rhs->is_scalar()) return expr;\n+      auto bound = call->arguments[1].literal();\n+      if (!bound) return util::nullopt;\n+      if (!bound->is_scalar()) return util::nullopt;\n \n-        if (!guarantee_rhs) return expr;\n-        if (!guarantee_rhs->is_scalar()) return expr;\n+      return Inequality{*cmp, /*target=*/*target, *bound, /*nullable=*/false};\n+    }\n \n-        ARROW_ASSIGN_OR_RAISE(auto cmp_rhs_guarantee_rhs,\n-                              Comparison::Execute(*rhs, *guarantee_rhs));\n-        DCHECK_NE(cmp_rhs_guarantee_rhs, Comparison::NA);\n+    return util::nullopt;\n+  }\n \n-        if (cmp_rhs_guarantee_rhs == Comparison::EQUAL) {\n-          // RHS of filter is equal to RHS of guarantee\n+  /// The given expression simplifies to `value` if the inequality\n+  /// target is not nullable. Otherwise, it simplifies to either a\n+  /// call to true_unless_null or !true_unless_null.\n+  Result<Expression> simplified_to(const Expression& bound_target, bool value) const {\n+    if (!nullable) return literal(value);\n+\n+    ExecContext exec_context;\n+\n+    // Data may be null, so comparison will yield `value` - or null IFF the data was null\n+    //\n+    // true_unless_null is cheap; it purely reuses the validity bitmap for the values\n+    // buffer. Inversion is less cheap but we expect that term never to be evaluated\n+    // since invert(true_unless_null(x)) is not satisfiable.\n+    Expression::Call call;\n+    call.function_name = \"true_unless_null\";\n+    call.arguments = {bound_target};\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto true_unless_null,\n+        BindNonRecursive(std::move(call),\n+                         /*insert_implicit_casts=*/false, &exec_context));\n+    if (value) return true_unless_null;\n+\n+    Expression::Call invert;\n+    invert.function_name = \"invert\";\n+    invert.arguments = {std::move(true_unless_null)};\n+    return BindNonRecursive(std::move(invert),\n+                            /*insert_implicit_casts=*/false, &exec_context);\n+  }\n \n-          if ((*cmp & *cmp_guarantee) == *cmp_guarantee) {\n-            // guarantee is a subset of filter, so all data will be included\n-            // x > 1, x >= 1, x != 1 guaranteed by x > 1\n-            return literal(true);\n-          }\n+  /// \\brief Simplify the given expression given this inequality as a guarantee.\n+  Result<Expression> Simplify(Expression expr) {\n+    const auto& guarantee = *this;\n \n-          if ((*cmp & *cmp_guarantee) == 0) {\n-            // guarantee disjoint with filter, so all data will be excluded\n-            // x > 1, x >= 1, x != 1 unsatisfiable if x == 1\n-            return literal(false);\n-          }\n+    auto call = expr.call();\n+    if (!call) return expr;\n \n-          return expr;\n-        }\n+    auto cmp = Comparison::Get(expr);\n+    if (!cmp) return expr;\n \n-        if (*cmp_guarantee & cmp_rhs_guarantee_rhs) {\n-          // x > 1, x >= 1, x != 1 cannot use guarantee x >= 3\n-          return expr;\n-        }\n+    auto rhs = call->arguments[1].literal();\n+    if (!rhs) return expr;\n+    if (!rhs->is_scalar()) return expr;\n \n-        if (*cmp & Comparison::GetFlipped(cmp_rhs_guarantee_rhs)) {\n-          // x > 1, x >= 1, x != 1 guaranteed by x >= 3\n-          return literal(true);\n-        } else {\n-          // x < 1, x <= 1, x == 1 unsatisfiable if x >= 3\n-          return literal(false);\n-        }\n+    const auto& lhs = Comparison::StripOrderPreservingCasts(call->arguments[0]);\n+    if (!lhs.field_ref()) return expr;\n+    if (*lhs.field_ref() != guarantee.target) return expr;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto cmp_rhs_bound, Comparison::Execute(*rhs, guarantee.bound));\n+    DCHECK_NE(cmp_rhs_bound, Comparison::NA);\n+\n+    if (cmp_rhs_bound == Comparison::EQUAL) {\n+      // RHS of filter is equal to RHS of guarantee\n+\n+      if ((*cmp & guarantee.cmp) == guarantee.cmp) {\n+        // guarantee is a subset of filter, so all data will be included\n+        // x > 1, x >= 1, x != 1 guaranteed by x > 1\n+        return simplified_to(lhs, true);\n+      }\n+\n+      if ((*cmp & guarantee.cmp) == 0) {\n+        // guarantee disjoint with filter, so all data will be excluded\n+        // x > 1, x >= 1, x != 1 unsatisfiable if x == 1\n+        return simplified_to(lhs, false);\n+      }\n+\n+      return expr;\n+    }\n+\n+    if (guarantee.cmp & cmp_rhs_bound) {\n+      // x > 1, x >= 1, x != 1 cannot use guarantee x >= 3\n\nReview Comment:\n   This is contradicted by the next comment below, did you make a mistake?\n\n\n\n##########\ncpp/src/arrow/compute/exec/expression.cc:\n##########\n@@ -879,79 +918,183 @@ Result<Expression> Canonicalize(Expression expr, compute::ExecContext* exec_cont\n \n namespace {\n \n-Result<Expression> DirectComparisonSimplification(Expression expr,\n-                                                  const Expression::Call& guarantee) {\n-  return Modify(\n-      std::move(expr), [](Expression expr) { return expr; },\n-      [&guarantee](Expression expr, ...) -> Result<Expression> {\n-        auto call = expr.call();\n-        if (!call) return expr;\n+// An inequality comparison which a target Expression is known to satisfy. If nullable,\n+// the target may evaluate to null in addition to values satisfying the comparison.\n+struct Inequality {\n+  Comparison::type cmp;\n+  const FieldRef& target;\n+  const Datum& bound;\n+  bool nullable;\n+\n+  // Extract an Inequality if possible, derived from \"less\",\n+  // \"greater\", \"less_equal\", and \"greater_equal\" expressions,\n+  // possibly disjuncted with an \"is_null\" Expression.\n+  // cmp(a, 2)\n+  // cmp(a, 2) or is_null(a)\n+  static util::optional<Inequality> ExtractOne(const Expression& guarantee) {\n+    auto call = guarantee.call();\n+    if (!call) return util::nullopt;\n+\n+    if (call->function_name == \"or_kleene\") {\n+      // expect the LHS to be a usable field inequality\n+      auto out = ExtractOneFromComparison(call->arguments[0]);\n+      if (!out) return util::nullopt;\n+\n+      // expect the RHS to be an is_null expression\n+      auto call_rhs = call->arguments[1].call();\n+      if (!call_rhs) return util::nullopt;\n+      if (call_rhs->function_name != \"is_null\") return util::nullopt;\n+\n+      // ... and that it references the same target\n+      auto target = call_rhs->arguments[0].field_ref();\n+      if (!target) return util::nullopt;\n+      if (*target != out->target) return util::nullopt;\n+\n+      out->nullable = true;\n+      return out;\n+    }\n \n-        // Ensure both calls are comparisons with equal LHS and scalar RHS\n-        auto cmp = Comparison::Get(expr);\n-        auto cmp_guarantee = Comparison::Get(guarantee.function_name);\n+    // fall back to a simple comparison with no \"is_null\"\n+    return ExtractOneFromComparison(guarantee);\n+  }\n \n-        if (!cmp) return expr;\n-        if (!cmp_guarantee) return expr;\n+  static util::optional<Inequality> ExtractOneFromComparison(\n+      const Expression& guarantee) {\n+    auto call = guarantee.call();\n+    if (!call) return util::nullopt;\n \n-        const auto& lhs = Comparison::StripOrderPreservingCasts(call->arguments[0]);\n-        const auto& guarantee_lhs = guarantee.arguments[0];\n-        if (lhs != guarantee_lhs) return expr;\n+    if (auto cmp = Comparison::Get(call->function_name)) {\n+      // not_equal comparisons are not very usable as guarantees\n+      if (*cmp == Comparison::NOT_EQUAL) return util::nullopt;\n \n-        auto rhs = call->arguments[1].literal();\n-        auto guarantee_rhs = guarantee.arguments[1].literal();\n+      auto target = call->arguments[0].field_ref();\n+      if (!target) return util::nullopt;\n \n-        if (!rhs) return expr;\n-        if (!rhs->is_scalar()) return expr;\n+      auto bound = call->arguments[1].literal();\n+      if (!bound) return util::nullopt;\n+      if (!bound->is_scalar()) return util::nullopt;\n \n-        if (!guarantee_rhs) return expr;\n-        if (!guarantee_rhs->is_scalar()) return expr;\n+      return Inequality{*cmp, /*target=*/*target, *bound, /*nullable=*/false};\n+    }\n \n-        ARROW_ASSIGN_OR_RAISE(auto cmp_rhs_guarantee_rhs,\n-                              Comparison::Execute(*rhs, *guarantee_rhs));\n-        DCHECK_NE(cmp_rhs_guarantee_rhs, Comparison::NA);\n+    return util::nullopt;\n+  }\n \n-        if (cmp_rhs_guarantee_rhs == Comparison::EQUAL) {\n-          // RHS of filter is equal to RHS of guarantee\n+  /// The given expression simplifies to `value` if the inequality\n+  /// target is not nullable. Otherwise, it simplifies to either a\n+  /// call to true_unless_null or !true_unless_null.\n+  Result<Expression> simplified_to(const Expression& bound_target, bool value) const {\n+    if (!nullable) return literal(value);\n+\n+    ExecContext exec_context;\n+\n+    // Data may be null, so comparison will yield `value` - or null IFF the data was null\n+    //\n+    // true_unless_null is cheap; it purely reuses the validity bitmap for the values\n+    // buffer. Inversion is less cheap but we expect that term never to be evaluated\n+    // since invert(true_unless_null(x)) is not satisfiable.\n+    Expression::Call call;\n+    call.function_name = \"true_unless_null\";\n+    call.arguments = {bound_target};\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto true_unless_null,\n+        BindNonRecursive(std::move(call),\n+                         /*insert_implicit_casts=*/false, &exec_context));\n+    if (value) return true_unless_null;\n+\n+    Expression::Call invert;\n+    invert.function_name = \"invert\";\n+    invert.arguments = {std::move(true_unless_null)};\n+    return BindNonRecursive(std::move(invert),\n+                            /*insert_implicit_casts=*/false, &exec_context);\n+  }\n \n-          if ((*cmp & *cmp_guarantee) == *cmp_guarantee) {\n-            // guarantee is a subset of filter, so all data will be included\n-            // x > 1, x >= 1, x != 1 guaranteed by x > 1\n-            return literal(true);\n-          }\n+  /// \\brief Simplify the given expression given this inequality as a guarantee.\n+  Result<Expression> Simplify(Expression expr) {\n+    const auto& guarantee = *this;\n \n-          if ((*cmp & *cmp_guarantee) == 0) {\n-            // guarantee disjoint with filter, so all data will be excluded\n-            // x > 1, x >= 1, x != 1 unsatisfiable if x == 1\n-            return literal(false);\n-          }\n+    auto call = expr.call();\n+    if (!call) return expr;\n \n-          return expr;\n-        }\n+    auto cmp = Comparison::Get(expr);\n+    if (!cmp) return expr;\n \n-        if (*cmp_guarantee & cmp_rhs_guarantee_rhs) {\n-          // x > 1, x >= 1, x != 1 cannot use guarantee x >= 3\n-          return expr;\n-        }\n+    auto rhs = call->arguments[1].literal();\n+    if (!rhs) return expr;\n+    if (!rhs->is_scalar()) return expr;\n \n-        if (*cmp & Comparison::GetFlipped(cmp_rhs_guarantee_rhs)) {\n-          // x > 1, x >= 1, x != 1 guaranteed by x >= 3\n-          return literal(true);\n-        } else {\n-          // x < 1, x <= 1, x == 1 unsatisfiable if x >= 3\n-          return literal(false);\n-        }\n+    const auto& lhs = Comparison::StripOrderPreservingCasts(call->arguments[0]);\n+    if (!lhs.field_ref()) return expr;\n+    if (*lhs.field_ref() != guarantee.target) return expr;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto cmp_rhs_bound, Comparison::Execute(*rhs, guarantee.bound));\n+    DCHECK_NE(cmp_rhs_bound, Comparison::NA);\n+\n+    if (cmp_rhs_bound == Comparison::EQUAL) {\n+      // RHS of filter is equal to RHS of guarantee\n+\n+      if ((*cmp & guarantee.cmp) == guarantee.cmp) {\n+        // guarantee is a subset of filter, so all data will be included\n+        // x > 1, x >= 1, x != 1 guaranteed by x > 1\n+        return simplified_to(lhs, true);\n+      }\n+\n+      if ((*cmp & guarantee.cmp) == 0) {\n+        // guarantee disjoint with filter, so all data will be excluded\n+        // x > 1, x >= 1, x != 1 unsatisfiable if x == 1\n+        return simplified_to(lhs, false);\n+      }\n+\n+      return expr;\n+    }\n+\n+    if (guarantee.cmp & cmp_rhs_bound) {\n+      // x > 1, x >= 1, x != 1 cannot use guarantee x >= 3\n+      return expr;\n+    }\n+\n+    if (*cmp & Comparison::GetFlipped(cmp_rhs_bound)) {\n+      // x > 1, x >= 1, x != 1 guaranteed by x >= 3\n+      return simplified_to(lhs, true);\n+    } else {\n+      // x < 1, x <= 1, x == 1 unsatisfiable if x >= 3\n+      return simplified_to(lhs, false);\n+    }\n+  }\n+};\n+\n+/// \\brief Simplify an expression given a guarantee, if the guarantee\n+///   is is_valid().\n+Result<Expression> IsValidSimplification(Expression expr,\n\nReview Comment:\n   Make this a verb, for example call it `SimplifyIsValid`.\n\n\n\n##########\ncpp/src/arrow/compute/exec/expression.cc:\n##########\n@@ -879,79 +918,183 @@ Result<Expression> Canonicalize(Expression expr, compute::ExecContext* exec_cont\n \n namespace {\n \n-Result<Expression> DirectComparisonSimplification(Expression expr,\n-                                                  const Expression::Call& guarantee) {\n-  return Modify(\n-      std::move(expr), [](Expression expr) { return expr; },\n-      [&guarantee](Expression expr, ...) -> Result<Expression> {\n-        auto call = expr.call();\n-        if (!call) return expr;\n+// An inequality comparison which a target Expression is known to satisfy. If nullable,\n+// the target may evaluate to null in addition to values satisfying the comparison.\n+struct Inequality {\n+  Comparison::type cmp;\n+  const FieldRef& target;\n+  const Datum& bound;\n+  bool nullable;\n\nReview Comment:\n   Is this \"the target can be null\"?\n\n\n\n",
                    "created": "2022-04-19T15:08:48.875+0000",
                    "updated": "2022-04-19T15:08:48.875+0000",
                    "started": "2022-04-19T15:08:48.875+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "758538",
                    "issueId": "13376844"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/758774",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #12891:\nURL: https://github.com/apache/arrow/pull/12891#discussion_r853417249\n\n\n##########\ncpp/src/arrow/util/vector.h:\n##########\n@@ -77,9 +77,14 @@ std::vector<T> ReplaceVectorElement(const std::vector<T>& values, size_t index,\n }\n \n template <typename T, typename Predicate>\n-std::vector<T> FilterVector(std::vector<T> values, Predicate&& predicate) {\n-  auto new_end =\n-      std::remove_if(values.begin(), values.end(), std::forward<Predicate>(predicate));\n+std::vector<T> FilterVector(std::vector<T> values, Predicate&& predicate,\n+                            std::vector<T>* filtered_out = NULLPTR) {\n\nReview Comment:\n   It's not used indeed. But the change is still needed since it actually inverts what FilterVector does! (The current FilterVector is backwards of what you would expect\u2026)\n\n\n\n",
                    "created": "2022-04-19T19:31:43.788+0000",
                    "updated": "2022-04-19T19:31:43.788+0000",
                    "started": "2022-04-19T19:31:43.788+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "758774",
                    "issueId": "13376844"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/758778",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #12891:\nURL: https://github.com/apache/arrow/pull/12891#discussion_r853420864\n\n\n##########\ncpp/src/arrow/dataset/file_parquet.cc:\n##########\n@@ -128,17 +128,30 @@ util::optional<compute::Expression> ColumnChunkStatisticsAsExpression(\n   auto maybe_min = min->CastTo(field->type());\n   auto maybe_max = max->CastTo(field->type());\n   if (maybe_min.ok() && maybe_max.ok()) {\n-    auto col_min = maybe_min.MoveValueUnsafe();\n-    auto col_max = maybe_max.MoveValueUnsafe();\n-    if (col_min->Equals(col_max)) {\n-      return compute::equal(std::move(field_expr), compute::literal(std::move(col_min)));\n+    min = maybe_min.MoveValueUnsafe();\n+    max = maybe_max.MoveValueUnsafe();\n+\n+    compute::Expression range;\n+    if (min->Equals(max)) {\n+      auto single_value = compute::equal(field_expr, compute::literal(std::move(min)));\n+\n+      if (statistics->null_count() == 0) {\n+        return compute::and_(single_value, compute::is_valid(field_expr));\n\nReview Comment:\n   Removing this does break a test, but it's because right now `i64 > 1` doesn't cause `is_null(i64)` to simplify - we need to be a little smarter here. Will fix that.\n\n\n\n",
                    "created": "2022-04-19T19:36:44.609+0000",
                    "updated": "2022-04-19T19:36:44.609+0000",
                    "started": "2022-04-19T19:36:44.609+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "758778",
                    "issueId": "13376844"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/758780",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #12891:\nURL: https://github.com/apache/arrow/pull/12891#discussion_r853427405\n\n\n##########\ncpp/src/arrow/compute/exec/expression.cc:\n##########\n@@ -305,19 +308,47 @@ bool Expression::IsNullLiteral() const {\n   return false;\n }\n \n-bool Expression::IsSatisfiable() const {\n-  if (type() && type()->id() == Type::NA) {\n-    return false;\n+namespace {\n+util::optional<compute::NullHandling::type> GetNullHandling(\n+    const Expression::Call& call) {\n+  DCHECK_NE(call.function, nullptr);\n+  if (call.function->kind() == compute::Function::SCALAR) {\n+    return static_cast<const compute::ScalarKernel*>(call.kernel)->null_handling;\n   }\n+  return util::nullopt;\n+}\n+}  // namespace\n+\n+bool Expression::IsSatisfiable() const {\n+  if (!type()) return true;\n+  if (type()->id() != Type::BOOL) return true;\n \n   if (auto lit = literal()) {\n     if (lit->null_count() == lit->length()) {\n       return false;\n     }\n \n-    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+    if (lit->is_scalar()) {\n       return lit->scalar_as<BooleanScalar>().value;\n     }\n+\n+    return true;\n+  }\n+\n+  if (field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  if (call->function_name == \"invert\") {\n+    if (auto nested_call = call->arguments[0].call()) {\n+      if (nested_call->function_name == \"true_unless_null\") return false;\n+    }\n+  }\n+\n+  if (call->function_name == \"and_kleene\") {\n\nReview Comment:\n   I'll move the explanation from https://issues.apache.org/jira/browse/ARROW-13848\n\n\n\n",
                    "created": "2022-04-19T19:44:05.762+0000",
                    "updated": "2022-04-19T19:44:05.762+0000",
                    "started": "2022-04-19T19:44:05.762+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "758780",
                    "issueId": "13376844"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/758782",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #12891:\nURL: https://github.com/apache/arrow/pull/12891#discussion_r853430402\n\n\n##########\ncpp/src/arrow/compute/exec/expression.cc:\n##########\n@@ -305,19 +308,47 @@ bool Expression::IsNullLiteral() const {\n   return false;\n }\n \n-bool Expression::IsSatisfiable() const {\n-  if (type() && type()->id() == Type::NA) {\n-    return false;\n+namespace {\n+util::optional<compute::NullHandling::type> GetNullHandling(\n+    const Expression::Call& call) {\n+  DCHECK_NE(call.function, nullptr);\n+  if (call.function->kind() == compute::Function::SCALAR) {\n+    return static_cast<const compute::ScalarKernel*>(call.kernel)->null_handling;\n   }\n+  return util::nullopt;\n+}\n+}  // namespace\n+\n+bool Expression::IsSatisfiable() const {\n+  if (!type()) return true;\n+  if (type()->id() != Type::BOOL) return true;\n \n   if (auto lit = literal()) {\n     if (lit->null_count() == lit->length()) {\n       return false;\n     }\n \n-    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+    if (lit->is_scalar()) {\n       return lit->scalar_as<BooleanScalar>().value;\n     }\n+\n+    return true;\n+  }\n+\n+  if (field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  if (call->function_name == \"invert\") {\n+    if (auto nested_call = call->arguments[0].call()) {\n+      if (nested_call->function_name == \"true_unless_null\") return false;\n+    }\n+  }\n+\n+  if (call->function_name == \"and_kleene\") {\n\nReview Comment:\n   Ah, actually, this is different. Yes, this should also accept \"and\".\n\n\n\n",
                    "created": "2022-04-19T19:48:21.484+0000",
                    "updated": "2022-04-19T19:48:21.484+0000",
                    "started": "2022-04-19T19:48:21.484+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "758782",
                    "issueId": "13376844"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/worklog/758805",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #12891:\nURL: https://github.com/apache/arrow/pull/12891#discussion_r853483076\n\n\n##########\ncpp/src/arrow/compute/exec/expression.cc:\n##########\n@@ -879,79 +918,183 @@ Result<Expression> Canonicalize(Expression expr, compute::ExecContext* exec_cont\n \n namespace {\n \n-Result<Expression> DirectComparisonSimplification(Expression expr,\n-                                                  const Expression::Call& guarantee) {\n-  return Modify(\n-      std::move(expr), [](Expression expr) { return expr; },\n-      [&guarantee](Expression expr, ...) -> Result<Expression> {\n-        auto call = expr.call();\n-        if (!call) return expr;\n+// An inequality comparison which a target Expression is known to satisfy. If nullable,\n+// the target may evaluate to null in addition to values satisfying the comparison.\n+struct Inequality {\n+  Comparison::type cmp;\n+  const FieldRef& target;\n+  const Datum& bound;\n+  bool nullable;\n+\n+  // Extract an Inequality if possible, derived from \"less\",\n+  // \"greater\", \"less_equal\", and \"greater_equal\" expressions,\n+  // possibly disjuncted with an \"is_null\" Expression.\n+  // cmp(a, 2)\n+  // cmp(a, 2) or is_null(a)\n+  static util::optional<Inequality> ExtractOne(const Expression& guarantee) {\n+    auto call = guarantee.call();\n+    if (!call) return util::nullopt;\n+\n+    if (call->function_name == \"or_kleene\") {\n+      // expect the LHS to be a usable field inequality\n+      auto out = ExtractOneFromComparison(call->arguments[0]);\n+      if (!out) return util::nullopt;\n+\n+      // expect the RHS to be an is_null expression\n+      auto call_rhs = call->arguments[1].call();\n+      if (!call_rhs) return util::nullopt;\n+      if (call_rhs->function_name != \"is_null\") return util::nullopt;\n+\n+      // ... and that it references the same target\n+      auto target = call_rhs->arguments[0].field_ref();\n+      if (!target) return util::nullopt;\n+      if (*target != out->target) return util::nullopt;\n+\n+      out->nullable = true;\n+      return out;\n+    }\n \n-        // Ensure both calls are comparisons with equal LHS and scalar RHS\n-        auto cmp = Comparison::Get(expr);\n-        auto cmp_guarantee = Comparison::Get(guarantee.function_name);\n+    // fall back to a simple comparison with no \"is_null\"\n+    return ExtractOneFromComparison(guarantee);\n+  }\n \n-        if (!cmp) return expr;\n-        if (!cmp_guarantee) return expr;\n+  static util::optional<Inequality> ExtractOneFromComparison(\n+      const Expression& guarantee) {\n+    auto call = guarantee.call();\n+    if (!call) return util::nullopt;\n \n-        const auto& lhs = Comparison::StripOrderPreservingCasts(call->arguments[0]);\n-        const auto& guarantee_lhs = guarantee.arguments[0];\n-        if (lhs != guarantee_lhs) return expr;\n+    if (auto cmp = Comparison::Get(call->function_name)) {\n+      // not_equal comparisons are not very usable as guarantees\n+      if (*cmp == Comparison::NOT_EQUAL) return util::nullopt;\n \n-        auto rhs = call->arguments[1].literal();\n-        auto guarantee_rhs = guarantee.arguments[1].literal();\n+      auto target = call->arguments[0].field_ref();\n+      if (!target) return util::nullopt;\n \n-        if (!rhs) return expr;\n-        if (!rhs->is_scalar()) return expr;\n+      auto bound = call->arguments[1].literal();\n+      if (!bound) return util::nullopt;\n+      if (!bound->is_scalar()) return util::nullopt;\n \n-        if (!guarantee_rhs) return expr;\n-        if (!guarantee_rhs->is_scalar()) return expr;\n+      return Inequality{*cmp, /*target=*/*target, *bound, /*nullable=*/false};\n+    }\n \n-        ARROW_ASSIGN_OR_RAISE(auto cmp_rhs_guarantee_rhs,\n-                              Comparison::Execute(*rhs, *guarantee_rhs));\n-        DCHECK_NE(cmp_rhs_guarantee_rhs, Comparison::NA);\n+    return util::nullopt;\n+  }\n \n-        if (cmp_rhs_guarantee_rhs == Comparison::EQUAL) {\n-          // RHS of filter is equal to RHS of guarantee\n+  /// The given expression simplifies to `value` if the inequality\n+  /// target is not nullable. Otherwise, it simplifies to either a\n+  /// call to true_unless_null or !true_unless_null.\n+  Result<Expression> simplified_to(const Expression& bound_target, bool value) const {\n+    if (!nullable) return literal(value);\n+\n+    ExecContext exec_context;\n+\n+    // Data may be null, so comparison will yield `value` - or null IFF the data was null\n+    //\n+    // true_unless_null is cheap; it purely reuses the validity bitmap for the values\n+    // buffer. Inversion is less cheap but we expect that term never to be evaluated\n+    // since invert(true_unless_null(x)) is not satisfiable.\n+    Expression::Call call;\n+    call.function_name = \"true_unless_null\";\n+    call.arguments = {bound_target};\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto true_unless_null,\n+        BindNonRecursive(std::move(call),\n+                         /*insert_implicit_casts=*/false, &exec_context));\n+    if (value) return true_unless_null;\n+\n+    Expression::Call invert;\n+    invert.function_name = \"invert\";\n+    invert.arguments = {std::move(true_unless_null)};\n+    return BindNonRecursive(std::move(invert),\n+                            /*insert_implicit_casts=*/false, &exec_context);\n+  }\n \n-          if ((*cmp & *cmp_guarantee) == *cmp_guarantee) {\n-            // guarantee is a subset of filter, so all data will be included\n-            // x > 1, x >= 1, x != 1 guaranteed by x > 1\n-            return literal(true);\n-          }\n+  /// \\brief Simplify the given expression given this inequality as a guarantee.\n+  Result<Expression> Simplify(Expression expr) {\n+    const auto& guarantee = *this;\n \n-          if ((*cmp & *cmp_guarantee) == 0) {\n-            // guarantee disjoint with filter, so all data will be excluded\n-            // x > 1, x >= 1, x != 1 unsatisfiable if x == 1\n-            return literal(false);\n-          }\n+    auto call = expr.call();\n+    if (!call) return expr;\n \n-          return expr;\n-        }\n+    auto cmp = Comparison::Get(expr);\n+    if (!cmp) return expr;\n \n-        if (*cmp_guarantee & cmp_rhs_guarantee_rhs) {\n-          // x > 1, x >= 1, x != 1 cannot use guarantee x >= 3\n-          return expr;\n-        }\n+    auto rhs = call->arguments[1].literal();\n+    if (!rhs) return expr;\n+    if (!rhs->is_scalar()) return expr;\n \n-        if (*cmp & Comparison::GetFlipped(cmp_rhs_guarantee_rhs)) {\n-          // x > 1, x >= 1, x != 1 guaranteed by x >= 3\n-          return literal(true);\n-        } else {\n-          // x < 1, x <= 1, x == 1 unsatisfiable if x >= 3\n-          return literal(false);\n-        }\n+    const auto& lhs = Comparison::StripOrderPreservingCasts(call->arguments[0]);\n+    if (!lhs.field_ref()) return expr;\n+    if (*lhs.field_ref() != guarantee.target) return expr;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto cmp_rhs_bound, Comparison::Execute(*rhs, guarantee.bound));\n+    DCHECK_NE(cmp_rhs_bound, Comparison::NA);\n+\n+    if (cmp_rhs_bound == Comparison::EQUAL) {\n+      // RHS of filter is equal to RHS of guarantee\n+\n+      if ((*cmp & guarantee.cmp) == guarantee.cmp) {\n+        // guarantee is a subset of filter, so all data will be included\n+        // x > 1, x >= 1, x != 1 guaranteed by x > 1\n+        return simplified_to(lhs, true);\n+      }\n+\n+      if ((*cmp & guarantee.cmp) == 0) {\n+        // guarantee disjoint with filter, so all data will be excluded\n+        // x > 1, x >= 1, x != 1 unsatisfiable if x == 1\n+        return simplified_to(lhs, false);\n+      }\n+\n+      return expr;\n+    }\n+\n+    if (guarantee.cmp & cmp_rhs_bound) {\n\nReview Comment:\n   It's unclear to me after writing out some examples (I don't think it handles all cases right either as you note with the incorrect comment)\n\n\n\n##########\ncpp/src/arrow/compute/exec/expression.cc:\n##########\n@@ -879,79 +918,183 @@ Result<Expression> Canonicalize(Expression expr, compute::ExecContext* exec_cont\n \n namespace {\n \n-Result<Expression> DirectComparisonSimplification(Expression expr,\n-                                                  const Expression::Call& guarantee) {\n-  return Modify(\n-      std::move(expr), [](Expression expr) { return expr; },\n-      [&guarantee](Expression expr, ...) -> Result<Expression> {\n-        auto call = expr.call();\n-        if (!call) return expr;\n+// An inequality comparison which a target Expression is known to satisfy. If nullable,\n+// the target may evaluate to null in addition to values satisfying the comparison.\n+struct Inequality {\n+  Comparison::type cmp;\n+  const FieldRef& target;\n+  const Datum& bound;\n+  bool nullable;\n+\n+  // Extract an Inequality if possible, derived from \"less\",\n+  // \"greater\", \"less_equal\", and \"greater_equal\" expressions,\n+  // possibly disjuncted with an \"is_null\" Expression.\n+  // cmp(a, 2)\n+  // cmp(a, 2) or is_null(a)\n+  static util::optional<Inequality> ExtractOne(const Expression& guarantee) {\n+    auto call = guarantee.call();\n+    if (!call) return util::nullopt;\n+\n+    if (call->function_name == \"or_kleene\") {\n+      // expect the LHS to be a usable field inequality\n+      auto out = ExtractOneFromComparison(call->arguments[0]);\n+      if (!out) return util::nullopt;\n+\n+      // expect the RHS to be an is_null expression\n+      auto call_rhs = call->arguments[1].call();\n+      if (!call_rhs) return util::nullopt;\n+      if (call_rhs->function_name != \"is_null\") return util::nullopt;\n+\n+      // ... and that it references the same target\n+      auto target = call_rhs->arguments[0].field_ref();\n+      if (!target) return util::nullopt;\n+      if (*target != out->target) return util::nullopt;\n+\n+      out->nullable = true;\n+      return out;\n+    }\n \n-        // Ensure both calls are comparisons with equal LHS and scalar RHS\n-        auto cmp = Comparison::Get(expr);\n-        auto cmp_guarantee = Comparison::Get(guarantee.function_name);\n+    // fall back to a simple comparison with no \"is_null\"\n+    return ExtractOneFromComparison(guarantee);\n+  }\n \n-        if (!cmp) return expr;\n-        if (!cmp_guarantee) return expr;\n+  static util::optional<Inequality> ExtractOneFromComparison(\n+      const Expression& guarantee) {\n+    auto call = guarantee.call();\n+    if (!call) return util::nullopt;\n \n-        const auto& lhs = Comparison::StripOrderPreservingCasts(call->arguments[0]);\n-        const auto& guarantee_lhs = guarantee.arguments[0];\n-        if (lhs != guarantee_lhs) return expr;\n+    if (auto cmp = Comparison::Get(call->function_name)) {\n+      // not_equal comparisons are not very usable as guarantees\n+      if (*cmp == Comparison::NOT_EQUAL) return util::nullopt;\n \n-        auto rhs = call->arguments[1].literal();\n-        auto guarantee_rhs = guarantee.arguments[1].literal();\n+      auto target = call->arguments[0].field_ref();\n+      if (!target) return util::nullopt;\n \n-        if (!rhs) return expr;\n-        if (!rhs->is_scalar()) return expr;\n+      auto bound = call->arguments[1].literal();\n+      if (!bound) return util::nullopt;\n+      if (!bound->is_scalar()) return util::nullopt;\n \n-        if (!guarantee_rhs) return expr;\n-        if (!guarantee_rhs->is_scalar()) return expr;\n+      return Inequality{*cmp, /*target=*/*target, *bound, /*nullable=*/false};\n+    }\n \n-        ARROW_ASSIGN_OR_RAISE(auto cmp_rhs_guarantee_rhs,\n-                              Comparison::Execute(*rhs, *guarantee_rhs));\n-        DCHECK_NE(cmp_rhs_guarantee_rhs, Comparison::NA);\n+    return util::nullopt;\n+  }\n \n-        if (cmp_rhs_guarantee_rhs == Comparison::EQUAL) {\n-          // RHS of filter is equal to RHS of guarantee\n+  /// The given expression simplifies to `value` if the inequality\n+  /// target is not nullable. Otherwise, it simplifies to either a\n+  /// call to true_unless_null or !true_unless_null.\n+  Result<Expression> simplified_to(const Expression& bound_target, bool value) const {\n+    if (!nullable) return literal(value);\n+\n+    ExecContext exec_context;\n+\n+    // Data may be null, so comparison will yield `value` - or null IFF the data was null\n+    //\n+    // true_unless_null is cheap; it purely reuses the validity bitmap for the values\n+    // buffer. Inversion is less cheap but we expect that term never to be evaluated\n+    // since invert(true_unless_null(x)) is not satisfiable.\n+    Expression::Call call;\n+    call.function_name = \"true_unless_null\";\n+    call.arguments = {bound_target};\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto true_unless_null,\n+        BindNonRecursive(std::move(call),\n+                         /*insert_implicit_casts=*/false, &exec_context));\n+    if (value) return true_unless_null;\n+\n+    Expression::Call invert;\n+    invert.function_name = \"invert\";\n+    invert.arguments = {std::move(true_unless_null)};\n+    return BindNonRecursive(std::move(invert),\n+                            /*insert_implicit_casts=*/false, &exec_context);\n+  }\n \n-          if ((*cmp & *cmp_guarantee) == *cmp_guarantee) {\n-            // guarantee is a subset of filter, so all data will be included\n-            // x > 1, x >= 1, x != 1 guaranteed by x > 1\n-            return literal(true);\n-          }\n+  /// \\brief Simplify the given expression given this inequality as a guarantee.\n+  Result<Expression> Simplify(Expression expr) {\n+    const auto& guarantee = *this;\n \n-          if ((*cmp & *cmp_guarantee) == 0) {\n-            // guarantee disjoint with filter, so all data will be excluded\n-            // x > 1, x >= 1, x != 1 unsatisfiable if x == 1\n-            return literal(false);\n-          }\n+    auto call = expr.call();\n+    if (!call) return expr;\n \n-          return expr;\n-        }\n+    auto cmp = Comparison::Get(expr);\n+    if (!cmp) return expr;\n \n-        if (*cmp_guarantee & cmp_rhs_guarantee_rhs) {\n-          // x > 1, x >= 1, x != 1 cannot use guarantee x >= 3\n-          return expr;\n-        }\n+    auto rhs = call->arguments[1].literal();\n+    if (!rhs) return expr;\n+    if (!rhs->is_scalar()) return expr;\n \n-        if (*cmp & Comparison::GetFlipped(cmp_rhs_guarantee_rhs)) {\n-          // x > 1, x >= 1, x != 1 guaranteed by x >= 3\n-          return literal(true);\n-        } else {\n-          // x < 1, x <= 1, x == 1 unsatisfiable if x >= 3\n-          return literal(false);\n-        }\n+    const auto& lhs = Comparison::StripOrderPreservingCasts(call->arguments[0]);\n+    if (!lhs.field_ref()) return expr;\n+    if (*lhs.field_ref() != guarantee.target) return expr;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto cmp_rhs_bound, Comparison::Execute(*rhs, guarantee.bound));\n+    DCHECK_NE(cmp_rhs_bound, Comparison::NA);\n+\n+    if (cmp_rhs_bound == Comparison::EQUAL) {\n+      // RHS of filter is equal to RHS of guarantee\n+\n+      if ((*cmp & guarantee.cmp) == guarantee.cmp) {\n+        // guarantee is a subset of filter, so all data will be included\n+        // x > 1, x >= 1, x != 1 guaranteed by x > 1\n+        return simplified_to(lhs, true);\n+      }\n+\n+      if ((*cmp & guarantee.cmp) == 0) {\n+        // guarantee disjoint with filter, so all data will be excluded\n+        // x > 1, x >= 1, x != 1 unsatisfiable if x == 1\n+        return simplified_to(lhs, false);\n+      }\n+\n+      return expr;\n+    }\n+\n+    if (guarantee.cmp & cmp_rhs_bound) {\n\nReview Comment:\n   I'll try to replace this\n\n\n\n",
                    "created": "2022-04-19T20:59:48.350+0000",
                    "updated": "2022-04-19T20:59:48.350+0000",
                    "started": "2022-04-19T20:59:48.349+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "758805",
                    "issueId": "13376844"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 24000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@6556f8bf[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@42243e48[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2a1d1023[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@4928ad56[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@64ca5bbc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@78eedb06[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3a305030[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@367e183d[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@dfa2f5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@e677f03[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@36ee0f2f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@7017563f[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 24000,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Apr 21 18:55:23 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-04-21T18:55:23.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12659/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2021-05-05T18:06:12.000+0000",
        "updated": "2022-04-24T14:31:06.000+0000",
        "timeoriginalestimate": null,
        "description": "Simplifying a predicate using is_null with a guarantee using invert(is_null()) doesn't lead to any simplification.\r\n\r\nOnce supported, tests should be added for Datasets to exercise row group filtering (and to generate the necessary clauses from statistics).",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "6h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 24000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Compute] Support SimplifyWithGuarantee(is_null(foo), is_valid(foo))",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/comment/17339840",
                    "id": "17339840",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "I can definitely see the utility of producing a row group statistics expression which includes non nullability, but I think it'd be {{foo >= 3 and foo <= 4 and is_valid(foo)}}\r\n\r\ninstead of  {{foo >= 3 and foo <= 4 and invert(is_null(foo))}}\r\n\r\nFor simplicity and also to limit the requisite depth of pattern recognition for guarantees.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-05-05T18:48:39.501+0000",
                    "updated": "2021-05-05T18:52:42.030+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/comment/17339844",
                    "id": "17339844",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Ah yes, you're right. I gave that a test too, but no dice (and I don't see any handling for is_valid in SimplifyWithGuarantee).",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-05-05T18:52:06.131+0000",
                    "updated": "2021-05-05T18:52:06.131+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376844/comment/17525987",
                    "id": "17525987",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jonkeane",
                        "name": "jonkeane",
                        "key": "jonkeane",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Jonathan Keane",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Issue resolved by pull request 12891\n[https://github.com/apache/arrow/pull/12891]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jonkeane",
                        "name": "jonkeane",
                        "key": "jonkeane",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Jonathan Keane",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-04-21T18:55:23.829+0000",
                    "updated": "2022-04-21T18:55:23.829+0000"
                }
            ],
            "maxResults": 3,
            "total": 3,
            "startAt": 0
        },
        "customfield_12311820": "0|z0qrao:",
        "customfield_12314139": null
    }
}