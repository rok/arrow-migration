{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13297736",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736",
    "key": "ARROW-8401",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12346687",
                "id": "12346687",
                "description": "",
                "name": "0.17.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-04-20"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=frank.du",
            "name": "frank.du",
            "key": "frank.du",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Frank Du",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=frank.du",
            "name": "frank.du",
            "key": "frank.du",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Frank Du",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=frank.du",
            "name": "frank.du",
            "key": "frank.du",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Frank Du",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 26400,
            "total": 26400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 26400,
            "total": 26400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-8401/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 51,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420689",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jianxind commented on pull request #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899\n \n \n   For decode, similar implementation with the SSE version, AVX512 reach up to\r\n   1.9x performance vs SSE on 1024 size float path while AVX2 get 1.5x.\r\n   \r\n   For encode, float path implemented for AVX2/AVX512, double fall back to sse\r\n   as currently no efficient way to pack a 128i target block. AVX512 reach 2.8x\r\n   improvement vs SSE on 1024 float, AVX2 is 1.6x.\r\n   \r\n   Signed-off-by: Frank Du <frank.du@intel.com>\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-11T05:32:14.608+0000",
                    "updated": "2020-04-11T05:32:14.608+0000",
                    "started": "2020-04-11T05:32:14.608+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420689",
                    "issueId": "13297736"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420691",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jianxind commented on issue #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899#issuecomment-612334271\n \n \n   Below is the size 1024 result,\r\n   \r\n   SSE:\r\n   BM_ByteStreamSplitDecode_Float_SIMD/1024            132 ns          132 ns      5296552 bytes_per_second=28.891G/s\r\n   BM_ByteStreamSplitDecode_Double_SIMD/1024           387 ns          386 ns      1818101 bytes_per_second=19.7603G/s\r\n   BM_ByteStreamSplitEncode_Float_SIMD/1024            263 ns          263 ns      2663415 bytes_per_second=14.5051G/s\r\n   \r\n   AVX2:\r\n   BM_ByteStreamSplitDecode_Float_SIMD/1024            104 ns          104 ns      6727450 bytes_per_second=36.686G/s\r\n   BM_ByteStreamSplitDecode_Double_SIMD/1024           265 ns          265 ns      2641345 bytes_per_second=28.7856G/s\r\n   BM_ByteStreamSplitEncode_Float_SIMD/1024            169 ns          169 ns      4147448 bytes_per_second=22.6001G/s\r\n   \r\n   AVX512:\r\n   BM_ByteStreamSplitDecode_Float_SIMD/1024           70.3 ns         70.2 ns      9315691 bytes_per_second=54.356G/s\r\n   BM_ByteStreamSplitDecode_Double_SIMD/1024           173 ns          173 ns      4038812 bytes_per_second=44.0386G/s\r\n   BM_ByteStreamSplitEncode_Float_SIMD/1024           88.3 ns         88.2 ns      7936455 bytes_per_second=43.2519G/s\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-11T05:35:04.866+0000",
                    "updated": "2020-04-11T05:35:04.866+0000",
                    "started": "2020-04-11T05:35:04.866+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420691",
                    "issueId": "13297736"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420693",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on issue #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899#issuecomment-612336154\n \n \n   https://issues.apache.org/jira/browse/ARROW-8401\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-11T05:46:52.624+0000",
                    "updated": "2020-04-11T05:46:52.624+0000",
                    "started": "2020-04-11T05:46:52.624+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420693",
                    "issueId": "13297736"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420708",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jianxind commented on pull request #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899\n \n \n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-11T08:55:20.900+0000",
                    "updated": "2020-04-11T08:55:20.900+0000",
                    "started": "2020-04-11T08:55:20.900+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420708",
                    "issueId": "13297736"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420744",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jianxind commented on issue #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899#issuecomment-612334271\n \n \n   Below is the size 1024 result,\r\n   \r\n   SSE:\r\n   BM_ByteStreamSplitDecode_Float_SIMD/1024            132 ns          132 ns      5296552 bytes_per_second=28.891G/s\r\n   BM_ByteStreamSplitDecode_Double_SIMD/1024           387 ns          386 ns      1818101 bytes_per_second=19.7603G/s\r\n   BM_ByteStreamSplitEncode_Float_SIMD/1024            263 ns          263 ns      2663415 bytes_per_second=14.5051G/s\r\n   BM_ByteStreamSplitEncode_Double_SIMD/1024           516 ns          516 ns      1358304 bytes_per_second=14.7992G/s\r\n   \r\n   AVX2:\r\n   BM_ByteStreamSplitDecode_Float_SIMD/1024            104 ns          104 ns      6727450 bytes_per_second=36.686G/s\r\n   BM_ByteStreamSplitDecode_Double_SIMD/1024           265 ns          265 ns      2641345 bytes_per_second=28.7856G/s\r\n   BM_ByteStreamSplitEncode_Float_SIMD/1024            169 ns          169 ns      4147448 bytes_per_second=22.6001G/s\r\n   BM_ByteStreamSplitEncode_Double_SIMD/1024           517 ns          517 ns      1355341 bytes_per_second=14.7681G/s\r\n   \r\n   AVX512:\r\n   BM_ByteStreamSplitDecode_Float_SIMD/1024           70.3 ns         70.2 ns      9315691 bytes_per_second=54.356G/s\r\n   BM_ByteStreamSplitDecode_Double_SIMD/1024           173 ns          173 ns      4038812 bytes_per_second=44.0386G/s\r\n   BM_ByteStreamSplitEncode_Float_SIMD/1024           88.3 ns         88.2 ns      7936455 bytes_per_second=43.2519G/s\r\n   BM_ByteStreamSplitEncode_Double_SIMD/1024           207 ns          207 ns      3385916 bytes_per_second=36.892G/s\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-11T11:18:23.246+0000",
                    "updated": "2020-04-11T11:18:23.246+0000",
                    "started": "2020-04-11T11:18:23.245+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420744",
                    "issueId": "13297736"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420745",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jianxind commented on issue #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899#issuecomment-612334271\n \n \n   Below is the BM_ByteStreamSplitDecode result for size 1024,\r\n   \r\n   SSE:\r\n   BM_ByteStreamSplitDecode_Float_SIMD/1024            132 ns          132 ns      5296552 bytes_per_second=28.891G/s\r\n   BM_ByteStreamSplitDecode_Double_SIMD/1024           387 ns          386 ns      1818101 bytes_per_second=19.7603G/s\r\n   BM_ByteStreamSplitEncode_Float_SIMD/1024            263 ns          263 ns      2663415 bytes_per_second=14.5051G/s\r\n   BM_ByteStreamSplitEncode_Double_SIMD/1024           516 ns          516 ns      1358304 bytes_per_second=14.7992G/s\r\n   \r\n   AVX2:\r\n   BM_ByteStreamSplitDecode_Float_SIMD/1024            104 ns          104 ns      6727450 bytes_per_second=36.686G/s\r\n   BM_ByteStreamSplitDecode_Double_SIMD/1024           265 ns          265 ns      2641345 bytes_per_second=28.7856G/s\r\n   BM_ByteStreamSplitEncode_Float_SIMD/1024            169 ns          169 ns      4147448 bytes_per_second=22.6001G/s\r\n   BM_ByteStreamSplitEncode_Double_SIMD/1024           517 ns          517 ns      1355341 bytes_per_second=14.7681G/s\r\n   \r\n   AVX512:\r\n   BM_ByteStreamSplitDecode_Float_SIMD/1024           70.3 ns         70.2 ns      9315691 bytes_per_second=54.356G/s\r\n   BM_ByteStreamSplitDecode_Double_SIMD/1024           173 ns          173 ns      4038812 bytes_per_second=44.0386G/s\r\n   BM_ByteStreamSplitEncode_Float_SIMD/1024           88.3 ns         88.2 ns      7936455 bytes_per_second=43.2519G/s\r\n   BM_ByteStreamSplitEncode_Double_SIMD/1024           207 ns          207 ns      3385916 bytes_per_second=36.892G/s\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-11T11:19:10.169+0000",
                    "updated": "2020-04-11T11:19:10.169+0000",
                    "started": "2020-04-11T11:19:10.169+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420745",
                    "issueId": "13297736"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420746",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jianxind commented on pull request #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899\n \n \n   For decode, similar implementation with the SSE version for both AVX512 and AVX2.\r\n   \r\n   For encode, float path implemented for AVX2/AVX512 also double for AVX512.\r\n   AVX2 double fall back to SSE as currently no epi16 permute support.\r\n   \r\n   BM_ByteStreamSplit result reach up to 3x for AVX512, 2x for AVX2.\r\n   \r\n   Signed-off-by: Frank Du <frank.du@intel.com>\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-11T11:19:28.571+0000",
                    "updated": "2020-04-11T11:19:28.571+0000",
                    "started": "2020-04-11T11:19:28.571+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420746",
                    "issueId": "13297736"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420804",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899#discussion_r407099471\n \n \n\n ##########\n File path: cpp/src/arrow/util/byte_stream_split.h\n ##########\n @@ -171,6 +171,381 @@ void ByteStreamSplitEncodeSSE2(const uint8_t* raw_values, const size_t num_value\n \n #endif\n \n+#if defined(ARROW_HAVE_AVX2)\n+template <typename T>\n+void _ByteStreamSplitDecodeAVX2(const uint8_t* data, int64_t num_values, int64_t stride,\n+                                T* out) {\n+  constexpr size_t kNumStreams = sizeof(T);\n+  constexpr size_t kNumStreamsLog2 = (kNumStreams == 8U ? 3U : 2U);\n+\n+  const int64_t size = num_values * sizeof(T);\n+  const int64_t block_size = sizeof(__m256i) * kNumStreams;\n+  if (size < block_size)  // Back to SSE for small size\n+    return _ByteStreamSplitDecodeSSE2(data, num_values, stride, out);\n+  const int64_t num_blocks = size / block_size;\n+  uint8_t* output_data = reinterpret_cast<uint8_t*>(out);\n+\n+  // First handle suffix.\n+  const int64_t num_processed_elements = (num_blocks * block_size) / kNumStreams;\n+  for (int64_t i = num_processed_elements; i < num_values; ++i) {\n+    uint8_t gathered_byte_data[kNumStreams];\n+    for (size_t b = 0; b < kNumStreams; ++b) {\n+      const size_t byte_index = b * stride + i;\n+      gathered_byte_data[b] = data[byte_index];\n+    }\n+    out[i] = arrow::util::SafeLoadAs<T>(&gathered_byte_data[0]);\n+  }\n+\n+  // Processed hierahically using unpack intrinsics, then permute intrinsics.\n+  __m256i stage[kNumStreamsLog2 + 1U][kNumStreams];\n+  __m256i final_result[kNumStreams];\n+  const size_t half = kNumStreams / 2U;\n+\n+  for (int64_t i = 0; i < num_blocks; ++i) {\n+    for (size_t j = 0; j < kNumStreams; ++j) {\n+      stage[0][j] = _mm256_loadu_si256(\n+          reinterpret_cast<const __m256i*>(&data[i * sizeof(__m256i) + j * stride]));\n+    }\n+\n+    for (size_t step = 0; step < kNumStreamsLog2; ++step) {\n+      for (size_t j = 0; j < half; ++j) {\n+        stage[step + 1U][j * 2] =\n+            _mm256_unpacklo_epi8(stage[step][j], stage[step][half + j]);\n+        stage[step + 1U][j * 2 + 1U] =\n+            _mm256_unpackhi_epi8(stage[step][j], stage[step][half + j]);\n+      }\n+    }\n+\n+    __m256i* unpack = &stage[kNumStreamsLog2][0];\n+    if (kNumStreams == 8U) {\n+      // path for double, 128i index:\n+      //   {0x00, 0x08}, {0x01, 0x09}, {0x02, 0x0A}, {0x03, 0x0B},\n+      //   {0x04, 0x0C}, {0x05, 0x0D}, {0x06, 0x0E}, {0x07, 0x0F},\n+      final_result[0] = _mm256_permute2x128_si256(unpack[0], unpack[1], 0b00100000);\n+      final_result[1] = _mm256_permute2x128_si256(unpack[2], unpack[3], 0b00100000);\n+      final_result[2] = _mm256_permute2x128_si256(unpack[4], unpack[5], 0b00100000);\n+      final_result[3] = _mm256_permute2x128_si256(unpack[6], unpack[7], 0b00100000);\n+      final_result[4] = _mm256_permute2x128_si256(unpack[0], unpack[1], 0b00110001);\n+      final_result[5] = _mm256_permute2x128_si256(unpack[2], unpack[3], 0b00110001);\n+      final_result[6] = _mm256_permute2x128_si256(unpack[4], unpack[5], 0b00110001);\n+      final_result[7] = _mm256_permute2x128_si256(unpack[6], unpack[7], 0b00110001);\n+    } else {\n+      // path for float, 128i index:\n+      //   {0x00, 0x04}, {0x01, 0x05}, {0x02, 0x06}, {0x03, 0x07}\n+      final_result[0] = _mm256_permute2x128_si256(unpack[0], unpack[1], 0b00100000);\n+      final_result[1] = _mm256_permute2x128_si256(unpack[2], unpack[3], 0b00100000);\n+      final_result[2] = _mm256_permute2x128_si256(unpack[0], unpack[1], 0b00110001);\n+      final_result[3] = _mm256_permute2x128_si256(unpack[2], unpack[3], 0b00110001);\n+    }\n+\n+    for (size_t j = 0; j < kNumStreams; ++j) {\n+      _mm256_storeu_si256(reinterpret_cast<__m256i*>(\n+                              &output_data[(i * kNumStreams + j) * sizeof(__m256i)]),\n+                          final_result[j]);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void _ByteStreamSplitEncodeAVX2(const uint8_t* raw_values, const size_t num_values,\n+                                uint8_t* output_buffer_raw) {\n+  constexpr size_t num_streams = sizeof(T);\n \n Review comment:\n   style: kNumStreams\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-11T19:12:06.172+0000",
                    "updated": "2020-04-11T19:12:06.172+0000",
                    "started": "2020-04-11T19:12:06.172+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420804",
                    "issueId": "13297736"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420805",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899#discussion_r407099831\n \n \n\n ##########\n File path: cpp/src/arrow/util/byte_stream_split.h\n ##########\n @@ -171,6 +171,381 @@ void ByteStreamSplitEncodeSSE2(const uint8_t* raw_values, const size_t num_value\n \n #endif\n \n+#if defined(ARROW_HAVE_AVX2)\n+template <typename T>\n+void _ByteStreamSplitDecodeAVX2(const uint8_t* data, int64_t num_values, int64_t stride,\n \n Review comment:\n   style: I think it would be better to move all SIMD implementation to a new header file  called something like  byte_stream_split_simd_internal.h and move put the functions in an \"internal\" namespace instead of prefixing with and underscore.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-11T19:12:06.282+0000",
                    "updated": "2020-04-11T19:12:06.282+0000",
                    "started": "2020-04-11T19:12:06.282+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420805",
                    "issueId": "13297736"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420806",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899#discussion_r407099642\n \n \n\n ##########\n File path: cpp/src/arrow/util/byte_stream_split.h\n ##########\n @@ -171,6 +171,381 @@ void ByteStreamSplitEncodeSSE2(const uint8_t* raw_values, const size_t num_value\n \n #endif\n \n+#if defined(ARROW_HAVE_AVX2)\n+template <typename T>\n+void _ByteStreamSplitDecodeAVX2(const uint8_t* data, int64_t num_values, int64_t stride,\n+                                T* out) {\n+  constexpr size_t kNumStreams = sizeof(T);\n+  constexpr size_t kNumStreamsLog2 = (kNumStreams == 8U ? 3U : 2U);\n+\n+  const int64_t size = num_values * sizeof(T);\n+  const int64_t block_size = sizeof(__m256i) * kNumStreams;\n+  if (size < block_size)  // Back to SSE for small size\n+    return _ByteStreamSplitDecodeSSE2(data, num_values, stride, out);\n+  const int64_t num_blocks = size / block_size;\n+  uint8_t* output_data = reinterpret_cast<uint8_t*>(out);\n+\n+  // First handle suffix.\n+  const int64_t num_processed_elements = (num_blocks * block_size) / kNumStreams;\n+  for (int64_t i = num_processed_elements; i < num_values; ++i) {\n+    uint8_t gathered_byte_data[kNumStreams];\n+    for (size_t b = 0; b < kNumStreams; ++b) {\n+      const size_t byte_index = b * stride + i;\n+      gathered_byte_data[b] = data[byte_index];\n+    }\n+    out[i] = arrow::util::SafeLoadAs<T>(&gathered_byte_data[0]);\n+  }\n+\n+  // Processed hierahically using unpack intrinsics, then permute intrinsics.\n+  __m256i stage[kNumStreamsLog2 + 1U][kNumStreams];\n+  __m256i final_result[kNumStreams];\n+  const size_t half = kNumStreams / 2U;\n+\n+  for (int64_t i = 0; i < num_blocks; ++i) {\n+    for (size_t j = 0; j < kNumStreams; ++j) {\n+      stage[0][j] = _mm256_loadu_si256(\n+          reinterpret_cast<const __m256i*>(&data[i * sizeof(__m256i) + j * stride]));\n+    }\n+\n+    for (size_t step = 0; step < kNumStreamsLog2; ++step) {\n+      for (size_t j = 0; j < half; ++j) {\n+        stage[step + 1U][j * 2] =\n+            _mm256_unpacklo_epi8(stage[step][j], stage[step][half + j]);\n+        stage[step + 1U][j * 2 + 1U] =\n+            _mm256_unpackhi_epi8(stage[step][j], stage[step][half + j]);\n+      }\n+    }\n+\n+    __m256i* unpack = &stage[kNumStreamsLog2][0];\n+    if (kNumStreams == 8U) {\n+      // path for double, 128i index:\n+      //   {0x00, 0x08}, {0x01, 0x09}, {0x02, 0x0A}, {0x03, 0x0B},\n+      //   {0x04, 0x0C}, {0x05, 0x0D}, {0x06, 0x0E}, {0x07, 0x0F},\n+      final_result[0] = _mm256_permute2x128_si256(unpack[0], unpack[1], 0b00100000);\n+      final_result[1] = _mm256_permute2x128_si256(unpack[2], unpack[3], 0b00100000);\n+      final_result[2] = _mm256_permute2x128_si256(unpack[4], unpack[5], 0b00100000);\n+      final_result[3] = _mm256_permute2x128_si256(unpack[6], unpack[7], 0b00100000);\n+      final_result[4] = _mm256_permute2x128_si256(unpack[0], unpack[1], 0b00110001);\n+      final_result[5] = _mm256_permute2x128_si256(unpack[2], unpack[3], 0b00110001);\n+      final_result[6] = _mm256_permute2x128_si256(unpack[4], unpack[5], 0b00110001);\n+      final_result[7] = _mm256_permute2x128_si256(unpack[6], unpack[7], 0b00110001);\n+    } else {\n+      // path for float, 128i index:\n+      //   {0x00, 0x04}, {0x01, 0x05}, {0x02, 0x06}, {0x03, 0x07}\n+      final_result[0] = _mm256_permute2x128_si256(unpack[0], unpack[1], 0b00100000);\n+      final_result[1] = _mm256_permute2x128_si256(unpack[2], unpack[3], 0b00100000);\n+      final_result[2] = _mm256_permute2x128_si256(unpack[0], unpack[1], 0b00110001);\n+      final_result[3] = _mm256_permute2x128_si256(unpack[2], unpack[3], 0b00110001);\n+    }\n+\n+    for (size_t j = 0; j < kNumStreams; ++j) {\n+      _mm256_storeu_si256(reinterpret_cast<__m256i*>(\n+                              &output_data[(i * kNumStreams + j) * sizeof(__m256i)]),\n+                          final_result[j]);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void _ByteStreamSplitEncodeAVX2(const uint8_t* raw_values, const size_t num_values,\n+                                uint8_t* output_buffer_raw) {\n+  constexpr size_t num_streams = sizeof(T);\n+  static_assert(num_streams == 4U || num_streams == 8U, \"Invalid number of streams.\");\n+  if (num_streams == 8U)  // Back to SSE, currently no path for double.\n+    return _ByteStreamSplitEncodeSSE2<T>(raw_values, num_values, output_buffer_raw);\n+\n+  const size_t size = num_values * sizeof(T);\n+  const size_t block_size = sizeof(__m256i) * num_streams;\n+  if (size < block_size)  // Back to SSE for small size\n+    return _ByteStreamSplitEncodeSSE2<T>(raw_values, num_values, output_buffer_raw);\n+  const size_t num_blocks = size / block_size;\n+  const __m256i* raw_values_simd = reinterpret_cast<const __m256i*>(raw_values);\n+  __m256i* output_buffer_streams[num_streams];\n+\n+  for (size_t i = 0; i < num_streams; ++i) {\n+    output_buffer_streams[i] =\n+        reinterpret_cast<__m256i*>(&output_buffer_raw[num_values * i]);\n+  }\n+\n+  const size_t num_processed_elements = (num_blocks * block_size) / sizeof(T);\n+  for (size_t i = num_processed_elements; i < num_values; ++i) {\n+    for (size_t j = 0U; j < num_streams; ++j) {\n+      const uint8_t byte_in_value = raw_values[i * num_streams + j];\n+      output_buffer_raw[j * num_values + i] = byte_in_value;\n+    }\n+  }\n+\n+  // Path for float.\n+  // 1. Processed hierahically to 32i blcok using the unpack intrinsics.\n+  // 2. Pack 128i block using _mm256_permutevar8x32_epi32.\n+  // 3. Pack final 256i block with _mm256_permute2x128_si256.\n+  __m256i stage[4][num_streams];\n+  __m256i permute_mask = _mm256_set_epi32(0x07, 0x03, 0x06, 0x02, 0x05, 0x01, 0x04, 0x00);\n+  __m256i permute[num_streams];\n+  __m256i final_result[num_streams];\n+\n+  for (size_t block_index = 0; block_index < num_blocks; ++block_index) {\n+    // First copy the data to stage 0.\n+    for (size_t i = 0; i < num_streams; ++i) {\n+      stage[0][i] = _mm256_loadu_si256(&raw_values_simd[block_index * num_streams + i]);\n+    }\n+\n+    for (size_t stage_lvl = 0; stage_lvl < 3U; ++stage_lvl) {\n+      for (size_t i = 0; i < num_streams / 2U; ++i) {\n+        stage[stage_lvl + 1][i * 2] =\n+            _mm256_unpacklo_epi8(stage[stage_lvl][i * 2], stage[stage_lvl][i * 2 + 1]);\n+        stage[stage_lvl + 1][i * 2 + 1] =\n+            _mm256_unpackhi_epi8(stage[stage_lvl][i * 2], stage[stage_lvl][i * 2 + 1]);\n+      }\n+    }\n+\n+    for (size_t i = 0; i < num_streams; ++i) {\n+      permute[i] = _mm256_permutevar8x32_epi32(stage[3][i], permute_mask);\n+    }\n+\n+    final_result[0] = _mm256_permute2x128_si256(permute[0], permute[2], 0b00100000);\n+    final_result[1] = _mm256_permute2x128_si256(permute[0], permute[2], 0b00110001);\n+    final_result[2] = _mm256_permute2x128_si256(permute[1], permute[3], 0b00100000);\n+    final_result[3] = _mm256_permute2x128_si256(permute[1], permute[3], 0b00110001);\n+\n+    for (size_t i = 0; i < num_streams; ++i) {\n+      _mm256_storeu_si256(&output_buffer_streams[i][block_index], final_result[i]);\n+    }\n+  }\n+}\n+#endif\n+\n+#if defined(ARROW_HAVE_AVX512)\n+template <typename T>\n+void _ByteStreamSplitDecodeAVX512(const uint8_t* data, int64_t num_values, int64_t stride,\n+                                  T* out) {\n+  constexpr size_t kNumStreams = sizeof(T);\n+  constexpr size_t kNumStreamsLog2 = (kNumStreams == 8U ? 3U : 2U);\n+\n+  const int64_t size = num_values * sizeof(T);\n+  const int64_t block_size = sizeof(__m512i) * kNumStreams;\n+  if (size < block_size)  // Back to AVX2 for small size\n+    return _ByteStreamSplitDecodeAVX2(data, num_values, stride, out);\n+  const int64_t num_blocks = size / block_size;\n+  uint8_t* output_data = reinterpret_cast<uint8_t*>(out);\n+\n+  // First handle suffix.\n+  const int64_t num_processed_elements = (num_blocks * block_size) / kNumStreams;\n+  for (int64_t i = num_processed_elements; i < num_values; ++i) {\n+    uint8_t gathered_byte_data[kNumStreams];\n+    for (size_t b = 0; b < kNumStreams; ++b) {\n+      const size_t byte_index = b * stride + i;\n+      gathered_byte_data[b] = data[byte_index];\n+    }\n+    out[i] = arrow::util::SafeLoadAs<T>(&gathered_byte_data[0]);\n+  }\n+\n+  // Processed hierahically using the unpack, then two shuffles.\n+  __m512i stage[kNumStreamsLog2 + 1U][kNumStreams];\n+  __m512i shuffle[2][kNumStreams];\n+  const size_t half = kNumStreams / 2U;\n+\n+  for (int64_t i = 0; i < num_blocks; ++i) {\n+    for (size_t j = 0; j < kNumStreams; ++j) {\n+      stage[0][j] = _mm512_loadu_si512(\n+          reinterpret_cast<const __m512i*>(&data[i * sizeof(__m512i) + j * stride]));\n+    }\n+\n+    for (size_t step = 0; step < kNumStreamsLog2; ++step) {\n+      for (size_t j = 0; j < half; ++j) {\n+        stage[step + 1U][j * 2] =\n+            _mm512_unpacklo_epi8(stage[step][j], stage[step][half + j]);\n+        stage[step + 1U][j * 2 + 1U] =\n+            _mm512_unpackhi_epi8(stage[step][j], stage[step][half + j]);\n+      }\n+    }\n+\n+    __m512i* unpack = &stage[kNumStreamsLog2][0];\n+    if (kNumStreams == 8U) {\n+      // path for double, 128i index:\n+      // {0x00, 0x04, 0x08, 0x0C}, {0x10, 0x14, 0x18, 0x1C},\n+      // {0x01, 0x05, 0x09, 0x0D}, {0x11, 0x15, 0x19, 0x1D},\n+      // {0x02, 0x06, 0x0A, 0x0E}, {0x12, 0x16, 0x1A, 0x1E},\n+      // {0x03, 0x07, 0x0B, 0x0F}, {0x13, 0x17, 0x1B, 0x1F},\n+      shuffle[0][0] = _mm512_shuffle_i32x4(unpack[0], unpack[1], 0b01000100);\n+      shuffle[0][1] = _mm512_shuffle_i32x4(unpack[2], unpack[3], 0b01000100);\n+      shuffle[0][2] = _mm512_shuffle_i32x4(unpack[4], unpack[5], 0b01000100);\n+      shuffle[0][3] = _mm512_shuffle_i32x4(unpack[6], unpack[7], 0b01000100);\n+      shuffle[0][4] = _mm512_shuffle_i32x4(unpack[0], unpack[1], 0b11101110);\n+      shuffle[0][5] = _mm512_shuffle_i32x4(unpack[2], unpack[3], 0b11101110);\n+      shuffle[0][6] = _mm512_shuffle_i32x4(unpack[4], unpack[5], 0b11101110);\n+      shuffle[0][7] = _mm512_shuffle_i32x4(unpack[6], unpack[7], 0b11101110);\n+\n+      shuffle[1][0] = _mm512_shuffle_i32x4(shuffle[0][0], shuffle[0][1], 0b10001000);\n+      shuffle[1][2] = _mm512_shuffle_i32x4(shuffle[0][0], shuffle[0][1], 0b11011101);\n+      shuffle[1][1] = _mm512_shuffle_i32x4(shuffle[0][2], shuffle[0][3], 0b10001000);\n+      shuffle[1][3] = _mm512_shuffle_i32x4(shuffle[0][2], shuffle[0][3], 0b11011101);\n+      shuffle[1][4] = _mm512_shuffle_i32x4(shuffle[0][4], shuffle[0][5], 0b10001000);\n+      shuffle[1][6] = _mm512_shuffle_i32x4(shuffle[0][4], shuffle[0][5], 0b11011101);\n+      shuffle[1][5] = _mm512_shuffle_i32x4(shuffle[0][6], shuffle[0][7], 0b10001000);\n+      shuffle[1][7] = _mm512_shuffle_i32x4(shuffle[0][6], shuffle[0][7], 0b11011101);\n+    } else {\n+      // path for float, 128i index:\n+      // {0x00, 0x04, 0x08, 0x0C}, {0x01, 0x05, 0x09, 0x0D}\n+      // {0x02, 0x06, 0x0A, 0x0E}, {0x03, 0x07, 0x0B, 0x0F},\n+      shuffle[0][0] = _mm512_shuffle_i32x4(unpack[0], unpack[1], 0b01000100);\n+      shuffle[0][1] = _mm512_shuffle_i32x4(unpack[2], unpack[3], 0b01000100);\n+      shuffle[0][2] = _mm512_shuffle_i32x4(unpack[0], unpack[1], 0b11101110);\n+      shuffle[0][3] = _mm512_shuffle_i32x4(unpack[2], unpack[3], 0b11101110);\n+\n+      shuffle[1][0] = _mm512_shuffle_i32x4(shuffle[0][0], shuffle[0][1], 0b10001000);\n+      shuffle[1][1] = _mm512_shuffle_i32x4(shuffle[0][0], shuffle[0][1], 0b11011101);\n+      shuffle[1][2] = _mm512_shuffle_i32x4(shuffle[0][2], shuffle[0][3], 0b10001000);\n+      shuffle[1][3] = _mm512_shuffle_i32x4(shuffle[0][2], shuffle[0][3], 0b11011101);\n+    }\n+\n+    for (size_t j = 0; j < kNumStreams; ++j) {\n+      _mm512_storeu_si512(reinterpret_cast<__m512i*>(\n+                              &output_data[(i * kNumStreams + j) * sizeof(__m512i)]),\n+                          shuffle[1][j]);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void _ByteStreamSplitEncodeAVX512(const uint8_t* raw_values, const size_t num_values,\n+                                  uint8_t* output_buffer_raw) {\n+  constexpr size_t num_streams = sizeof(T);\n+  static_assert(num_streams == 4U || num_streams == 8U, \"Invalid number of streams.\");\n+  const size_t size = num_values * sizeof(T);\n+  const size_t block_size = sizeof(__m512i) * num_streams;\n+  if (size < block_size)  // Back to AVX2 for small size\n+    return _ByteStreamSplitEncodeAVX2<T>(raw_values, num_values, output_buffer_raw);\n+\n+  const size_t num_blocks = size / block_size;\n+  const __m512i* raw_values_simd = reinterpret_cast<const __m512i*>(raw_values);\n+  __m512i* output_buffer_streams[num_streams];\n+  for (size_t i = 0; i < num_streams; ++i) {\n+    output_buffer_streams[i] =\n+        reinterpret_cast<__m512i*>(&output_buffer_raw[num_values * i]);\n+  }\n+\n+  const size_t num_processed_elements = (num_blocks * block_size) / sizeof(T);\n+  for (size_t i = num_processed_elements; i < num_values; ++i) {\n+    for (size_t j = 0U; j < num_streams; ++j) {\n+      const uint8_t byte_in_value = raw_values[i * num_streams + j];\n+      output_buffer_raw[j * num_values + i] = byte_in_value;\n+    }\n+  }\n+\n+  size_t num_unpack = (num_streams == 8U) ? 2 : 3;\n+  __m512i final_result[num_streams];\n+  __m512i unpack[num_unpack + 1][num_streams];\n+  __m512i permutex[num_streams];\n+  __m512i permutex_mask;\n+  if (num_streams == 8U) {\n+    // use _mm512_set_epi32, no _mm512_set_epi16 for some gcc version.\n+    permutex_mask = _mm512_set_epi32(0x001F0017, 0x000F0007, 0x001E0016, 0x000E0006,\n+                                     0x001D0015, 0x000D0005, 0x001C0014, 0x000C0004,\n+                                     0x001B0013, 0x000B0003, 0x001A0012, 0x000A0002,\n+                                     0x00190011, 0x00090001, 0x00180010, 0x00080000);\n+\n+  } else {\n+    permutex_mask = _mm512_set_epi32(0x0F, 0x0B, 0x07, 0x03, 0x0E, 0x0A, 0x06, 0x02, 0x0D,\n+                                     0x09, 0x05, 0x01, 0x0C, 0x08, 0x04, 0x00);\n+  }\n+\n+  for (size_t block_index = 0; block_index < num_blocks; ++block_index) {\n+    // First copy the data to stage 0.\n+    for (size_t i = 0; i < num_streams; ++i) {\n+      unpack[0][i] = _mm512_loadu_si512(&raw_values_simd[block_index * num_streams + i]);\n+    }\n+\n+    for (size_t unpack_lvl = 0; unpack_lvl < num_unpack; ++unpack_lvl) {\n+      for (size_t i = 0; i < num_streams / 2U; ++i) {\n+        unpack[unpack_lvl + 1][i * 2] = _mm512_unpacklo_epi8(\n+            unpack[unpack_lvl][i * 2], unpack[unpack_lvl][i * 2 + 1]);\n+        unpack[unpack_lvl + 1][i * 2 + 1] = _mm512_unpackhi_epi8(\n+            unpack[unpack_lvl][i * 2], unpack[unpack_lvl][i * 2 + 1]);\n+      }\n+    }\n+\n+    if (num_streams == 8U) {\n+      // path for double\n+      // 1. unpack to epi16 block\n+      // 2. permutexvar_epi16 to 128i block\n+      // 3. shuffle 128i to final 512i target, index:\n+      //   {0x00, 0x04, 0x08, 0x0C}, {0x10, 0x14, 0x18, 0x1C},\n+      //   {0x01, 0x05, 0x09, 0x0D}, {0x11, 0x15, 0x19, 0x1D},\n+      //   {0x02, 0x06, 0x0A, 0x0E}, {0x12, 0x16, 0x1A, 0x1E},\n+      //   {0x03, 0x07, 0x0B, 0x0F}, {0x13, 0x17, 0x1B, 0x1F},\n+      for (size_t i = 0; i < num_streams; ++i)\n+        permutex[i] = _mm512_permutexvar_epi16(permutex_mask, unpack[num_unpack][i]);\n+\n+      __m512i shuffle[num_streams];\n+      shuffle[0] = _mm512_shuffle_i32x4(permutex[0], permutex[2], 0b01000100);\n+      shuffle[1] = _mm512_shuffle_i32x4(permutex[4], permutex[6], 0b01000100);\n+      shuffle[2] = _mm512_shuffle_i32x4(permutex[0], permutex[2], 0b11101110);\n+      shuffle[3] = _mm512_shuffle_i32x4(permutex[4], permutex[6], 0b11101110);\n+      shuffle[4] = _mm512_shuffle_i32x4(permutex[1], permutex[3], 0b01000100);\n+      shuffle[5] = _mm512_shuffle_i32x4(permutex[5], permutex[7], 0b01000100);\n+      shuffle[6] = _mm512_shuffle_i32x4(permutex[1], permutex[3], 0b11101110);\n+      shuffle[7] = _mm512_shuffle_i32x4(permutex[5], permutex[7], 0b11101110);\n+\n+      final_result[0] = _mm512_shuffle_i32x4(shuffle[0], shuffle[1], 0b10001000);\n+      final_result[1] = _mm512_shuffle_i32x4(shuffle[0], shuffle[1], 0b11011101);\n+      final_result[2] = _mm512_shuffle_i32x4(shuffle[2], shuffle[3], 0b10001000);\n+      final_result[3] = _mm512_shuffle_i32x4(shuffle[2], shuffle[3], 0b11011101);\n+      final_result[4] = _mm512_shuffle_i32x4(shuffle[4], shuffle[5], 0b10001000);\n+      final_result[5] = _mm512_shuffle_i32x4(shuffle[4], shuffle[5], 0b11011101);\n+      final_result[6] = _mm512_shuffle_i32x4(shuffle[6], shuffle[7], 0b10001000);\n+      final_result[7] = _mm512_shuffle_i32x4(shuffle[6], shuffle[7], 0b11011101);\n+    } else {\n+      // Path for float.\n+      // 1. Processed hierahically to 32i blcok using the unpack intrinsics.\n+      // 2. Pack 128i block using _mm256_permutevar8x32_epi32.\n+      // 3. Pack final 256i block with _mm256_permute2x128_si256.\n+      for (size_t i = 0; i < num_streams; ++i)\n+        permutex[i] = _mm512_permutexvar_epi32(permutex_mask, unpack[num_unpack][i]);\n+\n+      final_result[0] = _mm512_shuffle_i32x4(permutex[0], permutex[2], 0b01000100);\n+      final_result[1] = _mm512_shuffle_i32x4(permutex[0], permutex[2], 0b11101110);\n+      final_result[2] = _mm512_shuffle_i32x4(permutex[1], permutex[3], 0b01000100);\n+      final_result[3] = _mm512_shuffle_i32x4(permutex[1], permutex[3], 0b11101110);\n+    }\n+\n+    for (size_t i = 0; i < num_streams; ++i) {\n+      _mm512_storeu_si512(&output_buffer_streams[i][block_index], final_result[i]);\n+    }\n+  }\n+}\n+#endif\n+\n+#if defined(ARROW_HAVE_SIMD_SPLIT)\n+template <typename T>\n+void inline ByteStreamSplitDecodeSIMD(const uint8_t* data, int64_t num_values,\n+                                      int64_t stride, T* out) {\n+#if defined(ARROW_HAVE_AVX512)\n+  return _ByteStreamSplitDecodeAVX512(data, num_values, stride, out);\n+#elif defined(ARROW_HAVE_AVX2)\n+  return _ByteStreamSplitDecodeAVX2(data, num_values, stride, out);\n+#elif defined(ARROW_HAVE_SSE4_2)\n+  return _ByteStreamSplitDecodeSSE2(data, num_values, stride, out);\n+#else\n+#error \"ByteStreamSplitDecodeSIMD not defined\"\n+#endif\n+}\n+\n+template <typename T>\n+void inline ByteStreamSplitEncodeSIMD(const uint8_t* raw_values, const size_t num_values,\n \n Review comment:\n   SIMD->Simd\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-11T19:12:06.335+0000",
                    "updated": "2020-04-11T19:12:06.335+0000",
                    "started": "2020-04-11T19:12:06.335+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420806",
                    "issueId": "13297736"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420807",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899#discussion_r407099591\n \n \n\n ##########\n File path: cpp/src/arrow/util/byte_stream_split.h\n ##########\n @@ -171,6 +171,381 @@ void ByteStreamSplitEncodeSSE2(const uint8_t* raw_values, const size_t num_value\n \n #endif\n \n+#if defined(ARROW_HAVE_AVX2)\n+template <typename T>\n+void _ByteStreamSplitDecodeAVX2(const uint8_t* data, int64_t num_values, int64_t stride,\n+                                T* out) {\n+  constexpr size_t kNumStreams = sizeof(T);\n+  constexpr size_t kNumStreamsLog2 = (kNumStreams == 8U ? 3U : 2U);\n+\n+  const int64_t size = num_values * sizeof(T);\n+  const int64_t block_size = sizeof(__m256i) * kNumStreams;\n+  if (size < block_size)  // Back to SSE for small size\n+    return _ByteStreamSplitDecodeSSE2(data, num_values, stride, out);\n+  const int64_t num_blocks = size / block_size;\n+  uint8_t* output_data = reinterpret_cast<uint8_t*>(out);\n+\n+  // First handle suffix.\n+  const int64_t num_processed_elements = (num_blocks * block_size) / kNumStreams;\n+  for (int64_t i = num_processed_elements; i < num_values; ++i) {\n+    uint8_t gathered_byte_data[kNumStreams];\n+    for (size_t b = 0; b < kNumStreams; ++b) {\n+      const size_t byte_index = b * stride + i;\n+      gathered_byte_data[b] = data[byte_index];\n+    }\n+    out[i] = arrow::util::SafeLoadAs<T>(&gathered_byte_data[0]);\n+  }\n+\n+  // Processed hierahically using unpack intrinsics, then permute intrinsics.\n+  __m256i stage[kNumStreamsLog2 + 1U][kNumStreams];\n+  __m256i final_result[kNumStreams];\n+  const size_t half = kNumStreams / 2U;\n+\n+  for (int64_t i = 0; i < num_blocks; ++i) {\n+    for (size_t j = 0; j < kNumStreams; ++j) {\n+      stage[0][j] = _mm256_loadu_si256(\n+          reinterpret_cast<const __m256i*>(&data[i * sizeof(__m256i) + j * stride]));\n+    }\n+\n+    for (size_t step = 0; step < kNumStreamsLog2; ++step) {\n+      for (size_t j = 0; j < half; ++j) {\n+        stage[step + 1U][j * 2] =\n+            _mm256_unpacklo_epi8(stage[step][j], stage[step][half + j]);\n+        stage[step + 1U][j * 2 + 1U] =\n+            _mm256_unpackhi_epi8(stage[step][j], stage[step][half + j]);\n+      }\n+    }\n+\n+    __m256i* unpack = &stage[kNumStreamsLog2][0];\n+    if (kNumStreams == 8U) {\n+      // path for double, 128i index:\n+      //   {0x00, 0x08}, {0x01, 0x09}, {0x02, 0x0A}, {0x03, 0x0B},\n+      //   {0x04, 0x0C}, {0x05, 0x0D}, {0x06, 0x0E}, {0x07, 0x0F},\n+      final_result[0] = _mm256_permute2x128_si256(unpack[0], unpack[1], 0b00100000);\n+      final_result[1] = _mm256_permute2x128_si256(unpack[2], unpack[3], 0b00100000);\n+      final_result[2] = _mm256_permute2x128_si256(unpack[4], unpack[5], 0b00100000);\n+      final_result[3] = _mm256_permute2x128_si256(unpack[6], unpack[7], 0b00100000);\n+      final_result[4] = _mm256_permute2x128_si256(unpack[0], unpack[1], 0b00110001);\n+      final_result[5] = _mm256_permute2x128_si256(unpack[2], unpack[3], 0b00110001);\n+      final_result[6] = _mm256_permute2x128_si256(unpack[4], unpack[5], 0b00110001);\n+      final_result[7] = _mm256_permute2x128_si256(unpack[6], unpack[7], 0b00110001);\n+    } else {\n+      // path for float, 128i index:\n+      //   {0x00, 0x04}, {0x01, 0x05}, {0x02, 0x06}, {0x03, 0x07}\n+      final_result[0] = _mm256_permute2x128_si256(unpack[0], unpack[1], 0b00100000);\n+      final_result[1] = _mm256_permute2x128_si256(unpack[2], unpack[3], 0b00100000);\n+      final_result[2] = _mm256_permute2x128_si256(unpack[0], unpack[1], 0b00110001);\n+      final_result[3] = _mm256_permute2x128_si256(unpack[2], unpack[3], 0b00110001);\n+    }\n+\n+    for (size_t j = 0; j < kNumStreams; ++j) {\n+      _mm256_storeu_si256(reinterpret_cast<__m256i*>(\n+                              &output_data[(i * kNumStreams + j) * sizeof(__m256i)]),\n+                          final_result[j]);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void _ByteStreamSplitEncodeAVX2(const uint8_t* raw_values, const size_t num_values,\n+                                uint8_t* output_buffer_raw) {\n+  constexpr size_t num_streams = sizeof(T);\n+  static_assert(num_streams == 4U || num_streams == 8U, \"Invalid number of streams.\");\n+  if (num_streams == 8U)  // Back to SSE, currently no path for double.\n+    return _ByteStreamSplitEncodeSSE2<T>(raw_values, num_values, output_buffer_raw);\n+\n+  const size_t size = num_values * sizeof(T);\n+  const size_t block_size = sizeof(__m256i) * num_streams;\n+  if (size < block_size)  // Back to SSE for small size\n+    return _ByteStreamSplitEncodeSSE2<T>(raw_values, num_values, output_buffer_raw);\n+  const size_t num_blocks = size / block_size;\n+  const __m256i* raw_values_simd = reinterpret_cast<const __m256i*>(raw_values);\n+  __m256i* output_buffer_streams[num_streams];\n+\n+  for (size_t i = 0; i < num_streams; ++i) {\n+    output_buffer_streams[i] =\n+        reinterpret_cast<__m256i*>(&output_buffer_raw[num_values * i]);\n+  }\n+\n+  const size_t num_processed_elements = (num_blocks * block_size) / sizeof(T);\n+  for (size_t i = num_processed_elements; i < num_values; ++i) {\n+    for (size_t j = 0U; j < num_streams; ++j) {\n+      const uint8_t byte_in_value = raw_values[i * num_streams + j];\n+      output_buffer_raw[j * num_values + i] = byte_in_value;\n+    }\n+  }\n+\n+  // Path for float.\n+  // 1. Processed hierahically to 32i blcok using the unpack intrinsics.\n+  // 2. Pack 128i block using _mm256_permutevar8x32_epi32.\n+  // 3. Pack final 256i block with _mm256_permute2x128_si256.\n+  __m256i stage[4][num_streams];\n+  __m256i permute_mask = _mm256_set_epi32(0x07, 0x03, 0x06, 0x02, 0x05, 0x01, 0x04, 0x00);\n+  __m256i permute[num_streams];\n+  __m256i final_result[num_streams];\n+\n+  for (size_t block_index = 0; block_index < num_blocks; ++block_index) {\n+    // First copy the data to stage 0.\n+    for (size_t i = 0; i < num_streams; ++i) {\n+      stage[0][i] = _mm256_loadu_si256(&raw_values_simd[block_index * num_streams + i]);\n+    }\n+\n+    for (size_t stage_lvl = 0; stage_lvl < 3U; ++stage_lvl) {\n+      for (size_t i = 0; i < num_streams / 2U; ++i) {\n+        stage[stage_lvl + 1][i * 2] =\n+            _mm256_unpacklo_epi8(stage[stage_lvl][i * 2], stage[stage_lvl][i * 2 + 1]);\n+        stage[stage_lvl + 1][i * 2 + 1] =\n+            _mm256_unpackhi_epi8(stage[stage_lvl][i * 2], stage[stage_lvl][i * 2 + 1]);\n+      }\n+    }\n+\n+    for (size_t i = 0; i < num_streams; ++i) {\n+      permute[i] = _mm256_permutevar8x32_epi32(stage[3][i], permute_mask);\n+    }\n+\n+    final_result[0] = _mm256_permute2x128_si256(permute[0], permute[2], 0b00100000);\n+    final_result[1] = _mm256_permute2x128_si256(permute[0], permute[2], 0b00110001);\n+    final_result[2] = _mm256_permute2x128_si256(permute[1], permute[3], 0b00100000);\n+    final_result[3] = _mm256_permute2x128_si256(permute[1], permute[3], 0b00110001);\n+\n+    for (size_t i = 0; i < num_streams; ++i) {\n+      _mm256_storeu_si256(&output_buffer_streams[i][block_index], final_result[i]);\n+    }\n+  }\n+}\n+#endif\n+\n+#if defined(ARROW_HAVE_AVX512)\n+template <typename T>\n+void _ByteStreamSplitDecodeAVX512(const uint8_t* data, int64_t num_values, int64_t stride,\n+                                  T* out) {\n+  constexpr size_t kNumStreams = sizeof(T);\n+  constexpr size_t kNumStreamsLog2 = (kNumStreams == 8U ? 3U : 2U);\n+\n+  const int64_t size = num_values * sizeof(T);\n+  const int64_t block_size = sizeof(__m512i) * kNumStreams;\n+  if (size < block_size)  // Back to AVX2 for small size\n+    return _ByteStreamSplitDecodeAVX2(data, num_values, stride, out);\n+  const int64_t num_blocks = size / block_size;\n+  uint8_t* output_data = reinterpret_cast<uint8_t*>(out);\n+\n+  // First handle suffix.\n+  const int64_t num_processed_elements = (num_blocks * block_size) / kNumStreams;\n+  for (int64_t i = num_processed_elements; i < num_values; ++i) {\n+    uint8_t gathered_byte_data[kNumStreams];\n+    for (size_t b = 0; b < kNumStreams; ++b) {\n+      const size_t byte_index = b * stride + i;\n+      gathered_byte_data[b] = data[byte_index];\n+    }\n+    out[i] = arrow::util::SafeLoadAs<T>(&gathered_byte_data[0]);\n+  }\n+\n+  // Processed hierahically using the unpack, then two shuffles.\n+  __m512i stage[kNumStreamsLog2 + 1U][kNumStreams];\n+  __m512i shuffle[2][kNumStreams];\n+  const size_t half = kNumStreams / 2U;\n+\n+  for (int64_t i = 0; i < num_blocks; ++i) {\n+    for (size_t j = 0; j < kNumStreams; ++j) {\n+      stage[0][j] = _mm512_loadu_si512(\n+          reinterpret_cast<const __m512i*>(&data[i * sizeof(__m512i) + j * stride]));\n+    }\n+\n+    for (size_t step = 0; step < kNumStreamsLog2; ++step) {\n+      for (size_t j = 0; j < half; ++j) {\n+        stage[step + 1U][j * 2] =\n+            _mm512_unpacklo_epi8(stage[step][j], stage[step][half + j]);\n+        stage[step + 1U][j * 2 + 1U] =\n+            _mm512_unpackhi_epi8(stage[step][j], stage[step][half + j]);\n+      }\n+    }\n+\n+    __m512i* unpack = &stage[kNumStreamsLog2][0];\n+    if (kNumStreams == 8U) {\n+      // path for double, 128i index:\n+      // {0x00, 0x04, 0x08, 0x0C}, {0x10, 0x14, 0x18, 0x1C},\n+      // {0x01, 0x05, 0x09, 0x0D}, {0x11, 0x15, 0x19, 0x1D},\n+      // {0x02, 0x06, 0x0A, 0x0E}, {0x12, 0x16, 0x1A, 0x1E},\n+      // {0x03, 0x07, 0x0B, 0x0F}, {0x13, 0x17, 0x1B, 0x1F},\n+      shuffle[0][0] = _mm512_shuffle_i32x4(unpack[0], unpack[1], 0b01000100);\n+      shuffle[0][1] = _mm512_shuffle_i32x4(unpack[2], unpack[3], 0b01000100);\n+      shuffle[0][2] = _mm512_shuffle_i32x4(unpack[4], unpack[5], 0b01000100);\n+      shuffle[0][3] = _mm512_shuffle_i32x4(unpack[6], unpack[7], 0b01000100);\n+      shuffle[0][4] = _mm512_shuffle_i32x4(unpack[0], unpack[1], 0b11101110);\n+      shuffle[0][5] = _mm512_shuffle_i32x4(unpack[2], unpack[3], 0b11101110);\n+      shuffle[0][6] = _mm512_shuffle_i32x4(unpack[4], unpack[5], 0b11101110);\n+      shuffle[0][7] = _mm512_shuffle_i32x4(unpack[6], unpack[7], 0b11101110);\n+\n+      shuffle[1][0] = _mm512_shuffle_i32x4(shuffle[0][0], shuffle[0][1], 0b10001000);\n+      shuffle[1][2] = _mm512_shuffle_i32x4(shuffle[0][0], shuffle[0][1], 0b11011101);\n+      shuffle[1][1] = _mm512_shuffle_i32x4(shuffle[0][2], shuffle[0][3], 0b10001000);\n+      shuffle[1][3] = _mm512_shuffle_i32x4(shuffle[0][2], shuffle[0][3], 0b11011101);\n+      shuffle[1][4] = _mm512_shuffle_i32x4(shuffle[0][4], shuffle[0][5], 0b10001000);\n+      shuffle[1][6] = _mm512_shuffle_i32x4(shuffle[0][4], shuffle[0][5], 0b11011101);\n+      shuffle[1][5] = _mm512_shuffle_i32x4(shuffle[0][6], shuffle[0][7], 0b10001000);\n+      shuffle[1][7] = _mm512_shuffle_i32x4(shuffle[0][6], shuffle[0][7], 0b11011101);\n+    } else {\n+      // path for float, 128i index:\n+      // {0x00, 0x04, 0x08, 0x0C}, {0x01, 0x05, 0x09, 0x0D}\n+      // {0x02, 0x06, 0x0A, 0x0E}, {0x03, 0x07, 0x0B, 0x0F},\n+      shuffle[0][0] = _mm512_shuffle_i32x4(unpack[0], unpack[1], 0b01000100);\n+      shuffle[0][1] = _mm512_shuffle_i32x4(unpack[2], unpack[3], 0b01000100);\n+      shuffle[0][2] = _mm512_shuffle_i32x4(unpack[0], unpack[1], 0b11101110);\n+      shuffle[0][3] = _mm512_shuffle_i32x4(unpack[2], unpack[3], 0b11101110);\n+\n+      shuffle[1][0] = _mm512_shuffle_i32x4(shuffle[0][0], shuffle[0][1], 0b10001000);\n+      shuffle[1][1] = _mm512_shuffle_i32x4(shuffle[0][0], shuffle[0][1], 0b11011101);\n+      shuffle[1][2] = _mm512_shuffle_i32x4(shuffle[0][2], shuffle[0][3], 0b10001000);\n+      shuffle[1][3] = _mm512_shuffle_i32x4(shuffle[0][2], shuffle[0][3], 0b11011101);\n+    }\n+\n+    for (size_t j = 0; j < kNumStreams; ++j) {\n+      _mm512_storeu_si512(reinterpret_cast<__m512i*>(\n+                              &output_data[(i * kNumStreams + j) * sizeof(__m512i)]),\n+                          shuffle[1][j]);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void _ByteStreamSplitEncodeAVX512(const uint8_t* raw_values, const size_t num_values,\n+                                  uint8_t* output_buffer_raw) {\n+  constexpr size_t num_streams = sizeof(T);\n+  static_assert(num_streams == 4U || num_streams == 8U, \"Invalid number of streams.\");\n+  const size_t size = num_values * sizeof(T);\n+  const size_t block_size = sizeof(__m512i) * num_streams;\n+  if (size < block_size)  // Back to AVX2 for small size\n+    return _ByteStreamSplitEncodeAVX2<T>(raw_values, num_values, output_buffer_raw);\n+\n+  const size_t num_blocks = size / block_size;\n+  const __m512i* raw_values_simd = reinterpret_cast<const __m512i*>(raw_values);\n+  __m512i* output_buffer_streams[num_streams];\n+  for (size_t i = 0; i < num_streams; ++i) {\n+    output_buffer_streams[i] =\n+        reinterpret_cast<__m512i*>(&output_buffer_raw[num_values * i]);\n+  }\n+\n+  const size_t num_processed_elements = (num_blocks * block_size) / sizeof(T);\n+  for (size_t i = num_processed_elements; i < num_values; ++i) {\n+    for (size_t j = 0U; j < num_streams; ++j) {\n+      const uint8_t byte_in_value = raw_values[i * num_streams + j];\n+      output_buffer_raw[j * num_values + i] = byte_in_value;\n+    }\n+  }\n+\n+  size_t num_unpack = (num_streams == 8U) ? 2 : 3;\n+  __m512i final_result[num_streams];\n+  __m512i unpack[num_unpack + 1][num_streams];\n+  __m512i permutex[num_streams];\n+  __m512i permutex_mask;\n+  if (num_streams == 8U) {\n+    // use _mm512_set_epi32, no _mm512_set_epi16 for some gcc version.\n+    permutex_mask = _mm512_set_epi32(0x001F0017, 0x000F0007, 0x001E0016, 0x000E0006,\n+                                     0x001D0015, 0x000D0005, 0x001C0014, 0x000C0004,\n+                                     0x001B0013, 0x000B0003, 0x001A0012, 0x000A0002,\n+                                     0x00190011, 0x00090001, 0x00180010, 0x00080000);\n+\n+  } else {\n+    permutex_mask = _mm512_set_epi32(0x0F, 0x0B, 0x07, 0x03, 0x0E, 0x0A, 0x06, 0x02, 0x0D,\n+                                     0x09, 0x05, 0x01, 0x0C, 0x08, 0x04, 0x00);\n+  }\n+\n+  for (size_t block_index = 0; block_index < num_blocks; ++block_index) {\n+    // First copy the data to stage 0.\n+    for (size_t i = 0; i < num_streams; ++i) {\n+      unpack[0][i] = _mm512_loadu_si512(&raw_values_simd[block_index * num_streams + i]);\n+    }\n+\n+    for (size_t unpack_lvl = 0; unpack_lvl < num_unpack; ++unpack_lvl) {\n+      for (size_t i = 0; i < num_streams / 2U; ++i) {\n+        unpack[unpack_lvl + 1][i * 2] = _mm512_unpacklo_epi8(\n+            unpack[unpack_lvl][i * 2], unpack[unpack_lvl][i * 2 + 1]);\n+        unpack[unpack_lvl + 1][i * 2 + 1] = _mm512_unpackhi_epi8(\n+            unpack[unpack_lvl][i * 2], unpack[unpack_lvl][i * 2 + 1]);\n+      }\n+    }\n+\n+    if (num_streams == 8U) {\n+      // path for double\n+      // 1. unpack to epi16 block\n+      // 2. permutexvar_epi16 to 128i block\n+      // 3. shuffle 128i to final 512i target, index:\n+      //   {0x00, 0x04, 0x08, 0x0C}, {0x10, 0x14, 0x18, 0x1C},\n+      //   {0x01, 0x05, 0x09, 0x0D}, {0x11, 0x15, 0x19, 0x1D},\n+      //   {0x02, 0x06, 0x0A, 0x0E}, {0x12, 0x16, 0x1A, 0x1E},\n+      //   {0x03, 0x07, 0x0B, 0x0F}, {0x13, 0x17, 0x1B, 0x1F},\n+      for (size_t i = 0; i < num_streams; ++i)\n+        permutex[i] = _mm512_permutexvar_epi16(permutex_mask, unpack[num_unpack][i]);\n+\n+      __m512i shuffle[num_streams];\n+      shuffle[0] = _mm512_shuffle_i32x4(permutex[0], permutex[2], 0b01000100);\n+      shuffle[1] = _mm512_shuffle_i32x4(permutex[4], permutex[6], 0b01000100);\n+      shuffle[2] = _mm512_shuffle_i32x4(permutex[0], permutex[2], 0b11101110);\n+      shuffle[3] = _mm512_shuffle_i32x4(permutex[4], permutex[6], 0b11101110);\n+      shuffle[4] = _mm512_shuffle_i32x4(permutex[1], permutex[3], 0b01000100);\n+      shuffle[5] = _mm512_shuffle_i32x4(permutex[5], permutex[7], 0b01000100);\n+      shuffle[6] = _mm512_shuffle_i32x4(permutex[1], permutex[3], 0b11101110);\n+      shuffle[7] = _mm512_shuffle_i32x4(permutex[5], permutex[7], 0b11101110);\n+\n+      final_result[0] = _mm512_shuffle_i32x4(shuffle[0], shuffle[1], 0b10001000);\n+      final_result[1] = _mm512_shuffle_i32x4(shuffle[0], shuffle[1], 0b11011101);\n+      final_result[2] = _mm512_shuffle_i32x4(shuffle[2], shuffle[3], 0b10001000);\n+      final_result[3] = _mm512_shuffle_i32x4(shuffle[2], shuffle[3], 0b11011101);\n+      final_result[4] = _mm512_shuffle_i32x4(shuffle[4], shuffle[5], 0b10001000);\n+      final_result[5] = _mm512_shuffle_i32x4(shuffle[4], shuffle[5], 0b11011101);\n+      final_result[6] = _mm512_shuffle_i32x4(shuffle[6], shuffle[7], 0b10001000);\n+      final_result[7] = _mm512_shuffle_i32x4(shuffle[6], shuffle[7], 0b11011101);\n+    } else {\n+      // Path for float.\n+      // 1. Processed hierahically to 32i blcok using the unpack intrinsics.\n+      // 2. Pack 128i block using _mm256_permutevar8x32_epi32.\n+      // 3. Pack final 256i block with _mm256_permute2x128_si256.\n+      for (size_t i = 0; i < num_streams; ++i)\n+        permutex[i] = _mm512_permutexvar_epi32(permutex_mask, unpack[num_unpack][i]);\n+\n+      final_result[0] = _mm512_shuffle_i32x4(permutex[0], permutex[2], 0b01000100);\n+      final_result[1] = _mm512_shuffle_i32x4(permutex[0], permutex[2], 0b11101110);\n+      final_result[2] = _mm512_shuffle_i32x4(permutex[1], permutex[3], 0b01000100);\n+      final_result[3] = _mm512_shuffle_i32x4(permutex[1], permutex[3], 0b11101110);\n+    }\n+\n+    for (size_t i = 0; i < num_streams; ++i) {\n+      _mm512_storeu_si512(&output_buffer_streams[i][block_index], final_result[i]);\n+    }\n+  }\n+}\n+#endif\n+\n+#if defined(ARROW_HAVE_SIMD_SPLIT)\n+template <typename T>\n+void inline ByteStreamSplitDecodeSIMD(const uint8_t* data, int64_t num_values,\n \n Review comment:\n   Style\r\n   ```suggestion\r\n   void inline ByteStreamSplitDecodeSimd(const uint8_t* data, int64_t num_values,\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-11T19:12:06.338+0000",
                    "updated": "2020-04-11T19:12:06.338+0000",
                    "started": "2020-04-11T19:12:06.338+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420807",
                    "issueId": "13297736"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420831",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899#issuecomment-612523104\n \n \n   You also probably know this, but the BYTE_STREAM_SPLIT encoding is brand new to the project and so not too many people will be able to reap the benefits of these optimizations. Wanted to mention anyway\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-11T22:07:39.055+0000",
                    "updated": "2020-04-11T22:07:39.055+0000",
                    "started": "2020-04-11T22:07:39.055+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420831",
                    "issueId": "13297736"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420851",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jianxind commented on pull request #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899#discussion_r407131251\n \n \n\n ##########\n File path: cpp/src/arrow/util/byte_stream_split.h\n ##########\n @@ -171,6 +171,381 @@ void ByteStreamSplitEncodeSSE2(const uint8_t* raw_values, const size_t num_value\n \n #endif\n \n+#if defined(ARROW_HAVE_AVX2)\n+template <typename T>\n+void _ByteStreamSplitDecodeAVX2(const uint8_t* data, int64_t num_values, int64_t stride,\n+                                T* out) {\n+  constexpr size_t kNumStreams = sizeof(T);\n+  constexpr size_t kNumStreamsLog2 = (kNumStreams == 8U ? 3U : 2U);\n+\n+  const int64_t size = num_values * sizeof(T);\n+  const int64_t block_size = sizeof(__m256i) * kNumStreams;\n+  if (size < block_size)  // Back to SSE for small size\n+    return _ByteStreamSplitDecodeSSE2(data, num_values, stride, out);\n+  const int64_t num_blocks = size / block_size;\n+  uint8_t* output_data = reinterpret_cast<uint8_t*>(out);\n+\n+  // First handle suffix.\n+  const int64_t num_processed_elements = (num_blocks * block_size) / kNumStreams;\n+  for (int64_t i = num_processed_elements; i < num_values; ++i) {\n+    uint8_t gathered_byte_data[kNumStreams];\n+    for (size_t b = 0; b < kNumStreams; ++b) {\n+      const size_t byte_index = b * stride + i;\n+      gathered_byte_data[b] = data[byte_index];\n+    }\n+    out[i] = arrow::util::SafeLoadAs<T>(&gathered_byte_data[0]);\n+  }\n+\n+  // Processed hierahically using unpack intrinsics, then permute intrinsics.\n+  __m256i stage[kNumStreamsLog2 + 1U][kNumStreams];\n+  __m256i final_result[kNumStreams];\n+  const size_t half = kNumStreams / 2U;\n+\n+  for (int64_t i = 0; i < num_blocks; ++i) {\n+    for (size_t j = 0; j < kNumStreams; ++j) {\n+      stage[0][j] = _mm256_loadu_si256(\n+          reinterpret_cast<const __m256i*>(&data[i * sizeof(__m256i) + j * stride]));\n+    }\n+\n+    for (size_t step = 0; step < kNumStreamsLog2; ++step) {\n+      for (size_t j = 0; j < half; ++j) {\n+        stage[step + 1U][j * 2] =\n+            _mm256_unpacklo_epi8(stage[step][j], stage[step][half + j]);\n+        stage[step + 1U][j * 2 + 1U] =\n+            _mm256_unpackhi_epi8(stage[step][j], stage[step][half + j]);\n+      }\n+    }\n+\n+    __m256i* unpack = &stage[kNumStreamsLog2][0];\n+    if (kNumStreams == 8U) {\n+      // path for double, 128i index:\n+      //   {0x00, 0x08}, {0x01, 0x09}, {0x02, 0x0A}, {0x03, 0x0B},\n+      //   {0x04, 0x0C}, {0x05, 0x0D}, {0x06, 0x0E}, {0x07, 0x0F},\n+      final_result[0] = _mm256_permute2x128_si256(unpack[0], unpack[1], 0b00100000);\n+      final_result[1] = _mm256_permute2x128_si256(unpack[2], unpack[3], 0b00100000);\n+      final_result[2] = _mm256_permute2x128_si256(unpack[4], unpack[5], 0b00100000);\n+      final_result[3] = _mm256_permute2x128_si256(unpack[6], unpack[7], 0b00100000);\n+      final_result[4] = _mm256_permute2x128_si256(unpack[0], unpack[1], 0b00110001);\n+      final_result[5] = _mm256_permute2x128_si256(unpack[2], unpack[3], 0b00110001);\n+      final_result[6] = _mm256_permute2x128_si256(unpack[4], unpack[5], 0b00110001);\n+      final_result[7] = _mm256_permute2x128_si256(unpack[6], unpack[7], 0b00110001);\n+    } else {\n+      // path for float, 128i index:\n+      //   {0x00, 0x04}, {0x01, 0x05}, {0x02, 0x06}, {0x03, 0x07}\n+      final_result[0] = _mm256_permute2x128_si256(unpack[0], unpack[1], 0b00100000);\n+      final_result[1] = _mm256_permute2x128_si256(unpack[2], unpack[3], 0b00100000);\n+      final_result[2] = _mm256_permute2x128_si256(unpack[0], unpack[1], 0b00110001);\n+      final_result[3] = _mm256_permute2x128_si256(unpack[2], unpack[3], 0b00110001);\n+    }\n+\n+    for (size_t j = 0; j < kNumStreams; ++j) {\n+      _mm256_storeu_si256(reinterpret_cast<__m256i*>(\n+                              &output_data[(i * kNumStreams + j) * sizeof(__m256i)]),\n+                          final_result[j]);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void _ByteStreamSplitEncodeAVX2(const uint8_t* raw_values, const size_t num_values,\n+                                uint8_t* output_buffer_raw) {\n+  constexpr size_t num_streams = sizeof(T);\n \n Review comment:\n   done\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-12T01:28:07.306+0000",
                    "updated": "2020-04-12T01:28:07.306+0000",
                    "started": "2020-04-12T01:28:07.306+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420851",
                    "issueId": "13297736"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420852",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jianxind commented on issue #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899#issuecomment-612548493\n \n \n   > Can you add unit tests that test the different AVX implementation directly, its not clear that there is good unit test coverage at the moment.\r\n   \r\n   More tests added for different block and with suffix, and also fix for other comments. Pls help to review it again. Thanks.\r\n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-12T01:36:09.149+0000",
                    "updated": "2020-04-12T01:36:09.149+0000",
                    "started": "2020-04-12T01:36:09.149+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420852",
                    "issueId": "13297736"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420854",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jianxind commented on issue #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899#issuecomment-612548913\n \n \n   > You also probably know this, but the BYTE_STREAM_SPLIT encoding is brand new to the project and so not too many people will be able to reap the benefits of these optimizations. Wanted to mention anyway\r\n   \r\n   Thanks, actually I don't know as I am very new to arrow:) And it will be very great if you can input us some priority lists of encoding which are more popular to end user, or where I can find the info. We can check the candidates though not each encoding may suitable to SIMD.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-12T01:42:47.723+0000",
                    "updated": "2020-04-12T01:42:47.723+0000",
                    "started": "2020-04-12T01:42:47.722+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420854",
                    "issueId": "13297736"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420861",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899#issuecomment-612549785\n \n \n   Cool, we're happy to have a SIMD expert involved in the project! Maybe we can have a mailing list discussion about the SIMD optimization topic since many people may have ideas about areas where there may be high value. One idea is SIMD-accelerated small size hashes, for values under say 128 bytes I wonder if we can do better than xxhash3\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-12T01:55:25.370+0000",
                    "updated": "2020-04-12T01:55:25.370+0000",
                    "started": "2020-04-12T01:55:25.370+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420861",
                    "issueId": "13297736"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420876",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899#discussion_r407137782\n \n \n\n ##########\n File path: cpp/src/arrow/util/byte_stream_split_simd_internal.h\n ##########\n @@ -0,0 +1,516 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"arrow/util/sse_util.h\"\n+\n+namespace arrow {\n+namespace util {\n+namespace internal {\n+\n+#if defined(ARROW_HAVE_SSE4_2)\n+template <typename T>\n+void ByteStreamSplitDecodeSSE2(const uint8_t* data, int64_t num_values, int64_t stride,\n+                               T* out) {\n+  constexpr size_t kNumStreams = sizeof(T);\n+  static_assert(kNumStreams == 4U || kNumStreams == 8U, \"Invalid number of streams.\");\n+  constexpr size_t kNumStreamsLog2 = (kNumStreams == 8U ? 3U : 2U);\n+\n+  const int64_t size = num_values * sizeof(T);\n+  const int64_t block_size = sizeof(__m128i) * kNumStreams;\n+  const int64_t num_blocks = size / block_size;\n+  uint8_t* output_data = reinterpret_cast<uint8_t*>(out);\n+\n+  // First handle suffix.\n+  // This helps catch if the simd-based processing overflows into the suffix\n+  // since almost surely a test would fail.\n+  const int64_t num_processed_elements = (num_blocks * block_size) / kNumStreams;\n+  for (int64_t i = num_processed_elements; i < num_values; ++i) {\n+    uint8_t gathered_byte_data[kNumStreams];\n+    for (size_t b = 0; b < kNumStreams; ++b) {\n+      const size_t byte_index = b * stride + i;\n+      gathered_byte_data[b] = data[byte_index];\n+    }\n+    out[i] = arrow::util::SafeLoadAs<T>(&gathered_byte_data[0]);\n+  }\n+\n+  // The blocks get processed hierahically using the unpack intrinsics.\n+  // Example with four streams:\n+  // Stage 1: AAAA BBBB CCCC DDDD\n+  // Stage 2: ACAC ACAC BDBD BDBD\n+  // Stage 3: ABCD ABCD ABCD ABCD\n+  __m128i stage[kNumStreamsLog2 + 1U][kNumStreams];\n+  const size_t half = kNumStreams / 2U;\n+\n+  for (int64_t i = 0; i < num_blocks; ++i) {\n+    for (size_t j = 0; j < kNumStreams; ++j) {\n+      stage[0][j] = _mm_loadu_si128(\n+          reinterpret_cast<const __m128i*>(&data[i * sizeof(__m128i) + j * stride]));\n+    }\n+    for (size_t step = 0; step < kNumStreamsLog2; ++step) {\n+      for (size_t j = 0; j < half; ++j) {\n+        stage[step + 1U][j * 2] =\n+            _mm_unpacklo_epi8(stage[step][j], stage[step][half + j]);\n+        stage[step + 1U][j * 2 + 1U] =\n+            _mm_unpackhi_epi8(stage[step][j], stage[step][half + j]);\n+      }\n+    }\n+    for (size_t j = 0; j < kNumStreams; ++j) {\n+      _mm_storeu_si128(reinterpret_cast<__m128i*>(\n+                           &output_data[(i * kNumStreams + j) * sizeof(__m128i)]),\n+                       stage[kNumStreamsLog2][j]);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void ByteStreamSplitEncodeSSE2(const uint8_t* raw_values, const size_t num_values,\n+                               uint8_t* output_buffer_raw) {\n+  constexpr size_t kNumStreams = sizeof(T);\n+  static_assert(kNumStreams == 4U || kNumStreams == 8U, \"Invalid number of streams.\");\n+  __m128i stage[3][kNumStreams];\n+  __m128i final_result[kNumStreams];\n+\n+  const size_t size = num_values * sizeof(T);\n+  const size_t block_size = sizeof(__m128i) * kNumStreams;\n+  const size_t num_blocks = size / block_size;\n+  const __m128i* raw_values_sse = reinterpret_cast<const __m128i*>(raw_values);\n+  __m128i* output_buffer_streams[kNumStreams];\n+  for (size_t i = 0; i < kNumStreams; ++i) {\n+    output_buffer_streams[i] =\n+        reinterpret_cast<__m128i*>(&output_buffer_raw[num_values * i]);\n+  }\n+\n+  // First handle suffix.\n+  const size_t num_processed_elements = (num_blocks * block_size) / sizeof(T);\n+  for (size_t i = num_processed_elements; i < num_values; ++i) {\n+    for (size_t j = 0U; j < kNumStreams; ++j) {\n+      const uint8_t byte_in_value = raw_values[i * kNumStreams + j];\n+      output_buffer_raw[j * num_values + i] = byte_in_value;\n+    }\n+  }\n+  // The current shuffling algorithm diverges for float and double types but the compiler\n+  // should be able to remove the branch since only one path is taken for each template\n+  // instantiation.\n+  // Example run for floats:\n+  // Step 0, copy:\n+  //   0: ABCD ABCD ABCD ABCD 1: ABCD ABCD ABCD ABCD ...\n+  // Step 1: _mm_unpacklo_epi8 and mm_unpackhi_epi8:\n+  //   0: AABB CCDD AABB CCDD 1: AABB CCDD AABB CCDD ...\n+  //   0: AAAA BBBB CCCC DDDD 1: AAAA BBBB CCCC DDDD ...\n+  // Step 3: __mm_unpacklo_epi8 and _mm_unpackhi_epi8:\n+  //   0: AAAA AAAA BBBB BBBB 1: CCCC CCCC DDDD DDDD ...\n+  // Step 4: __mm_unpacklo_epi64 and _mm_unpackhi_epi64:\n+  //   0: AAAA AAAA AAAA AAAA 1: BBBB BBBB BBBB BBBB ...\n+  for (size_t block_index = 0; block_index < num_blocks; ++block_index) {\n+    // First copy the data to stage 0.\n+    for (size_t i = 0; i < kNumStreams; ++i) {\n+      stage[0][i] = _mm_loadu_si128(&raw_values_sse[block_index * kNumStreams + i]);\n+    }\n+\n+    // The shuffling of bytes is performed through the unpack intrinsics.\n+    // In my measurements this gives better performance then an implementation\n+    // which uses the shuffle intrinsics.\n+    for (size_t stage_lvl = 0; stage_lvl < 2U; ++stage_lvl) {\n+      for (size_t i = 0; i < kNumStreams / 2U; ++i) {\n+        stage[stage_lvl + 1][i * 2] =\n+            _mm_unpacklo_epi8(stage[stage_lvl][i * 2], stage[stage_lvl][i * 2 + 1]);\n+        stage[stage_lvl + 1][i * 2 + 1] =\n+            _mm_unpackhi_epi8(stage[stage_lvl][i * 2], stage[stage_lvl][i * 2 + 1]);\n+      }\n+    }\n+    if (kNumStreams == 8U) {\n+      // This is the path for double.\n+      __m128i tmp[8];\n+      for (size_t i = 0; i < 4; ++i) {\n+        tmp[i * 2] = _mm_unpacklo_epi32(stage[2][i], stage[2][i + 4]);\n+        tmp[i * 2 + 1] = _mm_unpackhi_epi32(stage[2][i], stage[2][i + 4]);\n+      }\n+\n+      for (size_t i = 0; i < 4; ++i) {\n+        final_result[i * 2] = _mm_unpacklo_epi32(tmp[i], tmp[i + 4]);\n+        final_result[i * 2 + 1] = _mm_unpackhi_epi32(tmp[i], tmp[i + 4]);\n+      }\n+    } else {\n+      // this is the path for float.\n+      __m128i tmp[4];\n+      for (size_t i = 0; i < 2; ++i) {\n+        tmp[i * 2] = _mm_unpacklo_epi8(stage[2][i * 2], stage[2][i * 2 + 1]);\n+        tmp[i * 2 + 1] = _mm_unpackhi_epi8(stage[2][i * 2], stage[2][i * 2 + 1]);\n+      }\n+      for (size_t i = 0; i < 2; ++i) {\n+        final_result[i * 2] = _mm_unpacklo_epi64(tmp[i], tmp[i + 2]);\n+        final_result[i * 2 + 1] = _mm_unpackhi_epi64(tmp[i], tmp[i + 2]);\n+      }\n+    }\n+    for (size_t i = 0; i < kNumStreams; ++i) {\n+      _mm_storeu_si128(&output_buffer_streams[i][block_index], final_result[i]);\n+    }\n+  }\n+}\n+\n+#endif\n+\n+#if defined(ARROW_HAVE_AVX2)\n+template <typename T>\n+void ByteStreamSplitDecodeAVX2(const uint8_t* data, int64_t num_values, int64_t stride,\n+                               T* out) {\n+  constexpr size_t kNumStreams = sizeof(T);\n+  constexpr size_t kNumStreamsLog2 = (kNumStreams == 8U ? 3U : 2U);\n+\n+  const int64_t size = num_values * sizeof(T);\n+  const int64_t block_size = sizeof(__m256i) * kNumStreams;\n \n Review comment:\n   nit: constexpr kBlockSize\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-12T03:09:19.499+0000",
                    "updated": "2020-04-12T03:09:19.499+0000",
                    "started": "2020-04-12T03:09:19.498+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420876",
                    "issueId": "13297736"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420877",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899#discussion_r407137652\n \n \n\n ##########\n File path: cpp/src/arrow/util/byte_stream_split_simd_internal.h\n ##########\n @@ -0,0 +1,516 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"arrow/util/sse_util.h\"\n+\n+namespace arrow {\n+namespace util {\n+namespace internal {\n+\n+#if defined(ARROW_HAVE_SSE4_2)\n+template <typename T>\n+void ByteStreamSplitDecodeSSE2(const uint8_t* data, int64_t num_values, int64_t stride,\n+                               T* out) {\n+  constexpr size_t kNumStreams = sizeof(T);\n+  static_assert(kNumStreams == 4U || kNumStreams == 8U, \"Invalid number of streams.\");\n+  constexpr size_t kNumStreamsLog2 = (kNumStreams == 8U ? 3U : 2U);\n+\n+  const int64_t size = num_values * sizeof(T);\n+  const int64_t block_size = sizeof(__m128i) * kNumStreams;\n \n Review comment:\n   constexpr?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-12T03:09:19.512+0000",
                    "updated": "2020-04-12T03:09:19.512+0000",
                    "started": "2020-04-12T03:09:19.512+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420877",
                    "issueId": "13297736"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420878",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899#discussion_r407137701\n \n \n\n ##########\n File path: cpp/src/arrow/util/byte_stream_split_simd_internal.h\n ##########\n @@ -0,0 +1,516 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"arrow/util/sse_util.h\"\n+\n+namespace arrow {\n+namespace util {\n+namespace internal {\n+\n+#if defined(ARROW_HAVE_SSE4_2)\n+template <typename T>\n+void ByteStreamSplitDecodeSSE2(const uint8_t* data, int64_t num_values, int64_t stride,\n+                               T* out) {\n+  constexpr size_t kNumStreams = sizeof(T);\n+  static_assert(kNumStreams == 4U || kNumStreams == 8U, \"Invalid number of streams.\");\n+  constexpr size_t kNumStreamsLog2 = (kNumStreams == 8U ? 3U : 2U);\n+\n+  const int64_t size = num_values * sizeof(T);\n+  const int64_t block_size = sizeof(__m128i) * kNumStreams;\n+  const int64_t num_blocks = size / block_size;\n+  uint8_t* output_data = reinterpret_cast<uint8_t*>(out);\n+\n+  // First handle suffix.\n+  // This helps catch if the simd-based processing overflows into the suffix\n+  // since almost surely a test would fail.\n+  const int64_t num_processed_elements = (num_blocks * block_size) / kNumStreams;\n+  for (int64_t i = num_processed_elements; i < num_values; ++i) {\n+    uint8_t gathered_byte_data[kNumStreams];\n+    for (size_t b = 0; b < kNumStreams; ++b) {\n+      const size_t byte_index = b * stride + i;\n+      gathered_byte_data[b] = data[byte_index];\n+    }\n+    out[i] = arrow::util::SafeLoadAs<T>(&gathered_byte_data[0]);\n+  }\n+\n+  // The blocks get processed hierahically using the unpack intrinsics.\n+  // Example with four streams:\n+  // Stage 1: AAAA BBBB CCCC DDDD\n+  // Stage 2: ACAC ACAC BDBD BDBD\n+  // Stage 3: ABCD ABCD ABCD ABCD\n+  __m128i stage[kNumStreamsLog2 + 1U][kNumStreams];\n+  const size_t half = kNumStreams / 2U;\n+\n+  for (int64_t i = 0; i < num_blocks; ++i) {\n+    for (size_t j = 0; j < kNumStreams; ++j) {\n+      stage[0][j] = _mm_loadu_si128(\n+          reinterpret_cast<const __m128i*>(&data[i * sizeof(__m128i) + j * stride]));\n+    }\n+    for (size_t step = 0; step < kNumStreamsLog2; ++step) {\n+      for (size_t j = 0; j < half; ++j) {\n+        stage[step + 1U][j * 2] =\n+            _mm_unpacklo_epi8(stage[step][j], stage[step][half + j]);\n+        stage[step + 1U][j * 2 + 1U] =\n+            _mm_unpackhi_epi8(stage[step][j], stage[step][half + j]);\n+      }\n+    }\n+    for (size_t j = 0; j < kNumStreams; ++j) {\n+      _mm_storeu_si128(reinterpret_cast<__m128i*>(\n+                           &output_data[(i * kNumStreams + j) * sizeof(__m128i)]),\n+                       stage[kNumStreamsLog2][j]);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void ByteStreamSplitEncodeSSE2(const uint8_t* raw_values, const size_t num_values,\n \n Review comment:\n   nit: Sse2\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-12T03:09:19.515+0000",
                    "updated": "2020-04-12T03:09:19.515+0000",
                    "started": "2020-04-12T03:09:19.515+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420878",
                    "issueId": "13297736"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/worklog/420879",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #6899: ARROW-8401: [C++] add split avx2/avx512 intrinsics\nURL: https://github.com/apache/arrow/pull/6899#discussion_r407137746\n \n \n\n ##########\n File path: cpp/src/arrow/util/byte_stream_split_simd_internal.h\n ##########\n @@ -0,0 +1,516 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"arrow/util/sse_util.h\"\n+\n+namespace arrow {\n+namespace util {\n+namespace internal {\n+\n+#if defined(ARROW_HAVE_SSE4_2)\n+template <typename T>\n+void ByteStreamSplitDecodeSSE2(const uint8_t* data, int64_t num_values, int64_t stride,\n+                               T* out) {\n+  constexpr size_t kNumStreams = sizeof(T);\n+  static_assert(kNumStreams == 4U || kNumStreams == 8U, \"Invalid number of streams.\");\n+  constexpr size_t kNumStreamsLog2 = (kNumStreams == 8U ? 3U : 2U);\n+\n+  const int64_t size = num_values * sizeof(T);\n+  const int64_t block_size = sizeof(__m128i) * kNumStreams;\n+  const int64_t num_blocks = size / block_size;\n+  uint8_t* output_data = reinterpret_cast<uint8_t*>(out);\n+\n+  // First handle suffix.\n+  // This helps catch if the simd-based processing overflows into the suffix\n+  // since almost surely a test would fail.\n+  const int64_t num_processed_elements = (num_blocks * block_size) / kNumStreams;\n+  for (int64_t i = num_processed_elements; i < num_values; ++i) {\n+    uint8_t gathered_byte_data[kNumStreams];\n+    for (size_t b = 0; b < kNumStreams; ++b) {\n+      const size_t byte_index = b * stride + i;\n+      gathered_byte_data[b] = data[byte_index];\n+    }\n+    out[i] = arrow::util::SafeLoadAs<T>(&gathered_byte_data[0]);\n+  }\n+\n+  // The blocks get processed hierahically using the unpack intrinsics.\n+  // Example with four streams:\n+  // Stage 1: AAAA BBBB CCCC DDDD\n+  // Stage 2: ACAC ACAC BDBD BDBD\n+  // Stage 3: ABCD ABCD ABCD ABCD\n+  __m128i stage[kNumStreamsLog2 + 1U][kNumStreams];\n+  const size_t half = kNumStreams / 2U;\n+\n+  for (int64_t i = 0; i < num_blocks; ++i) {\n+    for (size_t j = 0; j < kNumStreams; ++j) {\n+      stage[0][j] = _mm_loadu_si128(\n+          reinterpret_cast<const __m128i*>(&data[i * sizeof(__m128i) + j * stride]));\n+    }\n+    for (size_t step = 0; step < kNumStreamsLog2; ++step) {\n+      for (size_t j = 0; j < half; ++j) {\n+        stage[step + 1U][j * 2] =\n+            _mm_unpacklo_epi8(stage[step][j], stage[step][half + j]);\n+        stage[step + 1U][j * 2 + 1U] =\n+            _mm_unpackhi_epi8(stage[step][j], stage[step][half + j]);\n+      }\n+    }\n+    for (size_t j = 0; j < kNumStreams; ++j) {\n+      _mm_storeu_si128(reinterpret_cast<__m128i*>(\n+                           &output_data[(i * kNumStreams + j) * sizeof(__m128i)]),\n+                       stage[kNumStreamsLog2][j]);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void ByteStreamSplitEncodeSSE2(const uint8_t* raw_values, const size_t num_values,\n+                               uint8_t* output_buffer_raw) {\n+  constexpr size_t kNumStreams = sizeof(T);\n+  static_assert(kNumStreams == 4U || kNumStreams == 8U, \"Invalid number of streams.\");\n+  __m128i stage[3][kNumStreams];\n+  __m128i final_result[kNumStreams];\n+\n+  const size_t size = num_values * sizeof(T);\n+  const size_t block_size = sizeof(__m128i) * kNumStreams;\n+  const size_t num_blocks = size / block_size;\n+  const __m128i* raw_values_sse = reinterpret_cast<const __m128i*>(raw_values);\n+  __m128i* output_buffer_streams[kNumStreams];\n+  for (size_t i = 0; i < kNumStreams; ++i) {\n+    output_buffer_streams[i] =\n+        reinterpret_cast<__m128i*>(&output_buffer_raw[num_values * i]);\n+  }\n+\n+  // First handle suffix.\n+  const size_t num_processed_elements = (num_blocks * block_size) / sizeof(T);\n+  for (size_t i = num_processed_elements; i < num_values; ++i) {\n+    for (size_t j = 0U; j < kNumStreams; ++j) {\n+      const uint8_t byte_in_value = raw_values[i * kNumStreams + j];\n+      output_buffer_raw[j * num_values + i] = byte_in_value;\n+    }\n+  }\n+  // The current shuffling algorithm diverges for float and double types but the compiler\n+  // should be able to remove the branch since only one path is taken for each template\n+  // instantiation.\n+  // Example run for floats:\n+  // Step 0, copy:\n+  //   0: ABCD ABCD ABCD ABCD 1: ABCD ABCD ABCD ABCD ...\n+  // Step 1: _mm_unpacklo_epi8 and mm_unpackhi_epi8:\n+  //   0: AABB CCDD AABB CCDD 1: AABB CCDD AABB CCDD ...\n+  //   0: AAAA BBBB CCCC DDDD 1: AAAA BBBB CCCC DDDD ...\n+  // Step 3: __mm_unpacklo_epi8 and _mm_unpackhi_epi8:\n+  //   0: AAAA AAAA BBBB BBBB 1: CCCC CCCC DDDD DDDD ...\n+  // Step 4: __mm_unpacklo_epi64 and _mm_unpackhi_epi64:\n+  //   0: AAAA AAAA AAAA AAAA 1: BBBB BBBB BBBB BBBB ...\n+  for (size_t block_index = 0; block_index < num_blocks; ++block_index) {\n+    // First copy the data to stage 0.\n+    for (size_t i = 0; i < kNumStreams; ++i) {\n+      stage[0][i] = _mm_loadu_si128(&raw_values_sse[block_index * kNumStreams + i]);\n+    }\n+\n+    // The shuffling of bytes is performed through the unpack intrinsics.\n+    // In my measurements this gives better performance then an implementation\n+    // which uses the shuffle intrinsics.\n+    for (size_t stage_lvl = 0; stage_lvl < 2U; ++stage_lvl) {\n+      for (size_t i = 0; i < kNumStreams / 2U; ++i) {\n+        stage[stage_lvl + 1][i * 2] =\n+            _mm_unpacklo_epi8(stage[stage_lvl][i * 2], stage[stage_lvl][i * 2 + 1]);\n+        stage[stage_lvl + 1][i * 2 + 1] =\n+            _mm_unpackhi_epi8(stage[stage_lvl][i * 2], stage[stage_lvl][i * 2 + 1]);\n+      }\n+    }\n+    if (kNumStreams == 8U) {\n+      // This is the path for double.\n+      __m128i tmp[8];\n+      for (size_t i = 0; i < 4; ++i) {\n+        tmp[i * 2] = _mm_unpacklo_epi32(stage[2][i], stage[2][i + 4]);\n+        tmp[i * 2 + 1] = _mm_unpackhi_epi32(stage[2][i], stage[2][i + 4]);\n+      }\n+\n+      for (size_t i = 0; i < 4; ++i) {\n+        final_result[i * 2] = _mm_unpacklo_epi32(tmp[i], tmp[i + 4]);\n+        final_result[i * 2 + 1] = _mm_unpackhi_epi32(tmp[i], tmp[i + 4]);\n+      }\n+    } else {\n+      // this is the path for float.\n+      __m128i tmp[4];\n+      for (size_t i = 0; i < 2; ++i) {\n+        tmp[i * 2] = _mm_unpacklo_epi8(stage[2][i * 2], stage[2][i * 2 + 1]);\n+        tmp[i * 2 + 1] = _mm_unpackhi_epi8(stage[2][i * 2], stage[2][i * 2 + 1]);\n+      }\n+      for (size_t i = 0; i < 2; ++i) {\n+        final_result[i * 2] = _mm_unpacklo_epi64(tmp[i], tmp[i + 2]);\n+        final_result[i * 2 + 1] = _mm_unpackhi_epi64(tmp[i], tmp[i + 2]);\n+      }\n+    }\n+    for (size_t i = 0; i < kNumStreams; ++i) {\n+      _mm_storeu_si128(&output_buffer_streams[i][block_index], final_result[i]);\n+    }\n+  }\n+}\n+\n+#endif\n+\n+#if defined(ARROW_HAVE_AVX2)\n+template <typename T>\n+void ByteStreamSplitDecodeAVX2(const uint8_t* data, int64_t num_values, int64_t stride,\n \n Review comment:\n   nit: Avx2\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-12T03:09:19.549+0000",
                    "updated": "2020-04-12T03:09:19.549+0000",
                    "started": "2020-04-12T03:09:19.549+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "420879",
                    "issueId": "13297736"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 26400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@3d3025ab[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5bcd7012[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@71f81fa9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@4185bc64[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6bfd9482[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@6d14a06f[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5ca0ef33[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@30aa1e5f[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3774c54c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@7f2b1c15[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@24a9adb4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@44910798[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 26400,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Apr 14 15:07:57 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-04-14T17:28:39.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-8401/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-04-11T05:27:11.000+0000",
        "updated": "2020-04-16T13:56:47.000+0000",
        "timeoriginalestimate": null,
        "description": "Add AVX2/AVX512 version of ByteStreamSplitDecode/ByteStreamSplitEncode, it should similar to the SSE implementation.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "7h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 26400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Add AVX2/AVX512 version of ByteStreamSplitDecode/ByteStreamSplitEncode",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13297736/comment/17083323",
                    "id": "17083323",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 6899\n[https://github.com/apache/arrow/pull/6899]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2020-04-14T15:07:57.300+0000",
                    "updated": "2020-04-14T15:07:57.300+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0ditk:",
        "customfield_12314139": null
    }
}