{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13311354",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354",
    "key": "ARROW-9128",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12591216",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12591216",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13042654",
                    "key": "ARROW-555",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13042654",
                    "fields": {
                        "summary": "[C++] String algorithm library for StringArray/BinaryArray",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12605896",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12605896",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13339954",
                    "key": "ARROW-10556",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339954",
                    "fields": {
                        "summary": "[C++] Caching pre computed data based on FunctionOptions in the kernel state",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12605133",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12605133",
                "type": {
                    "id": "12310040",
                    "name": "Required",
                    "inward": "is required by",
                    "outward": "requires",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310040"
                },
                "inwardIssue": {
                    "id": "13339965",
                    "key": "ARROW-10557",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339965",
                    "fields": {
                        "summary": "[C++] Add scalar string slicing/substring extract kernel ",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=maartenbreddels",
            "name": "maartenbreddels",
            "key": "maartenbreddels",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Maarten Breddels",
            "active": true,
            "timeZone": "Europe/Amsterdam"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 16200,
            "total": 16200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 16200,
            "total": 16200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9128/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 27,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/509680",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels opened a new pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621\n\n\n   There is one obvious loose end in this PR, which is where to generate the `std::set` based on the `TrimOptions` (now in the ctor of UTF8TrimBase). I'm not sure what the lifetime guarantees are for this object (TrimOptions), where it makes sense to initialize this set, and when an (utf8 decoding) error occurs, how/where to report this.\r\n   \r\n   Although this is not a costly operation, assuming people don't pass in a billion characters to trim, I do wonder what the best approach here is in general. It does not make much sense to create the `std::set` at each `Exec` call, but that is what happens now. (This also seems to happen in `TransformMatchSubstring` for creating the `prefix_table` btw.)\r\n   \r\n   Maybe a good place to put per-kernel pre-compute results are the `*Options` objects, but I'm not sure if that makes sense in the current architecture.\r\n   \r\n   Another idea is to explore alternatives to the `std::set`. It seem that (based on the TrimManyAscii benchmark), `std::unordered_set` seemed a bit slower, and simply using a linear search: `std::find(options.characters.begin(), options.characters.end(), c) != options.characters.end()` in the predicate instead of the set doesn't seem to affect performance that much.\r\n   \r\n   In CPython, a bloom filter is used, I could explore to see if that makes sense, but the implementation in Arrow lives under the parquet namespace.\r\n   \r\n   \r\n   \r\n   \r\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-10T13:14:46.049+0000",
                    "updated": "2020-11-10T13:14:46.049+0000",
                    "started": "2020-11-10T13:14:46.049+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "509680",
                    "issueId": "13311354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/509685",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621#issuecomment-724695171\n\n\n   https://issues.apache.org/jira/browse/ARROW-9128\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-10T13:17:13.189+0000",
                    "updated": "2020-11-10T13:17:13.189+0000",
                    "started": "2020-11-10T13:17:13.189+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "509685",
                    "issueId": "13311354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/509778",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621#discussion_r520675172\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -1231,6 +1252,302 @@ Result<ValueDescr> StrptimeResolve(KernelContext* ctx, const std::vector<ValueDe\n   return Status::Invalid(\"strptime does not provide default StrptimeOptions\");\n }\n \n+#ifdef ARROW_WITH_UTF8PROC\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimWhitespaceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+    const uint8_t* begin_trimmed = begin;\n+\n+    auto predicate = [](uint32_t c) { return !IsSpaceCharacterUnicode(c); };\n+    if (left && !ARROW_PREDICT_TRUE(\n+                    arrow::util::UTF8FindIf(begin, end, predicate, &begin_trimmed))) {\n+      return false;\n+    }\n+    if (right && (begin_trimmed < end)) {\n+      if (!ARROW_PREDICT_TRUE(arrow::util::UTF8FindIfReverse(begin_trimmed, end,\n+                                                             predicate, &end_trimmed))) {\n+        return false;\n+      }\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+template <typename Type>\n+struct UTF8TrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, true, UTF8TrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8LTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, false, UTF8LTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8RTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, false, true, UTF8RTrimWhitespace<Type>> {};\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<TrimOptions>;\n+  TrimOptions options;\n+  std::set<uint32_t> codepoints;\n\nReview comment:\n       `std::set` doesn't sound like a terrific data structure for this. I would expect `std::vector<bool>` (which is [specified](https://en.cppreference.com/w/cpp/container/vector_bool) as optimizing memory footprint) to give better perf, though benchmarks are required to confirm this.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-10T15:58:51.029+0000",
                    "updated": "2020-11-10T15:58:51.029+0000",
                    "started": "2020-11-10T15:58:51.029+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "509778",
                    "issueId": "13311354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/509780",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621#issuecomment-724796243\n\n\n   > Maybe a good place to put per-kernel pre-compute results are the *Options objects, but I'm not sure if that makes sense in the current architecture.\r\n   \r\n   I don't think the `Options` objects are the right place. Ideally the kernel state would be options-specific, otherwise we can devise a generic caching facility.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-10T16:00:16.342+0000",
                    "updated": "2020-11-10T16:00:16.342+0000",
                    "started": "2020-11-10T16:00:16.341+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "509780",
                    "issueId": "13311354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/509785",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621#issuecomment-724797289\n\n\n   Feel free to open a JIRA about that, by the way :-)\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-10T16:02:03.948+0000",
                    "updated": "2020-11-10T16:02:03.948+0000",
                    "started": "2020-11-10T16:02:03.948+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "509785",
                    "issueId": "13311354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/509886",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on a change in pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621#discussion_r520802117\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -1231,6 +1252,302 @@ Result<ValueDescr> StrptimeResolve(KernelContext* ctx, const std::vector<ValueDe\n   return Status::Invalid(\"strptime does not provide default StrptimeOptions\");\n }\n \n+#ifdef ARROW_WITH_UTF8PROC\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimWhitespaceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+    const uint8_t* begin_trimmed = begin;\n+\n+    auto predicate = [](uint32_t c) { return !IsSpaceCharacterUnicode(c); };\n+    if (left && !ARROW_PREDICT_TRUE(\n+                    arrow::util::UTF8FindIf(begin, end, predicate, &begin_trimmed))) {\n+      return false;\n+    }\n+    if (right && (begin_trimmed < end)) {\n+      if (!ARROW_PREDICT_TRUE(arrow::util::UTF8FindIfReverse(begin_trimmed, end,\n+                                                             predicate, &end_trimmed))) {\n+        return false;\n+      }\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+template <typename Type>\n+struct UTF8TrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, true, UTF8TrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8LTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, false, UTF8LTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8RTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, false, true, UTF8RTrimWhitespace<Type>> {};\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<TrimOptions>;\n+  TrimOptions options;\n+  std::set<uint32_t> codepoints;\n\nReview comment:\n       We need to test if a codepoint is present in a 'set' of codepoints (specified by options.characters), I don't see how an `std::vector<bool>` is useful here, maybe I'm not seeing it.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-10T18:59:23.787+0000",
                    "updated": "2020-11-10T18:59:23.787+0000",
                    "started": "2020-11-10T18:59:23.787+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "509886",
                    "issueId": "13311354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/509888",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621#discussion_r520803595\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -1231,6 +1252,302 @@ Result<ValueDescr> StrptimeResolve(KernelContext* ctx, const std::vector<ValueDe\n   return Status::Invalid(\"strptime does not provide default StrptimeOptions\");\n }\n \n+#ifdef ARROW_WITH_UTF8PROC\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimWhitespaceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+    const uint8_t* begin_trimmed = begin;\n+\n+    auto predicate = [](uint32_t c) { return !IsSpaceCharacterUnicode(c); };\n+    if (left && !ARROW_PREDICT_TRUE(\n+                    arrow::util::UTF8FindIf(begin, end, predicate, &begin_trimmed))) {\n+      return false;\n+    }\n+    if (right && (begin_trimmed < end)) {\n+      if (!ARROW_PREDICT_TRUE(arrow::util::UTF8FindIfReverse(begin_trimmed, end,\n+                                                             predicate, &end_trimmed))) {\n+        return false;\n+      }\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+template <typename Type>\n+struct UTF8TrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, true, UTF8TrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8LTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, false, UTF8LTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8RTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, false, true, UTF8RTrimWhitespace<Type>> {};\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<TrimOptions>;\n+  TrimOptions options;\n+  std::set<uint32_t> codepoints;\n\nReview comment:\n       Just index the `vector<bool>` by codepoint and make `true` mean containment.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-10T19:01:01.183+0000",
                    "updated": "2020-11-10T19:01:01.183+0000",
                    "started": "2020-11-10T19:01:01.182+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "509888",
                    "issueId": "13311354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/510175",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621#issuecomment-725345905\n\n\n   The `std::vector<bool>` was a good idea, and indeed because of it's bit usage, the memory usage for Unicode isn't that heavy (most extreme: `0x10FFFF bits = 140kb` in case of a contiguous array implementation).\r\n   \r\n   Benchmarks:\r\n   ```\r\n   set:\r\n   TrimManyAscii_median   28346892 ns   28345125 ns         25   558.956MB/s   35.2794M items/s\r\n   TrimManyUtf8_median    28302644 ns   28294883 ns         25   559.949MB/s   35.3421M items/s\r\n   \r\n   unordered_set:\r\n   TrimManyAscii_median   32017530 ns   32014024 ns         22   494.898MB/s   31.2363M items/s\r\n   TrimManyUtf8_median (not run)\r\n   \r\n   vector<bool>\r\n   TrimManyAscii_median   14911543 ns   14910620 ns         47   1062.58MB/s   67.0663M items/s\r\n   TrimManyUtf8_median    16148001 ns   16146053 ns         44   981.273MB/s   61.9346M items/s\r\n   \r\n   bitset<256>\r\n   TrimManyAscii_median   14304925 ns   14304010 ns         49   1107.64MB/s   69.9105M items/s\r\n   ```\r\n   \r\n   \r\n   `vector<bool>` is good enough I think, the bitset is consistently faster (5%), but I'd rather have similar code for both solutions.\r\n   \r\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T10:37:29.800+0000",
                    "updated": "2020-11-11T10:37:29.800+0000",
                    "started": "2020-11-11T10:37:29.800+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510175",
                    "issueId": "13311354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/510197",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621#discussion_r521311397\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -1231,6 +1251,305 @@ Result<ValueDescr> StrptimeResolve(KernelContext* ctx, const std::vector<ValueDe\n   return Status::Invalid(\"strptime does not provide default StrptimeOptions\");\n }\n \n+#ifdef ARROW_WITH_UTF8PROC\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimWhitespaceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+    const uint8_t* begin_trimmed = begin;\n+\n+    auto predicate = [](uint32_t c) { return !IsSpaceCharacterUnicode(c); };\n+    if (left && !ARROW_PREDICT_TRUE(\n+                    arrow::util::UTF8FindIf(begin, end, predicate, &begin_trimmed))) {\n+      return false;\n+    }\n+    if (right && (begin_trimmed < end)) {\n+      if (!ARROW_PREDICT_TRUE(arrow::util::UTF8FindIfReverse(begin_trimmed, end,\n+                                                             predicate, &end_trimmed))) {\n+        return false;\n+      }\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+template <typename Type>\n+struct UTF8TrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, true, UTF8TrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8LTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, false, UTF8LTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8RTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, false, true, UTF8RTrimWhitespace<Type>> {};\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<TrimOptions>;\n+  TrimOptions options;\n+  std::vector<bool> codepoints;\n+\n+  explicit UTF8TrimBase(TrimOptions options) : options(options) {\n+    // TODO: check return / can we raise an exception here?\n+    arrow::util::UTF8ForEach(options.characters, [&](uint32_t c) {\n+      codepoints.resize(std::max(c + 1, static_cast<uint32_t>(codepoints.size())));\n+      codepoints.at(c) = true;\n+    });\n+  }\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    TrimOptions options = State::Get(ctx);\n+    Derived(options).Execute(ctx, batch, out);\n+  }\n+\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();\n+    Base::Execute(ctx, batch, out);\n+  }\n+\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+    const uint8_t* begin_trimmed = begin;\n+\n+    auto predicate = [&](uint32_t c) {\n+      bool contains = codepoints[c];\n+      return !contains;\n+    };\n+    if (left && !ARROW_PREDICT_TRUE(\n+                    arrow::util::UTF8FindIf(begin, end, predicate, &begin_trimmed))) {\n+      return false;\n+    }\n+    if (right && (begin_trimmed < end)) {\n+      if (!ARROW_PREDICT_TRUE(arrow::util::UTF8FindIfReverse(begin_trimmed, end,\n+                                                             predicate, &end_trimmed))) {\n+        return false;\n+      }\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+};\n+template <typename Type>\n+struct UTF8Trim : UTF8TrimBase<Type, true, true, UTF8Trim<Type>> {\n+  using Base = UTF8TrimBase<Type, true, true, UTF8Trim<Type>>;\n+  using Base::Base;\n+};\n+\n+template <typename Type>\n+struct UTF8LTrim : UTF8TrimBase<Type, true, false, UTF8LTrim<Type>> {\n+  using Base = UTF8TrimBase<Type, true, false, UTF8LTrim<Type>>;\n+  using Base::Base;\n+};\n+\n+template <typename Type>\n+struct UTF8RTrim : UTF8TrimBase<Type, false, true, UTF8RTrim<Type>> {\n+  using Base = UTF8TrimBase<Type, false, true, UTF8RTrim<Type>>;\n+  using Base::Base;\n+};\n+\n+#endif\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct AsciiTrimWhitespaceBase : StringTransform<Type, Derived> {\n+  using offset_type = typename Type::offset_type;\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+\n+    auto predicate = [](unsigned char c) { return !IsSpaceCharacterAscii(c); };\n+    const uint8_t* begin_trimmed = left ? std::find_if(begin, end, predicate) : begin;\n+    if (right & (begin_trimmed < end)) {\n+      std::reverse_iterator<const uint8_t*> rbegin(end);\n+      std::reverse_iterator<const uint8_t*> rend(begin_trimmed);\n+      end_trimmed = std::find_if(rbegin, rend, predicate).base();\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+};\n+\n+template <typename Type>\n+struct AsciiTrimWhitespace\n+    : AsciiTrimWhitespaceBase<Type, true, true, AsciiTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct AsciiLTrimWhitespace\n+    : AsciiTrimWhitespaceBase<Type, true, false, AsciiLTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct AsciiRTrimWhitespace\n+    : AsciiTrimWhitespaceBase<Type, false, true, AsciiRTrimWhitespace<Type>> {};\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct AsciiTrimBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<TrimOptions>;\n+  TrimOptions options;\n+  std::vector<bool> characters;\n+\n+  explicit AsciiTrimBase(TrimOptions options) : options(options), characters(256) {\n+    std::for_each(options.characters.begin(), options.characters.end(),\n+                  [&](char c) { characters[static_cast<unsigned char>(c)] = true; });\n+  }\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    TrimOptions options = State::Get(ctx);\n+    Derived(options).Execute(ctx, batch, out);\n+  }\n+\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+    const uint8_t* begin_trimmed;\n+\n+    auto predicate = [&](unsigned char c) {\n+      bool contains = characters[c];\n+      return !contains;\n+    };\n+\n+    begin_trimmed = left ? std::find_if(begin, end, predicate) : begin;\n+    if (right & (begin_trimmed < end)) {\n+      std::reverse_iterator<const uint8_t*> rbegin(end);\n+      std::reverse_iterator<const uint8_t*> rend(begin_trimmed);\n+      end_trimmed = std::find_if(rbegin, rend, predicate).base();\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+};\n+\n+template <typename Type>\n+struct AsciiTrim : AsciiTrimBase<Type, true, true, AsciiTrim<Type>> {\n+  using Base = AsciiTrimBase<Type, true, true, AsciiTrim<Type>>;\n+  using Base::Base;\n+};\n+\n+template <typename Type>\n+struct AsciiLTrim : AsciiTrimBase<Type, true, false, AsciiLTrim<Type>> {\n+  using Base = AsciiTrimBase<Type, true, false, AsciiLTrim<Type>>;\n+  using Base::Base;\n+};\n+\n+template <typename Type>\n+struct AsciiRTrim : AsciiTrimBase<Type, false, true, AsciiRTrim<Type>> {\n+  using Base = AsciiTrimBase<Type, false, true, AsciiRTrim<Type>>;\n+  using Base::Base;\n+};\n+\n+const FunctionDoc utf8_trim_whitespace_doc(\n+    \"Trim leading and trailing whitespace characters\",\n+    (\"For each string in `strings`, emit a string with leading and trailing whitespace \"\n\nReview comment:\n       The other docstrings include `\\n` manually at the end of each line. I suppose this is to ensure it's properly formatted in python's help (but didn't check how it looks with this PR). \r\n   \r\n   (Now, I assume we could also update the python code that assembles the docstring to automatically do line wrapping with `textwrap` stdlib module, but that's probably something for another issue)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T12:09:06.435+0000",
                    "updated": "2020-11-11T12:09:06.435+0000",
                    "started": "2020-11-11T12:09:06.434+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510197",
                    "issueId": "13311354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/510285",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on a change in pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621#discussion_r521422359\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -1231,6 +1251,305 @@ Result<ValueDescr> StrptimeResolve(KernelContext* ctx, const std::vector<ValueDe\n   return Status::Invalid(\"strptime does not provide default StrptimeOptions\");\n }\n \n+#ifdef ARROW_WITH_UTF8PROC\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimWhitespaceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+    const uint8_t* begin_trimmed = begin;\n+\n+    auto predicate = [](uint32_t c) { return !IsSpaceCharacterUnicode(c); };\n+    if (left && !ARROW_PREDICT_TRUE(\n+                    arrow::util::UTF8FindIf(begin, end, predicate, &begin_trimmed))) {\n+      return false;\n+    }\n+    if (right && (begin_trimmed < end)) {\n+      if (!ARROW_PREDICT_TRUE(arrow::util::UTF8FindIfReverse(begin_trimmed, end,\n+                                                             predicate, &end_trimmed))) {\n+        return false;\n+      }\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+template <typename Type>\n+struct UTF8TrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, true, UTF8TrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8LTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, false, UTF8LTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8RTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, false, true, UTF8RTrimWhitespace<Type>> {};\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<TrimOptions>;\n+  TrimOptions options;\n+  std::vector<bool> codepoints;\n+\n+  explicit UTF8TrimBase(TrimOptions options) : options(options) {\n+    // TODO: check return / can we raise an exception here?\n+    arrow::util::UTF8ForEach(options.characters, [&](uint32_t c) {\n+      codepoints.resize(std::max(c + 1, static_cast<uint32_t>(codepoints.size())));\n+      codepoints.at(c) = true;\n+    });\n+  }\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    TrimOptions options = State::Get(ctx);\n+    Derived(options).Execute(ctx, batch, out);\n+  }\n+\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();\n+    Base::Execute(ctx, batch, out);\n+  }\n+\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+    const uint8_t* begin_trimmed = begin;\n+\n+    auto predicate = [&](uint32_t c) {\n+      bool contains = codepoints[c];\n+      return !contains;\n+    };\n+    if (left && !ARROW_PREDICT_TRUE(\n+                    arrow::util::UTF8FindIf(begin, end, predicate, &begin_trimmed))) {\n+      return false;\n+    }\n+    if (right && (begin_trimmed < end)) {\n+      if (!ARROW_PREDICT_TRUE(arrow::util::UTF8FindIfReverse(begin_trimmed, end,\n+                                                             predicate, &end_trimmed))) {\n+        return false;\n+      }\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+};\n+template <typename Type>\n+struct UTF8Trim : UTF8TrimBase<Type, true, true, UTF8Trim<Type>> {\n+  using Base = UTF8TrimBase<Type, true, true, UTF8Trim<Type>>;\n+  using Base::Base;\n+};\n+\n+template <typename Type>\n+struct UTF8LTrim : UTF8TrimBase<Type, true, false, UTF8LTrim<Type>> {\n+  using Base = UTF8TrimBase<Type, true, false, UTF8LTrim<Type>>;\n+  using Base::Base;\n+};\n+\n+template <typename Type>\n+struct UTF8RTrim : UTF8TrimBase<Type, false, true, UTF8RTrim<Type>> {\n+  using Base = UTF8TrimBase<Type, false, true, UTF8RTrim<Type>>;\n+  using Base::Base;\n+};\n+\n+#endif\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct AsciiTrimWhitespaceBase : StringTransform<Type, Derived> {\n+  using offset_type = typename Type::offset_type;\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+\n+    auto predicate = [](unsigned char c) { return !IsSpaceCharacterAscii(c); };\n+    const uint8_t* begin_trimmed = left ? std::find_if(begin, end, predicate) : begin;\n+    if (right & (begin_trimmed < end)) {\n+      std::reverse_iterator<const uint8_t*> rbegin(end);\n+      std::reverse_iterator<const uint8_t*> rend(begin_trimmed);\n+      end_trimmed = std::find_if(rbegin, rend, predicate).base();\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+};\n+\n+template <typename Type>\n+struct AsciiTrimWhitespace\n+    : AsciiTrimWhitespaceBase<Type, true, true, AsciiTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct AsciiLTrimWhitespace\n+    : AsciiTrimWhitespaceBase<Type, true, false, AsciiLTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct AsciiRTrimWhitespace\n+    : AsciiTrimWhitespaceBase<Type, false, true, AsciiRTrimWhitespace<Type>> {};\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct AsciiTrimBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<TrimOptions>;\n+  TrimOptions options;\n+  std::vector<bool> characters;\n+\n+  explicit AsciiTrimBase(TrimOptions options) : options(options), characters(256) {\n+    std::for_each(options.characters.begin(), options.characters.end(),\n+                  [&](char c) { characters[static_cast<unsigned char>(c)] = true; });\n+  }\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    TrimOptions options = State::Get(ctx);\n+    Derived(options).Execute(ctx, batch, out);\n+  }\n+\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+    const uint8_t* begin_trimmed;\n+\n+    auto predicate = [&](unsigned char c) {\n+      bool contains = characters[c];\n+      return !contains;\n+    };\n+\n+    begin_trimmed = left ? std::find_if(begin, end, predicate) : begin;\n+    if (right & (begin_trimmed < end)) {\n+      std::reverse_iterator<const uint8_t*> rbegin(end);\n+      std::reverse_iterator<const uint8_t*> rend(begin_trimmed);\n+      end_trimmed = std::find_if(rbegin, rend, predicate).base();\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+};\n+\n+template <typename Type>\n+struct AsciiTrim : AsciiTrimBase<Type, true, true, AsciiTrim<Type>> {\n+  using Base = AsciiTrimBase<Type, true, true, AsciiTrim<Type>>;\n+  using Base::Base;\n+};\n+\n+template <typename Type>\n+struct AsciiLTrim : AsciiTrimBase<Type, true, false, AsciiLTrim<Type>> {\n+  using Base = AsciiTrimBase<Type, true, false, AsciiLTrim<Type>>;\n+  using Base::Base;\n+};\n+\n+template <typename Type>\n+struct AsciiRTrim : AsciiTrimBase<Type, false, true, AsciiRTrim<Type>> {\n+  using Base = AsciiTrimBase<Type, false, true, AsciiRTrim<Type>>;\n+  using Base::Base;\n+};\n+\n+const FunctionDoc utf8_trim_whitespace_doc(\n+    \"Trim leading and trailing whitespace characters\",\n+    (\"For each string in `strings`, emit a string with leading and trailing whitespace \"\n\nReview comment:\n       Thanks, I didn't notice, fixed.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T15:07:08.271+0000",
                    "updated": "2020-11-11T15:07:08.271+0000",
                    "started": "2020-11-11T15:07:08.271+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510285",
                    "issueId": "13311354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/510286",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621#issuecomment-725476725\n\n\n   I've opened an issue at https://issues.apache.org/jira/browse/ARROW-10556\r\n   \r\n   I guess we still need to manually add content to compute.rst? \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T15:09:13.418+0000",
                    "updated": "2020-11-11T15:09:13.418+0000",
                    "started": "2020-11-11T15:09:13.418+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510286",
                    "issueId": "13311354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/510298",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621#issuecomment-725493506\n\n\n   > I guess we still need to manually add content to compute.rst?\r\n   \r\n   Yes, you do :-)\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T15:38:33.605+0000",
                    "updated": "2020-11-11T15:38:33.605+0000",
                    "started": "2020-11-11T15:38:33.605+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510298",
                    "issueId": "13311354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/516758",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621#issuecomment-733820473\n\n\n   @pitrou this is ready for review.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-25T16:42:43.007+0000",
                    "updated": "2020-11-25T16:42:43.007+0000",
                    "started": "2020-11-25T16:42:43.007+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "516758",
                    "issueId": "13311354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/517053",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621#discussion_r530997361\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -1231,6 +1251,302 @@ Result<ValueDescr> StrptimeResolve(KernelContext* ctx, const std::vector<ValueDe\n   return Status::Invalid(\"strptime does not provide default StrptimeOptions\");\n }\n \n+#ifdef ARROW_WITH_UTF8PROC\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimWhitespaceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+    const uint8_t* begin_trimmed = begin;\n+\n+    auto predicate = [](uint32_t c) { return !IsSpaceCharacterUnicode(c); };\n+    if (left && !ARROW_PREDICT_TRUE(\n+                    arrow::util::UTF8FindIf(begin, end, predicate, &begin_trimmed))) {\n+      return false;\n+    }\n+    if (right && (begin_trimmed < end)) {\n+      if (!ARROW_PREDICT_TRUE(arrow::util::UTF8FindIfReverse(begin_trimmed, end,\n+                                                             predicate, &end_trimmed))) {\n+        return false;\n+      }\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+template <typename Type>\n+struct UTF8TrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, true, UTF8TrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8LTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, false, UTF8LTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8RTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, false, true, UTF8RTrimWhitespace<Type>> {};\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<TrimOptions>;\n+  TrimOptions options;\n+  std::vector<bool> codepoints;\n+\n+  explicit UTF8TrimBase(TrimOptions options) : options(options) {\n+    // TODO: check return / can we raise an exception here?\n+    arrow::util::UTF8ForEach(options.characters, [&](uint32_t c) {\n+      codepoints.resize(std::max(c + 1, static_cast<uint32_t>(codepoints.size())));\n+      codepoints.at(c) = true;\n+    });\n+  }\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    TrimOptions options = State::Get(ctx);\n+    Derived(options).Execute(ctx, batch, out);\n+  }\n+\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();\n+    Base::Execute(ctx, batch, out);\n+  }\n+\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+    const uint8_t* begin_trimmed = begin;\n+\n+    auto predicate = [&](uint32_t c) {\n+      bool contains = codepoints[c];\n+      return !contains;\n+    };\n+    if (left && !ARROW_PREDICT_TRUE(\n+                    arrow::util::UTF8FindIf(begin, end, predicate, &begin_trimmed))) {\n+      return false;\n+    }\n+    if (right && (begin_trimmed < end)) {\n+      if (!ARROW_PREDICT_TRUE(arrow::util::UTF8FindIfReverse(begin_trimmed, end,\n+                                                             predicate, &end_trimmed))) {\n+        return false;\n+      }\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+};\n+template <typename Type>\n+struct UTF8Trim : UTF8TrimBase<Type, true, true, UTF8Trim<Type>> {\n+  using Base = UTF8TrimBase<Type, true, true, UTF8Trim<Type>>;\n+  using Base::Base;\n+};\n+\n+template <typename Type>\n+struct UTF8LTrim : UTF8TrimBase<Type, true, false, UTF8LTrim<Type>> {\n+  using Base = UTF8TrimBase<Type, true, false, UTF8LTrim<Type>>;\n+  using Base::Base;\n+};\n+\n+template <typename Type>\n+struct UTF8RTrim : UTF8TrimBase<Type, false, true, UTF8RTrim<Type>> {\n+  using Base = UTF8TrimBase<Type, false, true, UTF8RTrim<Type>>;\n+  using Base::Base;\n+};\n+\n+#endif\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct AsciiTrimWhitespaceBase : StringTransform<Type, Derived> {\n+  using offset_type = typename Type::offset_type;\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+\n+    auto predicate = [](unsigned char c) { return !IsSpaceCharacterAscii(c); };\n+    const uint8_t* begin_trimmed = left ? std::find_if(begin, end, predicate) : begin;\n+    if (right & (begin_trimmed < end)) {\n+      std::reverse_iterator<const uint8_t*> rbegin(end);\n+      std::reverse_iterator<const uint8_t*> rend(begin_trimmed);\n+      end_trimmed = std::find_if(rbegin, rend, predicate).base();\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+};\n+\n+template <typename Type>\n+struct AsciiTrimWhitespace\n+    : AsciiTrimWhitespaceBase<Type, true, true, AsciiTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct AsciiLTrimWhitespace\n+    : AsciiTrimWhitespaceBase<Type, true, false, AsciiLTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct AsciiRTrimWhitespace\n+    : AsciiTrimWhitespaceBase<Type, false, true, AsciiRTrimWhitespace<Type>> {};\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct AsciiTrimBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<TrimOptions>;\n+  TrimOptions options;\n+  std::vector<bool> characters;\n+\n+  explicit AsciiTrimBase(TrimOptions options) : options(options), characters(256) {\n+    std::for_each(options.characters.begin(), options.characters.end(),\n+                  [&](char c) { characters[static_cast<unsigned char>(c)] = true; });\n+  }\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    TrimOptions options = State::Get(ctx);\n+    Derived(options).Execute(ctx, batch, out);\n\nReview comment:\n       Can `std::move(options)`\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -1231,6 +1251,302 @@ Result<ValueDescr> StrptimeResolve(KernelContext* ctx, const std::vector<ValueDe\n   return Status::Invalid(\"strptime does not provide default StrptimeOptions\");\n }\n \n+#ifdef ARROW_WITH_UTF8PROC\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimWhitespaceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+    const uint8_t* begin_trimmed = begin;\n+\n+    auto predicate = [](uint32_t c) { return !IsSpaceCharacterUnicode(c); };\n+    if (left && !ARROW_PREDICT_TRUE(\n+                    arrow::util::UTF8FindIf(begin, end, predicate, &begin_trimmed))) {\n+      return false;\n+    }\n+    if (right && (begin_trimmed < end)) {\n+      if (!ARROW_PREDICT_TRUE(arrow::util::UTF8FindIfReverse(begin_trimmed, end,\n+                                                             predicate, &end_trimmed))) {\n+        return false;\n+      }\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+template <typename Type>\n+struct UTF8TrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, true, UTF8TrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8LTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, false, UTF8LTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8RTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, false, true, UTF8RTrimWhitespace<Type>> {};\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<TrimOptions>;\n+  TrimOptions options;\n+  std::vector<bool> codepoints;\n+\n+  explicit UTF8TrimBase(TrimOptions options) : options(options) {\n+    // TODO: check return / can we raise an exception here?\n+    arrow::util::UTF8ForEach(options.characters, [&](uint32_t c) {\n+      codepoints.resize(std::max(c + 1, static_cast<uint32_t>(codepoints.size())));\n+      codepoints.at(c) = true;\n+    });\n+  }\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    TrimOptions options = State::Get(ctx);\n+    Derived(options).Execute(ctx, batch, out);\n+  }\n+\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();\n+    Base::Execute(ctx, batch, out);\n+  }\n+\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+    const uint8_t* begin_trimmed = begin;\n+\n+    auto predicate = [&](uint32_t c) {\n+      bool contains = codepoints[c];\n+      return !contains;\n+    };\n+    if (left && !ARROW_PREDICT_TRUE(\n+                    arrow::util::UTF8FindIf(begin, end, predicate, &begin_trimmed))) {\n+      return false;\n+    }\n+    if (right && (begin_trimmed < end)) {\n+      if (!ARROW_PREDICT_TRUE(arrow::util::UTF8FindIfReverse(begin_trimmed, end,\n+                                                             predicate, &end_trimmed))) {\n+        return false;\n+      }\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+};\n+template <typename Type>\n+struct UTF8Trim : UTF8TrimBase<Type, true, true, UTF8Trim<Type>> {\n+  using Base = UTF8TrimBase<Type, true, true, UTF8Trim<Type>>;\n+  using Base::Base;\n+};\n+\n+template <typename Type>\n+struct UTF8LTrim : UTF8TrimBase<Type, true, false, UTF8LTrim<Type>> {\n+  using Base = UTF8TrimBase<Type, true, false, UTF8LTrim<Type>>;\n+  using Base::Base;\n+};\n+\n+template <typename Type>\n+struct UTF8RTrim : UTF8TrimBase<Type, false, true, UTF8RTrim<Type>> {\n+  using Base = UTF8TrimBase<Type, false, true, UTF8RTrim<Type>>;\n+  using Base::Base;\n+};\n+\n+#endif\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct AsciiTrimWhitespaceBase : StringTransform<Type, Derived> {\n+  using offset_type = typename Type::offset_type;\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+\n+    auto predicate = [](unsigned char c) { return !IsSpaceCharacterAscii(c); };\n+    const uint8_t* begin_trimmed = left ? std::find_if(begin, end, predicate) : begin;\n+    if (right & (begin_trimmed < end)) {\n+      std::reverse_iterator<const uint8_t*> rbegin(end);\n+      std::reverse_iterator<const uint8_t*> rend(begin_trimmed);\n+      end_trimmed = std::find_if(rbegin, rend, predicate).base();\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+};\n+\n+template <typename Type>\n+struct AsciiTrimWhitespace\n+    : AsciiTrimWhitespaceBase<Type, true, true, AsciiTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct AsciiLTrimWhitespace\n+    : AsciiTrimWhitespaceBase<Type, true, false, AsciiLTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct AsciiRTrimWhitespace\n+    : AsciiTrimWhitespaceBase<Type, false, true, AsciiRTrimWhitespace<Type>> {};\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct AsciiTrimBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<TrimOptions>;\n+  TrimOptions options;\n+  std::vector<bool> characters;\n+\n+  explicit AsciiTrimBase(TrimOptions options) : options(options), characters(256) {\n\nReview comment:\n       Can `std::move(options)`\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string_test.cc\n##########\n@@ -428,6 +428,59 @@ TYPED_TEST(TestStringKernels, StrptimeDoesNotProvideDefaultOptions) {\n   ASSERT_RAISES(Invalid, CallFunction(\"strptime\", {input}));\n }\n \n+#ifdef ARROW_WITH_UTF8PROC\n+\n+TYPED_TEST(TestStringKernels, TrimWhitespaceUTF8) {\n+  // \\xe2\\x80\\x88 is punctuation space\n+  this->CheckUnary(\"utf8_trim_whitespace\",\n+                   \"[\\\" foo\\\", null, \\\"bar  \\\", \\\" \\xe2\\x80\\x88 foo bar \\\"]\",\n\nReview comment:\n       Just for the record, you can also use the \"raw strings\" syntax that C++ offers:\r\n   ```c++\r\n   R\"([\" foo\", null, \"bar  \", \" \\xe2\\x80\\x88 foo bar \"])\"\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -1231,6 +1251,302 @@ Result<ValueDescr> StrptimeResolve(KernelContext* ctx, const std::vector<ValueDe\n   return Status::Invalid(\"strptime does not provide default StrptimeOptions\");\n }\n \n+#ifdef ARROW_WITH_UTF8PROC\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimWhitespaceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+    const uint8_t* begin_trimmed = begin;\n+\n+    auto predicate = [](uint32_t c) { return !IsSpaceCharacterUnicode(c); };\n+    if (left && !ARROW_PREDICT_TRUE(\n+                    arrow::util::UTF8FindIf(begin, end, predicate, &begin_trimmed))) {\n+      return false;\n+    }\n+    if (right && (begin_trimmed < end)) {\n+      if (!ARROW_PREDICT_TRUE(arrow::util::UTF8FindIfReverse(begin_trimmed, end,\n+                                                             predicate, &end_trimmed))) {\n+        return false;\n+      }\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+template <typename Type>\n+struct UTF8TrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, true, UTF8TrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8LTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, false, UTF8LTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8RTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, false, true, UTF8RTrimWhitespace<Type>> {};\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<TrimOptions>;\n+  TrimOptions options;\n+  std::vector<bool> codepoints;\n+\n+  explicit UTF8TrimBase(TrimOptions options) : options(options) {\n+    // TODO: check return / can we raise an exception here?\n+    arrow::util::UTF8ForEach(options.characters, [&](uint32_t c) {\n+      codepoints.resize(std::max(c + 1, static_cast<uint32_t>(codepoints.size())));\n+      codepoints.at(c) = true;\n+    });\n+  }\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    TrimOptions options = State::Get(ctx);\n+    Derived(options).Execute(ctx, batch, out);\n+  }\n+\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();\n+    Base::Execute(ctx, batch, out);\n+  }\n+\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+    const uint8_t* begin_trimmed = begin;\n+\n+    auto predicate = [&](uint32_t c) {\n+      bool contains = codepoints[c];\n+      return !contains;\n+    };\n+    if (left && !ARROW_PREDICT_TRUE(\n+                    arrow::util::UTF8FindIf(begin, end, predicate, &begin_trimmed))) {\n+      return false;\n+    }\n+    if (right && (begin_trimmed < end)) {\n+      if (!ARROW_PREDICT_TRUE(arrow::util::UTF8FindIfReverse(begin_trimmed, end,\n+                                                             predicate, &end_trimmed))) {\n+        return false;\n+      }\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+};\n+template <typename Type>\n+struct UTF8Trim : UTF8TrimBase<Type, true, true, UTF8Trim<Type>> {\n+  using Base = UTF8TrimBase<Type, true, true, UTF8Trim<Type>>;\n+  using Base::Base;\n+};\n+\n+template <typename Type>\n+struct UTF8LTrim : UTF8TrimBase<Type, true, false, UTF8LTrim<Type>> {\n+  using Base = UTF8TrimBase<Type, true, false, UTF8LTrim<Type>>;\n+  using Base::Base;\n+};\n+\n+template <typename Type>\n+struct UTF8RTrim : UTF8TrimBase<Type, false, true, UTF8RTrim<Type>> {\n+  using Base = UTF8TrimBase<Type, false, true, UTF8RTrim<Type>>;\n+  using Base::Base;\n+};\n+\n+#endif\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct AsciiTrimWhitespaceBase : StringTransform<Type, Derived> {\n+  using offset_type = typename Type::offset_type;\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+\n+    auto predicate = [](unsigned char c) { return !IsSpaceCharacterAscii(c); };\n+    const uint8_t* begin_trimmed = left ? std::find_if(begin, end, predicate) : begin;\n+    if (right & (begin_trimmed < end)) {\n+      std::reverse_iterator<const uint8_t*> rbegin(end);\n+      std::reverse_iterator<const uint8_t*> rend(begin_trimmed);\n+      end_trimmed = std::find_if(rbegin, rend, predicate).base();\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+};\n+\n+template <typename Type>\n+struct AsciiTrimWhitespace\n+    : AsciiTrimWhitespaceBase<Type, true, true, AsciiTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct AsciiLTrimWhitespace\n+    : AsciiTrimWhitespaceBase<Type, true, false, AsciiLTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct AsciiRTrimWhitespace\n+    : AsciiTrimWhitespaceBase<Type, false, true, AsciiRTrimWhitespace<Type>> {};\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct AsciiTrimBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<TrimOptions>;\n+  TrimOptions options;\n+  std::vector<bool> characters;\n\nReview comment:\n       Nit, but the convention is to append a trailing underscore to instance variable names (`options_`, `characters_`), so as to distinguish them from local variables.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -1231,6 +1251,302 @@ Result<ValueDescr> StrptimeResolve(KernelContext* ctx, const std::vector<ValueDe\n   return Status::Invalid(\"strptime does not provide default StrptimeOptions\");\n }\n \n+#ifdef ARROW_WITH_UTF8PROC\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimWhitespaceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+    const uint8_t* begin_trimmed = begin;\n+\n+    auto predicate = [](uint32_t c) { return !IsSpaceCharacterUnicode(c); };\n+    if (left && !ARROW_PREDICT_TRUE(\n+                    arrow::util::UTF8FindIf(begin, end, predicate, &begin_trimmed))) {\n+      return false;\n+    }\n+    if (right && (begin_trimmed < end)) {\n+      if (!ARROW_PREDICT_TRUE(arrow::util::UTF8FindIfReverse(begin_trimmed, end,\n+                                                             predicate, &end_trimmed))) {\n+        return false;\n+      }\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+template <typename Type>\n+struct UTF8TrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, true, UTF8TrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8LTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, false, UTF8LTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8RTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, false, true, UTF8RTrimWhitespace<Type>> {};\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<TrimOptions>;\n+  TrimOptions options;\n+  std::vector<bool> codepoints;\n+\n+  explicit UTF8TrimBase(TrimOptions options) : options(options) {\n+    // TODO: check return / can we raise an exception here?\n\nReview comment:\n       You could set the status on the KernelContext in the caller.\n\n##########\nFile path: cpp/src/arrow/util/utf8_util_test.cc\n##########\n@@ -412,5 +412,32 @@ TEST(UTF8DecodeReverse, Basics) {\n   CheckInvalid(\"\\xF0\\x80\\x80\");\n }\n \n+TEST(UTF8FindIf, Basics) {\n+  auto CheckOk = [](const std::string& s, unsigned char test, int64_t offset_left,\n+                    int64_t offset_right) -> void {\n+    const uint8_t* begin = reinterpret_cast<const uint8_t*>(s.c_str());\n+    const uint8_t* end = begin + s.length();\n+    std::reverse_iterator<const uint8_t*> rbegin(end);\n+    std::reverse_iterator<const uint8_t*> rend(begin);\n+    const uint8_t* left;\n+    const uint8_t* right;\n+    auto predicate = [&](uint32_t c) { return c == test; };\n+    EXPECT_TRUE(UTF8FindIf(begin, end, predicate, &left));\n+    EXPECT_TRUE(UTF8FindIfReverse(begin, end, predicate, &right));\n+    EXPECT_EQ(offset_left, left - begin);\n+    EXPECT_EQ(offset_right, right - begin);\n+    EXPECT_EQ(std::find_if(begin, end, predicate) - begin, left - begin);\n+    EXPECT_EQ(std::find_if(rbegin, rend, predicate).base() - begin, right - begin);\n+  };\n+\n+  CheckOk(\"aaaba\", 'a', 0, 5);\n+  CheckOk(\"aaaba\", 'b', 3, 4);\n+  CheckOk(\"aaababa\", 'b', 3, 6);\n+  CheckOk(\"aaababa\", 'c', 7, 0);\n+  CheckOk(\"a\", 'a', 0, 1);\n+  CheckOk(\"a\", 'b', 1, 0);\n+  CheckOk(\"\", 'b', 0, 0);\n\nReview comment:\n       Hmm... this conveniently only checks ASCII characters. The implementation looks ok, but still.\n\n##########\nFile path: cpp/src/arrow/util/utf8.h\n##########\n@@ -456,6 +456,67 @@ static inline bool UTF8Transform(const uint8_t* first, const uint8_t* last,\n   return true;\n }\n \n+template <class Predicate>\n+static inline bool UTF8FindIf(const uint8_t* first, const uint8_t* last,\n+                              Predicate&& predicate, const uint8_t** position) {\n+  const uint8_t* i = first;\n+  while (i < last) {\n+    uint32_t codepoint = 0;\n+    const uint8_t* current = i;\n+    if (ARROW_PREDICT_FALSE(!UTF8Decode(&i, &codepoint))) {\n+      return false;\n+    }\n+    if (predicate(codepoint)) {\n+      *position = current;\n+      return true;\n+    }\n+  }\n+  *position = last;\n+  return true;\n+}\n+\n+// same semantics as std::find_if using reverse iterators when the return value\n+// having the same semantics as std::reverse_iterator<..>.base()\n+template <class Predicate>\n+static inline bool UTF8FindIfReverse(const uint8_t* first, const uint8_t* last,\n+                                     Predicate&& predicate, const uint8_t** position) {\n+  const uint8_t* i = last - 1;\n+  while (i >= first) {\n+    uint32_t codepoint = 0;\n+    const uint8_t* current = i;\n+    if (ARROW_PREDICT_FALSE(!UTF8DecodeReverse(&i, &codepoint))) {\n+      return false;\n+    }\n+    if (predicate(codepoint)) {\n+      *position = current + 1;\n+      return true;\n+    }\n+  }\n+  *position = first;\n+  return true;\n+}\n+\n+template <class UnaryFunction>\n+static inline bool UTF8ForEach(const uint8_t* first, const uint8_t* last,\n+                               UnaryFunction&& f) {\n+  const uint8_t* i = first;\n+  while (i < last) {\n+    uint32_t codepoint = 0;\n+    if (ARROW_PREDICT_FALSE(!UTF8Decode(&i, &codepoint))) {\n+      return false;\n+    }\n+    f(codepoint);\n+  }\n+  return true;\n+}\n+\n+template <class UnaryFunction>\n+static inline bool UTF8ForEach(std::string s, UnaryFunction&& f) {\n\nReview comment:\n       `const std::string& s`, since it's neither stored nor mutated?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string_test.cc\n##########\n@@ -428,6 +428,59 @@ TYPED_TEST(TestStringKernels, StrptimeDoesNotProvideDefaultOptions) {\n   ASSERT_RAISES(Invalid, CallFunction(\"strptime\", {input}));\n }\n \n+#ifdef ARROW_WITH_UTF8PROC\n+\n+TYPED_TEST(TestStringKernels, TrimWhitespaceUTF8) {\n+  // \\xe2\\x80\\x88 is punctuation space\n+  this->CheckUnary(\"utf8_trim_whitespace\",\n+                   \"[\\\" foo\\\", null, \\\"bar  \\\", \\\" \\xe2\\x80\\x88 foo bar \\\"]\",\n+                   this->type(), \"[\\\"foo\\\", null, \\\"bar\\\", \\\"foo bar\\\"]\");\n+  this->CheckUnary(\"utf8_rtrim_whitespace\",\n+                   \"[\\\" foo\\\", null, \\\"bar  \\\", \\\" \\xe2\\x80\\x88 foo bar \\\"]\",\n+                   this->type(), \"[\\\" foo\\\", null, \\\"bar\\\", \\\" \\xe2\\x80\\x88 foo bar\\\"]\");\n+  this->CheckUnary(\"utf8_ltrim_whitespace\",\n+                   \"[\\\" foo\\\", null, \\\"bar  \\\", \\\" \\xe2\\x80\\x88 foo bar \\\"]\",\n+                   this->type(), \"[\\\"foo\\\", null, \\\"bar  \\\", \\\"foo bar \\\"]\");\n+}\n+\n+TYPED_TEST(TestStringKernels, TrimUTF8) {\n+  TrimOptions options{\"\u023aA\"};\n+  this->CheckUnary(\"utf8_trim\", \"[\\\"\u023a\u023afoo\u023aA\u023a\\\", null, \\\"bar\u023aA\u023a\\\", \\\"\u023aA\u023afoo\u023aA\u023abarA\\\"]\",\n+                   this->type(), \"[\\\"foo\\\", null, \\\"bar\\\", \\\"foo\u023aA\u023abar\\\"]\", &options);\n+  this->CheckUnary(\"utf8_ltrim\", \"[\\\"\u023a\u023afoo\u023aA\u023a\\\", null, \\\"bar\u023aA\u023a\\\", \\\"\u023aA\u023afoo\u023aA\u023abarA\\\"]\",\n+                   this->type(), \"[\\\"foo\u023aA\u023a\\\", null, \\\"bar\u023aA\u023a\\\", \\\"foo\u023aA\u023abarA\\\"]\",\n+                   &options);\n+  this->CheckUnary(\"utf8_rtrim\", \"[\\\"\u023a\u023afoo\u023aA\u023a\\\", null, \\\"bar\u023aA\u023a\\\", \\\"\u023aA\u023afoo\u023aA\u023abarA\\\"]\",\n+                   this->type(), \"[\\\"\u023a\u023afoo\\\", null, \\\"bar\\\", \\\"\u023aA\u023afoo\u023aA\u023abar\\\"]\",\n+                   &options);\n+}\n+#endif\n+\n+TYPED_TEST(TestStringKernels, TrimWhitespaceAscii) {\n+  // \\xe2\\x80\\x88 is punctuation space\n\nReview comment:\n       Also check regular Ascii whitespace such `\\t` or `\\r`?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-26T12:46:43.794+0000",
                    "updated": "2020-11-26T12:46:43.794+0000",
                    "started": "2020-11-26T12:46:43.794+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517053",
                    "issueId": "13311354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/525940",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on a change in pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621#discussion_r545752285\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string_test.cc\n##########\n@@ -428,6 +428,59 @@ TYPED_TEST(TestStringKernels, StrptimeDoesNotProvideDefaultOptions) {\n   ASSERT_RAISES(Invalid, CallFunction(\"strptime\", {input}));\n }\n \n+#ifdef ARROW_WITH_UTF8PROC\n+\n+TYPED_TEST(TestStringKernels, TrimWhitespaceUTF8) {\n+  // \\xe2\\x80\\x88 is punctuation space\n+  this->CheckUnary(\"utf8_trim_whitespace\",\n+                   \"[\\\" foo\\\", null, \\\"bar  \\\", \\\" \\xe2\\x80\\x88 foo bar \\\"]\",\n\nReview comment:\n       But that does not escape the escape chars, so you end up with:\r\n   ```\r\n   R\"([\" foo\", null, \"bar  \", \" )\"\r\n   \"\\xe2\\x80\\x88\"\r\n   R\"(foo bar \"])\"\r\n   ```\r\n   Which I also consider ugly :)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-18T10:49:27.242+0000",
                    "updated": "2020-12-18T10:49:27.242+0000",
                    "started": "2020-12-18T10:49:27.241+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525940",
                    "issueId": "13311354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/526001",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on a change in pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621#discussion_r545867768\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -1231,6 +1251,302 @@ Result<ValueDescr> StrptimeResolve(KernelContext* ctx, const std::vector<ValueDe\n   return Status::Invalid(\"strptime does not provide default StrptimeOptions\");\n }\n \n+#ifdef ARROW_WITH_UTF8PROC\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimWhitespaceBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  bool Transform(const uint8_t* input, offset_type input_string_ncodeunits,\n+                 uint8_t* output, offset_type* output_written) {\n+    const uint8_t* begin = input;\n+    const uint8_t* end = input + input_string_ncodeunits;\n+    const uint8_t* end_trimmed = end;\n+    const uint8_t* begin_trimmed = begin;\n+\n+    auto predicate = [](uint32_t c) { return !IsSpaceCharacterUnicode(c); };\n+    if (left && !ARROW_PREDICT_TRUE(\n+                    arrow::util::UTF8FindIf(begin, end, predicate, &begin_trimmed))) {\n+      return false;\n+    }\n+    if (right && (begin_trimmed < end)) {\n+      if (!ARROW_PREDICT_TRUE(arrow::util::UTF8FindIfReverse(begin_trimmed, end,\n+                                                             predicate, &end_trimmed))) {\n+        return false;\n+      }\n+    }\n+    std::copy(begin_trimmed, end_trimmed, output);\n+    *output_written = static_cast<offset_type>(end_trimmed - begin_trimmed);\n+    return true;\n+  }\n+  void Execute(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    EnsureLookupTablesFilled();\n+    Base::Execute(ctx, batch, out);\n+  }\n+};\n+\n+template <typename Type>\n+struct UTF8TrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, true, UTF8TrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8LTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, true, false, UTF8LTrimWhitespace<Type>> {};\n+\n+template <typename Type>\n+struct UTF8RTrimWhitespace\n+    : UTF8TrimWhitespaceBase<Type, false, true, UTF8RTrimWhitespace<Type>> {};\n+\n+template <typename Type, bool left, bool right, typename Derived>\n+struct UTF8TrimBase : StringTransform<Type, Derived> {\n+  using Base = StringTransform<Type, Derived>;\n+  using offset_type = typename Base::offset_type;\n+  using State = OptionsWrapper<TrimOptions>;\n+  TrimOptions options;\n+  std::vector<bool> codepoints;\n+\n+  explicit UTF8TrimBase(TrimOptions options) : options(options) {\n+    // TODO: check return / can we raise an exception here?\n\nReview comment:\n       I've refactored this a bit, the kernel state now include the codepoint vector, and there's where I have access to the KernelContext*.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-18T14:33:24.603+0000",
                    "updated": "2020-12-18T14:33:24.603+0000",
                    "started": "2020-12-18T14:33:24.602+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "526001",
                    "issueId": "13311354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/530629",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621#issuecomment-753949140\n\n\n   @pitrou this is ready for review\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-04T12:31:33.639+0000",
                    "updated": "2021-01-04T12:31:33.639+0000",
                    "started": "2021-01-04T12:31:33.638+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "530629",
                    "issueId": "13311354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/530797",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621#discussion_r551437108\n\n\n\n##########\nFile path: cpp/src/arrow/util/utf8.h\n##########\n@@ -456,6 +456,67 @@ static inline bool UTF8Transform(const uint8_t* first, const uint8_t* last,\n   return true;\n }\n \n+template <class Predicate>\n+static inline bool UTF8FindIf(const uint8_t* first, const uint8_t* last,\n+                              Predicate&& predicate, const uint8_t** position) {\n+  const uint8_t* i = first;\n+  while (i < last) {\n+    uint32_t codepoint = 0;\n+    const uint8_t* current = i;\n+    if (ARROW_PREDICT_FALSE(!UTF8Decode(&i, &codepoint))) {\n+      return false;\n+    }\n+    if (predicate(codepoint)) {\n+      *position = current;\n+      return true;\n+    }\n+  }\n+  *position = last;\n+  return true;\n+}\n+\n+// same semantics as std::find_if using reverse iterators when the return value\n+// having the same semantics as std::reverse_iterator<..>.base()\n+template <class Predicate>\n+static inline bool UTF8FindIfReverse(const uint8_t* first, const uint8_t* last,\n+                                     Predicate&& predicate, const uint8_t** position) {\n+  const uint8_t* i = last - 1;\n+  while (i >= first) {\n+    uint32_t codepoint = 0;\n+    const uint8_t* current = i;\n+    if (ARROW_PREDICT_FALSE(!UTF8DecodeReverse(&i, &codepoint))) {\n+      return false;\n+    }\n+    if (predicate(codepoint)) {\n+      *position = current + 1;\n\nReview comment:\n       This is a bit weird. It returns the position to the next codepoint? The docstring should be a bit clearer about that (the current spelling is cryptic to me).\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_string.cc\n##########\n@@ -186,6 +172,40 @@ struct UTF8Transform {\n   }\n };\n \n+#ifdef ARROW_WITH_UTF8PROC\n+\n+template <typename Type, typename Derived>\n+struct UTF8Transform : StringTransform<Type, Derived> {\n\nReview comment:\n       I don't exactly understand this refactor. There's a `UTF8Transform` with a `Transform` method for utf8 kernels but no corresponding class with a `Transform` method for ascii kernels, is that right?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-04T18:10:31.082+0000",
                    "updated": "2021-01-04T18:10:31.082+0000",
                    "started": "2021-01-04T18:10:31.082+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "530797",
                    "issueId": "13311354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/534885",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621#issuecomment-758708026\n\n\n   It'd be nice to include in the release, so ping @maartenbreddels \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T14:52:35.197+0000",
                    "updated": "2021-01-12T14:52:35.197+0000",
                    "started": "2021-01-12T14:52:35.196+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534885",
                    "issueId": "13311354"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/worklog/534965",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "maartenbreddels commented on a change in pull request #8621:\nURL: https://github.com/apache/arrow/pull/8621#discussion_r555979073\n\n\n\n##########\nFile path: cpp/src/arrow/util/utf8.h\n##########\n@@ -456,6 +456,67 @@ static inline bool UTF8Transform(const uint8_t* first, const uint8_t* last,\n   return true;\n }\n \n+template <class Predicate>\n+static inline bool UTF8FindIf(const uint8_t* first, const uint8_t* last,\n+                              Predicate&& predicate, const uint8_t** position) {\n+  const uint8_t* i = first;\n+  while (i < last) {\n+    uint32_t codepoint = 0;\n+    const uint8_t* current = i;\n+    if (ARROW_PREDICT_FALSE(!UTF8Decode(&i, &codepoint))) {\n+      return false;\n+    }\n+    if (predicate(codepoint)) {\n+      *position = current;\n+      return true;\n+    }\n+  }\n+  *position = last;\n+  return true;\n+}\n+\n+// same semantics as std::find_if using reverse iterators when the return value\n+// having the same semantics as std::reverse_iterator<..>.base()\n+template <class Predicate>\n+static inline bool UTF8FindIfReverse(const uint8_t* first, const uint8_t* last,\n+                                     Predicate&& predicate, const uint8_t** position) {\n+  const uint8_t* i = last - 1;\n+  while (i >= first) {\n+    uint32_t codepoint = 0;\n+    const uint8_t* current = i;\n+    if (ARROW_PREDICT_FALSE(!UTF8DecodeReverse(&i, &codepoint))) {\n+      return false;\n+    }\n+    if (predicate(codepoint)) {\n+      *position = current + 1;\n\nReview comment:\n       I added some more text, hope that clarifies enough. See also \r\n   https://stackoverflow.com/questions/14760134/why-does-removing-the-first-element-of-a-list-invalidate-rend/14760316#14760316 \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T18:17:58.310+0000",
                    "updated": "2021-01-12T18:17:58.310+0000",
                    "started": "2021-01-12T18:17:58.310+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534965",
                    "issueId": "13311354"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 16200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@6b326d8a[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3d44d5e1[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@30798899[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@2b09a8aa[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@56f4258b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@618dbb2a[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1dcccac2[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@7be67d29[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@c49d7a3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@1169eb[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7bf029f1[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@33b71c93[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 16200,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Jan 19 17:34:41 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-01-19T17:34:41.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9128/watchers",
            "watchCount": 5,
            "isWatching": false
        },
        "created": "2020-06-14T19:39:15.000+0000",
        "updated": "2021-04-29T13:38:25.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 16200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Implement string space trimming kernels: trim, ltrim, and rtrim",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/comment/17138039",
                    "id": "17138039",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "I'm gonna tackle this tomorrow (Wednesday) probably",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-06-17T02:34:30.523+0000",
                    "updated": "2020-06-17T02:34:30.523+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/comment/17138213",
                    "id": "17138213",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "body": "In Python these routines are called \\{{strip}}, any reasons for going for {{trim}} here?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "created": "2020-06-17T08:00:18.157+0000",
                    "updated": "2020-06-17T08:00:18.157+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/comment/17191809",
                    "id": "17191809",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "SQL and Postgres have trim /\u00a0 ltrim / rtrim it seems, I suppose that explains the names proposed here.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2020-09-07T17:08:38.027+0000",
                    "updated": "2020-09-07T17:08:38.027+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/comment/17213857",
                    "id": "17213857",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=maartenbreddels",
                        "name": "maartenbreddels",
                        "key": "maartenbreddels",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Maarten Breddels",
                        "active": true,
                        "timeZone": "Europe/Amsterdam"
                    },
                    "body": "Shall I implement this?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=maartenbreddels",
                        "name": "maartenbreddels",
                        "key": "maartenbreddels",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Maarten Breddels",
                        "active": true,
                        "timeZone": "Europe/Amsterdam"
                    },
                    "created": "2020-10-14T12:10:42.768+0000",
                    "updated": "2020-10-14T12:10:42.768+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/comment/17213891",
                    "id": "17213891",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "This is unassigned, so you can definitely take it up.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2020-10-14T12:57:31.546+0000",
                    "updated": "2020-10-14T12:57:31.546+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311354/comment/17268075",
                    "id": "17268075",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 8621\n[https://github.com/apache/arrow/pull/8621]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-01-19T17:34:41.980+0000",
                    "updated": "2021-01-19T17:34:41.980+0000"
                }
            ],
            "maxResults": 6,
            "total": 6,
            "startAt": 0
        },
        "customfield_12311820": "0|z0fu3s:",
        "customfield_12314139": null
    }
}