{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13120503",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13120503",
    "key": "ARROW-1850",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12341352",
                "id": "12341352",
                "name": "0.8.0",
                "archived": false,
                "released": true,
                "releaseDate": "2017-12-18"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "1.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": null,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": null,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1850/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 0,
            "worklogs": []
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": null,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@22c5bea9[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@77782d72[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@8f280a1[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@3ed73f70[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1ecd61bc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@735d710c[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6fb6104e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@689d9e77[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1d28c259[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@5e515e1[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5a8e5173[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@5ee40273[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": null,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Nov 27 16:46:03 UTC 2017",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2017-11-27T16:46:01.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1850/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2017-11-23T15:24:04.000+0000",
        "updated": "2017-11-27T16:46:03.000+0000",
        "timeoriginalestimate": null,
        "description": "I noticed that {{Writable}} is also misspelled. This would spare the user many usages of {{reinterpret_cast<const uint8_t*>(...)}}, and also will not cause any explicit API breakage (except where users have overridden the virtual function)",
        "customfield_10010": null,
        "timetracking": {},
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/attachment/12899411",
                "id": "12899411",
                "filename": "text.html",
                "author": {
                    "self": "https://issues.apache.org/jira/rest/api/2/user?username=Brian.Bowman%40sas.com",
                    "name": "Brian.Bowman@sas.com",
                    "key": "brian.bowman@sas.com",
                    "avatarUrls": {
                        "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                        "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                        "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                        "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                    },
                    "displayName": "Brian Bowman",
                    "active": true,
                    "timeZone": "Etc/UTC"
                },
                "created": "2017-11-27T14:45:14.467+0000",
                "size": 2005,
                "mimeType": "text/html",
                "content": "https://issues.apache.org/jira/secure/attachment/12899411/text.html"
            }
        ],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Use const void* in Writable::Write instead of const uint8_t*",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13120503/comment/16266185",
                    "id": "16266185",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm opened a new pull request #1363: ARROW-1850: [C++] Use void* / const void* for buffers in file APIs\nURL: https://github.com/apache/arrow/pull/1363\n \n \n   This makes for a more convenient / less rigid API without as need for as many usages of `reinterpret_cast<const uint8_t*>`. This does not impact downstream projects (e.g. parquet-cpp is unaffected) unless they provide implementations of these virtual interfaces. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-26T21:12:08.497+0000",
                    "updated": "2017-11-26T21:12:08.497+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13120503/comment/16266338",
                    "id": "16266338",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1363: ARROW-1850: [C++] Use void* / const void* for buffers in file APIs\nURL: https://github.com/apache/arrow/pull/1363#issuecomment-347070871\n \n \n   I will fix the glib bindings\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-27T03:37:08.171+0000",
                    "updated": "2017-11-27T03:37:08.171+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13120503/comment/16266890",
                    "id": "16266890",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=Brian.Bowman%40sas.com",
                        "name": "Brian.Bowman@sas.com",
                        "key": "brian.bowman@sas.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Brian Bowman",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "I\u2019m out of the office for the SAS Thanksgiving Holiday until Monday November 27th 2017.\r\n\r\n-Brian\r\n\r\nOn Nov 23, 2017, at 10:25 AM, Wes McKinney (JIRA) <jira@apache.org> wrote:\r\n\r\nEXTERNAL\r\n\r\nWes McKinney created ARROW-1850:\r\n-----------------------------------\r\n\r\n            Summary: [C++] Use const void* in Writable::Write instead of const uint8_t*\r\n                Key: ARROW-1850\r\n                URL: https://issues.apache.org/jira/browse/ARROW-1850\r\n            Project: Apache Arrow\r\n         Issue Type: Improvement\r\n         Components: C++\r\n           Reporter: Wes McKinney\r\n            Fix For: 0.8.0\r\n\r\n\r\nI noticed that {{Writable}} is also misspelled. This would spare the user many usages of {{reinterpret_cast<const uint8_t*>(...)}}, and also will not cause any explicit API breakage (except where users have overridden the virtual function)\r\n\r\n\r\n\r\n--\r\nThis message was sent by Atlassian JIRA\r\n(v6.4.14#64029)\r\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=Brian.Bowman%40sas.com",
                        "name": "Brian.Bowman@sas.com",
                        "key": "brian.bowman@sas.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Brian Bowman",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-27T14:45:14.160+0000",
                    "updated": "2017-11-27T14:45:14.160+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13120503/comment/16267034",
                    "id": "16267034",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 1363\n[https://github.com/apache/arrow/pull/1363]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-11-27T16:46:01.838+0000",
                    "updated": "2017-11-27T16:46:01.838+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13120503/comment/16267035",
                    "id": "16267035",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm closed pull request #1363: ARROW-1850: [C++] Use void* / const void* for buffers in file APIs\nURL: https://github.com/apache/arrow/pull/1363\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/c_glib/arrow-glib/input-stream.cpp b/c_glib/arrow-glib/input-stream.cpp\nindex a7a894b9d..94422241b 100644\n--- a/c_glib/arrow-glib/input-stream.cpp\n+++ b/c_glib/arrow-glib/input-stream.cpp\n@@ -420,7 +420,7 @@ namespace garrow {\n \n     arrow::Status Read(int64_t n_bytes,\n                        int64_t *n_read_bytes,\n-                       uint8_t *out) override {\n+                       void *out) override {\n       GError *error = NULL;\n       *n_read_bytes = g_input_stream_read(input_stream_,\n                                           out,\n@@ -437,7 +437,7 @@ namespace garrow {\n     }\n \n     arrow::Status ReadAt(int64_t position, int64_t n_bytes,\n-\t\t\t int64_t *n_read_bytes, uint8_t* out) override {\n+\t\t\t int64_t *n_read_bytes, void* out) override {\n \treturn arrow::io::RandomAccessFile::ReadAt(\n \t    position, n_bytes, n_read_bytes, out);\n     }\ndiff --git a/c_glib/arrow-glib/output-stream.cpp b/c_glib/arrow-glib/output-stream.cpp\nindex 739992fb6..9939f4f08 100644\n--- a/c_glib/arrow-glib/output-stream.cpp\n+++ b/c_glib/arrow-glib/output-stream.cpp\n@@ -76,7 +76,7 @@ garrow_output_stream_file_interface_init(GArrowFileInterface *iface)\n   iface->get_raw = garrow_output_stream_get_raw_file_interface;\n }\n \n-static std::shared_ptr<arrow::io::Writeable>\n+static std::shared_ptr<arrow::io::Writable>\n garrow_output_stream_get_raw_writeable_interface(GArrowWriteable *writeable)\n {\n   auto output_stream = GARROW_OUTPUT_STREAM(writeable);\n@@ -325,7 +325,7 @@ namespace garrow {\n       return arrow::Status::OK();\n     }\n \n-    arrow::Status Write(const uint8_t *data,\n+    arrow::Status Write(const void *data,\n                         int64_t n_bytes) override {\n       GError *error = NULL;\n       gsize n_written_bytes;\ndiff --git a/c_glib/arrow-glib/writeable.cpp b/c_glib/arrow-glib/writeable.cpp\nindex eb6adfee8..a16e43ab1 100644\n--- a/c_glib/arrow-glib/writeable.cpp\n+++ b/c_glib/arrow-glib/writeable.cpp\n@@ -88,7 +88,7 @@ garrow_writeable_flush(GArrowWriteable *writeable,\n \n G_END_DECLS\n \n-std::shared_ptr<arrow::io::Writeable>\n+std::shared_ptr<arrow::io::Writable>\n garrow_writeable_get_raw(GArrowWriteable *writeable)\n {\n   auto *iface = GARROW_WRITEABLE_GET_IFACE(writeable);\ndiff --git a/c_glib/arrow-glib/writeable.hpp b/c_glib/arrow-glib/writeable.hpp\nindex 2b398f8b5..806d36fc0 100644\n--- a/c_glib/arrow-glib/writeable.hpp\n+++ b/c_glib/arrow-glib/writeable.hpp\n@@ -26,13 +26,13 @@\n /**\n  * GArrowWriteableInterface:\n  *\n- * It wraps `arrow::io::Writeable`.\n+ * It wraps `arrow::io::Writable`.\n  */\n struct _GArrowWriteableInterface\n {\n   GTypeInterface parent_iface;\n \n-  std::shared_ptr<arrow::io::Writeable> (*get_raw)(GArrowWriteable *file);\n+  std::shared_ptr<arrow::io::Writable> (*get_raw)(GArrowWriteable *file);\n };\n \n-std::shared_ptr<arrow::io::Writeable> garrow_writeable_get_raw(GArrowWriteable *writeable);\n+std::shared_ptr<arrow::io::Writable> garrow_writeable_get_raw(GArrowWriteable *writeable);\ndiff --git a/cpp/src/arrow/gpu/CMakeLists.txt b/cpp/src/arrow/gpu/CMakeLists.txt\nindex 3f3069b91..3ddf2c797 100644\n--- a/cpp/src/arrow/gpu/CMakeLists.txt\n+++ b/cpp/src/arrow/gpu/CMakeLists.txt\n@@ -54,7 +54,7 @@ configure_file(cuda_version.h.in\n   @ONLY)\n \n install(FILES\n-  \"${CMAKE_CURRENT_SOURCE_DIR}/cuda_version.h\"\n+  \"${CMAKE_CURRENT_BINARY_DIR}/cuda_version.h\"\n   DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}/arrow/gpu\")\n \n install(FILES\ndiff --git a/cpp/src/arrow/gpu/cuda_context.cc b/cpp/src/arrow/gpu/cuda_context.cc\nindex fff8ece6c..2f5ccb0a9 100644\n--- a/cpp/src/arrow/gpu/cuda_context.cc\n+++ b/cpp/src/arrow/gpu/cuda_context.cc\n@@ -69,28 +69,27 @@ class CudaContext::CudaContextImpl {\n     return Status::OK();\n   }\n \n-  Status CopyHostToDevice(uint8_t* dst, const uint8_t* src, int64_t nbytes) {\n+  Status CopyHostToDevice(void* dst, const void* src, int64_t nbytes) {\n     CU_RETURN_NOT_OK(cuCtxSetCurrent(context_));\n-    CU_RETURN_NOT_OK(cuMemcpyHtoD(reinterpret_cast<CUdeviceptr>(dst),\n-                                  reinterpret_cast<const void*>(src),\n+    CU_RETURN_NOT_OK(cuMemcpyHtoD(reinterpret_cast<CUdeviceptr>(dst), src,\n                                   static_cast<size_t>(nbytes)));\n     return Status::OK();\n   }\n \n-  Status CopyDeviceToHost(uint8_t* dst, const uint8_t* src, int64_t nbytes) {\n+  Status CopyDeviceToHost(void* dst, const void* src, int64_t nbytes) {\n     CU_RETURN_NOT_OK(cuCtxSetCurrent(context_));\n     CU_RETURN_NOT_OK(cuMemcpyDtoH(dst, reinterpret_cast<const CUdeviceptr>(src),\n                                   static_cast<size_t>(nbytes)));\n     return Status::OK();\n   }\n \n-  Status Free(uint8_t* device_ptr, int64_t nbytes) {\n+  Status Free(void* device_ptr, int64_t nbytes) {\n     CU_RETURN_NOT_OK(cuMemFree(reinterpret_cast<CUdeviceptr>(device_ptr)));\n     bytes_allocated_ -= nbytes;\n     return Status::OK();\n   }\n \n-  Status ExportIpcBuffer(uint8_t* data, std::unique_ptr<CudaIpcMemHandle>* handle) {\n+  Status ExportIpcBuffer(void* data, std::unique_ptr<CudaIpcMemHandle>* handle) {\n     CU_RETURN_NOT_OK(cuCtxSetCurrent(context_));\n     CUipcMemHandle cu_handle;\n     CU_RETURN_NOT_OK(cuIpcGetMemHandle(&cu_handle, reinterpret_cast<CUdeviceptr>(data)));\n@@ -145,7 +144,7 @@ class CudaDeviceManager::CudaDeviceManagerImpl {\n     return Status::OK();\n   }\n \n-  Status FreeHost(uint8_t* data, int64_t nbytes) {\n+  Status FreeHost(void* data, int64_t nbytes) {\n     CU_RETURN_NOT_OK(cuMemFreeHost(data));\n     host_bytes_allocated_ -= nbytes;\n     return Status::OK();\n@@ -221,7 +220,7 @@ Status CudaDeviceManager::AllocateHost(int64_t nbytes,\n   return Status::OK();\n }\n \n-Status CudaDeviceManager::FreeHost(uint8_t* data, int64_t nbytes) {\n+Status CudaDeviceManager::FreeHost(void* data, int64_t nbytes) {\n   return impl_->FreeHost(data, nbytes);\n }\n \n@@ -241,22 +240,22 @@ Status CudaContext::Allocate(int64_t nbytes, std::shared_ptr<CudaBuffer>* out) {\n   return Status::OK();\n }\n \n-Status CudaContext::ExportIpcBuffer(uint8_t* data,\n+Status CudaContext::ExportIpcBuffer(void* data,\n                                     std::unique_ptr<CudaIpcMemHandle>* handle) {\n   return impl_->ExportIpcBuffer(data, handle);\n }\n \n-Status CudaContext::CopyHostToDevice(uint8_t* dst, const uint8_t* src, int64_t nbytes) {\n+Status CudaContext::CopyHostToDevice(void* dst, const void* src, int64_t nbytes) {\n   return impl_->CopyHostToDevice(dst, src, nbytes);\n }\n \n-Status CudaContext::CopyDeviceToHost(uint8_t* dst, const uint8_t* src, int64_t nbytes) {\n+Status CudaContext::CopyDeviceToHost(void* dst, const void* src, int64_t nbytes) {\n   return impl_->CopyDeviceToHost(dst, src, nbytes);\n }\n \n Status CudaContext::Close() { return impl_->Close(); }\n \n-Status CudaContext::Free(uint8_t* device_ptr, int64_t nbytes) {\n+Status CudaContext::Free(void* device_ptr, int64_t nbytes) {\n   return impl_->Free(device_ptr, nbytes);\n }\n \ndiff --git a/cpp/src/arrow/gpu/cuda_context.h b/cpp/src/arrow/gpu/cuda_context.h\nindex 647105961..6fc2e0d08 100644\n--- a/cpp/src/arrow/gpu/cuda_context.h\n+++ b/cpp/src/arrow/gpu/cuda_context.h\n@@ -46,7 +46,7 @@ class ARROW_EXPORT CudaDeviceManager {\n \n   Status AllocateHost(int64_t nbytes, std::shared_ptr<CudaHostBuffer>* buffer);\n \n-  Status FreeHost(uint8_t* data, int64_t nbytes);\n+  Status FreeHost(void* data, int64_t nbytes);\n \n   int num_devices() const;\n \n@@ -88,10 +88,10 @@ class ARROW_EXPORT CudaContext : public std::enable_shared_from_this<CudaContext\n  private:\n   CudaContext();\n \n-  Status ExportIpcBuffer(uint8_t* data, std::unique_ptr<CudaIpcMemHandle>* handle);\n-  Status CopyHostToDevice(uint8_t* dst, const uint8_t* src, int64_t nbytes);\n-  Status CopyDeviceToHost(uint8_t* dst, const uint8_t* src, int64_t nbytes);\n-  Status Free(uint8_t* device_ptr, int64_t nbytes);\n+  Status ExportIpcBuffer(void* data, std::unique_ptr<CudaIpcMemHandle>* handle);\n+  Status CopyHostToDevice(void* dst, const void* src, int64_t nbytes);\n+  Status CopyDeviceToHost(void* dst, const void* src, int64_t nbytes);\n+  Status Free(void* device_ptr, int64_t nbytes);\n \n   class CudaContextImpl;\n   std::unique_ptr<CudaContextImpl> impl_;\ndiff --git a/cpp/src/arrow/gpu/cuda_memory.cc b/cpp/src/arrow/gpu/cuda_memory.cc\nindex 949c1d7a4..cbf044121 100644\n--- a/cpp/src/arrow/gpu/cuda_memory.cc\n+++ b/cpp/src/arrow/gpu/cuda_memory.cc\n@@ -101,11 +101,11 @@ CudaBuffer::CudaBuffer(const std::shared_ptr<CudaBuffer>& parent, const int64_t\n       is_ipc_(false) {}\n \n Status CudaBuffer::CopyToHost(const int64_t position, const int64_t nbytes,\n-                              uint8_t* out) const {\n+                              void* out) const {\n   return context_->CopyDeviceToHost(out, data_ + position, nbytes);\n }\n \n-Status CudaBuffer::CopyFromHost(const int64_t position, const uint8_t* data,\n+Status CudaBuffer::CopyFromHost(const int64_t position, const void* data,\n                                 int64_t nbytes) {\n   DCHECK_LE(nbytes, size_ - position) << \"Copy would overflow buffer\";\n   return context_->CopyHostToDevice(mutable_data_ + position, data, nbytes);\n@@ -134,7 +134,7 @@ CudaBufferReader::CudaBufferReader(const std::shared_ptr<CudaBuffer>& buffer)\n \n CudaBufferReader::~CudaBufferReader() {}\n \n-Status CudaBufferReader::Read(int64_t nbytes, int64_t* bytes_read, uint8_t* buffer) {\n+Status CudaBufferReader::Read(int64_t nbytes, int64_t* bytes_read, void* buffer) {\n   nbytes = std::min(nbytes, size_ - position_);\n   *bytes_read = nbytes;\n   RETURN_NOT_OK(context_->CopyDeviceToHost(buffer, data_ + position_, nbytes));\n@@ -190,7 +190,7 @@ class CudaBufferWriter::CudaBufferWriterImpl {\n     return Status::OK();\n   }\n \n-  Status Write(const uint8_t* data, int64_t nbytes) {\n+  Status Write(const void* data, int64_t nbytes) {\n     if (nbytes == 0) {\n       return Status::OK();\n     }\n@@ -214,7 +214,7 @@ class CudaBufferWriter::CudaBufferWriterImpl {\n     return Status::OK();\n   }\n \n-  Status WriteAt(int64_t position, const uint8_t* data, int64_t nbytes) {\n+  Status WriteAt(int64_t position, const void* data, int64_t nbytes) {\n     std::lock_guard<std::mutex> guard(lock_);\n     RETURN_NOT_OK(Seek(position));\n     return Write(data, nbytes);\n@@ -269,11 +269,11 @@ Status CudaBufferWriter::Seek(int64_t position) {\n \n Status CudaBufferWriter::Tell(int64_t* position) const { return impl_->Tell(position); }\n \n-Status CudaBufferWriter::Write(const uint8_t* data, int64_t nbytes) {\n+Status CudaBufferWriter::Write(const void* data, int64_t nbytes) {\n   return impl_->Write(data, nbytes);\n }\n \n-Status CudaBufferWriter::WriteAt(int64_t position, const uint8_t* data, int64_t nbytes) {\n+Status CudaBufferWriter::WriteAt(int64_t position, const void* data, int64_t nbytes) {\n   return impl_->WriteAt(position, data, nbytes);\n }\n \ndiff --git a/cpp/src/arrow/gpu/cuda_memory.h b/cpp/src/arrow/gpu/cuda_memory.h\nindex 9ebd2ccf0..9376b4b3f 100644\n--- a/cpp/src/arrow/gpu/cuda_memory.h\n+++ b/cpp/src/arrow/gpu/cuda_memory.h\n@@ -49,14 +49,14 @@ class ARROW_EXPORT CudaBuffer : public Buffer {\n   /// \\brief Copy memory from GPU device to CPU host\n   /// \\param[out] out a pre-allocated output buffer\n   /// \\return Status\n-  Status CopyToHost(const int64_t position, const int64_t nbytes, uint8_t* out) const;\n+  Status CopyToHost(const int64_t position, const int64_t nbytes, void* out) const;\n \n   /// \\brief Copy memory to device at position\n   /// \\param[in] position start position to copy bytes\n   /// \\param[in] data the host data to copy\n   /// \\param[in] nbytes number of bytes to copy\n   /// \\return Status\n-  Status CopyFromHost(const int64_t position, const uint8_t* data, int64_t nbytes);\n+  Status CopyFromHost(const int64_t position, const void* data, int64_t nbytes);\n \n   /// \\brief Expose this device buffer as IPC memory which can be used in other processes\n   /// \\param[out] handle the exported IPC handle\n@@ -130,7 +130,7 @@ class ARROW_EXPORT CudaBufferReader : public io::BufferReader {\n   /// \\param[in] nbytes number of bytes to read\n   /// \\param[out] bytes_read actual number of bytes read\n   /// \\param[out] buffer pre-allocated memory to write into\n-  Status Read(int64_t nbytes, int64_t* bytes_read, uint8_t* buffer) override;\n+  Status Read(int64_t nbytes, int64_t* bytes_read, void* buffer) override;\n \n   /// \\brief Zero-copy read from device memory\n   /// \\param[in] nbytes number of bytes to read\n@@ -158,9 +158,9 @@ class ARROW_EXPORT CudaBufferWriter : public io::WriteableFile {\n \n   Status Seek(int64_t position) override;\n \n-  Status Write(const uint8_t* data, int64_t nbytes) override;\n+  Status Write(const void* data, int64_t nbytes) override;\n \n-  Status WriteAt(int64_t position, const uint8_t* data, int64_t nbytes) override;\n+  Status WriteAt(int64_t position, const void* data, int64_t nbytes) override;\n \n   Status Tell(int64_t* position) const override;\n \ndiff --git a/cpp/src/arrow/io/file.cc b/cpp/src/arrow/io/file.cc\nindex 1ec5e23e5..65a302c8b 100644\n--- a/cpp/src/arrow/io/file.cc\n+++ b/cpp/src/arrow/io/file.cc\n@@ -394,11 +394,11 @@ class OSFile {\n     return Status::OK();\n   }\n \n-  Status Read(int64_t nbytes, int64_t* bytes_read, uint8_t* out) {\n-    return FileRead(fd_, out, nbytes, bytes_read);\n+  Status Read(int64_t nbytes, int64_t* bytes_read, void* out) {\n+    return FileRead(fd_, reinterpret_cast<uint8_t*>(out), nbytes, bytes_read);\n   }\n \n-  Status ReadAt(int64_t position, int64_t nbytes, int64_t* bytes_read, uint8_t* out) {\n+  Status ReadAt(int64_t position, int64_t nbytes, int64_t* bytes_read, void* out) {\n     std::lock_guard<std::mutex> guard(lock_);\n     RETURN_NOT_OK(Seek(position));\n     return Read(nbytes, bytes_read, out);\n@@ -413,12 +413,12 @@ class OSFile {\n \n   Status Tell(int64_t* pos) const { return FileTell(fd_, pos); }\n \n-  Status Write(const uint8_t* data, int64_t length) {\n+  Status Write(const void* data, int64_t length) {\n     std::lock_guard<std::mutex> guard(lock_);\n     if (length < 0) {\n       return Status::IOError(\"Length must be non-negative\");\n     }\n-    return FileWrite(fd_, data, length);\n+    return FileWrite(fd_, reinterpret_cast<const uint8_t*>(data), length);\n   }\n \n   int fd() const { return fd_; }\n@@ -504,13 +504,13 @@ Status ReadableFile::Close() { return impl_->Close(); }\n \n Status ReadableFile::Tell(int64_t* pos) const { return impl_->Tell(pos); }\n \n-Status ReadableFile::Read(int64_t nbytes, int64_t* bytes_read, uint8_t* out) {\n+Status ReadableFile::Read(int64_t nbytes, int64_t* bytes_read, void* out) {\n   std::lock_guard<std::mutex> guard(impl_->lock());\n   return impl_->Read(nbytes, bytes_read, out);\n }\n \n Status ReadableFile::ReadAt(int64_t position, int64_t nbytes, int64_t* bytes_read,\n-                            uint8_t* out) {\n+                            void* out) {\n   return impl_->ReadAt(position, nbytes, bytes_read, out);\n }\n \n@@ -570,7 +570,7 @@ Status FileOutputStream::Close() { return impl_->Close(); }\n \n Status FileOutputStream::Tell(int64_t* pos) const { return impl_->Tell(pos); }\n \n-Status FileOutputStream::Write(const uint8_t* data, int64_t length) {\n+Status FileOutputStream::Write(const void* data, int64_t length) {\n   return impl_->Write(data, length);\n }\n \n@@ -710,7 +710,7 @@ Status MemoryMappedFile::Close() {\n   return Status::OK();\n }\n \n-Status MemoryMappedFile::Read(int64_t nbytes, int64_t* bytes_read, uint8_t* out) {\n+Status MemoryMappedFile::Read(int64_t nbytes, int64_t* bytes_read, void* out) {\n   nbytes = std::max<int64_t>(\n       0, std::min(nbytes, memory_map_->size() - memory_map_->position()));\n   if (nbytes > 0) {\n@@ -735,7 +735,7 @@ Status MemoryMappedFile::Read(int64_t nbytes, std::shared_ptr<Buffer>* out) {\n }\n \n Status MemoryMappedFile::ReadAt(int64_t position, int64_t nbytes, int64_t* bytes_read,\n-                                uint8_t* out) {\n+                                void* out) {\n   std::lock_guard<std::mutex> guard(memory_map_->lock());\n   RETURN_NOT_OK(Seek(position));\n   return Read(nbytes, bytes_read, out);\n@@ -750,7 +750,7 @@ Status MemoryMappedFile::ReadAt(int64_t position, int64_t nbytes,\n \n bool MemoryMappedFile::supports_zero_copy() const { return true; }\n \n-Status MemoryMappedFile::WriteAt(int64_t position, const uint8_t* data, int64_t nbytes) {\n+Status MemoryMappedFile::WriteAt(int64_t position, const void* data, int64_t nbytes) {\n   std::lock_guard<std::mutex> guard(memory_map_->lock());\n \n   if (!memory_map_->opened() || !memory_map_->writable()) {\n@@ -761,7 +761,7 @@ Status MemoryMappedFile::WriteAt(int64_t position, const uint8_t* data, int64_t\n   return WriteInternal(data, nbytes);\n }\n \n-Status MemoryMappedFile::Write(const uint8_t* data, int64_t nbytes) {\n+Status MemoryMappedFile::Write(const void* data, int64_t nbytes) {\n   std::lock_guard<std::mutex> guard(memory_map_->lock());\n \n   if (!memory_map_->opened() || !memory_map_->writable()) {\n@@ -773,7 +773,7 @@ Status MemoryMappedFile::Write(const uint8_t* data, int64_t nbytes) {\n   return WriteInternal(data, nbytes);\n }\n \n-Status MemoryMappedFile::WriteInternal(const uint8_t* data, int64_t nbytes) {\n+Status MemoryMappedFile::WriteInternal(const void* data, int64_t nbytes) {\n   memcpy(memory_map_->head(), data, static_cast<size_t>(nbytes));\n   memory_map_->advance(nbytes);\n   return Status::OK();\ndiff --git a/cpp/src/arrow/io/file.h b/cpp/src/arrow/io/file.h\nindex 7937fea74..265df4d65 100644\n--- a/cpp/src/arrow/io/file.h\n+++ b/cpp/src/arrow/io/file.h\n@@ -59,7 +59,7 @@ class ARROW_EXPORT FileOutputStream : public OutputStream {\n   Status Tell(int64_t* position) const override;\n \n   // Write bytes to the stream. Thread-safe\n-  Status Write(const uint8_t* data, int64_t nbytes) override;\n+  Status Write(const void* data, int64_t nbytes) override;\n \n   int file_descriptor() const;\n \n@@ -93,12 +93,12 @@ class ARROW_EXPORT ReadableFile : public RandomAccessFile {\n   Status Tell(int64_t* position) const override;\n \n   // Read bytes from the file. Thread-safe\n-  Status Read(int64_t nbytes, int64_t* bytes_read, uint8_t* buffer) override;\n+  Status Read(int64_t nbytes, int64_t* bytes_read, void* buffer) override;\n   Status Read(int64_t nbytes, std::shared_ptr<Buffer>* out) override;\n \n   /// \\brief Thread-safe implementation of ReadAt\n   Status ReadAt(int64_t position, int64_t nbytes, int64_t* bytes_read,\n-                uint8_t* out) override;\n+                void* out) override;\n \n   /// \\brief Thread-safe implementation of ReadAt\n   Status ReadAt(int64_t position, int64_t nbytes, std::shared_ptr<Buffer>* out) override;\n@@ -141,13 +141,13 @@ class ARROW_EXPORT MemoryMappedFile : public ReadWriteFileInterface {\n   Status Seek(int64_t position) override;\n \n   // Required by RandomAccessFile, copies memory into out. Not thread-safe\n-  Status Read(int64_t nbytes, int64_t* bytes_read, uint8_t* out) override;\n+  Status Read(int64_t nbytes, int64_t* bytes_read, void* out) override;\n \n   // Zero copy read. Not thread-safe\n   Status Read(int64_t nbytes, std::shared_ptr<Buffer>* out) override;\n \n   Status ReadAt(int64_t position, int64_t nbytes, int64_t* bytes_read,\n-                uint8_t* out) override;\n+                void* out) override;\n \n   /// Default implementation is thread-safe\n   Status ReadAt(int64_t position, int64_t nbytes, std::shared_ptr<Buffer>* out) override;\n@@ -155,10 +155,10 @@ class ARROW_EXPORT MemoryMappedFile : public ReadWriteFileInterface {\n   bool supports_zero_copy() const override;\n \n   /// Write data at the current position in the file. Thread-safe\n-  Status Write(const uint8_t* data, int64_t nbytes) override;\n+  Status Write(const void* data, int64_t nbytes) override;\n \n   /// Write data at a particular position in the file. Thread-safe\n-  Status WriteAt(int64_t position, const uint8_t* data, int64_t nbytes) override;\n+  Status WriteAt(int64_t position, const void* data, int64_t nbytes) override;\n \n   // @return: the size in bytes of the memory source\n   Status GetSize(int64_t* size) override;\n@@ -168,7 +168,7 @@ class ARROW_EXPORT MemoryMappedFile : public ReadWriteFileInterface {\n  private:\n   MemoryMappedFile();\n \n-  Status WriteInternal(const uint8_t* data, int64_t nbytes);\n+  Status WriteInternal(const void* data, int64_t nbytes);\n \n   class ARROW_NO_EXPORT MemoryMap;\n   std::shared_ptr<MemoryMap> memory_map_;\ndiff --git a/cpp/src/arrow/io/hdfs.cc b/cpp/src/arrow/io/hdfs.cc\nindex 77d1f524a..6e3e4a7a1 100644\n--- a/cpp/src/arrow/io/hdfs.cc\n+++ b/cpp/src/arrow/io/hdfs.cc\n@@ -119,7 +119,7 @@ class HdfsReadableFile::HdfsReadableFileImpl : public HdfsAnyFileImpl {\n     return Status::OK();\n   }\n \n-  Status ReadAt(int64_t position, int64_t nbytes, int64_t* bytes_read, uint8_t* buffer) {\n+  Status ReadAt(int64_t position, int64_t nbytes, int64_t* bytes_read, void* buffer) {\n     tSize ret;\n     if (driver_->HasPread()) {\n       ret = driver_->Pread(fs_, file_, static_cast<tOffset>(position),\n@@ -149,11 +149,11 @@ class HdfsReadableFile::HdfsReadableFileImpl : public HdfsAnyFileImpl {\n     return Status::OK();\n   }\n \n-  Status Read(int64_t nbytes, int64_t* bytes_read, uint8_t* buffer) {\n+  Status Read(int64_t nbytes, int64_t* bytes_read, void* buffer) {\n     int64_t total_bytes = 0;\n     while (total_bytes < nbytes) {\n       tSize ret = driver_->Read(\n-          fs_, file_, reinterpret_cast<void*>(buffer + total_bytes),\n+          fs_, file_, reinterpret_cast<uint8_t*>(buffer) + total_bytes,\n           static_cast<tSize>(std::min<int64_t>(buffer_size_, nbytes - total_bytes)));\n       RETURN_NOT_OK(CheckReadResult(ret));\n       total_bytes += ret;\n@@ -212,7 +212,7 @@ HdfsReadableFile::~HdfsReadableFile() { DCHECK(impl_->Close().ok()); }\n Status HdfsReadableFile::Close() { return impl_->Close(); }\n \n Status HdfsReadableFile::ReadAt(int64_t position, int64_t nbytes, int64_t* bytes_read,\n-                                uint8_t* buffer) {\n+                                void* buffer) {\n   return impl_->ReadAt(position, nbytes, bytes_read, buffer);\n }\n \n@@ -223,7 +223,7 @@ Status HdfsReadableFile::ReadAt(int64_t position, int64_t nbytes,\n \n bool HdfsReadableFile::supports_zero_copy() const { return false; }\n \n-Status HdfsReadableFile::Read(int64_t nbytes, int64_t* bytes_read, uint8_t* buffer) {\n+Status HdfsReadableFile::Read(int64_t nbytes, int64_t* bytes_read, void* buffer) {\n   return impl_->Read(nbytes, bytes_read, buffer);\n }\n \n@@ -261,7 +261,7 @@ class HdfsOutputStream::HdfsOutputStreamImpl : public HdfsAnyFileImpl {\n     return Status::OK();\n   }\n \n-  Status Write(const uint8_t* buffer, int64_t nbytes, int64_t* bytes_written) {\n+  Status Write(const void* buffer, int64_t nbytes, int64_t* bytes_written) {\n     std::lock_guard<std::mutex> guard(lock_);\n     tSize ret = driver_->Write(fs_, file_, reinterpret_cast<const void*>(buffer),\n                                static_cast<tSize>(nbytes));\n@@ -277,12 +277,11 @@ HdfsOutputStream::~HdfsOutputStream() { DCHECK(impl_->Close().ok()); }\n \n Status HdfsOutputStream::Close() { return impl_->Close(); }\n \n-Status HdfsOutputStream::Write(const uint8_t* buffer, int64_t nbytes,\n-                               int64_t* bytes_read) {\n+Status HdfsOutputStream::Write(const void* buffer, int64_t nbytes, int64_t* bytes_read) {\n   return impl_->Write(buffer, nbytes, bytes_read);\n }\n \n-Status HdfsOutputStream::Write(const uint8_t* buffer, int64_t nbytes) {\n+Status HdfsOutputStream::Write(const void* buffer, int64_t nbytes) {\n   int64_t bytes_written_dummy = 0;\n   return Write(buffer, nbytes, &bytes_written_dummy);\n }\ndiff --git a/cpp/src/arrow/io/hdfs.h b/cpp/src/arrow/io/hdfs.h\nindex 0708b11cc..062473b20 100644\n--- a/cpp/src/arrow/io/hdfs.h\n+++ b/cpp/src/arrow/io/hdfs.h\n@@ -182,12 +182,12 @@ class ARROW_EXPORT HdfsReadableFile : public RandomAccessFile {\n \n   // NOTE: If you wish to read a particular range of a file in a multithreaded\n   // context, you may prefer to use ReadAt to avoid locking issues\n-  Status Read(int64_t nbytes, int64_t* bytes_read, uint8_t* buffer) override;\n+  Status Read(int64_t nbytes, int64_t* bytes_read, void* buffer) override;\n \n   Status Read(int64_t nbytes, std::shared_ptr<Buffer>* out) override;\n \n   Status ReadAt(int64_t position, int64_t nbytes, int64_t* bytes_read,\n-                uint8_t* buffer) override;\n+                void* buffer) override;\n \n   Status ReadAt(int64_t position, int64_t nbytes, std::shared_ptr<Buffer>* out) override;\n \n@@ -217,9 +217,9 @@ class ARROW_EXPORT HdfsOutputStream : public OutputStream {\n \n   Status Close() override;\n \n-  Status Write(const uint8_t* buffer, int64_t nbytes) override;\n+  Status Write(const void* buffer, int64_t nbytes) override;\n \n-  Status Write(const uint8_t* buffer, int64_t nbytes, int64_t* bytes_written);\n+  Status Write(const void* buffer, int64_t nbytes, int64_t* bytes_written);\n \n   Status Flush() override;\n \ndiff --git a/cpp/src/arrow/io/interfaces.cc b/cpp/src/arrow/io/interfaces.cc\nindex 582cc2026..04560209a 100644\n--- a/cpp/src/arrow/io/interfaces.cc\n+++ b/cpp/src/arrow/io/interfaces.cc\n@@ -38,7 +38,7 @@ RandomAccessFile::RandomAccessFile()\n     : impl_(new RandomAccessFile::RandomAccessFileImpl()) {}\n \n Status RandomAccessFile::ReadAt(int64_t position, int64_t nbytes, int64_t* bytes_read,\n-                                uint8_t* out) {\n+                                void* out) {\n   std::lock_guard<std::mutex> lock(impl_->lock_);\n   RETURN_NOT_OK(Seek(position));\n   return Read(nbytes, bytes_read, out);\n@@ -51,12 +51,11 @@ Status RandomAccessFile::ReadAt(int64_t position, int64_t nbytes,\n   return Read(nbytes, out);\n }\n \n-Status Writeable::Write(const std::string& data) {\n-  return Write(reinterpret_cast<const uint8_t*>(data.c_str()),\n-               static_cast<int64_t>(data.size()));\n+Status Writable::Write(const std::string& data) {\n+  return Write(data.c_str(), static_cast<int64_t>(data.size()));\n }\n \n-Status Writeable::Flush() { return Status::OK(); }\n+Status Writable::Flush() { return Status::OK(); }\n \n }  // namespace io\n }  // namespace arrow\ndiff --git a/cpp/src/arrow/io/interfaces.h b/cpp/src/arrow/io/interfaces.h\nindex 82af875e7..09536a44e 100644\n--- a/cpp/src/arrow/io/interfaces.h\n+++ b/cpp/src/arrow/io/interfaces.h\n@@ -86,11 +86,11 @@ class ARROW_EXPORT Seekable {\n   virtual Status Seek(int64_t position) = 0;\n };\n \n-class ARROW_EXPORT Writeable {\n+class ARROW_EXPORT Writable {\n  public:\n-  virtual ~Writeable() = default;\n+  virtual ~Writable() = default;\n \n-  virtual Status Write(const uint8_t* data, int64_t nbytes) = 0;\n+  virtual Status Write(const void* data, int64_t nbytes) = 0;\n \n   /// \\brief Flush buffered bytes, if any\n   virtual Status Flush();\n@@ -102,13 +102,13 @@ class ARROW_EXPORT Readable {\n  public:\n   virtual ~Readable() = default;\n \n-  virtual Status Read(int64_t nbytes, int64_t* bytes_read, uint8_t* out) = 0;\n+  virtual Status Read(int64_t nbytes, int64_t* bytes_read, void* out) = 0;\n \n   // Does not copy if not necessary\n   virtual Status Read(int64_t nbytes, std::shared_ptr<Buffer>* out) = 0;\n };\n \n-class ARROW_EXPORT OutputStream : virtual public FileInterface, public Writeable {\n+class ARROW_EXPORT OutputStream : virtual public FileInterface, public Writable {\n  protected:\n   OutputStream() = default;\n };\n@@ -138,7 +138,7 @@ class ARROW_EXPORT RandomAccessFile : public InputStream, public Seekable {\n   /// \\param[out] out The buffer to read bytes into\n   /// \\return Status\n   virtual Status ReadAt(int64_t position, int64_t nbytes, int64_t* bytes_read,\n-                        uint8_t* out) = 0;\n+                        void* out) = 0;\n \n   /// \\brief Read nbytes at position, provide default implementations using Read(...), but\n   /// can be overridden. Default implementation is thread-safe.\n@@ -162,7 +162,7 @@ class ARROW_EXPORT RandomAccessFile : public InputStream, public Seekable {\n \n class ARROW_EXPORT WriteableFile : public OutputStream, public Seekable {\n  public:\n-  virtual Status WriteAt(int64_t position, const uint8_t* data, int64_t nbytes) = 0;\n+  virtual Status WriteAt(int64_t position, const void* data, int64_t nbytes) = 0;\n \n  protected:\n   WriteableFile() = default;\ndiff --git a/cpp/src/arrow/io/io-file-test.cc b/cpp/src/arrow/io/io-file-test.cc\nindex ee3beabd9..e70431e69 100644\n--- a/cpp/src/arrow/io/io-file-test.cc\n+++ b/cpp/src/arrow/io/io-file-test.cc\n@@ -135,7 +135,7 @@ TEST_F(TestFileOutputStream, Close) {\n   OpenFile();\n \n   const char* data = \"testdata\";\n-  ASSERT_OK(file_->Write(reinterpret_cast<const uint8_t*>(data), strlen(data)));\n+  ASSERT_OK(file_->Write(data, strlen(data)));\n \n   int fd = file_->file_descriptor();\n   ASSERT_OK(file_->Close());\n@@ -158,7 +158,7 @@ TEST_F(TestFileOutputStream, InvalidWrites) {\n \n   const char* data = \"\";\n \n-  ASSERT_RAISES(IOError, file_->Write(reinterpret_cast<const uint8_t*>(data), -1));\n+  ASSERT_RAISES(IOError, file_->Write(data, -1));\n }\n \n TEST_F(TestFileOutputStream, Tell) {\n@@ -170,7 +170,7 @@ TEST_F(TestFileOutputStream, Tell) {\n   ASSERT_EQ(0, position);\n \n   const char* data = \"testdata\";\n-  ASSERT_OK(file_->Write(reinterpret_cast<const uint8_t*>(data), 8));\n+  ASSERT_OK(file_->Write(data, 8));\n   ASSERT_OK(file_->Tell(&position));\n   ASSERT_EQ(8, position);\n }\n@@ -179,7 +179,7 @@ TEST_F(TestFileOutputStream, TruncatesNewFile) {\n   ASSERT_OK(FileOutputStream::Open(path_, &file_));\n \n   const char* data = \"testdata\";\n-  ASSERT_OK(file_->Write(reinterpret_cast<const uint8_t*>(data), strlen(data)));\n+  ASSERT_OK(file_->Write(data, strlen(data)));\n   ASSERT_OK(file_->Close());\n \n   ASSERT_OK(FileOutputStream::Open(path_, &file_));\n@@ -583,8 +583,7 @@ TEST_F(TestMemoryMappedFile, ThreadSafety) {\n \n   std::shared_ptr<MemoryMappedFile> file;\n   ASSERT_OK(MemoryMappedFile::Open(path, FileMode::READWRITE, &file));\n-  ASSERT_OK(file->Write(reinterpret_cast<const uint8_t*>(data.c_str()),\n-                        static_cast<int64_t>(data.size())));\n+  ASSERT_OK(file->Write(data.c_str(), static_cast<int64_t>(data.size())));\n \n   std::atomic<int> correct_count(0);\n   constexpr int niter = 10000;\ndiff --git a/cpp/src/arrow/io/io-memory-test.cc b/cpp/src/arrow/io/io-memory-test.cc\nindex 117972f1c..8c2e8c3b0 100644\n--- a/cpp/src/arrow/io/io-memory-test.cc\n+++ b/cpp/src/arrow/io/io-memory-test.cc\n@@ -93,7 +93,7 @@ TEST(TestFixedSizeBufferWriter, Basics) {\n \n   std::string data = \"data123456\";\n   auto nbytes = static_cast<int64_t>(data.size());\n-  ASSERT_OK(writer.Write(reinterpret_cast<const uint8_t*>(data.c_str()), nbytes));\n+  ASSERT_OK(writer.Write(data.c_str(), nbytes));\n \n   ASSERT_OK(writer.Tell(&position));\n   ASSERT_EQ(nbytes, position);\ndiff --git a/cpp/src/arrow/io/memory.cc b/cpp/src/arrow/io/memory.cc\nindex d9c84b495..74ec85c0e 100644\n--- a/cpp/src/arrow/io/memory.cc\n+++ b/cpp/src/arrow/io/memory.cc\n@@ -79,7 +79,7 @@ Status BufferOutputStream::Tell(int64_t* position) const {\n   return Status::OK();\n }\n \n-Status BufferOutputStream::Write(const uint8_t* data, int64_t nbytes) {\n+Status BufferOutputStream::Write(const void* data, int64_t nbytes) {\n   if (ARROW_PREDICT_FALSE(!is_open_)) {\n     return Status::IOError(\"OutputStream is closed\");\n   }\n@@ -116,7 +116,7 @@ Status MockOutputStream::Tell(int64_t* position) const {\n   return Status::OK();\n }\n \n-Status MockOutputStream::Write(const uint8_t* data, int64_t nbytes) {\n+Status MockOutputStream::Write(const void* data, int64_t nbytes) {\n   extent_bytes_written_ += nbytes;\n   return Status::OK();\n }\n@@ -162,9 +162,10 @@ class FixedSizeBufferWriter::FixedSizeBufferWriterImpl {\n     return Status::OK();\n   }\n \n-  Status Write(const uint8_t* data, int64_t nbytes) {\n+  Status Write(const void* data, int64_t nbytes) {\n     if (nbytes > memcopy_threshold_ && memcopy_num_threads_ > 1) {\n-      internal::parallel_memcopy(mutable_data_ + position_, data, nbytes,\n+      internal::parallel_memcopy(mutable_data_ + position_,\n+                                 reinterpret_cast<const uint8_t*>(data), nbytes,\n                                  memcopy_blocksize_, memcopy_num_threads_);\n     } else {\n       memcpy(mutable_data_ + position_, data, nbytes);\n@@ -173,7 +174,7 @@ class FixedSizeBufferWriter::FixedSizeBufferWriterImpl {\n     return Status::OK();\n   }\n \n-  Status WriteAt(int64_t position, const uint8_t* data, int64_t nbytes) {\n+  Status WriteAt(int64_t position, const void* data, int64_t nbytes) {\n     std::lock_guard<std::mutex> guard(lock_);\n     RETURN_NOT_OK(Seek(position));\n     return Write(data, nbytes);\n@@ -210,11 +211,11 @@ Status FixedSizeBufferWriter::Tell(int64_t* position) const {\n   return impl_->Tell(position);\n }\n \n-Status FixedSizeBufferWriter::Write(const uint8_t* data, int64_t nbytes) {\n+Status FixedSizeBufferWriter::Write(const void* data, int64_t nbytes) {\n   return impl_->Write(data, nbytes);\n }\n \n-Status FixedSizeBufferWriter::WriteAt(int64_t position, const uint8_t* data,\n+Status FixedSizeBufferWriter::WriteAt(int64_t position, const void* data,\n                                       int64_t nbytes) {\n   return impl_->WriteAt(position, data, nbytes);\n }\n@@ -252,7 +253,7 @@ Status BufferReader::Tell(int64_t* position) const {\n \n bool BufferReader::supports_zero_copy() const { return true; }\n \n-Status BufferReader::Read(int64_t nbytes, int64_t* bytes_read, uint8_t* buffer) {\n+Status BufferReader::Read(int64_t nbytes, int64_t* bytes_read, void* buffer) {\n   memcpy(buffer, data_ + position_, nbytes);\n   *bytes_read = std::min(nbytes, size_ - position_);\n   position_ += *bytes_read;\n@@ -273,7 +274,7 @@ Status BufferReader::Read(int64_t nbytes, std::shared_ptr<Buffer>* out) {\n }\n \n Status BufferReader::ReadAt(int64_t position, int64_t nbytes, int64_t* bytes_read,\n-                            uint8_t* out) {\n+                            void* out) {\n   return RandomAccessFile::ReadAt(position, nbytes, bytes_read, out);\n }\n \ndiff --git a/cpp/src/arrow/io/memory.h b/cpp/src/arrow/io/memory.h\nindex 3aec91f72..8dfd582f9 100644\n--- a/cpp/src/arrow/io/memory.h\n+++ b/cpp/src/arrow/io/memory.h\n@@ -48,7 +48,7 @@ class ARROW_EXPORT BufferOutputStream : public OutputStream {\n   // Implement the OutputStream interface\n   Status Close() override;\n   Status Tell(int64_t* position) const override;\n-  Status Write(const uint8_t* data, int64_t nbytes) override;\n+  Status Write(const void* data, int64_t nbytes) override;\n \n   /// Close the stream and return the buffer\n   Status Finish(std::shared_ptr<Buffer>* result);\n@@ -72,7 +72,7 @@ class ARROW_EXPORT MockOutputStream : public OutputStream {\n   // Implement the OutputStream interface\n   Status Close() override;\n   Status Tell(int64_t* position) const override;\n-  Status Write(const uint8_t* data, int64_t nbytes) override;\n+  Status Write(const void* data, int64_t nbytes) override;\n \n   int64_t GetExtentBytesWritten() const { return extent_bytes_written_; }\n \n@@ -90,8 +90,8 @@ class ARROW_EXPORT FixedSizeBufferWriter : public WriteableFile {\n   Status Close() override;\n   Status Seek(int64_t position) override;\n   Status Tell(int64_t* position) const override;\n-  Status Write(const uint8_t* data, int64_t nbytes) override;\n-  Status WriteAt(int64_t position, const uint8_t* data, int64_t nbytes) override;\n+  Status Write(const void* data, int64_t nbytes) override;\n+  Status WriteAt(int64_t position, const void* data, int64_t nbytes) override;\n \n   void set_memcopy_threads(int num_threads);\n   void set_memcopy_blocksize(int64_t blocksize);\n@@ -111,12 +111,12 @@ class ARROW_EXPORT BufferReader : public RandomAccessFile {\n \n   Status Close() override;\n   Status Tell(int64_t* position) const override;\n-  Status Read(int64_t nbytes, int64_t* bytes_read, uint8_t* buffer) override;\n+  Status Read(int64_t nbytes, int64_t* bytes_read, void* buffer) override;\n \n   // Zero copy read\n   Status Read(int64_t nbytes, std::shared_ptr<Buffer>* out) override;\n   Status ReadAt(int64_t position, int64_t nbytes, int64_t* bytes_read,\n-                uint8_t* out) override;\n+                void* out) override;\n \n   /// Default implementation is thread-safe\n   Status ReadAt(int64_t position, int64_t nbytes, std::shared_ptr<Buffer>* out) override;\ndiff --git a/cpp/src/arrow/ipc/feather.cc b/cpp/src/arrow/ipc/feather.cc\nindex d339449c0..d3872503e 100644\n--- a/cpp/src/arrow/ipc/feather.cc\n+++ b/cpp/src/arrow/ipc/feather.cc\n@@ -523,10 +523,8 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {\n     uint32_t buffer_size = static_cast<uint32_t>(bytes_written);\n \n     // Footer: metadata length, magic bytes\n-    RETURN_NOT_OK(\n-        stream_->Write(reinterpret_cast<const uint8_t*>(&buffer_size), sizeof(uint32_t)));\n-    return stream_->Write(reinterpret_cast<const uint8_t*>(kFeatherMagicBytes),\n-                          strlen(kFeatherMagicBytes));\n+    RETURN_NOT_OK(stream_->Write(&buffer_size, sizeof(uint32_t)));\n+    return stream_->Write(kFeatherMagicBytes, strlen(kFeatherMagicBytes));\n   }\n \n   Status LoadArrayMetadata(const Array& values, ArrayMetadata* meta) {\ndiff --git a/cpp/src/arrow/ipc/json-integration-test.cc b/cpp/src/arrow/ipc/json-integration-test.cc\nindex f487487df..f362d9701 100644\n--- a/cpp/src/arrow/ipc/json-integration-test.cc\n+++ b/cpp/src/arrow/ipc/json-integration-test.cc\n@@ -119,8 +119,7 @@ static Status ConvertArrowToJson(const std::string& arrow_path,\n \n   std::string result;\n   RETURN_NOT_OK(writer->Finish(&result));\n-  return out_file->Write(reinterpret_cast<const uint8_t*>(result.c_str()),\n-                         static_cast<int64_t>(result.size()));\n+  return out_file->Write(result.c_str(), static_cast<int64_t>(result.size()));\n }\n \n static Status ValidateArrowVsJson(const std::string& arrow_path,\n@@ -250,8 +249,7 @@ class TestJSONIntegration : public ::testing::Test {\n     do {\n       std::shared_ptr<io::FileOutputStream> out;\n       RETURN_NOT_OK(io::FileOutputStream::Open(path, &out));\n-      RETURN_NOT_OK(out->Write(reinterpret_cast<const uint8_t*>(data),\n-                               static_cast<int64_t>(strlen(data))));\n+      RETURN_NOT_OK(out->Write(data, static_cast<int64_t>(strlen(data))));\n     } while (0);\n     return Status::OK();\n   }\ndiff --git a/cpp/src/arrow/ipc/metadata-internal.cc b/cpp/src/arrow/ipc/metadata-internal.cc\nindex 87b4708bf..05202ea93 100644\n--- a/cpp/src/arrow/ipc/metadata-internal.cc\n+++ b/cpp/src/arrow/ipc/metadata-internal.cc\n@@ -945,8 +945,7 @@ Status WriteMessage(const Buffer& message, io::OutputStream* file,\n \n   // Write the flatbuffer size prefix including padding\n   int32_t flatbuffer_size = padded_message_length - 4;\n-  RETURN_NOT_OK(\n-      file->Write(reinterpret_cast<const uint8_t*>(&flatbuffer_size), sizeof(int32_t)));\n+  RETURN_NOT_OK(file->Write(&flatbuffer_size, sizeof(int32_t)));\n \n   // Write the flatbuffer\n   RETURN_NOT_OK(file->Write(message.data(), message.size()));\ndiff --git a/cpp/src/arrow/ipc/writer.cc b/cpp/src/arrow/ipc/writer.cc\nindex 3c1db0615..13daf2be8 100644\n--- a/cpp/src/arrow/ipc/writer.cc\n+++ b/cpp/src/arrow/ipc/writer.cc\n@@ -687,7 +687,7 @@ class StreamBookKeeper {\n   }\n \n   // Write data and update position\n-  Status Write(const uint8_t* data, int64_t nbytes) {\n+  Status Write(const void* data, int64_t nbytes) {\n     RETURN_NOT_OK(sink_->Write(data, nbytes));\n     position_ += nbytes;\n     return Status::OK();\n@@ -776,7 +776,7 @@ class RecordBatchStreamWriter::RecordBatchStreamWriterImpl : public StreamBookKe\n \n     // Write 0 EOS message\n     const int32_t kEos = 0;\n-    return Write(reinterpret_cast<const uint8_t*>(&kEos), sizeof(int32_t));\n+    return Write(&kEos, sizeof(int32_t));\n   }\n \n   Status CheckStarted() {\n@@ -864,8 +864,7 @@ class RecordBatchFileWriter::RecordBatchFileWriterImpl\n \n   Status Start() override {\n     // It is only necessary to align to 8-byte boundary at the start of the file\n-    RETURN_NOT_OK(Write(reinterpret_cast<const uint8_t*>(kArrowMagicBytes),\n-                        strlen(kArrowMagicBytes)));\n+    RETURN_NOT_OK(Write(kArrowMagicBytes, strlen(kArrowMagicBytes)));\n     RETURN_NOT_OK(Align());\n \n     // We write the schema at the start of the file (and the end). This also\n@@ -889,12 +888,10 @@ class RecordBatchFileWriter::RecordBatchFileWriterImpl\n       return Status::Invalid(\"Invalid file footer\");\n     }\n \n-    RETURN_NOT_OK(\n-        Write(reinterpret_cast<const uint8_t*>(&footer_length), sizeof(int32_t)));\n+    RETURN_NOT_OK(Write(&footer_length, sizeof(int32_t)));\n \n     // Write magic bytes to end file\n-    return Write(reinterpret_cast<const uint8_t*>(kArrowMagicBytes),\n-                 strlen(kArrowMagicBytes));\n+    return Write(kArrowMagicBytes, strlen(kArrowMagicBytes));\n   }\n };\n \ndiff --git a/cpp/src/arrow/python/io.cc b/cpp/src/arrow/python/io.cc\nindex b01358ab0..cc3892928 100644\n--- a/cpp/src/arrow/python/io.cc\n+++ b/cpp/src/arrow/python/io.cc\n@@ -76,7 +76,7 @@ class PythonFile {\n     return Status::OK();\n   }\n \n-  Status Write(const uint8_t* data, int64_t nbytes) {\n+  Status Write(const void* data, int64_t nbytes) {\n     PyObject* py_data =\n         PyBytes_FromStringAndSize(reinterpret_cast<const char*>(data), nbytes);\n     PY_RETURN_IF_ERROR(StatusCode::IOError);\n@@ -130,7 +130,7 @@ Status PyReadableFile::Tell(int64_t* position) const {\n   return file_->Tell(position);\n }\n \n-Status PyReadableFile::Read(int64_t nbytes, int64_t* bytes_read, uint8_t* out) {\n+Status PyReadableFile::Read(int64_t nbytes, int64_t* bytes_read, void* out) {\n   PyAcquireGIL lock;\n   PyObject* bytes_obj;\n   ARROW_RETURN_NOT_OK(file_->Read(nbytes, &bytes_obj));\n@@ -155,7 +155,7 @@ Status PyReadableFile::Read(int64_t nbytes, std::shared_ptr<Buffer>* out) {\n }\n \n Status PyReadableFile::ReadAt(int64_t position, int64_t nbytes, int64_t* bytes_read,\n-                              uint8_t* out) {\n+                              void* out) {\n   std::lock_guard<std::mutex> guard(file_->lock());\n   RETURN_NOT_OK(Seek(position));\n   return Read(nbytes, bytes_read, out);\n@@ -208,7 +208,7 @@ Status PyOutputStream::Tell(int64_t* position) const {\n   return Status::OK();\n }\n \n-Status PyOutputStream::Write(const uint8_t* data, int64_t nbytes) {\n+Status PyOutputStream::Write(const void* data, int64_t nbytes) {\n   PyAcquireGIL lock;\n   position_ += nbytes;\n   return file_->Write(data, nbytes);\ndiff --git a/cpp/src/arrow/python/io.h b/cpp/src/arrow/python/io.h\nindex bf5db5313..f550de7b2 100644\n--- a/cpp/src/arrow/python/io.h\n+++ b/cpp/src/arrow/python/io.h\n@@ -41,12 +41,12 @@ class ARROW_EXPORT PyReadableFile : public io::RandomAccessFile {\n \n   Status Close() override;\n \n-  Status Read(int64_t nbytes, int64_t* bytes_read, uint8_t* out) override;\n+  Status Read(int64_t nbytes, int64_t* bytes_read, void* out) override;\n   Status Read(int64_t nbytes, std::shared_ptr<Buffer>* out) override;\n \n   // Thread-safe version\n   Status ReadAt(int64_t position, int64_t nbytes, int64_t* bytes_read,\n-                uint8_t* out) override;\n+                void* out) override;\n \n   // Thread-safe version\n   Status ReadAt(int64_t position, int64_t nbytes, std::shared_ptr<Buffer>* out) override;\n@@ -70,7 +70,7 @@ class ARROW_EXPORT PyOutputStream : public io::OutputStream {\n \n   Status Close() override;\n   Status Tell(int64_t* position) const override;\n-  Status Write(const uint8_t* data, int64_t nbytes) override;\n+  Status Write(const void* data, int64_t nbytes) override;\n \n  private:\n   std::unique_ptr<PythonFile> file_;\ndiff --git a/cpp/src/arrow/util/io-util.h b/cpp/src/arrow/util/io-util.h\nindex dbca0d8be..7e2a94ca8 100644\n--- a/cpp/src/arrow/util/io-util.h\n+++ b/cpp/src/arrow/util/io-util.h\n@@ -40,7 +40,7 @@ class StdoutStream : public OutputStream {\n     return Status::OK();\n   }\n \n-  Status Write(const uint8_t* data, int64_t nbytes) override {\n+  Status Write(const void* data, int64_t nbytes) override {\n     pos_ += nbytes;\n     std::cout.write(reinterpret_cast<const char*>(data), nbytes);\n     return Status::OK();\n@@ -63,7 +63,7 @@ class StdinStream : public InputStream {\n     return Status::OK();\n   }\n \n-  Status Read(int64_t nbytes, int64_t* bytes_read, uint8_t* out) override {\n+  Status Read(int64_t nbytes, int64_t* bytes_read, void* out) override {\n     std::cin.read(reinterpret_cast<char*>(out), nbytes);\n     if (std::cin) {\n       *bytes_read = nbytes;\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-27T16:46:03.982+0000",
                    "updated": "2017-11-27T16:46:03.982+0000"
                }
            ],
            "maxResults": 5,
            "total": 5,
            "startAt": 0
        },
        "customfield_12311820": "0|i3n59b:",
        "customfield_12314139": null
    }
}