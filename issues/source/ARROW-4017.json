{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13204205",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204205",
    "key": "ARROW-4017",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343858",
                "id": "12343858",
                "description": "",
                "name": "0.12.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-01-20"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12344316",
                "id": "12344316",
                "name": "0.11.1",
                "archived": false,
                "released": true,
                "releaseDate": "2018-10-23"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "aggregateprogress": {
            "progress": 3600,
            "total": 3600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 3600,
            "total": 3600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-4017/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 6,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204205/worklog/175716",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou opened a new pull request #3184: ARROW-4017: [C++] Move vendored libraries in dedicated directory\nURL: https://github.com/apache/arrow/pull/3184\n \n \n   Also update mapbox::variant to v1.1.5 (I'm not sure which version was previously vendored).\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-15T17:01:20.186+0000",
                    "updated": "2018-12-15T17:01:20.186+0000",
                    "started": "2018-12-15T17:01:20.185+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "175716",
                    "issueId": "13204205"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204205/worklog/175721",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "codecov-io commented on issue #3184: ARROW-4017: [C++] Move vendored libraries in dedicated directory\nURL: https://github.com/apache/arrow/pull/3184#issuecomment-447585919\n \n \n   # [Codecov](https://codecov.io/gh/apache/arrow/pull/3184?src=pr&el=h1) Report\n   > Merging [#3184](https://codecov.io/gh/apache/arrow/pull/3184?src=pr&el=desc) into [master](https://codecov.io/gh/apache/arrow/commit/23dfc1c5b1e303aa4ed699970c68235e319aa3d8?src=pr&el=desc) will **increase** coverage by `1.04%`.\n   > The diff coverage is `83.33%`.\n   \n   [![Impacted file tree graph](https://codecov.io/gh/apache/arrow/pull/3184/graphs/tree.svg?width=650&token=LpTCFbqVT1&height=150&src=pr)](https://codecov.io/gh/apache/arrow/pull/3184?src=pr&el=tree)\n   \n   ```diff\n   @@            Coverage Diff             @@\n   ##           master    #3184      +/-   ##\n   ==========================================\n   + Coverage   86.41%   87.46%   +1.04%     \n   ==========================================\n     Files         504      446      -58     \n     Lines       69587    65848    -3739     \n   ==========================================\n   - Hits        60137    57596    -2541     \n   + Misses       9353     8252    -1101     \n   + Partials       97        0      -97\n   ```\n   \n   \n   | [Impacted Files](https://codecov.io/gh/apache/arrow/pull/3184?src=pr&el=tree) | Coverage \u0394 | |\n   |---|---|---|\n   | [cpp/src/arrow/util/parsing.h](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy91dGlsL3BhcnNpbmcuaA==) | `95.6% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [cpp/src/plasma/client.cc](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Y3BwL3NyYy9wbGFzbWEvY2xpZW50LmNj) | `78.97% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [cpp/src/gandiva/to\\_date\\_holder.cc](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Y3BwL3NyYy9nYW5kaXZhL3RvX2RhdGVfaG9sZGVyLmNj) | `2.08% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [cpp/src/arrow/vendored/xxhash/xxhash.c](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy92ZW5kb3JlZC94eGhhc2gveHhoYXNoLmM=) | `51.26% <\u00f8> (\u00f8)` | |\n   | [cpp/src/arrow/vendored/date.h](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy92ZW5kb3JlZC9kYXRlLmg=) | `90.32% <\u00f8> (\u00f8)` | |\n   | [cpp/src/arrow/vendored/string\\_view.hpp](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy92ZW5kb3JlZC9zdHJpbmdfdmlldy5ocHA=) | `84.61% <\u00f8> (\u00f8)` | |\n   | [cpp/src/arrow/vendored/variant/variant.hpp](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy92ZW5kb3JlZC92YXJpYW50L3ZhcmlhbnQuaHBw) | `83.33% <83.33%> (\u00f8)` | |\n   | [go/arrow/array/table.go](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Z28vYXJyb3cvYXJyYXkvdGFibGUuZ28=) | | |\n   | [go/arrow/math/uint64\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWF0aC91aW50NjRfYW1kNjQuZ28=) | | |\n   | [go/arrow/internal/testing/tools/bool.go](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Z28vYXJyb3cvaW50ZXJuYWwvdGVzdGluZy90b29scy9ib29sLmdv) | | |\n   | ... and [56 more](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree-more) | |\n   \n   ------\n   \n   [Continue to review full report at Codecov](https://codecov.io/gh/apache/arrow/pull/3184?src=pr&el=continue).\n   > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n   > `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n   > Powered by [Codecov](https://codecov.io/gh/apache/arrow/pull/3184?src=pr&el=footer). Last update [23dfc1c...de74797](https://codecov.io/gh/apache/arrow/pull/3184?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-15T17:53:38.461+0000",
                    "updated": "2018-12-15T17:53:38.461+0000",
                    "started": "2018-12-15T17:53:38.459+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "175721",
                    "issueId": "13204205"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204205/worklog/175776",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on a change in pull request #3184: ARROW-4017: [C++] Move vendored libraries in dedicated directory\nURL: https://github.com/apache/arrow/pull/3184#discussion_r241966256\n \n \n\n ##########\n File path: LICENSE.txt\n ##########\n @@ -736,7 +736,7 @@ SOFTWARE.\n \n --------------------------------------------------------------------------------\n \n-The file cpp/src/util/string_view/string_view.hpp has the following license\n+The file cpp/src/vendored/string_view.hpp has the following license\n \n Review comment:\n   `arrow/vendored`\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-16T02:48:45.402+0000",
                    "updated": "2018-12-16T02:48:45.402+0000",
                    "started": "2018-12-16T02:48:45.383+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "175776",
                    "issueId": "13204205"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204205/worklog/175953",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #3184: ARROW-4017: [C++] Move vendored libraries in dedicated directory\nURL: https://github.com/apache/arrow/pull/3184#discussion_r242096808\n \n \n\n ##########\n File path: LICENSE.txt\n ##########\n @@ -736,7 +736,7 @@ SOFTWARE.\n \n --------------------------------------------------------------------------------\n \n-The file cpp/src/util/string_view/string_view.hpp has the following license\n+The file cpp/src/vendored/string_view.hpp has the following license\n \n Review comment:\n   Thanks, I fixed it now.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-17T10:36:14.463+0000",
                    "updated": "2018-12-17T10:36:14.463+0000",
                    "started": "2018-12-17T10:36:14.462+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "175953",
                    "issueId": "13204205"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204205/worklog/175967",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "codecov-io edited a comment on issue #3184: ARROW-4017: [C++] Move vendored libraries in dedicated directory\nURL: https://github.com/apache/arrow/pull/3184#issuecomment-447585919\n \n \n   # [Codecov](https://codecov.io/gh/apache/arrow/pull/3184?src=pr&el=h1) Report\n   > Merging [#3184](https://codecov.io/gh/apache/arrow/pull/3184?src=pr&el=desc) into [master](https://codecov.io/gh/apache/arrow/commit/5d1934fc3f5c65f70a3966b71c68941b2fd8d362?src=pr&el=desc) will **increase** coverage by `1.04%`.\n   > The diff coverage is `83.33%`.\n   \n   [![Impacted file tree graph](https://codecov.io/gh/apache/arrow/pull/3184/graphs/tree.svg?width=650&token=LpTCFbqVT1&height=150&src=pr)](https://codecov.io/gh/apache/arrow/pull/3184?src=pr&el=tree)\n   \n   ```diff\n   @@            Coverage Diff             @@\n   ##           master    #3184      +/-   ##\n   ==========================================\n   + Coverage   86.43%   87.48%   +1.04%     \n   ==========================================\n     Files         504      446      -58     \n     Lines       69628    65889    -3739     \n   ==========================================\n   - Hits        60181    57640    -2541     \n   + Misses       9350     8249    -1101     \n   + Partials       97        0      -97\n   ```\n   \n   \n   | [Impacted Files](https://codecov.io/gh/apache/arrow/pull/3184?src=pr&el=tree) | Coverage \u0394 | |\n   |---|---|---|\n   | [cpp/src/arrow/util/parsing.h](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy91dGlsL3BhcnNpbmcuaA==) | `95.6% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [cpp/src/plasma/client.cc](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Y3BwL3NyYy9wbGFzbWEvY2xpZW50LmNj) | `78.97% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [cpp/src/gandiva/to\\_date\\_holder.cc](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Y3BwL3NyYy9nYW5kaXZhL3RvX2RhdGVfaG9sZGVyLmNj) | `2.08% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [cpp/src/arrow/vendored/xxhash/xxhash.c](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy92ZW5kb3JlZC94eGhhc2gveHhoYXNoLmM=) | `51.26% <\u00f8> (\u00f8)` | |\n   | [cpp/src/arrow/vendored/date.h](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy92ZW5kb3JlZC9kYXRlLmg=) | `90.32% <\u00f8> (\u00f8)` | |\n   | [cpp/src/arrow/vendored/string\\_view.hpp](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy92ZW5kb3JlZC9zdHJpbmdfdmlldy5ocHA=) | `84.61% <\u00f8> (\u00f8)` | |\n   | [cpp/src/arrow/vendored/variant/variant.hpp](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy92ZW5kb3JlZC92YXJpYW50L3ZhcmlhbnQuaHBw) | `83.33% <83.33%> (\u00f8)` | |\n   | [go/arrow/array/table.go](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Z28vYXJyb3cvYXJyYXkvdGFibGUuZ28=) | | |\n   | [go/arrow/math/uint64\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWF0aC91aW50NjRfYW1kNjQuZ28=) | | |\n   | [go/arrow/internal/testing/tools/bool.go](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree#diff-Z28vYXJyb3cvaW50ZXJuYWwvdGVzdGluZy90b29scy9ib29sLmdv) | | |\n   | ... and [56 more](https://codecov.io/gh/apache/arrow/pull/3184/diff?src=pr&el=tree-more) | |\n   \n   ------\n   \n   [Continue to review full report at Codecov](https://codecov.io/gh/apache/arrow/pull/3184?src=pr&el=continue).\n   > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n   > `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n   > Powered by [Codecov](https://codecov.io/gh/apache/arrow/pull/3184?src=pr&el=footer). Last update [5d1934f...fe69566](https://codecov.io/gh/apache/arrow/pull/3184?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-17T11:12:12.904+0000",
                    "updated": "2018-12-17T11:12:12.904+0000",
                    "started": "2018-12-17T11:12:12.892+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "175967",
                    "issueId": "13204205"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204205/worklog/176105",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm closed pull request #3184: ARROW-4017: [C++] Move vendored libraries in dedicated directory\nURL: https://github.com/apache/arrow/pull/3184\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/LICENSE.txt b/LICENSE.txt\nindex 5c9aaddc14..572d3ef548 100644\n--- a/LICENSE.txt\n+++ b/LICENSE.txt\n@@ -681,7 +681,7 @@ See the License for the specific language governing permissions and\n limitations under the License.\n \n --------------------------------------------------------------------------------\n-The file cpp/src/arrow/util/date.h has the following license (MIT)\n+The file cpp/src/arrow/vendored/date.h has the following license (MIT)\n \n The MIT License (MIT)\n Copyright (c) 2015, 2016, 2017 Howard Hinnant\n@@ -736,7 +736,7 @@ SOFTWARE.\n \n --------------------------------------------------------------------------------\n \n-The file cpp/src/util/string_view/string_view.hpp has the following license\n+The file cpp/src/arrow/vendored/string_view.hpp has the following license\n \n Boost Software License - Version 1.0 - August 17th, 2003\n \n@@ -764,7 +764,7 @@ DEALINGS IN THE SOFTWARE.\n \n --------------------------------------------------------------------------------\n \n-The files in cpp/src/arrow/util/xxhash/ have the following license\n+The files in cpp/src/arrow/vendored/xxhash/ have the following license\n (BSD 2-Clause License)\n \n xxHash Library\ndiff --git a/cpp/CMakeLists.txt b/cpp/CMakeLists.txt\nindex e3cc3f560a..f563199c62 100644\n--- a/cpp/CMakeLists.txt\n+++ b/cpp/CMakeLists.txt\n@@ -373,12 +373,8 @@ if (UNIX)\n     IF(NOT ((item MATCHES \"_generated.h\") OR\n             (item MATCHES \"pyarrow_api.h\") OR\n             (item MATCHES \"pyarrow_lib.h\") OR\n-            (item MATCHES \"xxhash.h\") OR\n-            (item MATCHES \"xxhash.cc\") OR\n             (item MATCHES \"config.h\") OR\n-            (item MATCHES \"util/date.h\") OR\n-            (item MATCHES \"util/string_view/\") OR\n-            (item MATCHES \"util/variant\") OR\n+            (item MATCHES \"vendored/\") OR\n             (item MATCHES \"zmalloc.h\") OR\n             (item MATCHES \"ae.h\")))\n       LIST(APPEND FILTERED_LINT_FILES ${item})\ndiff --git a/cpp/build-support/clang_format_exclusions.txt b/cpp/build-support/clang_format_exclusions.txt\nindex c04523af1d..2964898f4f 100644\n--- a/cpp/build-support/clang_format_exclusions.txt\n+++ b/cpp/build-support/clang_format_exclusions.txt\n@@ -4,11 +4,6 @@\n *pyarrow_lib.h\n *python/config.h\n *python/platform.h\n-*util/date.h\n-*util/string_view/*\n-*util/variant.h\n-*util/variant/*\n *thirdparty/ae/*\n-*xxhash.cc\n-*xxhash.h\n+*vendored/*\n *RcppExports.cpp*\ndiff --git a/cpp/build-support/lint_cpp_cli.py b/cpp/build-support/lint_cpp_cli.py\nindex 4c26927740..c8b25dfc5e 100644\n--- a/cpp/build-support/lint_cpp_cli.py\n+++ b/cpp/build-support/lint_cpp_cli.py\n@@ -70,13 +70,10 @@ def lint_file(path):\n \n EXCLUSIONS = [\n     'arrow/python/iterators.h',\n-    'arrow/util/date.h',\n     'arrow/util/hashing.h',\n     'arrow/util/macros.h',\n     'arrow/util/parallel.h',\n-    'arrow/util/string_view/string_view.hpp',\n-    'arrow/util/xxhash/xxhash.c',\n-    'arrow/util/xxhash/xxhash.h',\n+    'arrow/vendored',\n     'arrow/visitor_inline.h',\n     'gandiva/cache.h',\n     'gandiva/jni',\ndiff --git a/cpp/cmake_modules/BuildUtils.cmake b/cpp/cmake_modules/BuildUtils.cmake\nindex 7585ae9da8..812d0c39e7 100644\n--- a/cpp/cmake_modules/BuildUtils.cmake\n+++ b/cpp/cmake_modules/BuildUtils.cmake\n@@ -580,7 +580,8 @@ function(ARROW_INSTALL_ALL_HEADERS PATH)\n   set(multi_value_args PATTERN)\n   cmake_parse_arguments(ARG \"${options}\" \"${one_value_args}\" \"${multi_value_args}\" ${ARGN})\n   if (NOT ARG_PATTERN)\n-    set(ARG_PATTERN \"*.h\")\n+    # The .hpp extension is used by some vendored libraries\n+    set(ARG_PATTERN \"*.h\" \"*.hpp\")\n   endif()\n   file(GLOB CURRENT_DIRECTORY_HEADERS ${ARG_PATTERN})\n \ndiff --git a/cpp/src/arrow/CMakeLists.txt b/cpp/src/arrow/CMakeLists.txt\nindex bec290df2a..9291addca0 100644\n--- a/cpp/src/arrow/CMakeLists.txt\n+++ b/cpp/src/arrow/CMakeLists.txt\n@@ -280,6 +280,7 @@ add_subdirectory(array)\n add_subdirectory(csv)\n add_subdirectory(io)\n add_subdirectory(util)\n+add_subdirectory(vendored)\n \n if(ARROW_FLIGHT)\n   add_subdirectory(flight)\ndiff --git a/cpp/src/arrow/util/CMakeLists.txt b/cpp/src/arrow/util/CMakeLists.txt\nindex a097971832..b13b2f367b 100644\n--- a/cpp/src/arrow/util/CMakeLists.txt\n+++ b/cpp/src/arrow/util/CMakeLists.txt\n@@ -72,6 +72,3 @@ ADD_ARROW_BENCHMARK(int-util-benchmark)\n ADD_ARROW_BENCHMARK(lazy-benchmark)\n ADD_ARROW_BENCHMARK(number-parsing-benchmark)\n ADD_ARROW_BENCHMARK(utf8-util-benchmark)\n-\n-add_subdirectory(string_view)\n-add_subdirectory(variant)\ndiff --git a/cpp/src/arrow/util/parsing.h b/cpp/src/arrow/util/parsing.h\nindex 23e0361235..46d0f7c322 100644\n--- a/cpp/src/arrow/util/parsing.h\n+++ b/cpp/src/arrow/util/parsing.h\n@@ -34,7 +34,7 @@\n #include \"arrow/type.h\"\n #include \"arrow/type_traits.h\"\n #include \"arrow/util/checked_cast.h\"\n-#include \"arrow/util/date.h\"\n+#include \"arrow/vendored/date.h\"\n \n namespace arrow {\n namespace internal {\ndiff --git a/cpp/src/arrow/util/string_view.h b/cpp/src/arrow/util/string_view.h\nindex 0f35483e37..a1a813726e 100644\n--- a/cpp/src/arrow/util/string_view.h\n+++ b/cpp/src/arrow/util/string_view.h\n@@ -18,7 +18,7 @@\n #ifndef ARROW_UTIL_STRING_VIEW_H\n #define ARROW_UTIL_STRING_VIEW_H\n \n-#include \"arrow/util/string_view/string_view.hpp\"  // IWYU pragma: export\n+#include \"arrow/vendored/string_view.hpp\"  // IWYU pragma: export\n \n namespace arrow {\n namespace util {\ndiff --git a/cpp/src/arrow/util/variant.h b/cpp/src/arrow/util/variant.h\nindex 1aa9aa3732..cb6500aef8 100644\n--- a/cpp/src/arrow/util/variant.h\n+++ b/cpp/src/arrow/util/variant.h\n@@ -1,1105 +1,34 @@\n-// Copyright (c) MapBox\n-// All rights reserved.\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n //\n-// Redistribution and use in source and binary forms, with or without modification,\n-// are permitted provided that the following conditions are met:\n+//   http://www.apache.org/licenses/LICENSE-2.0\n //\n-// - Redistributions of source code must retain the above copyright notice, this\n-//   list of conditions and the following disclaimer.\n-// - Redistributions in binary form must reproduce the above copyright notice, this\n-//   list of conditions and the following disclaimer in the documentation and/or\n-//   other materials provided with the distribution.\n-// - Neither the name \"MapBox\" nor the names of its contributors may be\n-//   used to endorse or promote products derived from this software without\n-//   specific prior written permission.\n-//\n-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n-// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n-// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n-// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n-// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n \n #ifndef ARROW_UTIL_VARIANT_H\n #define ARROW_UTIL_VARIANT_H\n \n-#include <cassert>\n-#include <cstddef>   // size_t\n-#include <new>       // operator new\n-#include <stdexcept> // runtime_error\n-#include <string>\n-#include <tuple>\n-#include <type_traits>\n-#include <typeinfo>\n-#include <utility>\n-#include <functional>\n-#include <limits>\n-\n-#include <arrow/util/macros.h>\n-#include <arrow/util/variant/recursive_wrapper.h>\n-#include <arrow/util/variant/variant_visitor.h>\n-\n-\n-#ifdef _MSC_VER\n-// https://msdn.microsoft.com/en-us/library/bw1hbe6y.aspx\n-# ifdef NDEBUG\n-#  define VARIANT_INLINE __forceinline\n-# else\n-#  define VARIANT_INLINE //__declspec(noinline)\n-# endif\n-#else\n-# ifdef NDEBUG\n-#  define VARIANT_INLINE //inline __attribute__((always_inline))\n-# else\n-#  define VARIANT_INLINE __attribute__((noinline))\n-# endif\n-#endif\n-// clang-format on\n-\n-// Exceptions\n-#if defined( __EXCEPTIONS) || defined( _MSC_VER)\n-#define HAS_EXCEPTIONS\n-#endif\n-\n-#define VARIANT_MAJOR_VERSION 1\n-#define VARIANT_MINOR_VERSION 1\n-#define VARIANT_PATCH_VERSION 0\n-\n-#define VARIANT_VERSION (VARIANT_MAJOR_VERSION * 100000) + (VARIANT_MINOR_VERSION * 100) + (VARIANT_PATCH_VERSION)\n+#include \"arrow/vendored/variant/variant.hpp\"  // IWYU pragma: export\n \n namespace arrow {\n namespace util {\n \n-// XXX This should derive from std::logic_error instead of std::runtime_error.\n-//     See https://github.com/mapbox/variant/issues/48 for details.\n-class bad_variant_access : public std::runtime_error\n-{\n-\n-public:\n-    explicit bad_variant_access(const std::string& what_arg)\n-        : runtime_error(what_arg) {}\n-\n-    explicit bad_variant_access(const char* what_arg)\n-        : runtime_error(what_arg) {}\n-\n-}; // class bad_variant_access\n-\n-#if !defined(ARROW_VARIANT_MINIMIZE_SIZE)\n-using type_index_t = std::size_t;\n-#else\n-#if defined(ARROW_VARIANT_OPTIMIZE_FOR_SPEED)\n-using type_index_t = std::uint_fast8_t;\n-#else\n-using type_index_t = std::uint_least8_t;\n-#endif\n-#endif\n-\n-namespace detail {\n-\n-static constexpr type_index_t invalid_value = type_index_t(-1);\n-\n-template <typename T, typename... Types>\n-struct direct_type;\n-\n-template <typename T, typename First, typename... Types>\n-struct direct_type<T, First, Types...>\n-{\n-    static constexpr type_index_t index = std::is_same<T, First>::value\n-        ? sizeof...(Types)\n-        : direct_type<T, Types...>::index;\n-};\n-\n-template <typename T>\n-struct direct_type<T>\n-{\n-    static constexpr type_index_t index = invalid_value;\n-};\n-\n-#if __cpp_lib_logical_traits >= 201510L\n-\n-using std::conjunction;\n-using std::disjunction;\n-\n-#else\n-\n-template <typename...>\n-struct conjunction : std::true_type {};\n-\n-template <typename B1>\n-struct conjunction<B1> : B1 {};\n-\n-template <typename B1, typename B2>\n-struct conjunction<B1, B2> : std::conditional<B1::value, B2, B1>::type {};\n-\n-template <typename B1, typename... Bs>\n-struct conjunction<B1, Bs...> : std::conditional<B1::value, conjunction<Bs...>, B1>::type {};\n-\n-template <typename...>\n-struct disjunction : std::false_type {};\n-\n-template <typename B1>\n-struct disjunction<B1> : B1 {};\n-\n-template <typename B1, typename B2>\n-struct disjunction<B1, B2> : std::conditional<B1::value, B1, B2>::type {};\n-\n-template <typename B1, typename... Bs>\n-struct disjunction<B1, Bs...> : std::conditional<B1::value, B1, disjunction<Bs...>>::type {};\n-\n-#endif\n-\n-template <typename T, typename... Types>\n-struct convertible_type;\n-\n-template <typename T, typename First, typename... Types>\n-struct convertible_type<T, First, Types...>\n-{\n-    static constexpr type_index_t index = std::is_convertible<T, First>::value\n-        ? disjunction<std::is_convertible<T, Types>...>::value ? invalid_value : sizeof...(Types)\n-        : convertible_type<T, Types...>::index;\n-};\n-\n-template <typename T>\n-struct convertible_type<T>\n-{\n-    static constexpr type_index_t index = invalid_value;\n-};\n-\n-template <typename T, typename... Types>\n-struct value_traits\n-{\n-    using value_type = typename std::remove_const<typename std::remove_reference<T>::type>::type;\n-    using value_type_wrapper = recursive_wrapper<value_type>;\n-    static constexpr type_index_t direct_index = direct_type<value_type, Types...>::index;\n-    static constexpr bool is_direct = direct_index != invalid_value;\n-    static constexpr type_index_t index_direct_or_wrapper = is_direct ? direct_index : direct_type<value_type_wrapper, Types...>::index;\n-    static constexpr bool is_direct_or_wrapper = index_direct_or_wrapper != invalid_value;\n-    static constexpr type_index_t index = is_direct_or_wrapper ? index_direct_or_wrapper : convertible_type<value_type, Types...>::index;\n-    static constexpr bool is_valid = index != invalid_value;\n-    static constexpr type_index_t tindex = is_valid ? sizeof...(Types)-index : 0;\n-    using target_type = typename std::tuple_element<tindex, std::tuple<void, Types...>>::type;\n-};\n-\n-template <typename T, typename R = void>\n-struct enable_if_type\n-{\n-    using type = R;\n-};\n-\n-template <typename F, typename V, typename Enable = void>\n-struct result_of_unary_visit\n-{\n-    using type = typename std::result_of<F(V&)>::type;\n-};\n-\n-template <typename F, typename V>\n-struct result_of_unary_visit<F, V, typename enable_if_type<typename F::result_type>::type>\n-{\n-    using type = typename F::result_type;\n-};\n-\n-template <typename F, typename V, typename Enable = void>\n-struct result_of_binary_visit\n-{\n-    using type = typename std::result_of<F(V&, V&)>::type;\n-};\n-\n-template <typename F, typename V>\n-struct result_of_binary_visit<F, V, typename enable_if_type<typename F::result_type>::type>\n-{\n-    using type = typename F::result_type;\n-};\n-\n-template <type_index_t arg1, type_index_t... others>\n-struct static_max;\n-\n-template <type_index_t arg>\n-struct static_max<arg>\n-{\n-    static const type_index_t value = arg;\n-};\n-\n-template <type_index_t arg1, type_index_t arg2, type_index_t... others>\n-struct static_max<arg1, arg2, others...>\n-{\n-    static const type_index_t value = arg1 >= arg2 ? static_max<arg1, others...>::value : static_max<arg2, others...>::value;\n-};\n-\n-template <typename... Types>\n-struct variant_helper;\n-\n-template <typename T, typename... Types>\n-struct variant_helper<T, Types...>\n-{\n-    VARIANT_INLINE static void destroy(const type_index_t type_index, void* data)\n-    {\n-        if (type_index == sizeof...(Types))\n-        {\n-            reinterpret_cast<T*>(data)->~T();\n-        }\n-        else\n-        {\n-            variant_helper<Types...>::destroy(type_index, data);\n-        }\n-    }\n-\n-    VARIANT_INLINE static void move(const type_index_t old_type_index, void* old_value, void* new_value)\n-    {\n-        if (old_type_index == sizeof...(Types))\n-        {\n-            new (new_value) T(std::move(*reinterpret_cast<T*>(old_value)));\n-        }\n-        else\n-        {\n-            variant_helper<Types...>::move(old_type_index, old_value, new_value);\n-        }\n-    }\n-\n-    VARIANT_INLINE static void copy(const type_index_t old_type_index, const void* old_value, void* new_value)\n-    {\n-        if (old_type_index == sizeof...(Types))\n-        {\n-            new (new_value) T(*reinterpret_cast<const T*>(old_value));\n-        }\n-        else\n-        {\n-            variant_helper<Types...>::copy(old_type_index, old_value, new_value);\n-        }\n-    }\n-};\n-\n-template <>\n-struct variant_helper<>\n-{\n-    VARIANT_INLINE static void destroy(const type_index_t, void*) {}\n-    VARIANT_INLINE static void move(const type_index_t, void*, void*) {}\n-    VARIANT_INLINE static void copy(const type_index_t, const void*, void*) {}\n-};\n-\n-template <typename T>\n-struct unwrapper\n-{\n-    static T const& apply_const(T const& obj) { return obj; }\n-    static T& apply(T& obj) { return obj; }\n-};\n-\n-template <typename T>\n-struct unwrapper<recursive_wrapper<T>>\n-{\n-    static auto apply_const(recursive_wrapper<T> const& obj)\n-        -> typename recursive_wrapper<T>::type const&\n-    {\n-        return obj.get();\n-    }\n-    static auto apply(recursive_wrapper<T>& obj)\n-        -> typename recursive_wrapper<T>::type&\n-    {\n-        return obj.get();\n-    }\n-};\n-\n-template <typename T>\n-struct unwrapper<std::reference_wrapper<T>>\n-{\n-    static auto apply_const(std::reference_wrapper<T> const& obj)\n-        -> typename std::reference_wrapper<T>::type const&\n-    {\n-        return obj.get();\n-    }\n-    static auto apply(std::reference_wrapper<T>& obj)\n-        -> typename std::reference_wrapper<T>::type&\n-    {\n-        return obj.get();\n-    }\n-};\n-\n-template <typename F, typename V, typename R, typename... Types>\n-struct dispatcher;\n-\n-template <typename F, typename V, typename R, typename T, typename... Types>\n-struct dispatcher<F, V, R, T, Types...>\n-{\n-    VARIANT_INLINE static R apply_const(V const& v, F&& f)\n-    {\n-        if (v.template is<T>())\n-        {\n-            return f(unwrapper<T>::apply_const(v.template get_unchecked<T>()));\n-        }\n-        else\n-        {\n-            return dispatcher<F, V, R, Types...>::apply_const(v, std::forward<F>(f));\n-        }\n-    }\n-\n-    VARIANT_INLINE static R apply(V& v, F&& f)\n-    {\n-        if (v.template is<T>())\n-        {\n-            return f(unwrapper<T>::apply(v.template get_unchecked<T>()));\n-        }\n-        else\n-        {\n-            return dispatcher<F, V, R, Types...>::apply(v, std::forward<F>(f));\n-        }\n-    }\n-};\n-\n-template <typename F, typename V, typename R, typename T>\n-struct dispatcher<F, V, R, T>\n-{\n-    VARIANT_INLINE static R apply_const(V const& v, F&& f)\n-    {\n-        return f(unwrapper<T>::apply_const(v.template get_unchecked<T>()));\n-    }\n-\n-    VARIANT_INLINE static R apply(V& v, F&& f)\n-    {\n-        return f(unwrapper<T>::apply(v.template get_unchecked<T>()));\n-    }\n-};\n-\n-template <typename F, typename V, typename R, typename T, typename... Types>\n-struct binary_dispatcher_rhs;\n-\n-template <typename F, typename V, typename R, typename T0, typename T1, typename... Types>\n-struct binary_dispatcher_rhs<F, V, R, T0, T1, Types...>\n-{\n-    VARIANT_INLINE static R apply_const(V const& lhs, V const& rhs, F&& f)\n-    {\n-        if (rhs.template is<T1>()) // call binary functor\n-        {\n-            return f(unwrapper<T0>::apply_const(lhs.template get_unchecked<T0>()),\n-                     unwrapper<T1>::apply_const(rhs.template get_unchecked<T1>()));\n-        }\n-        else\n-        {\n-            return binary_dispatcher_rhs<F, V, R, T0, Types...>::apply_const(lhs, rhs, std::forward<F>(f));\n-        }\n-    }\n-\n-    VARIANT_INLINE static R apply(V& lhs, V& rhs, F&& f)\n-    {\n-        if (rhs.template is<T1>()) // call binary functor\n-        {\n-            return f(unwrapper<T0>::apply(lhs.template get_unchecked<T0>()),\n-                     unwrapper<T1>::apply(rhs.template get_unchecked<T1>()));\n-        }\n-        else\n-        {\n-            return binary_dispatcher_rhs<F, V, R, T0, Types...>::apply(lhs, rhs, std::forward<F>(f));\n-        }\n-    }\n-};\n-\n-template <typename F, typename V, typename R, typename T0, typename T1>\n-struct binary_dispatcher_rhs<F, V, R, T0, T1>\n-{\n-    VARIANT_INLINE static R apply_const(V const& lhs, V const& rhs, F&& f)\n-    {\n-        return f(unwrapper<T0>::apply_const(lhs.template get_unchecked<T0>()),\n-                 unwrapper<T1>::apply_const(rhs.template get_unchecked<T1>()));\n-    }\n-\n-    VARIANT_INLINE static R apply(V& lhs, V& rhs, F&& f)\n-    {\n-        return f(unwrapper<T0>::apply(lhs.template get_unchecked<T0>()),\n-                 unwrapper<T1>::apply(rhs.template get_unchecked<T1>()));\n-    }\n-};\n-\n-template <typename F, typename V, typename R, typename T, typename... Types>\n-struct binary_dispatcher_lhs;\n-\n-template <typename F, typename V, typename R, typename T0, typename T1, typename... Types>\n-struct binary_dispatcher_lhs<F, V, R, T0, T1, Types...>\n-{\n-    VARIANT_INLINE static R apply_const(V const& lhs, V const& rhs, F&& f)\n-    {\n-        if (lhs.template is<T1>()) // call binary functor\n-        {\n-            return f(unwrapper<T1>::apply_const(lhs.template get_unchecked<T1>()),\n-                     unwrapper<T0>::apply_const(rhs.template get_unchecked<T0>()));\n-        }\n-        else\n-        {\n-            return binary_dispatcher_lhs<F, V, R, T0, Types...>::apply_const(lhs, rhs, std::forward<F>(f));\n-        }\n-    }\n-\n-    VARIANT_INLINE static R apply(V& lhs, V& rhs, F&& f)\n-    {\n-        if (lhs.template is<T1>()) // call binary functor\n-        {\n-            return f(unwrapper<T1>::apply(lhs.template get_unchecked<T1>()),\n-                     unwrapper<T0>::apply(rhs.template get_unchecked<T0>()));\n-        }\n-        else\n-        {\n-            return binary_dispatcher_lhs<F, V, R, T0, Types...>::apply(lhs, rhs, std::forward<F>(f));\n-        }\n-    }\n-};\n-\n-template <typename F, typename V, typename R, typename T0, typename T1>\n-struct binary_dispatcher_lhs<F, V, R, T0, T1>\n-{\n-    VARIANT_INLINE static R apply_const(V const& lhs, V const& rhs, F&& f)\n-    {\n-        return f(unwrapper<T1>::apply_const(lhs.template get_unchecked<T1>()),\n-                 unwrapper<T0>::apply_const(rhs.template get_unchecked<T0>()));\n-    }\n-\n-    VARIANT_INLINE static R apply(V& lhs, V& rhs, F&& f)\n-    {\n-        return f(unwrapper<T1>::apply(lhs.template get_unchecked<T1>()),\n-                 unwrapper<T0>::apply(rhs.template get_unchecked<T0>()));\n-    }\n-};\n-\n-template <typename F, typename V, typename R, typename... Types>\n-struct binary_dispatcher;\n-\n-template <typename F, typename V, typename R, typename T, typename... Types>\n-struct binary_dispatcher<F, V, R, T, Types...>\n-{\n-    VARIANT_INLINE static R apply_const(V const& v0, V const& v1, F&& f)\n-    {\n-        if (v0.template is<T>())\n-        {\n-            if (v1.template is<T>())\n-            {\n-                return f(unwrapper<T>::apply_const(v0.template get_unchecked<T>()),\n-                         unwrapper<T>::apply_const(v1.template get_unchecked<T>())); // call binary functor\n-            }\n-            else\n-            {\n-                return binary_dispatcher_rhs<F, V, R, T, Types...>::apply_const(v0, v1, std::forward<F>(f));\n-            }\n-        }\n-        else if (v1.template is<T>())\n-        {\n-            return binary_dispatcher_lhs<F, V, R, T, Types...>::apply_const(v0, v1, std::forward<F>(f));\n-        }\n-        return binary_dispatcher<F, V, R, Types...>::apply_const(v0, v1, std::forward<F>(f));\n-    }\n-\n-    VARIANT_INLINE static R apply(V& v0, V& v1, F&& f)\n-    {\n-        if (v0.template is<T>())\n-        {\n-            if (v1.template is<T>())\n-            {\n-                return f(unwrapper<T>::apply(v0.template get_unchecked<T>()),\n-                         unwrapper<T>::apply(v1.template get_unchecked<T>())); // call binary functor\n-            }\n-            else\n-            {\n-                return binary_dispatcher_rhs<F, V, R, T, Types...>::apply(v0, v1, std::forward<F>(f));\n-            }\n-        }\n-        else if (v1.template is<T>())\n-        {\n-            return binary_dispatcher_lhs<F, V, R, T, Types...>::apply(v0, v1, std::forward<F>(f));\n-        }\n-        return binary_dispatcher<F, V, R, Types...>::apply(v0, v1, std::forward<F>(f));\n-    }\n-};\n-\n-template <typename F, typename V, typename R, typename T>\n-struct binary_dispatcher<F, V, R, T>\n-{\n-    VARIANT_INLINE static R apply_const(V const& v0, V const& v1, F&& f)\n-    {\n-        return f(unwrapper<T>::apply_const(v0.template get_unchecked<T>()),\n-                 unwrapper<T>::apply_const(v1.template get_unchecked<T>())); // call binary functor\n-    }\n-\n-    VARIANT_INLINE static R apply(V& v0, V& v1, F&& f)\n-    {\n-        return f(unwrapper<T>::apply(v0.template get_unchecked<T>()),\n-                 unwrapper<T>::apply(v1.template get_unchecked<T>())); // call binary functor\n-    }\n-};\n-\n-// comparator functors\n-struct equal_comp\n-{\n-    template <typename T>\n-    bool operator()(T const& lhs, T const& rhs) const\n-    {\n-        return lhs == rhs;\n-    }\n-};\n-\n-struct less_comp\n-{\n-    template <typename T>\n-    bool operator()(T const& lhs, T const& rhs) const\n-    {\n-        return lhs < rhs;\n-    }\n-};\n-\n-template <typename Variant, typename Comp>\n-class comparer\n-{\n-public:\n-    explicit comparer(Variant const& lhs) noexcept\n-        : lhs_(lhs) {}\n-    comparer& operator=(comparer const&) = delete;\n-    // visitor\n-    template <typename T>\n-    bool operator()(T const& rhs_content) const\n-    {\n-        T const& lhs_content = lhs_.template get_unchecked<T>();\n-        return Comp()(lhs_content, rhs_content);\n-    }\n-\n-private:\n-    Variant const& lhs_;\n-};\n-\n-// hashing visitor\n-struct hasher\n-{\n-    template <typename T>\n-    std::size_t operator()(const T& hashable) const\n-    {\n-        return std::hash<T>{}(hashable);\n-    }\n-};\n-\n-} // namespace detail\n-\n-struct no_init {};\n-\n-template <typename... Types>\n-class variant\n-{\n-    static_assert(sizeof...(Types) > 0, \"Template parameter type list of variant can not be empty.\");\n-    static_assert(!detail::disjunction<std::is_reference<Types>...>::value, \"Variant can not hold reference types. Maybe use std::reference_wrapper?\");\n-    static_assert(!detail::disjunction<std::is_array<Types>...>::value, \"Variant can not hold array types.\");\n-    static_assert(sizeof...(Types) < std::numeric_limits<type_index_t>::max(), \"Internal index type must be able to accommodate all alternatives.\");\n-private:\n-    static const std::size_t data_size = detail::static_max<sizeof(Types)...>::value;\n-    static const std::size_t data_align = detail::static_max<alignof(Types)...>::value;\n-public:\n-    struct adapted_variant_tag;\n-    using types = std::tuple<Types...>;\n-private:\n-    using first_type = typename std::tuple_element<0, types>::type;\n-    using data_type = typename std::aligned_storage<data_size, data_align>::type;\n-    using helper_type = detail::variant_helper<Types...>;\n-\n-    type_index_t type_index;\n-    data_type data;\n-\n-public:\n-    VARIANT_INLINE variant() noexcept(std::is_nothrow_default_constructible<first_type>::value)\n-        : type_index(sizeof...(Types)-1)\n-    {\n-        static_assert(std::is_default_constructible<first_type>::value, \"First type in variant must be default constructible to allow default construction of variant.\");\n-        new (&data) first_type();\n-    }\n-\n-    VARIANT_INLINE variant(no_init) noexcept\n-        : type_index(detail::invalid_value) {}\n-\n-    // http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers\n-    template <typename T, typename Traits = detail::value_traits<T, Types...>,\n-              typename Enable = typename std::enable_if<Traits::is_valid && !std::is_same<variant<Types...>, typename Traits::value_type>::value>::type >\n-    VARIANT_INLINE variant(T&& val) noexcept(std::is_nothrow_constructible<typename Traits::target_type, T&&>::value)\n-        : type_index(Traits::index)\n-    {\n-        new (&data) typename Traits::target_type(std::forward<T>(val));\n-    }\n-\n-    VARIANT_INLINE variant(variant<Types...> const& old)\n-        : type_index(old.type_index)\n-    {\n-        helper_type::copy(old.type_index, &old.data, &data);\n-    }\n-\n-    VARIANT_INLINE variant(variant<Types...>&& old)\n-        noexcept(detail::conjunction<std::is_nothrow_move_constructible<Types>...>::value)\n-        : type_index(old.type_index)\n-    {\n-        helper_type::move(old.type_index, &old.data, &data);\n-    }\n-\n-private:\n-    VARIANT_INLINE void copy_assign(variant<Types...> const& rhs)\n-    {\n-        helper_type::destroy(type_index, &data);\n-        type_index = detail::invalid_value;\n-        helper_type::copy(rhs.type_index, &rhs.data, &data);\n-        type_index = rhs.type_index;\n-    }\n-\n-    VARIANT_INLINE void move_assign(variant<Types...>&& rhs)\n-    {\n-        helper_type::destroy(type_index, &data);\n-        type_index = detail::invalid_value;\n-        helper_type::move(rhs.type_index, &rhs.data, &data);\n-        type_index = rhs.type_index;\n-    }\n-\n-public:\n-    VARIANT_INLINE variant<Types...>& operator=(variant<Types...>&& other)\n-    {\n-        move_assign(std::move(other));\n-        return *this;\n-    }\n-\n-    VARIANT_INLINE variant<Types...>& operator=(variant<Types...> const& other)\n-    {\n-        copy_assign(other);\n-        return *this;\n-    }\n-\n-    // conversions\n-    // move-assign\n-    template <typename T>\n-    VARIANT_INLINE variant<Types...>& operator=(T&& rhs) noexcept\n-    {\n-        variant<Types...> temp(std::forward<T>(rhs));\n-        move_assign(std::move(temp));\n-        return *this;\n-    }\n-\n-    // copy-assign\n-    template <typename T>\n-    VARIANT_INLINE variant<Types...>& operator=(T const& rhs)\n-    {\n-        variant<Types...> temp(rhs);\n-        copy_assign(temp);\n-        return *this;\n-    }\n-\n-    template <typename T, typename std::enable_if<\n-                          (detail::direct_type<T, Types...>::index != detail::invalid_value)>::type* = NULLPTR>\n-    VARIANT_INLINE bool is() const\n-    {\n-        return type_index == detail::direct_type<T, Types...>::index;\n-    }\n-\n-    template <typename T,typename std::enable_if<\n-                         (detail::direct_type<recursive_wrapper<T>, Types...>::index != detail::invalid_value)>::type* = NULLPTR>\n-    VARIANT_INLINE bool is() const\n-    {\n-        return type_index == detail::direct_type<recursive_wrapper<T>, Types...>::index;\n-    }\n-\n-    VARIANT_INLINE bool valid() const\n-    {\n-        return type_index != detail::invalid_value;\n-    }\n-\n-    template <typename T, typename... Args>\n-    VARIANT_INLINE void set(Args&&... args)\n-    {\n-        helper_type::destroy(type_index, &data);\n-        type_index = detail::invalid_value;\n-        new (&data) T(std::forward<Args>(args)...);\n-        type_index = detail::direct_type<T, Types...>::index;\n-    }\n-\n-    // get_unchecked<T>()\n-    template <typename T, typename std::enable_if<\n-                          (detail::direct_type<T, Types...>::index != detail::invalid_value)>::type* = NULLPTR>\n-    VARIANT_INLINE T& get_unchecked()\n-    {\n-        return *reinterpret_cast<T*>(&data);\n-    }\n-\n-#ifdef HAS_EXCEPTIONS\n-    // get<T>()\n-    template <typename T, typename std::enable_if<\n-                          (detail::direct_type<T, Types...>::index != detail::invalid_value)>::type* = NULLPTR>\n-    VARIANT_INLINE T& get()\n-    {\n-        if (type_index == detail::direct_type<T, Types...>::index)\n-        {\n-            return *reinterpret_cast<T*>(&data);\n-        }\n-        else\n-        {\n-            throw bad_variant_access(\"in get<T>()\");\n-        }\n-    }\n-#endif\n-\n-    template <typename T, typename std::enable_if<\n-                          (detail::direct_type<T, Types...>::index != detail::invalid_value)>::type* = NULLPTR>\n-    VARIANT_INLINE T const& get_unchecked() const\n-    {\n-        return *reinterpret_cast<T const*>(&data);\n-    }\n-\n-#ifdef HAS_EXCEPTIONS\n-    template <typename T, typename std::enable_if<\n-                          (detail::direct_type<T, Types...>::index != detail::invalid_value)>::type* = NULLPTR>\n-    VARIANT_INLINE T const& get() const\n-    {\n-        if (type_index == detail::direct_type<T, Types...>::index)\n-        {\n-            return *reinterpret_cast<T const*>(&data);\n-        }\n-        else\n-        {\n-            throw bad_variant_access(\"in get<T>()\");\n-        }\n-    }\n-#endif\n-\n-    // get_unchecked<T>() - T stored as recursive_wrapper<T>\n-    template <typename T, typename std::enable_if<\n-                          (detail::direct_type<recursive_wrapper<T>, Types...>::index != detail::invalid_value)>::type* = NULLPTR>\n-    VARIANT_INLINE T& get_unchecked()\n-    {\n-        return (*reinterpret_cast<recursive_wrapper<T>*>(&data)).get();\n-    }\n-\n-#ifdef HAS_EXCEPTIONS\n-    // get<T>() - T stored as recursive_wrapper<T>\n-    template <typename T, typename std::enable_if<\n-                          (detail::direct_type<recursive_wrapper<T>, Types...>::index != detail::invalid_value)>::type* = NULLPTR>\n-    VARIANT_INLINE T& get()\n-    {\n-        if (type_index == detail::direct_type<recursive_wrapper<T>, Types...>::index)\n-        {\n-            return (*reinterpret_cast<recursive_wrapper<T>*>(&data)).get();\n-        }\n-        else\n-        {\n-            throw bad_variant_access(\"in get<T>()\");\n-        }\n-    }\n-#endif\n-\n-    template <typename T, typename std::enable_if<\n-                          (detail::direct_type<recursive_wrapper<T>, Types...>::index != detail::invalid_value)>::type* = NULLPTR>\n-    VARIANT_INLINE T const& get_unchecked() const\n-    {\n-        return (*reinterpret_cast<recursive_wrapper<T> const*>(&data)).get();\n-    }\n-\n-#ifdef HAS_EXCEPTIONS\n-    template <typename T, typename std::enable_if<\n-                          (detail::direct_type<recursive_wrapper<T>, Types...>::index != detail::invalid_value)>::type* = NULLPTR>\n-    VARIANT_INLINE T const& get() const\n-    {\n-        if (type_index == detail::direct_type<recursive_wrapper<T>, Types...>::index)\n-        {\n-            return (*reinterpret_cast<recursive_wrapper<T> const*>(&data)).get();\n-        }\n-        else\n-        {\n-            throw bad_variant_access(\"in get<T>()\");\n-        }\n-    }\n-#endif\n-\n-    // get_unchecked<T>() - T stored as std::reference_wrapper<T>\n-    template <typename T, typename std::enable_if<\n-                          (detail::direct_type<std::reference_wrapper<T>, Types...>::index != detail::invalid_value)>::type* = NULLPTR>\n-    VARIANT_INLINE T& get_unchecked()\n-    {\n-        return (*reinterpret_cast<std::reference_wrapper<T>*>(&data)).get();\n-    }\n-\n-#ifdef HAS_EXCEPTIONS\n-    // get<T>() - T stored as std::reference_wrapper<T>\n-    template <typename T, typename std::enable_if<\n-                          (detail::direct_type<std::reference_wrapper<T>, Types...>::index != detail::invalid_value)>::type* = NULLPTR>\n-    VARIANT_INLINE T& get()\n-    {\n-        if (type_index == detail::direct_type<std::reference_wrapper<T>, Types...>::index)\n-        {\n-            return (*reinterpret_cast<std::reference_wrapper<T>*>(&data)).get();\n-        }\n-        else\n-        {\n-            throw bad_variant_access(\"in get<T>()\");\n-        }\n-    }\n-#endif\n-\n-    template <typename T, typename std::enable_if<\n-                          (detail::direct_type<std::reference_wrapper<T const>, Types...>::index != detail::invalid_value)>::type* = NULLPTR>\n-    VARIANT_INLINE T const& get_unchecked() const\n-    {\n-        return (*reinterpret_cast<std::reference_wrapper<T const> const*>(&data)).get();\n-    }\n-\n-#ifdef HAS_EXCEPTIONS\n-    template <typename T, typename std::enable_if<\n-                          (detail::direct_type<std::reference_wrapper<T const>, Types...>::index != detail::invalid_value)>::type* = NULLPTR>\n-    VARIANT_INLINE T const& get() const\n-    {\n-        if (type_index == detail::direct_type<std::reference_wrapper<T const>, Types...>::index)\n-        {\n-            return (*reinterpret_cast<std::reference_wrapper<T const> const*>(&data)).get();\n-        }\n-        else\n-        {\n-            throw bad_variant_access(\"in get<T>()\");\n-        }\n-    }\n-#endif\n-\n-    // This function is deprecated because it returns an internal index field.\n-    // Use which() instead.\n-    ARROW_DEPRECATED(\"Use which() instead\")\n-    VARIANT_INLINE type_index_t get_type_index() const\n-    {\n-        return type_index;\n-    }\n-\n-    VARIANT_INLINE int which() const noexcept\n-    {\n-        return static_cast<int>(sizeof...(Types) - type_index - 1);\n-    }\n-\n-    template <typename T, typename std::enable_if<\n-                          (detail::direct_type<T, Types...>::index != detail::invalid_value)>::type* = NULLPTR>\n-    VARIANT_INLINE static constexpr int which() noexcept\n-    {\n-        return static_cast<int>(sizeof...(Types)-detail::direct_type<T, Types...>::index - 1);\n-    }\n-\n-    // visitor\n-    // unary\n-    template <typename F, typename V, typename R = typename detail::result_of_unary_visit<F, first_type>::type>\n-    auto VARIANT_INLINE static visit(V const& v, F&& f)\n-        -> decltype(detail::dispatcher<F, V, R, Types...>::apply_const(v, std::forward<F>(f)))\n-    {\n-        return detail::dispatcher<F, V, R, Types...>::apply_const(v, std::forward<F>(f));\n-    }\n-    // non-const\n-    template <typename F, typename V, typename R = typename detail::result_of_unary_visit<F, first_type>::type>\n-    auto VARIANT_INLINE static visit(V& v, F&& f)\n-        -> decltype(detail::dispatcher<F, V, R, Types...>::apply(v, std::forward<F>(f)))\n-    {\n-        return detail::dispatcher<F, V, R, Types...>::apply(v, std::forward<F>(f));\n-    }\n-\n-    // binary\n-    // const\n-    template <typename F, typename V, typename R = typename detail::result_of_binary_visit<F, first_type>::type>\n-    auto VARIANT_INLINE static binary_visit(V const& v0, V const& v1, F&& f)\n-        -> decltype(detail::binary_dispatcher<F, V, R, Types...>::apply_const(v0, v1, std::forward<F>(f)))\n-    {\n-        return detail::binary_dispatcher<F, V, R, Types...>::apply_const(v0, v1, std::forward<F>(f));\n-    }\n-    // non-const\n-    template <typename F, typename V, typename R = typename detail::result_of_binary_visit<F, first_type>::type>\n-    auto VARIANT_INLINE static binary_visit(V& v0, V& v1, F&& f)\n-        -> decltype(detail::binary_dispatcher<F, V, R, Types...>::apply(v0, v1, std::forward<F>(f)))\n-    {\n-        return detail::binary_dispatcher<F, V, R, Types...>::apply(v0, v1, std::forward<F>(f));\n-    }\n-\n-    // match\n-    // unary\n-    template <typename... Fs>\n-    auto VARIANT_INLINE match(Fs&&... fs) const\n-        -> decltype(variant::visit(*this, ::arrow::util::make_visitor(std::forward<Fs>(fs)...)))\n-    {\n-        return variant::visit(*this, ::arrow::util::make_visitor(std::forward<Fs>(fs)...));\n-    }\n-    // non-const\n-    template <typename... Fs>\n-    auto VARIANT_INLINE match(Fs&&... fs)\n-        -> decltype(variant::visit(*this, ::arrow::util::make_visitor(std::forward<Fs>(fs)...)))\n-    {\n-        return variant::visit(*this, ::arrow::util::make_visitor(std::forward<Fs>(fs)...));\n-    }\n-\n-    ~variant() noexcept // no-throw destructor\n-    {\n-        helper_type::destroy(type_index, &data);\n-    }\n-\n-    // comparison operators\n-    // equality\n-    VARIANT_INLINE bool operator==(variant const& rhs) const\n-    {\n-        assert(valid() && rhs.valid());\n-        if (this->which() != rhs.which())\n-        {\n-            return false;\n-        }\n-        detail::comparer<variant, detail::equal_comp> visitor(*this);\n-        return visit(rhs, visitor);\n-    }\n-\n-    VARIANT_INLINE bool operator!=(variant const& rhs) const\n-    {\n-        return !(*this == rhs);\n-    }\n-\n-    // less than\n-    VARIANT_INLINE bool operator<(variant const& rhs) const\n-    {\n-        assert(valid() && rhs.valid());\n-        if (this->which() != rhs.which())\n-        {\n-            return this->which() < rhs.which();\n-        }\n-        detail::comparer<variant, detail::less_comp> visitor(*this);\n-        return visit(rhs, visitor);\n-    }\n-    VARIANT_INLINE bool operator>(variant const& rhs) const\n-    {\n-        return rhs < *this;\n-    }\n-    VARIANT_INLINE bool operator<=(variant const& rhs) const\n-    {\n-        return !(*this > rhs);\n-    }\n-    VARIANT_INLINE bool operator>=(variant const& rhs) const\n-    {\n-        return !(*this < rhs);\n-    }\n-};\n-\n-// unary visitor interface\n-// const\n-template <typename F, typename V>\n-auto VARIANT_INLINE apply_visitor(F&& f, V const& v) -> decltype(V::visit(v, std::forward<F>(f)))\n-{\n-    return V::visit(v, std::forward<F>(f));\n-}\n-\n-// non-const\n-template <typename F, typename V>\n-auto VARIANT_INLINE apply_visitor(F&& f, V& v) -> decltype(V::visit(v, std::forward<F>(f)))\n-{\n-    return V::visit(v, std::forward<F>(f));\n-}\n-\n-// binary visitor interface\n-// const\n-template <typename F, typename V>\n-auto VARIANT_INLINE apply_visitor(F&& f, V const& v0, V const& v1) -> decltype(V::binary_visit(v0, v1, std::forward<F>(f)))\n-{\n-    return V::binary_visit(v0, v1, std::forward<F>(f));\n-}\n-\n-// non-const\n-template <typename F, typename V>\n-auto VARIANT_INLINE apply_visitor(F&& f, V& v0, V& v1) -> decltype(V::binary_visit(v0, v1, std::forward<F>(f)))\n-{\n-    return V::binary_visit(v0, v1, std::forward<F>(f));\n-}\n-\n-// getter interface\n-\n-#ifdef HAS_EXCEPTIONS\n-template <typename ResultType, typename T>\n-auto get(T& var)->decltype(var.template get<ResultType>())\n-{\n-    return var.template get<ResultType>();\n-}\n-#endif\n-\n-template <typename ResultType, typename T>\n-ResultType& get_unchecked(T& var)\n-{\n-    return var.template get_unchecked<ResultType>();\n-}\n-\n-#ifdef HAS_EXCEPTIONS\n-template <typename ResultType, typename T>\n-auto get(T const& var)->decltype(var.template get<ResultType>())\n-{\n-    return var.template get<ResultType>();\n-}\n-#endif\n-\n-template <typename ResultType, typename T>\n-ResultType const& get_unchecked(T const& var)\n-{\n-    return var.template get_unchecked<ResultType>();\n-}\n-// variant_size\n-template <typename T>\n-struct variant_size;\n-\n-//variable templates is c++14\n-//template <typename T>\n-//constexpr std::size_t variant_size_v = variant_size<T>::value;\n-\n-template <typename T>\n-struct variant_size<const T>\n-    : variant_size<T> {};\n-\n-template <typename T>\n-struct variant_size<volatile T>\n-    : variant_size<T> {};\n-\n-template <typename T>\n-struct variant_size<const volatile T>\n-    : variant_size<T> {};\n-\n-template <typename... Types>\n-struct variant_size<variant<Types...>>\n-    : std::integral_constant<std::size_t, sizeof...(Types)> {};\n-\n-// variant_alternative\n-template <std::size_t Index, typename T>\n-struct variant_alternative;\n-\n-#if defined(__clang__)\n-#if __has_builtin(__type_pack_element)\n-#define has_type_pack_element\n-#endif\n-#endif\n-\n-#if defined(has_type_pack_element)\n-template <std::size_t Index, typename ...Types>\n-struct variant_alternative<Index, variant<Types...>>\n-{\n-    static_assert(sizeof...(Types) > Index , \"Index out of range\");\n-    using type = __type_pack_element<Index, Types...>;\n-};\n-#else\n-template <std::size_t Index, typename First, typename...Types>\n-struct variant_alternative<Index, variant<First, Types...>>\n-    : variant_alternative<Index - 1, variant<Types...>>\n-{\n-    static_assert(sizeof...(Types) > Index -1 , \"Index out of range\");\n-};\n-\n-template <typename First, typename...Types>\n-struct variant_alternative<0, variant<First, Types...>>\n-{\n-    using type = First;\n-};\n-\n-#endif\n-\n-template <size_t Index, typename T>\n-using variant_alternative_t = typename variant_alternative<Index, T>::type;\n-\n-template <size_t Index, typename T>\n-struct variant_alternative<Index, const T>\n-    : std::add_const<variant_alternative<Index, T>> {};\n-\n-template <size_t Index, typename T>\n-struct variant_alternative<Index, volatile T>\n-    : std::add_volatile<variant_alternative<Index, T>> {};\n-\n-template <size_t Index, typename T>\n-struct variant_alternative<Index, const volatile T>\n-    : std::add_cv<variant_alternative<Index, T>> {};\n+using mapbox::util::apply_visitor;  // seems akin to std::visit\n+using mapbox::util::bad_variant_access;\n+using mapbox::util::get;\n+using mapbox::util::variant;\n \n-} // namespace util\n-} // namespace arrow\n+}  // namespace util\n+}  // namespace arrow\n \n-#endif // ARROW_UTIL_VARIANT_H\n+#endif  // ARROW_UTIL_VARIANT_H\ndiff --git a/cpp/src/arrow/util/variant/optional.h b/cpp/src/arrow/util/variant/optional.h\ndeleted file mode 100644\nindex 4c6671061f..0000000000\n--- a/cpp/src/arrow/util/variant/optional.h\n+++ /dev/null\n@@ -1,100 +0,0 @@\n-// Copyright (c) MapBox\n-// All rights reserved.\n-//\n-// Redistribution and use in source and binary forms, with or without modification,\n-// are permitted provided that the following conditions are met:\n-//\n-// - Redistributions of source code must retain the above copyright notice, this\n-//   list of conditions and the following disclaimer.\n-// - Redistributions in binary form must reproduce the above copyright notice, this\n-//   list of conditions and the following disclaimer in the documentation and/or\n-//   other materials provided with the distribution.\n-// - Neither the name \"MapBox\" nor the names of its contributors may be\n-//   used to endorse or promote products derived from this software without\n-//   specific prior written permission.\n-//\n-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n-// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n-// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n-// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n-// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-#ifndef ARROW_UTIL_VARIANT_OPTIONAL_H\n-#define ARROW_UTIL_VARIANT_OPTIONAL_H\n-\n-#pragma message(\"This implementation of optional is deprecated. See https://github.com/mapbox/variant/issues/64.\")\n-\n-#include <type_traits>\n-#include <utility>\n-\n-#include <arrow/util/variant.h>\n-\n-namespace arrow {\n-namespace util {\n-\n-template <typename T>\n-class optional\n-{\n-    static_assert(!std::is_reference<T>::value, \"optional doesn't support references\");\n-\n-    struct none_type\n-    {\n-    };\n-\n-    variant<none_type, T> variant_;\n-\n-public:\n-    optional() = default;\n-\n-    optional(optional const& rhs)\n-    {\n-        if (this != &rhs)\n-        { // protect against invalid self-assignment\n-            variant_ = rhs.variant_;\n-        }\n-    }\n-\n-    optional(T const& v) { variant_ = v; }\n-\n-    explicit operator bool() const noexcept { return variant_.template is<T>(); }\n-\n-    T const& get() const { return variant_.template get<T>(); }\n-    T& get() { return variant_.template get<T>(); }\n-\n-    T const& operator*() const { return this->get(); }\n-    T operator*() { return this->get(); }\n-\n-    optional& operator=(T const& v)\n-    {\n-        variant_ = v;\n-        return *this;\n-    }\n-\n-    optional& operator=(optional const& rhs)\n-    {\n-        if (this != &rhs)\n-        {\n-            variant_ = rhs.variant_;\n-        }\n-        return *this;\n-    }\n-\n-    template <typename... Args>\n-    void emplace(Args&&... args)\n-    {\n-        variant_ = T{std::forward<Args>(args)...};\n-    }\n-\n-    void reset() { variant_ = none_type{}; }\n-\n-}; // class optional\n-\n-} // namespace util\n-} // namespace arrow\n-\n-#endif // ARROW_UTIL_VARIANT_OPTIONAL_H\ndiff --git a/cpp/src/arrow/util/variant/variant_cast.h b/cpp/src/arrow/util/variant/variant_cast.h\ndeleted file mode 100644\nindex 71ae80b5df..0000000000\n--- a/cpp/src/arrow/util/variant/variant_cast.h\n+++ /dev/null\n@@ -1,114 +0,0 @@\n-// Copyright (c) MapBox\n-// All rights reserved.\n-//\n-// Redistribution and use in source and binary forms, with or without modification,\n-// are permitted provided that the following conditions are met:\n-//\n-// - Redistributions of source code must retain the above copyright notice, this\n-//   list of conditions and the following disclaimer.\n-// - Redistributions in binary form must reproduce the above copyright notice, this\n-//   list of conditions and the following disclaimer in the documentation and/or\n-//   other materials provided with the distribution.\n-// - Neither the name \"MapBox\" nor the names of its contributors may be\n-//   used to endorse or promote products derived from this software without\n-//   specific prior written permission.\n-//\n-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n-// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n-// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n-// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n-// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-#ifndef ARROW_UTIL_VARIANT_CAST_H\n-#define ARROW_UTIL_VARIANT_CAST_H\n-\n-#include <type_traits>\n-\n-#include \"arrow/util/macros.h\"\n-\n-namespace arrow {\n-namespace util {\n-\n-namespace detail {\n-\n-template <class T>\n-class static_caster\n-{\n-public:\n-    template <class V>\n-    T& operator()(V& v) const\n-    {\n-        return static_cast<T&>(v);\n-    }\n-};\n-\n-template <class T>\n-class dynamic_caster\n-{\n-public:\n-    using result_type = T&;\n-    template <class V>\n-    T& operator()(V& v, typename std::enable_if<!std::is_polymorphic<V>::value>::type* = NULLPTR) const\n-    {\n-        throw std::bad_cast();\n-    }\n-    template <class V>\n-    T& operator()(V& v, typename std::enable_if<std::is_polymorphic<V>::value>::type* = NULLPTR) const\n-    {\n-        return dynamic_cast<T&>(v);\n-    }\n-};\n-\n-template <class T>\n-class dynamic_caster<T*>\n-{\n-public:\n-    using result_type = T*;\n-    template <class V>\n-    T* operator()(V& v, typename std::enable_if<!std::is_polymorphic<V>::value>::type* = NULLPTR) const\n-    {\n-        return NULLPTR;\n-    }\n-    template <class V>\n-    T* operator()(V& v, typename std::enable_if<std::is_polymorphic<V>::value>::type* = NULLPTR) const\n-    {\n-        return dynamic_cast<T*>(&v);\n-    }\n-};\n-}\n-\n-template <class T, class V>\n-typename detail::dynamic_caster<T>::result_type\n-dynamic_variant_cast(V& v)\n-{\n-    return arrow::util::apply_visitor(detail::dynamic_caster<T>(), v);\n-}\n-\n-template <class T, class V>\n-typename detail::dynamic_caster<const T>::result_type\n-dynamic_variant_cast(const V& v)\n-{\n-    return arrow::util::apply_visitor(detail::dynamic_caster<const T>(), v);\n-}\n-\n-template <class T, class V>\n-T& static_variant_cast(V& v)\n-{\n-    return arrow::util::apply_visitor(detail::static_caster<T>(), v);\n-}\n-\n-template <class T, class V>\n-const T& static_variant_cast(const V& v)\n-{\n-    return arrow::util::apply_visitor(detail::static_caster<const T>(), v);\n-}\n-\n-}  // namespace util\n-}  // namespace arrow\n-\n-#endif // ARROW_UTIL_VARIANT_CAST_H\ndiff --git a/cpp/src/arrow/util/variant/variant_io.h b/cpp/src/arrow/util/variant/variant_io.h\ndeleted file mode 100644\nindex 5541a81f70..0000000000\n--- a/cpp/src/arrow/util/variant/variant_io.h\n+++ /dev/null\n@@ -1,72 +0,0 @@\n-// Copyright (c) MapBox\n-// All rights reserved.\n-//\n-// Redistribution and use in source and binary forms, with or without modification,\n-// are permitted provided that the following conditions are met:\n-//\n-// - Redistributions of source code must retain the above copyright notice, this\n-//   list of conditions and the following disclaimer.\n-// - Redistributions in binary form must reproduce the above copyright notice, this\n-//   list of conditions and the following disclaimer in the documentation and/or\n-//   other materials provided with the distribution.\n-// - Neither the name \"MapBox\" nor the names of its contributors may be\n-//   used to endorse or promote products derived from this software without\n-//   specific prior written permission.\n-//\n-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n-// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n-// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n-// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n-// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-#ifndef ARROW_UTIL_VARIANT_IO_H\n-#define ARROW_UTIL_VARIANT_IO_H\n-\n-#include <iosfwd>\n-\n-#include <arrow/util/variant.h>\n-\n-namespace arrow {\n-namespace util {\n-\n-namespace detail {\n-// operator<< helper\n-template <typename Out>\n-class printer\n-{\n-public:\n-    explicit printer(Out& out)\n-        : out_(out) {}\n-    printer& operator=(printer const&) = delete;\n-\n-    // visitor\n-    template <typename T>\n-    void operator()(T const& operand) const\n-    {\n-        out_ << operand;\n-    }\n-\n-private:\n-    Out& out_;\n-};\n-}\n-\n-// operator<<\n-template <typename CharT, typename Traits, typename... Types>\n-VARIANT_INLINE std::basic_ostream<CharT, Traits>&\n-operator<<(std::basic_ostream<CharT, Traits>& out, variant<Types...> const& rhs)\n-{\n-    detail::printer<std::basic_ostream<CharT, Traits>> visitor(out);\n-    apply_visitor(visitor, rhs);\n-    return out;\n-}\n-\n-} // namespace util\n-} // namespace arrow\n-\n-#endif // ARROW_UTIL_VARIANT_IO_H\ndiff --git a/cpp/src/arrow/util/variant/variant_visitor.h b/cpp/src/arrow/util/variant/variant_visitor.h\ndeleted file mode 100644\nindex 66b1dfea3d..0000000000\n--- a/cpp/src/arrow/util/variant/variant_visitor.h\n+++ /dev/null\n@@ -1,69 +0,0 @@\n-// Copyright (c) MapBox\n-// All rights reserved.\n-//\n-// Redistribution and use in source and binary forms, with or without modification,\n-// are permitted provided that the following conditions are met:\n-//\n-// - Redistributions of source code must retain the above copyright notice, this\n-//   list of conditions and the following disclaimer.\n-// - Redistributions in binary form must reproduce the above copyright notice, this\n-//   list of conditions and the following disclaimer in the documentation and/or\n-//   other materials provided with the distribution.\n-// - Neither the name \"MapBox\" nor the names of its contributors may be\n-//   used to endorse or promote products derived from this software without\n-//   specific prior written permission.\n-//\n-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n-// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n-// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n-// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n-// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-#ifndef ARROW_UTIL_VARIANT_VISITOR_HPP\n-#define ARROW_UTIL_VARIANT_VISITOR_HPP\n-\n-#include <utility>\n-\n-namespace arrow {\n-namespace util {\n-\n-template <typename... Fns>\n-struct visitor;\n-\n-template <typename Fn>\n-struct visitor<Fn> : Fn\n-{\n-    using Fn::operator();\n-\n-    template<typename T>\n-    visitor(T&& fn) : Fn(std::forward<T>(fn)) {}\n-};\n-\n-template <typename Fn, typename... Fns>\n-struct visitor<Fn, Fns...> : Fn, visitor<Fns...>\n-{\n-    using Fn::operator();\n-    using visitor<Fns...>::operator();\n-\n-    template<typename T, typename... Ts>\n-    visitor(T&& fn, Ts&&... fns)\n-        : Fn(std::forward<T>(fn))\n-        , visitor<Fns...>(std::forward<Ts>(fns)...) {}\n-};\n-\n-template <typename... Fns>\n-visitor<typename std::decay<Fns>::type...> make_visitor(Fns&&... fns)\n-{\n-    return visitor<typename std::decay<Fns>::type...>\n-        (std::forward<Fns>(fns)...);\n-}\n-\n-} // namespace util\n-} // namespace arrow\n-\n-#endif // ARROW_UTIL_VARIANT_VISITOR_HPP\ndiff --git a/cpp/src/arrow/util/string_view/CMakeLists.txt b/cpp/src/arrow/vendored/CMakeLists.txt\nsimilarity index 88%\nrename from cpp/src/arrow/util/string_view/CMakeLists.txt\nrename to cpp/src/arrow/vendored/CMakeLists.txt\nindex 7e553077db..04ea67aa45 100644\n--- a/cpp/src/arrow/util/string_view/CMakeLists.txt\n+++ b/cpp/src/arrow/vendored/CMakeLists.txt\n@@ -15,6 +15,6 @@\n # specific language governing permissions and limitations\n # under the License.\n \n-install(FILES\n-  string_view.hpp\n-  DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}/arrow/util/string_view\")\n+ARROW_INSTALL_ALL_HEADERS(\"arrow/vendored\")\n+\n+add_subdirectory(variant)\ndiff --git a/cpp/src/arrow/util/date.h b/cpp/src/arrow/vendored/date.h\nsimilarity index 100%\nrename from cpp/src/arrow/util/date.h\nrename to cpp/src/arrow/vendored/date.h\ndiff --git a/cpp/src/arrow/util/string_view/string_view.hpp b/cpp/src/arrow/vendored/string_view.hpp\nsimilarity index 100%\nrename from cpp/src/arrow/util/string_view/string_view.hpp\nrename to cpp/src/arrow/vendored/string_view.hpp\ndiff --git a/cpp/src/arrow/util/variant/CMakeLists.txt b/cpp/src/arrow/vendored/variant/CMakeLists.txt\nsimilarity index 83%\nrename from cpp/src/arrow/util/variant/CMakeLists.txt\nrename to cpp/src/arrow/vendored/variant/CMakeLists.txt\nindex b7a5692b62..de26f938d7 100644\n--- a/cpp/src/arrow/util/variant/CMakeLists.txt\n+++ b/cpp/src/arrow/vendored/variant/CMakeLists.txt\n@@ -15,8 +15,4 @@\n # specific language governing permissions and limitations\n # under the License.\n \n-#######################################\n-# arrow_util_variant\n-#######################################\n-\n-ARROW_INSTALL_ALL_HEADERS(\"arrow/util/variant\")\n+ARROW_INSTALL_ALL_HEADERS(\"arrow/vendored/variant\")\ndiff --git a/cpp/src/arrow/util/variant/recursive_wrapper.h b/cpp/src/arrow/vendored/variant/recursive_wrapper.hpp\nsimilarity index 89%\nrename from cpp/src/arrow/util/variant/recursive_wrapper.h\nrename to cpp/src/arrow/vendored/variant/recursive_wrapper.hpp\nindex c9d9385394..96b6a3f217 100644\n--- a/cpp/src/arrow/util/variant/recursive_wrapper.h\n+++ b/cpp/src/arrow/vendored/variant/recursive_wrapper.hpp\n@@ -1,7 +1,9 @@\n-#ifndef ARROW_UTIL_VARIANT_RECURSIVE_WRAPPER_H\n-#define ARROW_UTIL_VARIANT_RECURSIVE_WRAPPER_H\n+// Vendored from https://github.com/mapbox/variant at tag v1.1.5\n \n-// Based on variant/recursive_wrapper.h from boost.\n+#ifndef MAPBOX_UTIL_RECURSIVE_WRAPPER_HPP\n+#define MAPBOX_UTIL_RECURSIVE_WRAPPER_HPP\n+\n+// Based on variant/recursive_wrapper.hpp from boost.\n //\n // Original license:\n //\n@@ -15,7 +17,7 @@\n #include <cassert>\n #include <utility>\n \n-namespace arrow {\n+namespace mapbox {\n namespace util {\n \n template <typename T>\n@@ -117,6 +119,6 @@ inline void swap(recursive_wrapper<T>& lhs, recursive_wrapper<T>& rhs) noexcept\n     lhs.swap(rhs);\n }\n } // namespace util\n-} // namespace arrow\n+} // namespace mapbox\n \n-#endif // ARROW_UTIL_VARIANT_RECURSIVE_WRAPPER_H\n+#endif // MAPBOX_UTIL_RECURSIVE_WRAPPER_HPP\ndiff --git a/cpp/src/arrow/vendored/variant/variant.hpp b/cpp/src/arrow/vendored/variant/variant.hpp\nnew file mode 100644\nindex 0000000000..bb399dece1\n--- /dev/null\n+++ b/cpp/src/arrow/vendored/variant/variant.hpp\n@@ -0,0 +1,1029 @@\n+// Vendored from https://github.com/mapbox/variant at tag v1.1.5\n+\n+#ifndef MAPBOX_UTIL_VARIANT_HPP\n+#define MAPBOX_UTIL_VARIANT_HPP\n+\n+#include <cassert>\n+#include <cstddef>   // size_t\n+#include <new>       // operator new\n+#include <stdexcept> // runtime_error\n+#include <string>\n+#include <tuple>\n+#include <type_traits>\n+#include <typeinfo>\n+#include <utility>\n+#include <functional>\n+\n+#include \"recursive_wrapper.hpp\"\n+#include \"variant_visitor.hpp\"\n+\n+// clang-format off\n+// [[deprecated]] is only available in C++14, use this for the time being\n+#if __cplusplus <= 201103L\n+# ifdef __GNUC__\n+#  define MAPBOX_VARIANT_DEPRECATED __attribute__((deprecated))\n+# elif defined(_MSC_VER)\n+#  define MAPBOX_VARIANT_DEPRECATED __declspec(deprecated)\n+# else\n+#  define MAPBOX_VARIANT_DEPRECATED\n+# endif\n+#else\n+#  define MAPBOX_VARIANT_DEPRECATED [[deprecated]]\n+#endif\n+\n+\n+#ifdef _MSC_VER\n+// https://msdn.microsoft.com/en-us/library/bw1hbe6y.aspx\n+# ifdef NDEBUG\n+#  define VARIANT_INLINE __forceinline\n+# else\n+#  define VARIANT_INLINE //__declspec(noinline)\n+# endif\n+#else\n+# ifdef NDEBUG\n+#  define VARIANT_INLINE //inline __attribute__((always_inline))\n+# else\n+#  define VARIANT_INLINE __attribute__((noinline))\n+# endif\n+#endif\n+// clang-format on\n+\n+// Exceptions\n+#if defined( __EXCEPTIONS) || defined( _MSC_VER)\n+#define HAS_EXCEPTIONS\n+#endif\n+\n+#define VARIANT_MAJOR_VERSION 1\n+#define VARIANT_MINOR_VERSION 1\n+#define VARIANT_PATCH_VERSION 0\n+\n+#define VARIANT_VERSION (VARIANT_MAJOR_VERSION * 100000) + (VARIANT_MINOR_VERSION * 100) + (VARIANT_PATCH_VERSION)\n+\n+namespace mapbox {\n+namespace util {\n+\n+// XXX This should derive from std::logic_error instead of std::runtime_error.\n+//     See https://github.com/mapbox/variant/issues/48 for details.\n+class bad_variant_access : public std::runtime_error\n+{\n+\n+public:\n+    explicit bad_variant_access(const std::string& what_arg)\n+        : runtime_error(what_arg) {}\n+\n+    explicit bad_variant_access(const char* what_arg)\n+        : runtime_error(what_arg) {}\n+\n+}; // class bad_variant_access\n+\n+template <typename R = void>\n+struct MAPBOX_VARIANT_DEPRECATED static_visitor\n+{\n+    using result_type = R;\n+\n+protected:\n+    static_visitor() {}\n+    ~static_visitor() {}\n+};\n+\n+namespace detail {\n+\n+static constexpr std::size_t invalid_value = std::size_t(-1);\n+\n+template <typename T, typename... Types>\n+struct direct_type;\n+\n+template <typename T, typename First, typename... Types>\n+struct direct_type<T, First, Types...>\n+{\n+    static constexpr std::size_t index = std::is_same<T, First>::value\n+        ? sizeof...(Types)\n+        : direct_type<T, Types...>::index;\n+};\n+\n+template <typename T>\n+struct direct_type<T>\n+{\n+    static constexpr std::size_t index = invalid_value;\n+};\n+\n+#if __cpp_lib_logical_traits >= 201510L\n+\n+using std::conjunction;\n+using std::disjunction;\n+\n+#else\n+\n+template <typename...>\n+struct conjunction : std::true_type {};\n+\n+template <typename B1>\n+struct conjunction<B1> : B1 {};\n+\n+template <typename B1, typename B2>\n+struct conjunction<B1, B2> : std::conditional<B1::value, B2, B1>::type {};\n+\n+template <typename B1, typename... Bs>\n+struct conjunction<B1, Bs...> : std::conditional<B1::value, conjunction<Bs...>, B1>::type {};\n+\n+template <typename...>\n+struct disjunction : std::false_type {};\n+\n+template <typename B1>\n+struct disjunction<B1> : B1 {};\n+\n+template <typename B1, typename B2>\n+struct disjunction<B1, B2> : std::conditional<B1::value, B1, B2>::type {};\n+\n+template <typename B1, typename... Bs>\n+struct disjunction<B1, Bs...> : std::conditional<B1::value, B1, disjunction<Bs...>>::type {};\n+\n+#endif\n+\n+template <typename T, typename... Types>\n+struct convertible_type;\n+\n+template <typename T, typename First, typename... Types>\n+struct convertible_type<T, First, Types...>\n+{\n+    static constexpr std::size_t index = std::is_convertible<T, First>::value\n+        ? disjunction<std::is_convertible<T, Types>...>::value ? invalid_value : sizeof...(Types)\n+        : convertible_type<T, Types...>::index;\n+};\n+\n+template <typename T>\n+struct convertible_type<T>\n+{\n+    static constexpr std::size_t index = invalid_value;\n+};\n+\n+template <typename T, typename... Types>\n+struct value_traits\n+{\n+    using value_type = typename std::remove_const<typename std::remove_reference<T>::type>::type;\n+    static constexpr std::size_t direct_index = direct_type<value_type, Types...>::index;\n+    static constexpr bool is_direct = direct_index != invalid_value;\n+    static constexpr std::size_t index = is_direct ? direct_index : convertible_type<value_type, Types...>::index;\n+    static constexpr bool is_valid = index != invalid_value;\n+    static constexpr std::size_t tindex = is_valid ? sizeof...(Types)-index : 0;\n+    using target_type = typename std::tuple_element<tindex, std::tuple<void, Types...>>::type;\n+};\n+\n+template <typename T, typename R = void>\n+struct enable_if_type\n+{\n+    using type = R;\n+};\n+\n+template <typename F, typename V, typename Enable = void>\n+struct result_of_unary_visit\n+{\n+    using type = typename std::result_of<F(V&)>::type;\n+};\n+\n+template <typename F, typename V>\n+struct result_of_unary_visit<F, V, typename enable_if_type<typename F::result_type>::type>\n+{\n+    using type = typename F::result_type;\n+};\n+\n+template <typename F, typename V, typename Enable = void>\n+struct result_of_binary_visit\n+{\n+    using type = typename std::result_of<F(V&, V&)>::type;\n+};\n+\n+template <typename F, typename V>\n+struct result_of_binary_visit<F, V, typename enable_if_type<typename F::result_type>::type>\n+{\n+    using type = typename F::result_type;\n+};\n+\n+template <std::size_t arg1, std::size_t... others>\n+struct static_max;\n+\n+template <std::size_t arg>\n+struct static_max<arg>\n+{\n+    static const std::size_t value = arg;\n+};\n+\n+template <std::size_t arg1, std::size_t arg2, std::size_t... others>\n+struct static_max<arg1, arg2, others...>\n+{\n+    static const std::size_t value = arg1 >= arg2 ? static_max<arg1, others...>::value : static_max<arg2, others...>::value;\n+};\n+\n+template <typename... Types>\n+struct variant_helper;\n+\n+template <typename T, typename... Types>\n+struct variant_helper<T, Types...>\n+{\n+    VARIANT_INLINE static void destroy(const std::size_t type_index, void* data)\n+    {\n+        if (type_index == sizeof...(Types))\n+        {\n+            reinterpret_cast<T*>(data)->~T();\n+        }\n+        else\n+        {\n+            variant_helper<Types...>::destroy(type_index, data);\n+        }\n+    }\n+\n+    VARIANT_INLINE static void move(const std::size_t old_type_index, void* old_value, void* new_value)\n+    {\n+        if (old_type_index == sizeof...(Types))\n+        {\n+            new (new_value) T(std::move(*reinterpret_cast<T*>(old_value)));\n+        }\n+        else\n+        {\n+            variant_helper<Types...>::move(old_type_index, old_value, new_value);\n+        }\n+    }\n+\n+    VARIANT_INLINE static void copy(const std::size_t old_type_index, const void* old_value, void* new_value)\n+    {\n+        if (old_type_index == sizeof...(Types))\n+        {\n+            new (new_value) T(*reinterpret_cast<const T*>(old_value));\n+        }\n+        else\n+        {\n+            variant_helper<Types...>::copy(old_type_index, old_value, new_value);\n+        }\n+    }\n+};\n+\n+template <>\n+struct variant_helper<>\n+{\n+    VARIANT_INLINE static void destroy(const std::size_t, void*) {}\n+    VARIANT_INLINE static void move(const std::size_t, void*, void*) {}\n+    VARIANT_INLINE static void copy(const std::size_t, const void*, void*) {}\n+};\n+\n+template <typename T>\n+struct unwrapper\n+{\n+    static T const& apply_const(T const& obj) { return obj; }\n+    static T& apply(T& obj) { return obj; }\n+};\n+\n+template <typename T>\n+struct unwrapper<recursive_wrapper<T>>\n+{\n+    static auto apply_const(recursive_wrapper<T> const& obj)\n+        -> typename recursive_wrapper<T>::type const&\n+    {\n+        return obj.get();\n+    }\n+    static auto apply(recursive_wrapper<T>& obj)\n+        -> typename recursive_wrapper<T>::type&\n+    {\n+        return obj.get();\n+    }\n+};\n+\n+template <typename T>\n+struct unwrapper<std::reference_wrapper<T>>\n+{\n+    static auto apply_const(std::reference_wrapper<T> const& obj)\n+        -> typename std::reference_wrapper<T>::type const&\n+    {\n+        return obj.get();\n+    }\n+    static auto apply(std::reference_wrapper<T>& obj)\n+        -> typename std::reference_wrapper<T>::type&\n+    {\n+        return obj.get();\n+    }\n+};\n+\n+template <typename F, typename V, typename R, typename... Types>\n+struct dispatcher;\n+\n+template <typename F, typename V, typename R, typename T, typename... Types>\n+struct dispatcher<F, V, R, T, Types...>\n+{\n+    VARIANT_INLINE static R apply_const(V const& v, F&& f)\n+    {\n+        if (v.template is<T>())\n+        {\n+            return f(unwrapper<T>::apply_const(v.template get_unchecked<T>()));\n+        }\n+        else\n+        {\n+            return dispatcher<F, V, R, Types...>::apply_const(v, std::forward<F>(f));\n+        }\n+    }\n+\n+    VARIANT_INLINE static R apply(V& v, F&& f)\n+    {\n+        if (v.template is<T>())\n+        {\n+            return f(unwrapper<T>::apply(v.template get_unchecked<T>()));\n+        }\n+        else\n+        {\n+            return dispatcher<F, V, R, Types...>::apply(v, std::forward<F>(f));\n+        }\n+    }\n+};\n+\n+template <typename F, typename V, typename R, typename T>\n+struct dispatcher<F, V, R, T>\n+{\n+    VARIANT_INLINE static R apply_const(V const& v, F&& f)\n+    {\n+        return f(unwrapper<T>::apply_const(v.template get_unchecked<T>()));\n+    }\n+\n+    VARIANT_INLINE static R apply(V& v, F&& f)\n+    {\n+        return f(unwrapper<T>::apply(v.template get_unchecked<T>()));\n+    }\n+};\n+\n+template <typename F, typename V, typename R, typename T, typename... Types>\n+struct binary_dispatcher_rhs;\n+\n+template <typename F, typename V, typename R, typename T0, typename T1, typename... Types>\n+struct binary_dispatcher_rhs<F, V, R, T0, T1, Types...>\n+{\n+    VARIANT_INLINE static R apply_const(V const& lhs, V const& rhs, F&& f)\n+    {\n+        if (rhs.template is<T1>()) // call binary functor\n+        {\n+            return f(unwrapper<T0>::apply_const(lhs.template get_unchecked<T0>()),\n+                     unwrapper<T1>::apply_const(rhs.template get_unchecked<T1>()));\n+        }\n+        else\n+        {\n+            return binary_dispatcher_rhs<F, V, R, T0, Types...>::apply_const(lhs, rhs, std::forward<F>(f));\n+        }\n+    }\n+\n+    VARIANT_INLINE static R apply(V& lhs, V& rhs, F&& f)\n+    {\n+        if (rhs.template is<T1>()) // call binary functor\n+        {\n+            return f(unwrapper<T0>::apply(lhs.template get_unchecked<T0>()),\n+                     unwrapper<T1>::apply(rhs.template get_unchecked<T1>()));\n+        }\n+        else\n+        {\n+            return binary_dispatcher_rhs<F, V, R, T0, Types...>::apply(lhs, rhs, std::forward<F>(f));\n+        }\n+    }\n+};\n+\n+template <typename F, typename V, typename R, typename T0, typename T1>\n+struct binary_dispatcher_rhs<F, V, R, T0, T1>\n+{\n+    VARIANT_INLINE static R apply_const(V const& lhs, V const& rhs, F&& f)\n+    {\n+        return f(unwrapper<T0>::apply_const(lhs.template get_unchecked<T0>()),\n+                 unwrapper<T1>::apply_const(rhs.template get_unchecked<T1>()));\n+    }\n+\n+    VARIANT_INLINE static R apply(V& lhs, V& rhs, F&& f)\n+    {\n+        return f(unwrapper<T0>::apply(lhs.template get_unchecked<T0>()),\n+                 unwrapper<T1>::apply(rhs.template get_unchecked<T1>()));\n+    }\n+};\n+\n+template <typename F, typename V, typename R, typename T, typename... Types>\n+struct binary_dispatcher_lhs;\n+\n+template <typename F, typename V, typename R, typename T0, typename T1, typename... Types>\n+struct binary_dispatcher_lhs<F, V, R, T0, T1, Types...>\n+{\n+    VARIANT_INLINE static R apply_const(V const& lhs, V const& rhs, F&& f)\n+    {\n+        if (lhs.template is<T1>()) // call binary functor\n+        {\n+            return f(unwrapper<T1>::apply_const(lhs.template get_unchecked<T1>()),\n+                     unwrapper<T0>::apply_const(rhs.template get_unchecked<T0>()));\n+        }\n+        else\n+        {\n+            return binary_dispatcher_lhs<F, V, R, T0, Types...>::apply_const(lhs, rhs, std::forward<F>(f));\n+        }\n+    }\n+\n+    VARIANT_INLINE static R apply(V& lhs, V& rhs, F&& f)\n+    {\n+        if (lhs.template is<T1>()) // call binary functor\n+        {\n+            return f(unwrapper<T1>::apply(lhs.template get_unchecked<T1>()),\n+                     unwrapper<T0>::apply(rhs.template get_unchecked<T0>()));\n+        }\n+        else\n+        {\n+            return binary_dispatcher_lhs<F, V, R, T0, Types...>::apply(lhs, rhs, std::forward<F>(f));\n+        }\n+    }\n+};\n+\n+template <typename F, typename V, typename R, typename T0, typename T1>\n+struct binary_dispatcher_lhs<F, V, R, T0, T1>\n+{\n+    VARIANT_INLINE static R apply_const(V const& lhs, V const& rhs, F&& f)\n+    {\n+        return f(unwrapper<T1>::apply_const(lhs.template get_unchecked<T1>()),\n+                 unwrapper<T0>::apply_const(rhs.template get_unchecked<T0>()));\n+    }\n+\n+    VARIANT_INLINE static R apply(V& lhs, V& rhs, F&& f)\n+    {\n+        return f(unwrapper<T1>::apply(lhs.template get_unchecked<T1>()),\n+                 unwrapper<T0>::apply(rhs.template get_unchecked<T0>()));\n+    }\n+};\n+\n+template <typename F, typename V, typename R, typename... Types>\n+struct binary_dispatcher;\n+\n+template <typename F, typename V, typename R, typename T, typename... Types>\n+struct binary_dispatcher<F, V, R, T, Types...>\n+{\n+    VARIANT_INLINE static R apply_const(V const& v0, V const& v1, F&& f)\n+    {\n+        if (v0.template is<T>())\n+        {\n+            if (v1.template is<T>())\n+            {\n+                return f(unwrapper<T>::apply_const(v0.template get_unchecked<T>()),\n+                         unwrapper<T>::apply_const(v1.template get_unchecked<T>())); // call binary functor\n+            }\n+            else\n+            {\n+                return binary_dispatcher_rhs<F, V, R, T, Types...>::apply_const(v0, v1, std::forward<F>(f));\n+            }\n+        }\n+        else if (v1.template is<T>())\n+        {\n+            return binary_dispatcher_lhs<F, V, R, T, Types...>::apply_const(v0, v1, std::forward<F>(f));\n+        }\n+        return binary_dispatcher<F, V, R, Types...>::apply_const(v0, v1, std::forward<F>(f));\n+    }\n+\n+    VARIANT_INLINE static R apply(V& v0, V& v1, F&& f)\n+    {\n+        if (v0.template is<T>())\n+        {\n+            if (v1.template is<T>())\n+            {\n+                return f(unwrapper<T>::apply(v0.template get_unchecked<T>()),\n+                         unwrapper<T>::apply(v1.template get_unchecked<T>())); // call binary functor\n+            }\n+            else\n+            {\n+                return binary_dispatcher_rhs<F, V, R, T, Types...>::apply(v0, v1, std::forward<F>(f));\n+            }\n+        }\n+        else if (v1.template is<T>())\n+        {\n+            return binary_dispatcher_lhs<F, V, R, T, Types...>::apply(v0, v1, std::forward<F>(f));\n+        }\n+        return binary_dispatcher<F, V, R, Types...>::apply(v0, v1, std::forward<F>(f));\n+    }\n+};\n+\n+template <typename F, typename V, typename R, typename T>\n+struct binary_dispatcher<F, V, R, T>\n+{\n+    VARIANT_INLINE static R apply_const(V const& v0, V const& v1, F&& f)\n+    {\n+        return f(unwrapper<T>::apply_const(v0.template get_unchecked<T>()),\n+                 unwrapper<T>::apply_const(v1.template get_unchecked<T>())); // call binary functor\n+    }\n+\n+    VARIANT_INLINE static R apply(V& v0, V& v1, F&& f)\n+    {\n+        return f(unwrapper<T>::apply(v0.template get_unchecked<T>()),\n+                 unwrapper<T>::apply(v1.template get_unchecked<T>())); // call binary functor\n+    }\n+};\n+\n+// comparator functors\n+struct equal_comp\n+{\n+    template <typename T>\n+    bool operator()(T const& lhs, T const& rhs) const\n+    {\n+        return lhs == rhs;\n+    }\n+};\n+\n+struct less_comp\n+{\n+    template <typename T>\n+    bool operator()(T const& lhs, T const& rhs) const\n+    {\n+        return lhs < rhs;\n+    }\n+};\n+\n+template <typename Variant, typename Comp>\n+class comparer\n+{\n+public:\n+    explicit comparer(Variant const& lhs) noexcept\n+        : lhs_(lhs) {}\n+    comparer& operator=(comparer const&) = delete;\n+    // visitor\n+    template <typename T>\n+    bool operator()(T const& rhs_content) const\n+    {\n+        T const& lhs_content = lhs_.template get_unchecked<T>();\n+        return Comp()(lhs_content, rhs_content);\n+    }\n+\n+private:\n+    Variant const& lhs_;\n+};\n+\n+// hashing visitor\n+struct hasher\n+{\n+    template <typename T>\n+    std::size_t operator()(const T& hashable) const\n+    {\n+        return std::hash<T>{}(hashable);\n+    }\n+};\n+\n+} // namespace detail\n+\n+struct no_init\n+{\n+};\n+\n+template <typename... Types>\n+class variant\n+{\n+    static_assert(sizeof...(Types) > 0, \"Template parameter type list of variant can not be empty\");\n+    static_assert(!detail::disjunction<std::is_reference<Types>...>::value, \"Variant can not hold reference types. Maybe use std::reference_wrapper?\");\n+\n+private:\n+    static const std::size_t data_size = detail::static_max<sizeof(Types)...>::value;\n+    static const std::size_t data_align = detail::static_max<alignof(Types)...>::value;\n+public:\n+    struct adapted_variant_tag;\n+    using types = std::tuple<Types...>;\n+private:\n+    using first_type = typename std::tuple_element<0, types>::type;\n+    using data_type = typename std::aligned_storage<data_size, data_align>::type;\n+    using helper_type = detail::variant_helper<Types...>;\n+\n+    std::size_t type_index;\n+    data_type data;\n+\n+public:\n+    VARIANT_INLINE variant() noexcept(std::is_nothrow_default_constructible<first_type>::value)\n+        : type_index(sizeof...(Types)-1)\n+    {\n+        static_assert(std::is_default_constructible<first_type>::value, \"First type in variant must be default constructible to allow default construction of variant\");\n+        new (&data) first_type();\n+    }\n+\n+    VARIANT_INLINE variant(no_init) noexcept\n+        : type_index(detail::invalid_value) {}\n+\n+    // http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers\n+    template <typename T, typename Traits = detail::value_traits<T, Types...>,\n+              typename Enable = typename std::enable_if<Traits::is_valid && !std::is_same<variant<Types...>, typename Traits::value_type>::value>::type >\n+    VARIANT_INLINE variant(T&& val) noexcept(std::is_nothrow_constructible<typename Traits::target_type, T&&>::value)\n+        : type_index(Traits::index)\n+    {\n+        new (&data) typename Traits::target_type(std::forward<T>(val));\n+    }\n+\n+    VARIANT_INLINE variant(variant<Types...> const& old)\n+        : type_index(old.type_index)\n+    {\n+        helper_type::copy(old.type_index, &old.data, &data);\n+    }\n+\n+    VARIANT_INLINE variant(variant<Types...>&& old)\n+        noexcept(detail::conjunction<std::is_nothrow_move_constructible<Types>...>::value)\n+        : type_index(old.type_index)\n+    {\n+        helper_type::move(old.type_index, &old.data, &data);\n+    }\n+\n+private:\n+    VARIANT_INLINE void copy_assign(variant<Types...> const& rhs)\n+    {\n+        helper_type::destroy(type_index, &data);\n+        type_index = detail::invalid_value;\n+        helper_type::copy(rhs.type_index, &rhs.data, &data);\n+        type_index = rhs.type_index;\n+    }\n+\n+    VARIANT_INLINE void move_assign(variant<Types...>&& rhs)\n+    {\n+        helper_type::destroy(type_index, &data);\n+        type_index = detail::invalid_value;\n+        helper_type::move(rhs.type_index, &rhs.data, &data);\n+        type_index = rhs.type_index;\n+    }\n+\n+public:\n+    VARIANT_INLINE variant<Types...>& operator=(variant<Types...>&& other)\n+    {\n+        move_assign(std::move(other));\n+        return *this;\n+    }\n+\n+    VARIANT_INLINE variant<Types...>& operator=(variant<Types...> const& other)\n+    {\n+        copy_assign(other);\n+        return *this;\n+    }\n+\n+    // conversions\n+    // move-assign\n+    template <typename T>\n+    VARIANT_INLINE variant<Types...>& operator=(T&& rhs) noexcept\n+    {\n+        variant<Types...> temp(std::forward<T>(rhs));\n+        move_assign(std::move(temp));\n+        return *this;\n+    }\n+\n+    // copy-assign\n+    template <typename T>\n+    VARIANT_INLINE variant<Types...>& operator=(T const& rhs)\n+    {\n+        variant<Types...> temp(rhs);\n+        copy_assign(temp);\n+        return *this;\n+    }\n+\n+    template <typename T, typename std::enable_if<\n+                          (detail::direct_type<T, Types...>::index != detail::invalid_value)>::type* = nullptr>\n+    VARIANT_INLINE bool is() const\n+    {\n+        return type_index == detail::direct_type<T, Types...>::index;\n+    }\n+\n+    template <typename T,typename std::enable_if<\n+                         (detail::direct_type<recursive_wrapper<T>, Types...>::index != detail::invalid_value)>::type* = nullptr>\n+    VARIANT_INLINE bool is() const\n+    {\n+        return type_index == detail::direct_type<recursive_wrapper<T>, Types...>::index;\n+    }\n+\n+    VARIANT_INLINE bool valid() const\n+    {\n+        return type_index != detail::invalid_value;\n+    }\n+\n+    template <typename T, typename... Args>\n+    VARIANT_INLINE void set(Args&&... args)\n+    {\n+        helper_type::destroy(type_index, &data);\n+        type_index = detail::invalid_value;\n+        new (&data) T(std::forward<Args>(args)...);\n+        type_index = detail::direct_type<T, Types...>::index;\n+    }\n+\n+    // get_unchecked<T>()\n+    template <typename T, typename std::enable_if<\n+                          (detail::direct_type<T, Types...>::index != detail::invalid_value)>::type* = nullptr>\n+    VARIANT_INLINE T& get_unchecked()\n+    {\n+        return *reinterpret_cast<T*>(&data);\n+    }\n+\n+#ifdef HAS_EXCEPTIONS\n+    // get<T>()\n+    template <typename T, typename std::enable_if<\n+                          (detail::direct_type<T, Types...>::index != detail::invalid_value)>::type* = nullptr>\n+    VARIANT_INLINE T& get()\n+    {\n+        if (type_index == detail::direct_type<T, Types...>::index)\n+        {\n+            return *reinterpret_cast<T*>(&data);\n+        }\n+        else\n+        {\n+            throw bad_variant_access(\"in get<T>()\");\n+        }\n+    }\n+#endif\n+\n+    template <typename T, typename std::enable_if<\n+                          (detail::direct_type<T, Types...>::index != detail::invalid_value)>::type* = nullptr>\n+    VARIANT_INLINE T const& get_unchecked() const\n+    {\n+        return *reinterpret_cast<T const*>(&data);\n+    }\n+\n+#ifdef HAS_EXCEPTIONS\n+    template <typename T, typename std::enable_if<\n+                          (detail::direct_type<T, Types...>::index != detail::invalid_value)>::type* = nullptr>\n+    VARIANT_INLINE T const& get() const\n+    {\n+        if (type_index == detail::direct_type<T, Types...>::index)\n+        {\n+            return *reinterpret_cast<T const*>(&data);\n+        }\n+        else\n+        {\n+            throw bad_variant_access(\"in get<T>()\");\n+        }\n+    }\n+#endif\n+\n+    // get_unchecked<T>() - T stored as recursive_wrapper<T>\n+    template <typename T, typename std::enable_if<\n+                          (detail::direct_type<recursive_wrapper<T>, Types...>::index != detail::invalid_value)>::type* = nullptr>\n+    VARIANT_INLINE T& get_unchecked()\n+    {\n+        return (*reinterpret_cast<recursive_wrapper<T>*>(&data)).get();\n+    }\n+\n+#ifdef HAS_EXCEPTIONS\n+    // get<T>() - T stored as recursive_wrapper<T>\n+    template <typename T, typename std::enable_if<\n+                          (detail::direct_type<recursive_wrapper<T>, Types...>::index != detail::invalid_value)>::type* = nullptr>\n+    VARIANT_INLINE T& get()\n+    {\n+        if (type_index == detail::direct_type<recursive_wrapper<T>, Types...>::index)\n+        {\n+            return (*reinterpret_cast<recursive_wrapper<T>*>(&data)).get();\n+        }\n+        else\n+        {\n+            throw bad_variant_access(\"in get<T>()\");\n+        }\n+    }\n+#endif\n+\n+    template <typename T, typename std::enable_if<\n+                          (detail::direct_type<recursive_wrapper<T>, Types...>::index != detail::invalid_value)>::type* = nullptr>\n+    VARIANT_INLINE T const& get_unchecked() const\n+    {\n+        return (*reinterpret_cast<recursive_wrapper<T> const*>(&data)).get();\n+    }\n+\n+#ifdef HAS_EXCEPTIONS\n+    template <typename T, typename std::enable_if<\n+                          (detail::direct_type<recursive_wrapper<T>, Types...>::index != detail::invalid_value)>::type* = nullptr>\n+    VARIANT_INLINE T const& get() const\n+    {\n+        if (type_index == detail::direct_type<recursive_wrapper<T>, Types...>::index)\n+        {\n+            return (*reinterpret_cast<recursive_wrapper<T> const*>(&data)).get();\n+        }\n+        else\n+        {\n+            throw bad_variant_access(\"in get<T>()\");\n+        }\n+    }\n+#endif\n+\n+    // get_unchecked<T>() - T stored as std::reference_wrapper<T>\n+    template <typename T, typename std::enable_if<\n+                          (detail::direct_type<std::reference_wrapper<T>, Types...>::index != detail::invalid_value)>::type* = nullptr>\n+    VARIANT_INLINE T& get_unchecked()\n+    {\n+        return (*reinterpret_cast<std::reference_wrapper<T>*>(&data)).get();\n+    }\n+\n+#ifdef HAS_EXCEPTIONS\n+    // get<T>() - T stored as std::reference_wrapper<T>\n+    template <typename T, typename std::enable_if<\n+                          (detail::direct_type<std::reference_wrapper<T>, Types...>::index != detail::invalid_value)>::type* = nullptr>\n+    VARIANT_INLINE T& get()\n+    {\n+        if (type_index == detail::direct_type<std::reference_wrapper<T>, Types...>::index)\n+        {\n+            return (*reinterpret_cast<std::reference_wrapper<T>*>(&data)).get();\n+        }\n+        else\n+        {\n+            throw bad_variant_access(\"in get<T>()\");\n+        }\n+    }\n+#endif\n+\n+    template <typename T, typename std::enable_if<\n+                          (detail::direct_type<std::reference_wrapper<T const>, Types...>::index != detail::invalid_value)>::type* = nullptr>\n+    VARIANT_INLINE T const& get_unchecked() const\n+    {\n+        return (*reinterpret_cast<std::reference_wrapper<T const> const*>(&data)).get();\n+    }\n+\n+#ifdef HAS_EXCEPTIONS\n+    template <typename T, typename std::enable_if<\n+                          (detail::direct_type<std::reference_wrapper<T const>, Types...>::index != detail::invalid_value)>::type* = nullptr>\n+    VARIANT_INLINE T const& get() const\n+    {\n+        if (type_index == detail::direct_type<std::reference_wrapper<T const>, Types...>::index)\n+        {\n+            return (*reinterpret_cast<std::reference_wrapper<T const> const*>(&data)).get();\n+        }\n+        else\n+        {\n+            throw bad_variant_access(\"in get<T>()\");\n+        }\n+    }\n+#endif\n+\n+    // This function is deprecated because it returns an internal index field.\n+    // Use which() instead.\n+    MAPBOX_VARIANT_DEPRECATED VARIANT_INLINE std::size_t get_type_index() const\n+    {\n+        return type_index;\n+    }\n+\n+    VARIANT_INLINE int which() const noexcept\n+    {\n+        return static_cast<int>(sizeof...(Types)-type_index - 1);\n+    }\n+\n+    template <typename T, typename std::enable_if<\n+                          (detail::direct_type<T, Types...>::index != detail::invalid_value)>::type* = nullptr>\n+    VARIANT_INLINE static constexpr int which() noexcept\n+    {\n+        return static_cast<int>(sizeof...(Types)-detail::direct_type<T, Types...>::index - 1);\n+    }\n+\n+    // visitor\n+    // unary\n+    template <typename F, typename V, typename R = typename detail::result_of_unary_visit<F, first_type>::type>\n+    auto VARIANT_INLINE static visit(V const& v, F&& f)\n+        -> decltype(detail::dispatcher<F, V, R, Types...>::apply_const(v, std::forward<F>(f)))\n+    {\n+        return detail::dispatcher<F, V, R, Types...>::apply_const(v, std::forward<F>(f));\n+    }\n+    // non-const\n+    template <typename F, typename V, typename R = typename detail::result_of_unary_visit<F, first_type>::type>\n+    auto VARIANT_INLINE static visit(V& v, F&& f)\n+        -> decltype(detail::dispatcher<F, V, R, Types...>::apply(v, std::forward<F>(f)))\n+    {\n+        return detail::dispatcher<F, V, R, Types...>::apply(v, std::forward<F>(f));\n+    }\n+\n+    // binary\n+    // const\n+    template <typename F, typename V, typename R = typename detail::result_of_binary_visit<F, first_type>::type>\n+    auto VARIANT_INLINE static binary_visit(V const& v0, V const& v1, F&& f)\n+        -> decltype(detail::binary_dispatcher<F, V, R, Types...>::apply_const(v0, v1, std::forward<F>(f)))\n+    {\n+        return detail::binary_dispatcher<F, V, R, Types...>::apply_const(v0, v1, std::forward<F>(f));\n+    }\n+    // non-const\n+    template <typename F, typename V, typename R = typename detail::result_of_binary_visit<F, first_type>::type>\n+    auto VARIANT_INLINE static binary_visit(V& v0, V& v1, F&& f)\n+        -> decltype(detail::binary_dispatcher<F, V, R, Types...>::apply(v0, v1, std::forward<F>(f)))\n+    {\n+        return detail::binary_dispatcher<F, V, R, Types...>::apply(v0, v1, std::forward<F>(f));\n+    }\n+\n+    // match\n+    // unary\n+    template <typename... Fs>\n+    auto VARIANT_INLINE match(Fs&&... fs) const\n+        -> decltype(variant::visit(*this, ::mapbox::util::make_visitor(std::forward<Fs>(fs)...)))\n+    {\n+        return variant::visit(*this, ::mapbox::util::make_visitor(std::forward<Fs>(fs)...));\n+    }\n+    // non-const\n+    template <typename... Fs>\n+    auto VARIANT_INLINE match(Fs&&... fs)\n+        -> decltype(variant::visit(*this, ::mapbox::util::make_visitor(std::forward<Fs>(fs)...)))\n+    {\n+        return variant::visit(*this, ::mapbox::util::make_visitor(std::forward<Fs>(fs)...));\n+    }\n+\n+    ~variant() noexcept // no-throw destructor\n+    {\n+        helper_type::destroy(type_index, &data);\n+    }\n+\n+    // comparison operators\n+    // equality\n+    VARIANT_INLINE bool operator==(variant const& rhs) const\n+    {\n+        assert(valid() && rhs.valid());\n+        if (this->which() != rhs.which())\n+        {\n+            return false;\n+        }\n+        detail::comparer<variant, detail::equal_comp> visitor(*this);\n+        return visit(rhs, visitor);\n+    }\n+\n+    VARIANT_INLINE bool operator!=(variant const& rhs) const\n+    {\n+        return !(*this == rhs);\n+    }\n+\n+    // less than\n+    VARIANT_INLINE bool operator<(variant const& rhs) const\n+    {\n+        assert(valid() && rhs.valid());\n+        if (this->which() != rhs.which())\n+        {\n+            return this->which() < rhs.which();\n+        }\n+        detail::comparer<variant, detail::less_comp> visitor(*this);\n+        return visit(rhs, visitor);\n+    }\n+    VARIANT_INLINE bool operator>(variant const& rhs) const\n+    {\n+        return rhs < *this;\n+    }\n+    VARIANT_INLINE bool operator<=(variant const& rhs) const\n+    {\n+        return !(*this > rhs);\n+    }\n+    VARIANT_INLINE bool operator>=(variant const& rhs) const\n+    {\n+        return !(*this < rhs);\n+    }\n+};\n+\n+// unary visitor interface\n+// const\n+template <typename F, typename V>\n+auto VARIANT_INLINE apply_visitor(F&& f, V const& v) -> decltype(V::visit(v, std::forward<F>(f)))\n+{\n+    return V::visit(v, std::forward<F>(f));\n+}\n+\n+// non-const\n+template <typename F, typename V>\n+auto VARIANT_INLINE apply_visitor(F&& f, V& v) -> decltype(V::visit(v, std::forward<F>(f)))\n+{\n+    return V::visit(v, std::forward<F>(f));\n+}\n+\n+// binary visitor interface\n+// const\n+template <typename F, typename V>\n+auto VARIANT_INLINE apply_visitor(F&& f, V const& v0, V const& v1) -> decltype(V::binary_visit(v0, v1, std::forward<F>(f)))\n+{\n+    return V::binary_visit(v0, v1, std::forward<F>(f));\n+}\n+\n+// non-const\n+template <typename F, typename V>\n+auto VARIANT_INLINE apply_visitor(F&& f, V& v0, V& v1) -> decltype(V::binary_visit(v0, v1, std::forward<F>(f)))\n+{\n+    return V::binary_visit(v0, v1, std::forward<F>(f));\n+}\n+\n+// getter interface\n+\n+#ifdef HAS_EXCEPTIONS\n+template <typename ResultType, typename T>\n+auto get(T& var)->decltype(var.template get<ResultType>())\n+{\n+    return var.template get<ResultType>();\n+}\n+#endif\n+\n+template <typename ResultType, typename T>\n+ResultType& get_unchecked(T& var)\n+{\n+    return var.template get_unchecked<ResultType>();\n+}\n+\n+#ifdef HAS_EXCEPTIONS\n+template <typename ResultType, typename T>\n+auto get(T const& var)->decltype(var.template get<ResultType>())\n+{\n+    return var.template get<ResultType>();\n+}\n+#endif\n+\n+template <typename ResultType, typename T>\n+ResultType const& get_unchecked(T const& var)\n+{\n+    return var.template get_unchecked<ResultType>();\n+}\n+} // namespace util\n+} // namespace mapbox\n+\n+// hashable iff underlying types are hashable\n+namespace std {\n+template <typename... Types>\n+struct hash< ::mapbox::util::variant<Types...>> {\n+    std::size_t operator()(const ::mapbox::util::variant<Types...>& v) const noexcept\n+    {\n+        return ::mapbox::util::apply_visitor(::mapbox::util::detail::hasher{}, v);\n+    }\n+};\n+}\n+\n+#endif // MAPBOX_UTIL_VARIANT_HPP\ndiff --git a/cpp/src/arrow/vendored/variant/variant_io.hpp b/cpp/src/arrow/vendored/variant/variant_io.hpp\nnew file mode 100644\nindex 0000000000..494d2a964e\n--- /dev/null\n+++ b/cpp/src/arrow/vendored/variant/variant_io.hpp\n@@ -0,0 +1,47 @@\n+// Vendored from https://github.com/mapbox/variant at tag v1.1.5\n+\n+#ifndef MAPBOX_UTIL_VARIANT_IO_HPP\n+#define MAPBOX_UTIL_VARIANT_IO_HPP\n+\n+#include <iosfwd>\n+\n+#include \"variant.hpp\"\n+\n+namespace mapbox {\n+namespace util {\n+\n+namespace detail {\n+// operator<< helper\n+template <typename Out>\n+class printer\n+{\n+public:\n+    explicit printer(Out& out)\n+        : out_(out) {}\n+    printer& operator=(printer const&) = delete;\n+\n+    // visitor\n+    template <typename T>\n+    void operator()(T const& operand) const\n+    {\n+        out_ << operand;\n+    }\n+\n+private:\n+    Out& out_;\n+};\n+}\n+\n+// operator<<\n+template <typename CharT, typename Traits, typename... Types>\n+VARIANT_INLINE std::basic_ostream<CharT, Traits>&\n+operator<<(std::basic_ostream<CharT, Traits>& out, variant<Types...> const& rhs)\n+{\n+    detail::printer<std::basic_ostream<CharT, Traits>> visitor(out);\n+    apply_visitor(visitor, rhs);\n+    return out;\n+}\n+} // namespace util\n+} // namespace mapbox\n+\n+#endif // MAPBOX_UTIL_VARIANT_IO_HPP\ndiff --git a/cpp/src/arrow/vendored/variant/variant_visitor.hpp b/cpp/src/arrow/vendored/variant/variant_visitor.hpp\nnew file mode 100644\nindex 0000000000..60020f4dd0\n--- /dev/null\n+++ b/cpp/src/arrow/vendored/variant/variant_visitor.hpp\n@@ -0,0 +1,40 @@\n+// Vendored from https://github.com/mapbox/variant at tag v1.1.5\n+\n+#ifndef MAPBOX_UTIL_VARIANT_VISITOR_HPP\n+#define MAPBOX_UTIL_VARIANT_VISITOR_HPP\n+\n+namespace mapbox {\n+namespace util {\n+\n+template <typename... Fns>\n+struct visitor;\n+\n+template <typename Fn>\n+struct visitor<Fn> : Fn\n+{\n+    using type = Fn;\n+    using Fn::operator();\n+\n+    visitor(Fn fn) : Fn(fn) {}\n+};\n+\n+template <typename Fn, typename... Fns>\n+struct visitor<Fn, Fns...> : Fn, visitor<Fns...>\n+{\n+    using type = visitor;\n+    using Fn::operator();\n+    using visitor<Fns...>::operator();\n+\n+    visitor(Fn fn, Fns... fns) : Fn(fn), visitor<Fns...>(fns...) {}\n+};\n+\n+template <typename... Fns>\n+visitor<Fns...> make_visitor(Fns... fns)\n+{\n+    return visitor<Fns...>(fns...);\n+}\n+\n+} // namespace util\n+} // namespace mapbox\n+\n+#endif // MAPBOX_UTIL_VARIANT_VISITOR_HPP\ndiff --git a/cpp/src/arrow/util/xxhash/xxhash.c b/cpp/src/arrow/vendored/xxhash/xxhash.c\nsimilarity index 100%\nrename from cpp/src/arrow/util/xxhash/xxhash.c\nrename to cpp/src/arrow/vendored/xxhash/xxhash.c\ndiff --git a/cpp/src/arrow/util/xxhash/xxhash.h b/cpp/src/arrow/vendored/xxhash/xxhash.h\nsimilarity index 100%\nrename from cpp/src/arrow/util/xxhash/xxhash.h\nrename to cpp/src/arrow/vendored/xxhash/xxhash.h\ndiff --git a/cpp/src/gandiva/precompiled/epoch_time_point.h b/cpp/src/gandiva/precompiled/epoch_time_point.h\nindex dc6340d134..115f019525 100644\n--- a/cpp/src/gandiva/precompiled/epoch_time_point.h\n+++ b/cpp/src/gandiva/precompiled/epoch_time_point.h\n@@ -19,7 +19,7 @@\n #define GANDIVA_EPOCH_TIME_POINT_H\n \n // TODO(wesm): IR compilation does not have any include directories set\n-#include \"../../arrow/util/date.h\"\n+#include \"../../arrow/vendored/date.h\"\n \n // A point of time measured in millis since epoch.\n class EpochTimePoint {\ndiff --git a/cpp/src/gandiva/to_date_holder.cc b/cpp/src/gandiva/to_date_holder.cc\nindex 9c85622800..b512934e23 100644\n--- a/cpp/src/gandiva/to_date_holder.cc\n+++ b/cpp/src/gandiva/to_date_holder.cc\n@@ -18,7 +18,7 @@\n #include <algorithm>\n #include <string>\n \n-#include \"arrow/util/date.h\"\n+#include \"arrow/vendored/date.h\"\n \n #include \"gandiva/date_utils.h\"\n #include \"gandiva/execution_context.h\"\ndiff --git a/cpp/src/plasma/client.cc b/cpp/src/plasma/client.cc\nindex 4215399c0b..8d153585c3 100644\n--- a/cpp/src/plasma/client.cc\n+++ b/cpp/src/plasma/client.cc\n@@ -64,7 +64,7 @@ using arrow::cuda::CudaDeviceManager;\n \n #define XXH_INLINE_ALL 1\n #define XXH_NAMESPACE plasma_client_\n-#include \"arrow/util/xxhash/xxhash.h\"\n+#include \"arrow/vendored/xxhash/xxhash.h\"\n \n #define XXH64_DEFAULT_SEED 0\n \ndiff --git a/dev/release/rat_exclude_files.txt b/dev/release/rat_exclude_files.txt\nindex e274d97548..d2c41520c8 100644\n--- a/dev/release/rat_exclude_files.txt\n+++ b/dev/release/rat_exclude_files.txt\n@@ -13,15 +13,7 @@ cpp/src/arrow/io/mman.h\n cpp/src/arrow/util/random.h\n cpp/src/arrow/status.cc\n cpp/src/arrow/status.h\n-cpp/src/arrow/util/string_view/string_view.hpp\n-cpp/src/arrow/util/variant.h\n-cpp/src/arrow/util/variant/optional.h\n-cpp/src/arrow/util/variant/recursive_wrapper.h\n-cpp/src/arrow/util/variant/variant_cast.h\n-cpp/src/arrow/util/variant/variant_io.h\n-cpp/src/arrow/util/variant/variant_visitor.h\n-cpp/src/arrow/util/xxhash/xxhash.c\n-cpp/src/arrow/util/xxhash/xxhash.h\n+cpp/src/arrow/vendored/*\n cpp/build-support/asan_symbolize.py\n cpp/build-support/cpplint.py\n cpp/build-support/clang_format_exclusions.txt\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-17T16:09:11.413+0000",
                    "updated": "2018-12-17T16:09:11.413+0000",
                    "started": "2018-12-17T16:09:11.412+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176105",
                    "issueId": "13204205"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 3600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@3fed57dc[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@77343e8f[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@267bbca5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@70ed2ea3[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4f18b648[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@5649a944[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2dacb9bc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@34ad029c[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3e0d58b7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@2595d5bb[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6d3cf9ec[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@31d9af35[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 3600,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Dec 17 16:08:59 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-12-17T16:08:59.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-4017/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2018-12-13T11:16:56.000+0000",
        "updated": "2018-12-17T16:09:11.000+0000",
        "timeoriginalestimate": null,
        "description": "Some vendored libraries, like {{util::variant}}, seem old. Also, perhaps we should put them all in a {{vendored/}} directory, to make inspection easier?",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 3600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Check and update vendored libraries",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204205/comment/16720556",
                    "id": "16720556",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Having an {{arrow/vendor}} directory seems fine to me. \r\n\r\nThere haven't been too many commits to mapbox/variant since last I looked, but I might have missed some. \r\n\r\nhttps://github.com/mapbox/variant/commits/master",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-12-13T20:06:08.502+0000",
                    "updated": "2018-12-13T20:06:08.502+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204205/comment/16723114",
                    "id": "16723114",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 3184\n[https://github.com/apache/arrow/pull/3184]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-12-17T16:08:59.708+0000",
                    "updated": "2018-12-17T16:08:59.708+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|s01hb4:",
        "customfield_12314139": null
    }
}