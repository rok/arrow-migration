{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13372310",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13372310",
    "key": "ARROW-12378",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349983",
                "id": "12349983",
                "description": "",
                "name": "5.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-07-28"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
            "name": "Minor",
            "id": "4"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jpedroantunes",
            "name": "jpedroantunes",
            "key": "jpedroantunes",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34060",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34060",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34060",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34060"
            },
            "displayName": "Jo\u00e3o Pedro Antunes Ferreira",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12334626",
                "id": "12334626",
                "name": "C++ - Gandiva"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jpedroantunes",
            "name": "jpedroantunes",
            "key": "jpedroantunes",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34060",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34060",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34060",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34060"
            },
            "displayName": "Jo\u00e3o Pedro Antunes Ferreira",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jpedroantunes",
            "name": "jpedroantunes",
            "key": "jpedroantunes",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34060",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34060",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34060",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34060"
            },
            "displayName": "Jo\u00e3o Pedro Antunes Ferreira",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 7200,
            "total": 7200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 7200,
            "total": 7200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12378/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 12,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13372310/worklog/582477",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jpedroantunes opened a new pull request #10023:\nURL: https://github.com/apache/arrow/pull/10023\n\n\n   Implement the following functions:\r\n   \r\n   - castVARBINARY(varchar, len)\r\n   - castVARBINARY(varbinary, len)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-14T13:17:03.304+0000",
                    "updated": "2021-04-14T13:17:03.304+0000",
                    "started": "2021-04-14T13:17:03.304+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "582477",
                    "issueId": "13372310"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13372310/worklog/582691",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10023:\nURL: https://github.com/apache/arrow/pull/10023#issuecomment-819664023\n\n\n   https://issues.apache.org/jira/browse/ARROW-12378\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-14T16:47:13.193+0000",
                    "updated": "2021-04-14T16:47:13.193+0000",
                    "started": "2021-04-14T16:47:13.193+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "582691",
                    "issueId": "13372310"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13372310/worklog/590827",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "projjal commented on a change in pull request #10023:\nURL: https://github.com/apache/arrow/pull/10023#discussion_r622719721\n\n\n\n##########\nFile path: cpp/src/gandiva/context_helper.cc\n##########\n@@ -69,6 +69,11 @@ uint8_t* gdv_fn_context_arena_malloc(int64_t context_ptr, int32_t size) {\n   return context->arena()->Allocate(size);\n }\n \n+uint8_t* gdv_fn_context_arena_malloc_int64(int64_t context_ptr, int64_t size) {\n\nReview comment:\n       why not keep only one method.\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -216,6 +216,72 @@ SHA_VAR_LEN_PARAMS(SHA1_HASH_FUNCTION_BUF)\n #undef SHA_NUMERIC_BOOL_DATE_PARAMS\n #undef SHA_VAR_LEN_PARAMS\n \n+// Add functions for castVARBINARY for utf8 and binary\n+#define CAST_VARBINARY_FROM_STRING_AND_BINARY(TYPE_NAME)                               \\\n+  GANDIVA_EXPORT                                                                       \\\n+  const char* gdv_fn_castVARBINARY_##TYPE_NAME(int64_t context, const char* data,      \\\n+                                               int32_t data_len, int64_t out_len,      \\\n+                                               int64_t* out_length) {                  \\\n+    if (out_len < 0) {                                                                 \\\n+      gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\"); \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    if (out_len >= data_len || out_len == 0) {                                         \\\n+      *out_length = data_len;                                                          \\\n+    } else {                                                                           \\\n+      *out_length = out_len;                                                           \\\n+    }                                                                                  \\\n+    return data;                                                                       \\\n+  }\n+\n+CAST_VARBINARY_FROM_STRING_AND_BINARY(utf8)\n+CAST_VARBINARY_FROM_STRING_AND_BINARY(binary)\n+\n+#undef CAST_VARBINARY_FROM_STRING_AND_BINARY\n+\n+// Add functions for castVARBINARY for numeric\n+#define CAST_VARBINARY_FROM_NUMERIC(TYPE_NAME)                                         \\\n+  GANDIVA_EXPORT                                                                       \\\n+  const char* gdv_fn_castVARBINARY_##TYPE_NAME(int64_t context, gdv_##TYPE_NAME value, \\\n\nReview comment:\n       I think you should return the the bytes corresponding to the string representation of int/float. (opposite of what the change castINT from varbinary is doing)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-29T04:53:39.209+0000",
                    "updated": "2021-04-29T04:53:39.209+0000",
                    "started": "2021-04-29T04:53:39.209+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "590827",
                    "issueId": "13372310"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13372310/worklog/590934",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jpedroantunes commented on a change in pull request #10023:\nURL: https://github.com/apache/arrow/pull/10023#discussion_r622948149\n\n\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -216,6 +216,72 @@ SHA_VAR_LEN_PARAMS(SHA1_HASH_FUNCTION_BUF)\n #undef SHA_NUMERIC_BOOL_DATE_PARAMS\n #undef SHA_VAR_LEN_PARAMS\n \n+// Add functions for castVARBINARY for utf8 and binary\n+#define CAST_VARBINARY_FROM_STRING_AND_BINARY(TYPE_NAME)                               \\\n+  GANDIVA_EXPORT                                                                       \\\n+  const char* gdv_fn_castVARBINARY_##TYPE_NAME(int64_t context, const char* data,      \\\n+                                               int32_t data_len, int64_t out_len,      \\\n+                                               int64_t* out_length) {                  \\\n+    if (out_len < 0) {                                                                 \\\n+      gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\"); \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    if (out_len >= data_len || out_len == 0) {                                         \\\n+      *out_length = data_len;                                                          \\\n+    } else {                                                                           \\\n+      *out_length = out_len;                                                           \\\n+    }                                                                                  \\\n+    return data;                                                                       \\\n+  }\n+\n+CAST_VARBINARY_FROM_STRING_AND_BINARY(utf8)\n+CAST_VARBINARY_FROM_STRING_AND_BINARY(binary)\n+\n+#undef CAST_VARBINARY_FROM_STRING_AND_BINARY\n+\n+// Add functions for castVARBINARY for numeric\n+#define CAST_VARBINARY_FROM_NUMERIC(TYPE_NAME)                                         \\\n+  GANDIVA_EXPORT                                                                       \\\n+  const char* gdv_fn_castVARBINARY_##TYPE_NAME(int64_t context, gdv_##TYPE_NAME value, \\\n\nReview comment:\n       If I get it correctly, I should do the same as the castVARCHAR for numeric types, but returning the correspondent bytes, correct?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-29T11:09:06.418+0000",
                    "updated": "2021-04-29T11:09:06.418+0000",
                    "started": "2021-04-29T11:09:06.417+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "590934",
                    "issueId": "13372310"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13372310/worklog/590935",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "projjal commented on a change in pull request #10023:\nURL: https://github.com/apache/arrow/pull/10023#discussion_r622948791\n\n\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -216,6 +216,72 @@ SHA_VAR_LEN_PARAMS(SHA1_HASH_FUNCTION_BUF)\n #undef SHA_NUMERIC_BOOL_DATE_PARAMS\n #undef SHA_VAR_LEN_PARAMS\n \n+// Add functions for castVARBINARY for utf8 and binary\n+#define CAST_VARBINARY_FROM_STRING_AND_BINARY(TYPE_NAME)                               \\\n+  GANDIVA_EXPORT                                                                       \\\n+  const char* gdv_fn_castVARBINARY_##TYPE_NAME(int64_t context, const char* data,      \\\n+                                               int32_t data_len, int64_t out_len,      \\\n+                                               int64_t* out_length) {                  \\\n+    if (out_len < 0) {                                                                 \\\n+      gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\"); \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    if (out_len >= data_len || out_len == 0) {                                         \\\n+      *out_length = data_len;                                                          \\\n+    } else {                                                                           \\\n+      *out_length = out_len;                                                           \\\n+    }                                                                                  \\\n+    return data;                                                                       \\\n+  }\n+\n+CAST_VARBINARY_FROM_STRING_AND_BINARY(utf8)\n+CAST_VARBINARY_FROM_STRING_AND_BINARY(binary)\n+\n+#undef CAST_VARBINARY_FROM_STRING_AND_BINARY\n+\n+// Add functions for castVARBINARY for numeric\n+#define CAST_VARBINARY_FROM_NUMERIC(TYPE_NAME)                                         \\\n+  GANDIVA_EXPORT                                                                       \\\n+  const char* gdv_fn_castVARBINARY_##TYPE_NAME(int64_t context, gdv_##TYPE_NAME value, \\\n\nReview comment:\n       yes..you can resuse that macro i suppose\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-29T11:10:09.736+0000",
                    "updated": "2021-04-29T11:10:09.736+0000",
                    "started": "2021-04-29T11:10:09.736+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "590935",
                    "issueId": "13372310"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13372310/worklog/595125",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "projjal commented on a change in pull request #10023:\nURL: https://github.com/apache/arrow/pull/10023#discussion_r623573772\n\n\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -307,85 +307,114 @@ CAST_NUMERIC_FROM_STRING(double, arrow::DoubleType, FLOAT8)\n \n #undef CAST_NUMERIC_FROM_STRING\n \n-#define GDV_FN_CAST_VARCHAR_INTEGER(IN_TYPE, ARROW_TYPE)                                 \\\n-  GANDIVA_EXPORT                                                                         \\\n-  const char* gdv_fn_castVARCHAR_##IN_TYPE##_int64(int64_t context, gdv_##IN_TYPE value, \\\n-                                                   int64_t len, int32_t * out_len) {     \\\n-    if (len < 0) {                                                                       \\\n-      gdv_fn_context_set_error_msg(context, \"Buffer length can not be negative\");        \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    if (len == 0) {                                                                      \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    arrow::internal::StringFormatter<arrow::ARROW_TYPE> formatter;                       \\\n-    char* ret = reinterpret_cast<char*>(                                                 \\\n-        gdv_fn_context_arena_malloc(context, static_cast<int32_t>(len)));                \\\n-    if (ret == nullptr) {                                                                \\\n-      gdv_fn_context_set_error_msg(context, \"Could not allocate memory\");                \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    arrow::Status status = formatter(value, [&](arrow::util::string_view v) {            \\\n-      int64_t size = static_cast<int64_t>(v.size());                                     \\\n-      *out_len = static_cast<int32_t>(len < size ? len : size);                          \\\n-      memcpy(ret, v.data(), *out_len);                                                   \\\n-      return arrow::Status::OK();                                                        \\\n-    });                                                                                  \\\n-    if (!status.ok()) {                                                                  \\\n-      std::string err = \"Could not cast \" + std::to_string(value) + \" to string\";        \\\n-      gdv_fn_context_set_error_msg(context, err.c_str());                                \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    return ret;                                                                          \\\n+// Add functions for castVARBINARY for utf8 and binary\n+#define CAST_VARBINARY_FROM_STRING_AND_BINARY(TYPE_NAME)                               \\\n\nReview comment:\n       You should move this function to the precompiled/string_ops.cc. There is arealy a similar castVARCHAR function, you can probably resuse that.\r\n   Also they seem to cast the int64 to int32 during arena_malloc. So probably you don't need to change the arena_malloc singature\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -307,85 +307,114 @@ CAST_NUMERIC_FROM_STRING(double, arrow::DoubleType, FLOAT8)\n \n #undef CAST_NUMERIC_FROM_STRING\n \n-#define GDV_FN_CAST_VARCHAR_INTEGER(IN_TYPE, ARROW_TYPE)                                 \\\n-  GANDIVA_EXPORT                                                                         \\\n-  const char* gdv_fn_castVARCHAR_##IN_TYPE##_int64(int64_t context, gdv_##IN_TYPE value, \\\n-                                                   int64_t len, int32_t * out_len) {     \\\n-    if (len < 0) {                                                                       \\\n-      gdv_fn_context_set_error_msg(context, \"Buffer length can not be negative\");        \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    if (len == 0) {                                                                      \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    arrow::internal::StringFormatter<arrow::ARROW_TYPE> formatter;                       \\\n-    char* ret = reinterpret_cast<char*>(                                                 \\\n-        gdv_fn_context_arena_malloc(context, static_cast<int32_t>(len)));                \\\n-    if (ret == nullptr) {                                                                \\\n-      gdv_fn_context_set_error_msg(context, \"Could not allocate memory\");                \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    arrow::Status status = formatter(value, [&](arrow::util::string_view v) {            \\\n-      int64_t size = static_cast<int64_t>(v.size());                                     \\\n-      *out_len = static_cast<int32_t>(len < size ? len : size);                          \\\n-      memcpy(ret, v.data(), *out_len);                                                   \\\n-      return arrow::Status::OK();                                                        \\\n-    });                                                                                  \\\n-    if (!status.ok()) {                                                                  \\\n-      std::string err = \"Could not cast \" + std::to_string(value) + \" to string\";        \\\n-      gdv_fn_context_set_error_msg(context, err.c_str());                                \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    return ret;                                                                          \\\n+// Add functions for castVARBINARY for utf8 and binary\n+#define CAST_VARBINARY_FROM_STRING_AND_BINARY(TYPE_NAME)                               \\\n+  GANDIVA_EXPORT                                                                       \\\n+  const char* gdv_fn_castVARBINARY_##TYPE_NAME(int64_t context, const char* data,      \\\n+                                               int32_t data_len, int64_t out_len,      \\\n+                                               int64_t* out_length) {                  \\\n+    if (out_len < 0) {                                                                 \\\n+      gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\"); \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    if (out_len >= data_len || out_len == 0) {                                         \\\n+      *out_length = data_len;                                                          \\\n+    } else {                                                                           \\\n+      *out_length = out_len;                                                           \\\n+    }                                                                                  \\\n+    return data;                                                                       \\\n   }\n \n-#define GDV_FN_CAST_VARCHAR_REAL(IN_TYPE, ARROW_TYPE)                                    \\\n-  GANDIVA_EXPORT                                                                         \\\n-  const char* gdv_fn_castVARCHAR_##IN_TYPE##_int64(int64_t context, gdv_##IN_TYPE value, \\\n-                                                   int64_t len, int32_t * out_len) {     \\\n-    if (len < 0) {                                                                       \\\n-      gdv_fn_context_set_error_msg(context, \"Buffer length can not be negative\");        \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    if (len == 0) {                                                                      \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    gandiva::GdvStringFormatter<arrow::ARROW_TYPE> formatter;                            \\\n-    char* ret = reinterpret_cast<char*>(                                                 \\\n-        gdv_fn_context_arena_malloc(context, static_cast<int32_t>(len)));                \\\n-    if (ret == nullptr) {                                                                \\\n-      gdv_fn_context_set_error_msg(context, \"Could not allocate memory\");                \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    arrow::Status status = formatter(value, [&](arrow::util::string_view v) {            \\\n-      int64_t size = static_cast<int64_t>(v.size());                                     \\\n-      *out_len = static_cast<int32_t>(len < size ? len : size);                          \\\n-      memcpy(ret, v.data(), *out_len);                                                   \\\n-      return arrow::Status::OK();                                                        \\\n-    });                                                                                  \\\n-    if (!status.ok()) {                                                                  \\\n-      std::string err = \"Could not cast \" + std::to_string(value) + \" to string\";        \\\n-      gdv_fn_context_set_error_msg(context, err.c_str());                                \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    return ret;                                                                          \\\n+CAST_VARBINARY_FROM_STRING_AND_BINARY(utf8)\n+CAST_VARBINARY_FROM_STRING_AND_BINARY(binary)\n+\n+#undef CAST_VARBINARY_FROM_STRING_AND_BINARY\n+\n+#define GDV_FN_CAST_VARCHAR_VARBINARY_INTEGER(IN_TYPE, CAST_NAME, ARROW_TYPE)     \\\n+  GANDIVA_EXPORT                                                                  \\\n+  const char* gdv_fn_cast##CAST_NAME##_##IN_TYPE##_int64(                         \\\n+      int64_t context, gdv_##IN_TYPE value, int64_t len, int32_t * out_len) {     \\\n+    if (len < 0) {                                                                \\\n+      gdv_fn_context_set_error_msg(context, \"Buffer length can not be negative\"); \\\n+      *out_len = 0;                                                               \\\n+      return \"\";                                                                  \\\n+    }                                                                             \\\n+    if (len == 0) {                                                               \\\n+      *out_len = 0;                                                               \\\n+      return \"\";                                                                  \\\n+    }                                                                             \\\n+    arrow::internal::StringFormatter<arrow::ARROW_TYPE> formatter;                \\\n+    char* ret = reinterpret_cast<char*>(                                          \\\n+        gdv_fn_context_arena_malloc(context, static_cast<int32_t>(len)));         \\\n+    if (ret == nullptr) {                                                         \\\n+      gdv_fn_context_set_error_msg(context, \"Could not allocate memory\");         \\\n+      *out_len = 0;                                                               \\\n+      return \"\";                                                                  \\\n+    }                                                                             \\\n+    arrow::Status status = formatter(value, [&](arrow::util::string_view v) {     \\\n+      int64_t size = static_cast<int64_t>(v.size());                              \\\n+      *out_len = static_cast<int32_t>(len < size ? len : size);                   \\\n+      memcpy(ret, v.data(), *out_len);                                            \\\n+      return arrow::Status::OK();                                                 \\\n+    });                                                                           \\\n+    if (!status.ok()) {                                                           \\\n+      std::string err = \"Could not cast \" + std::to_string(value) + \" to string\"; \\\n+      gdv_fn_context_set_error_msg(context, err.c_str());                         \\\n+      *out_len = 0;                                                               \\\n+      return \"\";                                                                  \\\n+    }                                                                             \\\n+    return ret;                                                                   \\\n   }\n \n-GDV_FN_CAST_VARCHAR_INTEGER(int32, Int32Type)\n-GDV_FN_CAST_VARCHAR_INTEGER(int64, Int64Type)\n-GDV_FN_CAST_VARCHAR_REAL(float32, FloatType)\n-GDV_FN_CAST_VARCHAR_REAL(float64, DoubleType)\n+#define GDV_FN_CAST_VARCHAR_VARBINARY_REAL(IN_TYPE, CAST_NAME, ARROW_TYPE)        \\\n+  GANDIVA_EXPORT                                                                  \\\n+  const char* gdv_fn_cast##CAST_NAME##_##IN_TYPE##_int64(                         \\\n+      int64_t context, gdv_##IN_TYPE value, int64_t len, int32_t * out_len) {     \\\n+    if (len < 0) {                                                                \\\n+      gdv_fn_context_set_error_msg(context, \"Buffer length can not be negative\"); \\\n+      *out_len = 0;                                                               \\\n+      return \"\";                                                                  \\\n+    }                                                                             \\\n+    if (len == 0) {                                                               \\\n+      *out_len = 0;                                                               \\\n+      return \"\";                                                                  \\\n+    }                                                                             \\\n+    gandiva::GdvStringFormatter<arrow::ARROW_TYPE> formatter;                     \\\n+    char* ret = reinterpret_cast<char*>(                                          \\\n+        gdv_fn_context_arena_malloc(context, static_cast<int32_t>(len)));         \\\n+    if (ret == nullptr) {                                                         \\\n+      gdv_fn_context_set_error_msg(context, \"Could not allocate memory\");         \\\n+      *out_len = 0;                                                               \\\n+      return \"\";                                                                  \\\n+    }                                                                             \\\n+    arrow::Status status = formatter(value, [&](arrow::util::string_view v) {     \\\n+      int64_t size = static_cast<int64_t>(v.size());                              \\\n+      *out_len = static_cast<int32_t>(len < size ? len : size);                   \\\n+      memcpy(ret, v.data(), *out_len);                                            \\\n+      return arrow::Status::OK();                                                 \\\n+    });                                                                           \\\n+    if (!status.ok()) {                                                           \\\n+      std::string err = \"Could not cast \" + std::to_string(value) + \" to string\"; \\\n+      gdv_fn_context_set_error_msg(context, err.c_str());                         \\\n+      *out_len = 0;                                                               \\\n+      return \"\";                                                                  \\\n+    }                                                                             \\\n+    return ret;                                                                   \\\n+  }\n \n-#undef GDV_FN_CAST_VARCHAR_INTEGER\n-#undef GDV_FN_CAST_VARCHAR_REAL\n+GDV_FN_CAST_VARCHAR_VARBINARY_INTEGER(int32, VARCHAR, Int32Type)\n\nReview comment:\n       This name looks confusing...make the original macro name GDV_FN_CAST_VARLEN_TYPE_FROM_INTEGER, then create two macros CAST_VARCHAR_FROM_INTEGER and CAST_VARBINARY_FROM_INTEGER that call the original macro and call these two macros with different numeric types\n\n##########\nFile path: cpp/src/gandiva/function_registry_string.cc\n##########\n@@ -236,6 +236,30 @@ std::vector<NativeFunction> GetStringFunctionRegistry() {\n       NativeFunction(\"binary_string\", {}, DataTypeVector{utf8()}, binary(),\n                      kResultNullIfNull, \"binary_string\", NativeFunction::kNeedsContext),\n \n+      NativeFunction(\"castVARBINARY\", {}, DataTypeVector{binary(), int64()}, binary(),\n+                     kResultNullIfNull, \"gdv_fn_castVARBINARY_binary\",\n\nReview comment:\n       add \"_int64\" to all the function names\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-12T08:24:50.071+0000",
                    "updated": "2021-05-12T08:24:50.071+0000",
                    "started": "2021-05-12T08:24:50.071+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "595125",
                    "issueId": "13372310"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13372310/worklog/595224",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jpedroantunes commented on a change in pull request #10023:\nURL: https://github.com/apache/arrow/pull/10023#discussion_r630961867\n\n\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -307,85 +307,114 @@ CAST_NUMERIC_FROM_STRING(double, arrow::DoubleType, FLOAT8)\n \n #undef CAST_NUMERIC_FROM_STRING\n \n-#define GDV_FN_CAST_VARCHAR_INTEGER(IN_TYPE, ARROW_TYPE)                                 \\\n-  GANDIVA_EXPORT                                                                         \\\n-  const char* gdv_fn_castVARCHAR_##IN_TYPE##_int64(int64_t context, gdv_##IN_TYPE value, \\\n-                                                   int64_t len, int32_t * out_len) {     \\\n-    if (len < 0) {                                                                       \\\n-      gdv_fn_context_set_error_msg(context, \"Buffer length can not be negative\");        \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    if (len == 0) {                                                                      \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    arrow::internal::StringFormatter<arrow::ARROW_TYPE> formatter;                       \\\n-    char* ret = reinterpret_cast<char*>(                                                 \\\n-        gdv_fn_context_arena_malloc(context, static_cast<int32_t>(len)));                \\\n-    if (ret == nullptr) {                                                                \\\n-      gdv_fn_context_set_error_msg(context, \"Could not allocate memory\");                \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    arrow::Status status = formatter(value, [&](arrow::util::string_view v) {            \\\n-      int64_t size = static_cast<int64_t>(v.size());                                     \\\n-      *out_len = static_cast<int32_t>(len < size ? len : size);                          \\\n-      memcpy(ret, v.data(), *out_len);                                                   \\\n-      return arrow::Status::OK();                                                        \\\n-    });                                                                                  \\\n-    if (!status.ok()) {                                                                  \\\n-      std::string err = \"Could not cast \" + std::to_string(value) + \" to string\";        \\\n-      gdv_fn_context_set_error_msg(context, err.c_str());                                \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    return ret;                                                                          \\\n+// Add functions for castVARBINARY for utf8 and binary\n+#define CAST_VARBINARY_FROM_STRING_AND_BINARY(TYPE_NAME)                               \\\n\nReview comment:\n       Solved\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -307,85 +307,114 @@ CAST_NUMERIC_FROM_STRING(double, arrow::DoubleType, FLOAT8)\n \n #undef CAST_NUMERIC_FROM_STRING\n \n-#define GDV_FN_CAST_VARCHAR_INTEGER(IN_TYPE, ARROW_TYPE)                                 \\\n-  GANDIVA_EXPORT                                                                         \\\n-  const char* gdv_fn_castVARCHAR_##IN_TYPE##_int64(int64_t context, gdv_##IN_TYPE value, \\\n-                                                   int64_t len, int32_t * out_len) {     \\\n-    if (len < 0) {                                                                       \\\n-      gdv_fn_context_set_error_msg(context, \"Buffer length can not be negative\");        \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    if (len == 0) {                                                                      \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    arrow::internal::StringFormatter<arrow::ARROW_TYPE> formatter;                       \\\n-    char* ret = reinterpret_cast<char*>(                                                 \\\n-        gdv_fn_context_arena_malloc(context, static_cast<int32_t>(len)));                \\\n-    if (ret == nullptr) {                                                                \\\n-      gdv_fn_context_set_error_msg(context, \"Could not allocate memory\");                \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    arrow::Status status = formatter(value, [&](arrow::util::string_view v) {            \\\n-      int64_t size = static_cast<int64_t>(v.size());                                     \\\n-      *out_len = static_cast<int32_t>(len < size ? len : size);                          \\\n-      memcpy(ret, v.data(), *out_len);                                                   \\\n-      return arrow::Status::OK();                                                        \\\n-    });                                                                                  \\\n-    if (!status.ok()) {                                                                  \\\n-      std::string err = \"Could not cast \" + std::to_string(value) + \" to string\";        \\\n-      gdv_fn_context_set_error_msg(context, err.c_str());                                \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    return ret;                                                                          \\\n+// Add functions for castVARBINARY for utf8 and binary\n+#define CAST_VARBINARY_FROM_STRING_AND_BINARY(TYPE_NAME)                               \\\n+  GANDIVA_EXPORT                                                                       \\\n+  const char* gdv_fn_castVARBINARY_##TYPE_NAME(int64_t context, const char* data,      \\\n+                                               int32_t data_len, int64_t out_len,      \\\n+                                               int64_t* out_length) {                  \\\n+    if (out_len < 0) {                                                                 \\\n+      gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\"); \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    if (out_len >= data_len || out_len == 0) {                                         \\\n+      *out_length = data_len;                                                          \\\n+    } else {                                                                           \\\n+      *out_length = out_len;                                                           \\\n+    }                                                                                  \\\n+    return data;                                                                       \\\n   }\n \n-#define GDV_FN_CAST_VARCHAR_REAL(IN_TYPE, ARROW_TYPE)                                    \\\n-  GANDIVA_EXPORT                                                                         \\\n-  const char* gdv_fn_castVARCHAR_##IN_TYPE##_int64(int64_t context, gdv_##IN_TYPE value, \\\n-                                                   int64_t len, int32_t * out_len) {     \\\n-    if (len < 0) {                                                                       \\\n-      gdv_fn_context_set_error_msg(context, \"Buffer length can not be negative\");        \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    if (len == 0) {                                                                      \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    gandiva::GdvStringFormatter<arrow::ARROW_TYPE> formatter;                            \\\n-    char* ret = reinterpret_cast<char*>(                                                 \\\n-        gdv_fn_context_arena_malloc(context, static_cast<int32_t>(len)));                \\\n-    if (ret == nullptr) {                                                                \\\n-      gdv_fn_context_set_error_msg(context, \"Could not allocate memory\");                \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    arrow::Status status = formatter(value, [&](arrow::util::string_view v) {            \\\n-      int64_t size = static_cast<int64_t>(v.size());                                     \\\n-      *out_len = static_cast<int32_t>(len < size ? len : size);                          \\\n-      memcpy(ret, v.data(), *out_len);                                                   \\\n-      return arrow::Status::OK();                                                        \\\n-    });                                                                                  \\\n-    if (!status.ok()) {                                                                  \\\n-      std::string err = \"Could not cast \" + std::to_string(value) + \" to string\";        \\\n-      gdv_fn_context_set_error_msg(context, err.c_str());                                \\\n-      *out_len = 0;                                                                      \\\n-      return \"\";                                                                         \\\n-    }                                                                                    \\\n-    return ret;                                                                          \\\n+CAST_VARBINARY_FROM_STRING_AND_BINARY(utf8)\n+CAST_VARBINARY_FROM_STRING_AND_BINARY(binary)\n+\n+#undef CAST_VARBINARY_FROM_STRING_AND_BINARY\n+\n+#define GDV_FN_CAST_VARCHAR_VARBINARY_INTEGER(IN_TYPE, CAST_NAME, ARROW_TYPE)     \\\n+  GANDIVA_EXPORT                                                                  \\\n+  const char* gdv_fn_cast##CAST_NAME##_##IN_TYPE##_int64(                         \\\n+      int64_t context, gdv_##IN_TYPE value, int64_t len, int32_t * out_len) {     \\\n+    if (len < 0) {                                                                \\\n+      gdv_fn_context_set_error_msg(context, \"Buffer length can not be negative\"); \\\n+      *out_len = 0;                                                               \\\n+      return \"\";                                                                  \\\n+    }                                                                             \\\n+    if (len == 0) {                                                               \\\n+      *out_len = 0;                                                               \\\n+      return \"\";                                                                  \\\n+    }                                                                             \\\n+    arrow::internal::StringFormatter<arrow::ARROW_TYPE> formatter;                \\\n+    char* ret = reinterpret_cast<char*>(                                          \\\n+        gdv_fn_context_arena_malloc(context, static_cast<int32_t>(len)));         \\\n+    if (ret == nullptr) {                                                         \\\n+      gdv_fn_context_set_error_msg(context, \"Could not allocate memory\");         \\\n+      *out_len = 0;                                                               \\\n+      return \"\";                                                                  \\\n+    }                                                                             \\\n+    arrow::Status status = formatter(value, [&](arrow::util::string_view v) {     \\\n+      int64_t size = static_cast<int64_t>(v.size());                              \\\n+      *out_len = static_cast<int32_t>(len < size ? len : size);                   \\\n+      memcpy(ret, v.data(), *out_len);                                            \\\n+      return arrow::Status::OK();                                                 \\\n+    });                                                                           \\\n+    if (!status.ok()) {                                                           \\\n+      std::string err = \"Could not cast \" + std::to_string(value) + \" to string\"; \\\n+      gdv_fn_context_set_error_msg(context, err.c_str());                         \\\n+      *out_len = 0;                                                               \\\n+      return \"\";                                                                  \\\n+    }                                                                             \\\n+    return ret;                                                                   \\\n   }\n \n-GDV_FN_CAST_VARCHAR_INTEGER(int32, Int32Type)\n-GDV_FN_CAST_VARCHAR_INTEGER(int64, Int64Type)\n-GDV_FN_CAST_VARCHAR_REAL(float32, FloatType)\n-GDV_FN_CAST_VARCHAR_REAL(float64, DoubleType)\n+#define GDV_FN_CAST_VARCHAR_VARBINARY_REAL(IN_TYPE, CAST_NAME, ARROW_TYPE)        \\\n+  GANDIVA_EXPORT                                                                  \\\n+  const char* gdv_fn_cast##CAST_NAME##_##IN_TYPE##_int64(                         \\\n+      int64_t context, gdv_##IN_TYPE value, int64_t len, int32_t * out_len) {     \\\n+    if (len < 0) {                                                                \\\n+      gdv_fn_context_set_error_msg(context, \"Buffer length can not be negative\"); \\\n+      *out_len = 0;                                                               \\\n+      return \"\";                                                                  \\\n+    }                                                                             \\\n+    if (len == 0) {                                                               \\\n+      *out_len = 0;                                                               \\\n+      return \"\";                                                                  \\\n+    }                                                                             \\\n+    gandiva::GdvStringFormatter<arrow::ARROW_TYPE> formatter;                     \\\n+    char* ret = reinterpret_cast<char*>(                                          \\\n+        gdv_fn_context_arena_malloc(context, static_cast<int32_t>(len)));         \\\n+    if (ret == nullptr) {                                                         \\\n+      gdv_fn_context_set_error_msg(context, \"Could not allocate memory\");         \\\n+      *out_len = 0;                                                               \\\n+      return \"\";                                                                  \\\n+    }                                                                             \\\n+    arrow::Status status = formatter(value, [&](arrow::util::string_view v) {     \\\n+      int64_t size = static_cast<int64_t>(v.size());                              \\\n+      *out_len = static_cast<int32_t>(len < size ? len : size);                   \\\n+      memcpy(ret, v.data(), *out_len);                                            \\\n+      return arrow::Status::OK();                                                 \\\n+    });                                                                           \\\n+    if (!status.ok()) {                                                           \\\n+      std::string err = \"Could not cast \" + std::to_string(value) + \" to string\"; \\\n+      gdv_fn_context_set_error_msg(context, err.c_str());                         \\\n+      *out_len = 0;                                                               \\\n+      return \"\";                                                                  \\\n+    }                                                                             \\\n+    return ret;                                                                   \\\n+  }\n \n-#undef GDV_FN_CAST_VARCHAR_INTEGER\n-#undef GDV_FN_CAST_VARCHAR_REAL\n+GDV_FN_CAST_VARCHAR_VARBINARY_INTEGER(int32, VARCHAR, Int32Type)\n\nReview comment:\n       Solved\n\n##########\nFile path: cpp/src/gandiva/function_registry_string.cc\n##########\n@@ -236,6 +236,30 @@ std::vector<NativeFunction> GetStringFunctionRegistry() {\n       NativeFunction(\"binary_string\", {}, DataTypeVector{utf8()}, binary(),\n                      kResultNullIfNull, \"binary_string\", NativeFunction::kNeedsContext),\n \n+      NativeFunction(\"castVARBINARY\", {}, DataTypeVector{binary(), int64()}, binary(),\n+                     kResultNullIfNull, \"gdv_fn_castVARBINARY_binary\",\n\nReview comment:\n       Solved\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-12T11:38:34.994+0000",
                    "updated": "2021-05-12T11:38:34.994+0000",
                    "started": "2021-05-12T11:38:34.993+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "595224",
                    "issueId": "13372310"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13372310/worklog/595266",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "projjal commented on a change in pull request #10023:\nURL: https://github.com/apache/arrow/pull/10023#discussion_r630996233\n\n\n\n##########\nFile path: cpp/src/gandiva/precompiled/string_ops.cc\n##########\n@@ -533,89 +533,102 @@ const char* castVARCHAR_bool_int64(gdv_int64 context, gdv_boolean value,\n   return out;\n }\n \n-// Truncates the string to given length\n-FORCE_INLINE\n-const char* castVARCHAR_utf8_int64(gdv_int64 context, const char* data,\n-                                   gdv_int32 data_len, int64_t out_len,\n-                                   int32_t* out_length) {\n-  int32_t len = static_cast<int32_t>(out_len);\n-\n-  if (len < 0) {\n-    gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\");\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  if (len >= data_len || len == 0) {\n-    *out_length = data_len;\n-    return data;\n-  }\n-\n-  int32_t remaining = len;\n-  int32_t index = 0;\n-  bool is_multibyte = false;\n-  do {\n-    // In utf8, MSB of a single byte unicode char is always 0,\n-    // whereas for a multibyte character the MSB of each byte is 1.\n-    // So for a single byte char, a bitwise-and with x80 (10000000) will be 0\n-    // and it won't be 0 for bytes of a multibyte char\n-    char* data_ptr = const_cast<char*>(data);\n-\n-    // we advance byte by byte till the 8 byte boundary then advance 8 bytes at a time\n-    auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;\n-    num_bytes = (8 - num_bytes) & 0x07;\n-    while (num_bytes > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-      num_bytes--;\n-    }\n-    if (is_multibyte) break;\n-    while (remaining >= 8) {\n-      uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);\n-      if ((*ptr & 0x8080808080808080) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index += 8;\n-      remaining -= 8;\n-    }\n-    if (is_multibyte) break;\n-    if (remaining >= 4) {\n-      uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);\n-      if ((*ptr & 0x80808080) != 0) break;\n-      index += 4;\n-      remaining -= 4;\n-    }\n-    while (remaining > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-    }\n-    if (is_multibyte) break;\n-    // reached here; all are single byte characters\n-    *out_length = len;\n-    return data;\n-  } while (false);\n-\n-  // detected multibyte utf8 characters; slow path\n-  int32_t byte_pos = utf8_byte_pos(context, data + index, data_len - index, len - index);\n-  if (byte_pos < 0) {\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  *out_length = index + byte_pos;\n-  return data;\n-}\n+// Add functions for castVARBINARY for utf8 and binary\n+#define CAST_FROM_STRING_AND_BINARY(OUTPUT, TYPE_NAME)                                 \\\n+  FORCE_INLINE                                                                         \\\n+  const char* cast##OUTPUT##_##TYPE_NAME##_int64(gdv_int64 context, const char* data,  \\\n+                                                 gdv_int32 data_len, int64_t out_len,  \\\n+                                                 int32_t* out_length) {                \\\n+    int32_t len = static_cast<int32_t>(out_len);                                       \\\n+                                                                                       \\\n+    if (len < 0) {                                                                     \\\n+      gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\"); \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    if (len >= data_len || len == 0) {                                                 \\\n+      *out_length = data_len;                                                          \\\n+      return data;                                                                     \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    int32_t remaining = len;                                                           \\\n+    int32_t index = 0;                                                                 \\\n+    bool is_multibyte = false;                                                         \\\n+    do {                                                                               \\\n+      /* In utf8, MSB of a single byte unicode char is always 0, */                    \\\n+      /* whereas for a multibyte character the MSB of each byte is 1. */               \\\n+      /* So for a single byte char, a bitwise-and with x80 (10000000) will be 0 */     \\\n+      /* and it won't be 0 for bytes of a multibyte char */                            \\\n+      char* data_ptr = const_cast<char*>(data);                                        \\\n+                                                                                       \\\n+      /* advance byte by byte till the 8 byte boundary, advance 8 bytes at a time */   \\\n+      auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;                   \\\n+      num_bytes = (8 - num_bytes) & 0x07;                                              \\\n+      while (num_bytes > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+        num_bytes--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      while (remaining >= 8) {                                                         \\\n+        uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x8080808080808080) != 0) {                                        \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index += 8;                                                                    \\\n+        remaining -= 8;                                                                \\\n+      }                                                                                \\\n+      if (is_multibyte) {                                                              \\\n+        break;                                                                         \\\n+      }                                                                                \\\n+      if (remaining >= 4) {                                                            \\\n+        uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x80808080) != 0) break;                                           \\\n+        index += 4;                                                                    \\\n+        remaining -= 4;                                                                \\\n+      }                                                                                \\\n+      while (remaining > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) {                                                              \\\n+        break;                                                                         \\\n+      }                                                                                \\\n+      /* reached here; all are single byte characters */                               \\\n+      *out_length = len;                                                               \\\n+      return data;                                                                     \\\n+    } while (false);                                                                   \\\n+                                                                                       \\\n+    /* detected multibyte utf8 characters; slow path */                                \\\n+    int32_t byte_pos =                                                                 \\\n+        utf8_byte_pos(context, data + index, data_len - index, len - index);           \\\n+    if (byte_pos < 0) {                                                                \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    *out_length = index + byte_pos;                                                    \\\n+    return data;                                                                       \\\n+  }\n+\n+CAST_FROM_STRING_AND_BINARY(VARCHAR, utf8)\n\nReview comment:\n       Looks like you can't reuse the same function. varchar one takes character count which needs utf8 decoding\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-12T12:31:33.336+0000",
                    "updated": "2021-05-12T12:31:33.336+0000",
                    "started": "2021-05-12T12:31:33.336+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "595266",
                    "issueId": "13372310"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13372310/worklog/595304",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jpedroantunes commented on a change in pull request #10023:\nURL: https://github.com/apache/arrow/pull/10023#discussion_r631027169\n\n\n\n##########\nFile path: cpp/src/gandiva/precompiled/string_ops.cc\n##########\n@@ -533,89 +533,102 @@ const char* castVARCHAR_bool_int64(gdv_int64 context, gdv_boolean value,\n   return out;\n }\n \n-// Truncates the string to given length\n-FORCE_INLINE\n-const char* castVARCHAR_utf8_int64(gdv_int64 context, const char* data,\n-                                   gdv_int32 data_len, int64_t out_len,\n-                                   int32_t* out_length) {\n-  int32_t len = static_cast<int32_t>(out_len);\n-\n-  if (len < 0) {\n-    gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\");\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  if (len >= data_len || len == 0) {\n-    *out_length = data_len;\n-    return data;\n-  }\n-\n-  int32_t remaining = len;\n-  int32_t index = 0;\n-  bool is_multibyte = false;\n-  do {\n-    // In utf8, MSB of a single byte unicode char is always 0,\n-    // whereas for a multibyte character the MSB of each byte is 1.\n-    // So for a single byte char, a bitwise-and with x80 (10000000) will be 0\n-    // and it won't be 0 for bytes of a multibyte char\n-    char* data_ptr = const_cast<char*>(data);\n-\n-    // we advance byte by byte till the 8 byte boundary then advance 8 bytes at a time\n-    auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;\n-    num_bytes = (8 - num_bytes) & 0x07;\n-    while (num_bytes > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-      num_bytes--;\n-    }\n-    if (is_multibyte) break;\n-    while (remaining >= 8) {\n-      uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);\n-      if ((*ptr & 0x8080808080808080) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index += 8;\n-      remaining -= 8;\n-    }\n-    if (is_multibyte) break;\n-    if (remaining >= 4) {\n-      uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);\n-      if ((*ptr & 0x80808080) != 0) break;\n-      index += 4;\n-      remaining -= 4;\n-    }\n-    while (remaining > 0) {\n-      uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);\n-      if ((*ptr & 0x80) != 0) {\n-        is_multibyte = true;\n-        break;\n-      }\n-      index++;\n-      remaining--;\n-    }\n-    if (is_multibyte) break;\n-    // reached here; all are single byte characters\n-    *out_length = len;\n-    return data;\n-  } while (false);\n-\n-  // detected multibyte utf8 characters; slow path\n-  int32_t byte_pos = utf8_byte_pos(context, data + index, data_len - index, len - index);\n-  if (byte_pos < 0) {\n-    *out_length = 0;\n-    return \"\";\n-  }\n-\n-  *out_length = index + byte_pos;\n-  return data;\n-}\n+// Add functions for castVARBINARY for utf8 and binary\n+#define CAST_FROM_STRING_AND_BINARY(OUTPUT, TYPE_NAME)                                 \\\n+  FORCE_INLINE                                                                         \\\n+  const char* cast##OUTPUT##_##TYPE_NAME##_int64(gdv_int64 context, const char* data,  \\\n+                                                 gdv_int32 data_len, int64_t out_len,  \\\n+                                                 int32_t* out_length) {                \\\n+    int32_t len = static_cast<int32_t>(out_len);                                       \\\n+                                                                                       \\\n+    if (len < 0) {                                                                     \\\n+      gdv_fn_context_set_error_msg(context, \"Output buffer length can't be negative\"); \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    if (len >= data_len || len == 0) {                                                 \\\n+      *out_length = data_len;                                                          \\\n+      return data;                                                                     \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    int32_t remaining = len;                                                           \\\n+    int32_t index = 0;                                                                 \\\n+    bool is_multibyte = false;                                                         \\\n+    do {                                                                               \\\n+      /* In utf8, MSB of a single byte unicode char is always 0, */                    \\\n+      /* whereas for a multibyte character the MSB of each byte is 1. */               \\\n+      /* So for a single byte char, a bitwise-and with x80 (10000000) will be 0 */     \\\n+      /* and it won't be 0 for bytes of a multibyte char */                            \\\n+      char* data_ptr = const_cast<char*>(data);                                        \\\n+                                                                                       \\\n+      /* advance byte by byte till the 8 byte boundary, advance 8 bytes at a time */   \\\n+      auto num_bytes = reinterpret_cast<uintptr_t>(data_ptr) & 0x07;                   \\\n+      num_bytes = (8 - num_bytes) & 0x07;                                              \\\n+      while (num_bytes > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+        num_bytes--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) break;                                                         \\\n+      while (remaining >= 8) {                                                         \\\n+        uint64_t* ptr = reinterpret_cast<uint64_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x8080808080808080) != 0) {                                        \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index += 8;                                                                    \\\n+        remaining -= 8;                                                                \\\n+      }                                                                                \\\n+      if (is_multibyte) {                                                              \\\n+        break;                                                                         \\\n+      }                                                                                \\\n+      if (remaining >= 4) {                                                            \\\n+        uint32_t* ptr = reinterpret_cast<uint32_t*>(data_ptr + index);                 \\\n+        if ((*ptr & 0x80808080) != 0) break;                                           \\\n+        index += 4;                                                                    \\\n+        remaining -= 4;                                                                \\\n+      }                                                                                \\\n+      while (remaining > 0) {                                                          \\\n+        uint8_t* ptr = reinterpret_cast<uint8_t*>(data_ptr + index);                   \\\n+        if ((*ptr & 0x80) != 0) {                                                      \\\n+          is_multibyte = true;                                                         \\\n+          break;                                                                       \\\n+        }                                                                              \\\n+        index++;                                                                       \\\n+        remaining--;                                                                   \\\n+      }                                                                                \\\n+      if (is_multibyte) {                                                              \\\n+        break;                                                                         \\\n+      }                                                                                \\\n+      /* reached here; all are single byte characters */                               \\\n+      *out_length = len;                                                               \\\n+      return data;                                                                     \\\n+    } while (false);                                                                   \\\n+                                                                                       \\\n+    /* detected multibyte utf8 characters; slow path */                                \\\n+    int32_t byte_pos =                                                                 \\\n+        utf8_byte_pos(context, data + index, data_len - index, len - index);           \\\n+    if (byte_pos < 0) {                                                                \\\n+      *out_length = 0;                                                                 \\\n+      return \"\";                                                                       \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    *out_length = index + byte_pos;                                                    \\\n+    return data;                                                                       \\\n+  }\n+\n+CAST_FROM_STRING_AND_BINARY(VARCHAR, utf8)\n\nReview comment:\n       Ok! Used the implementation I did before\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-12T13:12:12.531+0000",
                    "updated": "2021-05-12T13:12:12.531+0000",
                    "started": "2021-05-12T13:12:12.531+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "595304",
                    "issueId": "13372310"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13372310/worklog/607755",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "praveenbingo commented on pull request #10023:\nURL: https://github.com/apache/arrow/pull/10023#issuecomment-855806266\n\n\n   @projjal can you please check the errors on ths one.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-07T10:23:26.707+0000",
                    "updated": "2021-06-07T10:23:26.707+0000",
                    "started": "2021-06-07T10:23:26.707+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "607755",
                    "issueId": "13372310"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13372310/worklog/607775",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "projjal commented on pull request #10023:\nURL: https://github.com/apache/arrow/pull/10023#issuecomment-855819631\n\n\n   @jpedroantunes this needs a rebase\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-07T10:45:36.673+0000",
                    "updated": "2021-06-07T10:45:36.673+0000",
                    "started": "2021-06-07T10:45:36.673+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "607775",
                    "issueId": "13372310"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13372310/worklog/615400",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "praveenbingo closed pull request #10023:\nURL: https://github.com/apache/arrow/pull/10023\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-27T15:26:55.042+0000",
                    "updated": "2021-06-27T15:26:55.042+0000",
                    "started": "2021-06-27T15:26:55.042+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "615400",
                    "issueId": "13372310"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 7200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@53108080[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4c2df492[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1d408791[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@3e6a79cf[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@13aec87[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@53bd3bf3[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4a58521a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@2791fe9f[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7119703e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@4b41af4d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4301fcbd[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@6bcc9744[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 7200,
        "customfield_12312520": null,
        "customfield_12312521": "Sun Jun 27 15:26:54 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-06-27T15:26:54.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12378/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-04-14T13:15:05.000+0000",
        "updated": "2021-06-27T15:26:56.000+0000",
        "timeoriginalestimate": null,
        "description": "Implement the following functions:\r\n * castVARBINARY(varchar, len)\r\n * castVARBINARY(varbinary, len)\r\n * castVARBINARY(float/double/int/bigint, bigint len)",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 7200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Gandiva] Implement castVARBINARY functions",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13372310/comment/17370244",
                    "id": "17370244",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=praveenbingo",
                        "name": "praveenbingo",
                        "key": "praveenbingo",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Praveen Kumar",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Issue resolved by pull request 10023\n[https://github.com/apache/arrow/pull/10023]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=praveenbingo",
                        "name": "praveenbingo",
                        "key": "praveenbingo",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Praveen Kumar",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2021-06-27T15:26:54.455+0000",
                    "updated": "2021-06-27T15:26:54.455+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0pzco:",
        "customfield_12314139": null
    }
}